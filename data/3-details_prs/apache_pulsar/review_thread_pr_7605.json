{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUzMzUyNzU1", "number": 7605, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNDoxOTozNlrOEQpUfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOTo1NTo1NlrOEqPtGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1ODg5NjYwOnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/lookup/TopicLookupBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNDoxOTozNlrOG06RCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwODoyNzozNVrOG2nOAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEzMzc3MA==", "bodyText": "If redirect the partitioned topic lookup requests, the target broker will handle the partitioned topic lookup request right? So this may lead to redirect back again, the request can't complete.", "url": "https://github.com/apache/pulsar/pull/7605#discussion_r458133770", "createdAt": "2020-07-21T14:19:36Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/lookup/TopicLookupBase.java", "diffHunk": "@@ -127,6 +131,113 @@ protected void internalLookupTopicAsync(TopicName topicName, boolean authoritati\n         });\n     }\n \n+    protected void internalLookupPartitionedTopicAsync(TopicName topicName, boolean authoritative, AsyncResponse asyncResponse) {\n+        if (!pulsar().getBrokerService().getLookupRequestSemaphore().tryAcquire()) {\n+            log.warn(\"No broker was found available for topic {}\", topicName);\n+            asyncResponse.resume(new WebApplicationException(Response.Status.SERVICE_UNAVAILABLE));\n+            return;\n+        }\n+\n+        try {\n+            validateClusterOwnership(topicName.getCluster());\n+            checkConnect(topicName);\n+            validateGlobalNamespaceOwnership(topicName.getNamespaceObject());\n+        } catch (WebApplicationException we) {\n+            // Validation checks failed\n+            log.error(\"Validation check failed: {}\", we.getMessage());\n+            completeLookupResponseExceptionally(asyncResponse, we);\n+            return;\n+        } catch (Throwable t) {\n+            // Validation checks failed with unknown error\n+            log.error(\"Validation check failed: {}\", t.getMessage(), t);\n+            completeLookupResponseExceptionally(asyncResponse, new RestException(t));\n+            return;\n+        }\n+\n+        pulsar().getBrokerService().fetchPartitionedTopicMetadataAsync(topicName).whenComplete(\n+                (metadata, t) -> {\n+                    if (t != null) {\n+                        log.error(\" Can't find partitioned metadata for {}\", topicName);\n+                        completeLookupResponseExceptionally(asyncResponse, new RestException(t));\n+                        return ;\n+                    }\n+\n+                    String domain = topicName.getDomain().value();\n+                    NamespaceName namespace = topicName.getNamespaceObject();\n+                    String topicLocalName = topicName.getLocalName();\n+                    LookupOptions lookupOptions =  LookupOptions.builder().authoritative(authoritative).loadTopicsInBundle(false).build();\n+\n+                    List<CompletableFuture<Optional<LookupResult>>> futureList = new ArrayList<>();\n+                    if (metadata != null && metadata.partitions > 1) {\n+                        for (int i = 0 ; i < metadata.partitions; i ++) {\n+                            TopicName partitionedTopicName = TopicName.get(domain, namespace, topicLocalName + \"-partition-\" + i);\n+                            futureList.add(pulsar().getNamespaceService().getBrokerServiceUrlAsync(partitionedTopicName, lookupOptions));\n+                        }\n+                    } else {\n+                        futureList.add(pulsar().getNamespaceService().getBrokerServiceUrlAsync(topicName, lookupOptions));\n+                    }\n+\n+                    FutureUtil.waitForAll(futureList).whenComplete(\n+                            (ignore, te) -> {\n+                                if (te != null) {\n+                                    log.warn(\"Failed to lookup broker for topic {}: {}\", topicName, te.getMessage(), te);\n+                                    completeLookupResponseExceptionally(asyncResponse, te);\n+                                    return;\n+                                }\n+                                List<LookupData> lookupDataList = new ArrayList<>();\n+                                for (CompletableFuture<Optional<LookupResult>> partitionFuture : futureList) {\n+                                    partitionFuture.thenAccept(optionalResult -> {\n+                                        if (optionalResult == null || !optionalResult.isPresent()) {\n+                                            log.warn(\"No broker was found available for topic {}\", topicName);\n+                                            completeLookupResponseExceptionally(asyncResponse,\n+                                                    new WebApplicationException(Response.Status.SERVICE_UNAVAILABLE));\n+                                            return;\n+                                        }\n+\n+                                        LookupResult result = optionalResult.get();\n+                                        // We have found either a broker that owns the topic, or a broker to which we should redirect the client to\n+                                        if (result.isRedirect()) {\n+                                            boolean newAuthoritative = result.isAuthoritativeRedirect();\n+                                            URI redirect;\n+                                            try {\n+                                                String redirectUrl = isRequestHttps() ? result.getLookupData().getHttpUrlTls()\n+                                                        : result.getLookupData().getHttpUrl();\n+                                                checkNotNull(redirectUrl, \"Redirected cluster's service url is not configured\");\n+                                                String lookupPath = topicName.isV2() ? LOOKUP_PATH_V2 : LOOKUP_PATH_V1;\n+                                                redirect = new URI(String.format(\"%s%s%s?authoritative=%s\", redirectUrl, lookupPath,\n+                                                        topicName.getLookupName(), newAuthoritative));\n+                                            } catch (URISyntaxException | NullPointerException e) {\n+                                                log.error(\"Error in preparing redirect url for {}: {}\", topicName, e.getMessage(), e);\n+                                                completeLookupResponseExceptionally(asyncResponse, e);\n+                                                return;\n+                                            }\n+                                            if (log.isDebugEnabled()) {\n+                                                log.debug(\"Redirect lookup for topic {} to {}\", topicName, redirect);\n+                                            }\n+                                            completeLookupResponseExceptionally(asyncResponse,\n+                                                    new WebApplicationException(Response.temporaryRedirect(redirect).build()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c212af8cf5e9648a81cfb6f1a4295b281729f6c7"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkxODg0OA==", "bodyText": "I'll check this later", "url": "https://github.com/apache/pulsar/pull/7605#discussion_r459918848", "createdAt": "2020-07-24T08:27:35Z", "author": {"login": "aloyszhang"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/lookup/TopicLookupBase.java", "diffHunk": "@@ -127,6 +131,113 @@ protected void internalLookupTopicAsync(TopicName topicName, boolean authoritati\n         });\n     }\n \n+    protected void internalLookupPartitionedTopicAsync(TopicName topicName, boolean authoritative, AsyncResponse asyncResponse) {\n+        if (!pulsar().getBrokerService().getLookupRequestSemaphore().tryAcquire()) {\n+            log.warn(\"No broker was found available for topic {}\", topicName);\n+            asyncResponse.resume(new WebApplicationException(Response.Status.SERVICE_UNAVAILABLE));\n+            return;\n+        }\n+\n+        try {\n+            validateClusterOwnership(topicName.getCluster());\n+            checkConnect(topicName);\n+            validateGlobalNamespaceOwnership(topicName.getNamespaceObject());\n+        } catch (WebApplicationException we) {\n+            // Validation checks failed\n+            log.error(\"Validation check failed: {}\", we.getMessage());\n+            completeLookupResponseExceptionally(asyncResponse, we);\n+            return;\n+        } catch (Throwable t) {\n+            // Validation checks failed with unknown error\n+            log.error(\"Validation check failed: {}\", t.getMessage(), t);\n+            completeLookupResponseExceptionally(asyncResponse, new RestException(t));\n+            return;\n+        }\n+\n+        pulsar().getBrokerService().fetchPartitionedTopicMetadataAsync(topicName).whenComplete(\n+                (metadata, t) -> {\n+                    if (t != null) {\n+                        log.error(\" Can't find partitioned metadata for {}\", topicName);\n+                        completeLookupResponseExceptionally(asyncResponse, new RestException(t));\n+                        return ;\n+                    }\n+\n+                    String domain = topicName.getDomain().value();\n+                    NamespaceName namespace = topicName.getNamespaceObject();\n+                    String topicLocalName = topicName.getLocalName();\n+                    LookupOptions lookupOptions =  LookupOptions.builder().authoritative(authoritative).loadTopicsInBundle(false).build();\n+\n+                    List<CompletableFuture<Optional<LookupResult>>> futureList = new ArrayList<>();\n+                    if (metadata != null && metadata.partitions > 1) {\n+                        for (int i = 0 ; i < metadata.partitions; i ++) {\n+                            TopicName partitionedTopicName = TopicName.get(domain, namespace, topicLocalName + \"-partition-\" + i);\n+                            futureList.add(pulsar().getNamespaceService().getBrokerServiceUrlAsync(partitionedTopicName, lookupOptions));\n+                        }\n+                    } else {\n+                        futureList.add(pulsar().getNamespaceService().getBrokerServiceUrlAsync(topicName, lookupOptions));\n+                    }\n+\n+                    FutureUtil.waitForAll(futureList).whenComplete(\n+                            (ignore, te) -> {\n+                                if (te != null) {\n+                                    log.warn(\"Failed to lookup broker for topic {}: {}\", topicName, te.getMessage(), te);\n+                                    completeLookupResponseExceptionally(asyncResponse, te);\n+                                    return;\n+                                }\n+                                List<LookupData> lookupDataList = new ArrayList<>();\n+                                for (CompletableFuture<Optional<LookupResult>> partitionFuture : futureList) {\n+                                    partitionFuture.thenAccept(optionalResult -> {\n+                                        if (optionalResult == null || !optionalResult.isPresent()) {\n+                                            log.warn(\"No broker was found available for topic {}\", topicName);\n+                                            completeLookupResponseExceptionally(asyncResponse,\n+                                                    new WebApplicationException(Response.Status.SERVICE_UNAVAILABLE));\n+                                            return;\n+                                        }\n+\n+                                        LookupResult result = optionalResult.get();\n+                                        // We have found either a broker that owns the topic, or a broker to which we should redirect the client to\n+                                        if (result.isRedirect()) {\n+                                            boolean newAuthoritative = result.isAuthoritativeRedirect();\n+                                            URI redirect;\n+                                            try {\n+                                                String redirectUrl = isRequestHttps() ? result.getLookupData().getHttpUrlTls()\n+                                                        : result.getLookupData().getHttpUrl();\n+                                                checkNotNull(redirectUrl, \"Redirected cluster's service url is not configured\");\n+                                                String lookupPath = topicName.isV2() ? LOOKUP_PATH_V2 : LOOKUP_PATH_V1;\n+                                                redirect = new URI(String.format(\"%s%s%s?authoritative=%s\", redirectUrl, lookupPath,\n+                                                        topicName.getLookupName(), newAuthoritative));\n+                                            } catch (URISyntaxException | NullPointerException e) {\n+                                                log.error(\"Error in preparing redirect url for {}: {}\", topicName, e.getMessage(), e);\n+                                                completeLookupResponseExceptionally(asyncResponse, e);\n+                                                return;\n+                                            }\n+                                            if (log.isDebugEnabled()) {\n+                                                log.debug(\"Redirect lookup for topic {} to {}\", topicName, redirect);\n+                                            }\n+                                            completeLookupResponseExceptionally(asyncResponse,\n+                                                    new WebApplicationException(Response.temporaryRedirect(redirect).build()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEzMzc3MA=="}, "originalCommit": {"oid": "c212af8cf5e9648a81cfb6f1a4295b281729f6c7"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTUxNDkyOnYy", "diffSide": "RIGHT", "path": "pulsar-client-admin/src/main/java/org/apache/pulsar/client/admin/Lookup.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQwODozMTozMFrOHcF-cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwMTowNzoyNlrOHcLbrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIyMDA4Mw==", "bodyText": "This method should return a CompletableFuture as the method above", "url": "https://github.com/apache/pulsar/pull/7605#discussion_r499220083", "createdAt": "2020-10-04T08:31:30Z", "author": {"login": "eolivelli"}, "path": "pulsar-client-admin/src/main/java/org/apache/pulsar/client/admin/Lookup.java", "diffHunk": "@@ -41,6 +42,14 @@\n      */\n     CompletableFuture<String> lookupTopicAsync(String topic);\n \n+    /**\n+     * Lookup a partitioned topic.\n+     *\n+     * @param topic\n+     * @return the broker URL that serves the topic\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e714d9decb6acdf3938848256e536cfc0d79c6d6"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzMjAyMg==", "bodyText": "If a method is async, it should return a  CompletableFuture.\nBut Lookup#llookupPartitionedTopic is not a async method. It just invokes Lookup#lookupTopicAsync internal.", "url": "https://github.com/apache/pulsar/pull/7605#discussion_r499232022", "createdAt": "2020-10-04T10:43:56Z", "author": {"login": "aloyszhang"}, "path": "pulsar-client-admin/src/main/java/org/apache/pulsar/client/admin/Lookup.java", "diffHunk": "@@ -41,6 +42,14 @@\n      */\n     CompletableFuture<String> lookupTopicAsync(String topic);\n \n+    /**\n+     * Lookup a partitioned topic.\n+     *\n+     * @param topic\n+     * @return the broker URL that serves the topic\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIyMDA4Mw=="}, "originalCommit": {"oid": "e714d9decb6acdf3938848256e536cfc0d79c6d6"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzNjM4Mg==", "bodyText": "I meant that we should provide an async method.\nWhy not?", "url": "https://github.com/apache/pulsar/pull/7605#discussion_r499236382", "createdAt": "2020-10-04T11:32:55Z", "author": {"login": "eolivelli"}, "path": "pulsar-client-admin/src/main/java/org/apache/pulsar/client/admin/Lookup.java", "diffHunk": "@@ -41,6 +42,14 @@\n      */\n     CompletableFuture<String> lookupTopicAsync(String topic);\n \n+    /**\n+     * Lookup a partitioned topic.\n+     *\n+     * @param topic\n+     * @return the broker URL that serves the topic\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIyMDA4Mw=="}, "originalCommit": {"oid": "e714d9decb6acdf3938848256e536cfc0d79c6d6"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIzOTEzOA==", "bodyText": "For the uniform of method name, we should add a aync method for lookupPartitionedTopic.\nBut other method without async  juset  invoke the relative async method.\ne.g.\ngetBundleRange just invoke  getBundleRangeAsync(topic).get(this.readTimeoutMs, TimeUnit.MILLISECONDS)\nBut, lookupPartitionedTopic internal invokes topics.getPartitionedTopicMetadataAsync(topic).get(this.readTimeoutMs, TimeUnit.MILLISECONDS) and\n lookupTopicAsync(partitionTopicName).get(readTimeoutMs, TimeUnit.MILLISECONDS).\nSo it's hard to  tell which is better.", "url": "https://github.com/apache/pulsar/pull/7605#discussion_r499239138", "createdAt": "2020-10-04T12:04:37Z", "author": {"login": "aloyszhang"}, "path": "pulsar-client-admin/src/main/java/org/apache/pulsar/client/admin/Lookup.java", "diffHunk": "@@ -41,6 +42,14 @@\n      */\n     CompletableFuture<String> lookupTopicAsync(String topic);\n \n+    /**\n+     * Lookup a partitioned topic.\n+     *\n+     * @param topic\n+     * @return the broker URL that serves the topic\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIyMDA4Mw=="}, "originalCommit": {"oid": "e714d9decb6acdf3938848256e536cfc0d79c6d6"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0Nzk1Mw==", "bodyText": "Personally I would add lookupPartitionedTopicAsync\nIf the user wants to block it can do it.\nIf we provide only the blocking method it is not possible to turn it into non-blocking", "url": "https://github.com/apache/pulsar/pull/7605#discussion_r499247953", "createdAt": "2020-10-04T13:39:15Z", "author": {"login": "eolivelli"}, "path": "pulsar-client-admin/src/main/java/org/apache/pulsar/client/admin/Lookup.java", "diffHunk": "@@ -41,6 +42,14 @@\n      */\n     CompletableFuture<String> lookupTopicAsync(String topic);\n \n+    /**\n+     * Lookup a partitioned topic.\n+     *\n+     * @param topic\n+     * @return the broker URL that serves the topic\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIyMDA4Mw=="}, "originalCommit": {"oid": "e714d9decb6acdf3938848256e536cfc0d79c6d6"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI0Nzk2OQ==", "bodyText": "Personally I would add lookupPartitionedTopicAsync\nIf the user wants to block it can do it.\nIf we provide only the blocking method it is not possible to turn it into non-blocking", "url": "https://github.com/apache/pulsar/pull/7605#discussion_r499247969", "createdAt": "2020-10-04T13:39:19Z", "author": {"login": "eolivelli"}, "path": "pulsar-client-admin/src/main/java/org/apache/pulsar/client/admin/Lookup.java", "diffHunk": "@@ -41,6 +42,14 @@\n      */\n     CompletableFuture<String> lookupTopicAsync(String topic);\n \n+    /**\n+     * Lookup a partitioned topic.\n+     *\n+     * @param topic\n+     * @return the broker URL that serves the topic\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIyMDA4Mw=="}, "originalCommit": {"oid": "e714d9decb6acdf3938848256e536cfc0d79c6d6"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTMwOTQ4NQ==", "bodyText": "Thanks for your suggenstions @eolivelli .\nI have already add a async method", "url": "https://github.com/apache/pulsar/pull/7605#discussion_r499309485", "createdAt": "2020-10-05T01:07:26Z", "author": {"login": "aloyszhang"}, "path": "pulsar-client-admin/src/main/java/org/apache/pulsar/client/admin/Lookup.java", "diffHunk": "@@ -41,6 +42,14 @@\n      */\n     CompletableFuture<String> lookupTopicAsync(String topic);\n \n+    /**\n+     * Lookup a partitioned topic.\n+     *\n+     * @param topic\n+     * @return the broker URL that serves the topic\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIyMDA4Mw=="}, "originalCommit": {"oid": "e714d9decb6acdf3938848256e536cfc0d79c6d6"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNTUxNTAwOnYy", "diffSide": "RIGHT", "path": "pulsar-client-admin/src/main/java/org/apache/pulsar/client/admin/Lookup.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQwODozMTo0M1rOHcF-fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQwODozMTo0M1rOHcF-fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTIyMDA5NA==", "bodyText": "This method should return a CompletableFuture as the method above", "url": "https://github.com/apache/pulsar/pull/7605#discussion_r499220094", "createdAt": "2020-10-04T08:31:43Z", "author": {"login": "eolivelli"}, "path": "pulsar-client-admin/src/main/java/org/apache/pulsar/client/admin/Lookup.java", "diffHunk": "@@ -41,6 +42,14 @@\n      */\n     CompletableFuture<String> lookupTopicAsync(String topic);\n \n+    /**\n+     * Lookup a partitioned topic.\n+     *\n+     * @param topic\n+     * @return the broker URL that serves the topic\n+     */\n+    Map<String, String> lookupPartitionedTopic(String topic) throws PulsarAdminException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e714d9decb6acdf3938848256e536cfc0d79c6d6"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzMyOTU0OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/lookup/TopicLookupBase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQwOTo1NTo1NlrOHcV0fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMDowMjoxOFrOHcWDpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ3OTY3OA==", "bodyText": "is this line needed ?", "url": "https://github.com/apache/pulsar/pull/7605#discussion_r499479678", "createdAt": "2020-10-05T09:55:56Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/lookup/TopicLookupBase.java", "diffHunk": "@@ -26,6 +26,7 @@\n \n import java.net.URI;\n import java.net.URISyntaxException;\n+import java.util.List;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa544431042700c4dd3c5552c1b368affdd0b9ff"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ4MzU1Nw==", "bodyText": "removed", "url": "https://github.com/apache/pulsar/pull/7605#discussion_r499483557", "createdAt": "2020-10-05T10:02:18Z", "author": {"login": "aloyszhang"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/lookup/TopicLookupBase.java", "diffHunk": "@@ -26,6 +26,7 @@\n \n import java.net.URI;\n import java.net.URISyntaxException;\n+import java.util.List;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTQ3OTY3OA=="}, "originalCommit": {"oid": "fa544431042700c4dd3c5552c1b368affdd0b9ff"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2308, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}