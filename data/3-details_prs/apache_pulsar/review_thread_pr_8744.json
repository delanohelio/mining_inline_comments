{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5NDMwMDA4", "number": 8744, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMjo0NzoxMVrOE_5tWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMjo0NzoxMVrOE_5tWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NDQxMjQwOnYy", "diffSide": "RIGHT", "path": "pulsar-package-management/bookkeeper-storage/src/main/java/org/apache/pulsar/packages/management/storage/bookkeeper/BookKeeperPackagesStorage.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMjo0NzoxMVrOH93CBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwMjo1NDo1OFrOH93MgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDYyNjgyMA==", "bodyText": "We should also close the DistributedLogManager?", "url": "https://github.com/apache/pulsar/pull/8744#discussion_r534626820", "createdAt": "2020-12-03T02:47:11Z", "author": {"login": "codelipenghui"}, "path": "pulsar-package-management/bookkeeper-storage/src/main/java/org/apache/pulsar/packages/management/storage/bookkeeper/BookKeeperPackagesStorage.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.packages.management.storage.bookkeeper;\n+\n+import com.google.common.base.Strings;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.distributedlog.DistributedLogConfiguration;\n+import org.apache.distributedlog.DistributedLogConstants;\n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.namespace.Namespace;\n+import org.apache.distributedlog.api.namespace.NamespaceBuilder;\n+import org.apache.distributedlog.exceptions.ZKException;\n+import org.apache.distributedlog.impl.metadata.BKDLConfig;\n+import org.apache.distributedlog.metadata.DLMetadata;\n+import org.apache.distributedlog.namespace.NamespaceDriver;\n+import org.apache.pulsar.packages.management.core.PackagesStorage;\n+import org.apache.pulsar.packages.management.core.PackagesStorageConfiguration;\n+import org.apache.zookeeper.KeeperException;\n+\n+\n+/**\n+ * Packages management storage implementation with bookkeeper.\n+ */\n+@Slf4j\n+public class BookKeeperPackagesStorage implements PackagesStorage {\n+\n+    private final static String NS_CLIENT_ID = \"packages-management\";\n+    final BookKeeperPackagesStorageConfiguration configuration;\n+    private Namespace namespace;\n+\n+    BookKeeperPackagesStorage(PackagesStorageConfiguration configuration) {\n+        this.configuration = new BookKeeperPackagesStorageConfiguration(configuration);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        DistributedLogConfiguration conf = new DistributedLogConfiguration()\n+            .setImmediateFlushEnabled(true)\n+            .setOutputBufferSize(0)\n+            .setWriteQuorumSize(configuration.getNumReplicas())\n+            .setEnsembleSize(configuration.getNumReplicas())\n+            .setAckQuorumSize(configuration.getNumReplicas())\n+            .setLockTimeout(DistributedLogConstants.LOCK_IMMEDIATE);\n+        if (!Strings.isNullOrEmpty(configuration.getBookkeeperClientAuthenticationPlugin())) {\n+            conf.setProperty(\"bkc.clientAuthProviderFactoryClass\",\n+                configuration.getBookkeeperClientAuthenticationPlugin());\n+            if (!Strings.isNullOrEmpty(configuration.getBookkeeperClientAuthenticationParametersName())) {\n+                conf.setProperty(\"bkc.\" + configuration.getBookkeeperClientAuthenticationParametersName(),\n+                    configuration.getBookkeeperClientAuthenticationParameters());\n+            }\n+        }\n+        try {\n+            this.namespace = NamespaceBuilder.newBuilder()\n+                .conf(conf).clientId(NS_CLIENT_ID).uri(initializeDlogNamespace()).build();\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Initialize distributed log for packages management service failed.\", e);\n+        }\n+        log.info(\"Packages management bookKeeper storage initialized successfully\");\n+    }\n+\n+    private URI initializeDlogNamespace() throws IOException {\n+        BKDLConfig bkdlConfig = new BKDLConfig(configuration.getZkServers(), configuration.getLedgersRootPath());\n+        DLMetadata dlMetadata = DLMetadata.create(bkdlConfig);\n+        URI dlogURI = URI.create(String.format(\"distributedlog://%s/pulsar/packages\", configuration.getZkServers()));\n+        try {\n+            dlMetadata.create(dlogURI);\n+        } catch (ZKException e) {\n+            if (e.getKeeperExceptionCode() == KeeperException.Code.NODEEXISTS) {\n+                return dlogURI;\n+            }\n+        }\n+        return dlogURI;\n+    }\n+\n+    private CompletableFuture<DistributedLogManager> openLogManagerAsync(String path) {\n+        CompletableFuture<DistributedLogManager> logFuture = new CompletableFuture<>();\n+        CompletableFuture.runAsync(() -> {\n+            try {\n+                logFuture.complete(namespace.openLog(path));\n+            } catch (IOException e) {\n+                logFuture.completeExceptionally(e);\n+            }\n+        });\n+        return logFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> writeAsync(String path, InputStream inputStream) {\n+        return openLogManagerAsync(path)\n+            .thenCompose(DLOutputStream::openWriterAsync)\n+            .thenCompose(dlOutputStream -> dlOutputStream.writeAsync(inputStream))\n+            .thenCompose(DLOutputStream::closeAsync);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> readAsync(String path, OutputStream outputStream) {\n+        return openLogManagerAsync(path)\n+            .thenCompose(DLInputStream::openReaderAsync)\n+            .thenCompose(dlInputStream -> dlInputStream.readAsync(outputStream))\n+            .thenCompose(DLInputStream::closeAsync);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> deleteAsync(String path) {\n+        return namespace.getNamespaceDriver().getLogMetadataStore().getLogLocation(path)\n+            .thenCompose(uri -> uri.map(value -> namespace.getNamespaceDriver()\n+                .getLogStreamMetadataStore(NamespaceDriver.Role.WRITER).deleteLog(value, path))\n+                .orElse(null));\n+    }\n+\n+\n+    @Override\n+    public CompletableFuture<List<String>> listAsync(String path) {\n+        return namespace.getNamespaceDriver().getLogMetadataStore().getLogs(path)\n+            .thenApply(logs -> {\n+                ArrayList<String> packages = new ArrayList<>();\n+                logs.forEachRemaining(packages::add);\n+                return packages;\n+            });\n+    }\n+\n+    @Override\n+    public CompletableFuture<Boolean> existAsync(String path) {\n+        CompletableFuture<Boolean> result = new CompletableFuture<>();\n+        namespace.getNamespaceDriver().getLogMetadataStore().getLogLocation(path)\n+            .whenComplete((uriOptional, throwable) -> {\n+                if (throwable != null) {\n+                    result.complete(false);\n+                    return;\n+                }\n+\n+                if (uriOptional.isPresent()) {\n+                    namespace.getNamespaceDriver()\n+                        .getLogStreamMetadataStore(NamespaceDriver.Role.WRITER)\n+                        .logExists(uriOptional.get(), path)\n+                        .whenComplete((ignore, e) -> {\n+                            if (e != null) {\n+                                result.complete(false);\n+                            } else {\n+                                result.complete(true);\n+                            }\n+                        });\n+                } else {\n+                    result.complete(false);\n+                }\n+            });\n+        return result;    }\n+\n+    @Override\n+    public CompletableFuture<Void> closeAsync() {\n+        return CompletableFuture.runAsync(() -> this.namespace.close());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96d5514e8e2e206df3c08b8b7cea4b2a98fc8095"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDYyOTUwNQ==", "bodyText": "It closed at here https://github.com/apache/pulsar/pull/8744/files#diff-eb374311109d385162c647fec67fb23820f28aa8fc11c58dbdff2c859a51639dR118", "url": "https://github.com/apache/pulsar/pull/8744#discussion_r534629505", "createdAt": "2020-12-03T02:54:58Z", "author": {"login": "zymap"}, "path": "pulsar-package-management/bookkeeper-storage/src/main/java/org/apache/pulsar/packages/management/storage/bookkeeper/BookKeeperPackagesStorage.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.packages.management.storage.bookkeeper;\n+\n+import com.google.common.base.Strings;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.distributedlog.DistributedLogConfiguration;\n+import org.apache.distributedlog.DistributedLogConstants;\n+import org.apache.distributedlog.api.DistributedLogManager;\n+import org.apache.distributedlog.api.namespace.Namespace;\n+import org.apache.distributedlog.api.namespace.NamespaceBuilder;\n+import org.apache.distributedlog.exceptions.ZKException;\n+import org.apache.distributedlog.impl.metadata.BKDLConfig;\n+import org.apache.distributedlog.metadata.DLMetadata;\n+import org.apache.distributedlog.namespace.NamespaceDriver;\n+import org.apache.pulsar.packages.management.core.PackagesStorage;\n+import org.apache.pulsar.packages.management.core.PackagesStorageConfiguration;\n+import org.apache.zookeeper.KeeperException;\n+\n+\n+/**\n+ * Packages management storage implementation with bookkeeper.\n+ */\n+@Slf4j\n+public class BookKeeperPackagesStorage implements PackagesStorage {\n+\n+    private final static String NS_CLIENT_ID = \"packages-management\";\n+    final BookKeeperPackagesStorageConfiguration configuration;\n+    private Namespace namespace;\n+\n+    BookKeeperPackagesStorage(PackagesStorageConfiguration configuration) {\n+        this.configuration = new BookKeeperPackagesStorageConfiguration(configuration);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        DistributedLogConfiguration conf = new DistributedLogConfiguration()\n+            .setImmediateFlushEnabled(true)\n+            .setOutputBufferSize(0)\n+            .setWriteQuorumSize(configuration.getNumReplicas())\n+            .setEnsembleSize(configuration.getNumReplicas())\n+            .setAckQuorumSize(configuration.getNumReplicas())\n+            .setLockTimeout(DistributedLogConstants.LOCK_IMMEDIATE);\n+        if (!Strings.isNullOrEmpty(configuration.getBookkeeperClientAuthenticationPlugin())) {\n+            conf.setProperty(\"bkc.clientAuthProviderFactoryClass\",\n+                configuration.getBookkeeperClientAuthenticationPlugin());\n+            if (!Strings.isNullOrEmpty(configuration.getBookkeeperClientAuthenticationParametersName())) {\n+                conf.setProperty(\"bkc.\" + configuration.getBookkeeperClientAuthenticationParametersName(),\n+                    configuration.getBookkeeperClientAuthenticationParameters());\n+            }\n+        }\n+        try {\n+            this.namespace = NamespaceBuilder.newBuilder()\n+                .conf(conf).clientId(NS_CLIENT_ID).uri(initializeDlogNamespace()).build();\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Initialize distributed log for packages management service failed.\", e);\n+        }\n+        log.info(\"Packages management bookKeeper storage initialized successfully\");\n+    }\n+\n+    private URI initializeDlogNamespace() throws IOException {\n+        BKDLConfig bkdlConfig = new BKDLConfig(configuration.getZkServers(), configuration.getLedgersRootPath());\n+        DLMetadata dlMetadata = DLMetadata.create(bkdlConfig);\n+        URI dlogURI = URI.create(String.format(\"distributedlog://%s/pulsar/packages\", configuration.getZkServers()));\n+        try {\n+            dlMetadata.create(dlogURI);\n+        } catch (ZKException e) {\n+            if (e.getKeeperExceptionCode() == KeeperException.Code.NODEEXISTS) {\n+                return dlogURI;\n+            }\n+        }\n+        return dlogURI;\n+    }\n+\n+    private CompletableFuture<DistributedLogManager> openLogManagerAsync(String path) {\n+        CompletableFuture<DistributedLogManager> logFuture = new CompletableFuture<>();\n+        CompletableFuture.runAsync(() -> {\n+            try {\n+                logFuture.complete(namespace.openLog(path));\n+            } catch (IOException e) {\n+                logFuture.completeExceptionally(e);\n+            }\n+        });\n+        return logFuture;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> writeAsync(String path, InputStream inputStream) {\n+        return openLogManagerAsync(path)\n+            .thenCompose(DLOutputStream::openWriterAsync)\n+            .thenCompose(dlOutputStream -> dlOutputStream.writeAsync(inputStream))\n+            .thenCompose(DLOutputStream::closeAsync);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> readAsync(String path, OutputStream outputStream) {\n+        return openLogManagerAsync(path)\n+            .thenCompose(DLInputStream::openReaderAsync)\n+            .thenCompose(dlInputStream -> dlInputStream.readAsync(outputStream))\n+            .thenCompose(DLInputStream::closeAsync);\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> deleteAsync(String path) {\n+        return namespace.getNamespaceDriver().getLogMetadataStore().getLogLocation(path)\n+            .thenCompose(uri -> uri.map(value -> namespace.getNamespaceDriver()\n+                .getLogStreamMetadataStore(NamespaceDriver.Role.WRITER).deleteLog(value, path))\n+                .orElse(null));\n+    }\n+\n+\n+    @Override\n+    public CompletableFuture<List<String>> listAsync(String path) {\n+        return namespace.getNamespaceDriver().getLogMetadataStore().getLogs(path)\n+            .thenApply(logs -> {\n+                ArrayList<String> packages = new ArrayList<>();\n+                logs.forEachRemaining(packages::add);\n+                return packages;\n+            });\n+    }\n+\n+    @Override\n+    public CompletableFuture<Boolean> existAsync(String path) {\n+        CompletableFuture<Boolean> result = new CompletableFuture<>();\n+        namespace.getNamespaceDriver().getLogMetadataStore().getLogLocation(path)\n+            .whenComplete((uriOptional, throwable) -> {\n+                if (throwable != null) {\n+                    result.complete(false);\n+                    return;\n+                }\n+\n+                if (uriOptional.isPresent()) {\n+                    namespace.getNamespaceDriver()\n+                        .getLogStreamMetadataStore(NamespaceDriver.Role.WRITER)\n+                        .logExists(uriOptional.get(), path)\n+                        .whenComplete((ignore, e) -> {\n+                            if (e != null) {\n+                                result.complete(false);\n+                            } else {\n+                                result.complete(true);\n+                            }\n+                        });\n+                } else {\n+                    result.complete(false);\n+                }\n+            });\n+        return result;    }\n+\n+    @Override\n+    public CompletableFuture<Void> closeAsync() {\n+        return CompletableFuture.runAsync(() -> this.namespace.close());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDYyNjgyMA=="}, "originalCommit": {"oid": "96d5514e8e2e206df3c08b8b7cea4b2a98fc8095"}, "originalPosition": 174}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2745, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}