{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIwMjk2MTc0", "number": 8552, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMjo0NToxNFrOE4ptqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMjo0NToxNFrOE4ptqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3ODM5MTQ3OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/persistent/TopicDuplicationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMjo0NToxNFrOHys97Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMjo0NToxNFrOHys97Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjkyNzU5Nw==", "bodyText": "I have added awaitility dependency so that we can avoid use sleep in the test, for more details you can see #8557", "url": "https://github.com/apache/pulsar/pull/8552#discussion_r522927597", "createdAt": "2020-11-13T12:45:14Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/service/persistent/TopicDuplicationTest.java", "diffHunk": "@@ -92,6 +92,98 @@ public void testDuplicationApi() throws Exception {\n         assertNull(admin.topics().getDeduplicationEnabled(topicName));\n     }\n \n+    @Test(timeOut = 10000)\n+    public void testDuplicationSnapshotApi() throws Exception {\n+        final String topicName = testTopic + UUID.randomUUID().toString();\n+        admin.topics().createPartitionedTopic(topicName, 3);\n+        waitCacheInit(topicName);\n+        Integer interval = admin.topics().getDeduplicationSnapshotInterval(topicName);\n+        assertNull(interval);\n+\n+        admin.topics().setDeduplicationSnapshotInterval(topicName, 1024);\n+        for (int i = 0; i < 50; i++) {\n+            if (admin.topics().getDeduplicationSnapshotInterval(topicName) != null) {\n+                break;\n+            }\n+            Thread.sleep(100);\n+        }\n+        Assert.assertEquals(admin.topics().getDeduplicationSnapshotInterval(topicName).intValue(), 1024);\n+        admin.topics().removeDeduplicationSnapshotInterval(topicName);\n+        for (int i = 0; i < 50; i++) {\n+            if (admin.topics().getDeduplicationSnapshotInterval(topicName) == null) {\n+                break;\n+            }\n+            Thread.sleep(100);\n+        }\n+        assertNull(admin.topics().getDeduplicationSnapshotInterval(topicName));\n+    }\n+\n+    @Test(timeOut = 30000)\n+    private void testTopicPolicyTakeSnapshot() throws Exception {\n+        resetConfig();\n+        conf.setSystemTopicEnabled(true);\n+        conf.setTopicLevelPoliciesEnabled(true);\n+        conf.setBrokerDeduplicationEnabled(true);\n+        conf.setBrokerDeduplicationSnapshotFrequencyInSeconds(1);\n+        conf.setBrokerDeduplicationSnapshotIntervalSeconds(4);\n+        conf.setBrokerDeduplicationEntriesInterval(20000);\n+        super.internalCleanup();\n+        super.internalSetup();\n+        super.producerBaseSetup();\n+\n+        final String topicName = testTopic + UUID.randomUUID().toString();\n+        final String producerName = \"my-producer\";\n+        @Cleanup\n+        Producer<String> producer = pulsarClient\n+                .newProducer(Schema.STRING).topic(topicName).enableBatching(false).producerName(producerName).create();\n+        waitCacheInit(topicName);\n+        admin.topics().setDeduplicationSnapshotInterval(topicName, 1);\n+        admin.namespaces().setDeduplicationSnapshotInterval(myNamespace, 2);\n+\n+        int msgNum = 50;\n+        CountDownLatch countDownLatch = new CountDownLatch(msgNum);\n+        for (int i = 0; i < msgNum; i++) {\n+            producer.newMessage().value(\"msg\" + i).sendAsync().whenComplete((res, e) -> countDownLatch.countDown());\n+        }\n+        countDownLatch.await();\n+        PersistentTopic persistentTopic = (PersistentTopic) pulsar.getBrokerService().getTopicIfExists(topicName).get().get();\n+        long seqId = persistentTopic.getMessageDeduplication().highestSequencedPersisted.get(producerName);\n+        PositionImpl position = (PositionImpl) persistentTopic.getMessageDeduplication().getManagedCursor()\n+                .getManagedLedger().getLastConfirmedEntry();\n+        assertEquals(seqId, msgNum - 1);\n+        assertEquals(position.getEntryId(), msgNum - 1);\n+        //The first time, use topic-leve policies, 1 second delay + 1 second interval\n+        Thread.sleep(2000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e25247fc0833342d10faaa0a89f184b0e9de8f06"}, "originalPosition": 65}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2787, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}