{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ2ODEyODcx", "number": 9091, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwNjo0NTozNlrOFJ8Tzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwNjo0NTozNlrOFJ8Tzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1OTY5NjE0OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/intercept/ManagedLedgerInterceptorImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwNjo0NTozNlrOIMeiaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwODowMjo1NFrOIMh-vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk1NDE1Mw==", "bodyText": "Using instanceof is a bad practice, not Object oriented.\nIt is not in the scope of this PR but it would be better to have a more OO approach, using polymorphism", "url": "https://github.com/apache/pulsar/pull/9091#discussion_r549954153", "createdAt": "2020-12-30T06:45:36Z", "author": {"login": "eolivelli"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/intercept/ManagedLedgerInterceptorImpl.java", "diffHunk": "@@ -83,9 +83,9 @@ public void onManagedLedgerPropertiesInitialize(Map<String, String> propertiesMa\n     public void onManagedLedgerLastLedgerInitialize(String name, LedgerHandle lh) {\n         try {\n             for (BrokerEntryMetadataInterceptor interceptor : brokerEntryMetadataInterceptors) {\n-                if (interceptor instanceof AppendIndexMetadataInterceptor) {\n+                if (interceptor instanceof AppendIndexMetadataInterceptor && lh.getLastAddConfirmed() >= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80bec8fc924b49f749fb098e1a10cf42edec8bf1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDAxMDU1OQ==", "bodyText": "Agree with you that instanceof is not a good practice if we have a better choice.\nThere are two class AppendIndexMetadataInterceptor and AppendBrokerTimestampMetadataInterceptor implement BrokerEntryMetadataInterceptor.\nIf using polymorphism, for  AppendBrokerTimestampMetadataInterceptor, its recoveryIndexGenerator method do nothing like\npublic void recoveryIndexGenerator(long index) {\n       // do nothing.\n    }\nAnd the new onManagedLedgerLastLedgerInitialize would be like\n  @Override\n    public void onManagedLedgerLastLedgerInitialize(String name, LedgerHandle lh) {\n        try {\n            for (BrokerEntryMetadataInterceptor interceptor : brokerEntryMetadataInterceptors) {\n                if (lh.getLastAddConfirmed() >= 0) {\n                    LedgerEntries ledgerEntries =\n                            lh.read(lh.getLastAddConfirmed(), lh.getLastAddConfirmed());\n                    for (LedgerEntry entry : ledgerEntries) {\n                        PulsarApi.BrokerEntryMetadata brokerEntryMetadata =\n                                Commands.parseBrokerEntryMetadataIfExist(entry.getEntryBuffer());\n                        if (brokerEntryMetadata != null && brokerEntryMetadata.hasIndex()) {\n                                    interceptor.recoveryIndexGenerator(brokerEntryMetadata.getIndex());\n                        }\n                    }\n\n                }\n            }\n        } catch (org.apache.bookkeeper.client.api.BKException | InterruptedException e) {\n            log.error(\"[{}] Read last entry error.\", name, e);\n        }\n    }\nSo , even if interceptor is a AppendBrokerTimestampMetadataInterceptor, we still need to read the last entry from BookKeeper and  deserialize BrokerEntryMetadata  from the entry.\nhttps://github.com/aloyszhang/pulsar/blob/recovery-index/pulsar-broker/src/main/java/org/apache/pulsar/broker/intercept/ManagedLedgerInterceptorImpl.java#L87~L92\nLedgerEntries ledgerEntries =\n                            lh.read(lh.getLastAddConfirmed(), lh.getLastAddConfirmed());\n                    for (LedgerEntry entry : ledgerEntries) {\n                        PulsarApi.BrokerEntryMetadata brokerEntryMetadata =\n                                Commands.parseBrokerEntryMetadataIfExist(entry.getEntryBuffer());\n                        if (brokerEntryMetadata != null && brokerEntryMetadata.hasIndex()) {", "url": "https://github.com/apache/pulsar/pull/9091#discussion_r550010559", "createdAt": "2020-12-30T08:02:54Z", "author": {"login": "aloyszhang"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/intercept/ManagedLedgerInterceptorImpl.java", "diffHunk": "@@ -83,9 +83,9 @@ public void onManagedLedgerPropertiesInitialize(Map<String, String> propertiesMa\n     public void onManagedLedgerLastLedgerInitialize(String name, LedgerHandle lh) {\n         try {\n             for (BrokerEntryMetadataInterceptor interceptor : brokerEntryMetadataInterceptors) {\n-                if (interceptor instanceof AppendIndexMetadataInterceptor) {\n+                if (interceptor instanceof AppendIndexMetadataInterceptor && lh.getLastAddConfirmed() >= 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk1NDE1Mw=="}, "originalCommit": {"oid": "80bec8fc924b49f749fb098e1a10cf42edec8bf1"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2643, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}