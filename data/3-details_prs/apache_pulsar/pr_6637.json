{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1NTk3NDcw", "number": 6637, "title": "[pulsar-broker] Implement AutoSubscriptionCreation by namespace override", "bodyText": "Motivation\nAdd a new namespace policy autoSubscriptionCreationOverride which will enable an override of broker autoSubscriptionCreation settings on the namespace level. Users can keep autoSubscriptionCreation disabled for the broker and allow it on a specific namespace using this feature.\nModifications\n\nAdd a new namespace policy: autoSubscriptionCreationOverride and associated API / CLI interface for setting and removing.\nWhen checking autoSubscriptionCreation configuration, the broker first retrieves namespace policies from zookeeper. If not set, it falls back to broker configuration.\nSome minor improvement on autoTopicCreationOverride (e.g. v1 Namespaces API & cli md)", "createdAt": "2020-03-30T11:46:43Z", "url": "https://github.com/apache/pulsar/pull/6637", "merged": true, "mergeCommit": {"oid": "d8be7c5b56199d89eee921adf99b983f7861cf61"}, "closed": true, "closedAt": "2020-04-14T04:12:47Z", "author": {"login": "murong00"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcUvLQYAFqTM4Nzg1MTc0Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcXNGJMgBqjMyMjY3NjUxODY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3ODUxNzQz", "url": "https://github.com/apache/pulsar/pull/6637#pullrequestreview-387851743", "createdAt": "2020-04-05T19:22:24Z", "commit": {"oid": "4df8bad700f34961395c740142464b639a1f886a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4MTY0NjY1", "url": "https://github.com/apache/pulsar/pull/6637#pullrequestreview-388164665", "createdAt": "2020-04-06T11:36:42Z", "commit": {"oid": "4df8bad700f34961395c740142464b639a1f886a"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxMTozNjo0M1rOGBTmxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxMTozNzoyM1rOGBTn7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAyMjk4MA==", "bodyText": "It's better to call setData() asynchronously.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r404022980", "createdAt": "2020-04-06T11:36:43Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -653,6 +654,101 @@ protected void internalRemoveAutoTopicCreation(AsyncResponse asyncResponse) {\n         });\n     }\n \n+    protected void internalSetAutoSubscriptionCreation(AsyncResponse asyncResponse, AutoSubscriptionCreationOverride autoSubscriptionCreationOverride) {\n+        validateAdminAccessForTenant(namespaceName.getTenant());\n+        validatePoliciesReadOnlyAccess();\n+\n+        // Force to read the data s.t. the watch to the cache content is setup.\n+        policiesCache().getWithStatAsync(path(POLICIES, namespaceName.toString())).thenApply(\n+                policies -> {\n+                    if (policies.isPresent()) {\n+                        Entry<Policies, Stat> policiesNode = policies.get();\n+                        policiesNode.getKey().autoSubscriptionCreationOverride = autoSubscriptionCreationOverride;\n+                        try {\n+                            // Write back the new policies into zookeeper\n+                            globalZk().setData(path(POLICIES, namespaceName.toString()),\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4df8bad700f34961395c740142464b639a1f886a"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAyMzI3Nw==", "bodyText": "Same as the above comment.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r404023277", "createdAt": "2020-04-06T11:37:23Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -653,6 +654,101 @@ protected void internalRemoveAutoTopicCreation(AsyncResponse asyncResponse) {\n         });\n     }\n \n+    protected void internalSetAutoSubscriptionCreation(AsyncResponse asyncResponse, AutoSubscriptionCreationOverride autoSubscriptionCreationOverride) {\n+        validateAdminAccessForTenant(namespaceName.getTenant());\n+        validatePoliciesReadOnlyAccess();\n+\n+        // Force to read the data s.t. the watch to the cache content is setup.\n+        policiesCache().getWithStatAsync(path(POLICIES, namespaceName.toString())).thenApply(\n+                policies -> {\n+                    if (policies.isPresent()) {\n+                        Entry<Policies, Stat> policiesNode = policies.get();\n+                        policiesNode.getKey().autoSubscriptionCreationOverride = autoSubscriptionCreationOverride;\n+                        try {\n+                            // Write back the new policies into zookeeper\n+                            globalZk().setData(path(POLICIES, namespaceName.toString()),\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());\n+                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                            asyncResponse.resume(Response.noContent().build());\n+                            String autoOverride = autoSubscriptionCreationOverride.allowAutoSubscriptionCreation ? \"enabled\" : \"disabled\";\n+                            log.info(\"[{}] Successfully {} autoSubscriptionCreation on namespace {}\", clientAppId(), autoOverride, namespaceName);\n+                            return null;\n+                        } catch (KeeperException.NoNodeException e) {\n+                            log.error(\"[{}] Failed to modify autoSubscriptionCreation status for namespace {}: does not exist\", clientAppId(),\n+                                    namespaceName);\n+                            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                            return null;\n+                        } catch (KeeperException.BadVersionException e) {\n+                            log.error(\n+                                    \"[{}] Failed to modify autoSubscriptionCreation status on namespace {} expected policy node version={} : concurrent modification\",\n+                                    clientAppId(), namespaceName, policiesNode.getValue().getVersion());\n+\n+                            asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                            return null;\n+                        } catch (Exception e) {\n+                            log.error(\"[{}] Failed to modify autoSubscriptionCreation status on namespace {}\", clientAppId(), namespaceName, e);\n+                            asyncResponse.resume(new RestException(e));\n+                            return null;\n+                        }\n+                    } else {\n+                        asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace \" + namespaceName + \" does not exist\"));\n+                        return null;\n+                    }\n+                }\n+        ).exceptionally(e -> {\n+            log.error(\"[{}] Failed to modify autoSubscriptionCreation status on namespace {}\", clientAppId(), namespaceName, e);\n+            asyncResponse.resume(new RestException(e));\n+            return null;\n+        });\n+    }\n+\n+    protected void internalRemoveAutoSubscriptionCreation(AsyncResponse asyncResponse) {\n+        validateAdminAccessForTenant(namespaceName.getTenant());\n+        validatePoliciesReadOnlyAccess();\n+\n+        // Force to read the data s.t. the watch to the cache content is setup.\n+        policiesCache().getWithStatAsync(path(POLICIES, namespaceName.toString())).thenApply(\n+                policies -> {\n+                    if (policies.isPresent()) {\n+                        Entry<Policies, Stat> policiesNode = policies.get();\n+                        policiesNode.getKey().autoSubscriptionCreationOverride = null;\n+                        try {\n+                            // Write back the new policies into zookeeper\n+                            globalZk().setData(path(POLICIES, namespaceName.toString()),\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4df8bad700f34961395c740142464b639a1f886a"}, "originalPosition": 91}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4df8bad700f34961395c740142464b639a1f886a", "author": {"user": {"login": "murong00", "name": "Fangbin Sun"}}, "url": "https://github.com/apache/pulsar/commit/4df8bad700f34961395c740142464b639a1f886a", "committedDate": "2020-03-31T01:27:02Z", "message": "Fix checkstyle."}, "afterCommit": {"oid": "be660fbf52bb61ed6776b31fd3a1287fe479384f", "author": {"user": {"login": "murong00", "name": "Fangbin Sun"}}, "url": "https://github.com/apache/pulsar/commit/be660fbf52bb61ed6776b31fd3a1287fe479384f", "committedDate": "2020-04-07T03:09:11Z", "message": "Call setData asynchronously"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "be660fbf52bb61ed6776b31fd3a1287fe479384f", "author": {"user": {"login": "murong00", "name": "Fangbin Sun"}}, "url": "https://github.com/apache/pulsar/commit/be660fbf52bb61ed6776b31fd3a1287fe479384f", "committedDate": "2020-04-07T03:09:11Z", "message": "Call setData asynchronously"}, "afterCommit": {"oid": "79a3a5df63278cd28421d2ff4cf65067d334ed8e", "author": {"user": {"login": "murong00", "name": "Fangbin Sun"}}, "url": "https://github.com/apache/pulsar/commit/79a3a5df63278cd28421d2ff4cf65067d334ed8e", "committedDate": "2020-04-07T09:25:25Z", "message": "Call setData asynchronously"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5Nzc1NjQ5", "url": "https://github.com/apache/pulsar/pull/6637#pullrequestreview-389775649", "createdAt": "2020-04-08T08:51:45Z", "commit": {"oid": "79a3a5df63278cd28421d2ff4cf65067d334ed8e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5ODYyMjgx", "url": "https://github.com/apache/pulsar/pull/6637#pullrequestreview-389862281", "createdAt": "2020-04-08T10:50:39Z", "commit": {"oid": "79a3a5df63278cd28421d2ff4cf65067d334ed8e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMDo1MDozOVrOGCpvug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxMDo1NTo0NFrOGCp5xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQzNDI5OA==", "bodyText": "The response should complete in the zookeeper callback. Otherwise, the broker always returns success.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r405434298", "createdAt": "2020-04-08T10:50:39Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -571,23 +572,80 @@ protected void internalSetAutoTopicCreation(AsyncResponse asyncResponse, AutoTop\n                         try {\n                             // Write back the new policies into zookeeper\n                             globalZk().setData(path(POLICIES, namespaceName.toString()),\n-                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());\n-                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                        } else {\n+                                            String errorMsg = String.format(\n+                                                    \"[%s] Failed to modify autoTopicCreation status for namespace %s\",\n+                                                    clientAppId(), namespaceName);\n+                                            if (rc == KeeperException.Code.NONODE.intValue()) {\n+                                                log.warn(\"{} : does not exist\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                                            } else if (rc == KeeperException.Code.BADVERSION.intValue()) {\n+                                                log.warn(\"{} : concurrent modification\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                                            } else {\n+                                                asyncResponse.resume(KeeperException.create(KeeperException.Code.get(rc), errorMsg));\n+                                            }\n+                                        }\n+                                    }, null);\n+                            String autoOverride = autoTopicCreationOverride.allowAutoTopicCreation ? \"enabled\" : \"disabled\";\n+                            log.info(\"[{}] Successfully {} autoTopicCreation on namespace {}\", clientAppId(), autoOverride, namespaceName);\n                             asyncResponse.resume(Response.noContent().build());\n-                            log.info(\"[{}] Successfully {} on namespace {}\", clientAppId(),\n-                                    autoTopicCreationOverride.allowAutoTopicCreation ? \"enabled\" : \"disabled\", namespaceName);\n                             return null;\n-                        } catch (KeeperException.NoNodeException e) {\n-                            log.error(\"[{}] Failed to modify autoTopicCreation status for namespace {}: does not exist\", clientAppId(),\n-                                    namespaceName);\n-                            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                        } catch (Exception e) {\n+                            log.error(\"[{}] Failed to modify autoTopicCreation status on namespace {}\", clientAppId(), namespaceName, e);\n+                            asyncResponse.resume(new RestException(e));\n                             return null;\n-                        } catch (KeeperException.BadVersionException e) {\n-                            log.error(\n-                                    \"[{}] Failed to modify autoTopicCreation status on namespace {} expected policy node version={} : concurrent modification\",\n-                                    clientAppId(), namespaceName, policiesNode.getValue().getVersion());\n+                        }\n+                    } else {\n+                        asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace \" + namespaceName + \" does not exist\"));\n+                        return null;\n+                    }\n+                }\n+        ).exceptionally(e -> {\n+            log.error(\"[{}] Failed to modify autoTopicCreation status on namespace {}\", clientAppId(), namespaceName, e);\n+            asyncResponse.resume(new RestException(e));\n+            return null;\n+        });\n+    }\n+\n+    protected void internalRemoveAutoTopicCreation(AsyncResponse asyncResponse) {\n+        validateAdminAccessForTenant(namespaceName.getTenant());\n+        validatePoliciesReadOnlyAccess();\n \n-                            asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+        // Force to read the data s.t. the watch to the cache content is setup.\n+        policiesCache().getWithStatAsync(path(POLICIES, namespaceName.toString())).thenApply(\n+                policies -> {\n+                    if (policies.isPresent()) {\n+                        Entry<Policies, Stat> policiesNode = policies.get();\n+                        policiesNode.getKey().autoTopicCreationOverride = null;\n+                        try {\n+                            // Write back the new policies into zookeeper\n+                            globalZk().setData(path(POLICIES, namespaceName.toString()),\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                        } else {\n+                                            String errorMsg = String.format(\n+                                                    \"[%s] Failed to modify autoTopicCreation status for namespace %s\",\n+                                                    clientAppId(), namespaceName);\n+                                            if (rc == KeeperException.Code.NONODE.intValue()) {\n+                                                log.warn(\"{} : does not exist\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                                            } else if (rc == KeeperException.Code.BADVERSION.intValue()) {\n+                                                log.warn(\"{} : concurrent modification\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                                            } else {\n+                                                asyncResponse.resume(KeeperException.create(KeeperException.Code.get(rc), errorMsg));\n+                                            }\n+                                        }\n+                                    }, null);\n+                            log.info(\"[{}] Successfully removed autoTopicCreation override on namespace {}\", clientAppId(), namespaceName);\n+                            asyncResponse.resume(Response.noContent().build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79a3a5df63278cd28421d2ff4cf65067d334ed8e"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQzNTM5Ng==", "bodyText": "Looks should complete the asyncResponse here.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r405435396", "createdAt": "2020-04-08T10:52:49Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -571,23 +572,80 @@ protected void internalSetAutoTopicCreation(AsyncResponse asyncResponse, AutoTop\n                         try {\n                             // Write back the new policies into zookeeper\n                             globalZk().setData(path(POLICIES, namespaceName.toString()),\n-                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());\n-                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79a3a5df63278cd28421d2ff4cf65067d334ed8e"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQzNTk2MQ==", "bodyText": "Should move to the zookeeper callback.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r405435961", "createdAt": "2020-04-08T10:53:54Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -571,23 +572,80 @@ protected void internalSetAutoTopicCreation(AsyncResponse asyncResponse, AutoTop\n                         try {\n                             // Write back the new policies into zookeeper\n                             globalZk().setData(path(POLICIES, namespaceName.toString()),\n-                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());\n-                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                        } else {\n+                                            String errorMsg = String.format(\n+                                                    \"[%s] Failed to modify autoTopicCreation status for namespace %s\",\n+                                                    clientAppId(), namespaceName);\n+                                            if (rc == KeeperException.Code.NONODE.intValue()) {\n+                                                log.warn(\"{} : does not exist\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                                            } else if (rc == KeeperException.Code.BADVERSION.intValue()) {\n+                                                log.warn(\"{} : concurrent modification\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                                            } else {\n+                                                asyncResponse.resume(KeeperException.create(KeeperException.Code.get(rc), errorMsg));\n+                                            }\n+                                        }\n+                                    }, null);\n+                            String autoOverride = autoTopicCreationOverride.allowAutoTopicCreation ? \"enabled\" : \"disabled\";\n+                            log.info(\"[{}] Successfully {} autoTopicCreation on namespace {}\", clientAppId(), autoOverride, namespaceName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79a3a5df63278cd28421d2ff4cf65067d334ed8e"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQzNjY4Nw==", "bodyText": "Should move to the zookeeper callback.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r405436687", "createdAt": "2020-04-08T10:55:17Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -615,29 +673,87 @@ protected void internalRemoveAutoTopicCreation(AsyncResponse asyncResponse) {\n                 policies -> {\n                     if (policies.isPresent()) {\n                         Entry<Policies, Stat> policiesNode = policies.get();\n-                        policiesNode.getKey().autoTopicCreationOverride = null;\n+                        policiesNode.getKey().autoSubscriptionCreationOverride = autoSubscriptionCreationOverride;\n                         try {\n                             // Write back the new policies into zookeeper\n                             globalZk().setData(path(POLICIES, namespaceName.toString()),\n-                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());\n-                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                        } else {\n+                                            String errorMsg = String.format(\n+                                                    \"[%s] Failed to modify autoSubscriptionCreation status for namespace %s\",\n+                                                    clientAppId(), namespaceName);\n+                                            if (rc == KeeperException.Code.NONODE.intValue()) {\n+                                                log.warn(\"{} : does not exist\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                                            } else if (rc == KeeperException.Code.BADVERSION.intValue()) {\n+                                                log.warn(\"{} : concurrent modification\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                                            } else {\n+                                                asyncResponse.resume(KeeperException.create(KeeperException.Code.get(rc), errorMsg));\n+                                            }\n+                                        }\n+                                    }, null);\n+                            String autoOverride = autoSubscriptionCreationOverride.allowAutoSubscriptionCreation ? \"enabled\" : \"disabled\";\n+                            log.info(\"[{}] Successfully {} autoSubscriptionCreation on namespace {}\", clientAppId(), autoOverride, namespaceName);\n                             asyncResponse.resume(Response.noContent().build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79a3a5df63278cd28421d2ff4cf65067d334ed8e"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTQzNjg2OQ==", "bodyText": "Should move to the zookeeper callback.", "url": "https://github.com/apache/pulsar/pull/6637#discussion_r405436869", "createdAt": "2020-04-08T10:55:44Z", "author": {"login": "codelipenghui"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/NamespacesBase.java", "diffHunk": "@@ -615,29 +673,87 @@ protected void internalRemoveAutoTopicCreation(AsyncResponse asyncResponse) {\n                 policies -> {\n                     if (policies.isPresent()) {\n                         Entry<Policies, Stat> policiesNode = policies.get();\n-                        policiesNode.getKey().autoTopicCreationOverride = null;\n+                        policiesNode.getKey().autoSubscriptionCreationOverride = autoSubscriptionCreationOverride;\n                         try {\n                             // Write back the new policies into zookeeper\n                             globalZk().setData(path(POLICIES, namespaceName.toString()),\n-                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion());\n-                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                        } else {\n+                                            String errorMsg = String.format(\n+                                                    \"[%s] Failed to modify autoSubscriptionCreation status for namespace %s\",\n+                                                    clientAppId(), namespaceName);\n+                                            if (rc == KeeperException.Code.NONODE.intValue()) {\n+                                                log.warn(\"{} : does not exist\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                                            } else if (rc == KeeperException.Code.BADVERSION.intValue()) {\n+                                                log.warn(\"{} : concurrent modification\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                                            } else {\n+                                                asyncResponse.resume(KeeperException.create(KeeperException.Code.get(rc), errorMsg));\n+                                            }\n+                                        }\n+                                    }, null);\n+                            String autoOverride = autoSubscriptionCreationOverride.allowAutoSubscriptionCreation ? \"enabled\" : \"disabled\";\n+                            log.info(\"[{}] Successfully {} autoSubscriptionCreation on namespace {}\", clientAppId(), autoOverride, namespaceName);\n                             asyncResponse.resume(Response.noContent().build());\n-                            log.info(\"[{}] Successfully removed override on namespace {}\", clientAppId(), namespaceName);\n                             return null;\n-                        } catch (KeeperException.NoNodeException e) {\n-                            log.error(\"[{}] Failed to modify autoTopicCreation status for namespace {}: does not exist\", clientAppId(),\n-                                    namespaceName);\n-                            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                        } catch (Exception e) {\n+                            log.error(\"[{}] Failed to modify autoSubscriptionCreation status on namespace {}\", clientAppId(), namespaceName, e);\n+                            asyncResponse.resume(new RestException(e));\n                             return null;\n-                        } catch (KeeperException.BadVersionException e) {\n-                            log.error(\n-                                    \"[{}] Failed to modify autoTopicCreation status on namespace {} expected policy node version={} : concurrent modification\",\n-                                    clientAppId(), namespaceName, policiesNode.getValue().getVersion());\n+                        }\n+                    } else {\n+                        asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace \" + namespaceName + \" does not exist\"));\n+                        return null;\n+                    }\n+                }\n+        ).exceptionally(e -> {\n+            log.error(\"[{}] Failed to modify autoSubscriptionCreation status on namespace {}\", clientAppId(), namespaceName, e);\n+            asyncResponse.resume(new RestException(e));\n+            return null;\n+        });\n+    }\n+\n+    protected void internalRemoveAutoSubscriptionCreation(AsyncResponse asyncResponse) {\n+        validateAdminAccessForTenant(namespaceName.getTenant());\n+        validatePoliciesReadOnlyAccess();\n \n-                            asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+        // Force to read the data s.t. the watch to the cache content is setup.\n+        policiesCache().getWithStatAsync(path(POLICIES, namespaceName.toString())).thenApply(\n+                policies -> {\n+                    if (policies.isPresent()) {\n+                        Entry<Policies, Stat> policiesNode = policies.get();\n+                        policiesNode.getKey().autoSubscriptionCreationOverride = null;\n+                        try {\n+                            // Write back the new policies into zookeeper\n+                            globalZk().setData(path(POLICIES, namespaceName.toString()),\n+                                    jsonMapper().writeValueAsBytes(policiesNode.getKey()), policiesNode.getValue().getVersion(),\n+                                    (rc, path1, ctx, stat) -> {\n+                                        if (rc == KeeperException.Code.OK.intValue()) {\n+                                            policiesCache().invalidate(path(POLICIES, namespaceName.toString()));\n+                                        } else {\n+                                            String errorMsg = String.format(\n+                                                    \"[%s] Failed to modify autoSubscriptionCreation status for namespace %s\",\n+                                                    clientAppId(), namespaceName);\n+                                            if (rc == KeeperException.Code.NONODE.intValue()) {\n+                                                log.warn(\"{} : does not exist\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Namespace does not exist\"));\n+                                            } else if (rc == KeeperException.Code.BADVERSION.intValue()) {\n+                                                log.warn(\"{} : concurrent modification\", errorMsg);\n+                                                asyncResponse.resume(new RestException(Status.CONFLICT, \"Concurrent modification\"));\n+                                            } else {\n+                                                asyncResponse.resume(KeeperException.create(KeeperException.Code.get(rc), errorMsg));\n+                                            }\n+                                        }\n+                                    }, null);\n+                            log.info(\"[{}] Successfully removed autoSubscriptionCreation override on namespace {}\", clientAppId(), namespaceName);\n+                            asyncResponse.resume(Response.noContent().build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79a3a5df63278cd28421d2ff4cf65067d334ed8e"}, "originalPosition": 205}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwNTU5MjQ3", "url": "https://github.com/apache/pulsar/pull/6637#pullrequestreview-390559247", "createdAt": "2020-04-09T07:42:04Z", "commit": {"oid": "dbf3ca7e0a3dc0d4124906191245eb5a2c01e78c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c096fb0edd8ab7860057265cf7f7c3c6af090b63", "author": {"user": {"login": "murong00", "name": "Fangbin Sun"}}, "url": "https://github.com/apache/pulsar/commit/c096fb0edd8ab7860057265cf7f7c3c6af090b63", "committedDate": "2020-04-13T11:20:46Z", "message": "Implement AutoSubscriptionCreation by namespace override.\n\nFix checkstyle."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0bfa24cbe28d7a42427c2a5bbfdbc0fb840c4ca", "author": {"user": {"login": "murong00", "name": "Fangbin Sun"}}, "url": "https://github.com/apache/pulsar/commit/c0bfa24cbe28d7a42427c2a5bbfdbc0fb840c4ca", "committedDate": "2020-04-13T11:20:46Z", "message": "Call setData asynchronously"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c6e7db2cfd846e8c27f25c91645c9558348777b", "author": {"user": {"login": "murong00", "name": "Fangbin Sun"}}, "url": "https://github.com/apache/pulsar/commit/9c6e7db2cfd846e8c27f25c91645c9558348777b", "committedDate": "2020-04-13T11:20:46Z", "message": "Complete the asyncResponse correctly."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dbf3ca7e0a3dc0d4124906191245eb5a2c01e78c", "author": {"user": {"login": "murong00", "name": "Fangbin Sun"}}, "url": "https://github.com/apache/pulsar/commit/dbf3ca7e0a3dc0d4124906191245eb5a2c01e78c", "committedDate": "2020-04-09T01:52:02Z", "message": "Complete the asyncResponse correctly."}, "afterCommit": {"oid": "9c6e7db2cfd846e8c27f25c91645c9558348777b", "author": {"user": {"login": "murong00", "name": "Fangbin Sun"}}, "url": "https://github.com/apache/pulsar/commit/9c6e7db2cfd846e8c27f25c91645c9558348777b", "committedDate": "2020-04-13T11:20:46Z", "message": "Complete the asyncResponse correctly."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4879, "cost": 1, "resetAt": "2021-10-28T18:54:27Z"}}}