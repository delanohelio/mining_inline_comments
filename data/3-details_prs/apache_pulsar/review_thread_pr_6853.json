{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExNjQwNDY0", "number": 6853, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNTowMzo1MVrOD6Fz_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwMzozNzowNVrOD6f9CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjM5MjI5OnYy", "diffSide": "RIGHT", "path": "pulsar-client-auth-keystoretls/src/test/java/org/apache/pulsar/client/TlsProducerConsumerTestWithAuth.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNTowMzo1MVrOGRuglg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNTo0NzozOVrOGRvQyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI0MDk4Mg==", "bodyText": "why are these lines commented?", "url": "https://github.com/apache/pulsar/pull/6853#discussion_r421240982", "createdAt": "2020-05-07T05:03:51Z", "author": {"login": "sijie"}, "path": "pulsar-client-auth-keystoretls/src/test/java/org/apache/pulsar/client/TlsProducerConsumerTestWithAuth.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.client;\n+\n+import static org.mockito.Mockito.spy;\n+\n+import com.google.common.collect.Sets;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.pulsar.broker.authentication.AuthenticationProviderTls;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.api.ClientBuilder;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.Producer;\n+import org.apache.pulsar.client.api.ProducerConsumerBase;\n+import org.apache.pulsar.client.api.PulsarClient;\n+import org.apache.pulsar.client.api.SubscriptionType;\n+import org.apache.pulsar.client.impl.auth.AuthenticationKeyStoreTls;\n+import org.apache.pulsar.common.policies.data.ClusterData;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+// TLS authentication and authorization based on KeyStore type config.\n+@Slf4j\n+public class TlsProducerConsumerTestWithAuth extends ProducerConsumerBase {\n+    protected final String BROKER_KEYSTORE_FILE_PATH = \"./src/test/resources/broker.keystore.jks\";\n+    protected final String BROKER_TRUSTSTORE_FILE_PATH = \"./src/test/resources/broker.truststore.jks\";\n+    protected final String BROKER_KEYSTORE_PW = \"111111\";\n+    protected final String BROKER_TRUSTSTORE_PW = \"111111\";\n+\n+    protected final String CLIENT_KEYSTORE_FILE_PATH = \"./src/test/resources/client.keystore.jks\";\n+    protected final String CLIENT_TRUSTSTORE_FILE_PATH = \"./src/test/resources/client.truststore.jks\";\n+    protected final String CLIENT_KEYSTORE_PW = \"111111\";\n+    protected final String CLIENT_TRUSTSTORE_PW = \"111111\";\n+\n+    protected final String CLIENT_KEYSTORE_CN = \"clientuser\";\n+    protected final String KEYSTORE_TYPE = \"JKS\";\n+\n+    private final String clusterName = \"use\";\n+    Set<String> tlsProtocols = Sets.newConcurrentHashSet();\n+\n+    @BeforeMethod\n+    @Override\n+    protected void setup() throws Exception {\n+        // TLS configuration for Broker\n+        internalSetUpForBroker();\n+\n+        // Start Broker\n+\n+        super.init();\n+    }\n+\n+    @AfterMethod\n+    @Override\n+    protected void cleanup() throws Exception {\n+        super.internalCleanup();\n+    }\n+\n+    protected void internalSetUpForBroker() throws Exception {\n+        conf.setBrokerServicePortTls(Optional.of(0));\n+        conf.setWebServicePortTls(Optional.of(0));\n+        conf.setTlsEnabledWithKeyStore(true);\n+\n+        conf.setTlsKeyStoreType(KEYSTORE_TYPE);\n+        conf.setTlsKeyStore(BROKER_KEYSTORE_FILE_PATH);\n+        conf.setTlsKeyStorePassword(BROKER_KEYSTORE_PW);\n+\n+        conf.setTlsTrustStoreType(KEYSTORE_TYPE);\n+        conf.setTlsTrustStore(CLIENT_TRUSTSTORE_FILE_PATH);\n+        conf.setTlsTrustStorePassword(CLIENT_TRUSTSTORE_PW);\n+\n+        conf.setClusterName(clusterName);\n+        conf.setTlsRequireTrustedClientCertOnConnect(true);\n+        tlsProtocols.add(\"TLSv1.2\");\n+        conf.setTlsProtocols(tlsProtocols);\n+\n+        // config for authentication and authorization.\n+        conf.setSuperUserRoles(Sets.newHashSet(CLIENT_KEYSTORE_CN));\n+        conf.setAuthenticationEnabled(true);\n+        conf.setAuthorizationEnabled(true);\n+        Set<String> providers = new HashSet<>();\n+        providers.add(AuthenticationProviderTls.class.getName());\n+        conf.setAuthenticationProviders(providers);\n+    }\n+\n+    protected void internalSetUpForClient(boolean addCertificates, String lookupUrl) throws Exception {\n+        if (pulsarClient != null) {\n+            pulsarClient.close();\n+        }\n+\n+        Set<String> tlsProtocols = Sets.newConcurrentHashSet();\n+        tlsProtocols.add(\"TLSv1.2\");\n+\n+        ClientBuilder clientBuilder = PulsarClient.builder().serviceUrl(lookupUrl)\n+                .enableTls(true)\n+                .useKeyStoreTls(true)\n+                .tlsTrustStorePath(BROKER_TRUSTSTORE_FILE_PATH)\n+                .tlsTrustStorePassword(BROKER_TRUSTSTORE_PW)\n+                .allowTlsInsecureConnection(false)\n+                .tlsProtocols(tlsProtocols)\n+                .operationTimeout(1000, TimeUnit.MILLISECONDS);\n+        if (addCertificates) {\n+            Map<String, String> authParams = new HashMap<>();\n+            authParams.put(AuthenticationKeyStoreTls.KEYSTORE_TYPE, KEYSTORE_TYPE);\n+            authParams.put(AuthenticationKeyStoreTls.KEYSTORE_PATH, CLIENT_KEYSTORE_FILE_PATH);\n+            authParams.put(AuthenticationKeyStoreTls.KEYSTORE_PW, CLIENT_KEYSTORE_PW);\n+            clientBuilder.authentication(AuthenticationKeyStoreTls.class.getName(), authParams);\n+        }\n+        pulsarClient = clientBuilder.build();\n+    }\n+\n+    protected void internalSetUpForNamespace() throws Exception {\n+        Map<String, String> authParams = new HashMap<>();\n+        authParams.put(AuthenticationKeyStoreTls.KEYSTORE_PATH, CLIENT_KEYSTORE_FILE_PATH);\n+        authParams.put(AuthenticationKeyStoreTls.KEYSTORE_PW, CLIENT_KEYSTORE_PW);\n+\n+        if (admin != null) {\n+            admin.close();\n+        }\n+\n+        admin = spy(PulsarAdmin.builder().serviceHttpUrl(brokerUrlTls.toString())\n+                .useKeyStoreTls(true)\n+                .tlsTrustStorePath(BROKER_TRUSTSTORE_FILE_PATH)\n+                .tlsTrustStorePassword(BROKER_TRUSTSTORE_PW)\n+                .allowTlsInsecureConnection(true)\n+                .authentication(AuthenticationKeyStoreTls.class.getName(), authParams).build());\n+        admin.clusters().createCluster(clusterName, new ClusterData(brokerUrl.toString(), brokerUrlTls.toString(),\n+                pulsar.getBrokerServiceUrl(), pulsar.getBrokerServiceUrlTls()));\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"use\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+    }\n+\n+    /**\n+     * verifies that messages whose size is larger than 2^14 bytes (max size of single TLS chunk) can be\n+     * produced/consumed\n+     *\n+     * @throws Exception\n+     */\n+    @Test(timeOut = 30000)\n+    public void testTlsLargeSizeMessage() throws Exception {\n+        log.info(\"-- Starting {} test --\", methodName);\n+\n+        final int MESSAGE_SIZE = 16 * 1024 + 1;\n+        log.info(\"-- message size --\", MESSAGE_SIZE);\n+        String topicName = \"persistent://my-property/use/my-ns/testTlsLargeSizeMessage\"\n+                           + System.currentTimeMillis();\n+\n+        internalSetUpForClient(true, pulsar.getBrokerServiceUrlTls());\n+        internalSetUpForNamespace();\n+\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(topicName)\n+                .subscriptionName(\"my-subscriber-name\").subscribe();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .create();\n+        for (int i = 0; i < 10; i++) {\n+            byte[] message = new byte[MESSAGE_SIZE];\n+            Arrays.fill(message, (byte) i);\n+            producer.send(message);\n+        }\n+\n+        Message<byte[]> msg = null;\n+        for (int i = 0; i < 10; i++) {\n+            msg = consumer.receive(5, TimeUnit.SECONDS);\n+            byte[] expected = new byte[MESSAGE_SIZE];\n+            Arrays.fill(expected, (byte) i);\n+            Assert.assertEquals(expected, msg.getData());\n+        }\n+        // Acknowledge the consumption of all messages at once\n+        consumer.acknowledgeCumulative(msg);\n+        consumer.close();\n+        log.info(\"-- Exiting {} test --\", methodName);\n+    }\n+\n+    @Test(timeOut = 300000)\n+    public void testTlsClientAuthOverBinaryProtocol() throws Exception {\n+        log.info(\"-- Starting {} test --\", methodName);\n+\n+        final int MESSAGE_SIZE = 16 * 1024 + 1;\n+        log.info(\"-- message size --\", MESSAGE_SIZE);\n+        String topicName = \"persistent://my-property/use/my-ns/testTlsClientAuthOverBinaryProtocol\"\n+                           + System.currentTimeMillis();\n+\n+        internalSetUpForNamespace();\n+\n+//        // Test 1 - Using TLS on binary protocol without sending certs - expect failure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3343e924ab7d0c5f34c1bc00e376c985d7270895"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI1MzMyMg==", "bodyText": "Oh, thank, this is for debug reason. will uncomment them", "url": "https://github.com/apache/pulsar/pull/6853#discussion_r421253322", "createdAt": "2020-05-07T05:47:39Z", "author": {"login": "jiazhai"}, "path": "pulsar-client-auth-keystoretls/src/test/java/org/apache/pulsar/client/TlsProducerConsumerTestWithAuth.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.client;\n+\n+import static org.mockito.Mockito.spy;\n+\n+import com.google.common.collect.Sets;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.pulsar.broker.authentication.AuthenticationProviderTls;\n+import org.apache.pulsar.client.admin.PulsarAdmin;\n+import org.apache.pulsar.client.api.ClientBuilder;\n+import org.apache.pulsar.client.api.Consumer;\n+import org.apache.pulsar.client.api.Message;\n+import org.apache.pulsar.client.api.Producer;\n+import org.apache.pulsar.client.api.ProducerConsumerBase;\n+import org.apache.pulsar.client.api.PulsarClient;\n+import org.apache.pulsar.client.api.SubscriptionType;\n+import org.apache.pulsar.client.impl.auth.AuthenticationKeyStoreTls;\n+import org.apache.pulsar.common.policies.data.ClusterData;\n+import org.apache.pulsar.common.policies.data.TenantInfo;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+// TLS authentication and authorization based on KeyStore type config.\n+@Slf4j\n+public class TlsProducerConsumerTestWithAuth extends ProducerConsumerBase {\n+    protected final String BROKER_KEYSTORE_FILE_PATH = \"./src/test/resources/broker.keystore.jks\";\n+    protected final String BROKER_TRUSTSTORE_FILE_PATH = \"./src/test/resources/broker.truststore.jks\";\n+    protected final String BROKER_KEYSTORE_PW = \"111111\";\n+    protected final String BROKER_TRUSTSTORE_PW = \"111111\";\n+\n+    protected final String CLIENT_KEYSTORE_FILE_PATH = \"./src/test/resources/client.keystore.jks\";\n+    protected final String CLIENT_TRUSTSTORE_FILE_PATH = \"./src/test/resources/client.truststore.jks\";\n+    protected final String CLIENT_KEYSTORE_PW = \"111111\";\n+    protected final String CLIENT_TRUSTSTORE_PW = \"111111\";\n+\n+    protected final String CLIENT_KEYSTORE_CN = \"clientuser\";\n+    protected final String KEYSTORE_TYPE = \"JKS\";\n+\n+    private final String clusterName = \"use\";\n+    Set<String> tlsProtocols = Sets.newConcurrentHashSet();\n+\n+    @BeforeMethod\n+    @Override\n+    protected void setup() throws Exception {\n+        // TLS configuration for Broker\n+        internalSetUpForBroker();\n+\n+        // Start Broker\n+\n+        super.init();\n+    }\n+\n+    @AfterMethod\n+    @Override\n+    protected void cleanup() throws Exception {\n+        super.internalCleanup();\n+    }\n+\n+    protected void internalSetUpForBroker() throws Exception {\n+        conf.setBrokerServicePortTls(Optional.of(0));\n+        conf.setWebServicePortTls(Optional.of(0));\n+        conf.setTlsEnabledWithKeyStore(true);\n+\n+        conf.setTlsKeyStoreType(KEYSTORE_TYPE);\n+        conf.setTlsKeyStore(BROKER_KEYSTORE_FILE_PATH);\n+        conf.setTlsKeyStorePassword(BROKER_KEYSTORE_PW);\n+\n+        conf.setTlsTrustStoreType(KEYSTORE_TYPE);\n+        conf.setTlsTrustStore(CLIENT_TRUSTSTORE_FILE_PATH);\n+        conf.setTlsTrustStorePassword(CLIENT_TRUSTSTORE_PW);\n+\n+        conf.setClusterName(clusterName);\n+        conf.setTlsRequireTrustedClientCertOnConnect(true);\n+        tlsProtocols.add(\"TLSv1.2\");\n+        conf.setTlsProtocols(tlsProtocols);\n+\n+        // config for authentication and authorization.\n+        conf.setSuperUserRoles(Sets.newHashSet(CLIENT_KEYSTORE_CN));\n+        conf.setAuthenticationEnabled(true);\n+        conf.setAuthorizationEnabled(true);\n+        Set<String> providers = new HashSet<>();\n+        providers.add(AuthenticationProviderTls.class.getName());\n+        conf.setAuthenticationProviders(providers);\n+    }\n+\n+    protected void internalSetUpForClient(boolean addCertificates, String lookupUrl) throws Exception {\n+        if (pulsarClient != null) {\n+            pulsarClient.close();\n+        }\n+\n+        Set<String> tlsProtocols = Sets.newConcurrentHashSet();\n+        tlsProtocols.add(\"TLSv1.2\");\n+\n+        ClientBuilder clientBuilder = PulsarClient.builder().serviceUrl(lookupUrl)\n+                .enableTls(true)\n+                .useKeyStoreTls(true)\n+                .tlsTrustStorePath(BROKER_TRUSTSTORE_FILE_PATH)\n+                .tlsTrustStorePassword(BROKER_TRUSTSTORE_PW)\n+                .allowTlsInsecureConnection(false)\n+                .tlsProtocols(tlsProtocols)\n+                .operationTimeout(1000, TimeUnit.MILLISECONDS);\n+        if (addCertificates) {\n+            Map<String, String> authParams = new HashMap<>();\n+            authParams.put(AuthenticationKeyStoreTls.KEYSTORE_TYPE, KEYSTORE_TYPE);\n+            authParams.put(AuthenticationKeyStoreTls.KEYSTORE_PATH, CLIENT_KEYSTORE_FILE_PATH);\n+            authParams.put(AuthenticationKeyStoreTls.KEYSTORE_PW, CLIENT_KEYSTORE_PW);\n+            clientBuilder.authentication(AuthenticationKeyStoreTls.class.getName(), authParams);\n+        }\n+        pulsarClient = clientBuilder.build();\n+    }\n+\n+    protected void internalSetUpForNamespace() throws Exception {\n+        Map<String, String> authParams = new HashMap<>();\n+        authParams.put(AuthenticationKeyStoreTls.KEYSTORE_PATH, CLIENT_KEYSTORE_FILE_PATH);\n+        authParams.put(AuthenticationKeyStoreTls.KEYSTORE_PW, CLIENT_KEYSTORE_PW);\n+\n+        if (admin != null) {\n+            admin.close();\n+        }\n+\n+        admin = spy(PulsarAdmin.builder().serviceHttpUrl(brokerUrlTls.toString())\n+                .useKeyStoreTls(true)\n+                .tlsTrustStorePath(BROKER_TRUSTSTORE_FILE_PATH)\n+                .tlsTrustStorePassword(BROKER_TRUSTSTORE_PW)\n+                .allowTlsInsecureConnection(true)\n+                .authentication(AuthenticationKeyStoreTls.class.getName(), authParams).build());\n+        admin.clusters().createCluster(clusterName, new ClusterData(brokerUrl.toString(), brokerUrlTls.toString(),\n+                pulsar.getBrokerServiceUrl(), pulsar.getBrokerServiceUrlTls()));\n+        admin.tenants().createTenant(\"my-property\",\n+                new TenantInfo(Sets.newHashSet(\"appid1\", \"appid2\"), Sets.newHashSet(\"use\")));\n+        admin.namespaces().createNamespace(\"my-property/my-ns\");\n+    }\n+\n+    /**\n+     * verifies that messages whose size is larger than 2^14 bytes (max size of single TLS chunk) can be\n+     * produced/consumed\n+     *\n+     * @throws Exception\n+     */\n+    @Test(timeOut = 30000)\n+    public void testTlsLargeSizeMessage() throws Exception {\n+        log.info(\"-- Starting {} test --\", methodName);\n+\n+        final int MESSAGE_SIZE = 16 * 1024 + 1;\n+        log.info(\"-- message size --\", MESSAGE_SIZE);\n+        String topicName = \"persistent://my-property/use/my-ns/testTlsLargeSizeMessage\"\n+                           + System.currentTimeMillis();\n+\n+        internalSetUpForClient(true, pulsar.getBrokerServiceUrlTls());\n+        internalSetUpForNamespace();\n+\n+        Consumer<byte[]> consumer = pulsarClient.newConsumer().topic(topicName)\n+                .subscriptionName(\"my-subscriber-name\").subscribe();\n+\n+        Producer<byte[]> producer = pulsarClient.newProducer().topic(topicName)\n+                .create();\n+        for (int i = 0; i < 10; i++) {\n+            byte[] message = new byte[MESSAGE_SIZE];\n+            Arrays.fill(message, (byte) i);\n+            producer.send(message);\n+        }\n+\n+        Message<byte[]> msg = null;\n+        for (int i = 0; i < 10; i++) {\n+            msg = consumer.receive(5, TimeUnit.SECONDS);\n+            byte[] expected = new byte[MESSAGE_SIZE];\n+            Arrays.fill(expected, (byte) i);\n+            Assert.assertEquals(expected, msg.getData());\n+        }\n+        // Acknowledge the consumption of all messages at once\n+        consumer.acknowledgeCumulative(msg);\n+        consumer.close();\n+        log.info(\"-- Exiting {} test --\", methodName);\n+    }\n+\n+    @Test(timeOut = 300000)\n+    public void testTlsClientAuthOverBinaryProtocol() throws Exception {\n+        log.info(\"-- Starting {} test --\", methodName);\n+\n+        final int MESSAGE_SIZE = 16 * 1024 + 1;\n+        log.info(\"-- message size --\", MESSAGE_SIZE);\n+        String topicName = \"persistent://my-property/use/my-ns/testTlsClientAuthOverBinaryProtocol\"\n+                           + System.currentTimeMillis();\n+\n+        internalSetUpForNamespace();\n+\n+//        // Test 1 - Using TLS on binary protocol without sending certs - expect failure", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI0MDk4Mg=="}, "originalCommit": {"oid": "3343e924ab7d0c5f34c1bc00e376c985d7270895"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjY3NTI4OnYy", "diffSide": "RIGHT", "path": "pulsar-client-auth-keystoretls/src/main/java/org/apache/pulsar/client/impl/auth/AuthenticationKeyStoreTls.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwMzozNzowNVrOGSX2zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNjozMDo1NVrOGSav8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkxODQxNA==", "bodyText": "this is another authentication interface and we can avoid adding a new module for just this interface. can we move this interface under pulsar-client", "url": "https://github.com/apache/pulsar/pull/6853#discussion_r421918414", "createdAt": "2020-05-08T03:37:05Z", "author": {"login": "rdhabalia"}, "path": "pulsar-client-auth-keystoretls/src/main/java/org/apache/pulsar/client/impl/auth/AuthenticationKeyStoreTls.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.client.impl.auth;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Strings;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.pulsar.client.api.Authentication;\n+import org.apache.pulsar.client.api.AuthenticationDataProvider;\n+import org.apache.pulsar.client.api.EncodedAuthenticationParameterSupport;\n+import org.apache.pulsar.client.api.KeyStoreParams;\n+import org.apache.pulsar.client.api.PulsarClientException;\n+import org.apache.pulsar.client.impl.AuthenticationUtil;\n+\n+/**\n+ * This plugin requires these parameters: keyStoreType, keyStorePath, and  keyStorePassword.\n+ * This parameter will construct a AuthenticationDataProvider\n+ */\n+@Slf4j\n+public class AuthenticationKeyStoreTls implements Authentication, EncodedAuthenticationParameterSupport {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a7955379127e830282e83149b3db32422b2fe19f"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk2NTgxMQ==", "bodyText": "get it.", "url": "https://github.com/apache/pulsar/pull/6853#discussion_r421965811", "createdAt": "2020-05-08T06:30:55Z", "author": {"login": "jiazhai"}, "path": "pulsar-client-auth-keystoretls/src/main/java/org/apache/pulsar/client/impl/auth/AuthenticationKeyStoreTls.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.client.impl.auth;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Strings;\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.pulsar.client.api.Authentication;\n+import org.apache.pulsar.client.api.AuthenticationDataProvider;\n+import org.apache.pulsar.client.api.EncodedAuthenticationParameterSupport;\n+import org.apache.pulsar.client.api.KeyStoreParams;\n+import org.apache.pulsar.client.api.PulsarClientException;\n+import org.apache.pulsar.client.impl.AuthenticationUtil;\n+\n+/**\n+ * This plugin requires these parameters: keyStoreType, keyStorePath, and  keyStorePassword.\n+ * This parameter will construct a AuthenticationDataProvider\n+ */\n+@Slf4j\n+public class AuthenticationKeyStoreTls implements Authentication, EncodedAuthenticationParameterSupport {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkxODQxNA=="}, "originalCommit": {"oid": "a7955379127e830282e83149b3db32422b2fe19f"}, "originalPosition": 39}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1832, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}