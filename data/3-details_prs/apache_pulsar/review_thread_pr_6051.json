{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyNTk3MzY2", "number": 6051, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQyMToyNTo0OVrODZA6YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQyMToyNzozNFrODZA6pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTU1OTM3OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/AdminApiTest2.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQyMToyNTo0OVrOFfMKJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQyMToyNTo0OVrOFfMKJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI0OTM4Mw==", "bodyText": "don't you need to call #receive to ensure the message is dispatched to the consumer? Otherwise this can easily become a flaky test.", "url": "https://github.com/apache/pulsar/pull/6051#discussion_r368249383", "createdAt": "2020-01-18T21:25:49Z", "author": {"login": "sijie"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/AdminApiTest2.java", "diffHunk": "@@ -948,4 +952,98 @@ public void testCreateNamespaceWithNoClusters() throws PulsarAdminException {\n         assertEquals(admin.namespaces().getNamespaceReplicationClusters(namespace),\n                 Collections.singletonList(localCluster));\n     }\n+\n+    @Test(timeOut = 30000)\n+    public void testConsumerStatsLastTimestamp() throws PulsarClientException, PulsarAdminException, InterruptedException {\n+        long timestamp = System.currentTimeMillis();\n+        final String topicName = \"consumer-stats-\" + timestamp;\n+        final String subscribeName = topicName + \"-test-stats-sub\";\n+        final String topic = \"persistent://prop-xyz/ns1/\" + topicName;\n+        final String producerName = \"producer-\" + topicName;\n+\n+        @Cleanup\n+        PulsarClient client = PulsarClient.builder().serviceUrl(pulsar.getWebServiceAddress()).build();\n+        Producer<byte[]> producer = client.newProducer().topic(topic)\n+            .enableBatching(false)\n+            .producerName(producerName)\n+            .create();\n+\n+        // a. Send a message to the topic.\n+        producer.send(\"message-1\".getBytes(StandardCharsets.UTF_8));\n+\n+        // b. Create a consumer, because there was a message in the topic, the consumer will receive the message pushed\n+        // by the broker, the lastConsumedTimestamp will as the consume subscribe time.\n+        Consumer<byte[]> consumer = client.newConsumer().topic(topic)\n+            .subscriptionName(subscribeName)\n+            .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)\n+            .subscribe();\n+\n+        // Get the consumer stats.\n+        TopicStats topicStats = admin.topics().getStats(topic);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "567e6e5b343da5a4f4285e10b5d9feb2dbc1b389"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTU1OTU3OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/AdminApiTest2.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQyMToyNjoxOVrOFfMKQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQyMToyNjoxOVrOFfMKQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI0OTQwOA==", "bodyText": "move this to the line 979", "url": "https://github.com/apache/pulsar/pull/6051#discussion_r368249408", "createdAt": "2020-01-18T21:26:19Z", "author": {"login": "sijie"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/AdminApiTest2.java", "diffHunk": "@@ -948,4 +952,98 @@ public void testCreateNamespaceWithNoClusters() throws PulsarAdminException {\n         assertEquals(admin.namespaces().getNamespaceReplicationClusters(namespace),\n                 Collections.singletonList(localCluster));\n     }\n+\n+    @Test(timeOut = 30000)\n+    public void testConsumerStatsLastTimestamp() throws PulsarClientException, PulsarAdminException, InterruptedException {\n+        long timestamp = System.currentTimeMillis();\n+        final String topicName = \"consumer-stats-\" + timestamp;\n+        final String subscribeName = topicName + \"-test-stats-sub\";\n+        final String topic = \"persistent://prop-xyz/ns1/\" + topicName;\n+        final String producerName = \"producer-\" + topicName;\n+\n+        @Cleanup\n+        PulsarClient client = PulsarClient.builder().serviceUrl(pulsar.getWebServiceAddress()).build();\n+        Producer<byte[]> producer = client.newProducer().topic(topic)\n+            .enableBatching(false)\n+            .producerName(producerName)\n+            .create();\n+\n+        // a. Send a message to the topic.\n+        producer.send(\"message-1\".getBytes(StandardCharsets.UTF_8));\n+\n+        // b. Create a consumer, because there was a message in the topic, the consumer will receive the message pushed\n+        // by the broker, the lastConsumedTimestamp will as the consume subscribe time.\n+        Consumer<byte[]> consumer = client.newConsumer().topic(topic)\n+            .subscriptionName(subscribeName)\n+            .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)\n+            .subscribe();\n+\n+        // Get the consumer stats.\n+        TopicStats topicStats = admin.topics().getStats(topic);\n+        SubscriptionStats subscriptionStats = topicStats.subscriptions.get(subscribeName);\n+        long startConsumedFlowTimestamp = subscriptionStats.lastConsumedFlowTimestamp;\n+        long startAckedTimestampInSubStats = subscriptionStats.lastAckedTimestamp;\n+        ConsumerStats consumerStats = subscriptionStats.consumers.get(0);\n+        long startConsumedTimestampInConsumerStats = consumerStats.lastConsumedTimestamp;\n+        long startAckedTimestampInConsumerStats = consumerStats.lastAckedTimestamp;\n+\n+        // Because the message was pushed by the broker, the consumedTimestamp should not as 0.\n+        assertNotEquals(0, startConsumedTimestampInConsumerStats);\n+        // There is no consumer ack the message, so the lastAckedTimestamp still as 0.\n+        assertEquals(0, startAckedTimestampInConsumerStats);\n+        assertNotEquals(0, startConsumedFlowTimestamp);\n+        assertEquals(0, startAckedTimestampInSubStats);\n+\n+        // c. The Consumer receives the message and acks the message.\n+        Message<byte[]> message = consumer.receive();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "567e6e5b343da5a4f4285e10b5d9feb2dbc1b389"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTU1OTg0OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/AdminApiTest2.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQyMToyNzoxNlrOFfMKYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQyMToyNzoxNlrOFfMKYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI0OTQ0MA==", "bodyText": "I wouldn't suggest using sleep here. We should periodically getting the consumer stats until the lastAckedTimestamp get updated.", "url": "https://github.com/apache/pulsar/pull/6051#discussion_r368249440", "createdAt": "2020-01-18T21:27:16Z", "author": {"login": "sijie"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/AdminApiTest2.java", "diffHunk": "@@ -948,4 +952,98 @@ public void testCreateNamespaceWithNoClusters() throws PulsarAdminException {\n         assertEquals(admin.namespaces().getNamespaceReplicationClusters(namespace),\n                 Collections.singletonList(localCluster));\n     }\n+\n+    @Test(timeOut = 30000)\n+    public void testConsumerStatsLastTimestamp() throws PulsarClientException, PulsarAdminException, InterruptedException {\n+        long timestamp = System.currentTimeMillis();\n+        final String topicName = \"consumer-stats-\" + timestamp;\n+        final String subscribeName = topicName + \"-test-stats-sub\";\n+        final String topic = \"persistent://prop-xyz/ns1/\" + topicName;\n+        final String producerName = \"producer-\" + topicName;\n+\n+        @Cleanup\n+        PulsarClient client = PulsarClient.builder().serviceUrl(pulsar.getWebServiceAddress()).build();\n+        Producer<byte[]> producer = client.newProducer().topic(topic)\n+            .enableBatching(false)\n+            .producerName(producerName)\n+            .create();\n+\n+        // a. Send a message to the topic.\n+        producer.send(\"message-1\".getBytes(StandardCharsets.UTF_8));\n+\n+        // b. Create a consumer, because there was a message in the topic, the consumer will receive the message pushed\n+        // by the broker, the lastConsumedTimestamp will as the consume subscribe time.\n+        Consumer<byte[]> consumer = client.newConsumer().topic(topic)\n+            .subscriptionName(subscribeName)\n+            .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)\n+            .subscribe();\n+\n+        // Get the consumer stats.\n+        TopicStats topicStats = admin.topics().getStats(topic);\n+        SubscriptionStats subscriptionStats = topicStats.subscriptions.get(subscribeName);\n+        long startConsumedFlowTimestamp = subscriptionStats.lastConsumedFlowTimestamp;\n+        long startAckedTimestampInSubStats = subscriptionStats.lastAckedTimestamp;\n+        ConsumerStats consumerStats = subscriptionStats.consumers.get(0);\n+        long startConsumedTimestampInConsumerStats = consumerStats.lastConsumedTimestamp;\n+        long startAckedTimestampInConsumerStats = consumerStats.lastAckedTimestamp;\n+\n+        // Because the message was pushed by the broker, the consumedTimestamp should not as 0.\n+        assertNotEquals(0, startConsumedTimestampInConsumerStats);\n+        // There is no consumer ack the message, so the lastAckedTimestamp still as 0.\n+        assertEquals(0, startAckedTimestampInConsumerStats);\n+        assertNotEquals(0, startConsumedFlowTimestamp);\n+        assertEquals(0, startAckedTimestampInSubStats);\n+\n+        // c. The Consumer receives the message and acks the message.\n+        Message<byte[]> message = consumer.receive();\n+        consumer.acknowledge(message);\n+        // Waiting for the ack command send to the broker.\n+        TimeUnit.SECONDS.sleep(5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "567e6e5b343da5a4f4285e10b5d9feb2dbc1b389"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTU2MDA0OnYy", "diffSide": "RIGHT", "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/AdminApiTest2.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQyMToyNzozNFrOFfMKeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQyMToyNzozNFrOFfMKeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI0OTQ2NA==", "bodyText": "same comments as above", "url": "https://github.com/apache/pulsar/pull/6051#discussion_r368249464", "createdAt": "2020-01-18T21:27:34Z", "author": {"login": "sijie"}, "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/AdminApiTest2.java", "diffHunk": "@@ -948,4 +952,98 @@ public void testCreateNamespaceWithNoClusters() throws PulsarAdminException {\n         assertEquals(admin.namespaces().getNamespaceReplicationClusters(namespace),\n                 Collections.singletonList(localCluster));\n     }\n+\n+    @Test(timeOut = 30000)\n+    public void testConsumerStatsLastTimestamp() throws PulsarClientException, PulsarAdminException, InterruptedException {\n+        long timestamp = System.currentTimeMillis();\n+        final String topicName = \"consumer-stats-\" + timestamp;\n+        final String subscribeName = topicName + \"-test-stats-sub\";\n+        final String topic = \"persistent://prop-xyz/ns1/\" + topicName;\n+        final String producerName = \"producer-\" + topicName;\n+\n+        @Cleanup\n+        PulsarClient client = PulsarClient.builder().serviceUrl(pulsar.getWebServiceAddress()).build();\n+        Producer<byte[]> producer = client.newProducer().topic(topic)\n+            .enableBatching(false)\n+            .producerName(producerName)\n+            .create();\n+\n+        // a. Send a message to the topic.\n+        producer.send(\"message-1\".getBytes(StandardCharsets.UTF_8));\n+\n+        // b. Create a consumer, because there was a message in the topic, the consumer will receive the message pushed\n+        // by the broker, the lastConsumedTimestamp will as the consume subscribe time.\n+        Consumer<byte[]> consumer = client.newConsumer().topic(topic)\n+            .subscriptionName(subscribeName)\n+            .subscriptionInitialPosition(SubscriptionInitialPosition.Earliest)\n+            .subscribe();\n+\n+        // Get the consumer stats.\n+        TopicStats topicStats = admin.topics().getStats(topic);\n+        SubscriptionStats subscriptionStats = topicStats.subscriptions.get(subscribeName);\n+        long startConsumedFlowTimestamp = subscriptionStats.lastConsumedFlowTimestamp;\n+        long startAckedTimestampInSubStats = subscriptionStats.lastAckedTimestamp;\n+        ConsumerStats consumerStats = subscriptionStats.consumers.get(0);\n+        long startConsumedTimestampInConsumerStats = consumerStats.lastConsumedTimestamp;\n+        long startAckedTimestampInConsumerStats = consumerStats.lastAckedTimestamp;\n+\n+        // Because the message was pushed by the broker, the consumedTimestamp should not as 0.\n+        assertNotEquals(0, startConsumedTimestampInConsumerStats);\n+        // There is no consumer ack the message, so the lastAckedTimestamp still as 0.\n+        assertEquals(0, startAckedTimestampInConsumerStats);\n+        assertNotEquals(0, startConsumedFlowTimestamp);\n+        assertEquals(0, startAckedTimestampInSubStats);\n+\n+        // c. The Consumer receives the message and acks the message.\n+        Message<byte[]> message = consumer.receive();\n+        consumer.acknowledge(message);\n+        // Waiting for the ack command send to the broker.\n+        TimeUnit.SECONDS.sleep(5);\n+\n+        // Get the consumer stats.\n+        topicStats = admin.topics().getStats(topic);\n+        subscriptionStats = topicStats.subscriptions.get(subscribeName);\n+        long consumedFlowTimestamp = subscriptionStats.lastConsumedFlowTimestamp;\n+        long ackedTimestampInSubStats = subscriptionStats.lastAckedTimestamp;\n+        consumerStats = subscriptionStats.consumers.get(0);\n+        long consumedTimestamp = consumerStats.lastConsumedTimestamp;\n+        long ackedTimestamp = consumerStats.lastAckedTimestamp;\n+\n+        // The lastConsumedTimestamp should same as the last time because the broker does not push any messages and the\n+        // consumer does not pull any messages.\n+        assertEquals(startConsumedTimestampInConsumerStats, consumedTimestamp);\n+        assertTrue(startAckedTimestampInConsumerStats < ackedTimestamp);\n+        assertNotEquals(0, consumedFlowTimestamp);\n+        assertTrue(startAckedTimestampInSubStats < ackedTimestampInSubStats);\n+\n+        // d. Send another messages. The lastConsumedTimestamp should be updated.\n+        producer.send(\"message-2\".getBytes(StandardCharsets.UTF_8));\n+\n+        // e. Receive the message and ack it.\n+        message = consumer.receive();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "567e6e5b343da5a4f4285e10b5d9feb2dbc1b389"}, "originalPosition": 97}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2076, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}