{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5NTU0MTcz", "number": 6544, "title": "Implementation of Transaction Buffer Client.", "bodyText": "Motivation\nImplement the transaction buffer client.\nModifications\nVerifying this change\nNew unit tests added\nDoes this pull request potentially affect one of the following parts:\nIf yes was chosen, please highlight the changes\n\nDependencies (does it add or upgrade a dependency): (no)\nThe public API: (no)\nThe schema: (no)\nThe default values of configurations: (no)\nThe wire protocol: (no)\nThe rest endpoints: (no)\nThe admin cli options: (no)\nAnything that affects deployment: (no)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (yes)", "createdAt": "2020-03-17T00:10:39Z", "url": "https://github.com/apache/pulsar/pull/6544", "merged": true, "mergeCommit": {"oid": "054f18b35c3da81878f331689d1a85e29adbf592"}, "closed": true, "closedAt": "2020-07-27T13:12:49Z", "author": {"login": "codelipenghui"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcPMInWgBqjMxNDU2MDUzMDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc4-z-2AH2gAyMzg5NTU0MTczOjNhOWFmZmVjOGQzYzNkOGQ2MjBjOTFjZjE1MTQ0Y2VmZDU4ODAzMmI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a4fc1f6d650466cccd887c7a93149c2f6494797a", "author": {"user": {"login": "codelipenghui", "name": "lipenghui"}}, "url": "https://github.com/apache/pulsar/commit/a4fc1f6d650466cccd887c7a93149c2f6494797a", "committedDate": "2020-03-17T00:06:30Z", "message": "Implementation of Transaction Buffer Client."}, "afterCommit": {"oid": "b318862d6140d57ab3c4e013896a47a414653995", "author": {"user": {"login": "codelipenghui", "name": "lipenghui"}}, "url": "https://github.com/apache/pulsar/commit/b318862d6140d57ab3c4e013896a47a414653995", "committedDate": "2020-03-19T13:42:44Z", "message": "Implementation of Transaction Buffer Client."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MTg5ODgx", "url": "https://github.com/apache/pulsar/pull/6544#pullrequestreview-379189881", "createdAt": "2020-03-23T07:46:59Z", "commit": {"oid": "5d7e81611b92ce7c06e04875f7c3fc28f57c4d60"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwNzo0Njo1OVrOF55w-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwOTo1MzozNVrOF598qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI1OTU3OQ==", "bodyText": "It is time out, so timeTowaitMs  shouldn't  =  operationTimeoutInMills", "url": "https://github.com/apache/pulsar/pull/6544#discussion_r396259579", "createdAt": "2020-03-23T07:46:59Z", "author": {"login": "congbobo184"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/buffer/impl/TransactionBufferHandlerImpl.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.buffer.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.util.HashedWheelTimer;\n+import io.netty.util.Recycler;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.Timeout;\n+import io.netty.util.TimerTask;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.pulsar.broker.namespace.NamespaceService;\n+import org.apache.pulsar.client.api.transaction.TransactionBufferClientException;\n+import org.apache.pulsar.client.impl.ClientCnx;\n+import org.apache.pulsar.client.impl.ConnectionPool;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.client.impl.transaction.TransactionBufferHandler;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.transaction.impl.common.TxnID;\n+\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+@Slf4j\n+public class TransactionBufferHandlerImpl implements TransactionBufferHandler, TimerTask {\n+\n+    private final ConcurrentSkipListMap<Long, OpRequestSend> pendingRequests;\n+    private final ConnectionPool connectionPool;\n+    private final NamespaceService namespaceService;\n+    private final AtomicLong requestIdGenerator = new AtomicLong();\n+    private long operationTimeoutInMills;\n+    private Timeout requestTimeout;\n+    private HashedWheelTimer timer;\n+    private final Semaphore semaphore;\n+    private final boolean blockIfReachMaxPendingOps;\n+\n+    public TransactionBufferHandlerImpl(ConnectionPool connectionPool, NamespaceService namespaceService) {\n+        this.connectionPool = connectionPool;\n+        this.pendingRequests = new ConcurrentSkipListMap<>();\n+        this.namespaceService = namespaceService;\n+        this.operationTimeoutInMills = 3000L;\n+        this.semaphore = new Semaphore(10000);\n+        this.blockIfReachMaxPendingOps = true;\n+        this.timer = new HashedWheelTimer(new DefaultThreadFactory(\"pulsar-transaction-buffer-client-timer\"));\n+        this.requestTimeout = timer.newTimeout(this, operationTimeoutInMills, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @Override\n+    public CompletableFuture<TxnID> endTxnOnTopic(String topic, long txnIdMostBits, long txnIdLeastBits, PulsarApi.TxnAction action) {\n+        CompletableFuture<TxnID> cb = new CompletableFuture<>();\n+        if (!canSendRequest(cb)) {\n+            return cb;\n+        }\n+        long requestId = requestIdGenerator.getAndIncrement();\n+        ByteBuf cmd = Commands.newEndTxnOnPartition(requestId, txnIdLeastBits, txnIdMostBits, topic, action);\n+        OpRequestSend op = OpRequestSend.create(requestId, topic, cmd, cb);\n+        pendingRequests.put(requestId, op);\n+        cmd.retain();\n+        cnx(topic).whenComplete((clientCnx, throwable) -> {\n+            if (throwable == null) {\n+                try {\n+                    clientCnx.ctx().writeAndFlush(cmd, clientCnx.ctx().voidPromise());\n+                } catch (Exception e) {\n+                    cb.completeExceptionally(e);\n+                    pendingRequests.remove(requestId);\n+                    op.recycle();\n+                }\n+            } else {\n+                cb.completeExceptionally(throwable);\n+                pendingRequests.remove(requestId);\n+                op.recycle();\n+            }\n+        });\n+        return cb;\n+    }\n+\n+    @Override\n+    public CompletableFuture<TxnID> endTxnOnSubscription(String topic, String subscription, long txnIdMostBits, long txnIdLeastBits, PulsarApi.TxnAction action) {\n+        CompletableFuture<TxnID> cb = new CompletableFuture<>();\n+        if (!canSendRequest(cb)) {\n+            return cb;\n+        }\n+        long requestId = requestIdGenerator.getAndIncrement();\n+        ByteBuf cmd = Commands.newEndTxnOnSubscription(requestId, txnIdLeastBits, txnIdMostBits, topic, subscription, action);\n+        OpRequestSend op = OpRequestSend.create(requestId, topic, cmd, cb);\n+        pendingRequests.put(requestId, op);\n+        cmd.retain();\n+        cnx(topic).whenComplete((clientCnx, throwable) -> {\n+            if (throwable == null) {\n+                try {\n+                    clientCnx.ctx().writeAndFlush(cmd, clientCnx.ctx().voidPromise());\n+                } catch (Exception e) {\n+                    cb.completeExceptionally(e);\n+                    pendingRequests.remove(requestId);\n+                    op.recycle();\n+                }\n+            } else {\n+                cb.completeExceptionally(throwable);\n+                pendingRequests.remove(requestId);\n+                op.recycle();\n+            }\n+        });\n+        return cb;\n+    }\n+\n+    @Override\n+    public void handleEndTxnOnTopicResponse(long requestId, PulsarApi.CommandEndTxnOnPartitionResponse response) {\n+        OpRequestSend op = pendingRequests.remove(requestId);\n+        if (op == null) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Got end txn on topic response for timeout {} - {}\", response.getTxnidMostBits(),\n+                        response.getTxnidLeastBits());\n+            }\n+            return;\n+        }\n+\n+        if (!response.hasError()) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"[{}] Got end txn on topic response for for request {}\", op.topic, response.getRequestId());\n+            }\n+            op.cb.complete(new TxnID(response.getTxnidMostBits(), response.getTxnidLeastBits()));\n+        } else {\n+            log.error(\"[{}] Got end txn on topic response for request {} error {}\", op.topic, response.getRequestId(), response.getError());\n+            op.cb.completeExceptionally(getException(response.getError(), response.getMessage()));\n+        }\n+        op.recycle();\n+    }\n+\n+    @Override\n+    public void handleEndTxnOnSubscriptionResponse(long requestId, PulsarApi.CommandEndTxnOnSubscriptionResponse response) {\n+        OpRequestSend op = pendingRequests.remove(requestId);\n+        if (op == null) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Got end txn on subscription response for timeout {} - {}\", response.getTxnidMostBits(),\n+                        response.getTxnidLeastBits());\n+            }\n+            return;\n+        }\n+\n+        if (!response.hasError()) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"[{}] Got end txn on subscription response for for request {}\", op.topic, response.getRequestId());\n+            }\n+            op.cb.complete(new TxnID(response.getTxnidMostBits(), response.getTxnidLeastBits()));\n+        } else {\n+            log.error(\"[{}] Got end txn on subscription response for request {} error {}\", op.topic, response.getRequestId(), response.getError());\n+            op.cb.completeExceptionally(getException(response.getError(), response.getMessage()));\n+        }\n+        op.recycle();\n+    }\n+\n+    private CompletableFuture<ClientCnx> cnx(String topic) {\n+        return getServiceUrl(topic).thenCompose(serviceUrl -> {\n+            try {\n+                if (serviceUrl == null) {\n+                    return CompletableFuture.completedFuture(null);\n+                }\n+                URI uri = new URI(serviceUrl);\n+                return connectionPool.getConnection(InetSocketAddress.createUnresolved(uri.getHost(), uri.getPort())).thenCompose(clientCnx -> {\n+                    clientCnx.registerTransactionBufferHandler(TransactionBufferHandlerImpl.this);\n+                    return CompletableFuture.completedFuture(clientCnx);\n+                });\n+            } catch (Exception e) {\n+                return FutureUtil.failedFuture(e);\n+            }\n+        });\n+    }\n+\n+    private CompletableFuture<String> getServiceUrl(String topic) {\n+        TopicName topicName = TopicName.get(topic);\n+        return namespaceService.getBundleAsync(topicName)\n+                .thenCompose(namespaceService::getOwnerAsync)\n+                .thenCompose(ned -> {\n+                    String serviceUrl = null;\n+                    if (ned.isPresent()) {\n+                        serviceUrl = ned.get().getNativeUrl();\n+                    }\n+                   return CompletableFuture.completedFuture(serviceUrl);\n+                });\n+    }\n+\n+    private TransactionBufferClientException getException(PulsarApi.ServerError serverError, String msg) {\n+        return new TransactionBufferClientException(msg);\n+    }\n+\n+    private boolean canSendRequest(CompletableFuture<?> callback) {\n+        try {\n+            if (blockIfReachMaxPendingOps) {\n+                semaphore.acquire();\n+            } else {\n+                if (!semaphore.tryAcquire()) {\n+                    callback.completeExceptionally(new TransactionBufferClientException(\"Reach max pending ops.\"));\n+                    return false;\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            callback.completeExceptionally(TransactionBufferClientException.unwrap(e));\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void run(Timeout timeout) throws Exception {\n+        if (timeout.isCancelled()) {\n+            return;\n+        }\n+        long timeToWaitMs;\n+        OpRequestSend peeked = null;\n+        Map.Entry<Long, OpRequestSend> firstEntry = pendingRequests.firstEntry();\n+        peeked = firstEntry == null ? null : firstEntry.getValue();\n+        while (peeked != null && peeked.createdAt + operationTimeoutInMills - System.currentTimeMillis() <= 0) {\n+            if (!peeked.cb.isDone()) {\n+                peeked.cb.completeExceptionally(new TransactionBufferClientException.RequestTimeoutException());\n+                onResponse(peeked);\n+            } else {\n+                break;\n+            }\n+            firstEntry = pendingRequests.firstEntry();\n+            peeked = firstEntry == null ? null : firstEntry.getValue();\n+        }\n+        if (peeked == null) {\n+            timeToWaitMs = operationTimeoutInMills;\n+        } else {\n+            long diff = (peeked.createdAt + operationTimeoutInMills) - System.currentTimeMillis();\n+            if (diff <= 0) {\n+                timeToWaitMs = operationTimeoutInMills;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d7e81611b92ce7c06e04875f7c3fc28f57c4d60"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMyODEwNw==", "bodyText": "I think  clientCnx.ctx().writeAndFlush(cmd, clientCnx.ctx().voidPromise());  should .addListener", "url": "https://github.com/apache/pulsar/pull/6544#discussion_r396328107", "createdAt": "2020-03-23T09:53:35Z", "author": {"login": "congbobo184"}, "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/transaction/buffer/impl/TransactionBufferHandlerImpl.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.transaction.buffer.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.util.HashedWheelTimer;\n+import io.netty.util.Recycler;\n+import io.netty.util.ReferenceCountUtil;\n+import io.netty.util.Timeout;\n+import io.netty.util.TimerTask;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.pulsar.broker.namespace.NamespaceService;\n+import org.apache.pulsar.client.api.transaction.TransactionBufferClientException;\n+import org.apache.pulsar.client.impl.ClientCnx;\n+import org.apache.pulsar.client.impl.ConnectionPool;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.client.impl.transaction.TransactionBufferHandler;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.transaction.impl.common.TxnID;\n+\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+@Slf4j\n+public class TransactionBufferHandlerImpl implements TransactionBufferHandler, TimerTask {\n+\n+    private final ConcurrentSkipListMap<Long, OpRequestSend> pendingRequests;\n+    private final ConnectionPool connectionPool;\n+    private final NamespaceService namespaceService;\n+    private final AtomicLong requestIdGenerator = new AtomicLong();\n+    private long operationTimeoutInMills;\n+    private Timeout requestTimeout;\n+    private HashedWheelTimer timer;\n+    private final Semaphore semaphore;\n+    private final boolean blockIfReachMaxPendingOps;\n+\n+    public TransactionBufferHandlerImpl(ConnectionPool connectionPool, NamespaceService namespaceService) {\n+        this.connectionPool = connectionPool;\n+        this.pendingRequests = new ConcurrentSkipListMap<>();\n+        this.namespaceService = namespaceService;\n+        this.operationTimeoutInMills = 3000L;\n+        this.semaphore = new Semaphore(10000);\n+        this.blockIfReachMaxPendingOps = true;\n+        this.timer = new HashedWheelTimer(new DefaultThreadFactory(\"pulsar-transaction-buffer-client-timer\"));\n+        this.requestTimeout = timer.newTimeout(this, operationTimeoutInMills, TimeUnit.MILLISECONDS);\n+    }\n+\n+    @Override\n+    public CompletableFuture<TxnID> endTxnOnTopic(String topic, long txnIdMostBits, long txnIdLeastBits, PulsarApi.TxnAction action) {\n+        CompletableFuture<TxnID> cb = new CompletableFuture<>();\n+        if (!canSendRequest(cb)) {\n+            return cb;\n+        }\n+        long requestId = requestIdGenerator.getAndIncrement();\n+        ByteBuf cmd = Commands.newEndTxnOnPartition(requestId, txnIdLeastBits, txnIdMostBits, topic, action);\n+        OpRequestSend op = OpRequestSend.create(requestId, topic, cmd, cb);\n+        pendingRequests.put(requestId, op);\n+        cmd.retain();\n+        cnx(topic).whenComplete((clientCnx, throwable) -> {\n+            if (throwable == null) {\n+                try {\n+                    clientCnx.ctx().writeAndFlush(cmd, clientCnx.ctx().voidPromise());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d7e81611b92ce7c06e04875f7c3fc28f57c4d60"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "510c8c5c7e1c762f060c26b10b456b1b2d8e5548", "author": {"user": {"login": "codelipenghui", "name": "lipenghui"}}, "url": "https://github.com/apache/pulsar/commit/510c8c5c7e1c762f060c26b10b456b1b2d8e5548", "committedDate": "2020-05-22T10:26:10Z", "message": "Implementation of Transaction Buffer Client."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b52b347b50ff7c37affc4a0658d822c52eff8885", "author": {"user": {"login": "codelipenghui", "name": "lipenghui"}}, "url": "https://github.com/apache/pulsar/commit/b52b347b50ff7c37affc4a0658d822c52eff8885", "committedDate": "2020-05-22T10:26:10Z", "message": "Fix check style."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9c99102a620610bcd73da647d35d1d68fe86fae", "author": {"user": {"login": "codelipenghui", "name": "lipenghui"}}, "url": "https://github.com/apache/pulsar/commit/f9c99102a620610bcd73da647d35d1d68fe86fae", "committedDate": "2020-05-22T10:26:10Z", "message": "add license header"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5d7e81611b92ce7c06e04875f7c3fc28f57c4d60", "author": {"user": {"login": "codelipenghui", "name": "lipenghui"}}, "url": "https://github.com/apache/pulsar/commit/5d7e81611b92ce7c06e04875f7c3fc28f57c4d60", "committedDate": "2020-03-20T02:21:38Z", "message": "add license header"}, "afterCommit": {"oid": "f9c99102a620610bcd73da647d35d1d68fe86fae", "author": {"user": {"login": "codelipenghui", "name": "lipenghui"}}, "url": "https://github.com/apache/pulsar/commit/f9c99102a620610bcd73da647d35d1d68fe86fae", "committedDate": "2020-05-22T10:26:10Z", "message": "add license header"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyMjU2MzUy", "url": "https://github.com/apache/pulsar/pull/6544#pullrequestreview-452256352", "createdAt": "2020-07-21T08:53:10Z", "commit": {"oid": "f9c99102a620610bcd73da647d35d1d68fe86fae"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyMjU5MjIz", "url": "https://github.com/apache/pulsar/pull/6544#pullrequestreview-452259223", "createdAt": "2020-07-21T08:56:40Z", "commit": {"oid": "f9c99102a620610bcd73da647d35d1d68fe86fae"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba2ff3deae4fc2d0f9d61b8b309df329ebbcc4aa", "author": {"user": {"login": "codelipenghui", "name": "lipenghui"}}, "url": "https://github.com/apache/pulsar/commit/ba2ff3deae4fc2d0f9d61b8b309df329ebbcc4aa", "committedDate": "2020-07-21T08:58:10Z", "message": "Merge remote-tracking branch 'apache/master' into txn_buffer_client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86a22fdb120ecfd4fd12797d0bcfc896cb7c6599", "author": {"user": {"login": "codelipenghui", "name": "lipenghui"}}, "url": "https://github.com/apache/pulsar/commit/86a22fdb120ecfd4fd12797d0bcfc896cb7c6599", "committedDate": "2020-07-21T09:14:42Z", "message": "fix  tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4740050be1f802310fbd6c6d046f8984ef8e098", "author": {"user": {"login": "codelipenghui", "name": "lipenghui"}}, "url": "https://github.com/apache/pulsar/commit/a4740050be1f802310fbd6c6d046f8984ef8e098", "committedDate": "2020-07-23T08:31:16Z", "message": "Merge remote-tracking branch 'apache/master' into txn_buffer_client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a9affec8d3c3d8d620c91cf15144cefd588032b", "author": {"user": {"login": "codelipenghui", "name": "lipenghui"}}, "url": "https://github.com/apache/pulsar/commit/3a9affec8d3c3d8d620c91cf15144cefd588032b", "committedDate": "2020-07-27T09:56:44Z", "message": "Merge remote-tracking branch 'apache/master' into txn_buffer_client"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 16, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}