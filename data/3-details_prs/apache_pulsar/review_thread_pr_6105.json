{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1MDg1NzAw", "number": 6105, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDo1MToyMVrODt5iEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQwNTowMzozNVrODzUjXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDU1MTIxOnYy", "diffSide": "RIGHT", "path": "pulsar-function-go/pf/stats_test.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDo1MToyMVrOF_lv-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQwNDo1Njo0OVrOGHyNEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyMzA5OA==", "bodyText": "Could this be removed?", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r402223098", "createdAt": "2020-04-02T10:51:21Z", "author": {"login": "jiazhai"}, "path": "pulsar-function-go/pf/stats_test.go", "diffHunk": "@@ -0,0 +1,222 @@\n+//\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+//\n+\n+package pf\n+\n+import (\n+\t\"fmt\"\n+\t\"math\"\n+\t\"testing\"\n+\n+\t\"github.com/golang/protobuf/proto\"\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\tio_prometheus_client \"github.com/prometheus/client_model/go\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+/*func test(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73e3c922c7c5192424e82ba5a53d85e53b930d26"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxNTc2Mg==", "bodyText": "@devinbost please remove these comments if we don't need the test case", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r410815762", "createdAt": "2020-04-19T04:56:49Z", "author": {"login": "wolfstudy"}, "path": "pulsar-function-go/pf/stats_test.go", "diffHunk": "@@ -0,0 +1,222 @@\n+//\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+//\n+\n+package pf\n+\n+import (\n+\t\"fmt\"\n+\t\"math\"\n+\t\"testing\"\n+\n+\t\"github.com/golang/protobuf/proto\"\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\tio_prometheus_client \"github.com/prometheus/client_model/go\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+/*func test(){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyMzA5OA=="}, "originalCommit": {"oid": "73e3c922c7c5192424e82ba5a53d85e53b930d26"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDU1MzE0OnYy", "diffSide": "RIGHT", "path": "pulsar-function-go/pf/stats.go", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDo1MTo1OVrOF_lxMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDo1MTo1OVrOF_lxMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyMzQwOA==", "bodyText": "Could this be removed?", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r402223408", "createdAt": "2020-04-02T10:51:59Z", "author": {"login": "jiazhai"}, "path": "pulsar-function-go/pf/stats.go", "diffHunk": "@@ -0,0 +1,316 @@\n+//\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+//\n+\n+package pf\n+\n+import (\n+\t\"strconv\"\n+\t\"time\"\n+\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\tio_prometheus_client \"github.com/prometheus/client_model/go\"\n+\t//\"strings\"\n+\t//\"github.com/prometheus/common/expfmt\"\n+\t//\"time\"\n+)\n+\n+var metricsLabelNames = []string{\"tenant\", \"namespace\", \"name\", \"instance_id\", \"cluster\", \"fqfn\"}\n+var exceptionLabelNames = []string{\"error\", \"ts\"}\n+var exceptionMetricsLabelNames = append(metricsLabelNames, exceptionLabelNames...)\n+\n+const (\n+\tPulsarFunctionMetricsPrefix = \"pulsar_function_\"\n+\n+\tTotalSuccessfullyProcessed = \"processed_successfully_total\"\n+\tTotalSystemExceptions      = \"system_exceptions_total\"\n+\tTotalUserExceptions        = \"user_exceptions_total\"\n+\tProcessLatencyMs           = \"process_latency_ms\"\n+\tLastInvocation             = \"last_invocation\"\n+\tTotalReceived              = \"received_total\"\n+\n+\tTotalSuccessfullyProcessed1min = \"processed_successfully_total_1min\"\n+\tTotalSystemExceptions1min      = \"system_exceptions_total_1min\"\n+\tTotalUserExceptions1min        = \"user_exceptions_total_1min\"\n+\tProcessLatencyMs1min           = \"process_latency_ms_1min\"\n+\tTotalReceived1min              = \"received_total_1min\"\n+)\n+\n+// Declare Prometheus\n+var statTotalProcessedSuccessfully = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalSuccessfullyProcessed,\n+\t\tHelp: \"Total number of messages processed successfully.\"},\n+\tmetricsLabelNames)\n+var statTotalSysExceptions = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalSystemExceptions,\n+\t\tHelp: \"Total number of system exceptions.\"},\n+\tmetricsLabelNames)\n+var statTotalUserExceptions = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalUserExceptions,\n+\t\tHelp: \"Total number of user exceptions.\"},\n+\tmetricsLabelNames)\n+\n+var statProcessLatencyMs = prometheus.NewSummaryVec(\n+\tprometheus.SummaryOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + ProcessLatencyMs,\n+\t\tHelp: \"Process latency in milliseconds.\"}, metricsLabelNames)\n+\n+var statLastInvocation = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + LastInvocation,\n+\t\tHelp: \"The timestamp of the last invocation of the function.\"}, metricsLabelNames)\n+\n+var statTotalReceived = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalReceived,\n+\t\tHelp: \"Total number of messages received from source.\"}, metricsLabelNames)\n+\n+// 1min windowed metrics\n+var statTotalProcessedSuccessfully1min = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalSuccessfullyProcessed1min,\n+\t\tHelp: \"Total number of messages processed successfully in the last 1 minute.\"}, metricsLabelNames)\n+var statTotalSysExceptions1min = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalSystemExceptions1min,\n+\t\tHelp: \"Total number of system exceptions in the last 1 minute.\"},\n+\tmetricsLabelNames)\n+var statTotalUserExceptions1min = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalUserExceptions1min,\n+\t\tHelp: \"Total number of user exceptions in the last 1 minute.\"},\n+\tmetricsLabelNames)\n+\n+var statProcessLatencyMs1min = prometheus.NewSummaryVec(\n+\tprometheus.SummaryOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + ProcessLatencyMs1min,\n+\t\tHelp: \"Process latency in milliseconds in the last 1 minute.\"}, metricsLabelNames)\n+\n+var statTotalReceived1min = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalReceived1min,\n+\t\tHelp: \"Total number of messages received from source in the last 1 minute.\"}, metricsLabelNames)\n+\n+// exceptions\n+var userExceptions = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + \"user_exception\",\n+\t\tHelp: \"Exception from user code.\"}, exceptionMetricsLabelNames)\n+\n+var systemExceptions = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + \"system_exception\",\n+\t\tHelp: \"Exception from system code.\"}, exceptionMetricsLabelNames)\n+\n+var reg *prometheus.Registry\n+\n+func init() {\n+\treg = prometheus.NewRegistry()\n+\treg.MustRegister(statTotalProcessedSuccessfully)\n+\treg.MustRegister(statTotalSysExceptions)\n+\treg.MustRegister(statTotalUserExceptions)\n+\treg.MustRegister(statProcessLatencyMs)\n+\treg.MustRegister(statLastInvocation)\n+\treg.MustRegister(statTotalReceived)\n+\treg.MustRegister(statTotalProcessedSuccessfully1min)\n+\treg.MustRegister(statTotalSysExceptions1min)\n+\treg.MustRegister(statTotalUserExceptions1min)\n+\treg.MustRegister(statProcessLatencyMs1min)\n+\treg.MustRegister(statTotalReceived1min)\n+\treg.MustRegister(userExceptions)\n+\treg.MustRegister(systemExceptions)\n+\n+}\n+\n+type LatestException struct {\n+\texception error\n+\ttimestamp int64\n+}\n+\n+// Be sure to use the constructor method: NewStatWithLabelValues\n+type StatWithLabelValues struct {\n+\tstatTotalProcessedSuccessfully     prometheus.Gauge\n+\tstatTotalSysExceptions             prometheus.Gauge\n+\tstatTotalUserExceptions            prometheus.Gauge\n+\tstatProcessLatencyMs               prometheus.Observer\n+\tstatLastInvocation                 prometheus.Gauge\n+\tstatTotalReceived                  prometheus.Gauge\n+\tstatTotalProcessedSuccessfully1min prometheus.Gauge\n+\tstatTotalSysExceptions1min         prometheus.Gauge\n+\tstatTotalUserExceptions1min        prometheus.Gauge\n+\t//_stat_process_latency_ms_1min prometheus.Observer\n+\tstatTotalReceived1min prometheus.Gauge\n+\tlatestUserException   []LatestException\n+\tlatestSysException    []LatestException\n+\tprocessStartTime      int64\n+\tmetricsLabels         []string\n+}\n+\n+func NewStatWithLabelValues(metricsLabels ...string) StatWithLabelValues {\n+\t// as optimization\n+\tvar statTotalProcessedSuccessfully = statTotalProcessedSuccessfully.WithLabelValues(metricsLabels...)\n+\tvar statTotalSysExceptions = statTotalSysExceptions.WithLabelValues(metricsLabels...)\n+\tvar statTotalUserExceptions = statTotalUserExceptions.WithLabelValues(metricsLabels...)\n+\tvar statProcessLatencyMs = statProcessLatencyMs.WithLabelValues(metricsLabels...)\n+\tvar statLastInvocation = statLastInvocation.WithLabelValues(metricsLabels...)\n+\tvar statTotalReceived = statTotalReceived.WithLabelValues(metricsLabels...)\n+\tvar statTotalProcessedSuccessfully1min = statTotalProcessedSuccessfully1min.WithLabelValues(metricsLabels...)\n+\tvar statTotalSysExceptions1min = statTotalSysExceptions1min.WithLabelValues(metricsLabels...)\n+\tvar statTotalUserExceptions1min = statTotalUserExceptions1min.WithLabelValues(metricsLabels...)\n+\t//var _stat_process_latency_ms_1min = stat_process_latency_ms_1min.WithLabelValues(metrics_labels...)\n+\tvar statTotalReceived1min = statTotalReceived1min.WithLabelValues(metricsLabels...)\n+\n+\tstatObj := StatWithLabelValues{\n+\t\tstatTotalProcessedSuccessfully,\n+\t\tstatTotalSysExceptions,\n+\t\tstatTotalUserExceptions,\n+\t\tstatProcessLatencyMs,\n+\t\tstatLastInvocation,\n+\t\tstatTotalReceived,\n+\t\tstatTotalProcessedSuccessfully1min,\n+\t\tstatTotalSysExceptions1min,\n+\t\tstatTotalUserExceptions1min,\n+\t\t//_stat_process_latency_ms_1min,\n+\t\tstatTotalReceived1min,\n+\t\t[]LatestException{},\n+\t\t[]LatestException{},\n+\t\t0,\n+\t\tmetricsLabels,\n+\t}\n+\treturn statObj\n+}\n+\n+func filter(\n+\tss []*io_prometheus_client.MetricFamily,\n+\ttest func(*io_prometheus_client.MetricFamily) bool) (ret []*io_prometheus_client.MetricFamily) {\n+\tfor _, s := range ss {\n+\t\tif test(s) {\n+\t\t\tret = append(ret, s)\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+func getFirstMatch(\n+\tmetrics []*io_prometheus_client.Metric,\n+\ttest func(*io_prometheus_client.LabelPair) bool) *io_prometheus_client.Metric {\n+\tfor _, met := range metrics {\n+\t\tfor _, lbl := range met.Label {\n+\t\t\tif test(lbl) {\n+\t\t\t\treturn met\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (stat *StatWithLabelValues) setLastInvocation() {\n+\tnow := time.Now()\n+\tstat.statLastInvocation.Set(float64(now.UnixNano()))\n+}\n+\n+func (stat *StatWithLabelValues) processTimeStart() {\n+\tnow := time.Now()\n+\tstat.processStartTime = now.UnixNano()\n+}\n+\n+func (stat *StatWithLabelValues) processTimeEnd() {\n+\tif stat.processStartTime != 0 {\n+\t\tnow := time.Now()\n+\t\tduration := now.UnixNano() - stat.processStartTime\n+\t\tstat.statProcessLatencyMs.Observe(float64(duration))\n+\t\t//stat._stat_process_latency_ms_1min.Observe(float64(duration))\n+\t}\n+}\n+\n+func (stat *StatWithLabelValues) incrTotalUserExceptions(err error) {\n+\tstat.statTotalUserExceptions.Inc()\n+\tstat.statTotalUserExceptions1min.Inc()\n+\tstat.addUserException(err)\n+}\n+\n+func (stat *StatWithLabelValues) addUserException(err error) {\n+\tnow := time.Now()\n+\tts := now.UnixNano()\n+\terrorTs := LatestException{err, ts}\n+\tstat.latestUserException = append(stat.latestUserException, errorTs)\n+\tif len(stat.latestUserException) > 10 {\n+\t\tstat.latestUserException = stat.latestUserException[1:]\n+\t}\n+\t// report exception via prometheus\n+\tstat.reportUserExceptionPrometheus(err, ts)\n+}\n+\n+//@limits(calls=5, period=60)\n+func (stat *StatWithLabelValues) reportUserExceptionPrometheus(exception error, ts int64) {\n+\terrorTs := []string{exception.Error(), strconv.FormatInt(ts, 10)}\n+\texceptionMetricLabels := append(stat.metricsLabels, errorTs...)\n+\tuserExceptions.WithLabelValues(exceptionMetricLabels...).Set(1.0)\n+}\n+\n+func (stat *StatWithLabelValues) incrTotalProcessedSuccessfully() {\n+\tstat.statTotalProcessedSuccessfully.Inc()\n+\tstat.statTotalProcessedSuccessfully1min.Inc()\n+}\n+\n+func (stat *StatWithLabelValues) incrTotalSysExceptions(exception error) {\n+\tstat.statTotalSysExceptions.Inc()\n+\tstat.statTotalSysExceptions1min.Inc()\n+\tstat.addSysException(exception)\n+}\n+\n+func (stat *StatWithLabelValues) addSysException(exception error) {\n+\tnow := time.Now()\n+\tts := now.UnixNano()\n+\terrorTs := LatestException{exception, ts}\n+\tstat.latestSysException = append(stat.latestSysException, errorTs)\n+\tif len(stat.latestSysException) > 10 {\n+\t\tstat.latestSysException = stat.latestSysException[1:]\n+\t}\n+\t// report exception via prometheus\n+\tstat.reportSystemExceptionPrometheus(exception, ts)\n+}\n+\n+//@limits(calls=5, period=60)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73e3c922c7c5192424e82ba5a53d85e53b930d26"}, "originalPosition": 292}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDU1NDU1OnYy", "diffSide": "RIGHT", "path": "pulsar-function-go/pf/stats.go", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDo1MjoyOFrOF_lyGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDo1MjoyOFrOF_lyGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyMzY0Mw==", "bodyText": "could this be removed?", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r402223643", "createdAt": "2020-04-02T10:52:28Z", "author": {"login": "jiazhai"}, "path": "pulsar-function-go/pf/stats.go", "diffHunk": "@@ -0,0 +1,316 @@\n+//\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+//\n+\n+package pf\n+\n+import (\n+\t\"strconv\"\n+\t\"time\"\n+\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\tio_prometheus_client \"github.com/prometheus/client_model/go\"\n+\t//\"strings\"\n+\t//\"github.com/prometheus/common/expfmt\"\n+\t//\"time\"\n+)\n+\n+var metricsLabelNames = []string{\"tenant\", \"namespace\", \"name\", \"instance_id\", \"cluster\", \"fqfn\"}\n+var exceptionLabelNames = []string{\"error\", \"ts\"}\n+var exceptionMetricsLabelNames = append(metricsLabelNames, exceptionLabelNames...)\n+\n+const (\n+\tPulsarFunctionMetricsPrefix = \"pulsar_function_\"\n+\n+\tTotalSuccessfullyProcessed = \"processed_successfully_total\"\n+\tTotalSystemExceptions      = \"system_exceptions_total\"\n+\tTotalUserExceptions        = \"user_exceptions_total\"\n+\tProcessLatencyMs           = \"process_latency_ms\"\n+\tLastInvocation             = \"last_invocation\"\n+\tTotalReceived              = \"received_total\"\n+\n+\tTotalSuccessfullyProcessed1min = \"processed_successfully_total_1min\"\n+\tTotalSystemExceptions1min      = \"system_exceptions_total_1min\"\n+\tTotalUserExceptions1min        = \"user_exceptions_total_1min\"\n+\tProcessLatencyMs1min           = \"process_latency_ms_1min\"\n+\tTotalReceived1min              = \"received_total_1min\"\n+)\n+\n+// Declare Prometheus\n+var statTotalProcessedSuccessfully = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalSuccessfullyProcessed,\n+\t\tHelp: \"Total number of messages processed successfully.\"},\n+\tmetricsLabelNames)\n+var statTotalSysExceptions = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalSystemExceptions,\n+\t\tHelp: \"Total number of system exceptions.\"},\n+\tmetricsLabelNames)\n+var statTotalUserExceptions = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalUserExceptions,\n+\t\tHelp: \"Total number of user exceptions.\"},\n+\tmetricsLabelNames)\n+\n+var statProcessLatencyMs = prometheus.NewSummaryVec(\n+\tprometheus.SummaryOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + ProcessLatencyMs,\n+\t\tHelp: \"Process latency in milliseconds.\"}, metricsLabelNames)\n+\n+var statLastInvocation = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + LastInvocation,\n+\t\tHelp: \"The timestamp of the last invocation of the function.\"}, metricsLabelNames)\n+\n+var statTotalReceived = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalReceived,\n+\t\tHelp: \"Total number of messages received from source.\"}, metricsLabelNames)\n+\n+// 1min windowed metrics\n+var statTotalProcessedSuccessfully1min = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalSuccessfullyProcessed1min,\n+\t\tHelp: \"Total number of messages processed successfully in the last 1 minute.\"}, metricsLabelNames)\n+var statTotalSysExceptions1min = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalSystemExceptions1min,\n+\t\tHelp: \"Total number of system exceptions in the last 1 minute.\"},\n+\tmetricsLabelNames)\n+var statTotalUserExceptions1min = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalUserExceptions1min,\n+\t\tHelp: \"Total number of user exceptions in the last 1 minute.\"},\n+\tmetricsLabelNames)\n+\n+var statProcessLatencyMs1min = prometheus.NewSummaryVec(\n+\tprometheus.SummaryOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + ProcessLatencyMs1min,\n+\t\tHelp: \"Process latency in milliseconds in the last 1 minute.\"}, metricsLabelNames)\n+\n+var statTotalReceived1min = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + TotalReceived1min,\n+\t\tHelp: \"Total number of messages received from source in the last 1 minute.\"}, metricsLabelNames)\n+\n+// exceptions\n+var userExceptions = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + \"user_exception\",\n+\t\tHelp: \"Exception from user code.\"}, exceptionMetricsLabelNames)\n+\n+var systemExceptions = prometheus.NewGaugeVec(\n+\tprometheus.GaugeOpts{\n+\t\tName: PulsarFunctionMetricsPrefix + \"system_exception\",\n+\t\tHelp: \"Exception from system code.\"}, exceptionMetricsLabelNames)\n+\n+var reg *prometheus.Registry\n+\n+func init() {\n+\treg = prometheus.NewRegistry()\n+\treg.MustRegister(statTotalProcessedSuccessfully)\n+\treg.MustRegister(statTotalSysExceptions)\n+\treg.MustRegister(statTotalUserExceptions)\n+\treg.MustRegister(statProcessLatencyMs)\n+\treg.MustRegister(statLastInvocation)\n+\treg.MustRegister(statTotalReceived)\n+\treg.MustRegister(statTotalProcessedSuccessfully1min)\n+\treg.MustRegister(statTotalSysExceptions1min)\n+\treg.MustRegister(statTotalUserExceptions1min)\n+\treg.MustRegister(statProcessLatencyMs1min)\n+\treg.MustRegister(statTotalReceived1min)\n+\treg.MustRegister(userExceptions)\n+\treg.MustRegister(systemExceptions)\n+\n+}\n+\n+type LatestException struct {\n+\texception error\n+\ttimestamp int64\n+}\n+\n+// Be sure to use the constructor method: NewStatWithLabelValues\n+type StatWithLabelValues struct {\n+\tstatTotalProcessedSuccessfully     prometheus.Gauge\n+\tstatTotalSysExceptions             prometheus.Gauge\n+\tstatTotalUserExceptions            prometheus.Gauge\n+\tstatProcessLatencyMs               prometheus.Observer\n+\tstatLastInvocation                 prometheus.Gauge\n+\tstatTotalReceived                  prometheus.Gauge\n+\tstatTotalProcessedSuccessfully1min prometheus.Gauge\n+\tstatTotalSysExceptions1min         prometheus.Gauge\n+\tstatTotalUserExceptions1min        prometheus.Gauge\n+\t//_stat_process_latency_ms_1min prometheus.Observer\n+\tstatTotalReceived1min prometheus.Gauge\n+\tlatestUserException   []LatestException\n+\tlatestSysException    []LatestException\n+\tprocessStartTime      int64\n+\tmetricsLabels         []string\n+}\n+\n+func NewStatWithLabelValues(metricsLabels ...string) StatWithLabelValues {\n+\t// as optimization\n+\tvar statTotalProcessedSuccessfully = statTotalProcessedSuccessfully.WithLabelValues(metricsLabels...)\n+\tvar statTotalSysExceptions = statTotalSysExceptions.WithLabelValues(metricsLabels...)\n+\tvar statTotalUserExceptions = statTotalUserExceptions.WithLabelValues(metricsLabels...)\n+\tvar statProcessLatencyMs = statProcessLatencyMs.WithLabelValues(metricsLabels...)\n+\tvar statLastInvocation = statLastInvocation.WithLabelValues(metricsLabels...)\n+\tvar statTotalReceived = statTotalReceived.WithLabelValues(metricsLabels...)\n+\tvar statTotalProcessedSuccessfully1min = statTotalProcessedSuccessfully1min.WithLabelValues(metricsLabels...)\n+\tvar statTotalSysExceptions1min = statTotalSysExceptions1min.WithLabelValues(metricsLabels...)\n+\tvar statTotalUserExceptions1min = statTotalUserExceptions1min.WithLabelValues(metricsLabels...)\n+\t//var _stat_process_latency_ms_1min = stat_process_latency_ms_1min.WithLabelValues(metrics_labels...)\n+\tvar statTotalReceived1min = statTotalReceived1min.WithLabelValues(metricsLabels...)\n+\n+\tstatObj := StatWithLabelValues{\n+\t\tstatTotalProcessedSuccessfully,\n+\t\tstatTotalSysExceptions,\n+\t\tstatTotalUserExceptions,\n+\t\tstatProcessLatencyMs,\n+\t\tstatLastInvocation,\n+\t\tstatTotalReceived,\n+\t\tstatTotalProcessedSuccessfully1min,\n+\t\tstatTotalSysExceptions1min,\n+\t\tstatTotalUserExceptions1min,\n+\t\t//_stat_process_latency_ms_1min,\n+\t\tstatTotalReceived1min,\n+\t\t[]LatestException{},\n+\t\t[]LatestException{},\n+\t\t0,\n+\t\tmetricsLabels,\n+\t}\n+\treturn statObj\n+}\n+\n+func filter(\n+\tss []*io_prometheus_client.MetricFamily,\n+\ttest func(*io_prometheus_client.MetricFamily) bool) (ret []*io_prometheus_client.MetricFamily) {\n+\tfor _, s := range ss {\n+\t\tif test(s) {\n+\t\t\tret = append(ret, s)\n+\t\t}\n+\t}\n+\treturn\n+}\n+\n+func getFirstMatch(\n+\tmetrics []*io_prometheus_client.Metric,\n+\ttest func(*io_prometheus_client.LabelPair) bool) *io_prometheus_client.Metric {\n+\tfor _, met := range metrics {\n+\t\tfor _, lbl := range met.Label {\n+\t\t\tif test(lbl) {\n+\t\t\t\treturn met\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (stat *StatWithLabelValues) setLastInvocation() {\n+\tnow := time.Now()\n+\tstat.statLastInvocation.Set(float64(now.UnixNano()))\n+}\n+\n+func (stat *StatWithLabelValues) processTimeStart() {\n+\tnow := time.Now()\n+\tstat.processStartTime = now.UnixNano()\n+}\n+\n+func (stat *StatWithLabelValues) processTimeEnd() {\n+\tif stat.processStartTime != 0 {\n+\t\tnow := time.Now()\n+\t\tduration := now.UnixNano() - stat.processStartTime\n+\t\tstat.statProcessLatencyMs.Observe(float64(duration))\n+\t\t//stat._stat_process_latency_ms_1min.Observe(float64(duration))\n+\t}\n+}\n+\n+func (stat *StatWithLabelValues) incrTotalUserExceptions(err error) {\n+\tstat.statTotalUserExceptions.Inc()\n+\tstat.statTotalUserExceptions1min.Inc()\n+\tstat.addUserException(err)\n+}\n+\n+func (stat *StatWithLabelValues) addUserException(err error) {\n+\tnow := time.Now()\n+\tts := now.UnixNano()\n+\terrorTs := LatestException{err, ts}\n+\tstat.latestUserException = append(stat.latestUserException, errorTs)\n+\tif len(stat.latestUserException) > 10 {\n+\t\tstat.latestUserException = stat.latestUserException[1:]\n+\t}\n+\t// report exception via prometheus\n+\tstat.reportUserExceptionPrometheus(err, ts)\n+}\n+\n+//@limits(calls=5, period=60)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73e3c922c7c5192424e82ba5a53d85e53b930d26"}, "originalPosition": 262}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NDU2NTA0OnYy", "diffSide": "RIGHT", "path": "pulsar-function-go/pf/instance.go", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxMDo1NTo0NFrOF_l4lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxNzowNjo0NFrOGDhm7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyNTMwMw==", "bodyText": "Do we still need this?", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r402225303", "createdAt": "2020-04-02T10:55:44Z", "author": {"login": "jiazhai"}, "path": "pulsar-function-go/pf/instance.go", "diffHunk": "@@ -374,17 +409,201 @@ func (gi *goInstance) healthCheck() *pb.HealthCheckResult {\n }\n \n func (gi *goInstance) getFunctionStatus() *pb.FunctionStatus {\n-\treturn nil // Not implemented until we add the statistics features\n+\tstatus := pb.FunctionStatus{}\n+\tstatus.Running = true\n+\ttotalReceived := gi.getTotalReceived()\n+\ttotalProcessedSuccessfully := gi.getTotalProcessedSuccessfully()\n+\ttotalUserExceptions := gi.getTotalUserExceptions()\n+\ttotalSysExceptions := gi.getTotalSysExceptions()\n+\tavgProcessLatencyMs := gi.getAvgProcessLatency()\n+\tlastInvocation := gi.getLastInvocation()\n+\n+\tstatus.NumReceived = int64(totalReceived)\n+\tstatus.NumSuccessfullyProcessed = int64(totalProcessedSuccessfully)\n+\tstatus.NumUserExceptions = int64(totalUserExceptions)\n+\tstatus.InstanceId = strconv.Itoa(gi.context.instanceConf.instanceID)\n+\n+\tstatus.NumUserExceptions = int64(totalUserExceptions)\n+\tfor _, exPair := range gi.stats.latestUserException {\n+\t\ttoAdd := pb.FunctionStatus_ExceptionInformation{}\n+\t\ttoAdd.ExceptionString = exPair.exception.Error()\n+\t\ttoAdd.MsSinceEpoch = exPair.timestamp\n+\t\tstatus.LatestUserExceptions = append(status.LatestUserExceptions, &toAdd)\n+\t}\n+\n+\tstatus.NumSystemExceptions = int64(totalSysExceptions)\n+\tfor _, exPair := range gi.stats.latestSysException {\n+\t\ttoAdd := pb.FunctionStatus_ExceptionInformation{}\n+\t\ttoAdd.ExceptionString = exPair.exception.Error()\n+\t\ttoAdd.MsSinceEpoch = exPair.timestamp\n+\t\tstatus.LatestSystemExceptions = append(status.LatestSystemExceptions, &toAdd)\n+\t}\n+\tstatus.AverageLatency = float64(avgProcessLatencyMs)\n+\tstatus.LastInvocationTime = int64(lastInvocation)\n+\treturn &status\n+}\n+\n+func (gi *goInstance) getMetrics() *pb.MetricsData {\n+\ttotalReceived := gi.getTotalReceived()\n+\ttotalProcessedSuccessfully := gi.getTotalProcessedSuccessfully()\n+\ttotalUserExceptions := gi.getTotalUserExceptions()\n+\ttotalSysExceptions := gi.getTotalSysExceptions()\n+\tavgProcessLatencyMs := gi.getAvgProcessLatency()\n+\tlastInvocation := gi.getLastInvocation()\n+\n+\ttotalReceived1min := gi.getTotalReceived1min()\n+\ttotalProcessedSuccessfully1min := gi.getTotalProcessedSuccessfully1min()\n+\ttotalUserExceptions1min := gi.getTotalUserExceptions1min()\n+\ttotalSysExceptions1min := gi.getTotalSysExceptions1min()\n+\t//avg_process_latency_ms_1min := gi.get_avg_process_latency_1min()\n+\n+\tmetricsData := pb.MetricsData{}\n+\t// total metrics\n+\tmetricsData.ReceivedTotal = int64(totalReceived)\n+\tmetricsData.ProcessedSuccessfullyTotal = int64(totalProcessedSuccessfully)\n+\tmetricsData.SystemExceptionsTotal = int64(totalSysExceptions)\n+\tmetricsData.UserExceptionsTotal = int64(totalUserExceptions)\n+\tmetricsData.AvgProcessLatency = float64(avgProcessLatencyMs)\n+\tmetricsData.LastInvocation = int64(lastInvocation)\n+\t// 1min metrics\n+\tmetricsData.ReceivedTotal_1Min = int64(totalReceived1min)\n+\tmetricsData.ProcessedSuccessfullyTotal_1Min = int64(totalProcessedSuccessfully1min)\n+\tmetricsData.SystemExceptionsTotal_1Min = int64(totalSysExceptions1min)\n+\tmetricsData.UserExceptionsTotal_1Min = int64(totalUserExceptions1min)\n+\t//metrics_data.AvgProcessLatency_1Min = avg_process_latency_ms_1min\n+\n+\t// get any user metrics\n+\t// Not sure yet where these are stored.\n+\t/*\n+\t   user_metrics := self.contextimpl.get_metrics()\n+\t   for metric_name, value in user_metrics.items():\n+\t     metrics_data.userMetrics[metric_name] = value\n+\t*/\n+\n+\treturn &metricsData\n }\n \n func (gi *goInstance) getAndResetMetrics() *pb.MetricsData {\n-\treturn nil // Not implemented until we add the statistics features\n+\tmetricsData := gi.getMetrics()\n+\tgi.resetMetrics()\n+\treturn metricsData\n }\n \n func (gi *goInstance) resetMetrics() *empty.Empty {\n-\treturn nil // Not implemented until we add the statistics features\n+\tgi.stats.reset()\n+\treturn &empty.Empty{}\n }\n \n-func (gi *goInstance) getMetrics() *pb.MetricsData {\n-\treturn nil // Not implemented until we add the statistics features\n+// This method is used to get the required metrics for Prometheus.\n+// Note that this doesn't distinguish between parallel function instances!\n+func (gi *goInstance) getMatchingMetricFunc() func(lbl *io_prometheus_client.LabelPair) bool {\n+\tmatchMetricFunc := func(lbl *io_prometheus_client.LabelPair) bool {\n+\t\treturn *lbl.Name == \"fqfn\" && *lbl.Value == gi.context.GetTenantAndNamespaceAndName()\n+\t}\n+\treturn matchMetricFunc\n+}\n+\n+// e.g. metricName = \"pulsar_function_process_latency_ms\"\n+func (gi *goInstance) getMatchingMetricFromRegistry(metricName string) io_prometheus_client.Metric {\n+\tmetricFamilies, err := reg.Gather()\n+\tif err != nil {\n+\t\tlog.Error(\"Something went wrong when calling reg.Gather() in getMatchingMetricFromRegistry(..) for \" + metricName)\n+\t}\n+\tmatchFamilyFunc := func(vect *io_prometheus_client.MetricFamily) bool {\n+\t\treturn *vect.Name == metricName\n+\t}\n+\tfiteredMetricFamilies := filter(metricFamilies, matchFamilyFunc)\n+\tif len(fiteredMetricFamilies) > 1 {\n+\t\t// handle this.\n+\t\tlog.Error(\"Too many metric families for metricName = \" + metricName)\n+\t\t// Should we panic here instead of report an error since it reflects a code problem, not a user problem?\n+\t}\n+\tmetricFunc := gi.getMatchingMetricFunc()\n+\tmatchingMetric := getFirstMatch(fiteredMetricFamilies[0].Metric, metricFunc)\n+\treturn *matchingMetric\n+}\n+\n+func (gi *goInstance) getTotalReceived() float32 {\n+\t// \"pulsar_function_\" + \"received_total\", NewGaugeVec.\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalReceived)\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+func (gi *goInstance) getTotalProcessedSuccessfully() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalSuccessfullyProcessed)\n+\t// \"pulsar_function_\" + \"processed_successfully_total\", NewGaugeVec.\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+func (gi *goInstance) getTotalSysExceptions() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalSystemExceptions)\n+\t// \"pulsar_function_\"+ \"system_exceptions_total\", NewGaugeVec.\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+\n+func (gi *goInstance) getTotalUserExceptions() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalUserExceptions)\n+\t// \"pulsar_function_\" + \"user_exceptions_total\", NewGaugeVec\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+\n+func (gi *goInstance) getAvgProcessLatency() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + ProcessLatencyMs)\n+\t// \"pulsar_function_\" + \"process_latency_ms\", SummaryVec.\n+\tcount := metric.GetSummary().SampleCount\n+\tsum := metric.GetSummary().SampleSum\n+\tif *count <= 0.0 {\n+\t\treturn 0.0\n+\t}\n+\treturn float32(*sum) / float32(*count)\n+}\n+\n+func (gi *goInstance) getLastInvocation() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + LastInvocation)\n+\t// \"pulsar_function_\" + \"last_invocation\", GaugeVec.\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+\n+func (gi *goInstance) getTotalProcessedSuccessfully1min() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalSuccessfullyProcessed1min)\n+\t// \"pulsar_function_\" + \"processed_successfully_total_1min\", GaugeVec.\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+\n+func (gi *goInstance) getTotalSysExceptions1min() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalSystemExceptions1min)\n+\t// \"pulsar_function_\" + \"system_exceptions_total_1min\", GaugeVec\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+\n+func (gi *goInstance) getTotalUserExceptions1min() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalUserExceptions1min)\n+\t// \"pulsar_function_\" + \"user_exceptions_total_1min\", GaugeVec\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+\n+/*\n+func (gi *goInstance) get_avg_process_latency_1min() float32 {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73e3c922c7c5192424e82ba5a53d85e53b930d26"}, "originalPosition": 311}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM0OTU0OQ==", "bodyText": "@jiazhai This is a method that isn't available due to the Prometheus architecture change they rolled out to their Go library. So, we need to find another way to capture the 1 min metrics. The comment was to note that this feature is currently missing.", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r406349549", "createdAt": "2020-04-09T17:06:44Z", "author": {"login": "devinbost"}, "path": "pulsar-function-go/pf/instance.go", "diffHunk": "@@ -374,17 +409,201 @@ func (gi *goInstance) healthCheck() *pb.HealthCheckResult {\n }\n \n func (gi *goInstance) getFunctionStatus() *pb.FunctionStatus {\n-\treturn nil // Not implemented until we add the statistics features\n+\tstatus := pb.FunctionStatus{}\n+\tstatus.Running = true\n+\ttotalReceived := gi.getTotalReceived()\n+\ttotalProcessedSuccessfully := gi.getTotalProcessedSuccessfully()\n+\ttotalUserExceptions := gi.getTotalUserExceptions()\n+\ttotalSysExceptions := gi.getTotalSysExceptions()\n+\tavgProcessLatencyMs := gi.getAvgProcessLatency()\n+\tlastInvocation := gi.getLastInvocation()\n+\n+\tstatus.NumReceived = int64(totalReceived)\n+\tstatus.NumSuccessfullyProcessed = int64(totalProcessedSuccessfully)\n+\tstatus.NumUserExceptions = int64(totalUserExceptions)\n+\tstatus.InstanceId = strconv.Itoa(gi.context.instanceConf.instanceID)\n+\n+\tstatus.NumUserExceptions = int64(totalUserExceptions)\n+\tfor _, exPair := range gi.stats.latestUserException {\n+\t\ttoAdd := pb.FunctionStatus_ExceptionInformation{}\n+\t\ttoAdd.ExceptionString = exPair.exception.Error()\n+\t\ttoAdd.MsSinceEpoch = exPair.timestamp\n+\t\tstatus.LatestUserExceptions = append(status.LatestUserExceptions, &toAdd)\n+\t}\n+\n+\tstatus.NumSystemExceptions = int64(totalSysExceptions)\n+\tfor _, exPair := range gi.stats.latestSysException {\n+\t\ttoAdd := pb.FunctionStatus_ExceptionInformation{}\n+\t\ttoAdd.ExceptionString = exPair.exception.Error()\n+\t\ttoAdd.MsSinceEpoch = exPair.timestamp\n+\t\tstatus.LatestSystemExceptions = append(status.LatestSystemExceptions, &toAdd)\n+\t}\n+\tstatus.AverageLatency = float64(avgProcessLatencyMs)\n+\tstatus.LastInvocationTime = int64(lastInvocation)\n+\treturn &status\n+}\n+\n+func (gi *goInstance) getMetrics() *pb.MetricsData {\n+\ttotalReceived := gi.getTotalReceived()\n+\ttotalProcessedSuccessfully := gi.getTotalProcessedSuccessfully()\n+\ttotalUserExceptions := gi.getTotalUserExceptions()\n+\ttotalSysExceptions := gi.getTotalSysExceptions()\n+\tavgProcessLatencyMs := gi.getAvgProcessLatency()\n+\tlastInvocation := gi.getLastInvocation()\n+\n+\ttotalReceived1min := gi.getTotalReceived1min()\n+\ttotalProcessedSuccessfully1min := gi.getTotalProcessedSuccessfully1min()\n+\ttotalUserExceptions1min := gi.getTotalUserExceptions1min()\n+\ttotalSysExceptions1min := gi.getTotalSysExceptions1min()\n+\t//avg_process_latency_ms_1min := gi.get_avg_process_latency_1min()\n+\n+\tmetricsData := pb.MetricsData{}\n+\t// total metrics\n+\tmetricsData.ReceivedTotal = int64(totalReceived)\n+\tmetricsData.ProcessedSuccessfullyTotal = int64(totalProcessedSuccessfully)\n+\tmetricsData.SystemExceptionsTotal = int64(totalSysExceptions)\n+\tmetricsData.UserExceptionsTotal = int64(totalUserExceptions)\n+\tmetricsData.AvgProcessLatency = float64(avgProcessLatencyMs)\n+\tmetricsData.LastInvocation = int64(lastInvocation)\n+\t// 1min metrics\n+\tmetricsData.ReceivedTotal_1Min = int64(totalReceived1min)\n+\tmetricsData.ProcessedSuccessfullyTotal_1Min = int64(totalProcessedSuccessfully1min)\n+\tmetricsData.SystemExceptionsTotal_1Min = int64(totalSysExceptions1min)\n+\tmetricsData.UserExceptionsTotal_1Min = int64(totalUserExceptions1min)\n+\t//metrics_data.AvgProcessLatency_1Min = avg_process_latency_ms_1min\n+\n+\t// get any user metrics\n+\t// Not sure yet where these are stored.\n+\t/*\n+\t   user_metrics := self.contextimpl.get_metrics()\n+\t   for metric_name, value in user_metrics.items():\n+\t     metrics_data.userMetrics[metric_name] = value\n+\t*/\n+\n+\treturn &metricsData\n }\n \n func (gi *goInstance) getAndResetMetrics() *pb.MetricsData {\n-\treturn nil // Not implemented until we add the statistics features\n+\tmetricsData := gi.getMetrics()\n+\tgi.resetMetrics()\n+\treturn metricsData\n }\n \n func (gi *goInstance) resetMetrics() *empty.Empty {\n-\treturn nil // Not implemented until we add the statistics features\n+\tgi.stats.reset()\n+\treturn &empty.Empty{}\n }\n \n-func (gi *goInstance) getMetrics() *pb.MetricsData {\n-\treturn nil // Not implemented until we add the statistics features\n+// This method is used to get the required metrics for Prometheus.\n+// Note that this doesn't distinguish between parallel function instances!\n+func (gi *goInstance) getMatchingMetricFunc() func(lbl *io_prometheus_client.LabelPair) bool {\n+\tmatchMetricFunc := func(lbl *io_prometheus_client.LabelPair) bool {\n+\t\treturn *lbl.Name == \"fqfn\" && *lbl.Value == gi.context.GetTenantAndNamespaceAndName()\n+\t}\n+\treturn matchMetricFunc\n+}\n+\n+// e.g. metricName = \"pulsar_function_process_latency_ms\"\n+func (gi *goInstance) getMatchingMetricFromRegistry(metricName string) io_prometheus_client.Metric {\n+\tmetricFamilies, err := reg.Gather()\n+\tif err != nil {\n+\t\tlog.Error(\"Something went wrong when calling reg.Gather() in getMatchingMetricFromRegistry(..) for \" + metricName)\n+\t}\n+\tmatchFamilyFunc := func(vect *io_prometheus_client.MetricFamily) bool {\n+\t\treturn *vect.Name == metricName\n+\t}\n+\tfiteredMetricFamilies := filter(metricFamilies, matchFamilyFunc)\n+\tif len(fiteredMetricFamilies) > 1 {\n+\t\t// handle this.\n+\t\tlog.Error(\"Too many metric families for metricName = \" + metricName)\n+\t\t// Should we panic here instead of report an error since it reflects a code problem, not a user problem?\n+\t}\n+\tmetricFunc := gi.getMatchingMetricFunc()\n+\tmatchingMetric := getFirstMatch(fiteredMetricFamilies[0].Metric, metricFunc)\n+\treturn *matchingMetric\n+}\n+\n+func (gi *goInstance) getTotalReceived() float32 {\n+\t// \"pulsar_function_\" + \"received_total\", NewGaugeVec.\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalReceived)\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+func (gi *goInstance) getTotalProcessedSuccessfully() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalSuccessfullyProcessed)\n+\t// \"pulsar_function_\" + \"processed_successfully_total\", NewGaugeVec.\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+func (gi *goInstance) getTotalSysExceptions() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalSystemExceptions)\n+\t// \"pulsar_function_\"+ \"system_exceptions_total\", NewGaugeVec.\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+\n+func (gi *goInstance) getTotalUserExceptions() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalUserExceptions)\n+\t// \"pulsar_function_\" + \"user_exceptions_total\", NewGaugeVec\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+\n+func (gi *goInstance) getAvgProcessLatency() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + ProcessLatencyMs)\n+\t// \"pulsar_function_\" + \"process_latency_ms\", SummaryVec.\n+\tcount := metric.GetSummary().SampleCount\n+\tsum := metric.GetSummary().SampleSum\n+\tif *count <= 0.0 {\n+\t\treturn 0.0\n+\t}\n+\treturn float32(*sum) / float32(*count)\n+}\n+\n+func (gi *goInstance) getLastInvocation() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + LastInvocation)\n+\t// \"pulsar_function_\" + \"last_invocation\", GaugeVec.\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+\n+func (gi *goInstance) getTotalProcessedSuccessfully1min() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalSuccessfullyProcessed1min)\n+\t// \"pulsar_function_\" + \"processed_successfully_total_1min\", GaugeVec.\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+\n+func (gi *goInstance) getTotalSysExceptions1min() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalSystemExceptions1min)\n+\t// \"pulsar_function_\" + \"system_exceptions_total_1min\", GaugeVec\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+\n+func (gi *goInstance) getTotalUserExceptions1min() float32 {\n+\tmetric := gi.getMatchingMetricFromRegistry(PulsarFunctionMetricsPrefix + TotalUserExceptions1min)\n+\t// \"pulsar_function_\" + \"user_exceptions_total_1min\", GaugeVec\n+\tval := metric.GetGauge().Value\n+\treturn float32(*val)\n+}\n+\n+/*\n+func (gi *goInstance) get_avg_process_latency_1min() float32 {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjIyNTMwMw=="}, "originalCommit": {"oid": "73e3c922c7c5192424e82ba5a53d85e53b930d26"}, "originalPosition": 311}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMTk3NTQ3OnYy", "diffSide": "RIGHT", "path": "pulsar-function-go/pf/instance.go", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxODoxNzoyN1rOGDkDmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxODoxNzoyN1rOGDkDmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM4OTY1OA==", "bodyText": "I think this should be called before processResult.", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r406389658", "createdAt": "2020-04-09T18:17:27Z", "author": {"login": "sijie"}, "path": "pulsar-function-go/pf/instance.go", "diffHunk": "@@ -128,20 +146,27 @@ CLOSE:\n \t\t\tif autoAck && atMostOnce {\n \t\t\t\tgi.ackInputMessage(msgInput)\n \t\t\t}\n-\n+\t\t\tgi.stats.incrTotalReceived()\n \t\t\tgi.addLogTopicHandler()\n \n+\t\t\tgi.stats.setLastInvocation()\n+\t\t\tgi.stats.processTimeStart()\n+\n \t\t\toutput, err := gi.handlerMsg(msgInput)\n \t\t\tif err != nil {\n \t\t\t\tlog.Errorf(\"handler message error:%v\", err)\n \t\t\t\tif autoAck && atLeastOnce {\n \t\t\t\t\tgi.nackInputMessage(msgInput)\n \t\t\t\t}\n+\t\t\t\tgi.stats.incrTotalUserExceptions(err)\n \t\t\t\treturn err\n \t\t\t}\n \n \t\t\tgi.processResult(msgInput, output)\n \n+\t\t\tgi.stats.processTimeEnd() // Should this be called here or before processResult(..)?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73e3c922c7c5192424e82ba5a53d85e53b930d26"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MTQwNDcxOnYy", "diffSide": "RIGHT", "path": "pulsar-function-go/pf/stats_test.go", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQwNTowMjoyMlrOGHyPow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQwNTowMjoyMlrOGHyPow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxNjQxOQ==", "bodyText": "Please replace panic with t.Fatal()", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r410816419", "createdAt": "2020-04-19T05:02:22Z", "author": {"login": "wolfstudy"}, "path": "pulsar-function-go/pf/stats_test.go", "diffHunk": "@@ -0,0 +1,222 @@\n+//\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+//\n+\n+package pf\n+\n+import (\n+\t\"fmt\"\n+\t\"math\"\n+\t\"testing\"\n+\n+\t\"github.com/golang/protobuf/proto\"\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\tio_prometheus_client \"github.com/prometheus/client_model/go\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+/*func test(){\n+\tvar metrics_label_names = []string{\"tenant\", \"namespace\", \"name\", \"instance_id\", \"cluster\", \"fqfn\"}\n+\tvar exception_label_names = []string{\"error\", \"ts\"}\n+\tvar exception_metrics_label_names = append(metrics_label_names, exception_label_names...)\n+\tvar stat_process_latency_ms = prometheus.NewSummaryVec(\n+\t\tprometheus.SummaryOpts{\n+\t\t\tName: PULSAR_FUNCTION_METRICS_PREFIX + PROCESS_LATENCY_MS,\n+\t\t\tHelp: \"Process latency in milliseconds.\"}, metrics_label_names)\n+\tvar reg *prometheus.Registry\n+\treg = prometheus.NewRegistry()\n+\treg.MustRegister(stat_process_latency_ms)\n+\tmetrics_labels := []string{\"test-tenant\",\"test-tenant/test-namespace\", \"test-name\", \"1234\", \"test-cluster\",\n+\t\t\"test-tenant/test-namespace/test-name\"}\n+\t// 1234 is instanceId\n+\t// ['test-tenant', 'test-tenant/test-namespace', 'test-name',1234,\n+    //    'test-cluster', 'test-tenant/test-namespace/test-name']\n+\t//var _stat_process_latency_ms = stat_process_latency_ms.WithLabelValues(metrics_labels...)\n+\t//process_latency_ms_count := stat._stat_process_latency_ms._count.get()\n+\t//process_latency_ms_sum := stat._stat_process_latency_ms._sum.get()\n+}\n+func  (stat *StatWithLabelValues) getTotalReceived() float32 {\n+\tgathering, _ := reg.Gather()\n+\tout := &bytes.Buffer{}\n+\tfor _, mf := range gathering {\n+\t\tif _, err := expfmt.MetricFamilyToText(out, mf); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}\n+\tfmt.Print(out.String())\n+\tfmt.Println(\"----------\")\n+}\n+*/\n+func TestExampleSummaryVec(t *testing.T) {\n+\n+\ttemps := prometheus.NewSummaryVec(\n+\t\tprometheus.SummaryOpts{\n+\t\t\tName:       \"pond_temperature_celsius\",\n+\t\t\tHelp:       \"The temperature of the frog pond.\",\n+\t\t\tObjectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},\n+\t\t},\n+\t\t[]string{\"species\"},\n+\t)\n+\t// Simulate some observations.\n+\tfor i := 0; i < 1000; i++ {\n+\t\ttemps.WithLabelValues(\"litoria-caerulea\").Observe(30 + math.Floor(120*math.Sin(float64(i)*0.1))/10)\n+\t\ttemps.WithLabelValues(\"lithobates-catesbeianus\").Observe(32 + math.Floor(100*math.Cos(float64(i)*0.11))/10)\n+\t}\n+\n+\t// Create a Summary without any observations.\n+\ttemps.WithLabelValues(\"leiopelma-hochstetteri\")\n+\n+\t// Just for demonstration, let's check the state of the summary vector\n+\t// by registering it with a custom registry and then let it collect the\n+\t// metrics.\n+\treg := prometheus.NewRegistry()\n+\treg.MustRegister(temps)\n+\n+\tmetricFamilies, err := reg.Gather()\n+\tif err != nil || len(metricFamilies) != 1 {\n+\t\tpanic(\"unexpected behavior of custom test registry\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73e3c922c7c5192424e82ba5a53d85e53b930d26"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MTQwNDk5OnYy", "diffSide": "RIGHT", "path": "pulsar-function-go/pf/stats_test.go", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQwNTowMjozOFrOGHyPwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQwNTowMjozOFrOGHyPwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxNjQ0OQ==", "bodyText": "Please replace panic with t.Fatal()", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r410816449", "createdAt": "2020-04-19T05:02:38Z", "author": {"login": "wolfstudy"}, "path": "pulsar-function-go/pf/stats_test.go", "diffHunk": "@@ -0,0 +1,222 @@\n+//\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+//\n+\n+package pf\n+\n+import (\n+\t\"fmt\"\n+\t\"math\"\n+\t\"testing\"\n+\n+\t\"github.com/golang/protobuf/proto\"\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\tio_prometheus_client \"github.com/prometheus/client_model/go\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+/*func test(){\n+\tvar metrics_label_names = []string{\"tenant\", \"namespace\", \"name\", \"instance_id\", \"cluster\", \"fqfn\"}\n+\tvar exception_label_names = []string{\"error\", \"ts\"}\n+\tvar exception_metrics_label_names = append(metrics_label_names, exception_label_names...)\n+\tvar stat_process_latency_ms = prometheus.NewSummaryVec(\n+\t\tprometheus.SummaryOpts{\n+\t\t\tName: PULSAR_FUNCTION_METRICS_PREFIX + PROCESS_LATENCY_MS,\n+\t\t\tHelp: \"Process latency in milliseconds.\"}, metrics_label_names)\n+\tvar reg *prometheus.Registry\n+\treg = prometheus.NewRegistry()\n+\treg.MustRegister(stat_process_latency_ms)\n+\tmetrics_labels := []string{\"test-tenant\",\"test-tenant/test-namespace\", \"test-name\", \"1234\", \"test-cluster\",\n+\t\t\"test-tenant/test-namespace/test-name\"}\n+\t// 1234 is instanceId\n+\t// ['test-tenant', 'test-tenant/test-namespace', 'test-name',1234,\n+    //    'test-cluster', 'test-tenant/test-namespace/test-name']\n+\t//var _stat_process_latency_ms = stat_process_latency_ms.WithLabelValues(metrics_labels...)\n+\t//process_latency_ms_count := stat._stat_process_latency_ms._count.get()\n+\t//process_latency_ms_sum := stat._stat_process_latency_ms._sum.get()\n+}\n+func  (stat *StatWithLabelValues) getTotalReceived() float32 {\n+\tgathering, _ := reg.Gather()\n+\tout := &bytes.Buffer{}\n+\tfor _, mf := range gathering {\n+\t\tif _, err := expfmt.MetricFamilyToText(out, mf); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}\n+\tfmt.Print(out.String())\n+\tfmt.Println(\"----------\")\n+}\n+*/\n+func TestExampleSummaryVec(t *testing.T) {\n+\n+\ttemps := prometheus.NewSummaryVec(\n+\t\tprometheus.SummaryOpts{\n+\t\t\tName:       \"pond_temperature_celsius\",\n+\t\t\tHelp:       \"The temperature of the frog pond.\",\n+\t\t\tObjectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},\n+\t\t},\n+\t\t[]string{\"species\"},\n+\t)\n+\t// Simulate some observations.\n+\tfor i := 0; i < 1000; i++ {\n+\t\ttemps.WithLabelValues(\"litoria-caerulea\").Observe(30 + math.Floor(120*math.Sin(float64(i)*0.1))/10)\n+\t\ttemps.WithLabelValues(\"lithobates-catesbeianus\").Observe(32 + math.Floor(100*math.Cos(float64(i)*0.11))/10)\n+\t}\n+\n+\t// Create a Summary without any observations.\n+\ttemps.WithLabelValues(\"leiopelma-hochstetteri\")\n+\n+\t// Just for demonstration, let's check the state of the summary vector\n+\t// by registering it with a custom registry and then let it collect the\n+\t// metrics.\n+\treg := prometheus.NewRegistry()\n+\treg.MustRegister(temps)\n+\n+\tmetricFamilies, err := reg.Gather()\n+\tif err != nil || len(metricFamilies) != 1 {\n+\t\tpanic(\"unexpected behavior of custom test registry\")\n+\t}\n+\tmatch := func(vect *io_prometheus_client.MetricFamily) bool {\n+\t\treturn *vect.Name == \"pond_temperature_celsius\"\n+\t}\n+\tfiteredMetricFamilies := filter(metricFamilies, match)\n+\n+\tif len(fiteredMetricFamilies) > 1 {\n+\t\tpanic(\"Too many metric families\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73e3c922c7c5192424e82ba5a53d85e53b930d26"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MTQwNjA0OnYy", "diffSide": "RIGHT", "path": "pulsar-function-go/pf/stats_test.go", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQwNTowMzowOFrOGHyQLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQwNTowMzowOFrOGHyQLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxNjU1OA==", "bodyText": "Why don't we use assert to compare whether the expected value and the actual value are equal? If my understanding is correct, this test case will succeed at any time, right?\nE.g:\nassert.Equal(t, x, y)", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r410816558", "createdAt": "2020-04-19T05:03:08Z", "author": {"login": "wolfstudy"}, "path": "pulsar-function-go/pf/stats_test.go", "diffHunk": "@@ -0,0 +1,222 @@\n+//\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+//\n+\n+package pf\n+\n+import (\n+\t\"fmt\"\n+\t\"math\"\n+\t\"testing\"\n+\n+\t\"github.com/golang/protobuf/proto\"\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\tio_prometheus_client \"github.com/prometheus/client_model/go\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+/*func test(){\n+\tvar metrics_label_names = []string{\"tenant\", \"namespace\", \"name\", \"instance_id\", \"cluster\", \"fqfn\"}\n+\tvar exception_label_names = []string{\"error\", \"ts\"}\n+\tvar exception_metrics_label_names = append(metrics_label_names, exception_label_names...)\n+\tvar stat_process_latency_ms = prometheus.NewSummaryVec(\n+\t\tprometheus.SummaryOpts{\n+\t\t\tName: PULSAR_FUNCTION_METRICS_PREFIX + PROCESS_LATENCY_MS,\n+\t\t\tHelp: \"Process latency in milliseconds.\"}, metrics_label_names)\n+\tvar reg *prometheus.Registry\n+\treg = prometheus.NewRegistry()\n+\treg.MustRegister(stat_process_latency_ms)\n+\tmetrics_labels := []string{\"test-tenant\",\"test-tenant/test-namespace\", \"test-name\", \"1234\", \"test-cluster\",\n+\t\t\"test-tenant/test-namespace/test-name\"}\n+\t// 1234 is instanceId\n+\t// ['test-tenant', 'test-tenant/test-namespace', 'test-name',1234,\n+    //    'test-cluster', 'test-tenant/test-namespace/test-name']\n+\t//var _stat_process_latency_ms = stat_process_latency_ms.WithLabelValues(metrics_labels...)\n+\t//process_latency_ms_count := stat._stat_process_latency_ms._count.get()\n+\t//process_latency_ms_sum := stat._stat_process_latency_ms._sum.get()\n+}\n+func  (stat *StatWithLabelValues) getTotalReceived() float32 {\n+\tgathering, _ := reg.Gather()\n+\tout := &bytes.Buffer{}\n+\tfor _, mf := range gathering {\n+\t\tif _, err := expfmt.MetricFamilyToText(out, mf); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}\n+\tfmt.Print(out.String())\n+\tfmt.Println(\"----------\")\n+}\n+*/\n+func TestExampleSummaryVec(t *testing.T) {\n+\n+\ttemps := prometheus.NewSummaryVec(\n+\t\tprometheus.SummaryOpts{\n+\t\t\tName:       \"pond_temperature_celsius\",\n+\t\t\tHelp:       \"The temperature of the frog pond.\",\n+\t\t\tObjectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},\n+\t\t},\n+\t\t[]string{\"species\"},\n+\t)\n+\t// Simulate some observations.\n+\tfor i := 0; i < 1000; i++ {\n+\t\ttemps.WithLabelValues(\"litoria-caerulea\").Observe(30 + math.Floor(120*math.Sin(float64(i)*0.1))/10)\n+\t\ttemps.WithLabelValues(\"lithobates-catesbeianus\").Observe(32 + math.Floor(100*math.Cos(float64(i)*0.11))/10)\n+\t}\n+\n+\t// Create a Summary without any observations.\n+\ttemps.WithLabelValues(\"leiopelma-hochstetteri\")\n+\n+\t// Just for demonstration, let's check the state of the summary vector\n+\t// by registering it with a custom registry and then let it collect the\n+\t// metrics.\n+\treg := prometheus.NewRegistry()\n+\treg.MustRegister(temps)\n+\n+\tmetricFamilies, err := reg.Gather()\n+\tif err != nil || len(metricFamilies) != 1 {\n+\t\tpanic(\"unexpected behavior of custom test registry\")\n+\t}\n+\tmatch := func(vect *io_prometheus_client.MetricFamily) bool {\n+\t\treturn *vect.Name == \"pond_temperature_celsius\"\n+\t}\n+\tfiteredMetricFamilies := filter(metricFamilies, match)\n+\n+\tif len(fiteredMetricFamilies) > 1 {\n+\t\tpanic(\"Too many metric families\")\n+\t}\n+\t// Then, we need to filter the metrics in the family to one that matches our label.\n+\n+\tfmt.Println(proto.MarshalTextString(metricFamilies[0]))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73e3c922c7c5192424e82ba5a53d85e53b930d26"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MTQwNzAyOnYy", "diffSide": "RIGHT", "path": "pulsar-function-go/pf/stats_test.go", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQwNTowMzozNVrOGHyQlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQwNTowMzozNVrOGHyQlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDgxNjY2Mg==", "bodyText": "Please remove these comments if we don't need", "url": "https://github.com/apache/pulsar/pull/6105#discussion_r410816662", "createdAt": "2020-04-19T05:03:35Z", "author": {"login": "wolfstudy"}, "path": "pulsar-function-go/pf/stats_test.go", "diffHunk": "@@ -0,0 +1,222 @@\n+//\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+//\n+\n+package pf\n+\n+import (\n+\t\"fmt\"\n+\t\"math\"\n+\t\"testing\"\n+\n+\t\"github.com/golang/protobuf/proto\"\n+\t\"github.com/prometheus/client_golang/prometheus\"\n+\tio_prometheus_client \"github.com/prometheus/client_model/go\"\n+\t\"github.com/stretchr/testify/assert\"\n+)\n+\n+/*func test(){\n+\tvar metrics_label_names = []string{\"tenant\", \"namespace\", \"name\", \"instance_id\", \"cluster\", \"fqfn\"}\n+\tvar exception_label_names = []string{\"error\", \"ts\"}\n+\tvar exception_metrics_label_names = append(metrics_label_names, exception_label_names...)\n+\tvar stat_process_latency_ms = prometheus.NewSummaryVec(\n+\t\tprometheus.SummaryOpts{\n+\t\t\tName: PULSAR_FUNCTION_METRICS_PREFIX + PROCESS_LATENCY_MS,\n+\t\t\tHelp: \"Process latency in milliseconds.\"}, metrics_label_names)\n+\tvar reg *prometheus.Registry\n+\treg = prometheus.NewRegistry()\n+\treg.MustRegister(stat_process_latency_ms)\n+\tmetrics_labels := []string{\"test-tenant\",\"test-tenant/test-namespace\", \"test-name\", \"1234\", \"test-cluster\",\n+\t\t\"test-tenant/test-namespace/test-name\"}\n+\t// 1234 is instanceId\n+\t// ['test-tenant', 'test-tenant/test-namespace', 'test-name',1234,\n+    //    'test-cluster', 'test-tenant/test-namespace/test-name']\n+\t//var _stat_process_latency_ms = stat_process_latency_ms.WithLabelValues(metrics_labels...)\n+\t//process_latency_ms_count := stat._stat_process_latency_ms._count.get()\n+\t//process_latency_ms_sum := stat._stat_process_latency_ms._sum.get()\n+}\n+func  (stat *StatWithLabelValues) getTotalReceived() float32 {\n+\tgathering, _ := reg.Gather()\n+\tout := &bytes.Buffer{}\n+\tfor _, mf := range gathering {\n+\t\tif _, err := expfmt.MetricFamilyToText(out, mf); err != nil {\n+\t\t\tpanic(err)\n+\t\t}\n+\t}\n+\tfmt.Print(out.String())\n+\tfmt.Println(\"----------\")\n+}\n+*/\n+func TestExampleSummaryVec(t *testing.T) {\n+\n+\ttemps := prometheus.NewSummaryVec(\n+\t\tprometheus.SummaryOpts{\n+\t\t\tName:       \"pond_temperature_celsius\",\n+\t\t\tHelp:       \"The temperature of the frog pond.\",\n+\t\t\tObjectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},\n+\t\t},\n+\t\t[]string{\"species\"},\n+\t)\n+\t// Simulate some observations.\n+\tfor i := 0; i < 1000; i++ {\n+\t\ttemps.WithLabelValues(\"litoria-caerulea\").Observe(30 + math.Floor(120*math.Sin(float64(i)*0.1))/10)\n+\t\ttemps.WithLabelValues(\"lithobates-catesbeianus\").Observe(32 + math.Floor(100*math.Cos(float64(i)*0.11))/10)\n+\t}\n+\n+\t// Create a Summary without any observations.\n+\ttemps.WithLabelValues(\"leiopelma-hochstetteri\")\n+\n+\t// Just for demonstration, let's check the state of the summary vector\n+\t// by registering it with a custom registry and then let it collect the\n+\t// metrics.\n+\treg := prometheus.NewRegistry()\n+\treg.MustRegister(temps)\n+\n+\tmetricFamilies, err := reg.Gather()\n+\tif err != nil || len(metricFamilies) != 1 {\n+\t\tpanic(\"unexpected behavior of custom test registry\")\n+\t}\n+\tmatch := func(vect *io_prometheus_client.MetricFamily) bool {\n+\t\treturn *vect.Name == \"pond_temperature_celsius\"\n+\t}\n+\tfiteredMetricFamilies := filter(metricFamilies, match)\n+\n+\tif len(fiteredMetricFamilies) > 1 {\n+\t\tpanic(\"Too many metric families\")\n+\t}\n+\t// Then, we need to filter the metrics in the family to one that matches our label.\n+\n+\tfmt.Println(proto.MarshalTextString(metricFamilies[0]))\n+\n+\t// Output:\n+\t// name: \"pond_temperature_celsius\"\n+\t// help: \"The temperature of the frog pond.\"\n+\t// type: SUMMARY\n+\t// metric: <\n+\t//   label: <\n+\t//     name: \"species\"\n+\t//     value: \"leiopelma-hochstetteri\"\n+\t//   >\n+\t//   summary: <\n+\t//     sample_count: 0\n+\t//     sample_sum: 0\n+\t//     quantile: <\n+\t//       quantile: 0.5\n+\t//       value: nan\n+\t//     >\n+\t//     quantile: <\n+\t//       quantile: 0.9\n+\t//       value: nan\n+\t//     >\n+\t//     quantile: <\n+\t//       quantile: 0.99\n+\t//       value: nan\n+\t//     >\n+\t//   >\n+\t// >\n+\t// metric: <\n+\t//   label: <\n+\t//     name: \"species\"\n+\t//     value: \"lithobates-catesbeianus\"\n+\t//   >\n+\t//   summary: <\n+\t//     sample_count: 1000\n+\t//     sample_sum: 31956.100000000017\n+\t//     quantile: <\n+\t//       quantile: 0.5\n+\t//       value: 32.4\n+\t//     >\n+\t//     quantile: <\n+\t//       quantile: 0.9\n+\t//       value: 41.4\n+\t//     >\n+\t//     quantile: <\n+\t//       quantile: 0.99\n+\t//       value: 41.9\n+\t//     >\n+\t//   >\n+\t// >\n+\t// metric: <\n+\t//   label: <\n+\t//     name: \"species\"\n+\t//     value: \"litoria-caerulea\"\n+\t//   >\n+\t//   summary: <\n+\t//     sample_count: 1000\n+\t//     sample_sum: 29969.50000000001\n+\t//     quantile: <\n+\t//       quantile: 0.5\n+\t//       value: 31.1\n+\t//     >\n+\t//     quantile: <\n+\t//       quantile: 0.9\n+\t//       value: 41.3\n+\t//     >\n+\t//     quantile: <\n+\t//       quantile: 0.99\n+\t//       value: 41.9\n+\t//     >\n+\t//   >\n+\t// >", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73e3c922c7c5192424e82ba5a53d85e53b930d26"}, "originalPosition": 175}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1991, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}