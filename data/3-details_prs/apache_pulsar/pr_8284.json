{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA1MjE4NTIy", "number": 8284, "title": "Fix Broker enters an infinite loop in ManagedLedgerImpl.asyncReadEntries", "bodyText": "Fix #8229\nBug Detail\nrefer to broker dump file info: https://gist.github.com/lhotari/c34db2664b15fc32c9f0e7ae8b37dbda#gistcomment-3491707\nWe take the first row in the extracted table for example.\ncursor.markDeletePosition = 2273599:-1\nopread readPosition = 2282101:0\nopread nextReadPosition = 2282101:0\ncursor readPosition = 2273599:0\ncursor writePosition = 2273599:4\ncursor.ledger.currentLedger.lastAddConfirmed = -1\ncursor.ledger.currentLedger.ledgerId = 2282101\n\nSQL:\n((cursor.markDeletePosition.ledgerId.toString() + \":\") + cursor.markDeletePosition.entryId.toString()) AS \"cursor.markDeletePosition\", ((readPosition.ledgerId.toString() + \":\") + readPosition.entryId.toString()) AS \"opread readPosition\", \n((nextReadPosition.ledgerId.toString() + \":\") + nextReadPosition.entryId.toString()) AS \"opread nextReadPosition\",\n ((cursor.readPosition.ledgerId.toString() + \":\") + cursor.readPosition.entryId.toString()) AS \"cursor readPosition\", \n((cursor.ledger.lastConfirmedEntry.ledgerId.toString() + \":\") + cursor.ledger.lastConfirmedEntry.entryId.toString()) AS \"cursor writePosition\", \ncursor.ledger.currentLedger.lastAddConfirmed, cursor.ledger.currentLedger.ledgerId.toString() AS\n \"cursor.ledger.currentLedger.ledgerId\"\nWhen call ManagedCursorImpl#asyncReadEntries, cursor.readPosisition is 2273599:0, however, when using cursor.readPostition to construct opReadEntry OpReadEntry op = OpReadEntry.create(this, readPosition, numberOfEntriesToRead, callback, ctx);, it use the cursor.readPosition to construct op.readPostition op.readPosition = cursor.ledger.startReadOperationOnLedger(readPositionRef, op);. Due to cursor.readPosition not exist in managedLedger ledgers map, startReadOperationOnLedger return the earliest available ledger position, and set op.readPosition to 2282101:0, but the cursor.readPosition still 2273599:0.\nWhen call ManagedLedgerImpl#asyncReadEntries according to the constructed opReadEntry, it call ManagedLedgerImpl#internalReadFromLedger. The key variables as follow\nledger = 2282101:-1\nlastPosition = 2273599:4\nledger.getId()[2282101] != lastPosition.getLedgerId() [2273599]\nfirstEntry = op.readPosition.getEntryId() = 0\nlastEntryInLedger = ledger.getLastAddConfirmed = -1\nThus, it will go into the following branch\nif (firstEntry > lastEntryInLedger) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"[{}] No more messages to read from ledger={} lastEntry={} readEntry={}\", name,\n                        ledger.getId(), lastEntryInLedger, firstEntry);\n            }\n\n            if (currentLedger == null || ledger.getId() != currentLedger.getId()) {\n                // Cursor was placed past the end of one ledger, move it to the\n                // beginning of the next ledger\n                Long nextLedgerId = ledgers.ceilingKey(ledger.getId() + 1);\n                if (nextLedgerId != null) {\n                    opReadEntry.updateReadPosition(new PositionImpl(nextLedgerId, 0));\n                } else {\n                    opReadEntry.updateReadPosition(new PositionImpl(ledger.getId() + 1, 0));\n                }\n            }\n\n            opReadEntry.checkReadCompletion();\n            return;\n        }\nFinally, it call opReadEntry.checkReadCompletion(), and then call ManagedCursor#hasMoreEntries to check whether has more entries to read. If hasMoreEntries returns true, it will setup another read thread to read more entries.\npublic boolean hasMoreEntries() {\n        // If writer and reader are on the same ledger, we just need to compare the entry id to know if we have more\n        // entries.\n        // If they are on different ledgers we have 2 cases :\n        // * Writer pointing to valid entry --> should return true since we have available entries\n        // * Writer pointing to \"invalid\" entry -1 (meaning no entries in that ledger) --> Need to check if the reader\n        // is\n        // at the last entry in the previous ledger\n        PositionImpl writerPosition = ledger.getLastPosition();\n        if (writerPosition.getEntryId() != -1) {\n            return readPosition.compareTo(writerPosition) <= 0;\n        } else {\n            // Fall back to checking the number of entries to ensure we are at the last entry in ledger and no ledgers\n            // are in the middle\n            return getNumberOfEntries() > 0;\n        }\n    }\nIn hasMoreEntries, the key variables are writerPosition and readPosition. writerPosition is cursor.ledger.lastConfirmedEntry, which is 2273599:4 and readPosition is cursor.readPosition, which is 2273599:0, thus, hasMoreEntries always return true and will fall into infinite loop and create a lot of read thread.\nThe bug is op.readPosition not sync immediatly with cursor.readPosition.\nChanges\n\nsync op.readPosition with cursor.readPosition before calling checkReadCompletion.\n\n@sijie @jiazhai @codelipenghui @lhotari  Please help take a look, we may discuss in this pr, thanks.", "createdAt": "2020-10-17T05:16:43Z", "url": "https://github.com/apache/pulsar/pull/8284", "merged": true, "mergeCommit": {"oid": "5df23b592f055416fbdf4b0a665e01153a4a237c"}, "closed": true, "closedAt": "2020-10-19T03:10:36Z", "author": {"login": "hangc0276"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdTT4bxAH2gAyNTA1MjE4NTIyOjJhOGIwNjBlNDcyZGUwNmVmMjAyY2EzNTIzOTNkMDY4ZDYxOTIyNTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdT7SvgAFqTUxMTM4NDcxMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2a8b060e472de06ef202ca352393d068d6192258", "author": {"user": {"login": "hangc0276", "name": "Hang Chen"}}, "url": "https://github.com/apache/pulsar/commit/2a8b060e472de06ef202ca352393d068d6192258", "committedDate": "2020-10-17T05:11:38Z", "message": "Fix Broker enters an infinite loop in ManagedLedgerImpl.asyncReadEntries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8282ba0748603d3f26e46a9fd261ed97878958c5", "author": {"user": {"login": "hangc0276", "name": "Hang Chen"}}, "url": "https://github.com/apache/pulsar/commit/8282ba0748603d3f26e46a9fd261ed97878958c5", "committedDate": "2020-10-17T05:23:12Z", "message": "format code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwOTU0MzA0", "url": "https://github.com/apache/pulsar/pull/8284#pullrequestreview-510954304", "createdAt": "2020-10-17T06:11:13Z", "commit": {"oid": "8282ba0748603d3f26e46a9fd261ed97878958c5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNjoxMToxM1rOHjV9zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNjoxMToxM1rOHjV9zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjgyMjA5Mg==", "bodyText": "Looks like it's better to move it to the following if ... else ...\nif (currentLedger == null || ledger.getId() != currentLedger.getId()) {\n       ...\n} else {\n      opReadEntry.updateReadPosition(opReadEntry.readPosition);\n}", "url": "https://github.com/apache/pulsar/pull/8284#discussion_r506822092", "createdAt": "2020-10-17T06:11:13Z", "author": {"login": "codelipenghui"}, "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedLedgerImpl.java", "diffHunk": "@@ -1618,6 +1616,8 @@ private void internalReadFromLedger(ReadHandle ledger, OpReadEntry opReadEntry)\n                         ledger.getId(), lastEntryInLedger, firstEntry);\n             }\n \n+            opReadEntry.updateReadPosition(opReadEntry.readPosition);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8282ba0748603d3f26e46a9fd261ed97878958c5"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b40a05858d6fcc1d17076d25de723946e608410", "author": {"user": {"login": "hangc0276", "name": "Hang Chen"}}, "url": "https://github.com/apache/pulsar/commit/7b40a05858d6fcc1d17076d25de723946e608410", "committedDate": "2020-10-17T06:21:28Z", "message": "format code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMTI0NzQw", "url": "https://github.com/apache/pulsar/pull/8284#pullrequestreview-511124740", "createdAt": "2020-10-18T09:16:56Z", "commit": {"oid": "7b40a05858d6fcc1d17076d25de723946e608410"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMTI5NjM3", "url": "https://github.com/apache/pulsar/pull/8284#pullrequestreview-511129637", "createdAt": "2020-10-18T10:21:15Z", "commit": {"oid": "7b40a05858d6fcc1d17076d25de723946e608410"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTExMzg0NzEz", "url": "https://github.com/apache/pulsar/pull/8284#pullrequestreview-511384713", "createdAt": "2020-10-19T03:06:41Z", "commit": {"oid": "7b40a05858d6fcc1d17076d25de723946e608410"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1249, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}