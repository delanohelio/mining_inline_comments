{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwMTIzMzgw", "number": 6684, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzoxNjozNFrODvqWMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNDoxNTo0N1rOD6FULA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzAzNDc1OnYy", "diffSide": "RIGHT", "path": "pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaInstance.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzoxNjozNFrOGCN7pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMjowNjowM1rOGCcc5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk3ODU5Nw==", "bodyText": "This is not applying any backpressure on the consumer. If the function doesn't have a mechanism to self-throttle, it will just blow up the memory.", "url": "https://github.com/apache/pulsar/pull/6684#discussion_r404978597", "createdAt": "2020-04-07T17:16:34Z", "author": {"login": "merlimat"}, "path": "pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaInstance.java", "diffHunk": "@@ -52,23 +53,49 @@ public JavaInstance(ContextImpl contextImpl, Object userClassObject) {\n         }\n     }\n \n-    public JavaExecutionResult handleMessage(Record<?> record, Object input) {\n+    public CompletableFuture<JavaExecutionResult> handleMessage(Record<?> record, Object input) {\n         if (context != null) {\n             context.setCurrentMessageContext(record);\n         }\n+\n+        final CompletableFuture<JavaExecutionResult> future = new CompletableFuture<>();\n         JavaExecutionResult executionResult = new JavaExecutionResult();\n+\n         try {\n             Object output;\n             if (function != null) {\n                 output = function.process(input, context);\n             } else {\n                 output = javaUtilFunction.apply(input);\n             }\n-            executionResult.setResult(output);\n+\n+            if (output instanceof CompletableFuture) {\n+                // Function is in format: Function<I, CompletableFuture<O>>\n+                ((CompletableFuture) output).whenComplete((obj, throwable) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7966d4609897fa4877b19aa15bdf1c06de37465a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk4Nzk4NQ==", "bodyText": "shared the same concern here. I think we need to introduce a setting to limit the max outstanding items (results) being processed.", "url": "https://github.com/apache/pulsar/pull/6684#discussion_r404987985", "createdAt": "2020-04-07T17:31:12Z", "author": {"login": "sijie"}, "path": "pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaInstance.java", "diffHunk": "@@ -52,23 +53,49 @@ public JavaInstance(ContextImpl contextImpl, Object userClassObject) {\n         }\n     }\n \n-    public JavaExecutionResult handleMessage(Record<?> record, Object input) {\n+    public CompletableFuture<JavaExecutionResult> handleMessage(Record<?> record, Object input) {\n         if (context != null) {\n             context.setCurrentMessageContext(record);\n         }\n+\n+        final CompletableFuture<JavaExecutionResult> future = new CompletableFuture<>();\n         JavaExecutionResult executionResult = new JavaExecutionResult();\n+\n         try {\n             Object output;\n             if (function != null) {\n                 output = function.process(input, context);\n             } else {\n                 output = javaUtilFunction.apply(input);\n             }\n-            executionResult.setResult(output);\n+\n+            if (output instanceof CompletableFuture) {\n+                // Function is in format: Function<I, CompletableFuture<O>>\n+                ((CompletableFuture) output).whenComplete((obj, throwable) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk3ODU5Nw=="}, "originalCommit": {"oid": "7966d4609897fa4877b19aa15bdf1c06de37465a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIxNjQ4NQ==", "bodyText": "Ok. Thanks for the suggestion.", "url": "https://github.com/apache/pulsar/pull/6684#discussion_r405216485", "createdAt": "2020-04-08T02:06:03Z", "author": {"login": "jiazhai"}, "path": "pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaInstance.java", "diffHunk": "@@ -52,23 +53,49 @@ public JavaInstance(ContextImpl contextImpl, Object userClassObject) {\n         }\n     }\n \n-    public JavaExecutionResult handleMessage(Record<?> record, Object input) {\n+    public CompletableFuture<JavaExecutionResult> handleMessage(Record<?> record, Object input) {\n         if (context != null) {\n             context.setCurrentMessageContext(record);\n         }\n+\n+        final CompletableFuture<JavaExecutionResult> future = new CompletableFuture<>();\n         JavaExecutionResult executionResult = new JavaExecutionResult();\n+\n         try {\n             Object output;\n             if (function != null) {\n                 output = function.process(input, context);\n             } else {\n                 output = javaUtilFunction.apply(input);\n             }\n-            executionResult.setResult(output);\n+\n+            if (output instanceof CompletableFuture) {\n+                // Function is in format: Function<I, CompletableFuture<O>>\n+                ((CompletableFuture) output).whenComplete((obj, throwable) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk3ODU5Nw=="}, "originalCommit": {"oid": "7966d4609897fa4877b19aa15bdf1c06de37465a"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjMxMDg0OnYy", "diffSide": "RIGHT", "path": "pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaInstance.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNDoxNTo0N1rOGRtxbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjoxNTo1OFrOGWoyCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyODkxMQ==", "bodyText": "Looks the blocking queue can be simplified by a semaphore", "url": "https://github.com/apache/pulsar/pull/6684#discussion_r421228911", "createdAt": "2020-05-07T04:15:47Z", "author": {"login": "codelipenghui"}, "path": "pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaInstance.java", "diffHunk": "@@ -40,9 +45,18 @@\n     private Function function;\n     private java.util.function.Function javaUtilFunction;\n \n-    public JavaInstance(ContextImpl contextImpl, Object userClassObject) {\n+    // for Async function max out standing items\n+    private final InstanceConfig instanceConfig;\n+    private final Executor executor;\n+    @Getter\n+    private final LinkedBlockingQueue<CompletableFuture<Void>> pendingAsyncRequests;\n+\n+    public JavaInstance(ContextImpl contextImpl, Object userClassObject, InstanceConfig instanceConfig) {\n \n         this.context = contextImpl;\n+        this.instanceConfig = instanceConfig;\n+        this.executor = Executors.newSingleThreadExecutor();\n+        this.pendingAsyncRequests = new LinkedBlockingQueue<>(this.instanceConfig.getMaxPendingAsyncRequests());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cbed6065b1434f96498d80696b622fc1faec5388"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5MDAyNw==", "bodyText": "we could change it once there is some performance issue in the future.", "url": "https://github.com/apache/pulsar/pull/6684#discussion_r426390027", "createdAt": "2020-05-18T06:15:58Z", "author": {"login": "jiazhai"}, "path": "pulsar-functions/instance/src/main/java/org/apache/pulsar/functions/instance/JavaInstance.java", "diffHunk": "@@ -40,9 +45,18 @@\n     private Function function;\n     private java.util.function.Function javaUtilFunction;\n \n-    public JavaInstance(ContextImpl contextImpl, Object userClassObject) {\n+    // for Async function max out standing items\n+    private final InstanceConfig instanceConfig;\n+    private final Executor executor;\n+    @Getter\n+    private final LinkedBlockingQueue<CompletableFuture<Void>> pendingAsyncRequests;\n+\n+    public JavaInstance(ContextImpl contextImpl, Object userClassObject, InstanceConfig instanceConfig) {\n \n         this.context = contextImpl;\n+        this.instanceConfig = instanceConfig;\n+        this.executor = Executors.newSingleThreadExecutor();\n+        this.pendingAsyncRequests = new LinkedBlockingQueue<>(this.instanceConfig.getMaxPendingAsyncRequests());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyODkxMQ=="}, "originalCommit": {"oid": "cbed6065b1434f96498d80696b622fc1faec5388"}, "originalPosition": 28}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1871, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}