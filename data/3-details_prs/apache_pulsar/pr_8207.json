{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk4MjI2NzI0", "number": 8207, "title": "Remove unnecessary locks", "bodyText": "Motivation\nThere are many unnecessary locks in MultiTopicsConsumerImpl, which affect performance.\nBlockingQueue is inherently thread-safe, and there is no need to lock in many places.\nModifications\nRemove unnecessary locks\nVerifying this change\nUse the perf tool, 3 * 8-core 16G nodes,recording time is about 2 minutes\n\nPrepare a 3-node pulsar cluster and produce some data\uff08topic with 4 partitions\uff09\nUse pulsar-perf on another machine,\nbin/pulsar-perf consume -u 'http://x.x.x.x:8080' -s my-sub-6 -sp Earliest -q 100000 persistent://public/default/p-topic\nPressure test twice, the first time with the original one, and the second time to replace the pulsar-client-original.jar in the lib folder\n\nbefore removing\uff1a\nAggregated throughput stats --- 11715556 records received --- 68813.420 msg/s --- 537.605 Mbit/s\nafter removing\uff1a\nAggregated throughput stats --- 25062077 records received --- 161656.814 msg/s --- 1262.944 Mbit/s", "createdAt": "2020-10-06T02:44:58Z", "url": "https://github.com/apache/pulsar/pull/8207", "merged": true, "mergeCommit": {"oid": "99627c9636d86bfa0f5863f7738a1cdc67224753"}, "closed": true, "closedAt": "2020-10-12T00:24:58Z", "author": {"login": "315157973"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdPvF00AH2gAyNDk4MjI2NzI0OmFjNDgyNjJkNGZhNDMxZGUwMzY0MzkxY2M1ODVjOTY5NGZlZmQ1ODE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQPhvNgH2gAyNDk4MjI2NzI0OmI2OWFiY2ZlYzM4NzliNmFkZmNiM2JkMWJlMzU3M2VhZDg4MTNkZGY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ac48262d4fa431de0364391cc585c9694fefd581", "author": {"user": {"login": "315157973", "name": "feynmanlin"}}, "url": "https://github.com/apache/pulsar/commit/ac48262d4fa431de0364391cc585c9694fefd581", "committedDate": "2020-10-06T02:38:00Z", "message": "remove lock"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNTYxNjc3", "url": "https://github.com/apache/pulsar/pull/8207#pullrequestreview-503561677", "createdAt": "2020-10-07T06:33:39Z", "commit": {"oid": "ac48262d4fa431de0364391cc585c9694fefd581"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNjozMzozOVrOHdkcgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNjozNToxNVrOHdke_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc2Nzg3NA==", "bodyText": "we are now using only writeLock so we could use a simple ReentrantLock and not a ReentrantReadWriteLock", "url": "https://github.com/apache/pulsar/pull/8207#discussion_r500767874", "createdAt": "2020-10-07T06:33:39Z", "author": {"login": "eolivelli"}, "path": "pulsar-client/src/main/java/org/apache/pulsar/client/impl/MultiTopicsConsumerImpl.java", "diffHunk": "@@ -219,51 +219,44 @@ private void receiveMessageFromConsumer(ConsumerImpl<T> consumer) {\n             messageReceived(consumer, message);\n \n             // we're modifying pausedConsumers\n-            lock.writeLock().lock();\n-            try {\n-                int size = incomingMessages.size();\n-                if (size >= maxReceiverQueueSize\n-                        || (size > sharedQueueResumeThreshold && !pausedConsumers.isEmpty())) {\n-                    // mark this consumer to be resumed later: if No more space left in shared queue,\n-                    // or if any consumer is already paused (to create fair chance for already paused consumers)\n-                    pausedConsumers.add(consumer);\n-                } else {\n-                    // Schedule next receiveAsync() if the incoming queue is not full. Use a different thread to avoid\n-                    // recursion and stack overflow\n-                    client.eventLoopGroup().execute(() -> {\n-                        receiveMessageFromConsumer(consumer);\n-                    });\n-                }\n-            } finally {\n-                lock.writeLock().unlock();\n+            int size = incomingMessages.size();\n+            if (size >= maxReceiverQueueSize\n+                    || (size > sharedQueueResumeThreshold && !pausedConsumers.isEmpty())) {\n+                // mark this consumer to be resumed later: if No more space left in shared queue,\n+                // or if any consumer is already paused (to create fair chance for already paused consumers)\n+                pausedConsumers.add(consumer);\n+            } else {\n+                // Schedule next receiveAsync() if the incoming queue is not full. Use a different thread to avoid\n+                // recursion and stack overflow\n+                client.eventLoopGroup().execute(() -> {\n+                    receiveMessageFromConsumer(consumer);\n+                });\n             }\n         });\n     }\n \n     private void messageReceived(ConsumerImpl<T> consumer, Message<T> message) {\n         checkArgument(message instanceof MessageImpl);\n-        lock.writeLock().lock();\n-        try {\n-            TopicMessageImpl<T> topicMessage = new TopicMessageImpl<>(\n+        TopicMessageImpl<T> topicMessage = new TopicMessageImpl<>(\n                 consumer.getTopic(), consumer.getTopicNameWithoutPartition(), message);\n \n-            if (log.isDebugEnabled()) {\n-                log.debug(\"[{}][{}] Received message from topics-consumer {}\",\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}][{}] Received message from topics-consumer {}\",\n                     topic, subscription, message.getMessageId());\n-            }\n+        }\n \n-            // if asyncReceive is waiting : return message to callback without adding to incomingMessages queue\n-            if (!pendingReceives.isEmpty()) {\n-                CompletableFuture<Message<T>> receivedFuture = pendingReceives.poll();\n-                unAckedMessageTracker.add(topicMessage.getMessageId());\n-                listenerExecutor.execute(() -> receivedFuture.complete(topicMessage));\n-            } else if (enqueueMessageAndCheckBatchReceive(topicMessage)) {\n-                if (hasPendingBatchReceive()) {\n-                    notifyPendingBatchReceivedCallBack();\n-                }\n+        // if asyncReceive is waiting : return message to callback without adding to incomingMessages queue\n+        CompletableFuture<Message<T>> receivedFuture = pendingReceives.poll();\n+        if (receivedFuture != null) {\n+            unAckedMessageTracker.add(topicMessage.getMessageId());\n+            listenerExecutor.execute(() -> receivedFuture.complete(topicMessage));\n+        } else if (enqueueMessageAndCheckBatchReceive(topicMessage) && hasPendingBatchReceive()) {\n+            try {\n+                lock.writeLock().lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac48262d4fa431de0364391cc585c9694fefd581"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc2ODExMw==", "bodyText": "not every call of this notifyPendingBatchReceivedCallBack method are guarded by the lock, do we need to use the lock here ?", "url": "https://github.com/apache/pulsar/pull/8207#discussion_r500768113", "createdAt": "2020-10-07T06:34:17Z", "author": {"login": "eolivelli"}, "path": "pulsar-client/src/main/java/org/apache/pulsar/client/impl/MultiTopicsConsumerImpl.java", "diffHunk": "@@ -219,51 +219,44 @@ private void receiveMessageFromConsumer(ConsumerImpl<T> consumer) {\n             messageReceived(consumer, message);\n \n             // we're modifying pausedConsumers\n-            lock.writeLock().lock();\n-            try {\n-                int size = incomingMessages.size();\n-                if (size >= maxReceiverQueueSize\n-                        || (size > sharedQueueResumeThreshold && !pausedConsumers.isEmpty())) {\n-                    // mark this consumer to be resumed later: if No more space left in shared queue,\n-                    // or if any consumer is already paused (to create fair chance for already paused consumers)\n-                    pausedConsumers.add(consumer);\n-                } else {\n-                    // Schedule next receiveAsync() if the incoming queue is not full. Use a different thread to avoid\n-                    // recursion and stack overflow\n-                    client.eventLoopGroup().execute(() -> {\n-                        receiveMessageFromConsumer(consumer);\n-                    });\n-                }\n-            } finally {\n-                lock.writeLock().unlock();\n+            int size = incomingMessages.size();\n+            if (size >= maxReceiverQueueSize\n+                    || (size > sharedQueueResumeThreshold && !pausedConsumers.isEmpty())) {\n+                // mark this consumer to be resumed later: if No more space left in shared queue,\n+                // or if any consumer is already paused (to create fair chance for already paused consumers)\n+                pausedConsumers.add(consumer);\n+            } else {\n+                // Schedule next receiveAsync() if the incoming queue is not full. Use a different thread to avoid\n+                // recursion and stack overflow\n+                client.eventLoopGroup().execute(() -> {\n+                    receiveMessageFromConsumer(consumer);\n+                });\n             }\n         });\n     }\n \n     private void messageReceived(ConsumerImpl<T> consumer, Message<T> message) {\n         checkArgument(message instanceof MessageImpl);\n-        lock.writeLock().lock();\n-        try {\n-            TopicMessageImpl<T> topicMessage = new TopicMessageImpl<>(\n+        TopicMessageImpl<T> topicMessage = new TopicMessageImpl<>(\n                 consumer.getTopic(), consumer.getTopicNameWithoutPartition(), message);\n \n-            if (log.isDebugEnabled()) {\n-                log.debug(\"[{}][{}] Received message from topics-consumer {}\",\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}][{}] Received message from topics-consumer {}\",\n                     topic, subscription, message.getMessageId());\n-            }\n+        }\n \n-            // if asyncReceive is waiting : return message to callback without adding to incomingMessages queue\n-            if (!pendingReceives.isEmpty()) {\n-                CompletableFuture<Message<T>> receivedFuture = pendingReceives.poll();\n-                unAckedMessageTracker.add(topicMessage.getMessageId());\n-                listenerExecutor.execute(() -> receivedFuture.complete(topicMessage));\n-            } else if (enqueueMessageAndCheckBatchReceive(topicMessage)) {\n-                if (hasPendingBatchReceive()) {\n-                    notifyPendingBatchReceivedCallBack();\n-                }\n+        // if asyncReceive is waiting : return message to callback without adding to incomingMessages queue\n+        CompletableFuture<Message<T>> receivedFuture = pendingReceives.poll();\n+        if (receivedFuture != null) {\n+            unAckedMessageTracker.add(topicMessage.getMessageId());\n+            listenerExecutor.execute(() -> receivedFuture.complete(topicMessage));\n+        } else if (enqueueMessageAndCheckBatchReceive(topicMessage) && hasPendingBatchReceive()) {\n+            try {\n+                lock.writeLock().lock();\n+                notifyPendingBatchReceivedCallBack();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac48262d4fa431de0364391cc585c9694fefd581"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc2ODUwOA==", "bodyText": "probably this comment is no more useful", "url": "https://github.com/apache/pulsar/pull/8207#discussion_r500768508", "createdAt": "2020-10-07T06:35:15Z", "author": {"login": "eolivelli"}, "path": "pulsar-client/src/main/java/org/apache/pulsar/client/impl/MultiTopicsConsumerImpl.java", "diffHunk": "@@ -219,51 +219,44 @@ private void receiveMessageFromConsumer(ConsumerImpl<T> consumer) {\n             messageReceived(consumer, message);\n \n             // we're modifying pausedConsumers", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac48262d4fa431de0364391cc585c9694fefd581"}, "originalPosition": 3}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "675b28d1755f8968ec51032f80543023d523465d", "author": {"user": {"login": "315157973", "name": "feynmanlin"}}, "url": "https://github.com/apache/pulsar/commit/675b28d1755f8968ec51032f80543023d523465d", "committedDate": "2020-10-07T08:46:10Z", "message": "Reduce lock range"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNjYyMTA1", "url": "https://github.com/apache/pulsar/pull/8207#pullrequestreview-503662105", "createdAt": "2020-10-07T08:53:59Z", "commit": {"oid": "675b28d1755f8968ec51032f80543023d523465d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwODo1NDowMFrOHdpRug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwODo1NDowMFrOHdpRug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg0NzAzNA==", "bodyText": "can you please explain the reason for this 'synchronized' block ?", "url": "https://github.com/apache/pulsar/pull/8207#discussion_r500847034", "createdAt": "2020-10-07T08:54:00Z", "author": {"login": "eolivelli"}, "path": "pulsar-client/src/main/java/org/apache/pulsar/client/impl/ConsumerBase.java", "diffHunk": "@@ -677,19 +677,16 @@ protected void notifyPendingBatchReceivedCallBack() {\n         if (opBatchReceive == null || opBatchReceive.future == null) {\n             return;\n         }\n-        notifyPendingBatchReceivedCallBack(opBatchReceive);\n+        synchronized (incomingMessages) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "675b28d1755f8968ec51032f80543023d523465d"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzOTAzMTE0", "url": "https://github.com/apache/pulsar/pull/8207#pullrequestreview-503903114", "createdAt": "2020-10-07T13:52:56Z", "commit": {"oid": "675b28d1755f8968ec51032f80543023d523465d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b69abcfec3879b6adfcb3bd1be3573ead8813ddf", "author": {"user": {"login": "315157973", "name": "feynmanlin"}}, "url": "https://github.com/apache/pulsar/commit/b69abcfec3879b6adfcb3bd1be3573ead8813ddf", "committedDate": "2020-10-07T16:25:27Z", "message": "use ReentrantLock"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 143, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}