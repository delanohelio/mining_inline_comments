{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMzNDMyMjIz", "number": 7255, "title": "Re-work Function MetaDataManager to make all metadata writes only by the leader", "bodyText": "(If this PR fixes a github issue, please add Fixes #<xyz>.)\nFixes #\n(or if this PR is one task of a github issue, please add Master Issue: #<xyz> to link to the master issue.)\nMaster Issue: #\nMotivation\nCurrently Function Metadata topic is not compacted, which means that in a long running system, with sufficient number of function submissions/updates/state changes, the startup lag for workers to read from beginning increases linearly.\nHowever the current mechanism of Function Metadata topic writes does not lend itself to compaction. This is because all workers write into the topic and only one of them wins(it need not be the last).\nThis pr makes a first stab at simplifying the current workflow. Now, upon a function submission/update/state change, the workers simply pass that request to the leader. The leader is the arbitrer of what goes in(just like it is today) and is the only one writing to the function metadata topic. The rest of the worker still continue to tail the topic to receive the appropriate updates. The leader does not have the tailer, and instead directly updates in in-memory state when it writes to the metadata topic.\nModifications\nDescribe the modifications you've done.\nVerifying this change\n\n Make sure that the change passes the CI checks.\n\n(Please pick either of the following options)\nThis change is a trivial rework / code cleanup without any test coverage.\n(or)\nThis change is already covered by existing tests, such as (please describe tests).\n(or)\nThis change added tests and can be verified as follows:\n(example:)\n\nAdded integration tests for end-to-end deployment with large payloads (10MB)\nExtended integration test for recovery after broker failure\n\nDoes this pull request potentially affect one of the following parts:\nIf yes was chosen, please highlight the changes\n\nDependencies (does it add or upgrade a dependency): (yes / no)\nThe public API: (yes / no)\nThe schema: (yes / no / don't know)\nThe default values of configurations: (yes / no)\nThe wire protocol: (yes / no)\nThe rest endpoints: (yes / no)\nThe admin cli options: (yes / no)\nAnything that affects deployment: (yes / no / don't know)\n\nDocumentation\n\nDoes this pull request introduce a new feature? (yes / no)\nIf yes, how is the feature documented? (not applicable / docs / JavaDocs / not documented)\nIf a feature is not applicable for documentation, explain why?\nIf a feature is not documented yet in this PR, please create a followup issue for adding the documentation", "createdAt": "2020-06-12T02:43:47Z", "url": "https://github.com/apache/pulsar/pull/7255", "merged": true, "mergeCommit": {"oid": "c83a6563f9e0c71d7a5fd62fdece3e29128bbae0"}, "closed": true, "closedAt": "2020-06-26T14:49:03Z", "author": {"login": "srkukarni"}, "timelineItems": {"totalCount": 59, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcqEBjUgH2gAyNDMzNDMyMjIzOmJmMTFmMGNhNjUzMmVlM2ExNzZiZGUyN2I5NDRiOGI0YmM3YTZmZjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcu148hAH2gAyNDMzNDMyMjIzOjk3MDk0Nzg4ZTUyYmFhYmFjZWEyMTEwMjI4YWRmNTRiZjZlOWNlMmQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "bf11f0ca6532ee3a176bde27b944b8b4bc7a6ff3", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/bf11f0ca6532ee3a176bde27b944b8b4bc7a6ff3", "committedDate": "2020-06-11T01:32:13Z", "message": "Function workers re-direct call update requests to the leader"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "691d0548ee9552ddef23298a3ce5d00bda022037", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/691d0548ee9552ddef23298a3ce5d00bda022037", "committedDate": "2020-06-11T01:45:22Z", "message": "Fixed test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfb203d011dcded6248c8d33e414d519fa955b1a", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/cfb203d011dcded6248c8d33e414d519fa955b1a", "committedDate": "2020-06-11T05:18:25Z", "message": "tests pass"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8145443b49957898144cd9ec1f2b76b0b1f6f09", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/f8145443b49957898144cd9ec1f2b76b0b1f6f09", "committedDate": "2020-06-11T07:44:32Z", "message": "Working version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0a7f284351f58810e8c962221413bcf6578db02", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/b0a7f284351f58810e8c962221413bcf6578db02", "committedDate": "2020-06-11T15:42:44Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e612318f8ad1b0b7356d1fb885b4723eca7c6afd", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/e612318f8ad1b0b7356d1fb885b4723eca7c6afd", "committedDate": "2020-06-11T15:43:08Z", "message": "Merge remote-tracking branch 'apache/master' into functions_leader_executor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea53753ec173eff15fd4223f634bc31e658fad74", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/ea53753ec173eff15fd4223f634bc31e658fad74", "committedDate": "2020-06-12T02:36:27Z", "message": "Merge branch 'master' into functions_leader_executor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c02274ab17fed9c3d85a98c1ff4a90201bfb3a88", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/c02274ab17fed9c3d85a98c1ff4a90201bfb3a88", "committedDate": "2020-06-12T18:57:03Z", "message": "Short circuit update"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93c54e1b4083107010a90fc162a1a7039c2e64b8", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/93c54e1b4083107010a90fc162a1a7039c2e64b8", "committedDate": "2020-06-12T19:15:07Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd8766e46f22329c831b9141a05d1a90b8e3146e", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/fd8766e46f22329c831b9141a05d1a90b8e3146e", "committedDate": "2020-06-12T19:35:03Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5b17528eea66df0d94fad47616f901f53a42473", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/b5b17528eea66df0d94fad47616f901f53a42473", "committedDate": "2020-06-12T23:03:34Z", "message": "Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3403c7ae8129f12a3f0e982e3372ad5d4ad5d7a", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/d3403c7ae8129f12a3f0e982e3372ad5d4ad5d7a", "committedDate": "2020-06-12T23:05:19Z", "message": "Added one more catch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc3646ebaae59d683462b240478fae3319aeac7a", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/cc3646ebaae59d683462b240478fae3319aeac7a", "committedDate": "2020-06-12T23:05:42Z", "message": "Added one more catch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b8d6d251bbeac1ad565aaebd0b4629794258c82", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/6b8d6d251bbeac1ad565aaebd0b4629794258c82", "committedDate": "2020-06-12T23:06:35Z", "message": "Seperated internal and external errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4", "committedDate": "2020-06-13T00:04:06Z", "message": "Fix test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwODY2Mjg4", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-430866288", "createdAt": "2020-06-15T17:51:55Z", "commit": {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzo1MTo1NVrOGj8mXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzo1MTo1NVrOGj8mXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0NjIwNw==", "bodyText": "I don't think it is a good idea to expose this in the admin API. This is an internal thing and users should not have to the option to call this directly", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440346207", "createdAt": "2020-06-15T17:51:55Z", "author": {"login": "jerrypeng"}, "path": "pulsar-client-admin/src/main/java/org/apache/pulsar/client/admin/Functions.java", "diffHunk": "@@ -893,4 +893,42 @@ void putFunctionState(String tenant, String namespace, String function, Function\n      */\n     CompletableFuture<Void> putFunctionStateAsync(\n             String tenant, String namespace, String function, FunctionState state);\n+\n+    /**\n+     * Sends update function request to worker leader. This is an internal only api\n+     * <p/>\n+     *\n+     * @param tenant\n+     *            Tenant name\n+     * @param namespace\n+     *            Namespace name\n+     * @param function\n+     *            Function name\n+     * @param functionMetaData\n+     *            byte repr of FunctionMetaData\n+     **\n+     * @throws NotAuthorizedException\n+     *             You don't have admin permission to get the configuration of the cluster\n+     * @throws PulsarAdminException\n+     *             Unexpected error\n+     */\n+    void updateOnWorkerLeader(String tenant, String namespace, String function, byte[] functionMetaData,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwODY2NjU3", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-430866657", "createdAt": "2020-06-15T17:52:27Z", "commit": {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzo1MjoyN1rOGj8nZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNzo1MjoyN1rOGj8nZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0NjQ3MQ==", "bodyText": "Same comment about exposing these internal APIs to end users", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440346471", "createdAt": "2020-06-15T17:52:27Z", "author": {"login": "jerrypeng"}, "path": "pulsar-client-admin/src/main/java/org/apache/pulsar/client/admin/internal/FunctionsImpl.java", "diffHunk": "@@ -984,4 +985,53 @@ public void putFunctionState(String tenant, String namespace, String function, F\n         }\n         return future;\n     }\n+\n+    @Override\n+    public void updateOnWorkerLeader(String tenant, String namespace,\n+                                     String function, byte[] functionMetaData,\n+                                     boolean delete) throws PulsarAdminException {\n+        try {\n+            updateOnWorkerLeaderAsync(tenant, namespace, function,\n+                    functionMetaData, delete).get(this.readTimeoutMs, TimeUnit.MILLISECONDS);\n+        } catch (ExecutionException e) {\n+            throw (PulsarAdminException) e.getCause();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            throw new PulsarAdminException(e);\n+        } catch (TimeoutException e) {\n+            throw new PulsarAdminException.TimeoutException(e);\n+        }\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> updateOnWorkerLeaderAsync(String tenant, String namespace,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwODkyMDQ2", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-430892046", "createdAt": "2020-06-15T18:29:37Z", "commit": {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODoyOTozOFrOGj91bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODoyOTozOFrOGj91bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2NjQ0NA==", "bodyText": "Shouldn't we also set a key so that we can use topic compaction?", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440366444", "createdAt": "2020-06-15T18:29:38Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -168,68 +151,78 @@ public synchronized boolean containsFunction(String tenant, String namespace, St\n         return containsFunctionMetaData(tenant, namespace, functionName);\n     }\n \n-    /**\n-     * Sends an update request to the FMT (Function Metadata Topic)\n-     * @param functionMetaData The function metadata that needs to be updated\n-     * @return a completable future of when the update has been applied\n-     */\n-    public synchronized CompletableFuture<RequestResult> updateFunction(FunctionMetaData functionMetaData) {\n-\n-        FunctionMetaData existingFunctionMetadata = null;\n-        if (containsFunction(functionMetaData.getFunctionDetails().getTenant(),\n-                functionMetaData.getFunctionDetails().getNamespace(),\n-                functionMetaData.getFunctionDetails().getName())) {\n-            existingFunctionMetadata = getFunctionMetaData(functionMetaData.getFunctionDetails().getTenant(),\n-                    functionMetaData.getFunctionDetails().getNamespace(),\n-                    functionMetaData.getFunctionDetails().getName());\n+    public synchronized void updateFunctionOnLeader(FunctionMetaData functionMetaData, boolean delete)\n+            throws IllegalStateException, IllegalArgumentException {\n+        if (exclusiveLeaderProducer == null) {\n+            throw new IllegalStateException(\"Not the leader\");\n+        }\n+        boolean needsScheduling;\n+        if (delete) {\n+            needsScheduling = proccessDeregister(functionMetaData);\n+        } else {\n+            needsScheduling = processUpdate(functionMetaData);\n+        }\n+        Request.ServiceRequest serviceRequest = Request.ServiceRequest.newBuilder()\n+                .setServiceRequestType(delete ? Request.ServiceRequest.ServiceRequestType.DELETE : Request.ServiceRequest.ServiceRequestType.UPDATE)\n+                .setFunctionMetaData(functionMetaData)\n+                .setWorkerId(workerConfig.getWorkerId())\n+                .setRequestId(UUID.randomUUID().toString())\n+                .build();\n+        try {\n+            exclusiveLeaderProducer.send(serviceRequest.toByteArray());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4"}, "originalPosition": 127}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwODk0Njkx", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-430894691", "createdAt": "2020-06-15T18:33:21Z", "commit": {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODozMzoyMlrOGj99gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODozMzoyMlrOGj99gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2ODUxMg==", "bodyText": "I don't think this is the right approach.  You might be interrupting a message being processed.  The goal is the reach to the end and process all the messages.  I would just doing something similar to what I have done here:\nhttps://github.com/apache/pulsar/pull/7237/files#diff-fb140c4ab9a86232f8d85b90cf0d3705R168", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440368512", "createdAt": "2020-06-15T18:33:22Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataTopicTailer.java", "diffHunk": "@@ -77,12 +89,25 @@ public void run() {\n                     if (!(th instanceof InterruptedException || th.getCause() instanceof InterruptedException)) {\n                         log.warn(\"Encountered error when metadata tailer is not running\", th);\n                     }\n-                    return;\n                 }\n             }\n         }\n     }\n \n+    public void stopWhenNoMoreMessages() {\n+        stopOnNoMessageAvailable = true;\n+        readerThread.interrupt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwODk3MjA2", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-430897206", "createdAt": "2020-06-15T18:37:08Z", "commit": {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODozNzowOFrOGj-Fdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODozNzowOFrOGj-Fdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MDU1MQ==", "bodyText": "we shouldn't need to catch any exceptions.  The thread needs to complete without any errors", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440370551", "createdAt": "2020-06-15T18:37:08Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataTopicTailer.java", "diffHunk": "@@ -77,12 +89,25 @@ public void run() {\n                     if (!(th instanceof InterruptedException || th.getCause() instanceof InterruptedException)) {\n                         log.warn(\"Encountered error when metadata tailer is not running\", th);\n                     }\n-                    return;\n                 }\n             }\n         }\n     }\n \n+    public void stopWhenNoMoreMessages() {\n+        stopOnNoMessageAvailable = true;\n+        readerThread.interrupt();\n+        // We need to wait here till the thread exits to make sure that the reader is up to date\n+        while (true) {\n+            try {\n+                readerThread.join();\n+                return;\n+            } catch (InterruptedException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwOTEwMjc5", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-430910279", "createdAt": "2020-06-15T18:56:34Z", "commit": {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODo1NjozNVrOGj-uOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODo1NjozNVrOGj-uOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4MDk4Ng==", "bodyText": "I don't think we should check \"! stopOnNoMessageAvailable\". If errors occur while stopOnNoMessageAvailable=true, we still need to correctly handle the exception and not ignore it because that means we didn't process all messages successfully", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440380986", "createdAt": "2020-06-15T18:56:35Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataTopicTailer.java", "diffHunk": "@@ -63,12 +65,22 @@ public void start() {\n \n     @Override\n     public void run() {\n-        while(running) {\n+        while (running) {\n+            if (stopOnNoMessageAvailable) {\n+                try {\n+                    if (!reader.hasMessageAvailable()) {\n+                        break;\n+                    }\n+                } catch (PulsarClientException e) {\n+                    log.error(\"Received exception while testing hasMessageAvailable\", e);\n+                    errorNotifier.triggerError(e);\n+                }\n+            }\n             try {\n                 Message<byte[]> msg = reader.readNext();\n                 processRequest(msg);\n             } catch (Throwable th) {\n-                if (running) {\n+                if (running && !stopOnNoMessageAvailable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwOTE3MjMz", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-430917233", "createdAt": "2020-06-15T19:06:38Z", "commit": {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxOTowNjozOVrOGj_DmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxOTowNjozOVrOGj_DmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4NjQ1Ng==", "bodyText": "Why do you need to move this here?", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440386456", "createdAt": "2020-06-15T19:06:39Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/WorkerService.java", "diffHunk": "@@ -171,6 +171,9 @@ public void start(URI dlogUri,\n             this.functionMetaDataManager = new FunctionMetaDataManager(\n                     this.workerConfig, this.schedulerManager, this.client, errorNotifier);\n \n+            // initialize function metadata manager\n+            this.functionMetaDataManager.initialize();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwOTI3NDE1", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-430927415", "createdAt": "2020-06-15T19:22:29Z", "commit": {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxOToyMjoyOVrOGj_jdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxOToyMjoyOVrOGj_jdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM5NDYxMw==", "bodyText": "It is not a good idea to simply re-create the metadata tailer object.  This will cause the tailer to start reading from the beginning.  This will cause all the tailer to have to re-read the whole topic.  The problem here is not only that the the tailer has to re-read the whole topic which can take time but during that time the in-memory metadata map for the worker will be inconsistent.  If a user request is sent to the worker during this time, the behavior might be incorrect.  I would suggest keeping track of the message Id that represents to which message the current view of the metadata relates to.  When the worker is the leader and it updates its in memory metadata cache and  produces messages to metadata topic, we should update the message id.  When the worker loses leadership, the tailer should use the message id and start reading from there", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440394613", "createdAt": "2020-06-15T19:22:29Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -168,68 +151,78 @@ public synchronized boolean containsFunction(String tenant, String namespace, St\n         return containsFunctionMetaData(tenant, namespace, functionName);\n     }\n \n-    /**\n-     * Sends an update request to the FMT (Function Metadata Topic)\n-     * @param functionMetaData The function metadata that needs to be updated\n-     * @return a completable future of when the update has been applied\n-     */\n-    public synchronized CompletableFuture<RequestResult> updateFunction(FunctionMetaData functionMetaData) {\n-\n-        FunctionMetaData existingFunctionMetadata = null;\n-        if (containsFunction(functionMetaData.getFunctionDetails().getTenant(),\n-                functionMetaData.getFunctionDetails().getNamespace(),\n-                functionMetaData.getFunctionDetails().getName())) {\n-            existingFunctionMetadata = getFunctionMetaData(functionMetaData.getFunctionDetails().getTenant(),\n-                    functionMetaData.getFunctionDetails().getNamespace(),\n-                    functionMetaData.getFunctionDetails().getName());\n+    public synchronized void updateFunctionOnLeader(FunctionMetaData functionMetaData, boolean delete)\n+            throws IllegalStateException, IllegalArgumentException {\n+        if (exclusiveLeaderProducer == null) {\n+            throw new IllegalStateException(\"Not the leader\");\n+        }\n+        boolean needsScheduling;\n+        if (delete) {\n+            needsScheduling = proccessDeregister(functionMetaData);\n+        } else {\n+            needsScheduling = processUpdate(functionMetaData);\n+        }\n+        Request.ServiceRequest serviceRequest = Request.ServiceRequest.newBuilder()\n+                .setServiceRequestType(delete ? Request.ServiceRequest.ServiceRequestType.DELETE : Request.ServiceRequest.ServiceRequestType.UPDATE)\n+                .setFunctionMetaData(functionMetaData)\n+                .setWorkerId(workerConfig.getWorkerId())\n+                .setRequestId(UUID.randomUUID().toString())\n+                .build();\n+        try {\n+            exclusiveLeaderProducer.send(serviceRequest.toByteArray());\n+        } catch (Exception e) {\n+            log.error(\"Could not write into Function Metadata topic\", e);\n+            errorNotifier.triggerError(e);\n+        }\n+        if (needsScheduling) {\n+            this.schedulerManager.schedule();\n         }\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(existingFunctionMetadata, functionMetaData);\n-\n-        Request.ServiceRequest updateRequest = ServiceRequestUtils.getUpdateRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n-\n-        return submit(updateRequest);\n     }\n \n-\n-    /**\n-     * Sends a deregister request to the FMT (Function Metadata Topic) for a function\n-     * @param tenant the tenant the function that needs to be deregistered belongs to\n-     * @param namespace the namespace the function that needs to be deregistered belongs to\n-     * @param functionName the name of the function\n-     * @return a completable future of when the deregister has been applied\n-     */\n-    public synchronized CompletableFuture<RequestResult> deregisterFunction(String tenant, String namespace, String functionName) {\n-        FunctionMetaData functionMetaData = this.functionMetaDataMap.get(tenant).get(namespace).get(functionName);\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(functionMetaData, functionMetaData);\n-\n-        Request.ServiceRequest deregisterRequest = ServiceRequestUtils.getDeregisterRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n-\n-        return submit(deregisterRequest);\n+    // Note that this method cannot be syncrhonized because the tailer might still be processing messages\n+    public void acquireLeadership() {\n+        log.info(\"FunctionMetaDataManager becoming leader by creating exclusive producer\");\n+        FunctionMetaDataTopicTailer tailer = internalAcquireLeadership();\n+        // Now that we have created the exclusive producer, wait for reader to get over\n+        if (tailer != null) {\n+            tailer.stopWhenNoMoreMessages();\n+            tailer.close();\n+        }\n+        this.schedulerManager.schedule();\n+        log.info(\"FunctionMetaDataManager done becoming leader by doing its first schedule\");\n     }\n \n-    /**\n-     * Sends a start/stop function request to the FMT (Function Metadata Topic) for a function\n-     * @param tenant the tenant the function that needs to be deregistered belongs to\n-     * @param namespace the namespace the function that needs to be deregistered belongs to\n-     * @param functionName the name of the function\n-     * @param instanceId the instanceId of the function, -1 if for all instances\n-     * @param start do we need to start or stop\n-     * @return a completable future of when the start/stop has been applied\n-     */\n-    public synchronized CompletableFuture<RequestResult> changeFunctionInstanceStatus(String tenant, String namespace, String functionName,\n-                                                                                      Integer instanceId, boolean start) {\n-        FunctionMetaData functionMetaData = this.functionMetaDataMap.get(tenant).get(namespace).get(functionName);\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.changeFunctionInstanceStatus(functionMetaData, instanceId, start);\n-\n-        Request.ServiceRequest updateRequest = ServiceRequestUtils.getUpdateRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n+    private synchronized FunctionMetaDataTopicTailer internalAcquireLeadership() {\n+        if (exclusiveLeaderProducer == null) {\n+            try {\n+                exclusiveLeaderProducer = pulsarClient.newProducer()\n+                        .topic(this.workerConfig.getFunctionMetadataTopic())\n+                        .producerName(workerConfig.getWorkerId() + \"-leader\")\n+                        // .type(EXCLUSIVE)\n+                        .create();\n+            } catch (PulsarClientException e) {\n+                log.error(\"Error creating exclusive producer\", e);\n+                errorNotifier.triggerError(e);\n+            }\n+        } else {\n+            log.error(\"Logic Error in FunctionMetaData Manager\");\n+            errorNotifier.triggerError(new IllegalStateException());\n+        }\n+        FunctionMetaDataTopicTailer tailer = this.functionMetaDataTopicTailer;\n+        this.functionMetaDataTopicTailer = null;\n+        return tailer;\n+    }\n \n-        return submit(updateRequest);\n+    public synchronized void giveupLeadership() {\n+        log.info(\"FunctionMetaDataManager giving up leadership by closing exclusive producer\");\n+        try {\n+            exclusiveLeaderProducer.close();\n+        } catch (PulsarClientException e) {\n+            log.error(\"Error closing exclusive producer\", e);\n+            errorNotifier.triggerError(e);\n+        }\n+        exclusiveLeaderProducer = null;\n+        initializeTailer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4"}, "originalPosition": 222}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwOTM3ODUx", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-430937851", "createdAt": "2020-06-15T19:39:12Z", "commit": {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxOTozOToxMlrOGkAFTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxOTozOToxMlrOGkAFTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQwMzI3OQ==", "bodyText": "Currently when there are concurrent modifications, the worker will fail requests.  That doesn't seem to be done now.  All requests are accepted and 200s will be returned to the user but internally some requests will just be silently ignored.", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r440403279", "createdAt": "2020-06-15T19:39:12Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -168,68 +151,78 @@ public synchronized boolean containsFunction(String tenant, String namespace, St\n         return containsFunctionMetaData(tenant, namespace, functionName);\n     }\n \n-    /**\n-     * Sends an update request to the FMT (Function Metadata Topic)\n-     * @param functionMetaData The function metadata that needs to be updated\n-     * @return a completable future of when the update has been applied\n-     */\n-    public synchronized CompletableFuture<RequestResult> updateFunction(FunctionMetaData functionMetaData) {\n-\n-        FunctionMetaData existingFunctionMetadata = null;\n-        if (containsFunction(functionMetaData.getFunctionDetails().getTenant(),\n-                functionMetaData.getFunctionDetails().getNamespace(),\n-                functionMetaData.getFunctionDetails().getName())) {\n-            existingFunctionMetadata = getFunctionMetaData(functionMetaData.getFunctionDetails().getTenant(),\n-                    functionMetaData.getFunctionDetails().getNamespace(),\n-                    functionMetaData.getFunctionDetails().getName());\n+    public synchronized void updateFunctionOnLeader(FunctionMetaData functionMetaData, boolean delete)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aeb51ca4c44bb0cdf83904dcb8b2bbe9446a0da4"}, "originalPosition": 109}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "527aea2affed67ca9bda71831c9fa615be9529c5", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/527aea2affed67ca9bda71831c9fa615be9529c5", "committedDate": "2020-06-18T16:24:20Z", "message": "Address feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dcc4cd2ceb555366c4ce54ffd32979be4c6c99a6", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/dcc4cd2ceb555366c4ce54ffd32979be4c6c99a6", "committedDate": "2020-06-18T17:00:37Z", "message": "Do not expose updateOnLeader to functions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8f2d345af3630f651ab5ac0c39c229df8d6d5c5", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/f8f2d345af3630f651ab5ac0c39c229df8d6d5c5", "committedDate": "2020-06-18T17:15:37Z", "message": "hide api"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "476b692bdc9b7a2aece1e4ccad597dca30391b27", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/476b692bdc9b7a2aece1e4ccad597dca30391b27", "committedDate": "2020-06-18T17:15:55Z", "message": "hide api"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad7309946d060252bf19aabc589f152bb93d1423", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/ad7309946d060252bf19aabc589f152bb93d1423", "committedDate": "2020-06-20T22:25:04Z", "message": "Merge branch 'master' into functions_leader_executor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acd999f81b21f73e78ec951df9a81e93c541666e", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/acd999f81b21f73e78ec951df9a81e93c541666e", "committedDate": "2020-06-20T22:31:49Z", "message": "removed duplicate comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a256bc987bca5a8cc61c2b95b0103b3c159d4399", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/a256bc987bca5a8cc61c2b95b0103b3c159d4399", "committedDate": "2020-06-20T22:49:27Z", "message": "Do leadership changes in function metadata manager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fc89c35e9752682a70540510447764639ed5fbe", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/8fc89c35e9752682a70540510447764639ed5fbe", "committedDate": "2020-06-21T00:00:17Z", "message": "make the function sync"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1MTUxNTYx", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-435151561", "createdAt": "2020-06-22T17:55:17Z", "commit": {"oid": "8fc89c35e9752682a70540510447764639ed5fbe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzo1NToxN1rOGnLM2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNzo1NToxN1rOGnLM2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzczMTE2Mg==", "bodyText": "Should we separate out the metadata tailer from the meta manager like what we did for the assignment tailer and runtime manager?", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r443731162", "createdAt": "2020-06-22T17:55:17Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -90,25 +79,25 @@ public FunctionMetaDataManager(WorkerConfig workerConfig,\n      */\n     public void initialize() {\n         try {\n+            initializeTailer();\n             this.functionMetaDataTopicTailer = new FunctionMetaDataTopicTailer(this,\n                     pulsarClient.newReader(), this.workerConfig, this.errorNotifier);\n             // read all existing messages\n-            this.setInitializePhase(true);\n             while (this.functionMetaDataTopicTailer.getReader().hasMessageAvailable()) {\n                 this.functionMetaDataTopicTailer.processRequest(this.functionMetaDataTopicTailer.getReader().readNext());\n             }\n-            this.setInitializePhase(false);\n-            \n-\n         } catch (Exception e) {\n             log.error(\"Failed to initialize meta data store\", e);\n-            throw new RuntimeException(e);\n+            errorNotifier.triggerError(e);\n         }\n     }\n-    \n+\n+    private void initializeTailer() throws PulsarClientException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fc89c35e9752682a70540510447764639ed5fbe"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1NTExMTAw", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-435511100", "createdAt": "2020-06-23T07:27:43Z", "commit": {"oid": "8fc89c35e9752682a70540510447764639ed5fbe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwNzoyNzo0M1rOGncoow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwNzoyNzo0M1rOGncoow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAxNjgwMw==", "bodyText": "Can you add some comments to this method as well of the FunctionMetadataManager to explain the workflow of processing a metadata request?", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444016803", "createdAt": "2020-06-23T07:27:43Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -171,68 +160,83 @@ public synchronized boolean containsFunction(String tenant, String namespace, St\n         return containsFunctionMetaData(tenant, namespace, functionName);\n     }\n \n-    /**\n-     * Sends an update request to the FMT (Function Metadata Topic)\n-     * @param functionMetaData The function metadata that needs to be updated\n-     * @return a completable future of when the update has been applied\n-     */\n-    public synchronized CompletableFuture<RequestResult> updateFunction(FunctionMetaData functionMetaData) {\n-\n-        FunctionMetaData existingFunctionMetadata = null;\n-        if (containsFunction(functionMetaData.getFunctionDetails().getTenant(),\n-                functionMetaData.getFunctionDetails().getNamespace(),\n-                functionMetaData.getFunctionDetails().getName())) {\n-            existingFunctionMetadata = getFunctionMetaData(functionMetaData.getFunctionDetails().getTenant(),\n-                    functionMetaData.getFunctionDetails().getNamespace(),\n-                    functionMetaData.getFunctionDetails().getName());\n+    public synchronized void updateFunctionOnLeader(FunctionMetaData functionMetaData, boolean delete)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fc89c35e9752682a70540510447764639ed5fbe"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1NTI1Nzg2", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-435525786", "createdAt": "2020-06-23T07:48:05Z", "commit": {"oid": "8fc89c35e9752682a70540510447764639ed5fbe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwNzo0ODowNVrOGndWAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwNzo0ODowNVrOGndWAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDAyODQxOA==", "bodyText": "Why are we catching and ignoring the exceptions?  Are not the \"out of data request errors\" thrown as illegal argument exceptions? If we catch them and ignore it, how are to users going to receive the error?", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444028418", "createdAt": "2020-06-23T07:48:05Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -241,20 +245,21 @@ public synchronized boolean containsFunction(String tenant, String namespace, St\n      * @param serviceRequest The request\n      */\n     public void processRequest(MessageId messageId, Request.ServiceRequest serviceRequest) {\n-\n-        // make sure that processing requests don't happen simultaneously\n-        synchronized (this) {\n+        try {\n             switch (serviceRequest.getServiceRequestType()) {\n                 case UPDATE:\n-                    this.processUpdate(serviceRequest);\n+                    this.processUpdate(serviceRequest.getFunctionMetaData());\n                     break;\n                 case DELETE:\n-                    this.proccessDeregister(serviceRequest);\n+                    this.proccessDeregister(serviceRequest.getFunctionMetaData());\n                     break;\n                 default:\n                     log.warn(\"Received request with unrecognized type: {}\", serviceRequest);\n             }\n+        } catch (IllegalArgumentException e) {\n+            // Its ok. Nothing much we can do about it", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8fc89c35e9752682a70540510447764639ed5fbe"}, "originalPosition": 258}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f21176c62a23df0df7b327778b4ce81d3ea8dbe", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/6f21176c62a23df0df7b327778b4ce81d3ea8dbe", "committedDate": "2020-06-23T15:56:51Z", "message": "Added more comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/f381eeeca5da48123d2d034de374919a0734cbd4", "committedDate": "2020-06-23T17:31:44Z", "message": "Merge branch 'master' into functions_leader_executor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MDU3MDgy", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-436057082", "createdAt": "2020-06-23T18:41:49Z", "commit": {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODo0MTo0OVrOGn18QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODo0MTo0OVrOGn18QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzMTQyNQ==", "bodyText": "Why are we removing this?", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444431425", "createdAt": "2020-06-23T18:41:49Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -80,37 +84,40 @@ public FunctionMetaDataManager(WorkerConfig workerConfig,\n                 this.pulsarClient, this.workerConfig.getFunctionMetadataTopic());\n         this.schedulerManager = schedulerManager;\n         this.errorNotifier = errorNotifier;\n+        exclusiveLeaderProducer = null;\n     }\n \n     /**\n      * Public methods. Please use these methods if references FunctionMetaManager from an external class\n      */\n \n     /**\n-     * Initializes the FunctionMetaDataManager.  Does the following:\n-     * 1. Consume all existing function meta data upon start to establish existing state\n+     * Initializes the FunctionMetaDataManager. By default we start in the worker mode.\n+     * We consume all existing function meta data to establish existing state\n      */\n     public void initialize() {\n         try {\n+            initializeTailer();\n             this.functionMetaDataTopicTailer = new FunctionMetaDataTopicTailer(this,\n                     pulsarClient.newReader(), this.workerConfig, this.errorNotifier);\n             // read all existing messages\n-            this.setInitializePhase(true);\n             while (this.functionMetaDataTopicTailer.getReader().hasMessageAvailable()) {\n                 this.functionMetaDataTopicTailer.processRequest(this.functionMetaDataTopicTailer.getReader().readNext());\n             }\n-            this.setInitializePhase(false);\n             \n             this.isInitialized.complete(null);\n         } catch (Exception e) {\n             log.error(\"Failed to initialize meta data store\", e);\n-            throw new RuntimeException(e);\n+            errorNotifier.triggerError(e);\n         }\n     }\n-    \n+\n+    private void initializeTailer() throws PulsarClientException {\n+        this.functionMetaDataTopicTailer = new FunctionMetaDataTopicTailer(this,\n+                pulsarClient.newReader().startMessageId(lastMessageSeen), this.workerConfig, this.errorNotifier);\n+    }\n+\n     public void start() {\n-        // schedule functions if necessary\n-        this.schedulerManager.schedule();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4"}, "originalPosition": 118}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MDYyNDc1", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-436062475", "createdAt": "2020-06-23T18:49:24Z", "commit": {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODo0OToyNFrOGn2NfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODo0OToyNFrOGn2NfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzNTgzNg==", "bodyText": "Why are we getting rid of the \"isInitializePhase\" flag?  The flag is in place so we don't call schedule() for every message during the initialization phase and we wait to just call schedule at the end of the init phase", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444435836", "createdAt": "2020-06-23T18:49:24Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -52,20 +61,15 @@\n     @VisibleForTesting\n     final Map<String, Map<String, Map<String, FunctionMetaData>>> functionMetaDataMap = new ConcurrentHashMap<>();\n \n-    // A map in which the key is the service request id and value is the service request\n-    private final Map<String, ServiceRequestInfo> pendingServiceRequests = new ConcurrentHashMap<>();\n-\n     private final ServiceRequestManager serviceRequestManager;\n     private final SchedulerManager schedulerManager;\n     private final WorkerConfig workerConfig;\n     private final PulsarClient pulsarClient;\n     private final ErrorNotifier errorNotifier;\n \n     private FunctionMetaDataTopicTailer functionMetaDataTopicTailer;\n-\n-    @Setter\n-    @Getter\n-    boolean isInitializePhase = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MDY1OTYz", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-436065963", "createdAt": "2020-06-23T18:54:33Z", "commit": {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODo1NDozM1rOGn2YOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODo1NDozM1rOGn2YOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzODU4Nw==", "bodyText": "It seems more natural that the FunctionMetaDataTopicTailer keeps track of this since the FunctionMetadataManager isn't in charge of reading the topic", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444438587", "createdAt": "2020-06-23T18:54:33Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -52,20 +61,15 @@\n     @VisibleForTesting\n     final Map<String, Map<String, Map<String, FunctionMetaData>>> functionMetaDataMap = new ConcurrentHashMap<>();\n \n-    // A map in which the key is the service request id and value is the service request\n-    private final Map<String, ServiceRequestInfo> pendingServiceRequests = new ConcurrentHashMap<>();\n-\n     private final ServiceRequestManager serviceRequestManager;\n     private final SchedulerManager schedulerManager;\n     private final WorkerConfig workerConfig;\n     private final PulsarClient pulsarClient;\n     private final ErrorNotifier errorNotifier;\n \n     private FunctionMetaDataTopicTailer functionMetaDataTopicTailer;\n-\n-    @Setter\n-    @Getter\n-    boolean isInitializePhase = false;\n+    private Producer exclusiveLeaderProducer;\n+    private MessageId lastMessageSeen = MessageId.earliest;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MDY4NDM0", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-436068434", "createdAt": "2020-06-23T18:57:52Z", "commit": {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODo1Nzo1MlrOGn2fyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxODo1Nzo1MlrOGn2fyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MDUyMw==", "bodyText": "it is kind of weird that the functionMetaDataTopicTailer.processRequest() will call back to FunctionMetadataManager.  Seems like an awkward interaction between the classes.  Perhaps we can refactor in a subsequent PR.", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444440523", "createdAt": "2020-06-23T18:57:52Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -80,37 +84,40 @@ public FunctionMetaDataManager(WorkerConfig workerConfig,\n                 this.pulsarClient, this.workerConfig.getFunctionMetadataTopic());\n         this.schedulerManager = schedulerManager;\n         this.errorNotifier = errorNotifier;\n+        exclusiveLeaderProducer = null;\n     }\n \n     /**\n      * Public methods. Please use these methods if references FunctionMetaManager from an external class\n      */\n \n     /**\n-     * Initializes the FunctionMetaDataManager.  Does the following:\n-     * 1. Consume all existing function meta data upon start to establish existing state\n+     * Initializes the FunctionMetaDataManager. By default we start in the worker mode.\n+     * We consume all existing function meta data to establish existing state\n      */\n     public void initialize() {\n         try {\n+            initializeTailer();\n             this.functionMetaDataTopicTailer = new FunctionMetaDataTopicTailer(this,\n                     pulsarClient.newReader(), this.workerConfig, this.errorNotifier);\n             // read all existing messages\n-            this.setInitializePhase(true);\n             while (this.functionMetaDataTopicTailer.getReader().hasMessageAvailable()) {\n                 this.functionMetaDataTopicTailer.processRequest(this.functionMetaDataTopicTailer.getReader().readNext());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4"}, "originalPosition": 98}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MTAwNTUx", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-436100551", "createdAt": "2020-06-23T19:44:49Z", "commit": {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxOTo0NDo0OVrOGn4AOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxOTo0NDo0OVrOGn4AOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ2NTIwOA==", "bodyText": "Shouldn't we also start the the tailer here?", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444465208", "createdAt": "2020-06-23T19:44:49Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -174,89 +181,124 @@ public synchronized boolean containsFunction(String tenant, String namespace, St\n     }\n \n     /**\n-     * Sends an update request to the FMT (Function Metadata Topic)\n-     * @param functionMetaData The function metadata that needs to be updated\n-     * @return a completable future of when the update has been applied\n+     * Called by the worker when we are in the leader mode.  In this state, we update our in-memory\n+     * data structures and then write to the metadata topic.\n+     * @param functionMetaData The function metadata in question\n+     * @param delete Is this a delete operation\n+     * @throws IllegalStateException if we are not the leader\n+     * @throws IllegalArgumentException if the request is out of date.\n      */\n-    public synchronized CompletableFuture<RequestResult> updateFunction(FunctionMetaData functionMetaData) {\n-\n-        FunctionMetaData existingFunctionMetadata = null;\n-        if (containsFunction(functionMetaData.getFunctionDetails().getTenant(),\n-                functionMetaData.getFunctionDetails().getNamespace(),\n-                functionMetaData.getFunctionDetails().getName())) {\n-            existingFunctionMetadata = getFunctionMetaData(functionMetaData.getFunctionDetails().getTenant(),\n-                    functionMetaData.getFunctionDetails().getNamespace(),\n-                    functionMetaData.getFunctionDetails().getName());\n+    public synchronized void updateFunctionOnLeader(FunctionMetaData functionMetaData, boolean delete)\n+            throws IllegalStateException, IllegalArgumentException {\n+        if (exclusiveLeaderProducer == null) {\n+            throw new IllegalStateException(\"Not the leader\");\n+        }\n+        boolean needsScheduling;\n+        if (delete) {\n+            needsScheduling = proccessDeregister(functionMetaData);\n+        } else {\n+            needsScheduling = processUpdate(functionMetaData);\n+        }\n+        Request.ServiceRequest serviceRequest = Request.ServiceRequest.newBuilder()\n+                .setServiceRequestType(delete ? Request.ServiceRequest.ServiceRequestType.DELETE : Request.ServiceRequest.ServiceRequestType.UPDATE)\n+                .setFunctionMetaData(functionMetaData)\n+                .setWorkerId(workerConfig.getWorkerId())\n+                .setRequestId(UUID.randomUUID().toString())\n+                .build();\n+        try {\n+            lastMessageSeen = exclusiveLeaderProducer.send(serviceRequest.toByteArray());\n+        } catch (Exception e) {\n+            log.error(\"Could not write into Function Metadata topic\", e);\n+            errorNotifier.triggerError(e);\n+        }\n+        if (needsScheduling) {\n+            this.schedulerManager.schedule();\n         }\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(existingFunctionMetadata, functionMetaData);\n-\n-        Request.ServiceRequest updateRequest = ServiceRequestUtils.getUpdateRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n-\n-        return submit(updateRequest);\n     }\n \n-\n     /**\n-     * Sends a deregister request to the FMT (Function Metadata Topic) for a function\n-     * @param tenant the tenant the function that needs to be deregistered belongs to\n-     * @param namespace the namespace the function that needs to be deregistered belongs to\n-     * @param functionName the name of the function\n-     * @return a completable future of when the deregister has been applied\n+     * Called by the leader service when this worker becomes the leader.\n+     * We first get exclusive producer on the metadata topic. Next we drain the tailer\n+     * to ensure that we have caught up to metadata topic. After which we close the tailer.\n+     * Note that this method cannot be syncrhonized because the tailer might still be processing messages\n      */\n-    public synchronized CompletableFuture<RequestResult> deregisterFunction(String tenant, String namespace, String functionName) {\n-        FunctionMetaData functionMetaData = this.functionMetaDataMap.get(tenant).get(namespace).get(functionName);\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(functionMetaData, functionMetaData);\n-\n-        Request.ServiceRequest deregisterRequest = ServiceRequestUtils.getDeregisterRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n+    public void acquireLeadership() {\n+        log.info(\"FunctionMetaDataManager becoming leader by creating exclusive producer\");\n+        FunctionMetaDataTopicTailer tailer = internalAcquireLeadership();\n+        // Now that we have created the exclusive producer, wait for reader to get over\n+        if (tailer != null) {\n+            try {\n+                tailer.stopWhenNoMoreMessages().get();\n+            } catch (Exception e) {\n+                log.error(\"Error while waiting for metadata tailer thread to finish\", e);\n+                errorNotifier.triggerError(e);\n+            }\n+            tailer.close();\n+        }\n+        this.schedulerManager.schedule();\n+        log.info(\"FunctionMetaDataManager done becoming leader by doing its first schedule\");\n+    }\n \n-        return submit(deregisterRequest);\n+    private synchronized FunctionMetaDataTopicTailer internalAcquireLeadership() {\n+        if (exclusiveLeaderProducer == null) {\n+            try {\n+                exclusiveLeaderProducer = pulsarClient.newProducer()\n+                        .topic(this.workerConfig.getFunctionMetadataTopic())\n+                        .producerName(workerConfig.getWorkerId() + \"-leader\")\n+                        // .type(EXCLUSIVE)\n+                        .create();\n+            } catch (PulsarClientException e) {\n+                log.error(\"Error creating exclusive producer\", e);\n+                errorNotifier.triggerError(e);\n+            }\n+        } else {\n+            log.error(\"Logic Error in FunctionMetaData Manager\");\n+            errorNotifier.triggerError(new IllegalStateException());\n+        }\n+        FunctionMetaDataTopicTailer tailer = this.functionMetaDataTopicTailer;\n+        this.functionMetaDataTopicTailer = null;\n+        return tailer;\n     }\n \n     /**\n-     * Sends a start/stop function request to the FMT (Function Metadata Topic) for a function\n-     * @param tenant the tenant the function that needs to be deregistered belongs to\n-     * @param namespace the namespace the function that needs to be deregistered belongs to\n-     * @param functionName the name of the function\n-     * @param instanceId the instanceId of the function, -1 if for all instances\n-     * @param start do we need to start or stop\n-     * @return a completable future of when the start/stop has been applied\n+     * called by the leader service when we lose leadership. We close the exclusive producer\n+     * and start the tailer.\n      */\n-    public synchronized CompletableFuture<RequestResult> changeFunctionInstanceStatus(String tenant, String namespace, String functionName,\n-                                                                                      Integer instanceId, boolean start) {\n-        FunctionMetaData functionMetaData = this.functionMetaDataMap.get(tenant).get(namespace).get(functionName);\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.changeFunctionInstanceStatus(functionMetaData, instanceId, start);\n-\n-        Request.ServiceRequest updateRequest = ServiceRequestUtils.getUpdateRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n-\n-        return submit(updateRequest);\n+    public synchronized void giveupLeadership() {\n+        log.info(\"FunctionMetaDataManager giving up leadership by closing exclusive producer\");\n+        try {\n+            exclusiveLeaderProducer.close();\n+            exclusiveLeaderProducer = null;\n+            initializeTailer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4"}, "originalPosition": 264}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MTA3NjI4", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-436107628", "createdAt": "2020-06-23T19:55:08Z", "commit": {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxOTo1NTowOFrOGn4VPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxOTo1NTowOFrOGn4VPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ3MDU5MQ==", "bodyText": "To check if we have really reached the end of the topic, I think its safer if we check reader.hasMessageAvailable() == false and reader.readNext(5, TimeUnit.SECONDS) returns null.", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444470591", "createdAt": "2020-06-23T19:55:08Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataTopicTailer.java", "diffHunk": "@@ -54,19 +58,33 @@ public FunctionMetaDataTopicTailer(FunctionMetaDataManager functionMetaDataManag\n         readerThread = new Thread(this);\n         readerThread.setName(\"function-metadata-tailer-thread\");\n         this.errorNotifier = errorNotifier;\n+        stopOnNoMessageAvailable = false;\n     }\n \n     public void start() {\n         running = true;\n+        exitFuture = new CompletableFuture<>();\n         readerThread.start();\n     }\n \n     @Override\n     public void run() {\n-        while(running) {\n+        while (running) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MTIwMTY5", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-436120169", "createdAt": "2020-06-23T20:13:35Z", "commit": {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDoxMzozNlrOGn455Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDoxMzozNlrOGn455Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ3OTk3Mw==", "bodyText": "Shouldn't we return a 500 error to the end user?  If we call just \"errorNotifier.triggerError(e)\", the worker die and the end user will likely not get a response or a timeout error", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444479973", "createdAt": "2020-06-23T20:13:36Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -174,89 +181,124 @@ public synchronized boolean containsFunction(String tenant, String namespace, St\n     }\n \n     /**\n-     * Sends an update request to the FMT (Function Metadata Topic)\n-     * @param functionMetaData The function metadata that needs to be updated\n-     * @return a completable future of when the update has been applied\n+     * Called by the worker when we are in the leader mode.  In this state, we update our in-memory\n+     * data structures and then write to the metadata topic.\n+     * @param functionMetaData The function metadata in question\n+     * @param delete Is this a delete operation\n+     * @throws IllegalStateException if we are not the leader\n+     * @throws IllegalArgumentException if the request is out of date.\n      */\n-    public synchronized CompletableFuture<RequestResult> updateFunction(FunctionMetaData functionMetaData) {\n-\n-        FunctionMetaData existingFunctionMetadata = null;\n-        if (containsFunction(functionMetaData.getFunctionDetails().getTenant(),\n-                functionMetaData.getFunctionDetails().getNamespace(),\n-                functionMetaData.getFunctionDetails().getName())) {\n-            existingFunctionMetadata = getFunctionMetaData(functionMetaData.getFunctionDetails().getTenant(),\n-                    functionMetaData.getFunctionDetails().getNamespace(),\n-                    functionMetaData.getFunctionDetails().getName());\n+    public synchronized void updateFunctionOnLeader(FunctionMetaData functionMetaData, boolean delete)\n+            throws IllegalStateException, IllegalArgumentException {\n+        if (exclusiveLeaderProducer == null) {\n+            throw new IllegalStateException(\"Not the leader\");\n+        }\n+        boolean needsScheduling;\n+        if (delete) {\n+            needsScheduling = proccessDeregister(functionMetaData);\n+        } else {\n+            needsScheduling = processUpdate(functionMetaData);\n+        }\n+        Request.ServiceRequest serviceRequest = Request.ServiceRequest.newBuilder()\n+                .setServiceRequestType(delete ? Request.ServiceRequest.ServiceRequestType.DELETE : Request.ServiceRequest.ServiceRequestType.UPDATE)\n+                .setFunctionMetaData(functionMetaData)\n+                .setWorkerId(workerConfig.getWorkerId())\n+                .setRequestId(UUID.randomUUID().toString())\n+                .build();\n+        try {\n+            lastMessageSeen = exclusiveLeaderProducer.send(serviceRequest.toByteArray());\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4"}, "originalPosition": 164}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MTIyMDYw", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-436122060", "createdAt": "2020-06-23T20:16:32Z", "commit": {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDoxNjozMlrOGn4_kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDoxNjozMlrOGn4_kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ4MTQyNA==", "bodyText": "why do we need to synchronize this method?", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444481424", "createdAt": "2020-06-23T20:16:32Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -174,89 +181,124 @@ public synchronized boolean containsFunction(String tenant, String namespace, St\n     }\n \n     /**\n-     * Sends an update request to the FMT (Function Metadata Topic)\n-     * @param functionMetaData The function metadata that needs to be updated\n-     * @return a completable future of when the update has been applied\n+     * Called by the worker when we are in the leader mode.  In this state, we update our in-memory\n+     * data structures and then write to the metadata topic.\n+     * @param functionMetaData The function metadata in question\n+     * @param delete Is this a delete operation\n+     * @throws IllegalStateException if we are not the leader\n+     * @throws IllegalArgumentException if the request is out of date.\n      */\n-    public synchronized CompletableFuture<RequestResult> updateFunction(FunctionMetaData functionMetaData) {\n-\n-        FunctionMetaData existingFunctionMetadata = null;\n-        if (containsFunction(functionMetaData.getFunctionDetails().getTenant(),\n-                functionMetaData.getFunctionDetails().getNamespace(),\n-                functionMetaData.getFunctionDetails().getName())) {\n-            existingFunctionMetadata = getFunctionMetaData(functionMetaData.getFunctionDetails().getTenant(),\n-                    functionMetaData.getFunctionDetails().getNamespace(),\n-                    functionMetaData.getFunctionDetails().getName());\n+    public synchronized void updateFunctionOnLeader(FunctionMetaData functionMetaData, boolean delete)\n+            throws IllegalStateException, IllegalArgumentException {\n+        if (exclusiveLeaderProducer == null) {\n+            throw new IllegalStateException(\"Not the leader\");\n+        }\n+        boolean needsScheduling;\n+        if (delete) {\n+            needsScheduling = proccessDeregister(functionMetaData);\n+        } else {\n+            needsScheduling = processUpdate(functionMetaData);\n+        }\n+        Request.ServiceRequest serviceRequest = Request.ServiceRequest.newBuilder()\n+                .setServiceRequestType(delete ? Request.ServiceRequest.ServiceRequestType.DELETE : Request.ServiceRequest.ServiceRequestType.UPDATE)\n+                .setFunctionMetaData(functionMetaData)\n+                .setWorkerId(workerConfig.getWorkerId())\n+                .setRequestId(UUID.randomUUID().toString())\n+                .build();\n+        try {\n+            lastMessageSeen = exclusiveLeaderProducer.send(serviceRequest.toByteArray());\n+        } catch (Exception e) {\n+            log.error(\"Could not write into Function Metadata topic\", e);\n+            errorNotifier.triggerError(e);\n+        }\n+        if (needsScheduling) {\n+            this.schedulerManager.schedule();\n         }\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(existingFunctionMetadata, functionMetaData);\n-\n-        Request.ServiceRequest updateRequest = ServiceRequestUtils.getUpdateRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n-\n-        return submit(updateRequest);\n     }\n \n-\n     /**\n-     * Sends a deregister request to the FMT (Function Metadata Topic) for a function\n-     * @param tenant the tenant the function that needs to be deregistered belongs to\n-     * @param namespace the namespace the function that needs to be deregistered belongs to\n-     * @param functionName the name of the function\n-     * @return a completable future of when the deregister has been applied\n+     * Called by the leader service when this worker becomes the leader.\n+     * We first get exclusive producer on the metadata topic. Next we drain the tailer\n+     * to ensure that we have caught up to metadata topic. After which we close the tailer.\n+     * Note that this method cannot be syncrhonized because the tailer might still be processing messages\n      */\n-    public synchronized CompletableFuture<RequestResult> deregisterFunction(String tenant, String namespace, String functionName) {\n-        FunctionMetaData functionMetaData = this.functionMetaDataMap.get(tenant).get(namespace).get(functionName);\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(functionMetaData, functionMetaData);\n-\n-        Request.ServiceRequest deregisterRequest = ServiceRequestUtils.getDeregisterRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n+    public void acquireLeadership() {\n+        log.info(\"FunctionMetaDataManager becoming leader by creating exclusive producer\");\n+        FunctionMetaDataTopicTailer tailer = internalAcquireLeadership();\n+        // Now that we have created the exclusive producer, wait for reader to get over\n+        if (tailer != null) {\n+            try {\n+                tailer.stopWhenNoMoreMessages().get();\n+            } catch (Exception e) {\n+                log.error(\"Error while waiting for metadata tailer thread to finish\", e);\n+                errorNotifier.triggerError(e);\n+            }\n+            tailer.close();\n+        }\n+        this.schedulerManager.schedule();\n+        log.info(\"FunctionMetaDataManager done becoming leader by doing its first schedule\");\n+    }\n \n-        return submit(deregisterRequest);\n+    private synchronized FunctionMetaDataTopicTailer internalAcquireLeadership() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4"}, "originalPosition": 217}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MTI0OTE0", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-436124914", "createdAt": "2020-06-23T20:20:51Z", "commit": {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDoyMDo1MVrOGn5IYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDoyMDo1MVrOGn5IYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ4MzY4Mw==", "bodyText": "It is kind of confusing to be calling \"processFunctionUpdate\" in de-register routine since we also have a update function routine. Maybe rename the method to something else?  \"processFunctionRequest\"?", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444483683", "createdAt": "2020-06-23T20:20:51Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/rest/api/ComponentImpl.java", "diffHunk": "@@ -392,24 +392,13 @@ public void deregisterFunction(final String tenant,\n             throw new RestException(Status.NOT_FOUND, String.format(\"%s %s doesn't exist\", ComponentTypeUtils.toString(componentType), componentName));\n         }\n \n-        CompletableFuture<RequestResult> completableFuture = functionMetaDataManager.deregisterFunction(tenant,\n-                namespace, componentName);\n-\n-        RequestResult requestResult = null;\n-        try {\n-            requestResult = completableFuture.get();\n-            if (!requestResult.isSuccess()) {\n-                throw new RestException(Status.BAD_REQUEST, requestResult.getMessage());\n-            }\n-        } catch (ExecutionException e) {\n-            log.error(\"Execution Exception while deregistering {} @ /{}/{}/{}\",\n-                    ComponentTypeUtils.toString(componentType), tenant, namespace, componentName, e);\n-            throw new RestException(Status.INTERNAL_SERVER_ERROR, e.getCause().getMessage());\n-        } catch (InterruptedException e) {\n-            log.error(\"Interrupted Exception while deregistering {} @ /{}/{}/{}\",\n-                    ComponentTypeUtils.toString(componentType), tenant, namespace, componentName, e);\n-            throw new RestException(Status.REQUEST_TIMEOUT, e.getMessage());\n-        }\n+        FunctionMetaData newVersionedMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(functionMetaData, functionMetaData);\n+        processFunctionUpdate(newVersionedMetaData.getFunctionDetails().getTenant(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f381eeeca5da48123d2d034de374919a0734cbd4"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43eaf86d1a503ee7aa7eead8772b878dc4652379", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/43eaf86d1a503ee7aa7eead8772b878dc4652379", "committedDate": "2020-06-23T20:46:07Z", "message": "Throw error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c28e1224402c8a51a2eca0e93602b0f753ff2b03", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/c28e1224402c8a51a2eca0e93602b0f753ff2b03", "committedDate": "2020-06-23T20:47:29Z", "message": "Changed name"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MjEzNDY3", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-436213467", "createdAt": "2020-06-23T22:52:47Z", "commit": {"oid": "c28e1224402c8a51a2eca0e93602b0f753ff2b03"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMjo1Mjo0N1rOGn9Q2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMjo1Mjo0N1rOGn9Q2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1MTM4NA==", "bodyText": "Can we rename \" FunctionMetaDataUtils.generateUpdatedMetadata\" to something like  \"FunctionMetaDataUtils.incrMetadataVersion\"", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r444551384", "createdAt": "2020-06-23T22:52:47Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/rest/api/ComponentImpl.java", "diffHunk": "@@ -392,24 +391,13 @@ public void deregisterFunction(final String tenant,\n             throw new RestException(Status.NOT_FOUND, String.format(\"%s %s doesn't exist\", ComponentTypeUtils.toString(componentType), componentName));\n         }\n \n-        CompletableFuture<RequestResult> completableFuture = functionMetaDataManager.deregisterFunction(tenant,\n-                namespace, componentName);\n-\n-        RequestResult requestResult = null;\n-        try {\n-            requestResult = completableFuture.get();\n-            if (!requestResult.isSuccess()) {\n-                throw new RestException(Status.BAD_REQUEST, requestResult.getMessage());\n-            }\n-        } catch (ExecutionException e) {\n-            log.error(\"Execution Exception while deregistering {} @ /{}/{}/{}\",\n-                    ComponentTypeUtils.toString(componentType), tenant, namespace, componentName, e);\n-            throw new RestException(Status.INTERNAL_SERVER_ERROR, e.getCause().getMessage());\n-        } catch (InterruptedException e) {\n-            log.error(\"Interrupted Exception while deregistering {} @ /{}/{}/{}\",\n-                    ComponentTypeUtils.toString(componentType), tenant, namespace, componentName, e);\n-            throw new RestException(Status.REQUEST_TIMEOUT, e.getMessage());\n-        }\n+        FunctionMetaData newVersionedMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(functionMetaData, functionMetaData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c28e1224402c8a51a2eca0e93602b0f753ff2b03"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb86d0a49fa92eff08726a399db825e4783fc3b9", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/fb86d0a49fa92eff08726a399db825e4783fc3b9", "committedDate": "2020-06-23T22:58:06Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a61e6748bda039235b1d95b34367468d7a4135aa", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/a61e6748bda039235b1d95b34367468d7a4135aa", "committedDate": "2020-06-24T05:49:11Z", "message": "Deleted unused classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7196264acd6f6e6995726b9a0a4aa11abe26678", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/d7196264acd6f6e6995726b9a0a4aa11abe26678", "committedDate": "2020-06-24T18:33:23Z", "message": "Rework metadata manager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b824e9e881c90902787290475416a6b9076f54b", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/3b824e9e881c90902787290475416a6b9076f54b", "committedDate": "2020-06-24T21:24:53Z", "message": "Working"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5328d14af689f3763344f5c7642ec1957cbc6ea", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/c5328d14af689f3763344f5c7642ec1957cbc6ea", "committedDate": "2020-06-24T22:07:06Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abed1f756f6abb92b718a1ce7aea733d14413272", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/abed1f756f6abb92b718a1ce7aea733d14413272", "committedDate": "2020-06-24T22:50:04Z", "message": "A better way for test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MTExNjM4", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-437111638", "createdAt": "2020-06-25T01:30:50Z", "commit": {"oid": "abed1f756f6abb92b718a1ce7aea733d14413272"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwMTozMDo1MFrOGoodng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwMTozMDo1MFrOGoodng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI1OTE2Ng==", "bodyText": "couldn't there be a race condition between here and \"start()\" where you are relying on whether exclusiveLeaderProducer is null or not.  \"acquireLeadership()\" is called by the \"becomeActive\" which is using the client listener thread while \"start()\" is executed by the worker \"main\" thread", "url": "https://github.com/apache/pulsar/pull/7255#discussion_r445259166", "createdAt": "2020-06-25T01:30:50Z", "author": {"login": "jerrypeng"}, "path": "pulsar-functions/worker/src/main/java/org/apache/pulsar/functions/worker/FunctionMetaDataManager.java", "diffHunk": "@@ -174,89 +188,127 @@ public synchronized boolean containsFunction(String tenant, String namespace, St\n     }\n \n     /**\n-     * Sends an update request to the FMT (Function Metadata Topic)\n-     * @param functionMetaData The function metadata that needs to be updated\n-     * @return a completable future of when the update has been applied\n+     * Called by the worker when we are in the leader mode.  In this state, we update our in-memory\n+     * data structures and then write to the metadata topic.\n+     * @param functionMetaData The function metadata in question\n+     * @param delete Is this a delete operation\n+     * @throws IllegalStateException if we are not the leader\n+     * @throws IllegalArgumentException if the request is out of date.\n      */\n-    public synchronized CompletableFuture<RequestResult> updateFunction(FunctionMetaData functionMetaData) {\n-\n-        FunctionMetaData existingFunctionMetadata = null;\n-        if (containsFunction(functionMetaData.getFunctionDetails().getTenant(),\n-                functionMetaData.getFunctionDetails().getNamespace(),\n-                functionMetaData.getFunctionDetails().getName())) {\n-            existingFunctionMetadata = getFunctionMetaData(functionMetaData.getFunctionDetails().getTenant(),\n-                    functionMetaData.getFunctionDetails().getNamespace(),\n-                    functionMetaData.getFunctionDetails().getName());\n+    public synchronized void updateFunctionOnLeader(FunctionMetaData functionMetaData, boolean delete)\n+            throws IllegalStateException, IllegalArgumentException {\n+        if (exclusiveLeaderProducer == null) {\n+            throw new IllegalStateException(\"Not the leader\");\n+        }\n+        boolean needsScheduling;\n+        if (delete) {\n+            needsScheduling = proccessDeregister(functionMetaData);\n+        } else {\n+            needsScheduling = processUpdate(functionMetaData);\n+        }\n+        Request.ServiceRequest serviceRequest = Request.ServiceRequest.newBuilder()\n+                .setServiceRequestType(delete ? Request.ServiceRequest.ServiceRequestType.DELETE : Request.ServiceRequest.ServiceRequestType.UPDATE)\n+                .setFunctionMetaData(functionMetaData)\n+                .setWorkerId(workerConfig.getWorkerId())\n+                .setRequestId(UUID.randomUUID().toString())\n+                .build();\n+        try {\n+            lastMessageSeen = exclusiveLeaderProducer.send(serviceRequest.toByteArray());\n+        } catch (Exception e) {\n+            log.error(\"Could not write into Function Metadata topic\", e);\n+            errorNotifier.triggerError(e);\n+            throw new IllegalStateException(\"Internal Error updating function at the leader\", e);\n+        }\n+        if (needsScheduling) {\n+            this.schedulerManager.schedule();\n         }\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(existingFunctionMetadata, functionMetaData);\n-\n-        Request.ServiceRequest updateRequest = ServiceRequestUtils.getUpdateRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n-\n-        return submit(updateRequest);\n     }\n \n-\n     /**\n-     * Sends a deregister request to the FMT (Function Metadata Topic) for a function\n-     * @param tenant the tenant the function that needs to be deregistered belongs to\n-     * @param namespace the namespace the function that needs to be deregistered belongs to\n-     * @param functionName the name of the function\n-     * @return a completable future of when the deregister has been applied\n+     * Called by the leader service when this worker becomes the leader.\n+     * We first get exclusive producer on the metadata topic. Next we drain the tailer\n+     * to ensure that we have caught up to metadata topic. After which we close the tailer.\n+     * Note that this method cannot be syncrhonized because the tailer might still be processing messages\n      */\n-    public synchronized CompletableFuture<RequestResult> deregisterFunction(String tenant, String namespace, String functionName) {\n-        FunctionMetaData functionMetaData = this.functionMetaDataMap.get(tenant).get(namespace).get(functionName);\n-\n-        FunctionMetaData newFunctionMetaData = FunctionMetaDataUtils.generateUpdatedMetadata(functionMetaData, functionMetaData);\n-\n-        Request.ServiceRequest deregisterRequest = ServiceRequestUtils.getDeregisterRequest(\n-                this.workerConfig.getWorkerId(), newFunctionMetaData);\n+    public void acquireLeadership() {\n+        log.info(\"FunctionMetaDataManager becoming leader by creating exclusive producer\");\n+        FunctionMetaDataTopicTailer tailer = internalAcquireLeadership();\n+        // Now that we have created the exclusive producer, wait for reader to get over\n+        if (tailer != null) {\n+            try {\n+                tailer.stopWhenNoMoreMessages().get();\n+            } catch (Exception e) {\n+                log.error(\"Error while waiting for metadata tailer thread to finish\", e);\n+                errorNotifier.triggerError(e);\n+            }\n+            tailer.close();\n+        }\n+        log.info(\"FunctionMetaDataManager done becoming leader\");\n+    }\n \n-        return submit(deregisterRequest);\n+    private synchronized FunctionMetaDataTopicTailer internalAcquireLeadership() {\n+        if (exclusiveLeaderProducer == null) {\n+            try {\n+                exclusiveLeaderProducer = pulsarClient.newProducer()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abed1f756f6abb92b718a1ce7aea733d14413272"}, "originalPosition": 252}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NzA2NzM1", "url": "https://github.com/apache/pulsar/pull/7255#pullrequestreview-437706735", "createdAt": "2020-06-25T17:26:16Z", "commit": {"oid": "abed1f756f6abb92b718a1ce7aea733d14413272"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7bb5bc0222903b30aeeb7c01afadf6a390925bab", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/7bb5bc0222903b30aeeb7c01afadf6a390925bab", "committedDate": "2020-06-25T17:45:06Z", "message": "Address feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97094788e52baabacea2110228adf54bf6e9ce2d", "author": {"user": null}, "url": "https://github.com/apache/pulsar/commit/97094788e52baabacea2110228adf54bf6e9ce2d", "committedDate": "2020-06-25T21:53:46Z", "message": "Merge branch 'master' into functions_leader_executor"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 682, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}