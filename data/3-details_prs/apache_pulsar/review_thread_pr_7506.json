{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ3NjEyNDE1", "number": 7506, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDo0NjoxNFrOENaQ-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDo0NjoxNFrOENaQ-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyNDk3MjcyOnYy", "diffSide": "RIGHT", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedLedgerFactoryImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMDo0NjoxNFrOGwFJ8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMFQyMjozNToyM1rOGwHcgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA2OTI5Nw==", "bodyText": "As opposed to requiring another call to check if the timeout has elapsed, would it make sense to instead use a CompletableFuture with a timeout? Much like we do in the BrokerService, the future created on line 370 could instead be made to have a timeout if it isn't resolved in so many milliseconds with the error handler remove the future from the cache of futures.", "url": "https://github.com/apache/pulsar/pull/7506#discussion_r453069297", "createdAt": "2020-07-10T20:46:14Z", "author": {"login": "addisonj"}, "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedLedgerFactoryImpl.java", "diffHunk": "@@ -320,18 +335,32 @@ public void asyncOpen(final String name, final ManagedLedgerConfig config, final\n \n         // If the ledger state is bad, remove it from the map.\n         CompletableFuture<ManagedLedgerImpl> existingFuture = ledgers.get(name);\n-        if (existingFuture != null && existingFuture.isDone()) {\n-            try {\n-                ManagedLedgerImpl l = existingFuture.get();\n-                if (l.getState().equals(State.Fenced.toString()) || l.getState().equals(State.Closed.toString())) {\n-                    // Managed ledger is in unusable state. Recreate it.\n-                    log.warn(\"[{}] Attempted to open ledger in {} state. Removing from the map to recreate it\", name,\n+        if (existingFuture != null) {\n+            if (existingFuture.isDone()) {\n+                try {\n+                    ManagedLedgerImpl l = existingFuture.get();\n+                    if (l.getState().equals(State.Fenced.toString()) || l.getState().equals(State.Closed.toString())) {\n+                        // Managed ledger is in unusable state. Recreate it.\n+                        log.warn(\"[{}] Attempted to open ledger in {} state. Removing from the map to recreate it\", name,\n                             l.getState());\n-                    ledgers.remove(name, existingFuture);\n+                        ledgers.remove(name, existingFuture);\n+                    }\n+                } catch (Exception e) {\n+                    // Unable to get the future\n+                    log.warn(\"[{}] Got exception while trying to retrieve ledger\", name, e);\n                 }\n-            } catch (Exception e) {\n-                // Unable to get the future\n-                log.warn(\"[{}] Got exception while trying to retrieve ledger\", name, e);\n+            } else {\n+                PendingInitializeManagedLedger pendingLedger = pendingInitializeLedgers.get(name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "298bee79b3ff92037ae69977ca764ab7b2576c4d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEwNjgxNg==", "bodyText": "We can do that. However, I didn't go down that route because of the following reason:\nwe need to keep the ManageLedger reference and to close it to release resources. Because the initialization involves a long pipeline including opening managed ledger and cursors. The behavior we observed is that the operation is stuck at opening cursors. So if we don't attempt to close the ManagedLedger instance, it can result in resource leaking.\nWith that being said, we need to keep a reference to ManagedLedgerImpl along with the CompletableFuture. Hence I chose the current implementation.\nAnother reason is to allow checking the timestamp proactively. I fixed a couple of issues before that NPE is thrown between creating a Future and registering error handling logic. I would like to have a mechanism in place that can fix any potential bugs by proactively checking if a CompletableFuture timed out.", "url": "https://github.com/apache/pulsar/pull/7506#discussion_r453106816", "createdAt": "2020-07-10T22:35:23Z", "author": {"login": "sijie"}, "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedLedgerFactoryImpl.java", "diffHunk": "@@ -320,18 +335,32 @@ public void asyncOpen(final String name, final ManagedLedgerConfig config, final\n \n         // If the ledger state is bad, remove it from the map.\n         CompletableFuture<ManagedLedgerImpl> existingFuture = ledgers.get(name);\n-        if (existingFuture != null && existingFuture.isDone()) {\n-            try {\n-                ManagedLedgerImpl l = existingFuture.get();\n-                if (l.getState().equals(State.Fenced.toString()) || l.getState().equals(State.Closed.toString())) {\n-                    // Managed ledger is in unusable state. Recreate it.\n-                    log.warn(\"[{}] Attempted to open ledger in {} state. Removing from the map to recreate it\", name,\n+        if (existingFuture != null) {\n+            if (existingFuture.isDone()) {\n+                try {\n+                    ManagedLedgerImpl l = existingFuture.get();\n+                    if (l.getState().equals(State.Fenced.toString()) || l.getState().equals(State.Closed.toString())) {\n+                        // Managed ledger is in unusable state. Recreate it.\n+                        log.warn(\"[{}] Attempted to open ledger in {} state. Removing from the map to recreate it\", name,\n                             l.getState());\n-                    ledgers.remove(name, existingFuture);\n+                        ledgers.remove(name, existingFuture);\n+                    }\n+                } catch (Exception e) {\n+                    // Unable to get the future\n+                    log.warn(\"[{}] Got exception while trying to retrieve ledger\", name, e);\n                 }\n-            } catch (Exception e) {\n-                // Unable to get the future\n-                log.warn(\"[{}] Got exception while trying to retrieve ledger\", name, e);\n+            } else {\n+                PendingInitializeManagedLedger pendingLedger = pendingInitializeLedgers.get(name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA2OTI5Nw=="}, "originalCommit": {"oid": "298bee79b3ff92037ae69977ca764ab7b2576c4d"}, "originalPosition": 65}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2447, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}