{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0MTk5NzYw", "number": 923, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo1NDo0MlrODY4Ozg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo1NDo0MlrODY4Ozg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NDEzNzEwOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxNjo1NDo0MlrOFe_L6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QxODozNjo1M1rOFnGYSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNjg0MQ==", "bodyText": "We call this method when we receive ProtocolPayloadEndEvent.OUTBOUND which is different than channel outbound closed. I am not convinced this is the correct nomenclature here.\nFrom the perspective of a write, outbound closure is the only interesting event and we intentionally wanted to remove the older approach of handling outbound closure and channel closure differently. Although this renaming does not alter behavior but it has the potential of adding confusion that outbound closure and full channel closure should be handled differently.", "url": "https://github.com/apple/servicetalk/pull/923#discussion_r368036841", "createdAt": "2020-01-17T16:54:42Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -459,37 +464,34 @@ public FlushStrategy defaultFlushStrategy() {\n         void channelWritable();\n \n         /**\n-         * Close the channel after the pending writes complete.\n-         *\n+         * Notification that the channel's outbound side has been closed and will no longer accept writes.s\n          * <p>\n-         * Calling {@link #close(Throwable)} after {@link #closeGracefully()} will be ignored.\n-         * <p>\n-         * This event is expected be called from the eventloop.\n+         * Always called from the event loop thread.\n          */\n-        void closeGracefully();\n+        void channelOutboundClosed();\n \n         /**\n          * Notification that the channel has been closed.\n          * <p>\n-         * This may not always be called from the event loop. For example if the channel is closed when a new write\n-         * happens then this method will be called from the writer thread.\n+         * This may not always be called from the event loop thread. For example if the channel is closed when a new\n+         * write happens then this method will be called from the writer thread.\n          *\n          * @param closedException the exception which describes the close rational.\n          */\n-        void close(Throwable closedException);\n+        void channelClosed(Throwable closedException);\n     }\n \n-    private static final class NoopWritableListener implements WritableListener {\n+    private static final class NoopChannelOutboundListener implements ChannelOutboundListener {\n         @Override\n         public void channelWritable() {\n         }\n \n         @Override\n-        public void closeGracefully() {\n+        public void channelOutboundClosed() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1638ff22a7f630a8b958e1db5119fea700ef72e4"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA5NDQ1NA==", "bodyText": "(I meant to link the related discussion #919 (comment) here)\nIMHO the interface naming (prior to this PR) has confusing semantics. From a functional perspective this interface provides methods that are called when certain channel/protocol events occur (e.g. writability change, channel close, protocol write close, etc...). However the method names are targeted toward how the implementations are assumed to react. The closeGracefully creates confusion IMHO because it isn't clear how implementations are expected to change their internal state related to any writes/events (which maybe concurrent) that may occur (e.g. found myself asking these types of questions looking at WSS in isolation).\nI see how channelOutboundClosed maybe ambiguous between \"transport closure\" and \"protocol not accepting any more writes\" and happy to consider renaming, but I think it makes more sense to target the event name (rather than the assumed action this event results in). What about channelProtocolOutboundClosed or protocolOutboundClosed ?", "url": "https://github.com/apple/servicetalk/pull/923#discussion_r368094454", "createdAt": "2020-01-17T19:16:33Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -459,37 +464,34 @@ public FlushStrategy defaultFlushStrategy() {\n         void channelWritable();\n \n         /**\n-         * Close the channel after the pending writes complete.\n-         *\n+         * Notification that the channel's outbound side has been closed and will no longer accept writes.s\n          * <p>\n-         * Calling {@link #close(Throwable)} after {@link #closeGracefully()} will be ignored.\n-         * <p>\n-         * This event is expected be called from the eventloop.\n+         * Always called from the event loop thread.\n          */\n-        void closeGracefully();\n+        void channelOutboundClosed();\n \n         /**\n          * Notification that the channel has been closed.\n          * <p>\n-         * This may not always be called from the event loop. For example if the channel is closed when a new write\n-         * happens then this method will be called from the writer thread.\n+         * This may not always be called from the event loop thread. For example if the channel is closed when a new\n+         * write happens then this method will be called from the writer thread.\n          *\n          * @param closedException the exception which describes the close rational.\n          */\n-        void close(Throwable closedException);\n+        void channelClosed(Throwable closedException);\n     }\n \n-    private static final class NoopWritableListener implements WritableListener {\n+    private static final class NoopChannelOutboundListener implements ChannelOutboundListener {\n         @Override\n         public void channelWritable() {\n         }\n \n         @Override\n-        public void closeGracefully() {\n+        public void channelOutboundClosed() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNjg0MQ=="}, "originalCommit": {"oid": "1638ff22a7f630a8b958e1db5119fea700ef72e4"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ1OTMwNw==", "bodyText": "@NiteshKant - wdyt?", "url": "https://github.com/apple/servicetalk/pull/923#discussion_r376459307", "createdAt": "2020-02-07T15:42:17Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -459,37 +464,34 @@ public FlushStrategy defaultFlushStrategy() {\n         void channelWritable();\n \n         /**\n-         * Close the channel after the pending writes complete.\n-         *\n+         * Notification that the channel's outbound side has been closed and will no longer accept writes.s\n          * <p>\n-         * Calling {@link #close(Throwable)} after {@link #closeGracefully()} will be ignored.\n-         * <p>\n-         * This event is expected be called from the eventloop.\n+         * Always called from the event loop thread.\n          */\n-        void closeGracefully();\n+        void channelOutboundClosed();\n \n         /**\n          * Notification that the channel has been closed.\n          * <p>\n-         * This may not always be called from the event loop. For example if the channel is closed when a new write\n-         * happens then this method will be called from the writer thread.\n+         * This may not always be called from the event loop thread. For example if the channel is closed when a new\n+         * write happens then this method will be called from the writer thread.\n          *\n          * @param closedException the exception which describes the close rational.\n          */\n-        void close(Throwable closedException);\n+        void channelClosed(Throwable closedException);\n     }\n \n-    private static final class NoopWritableListener implements WritableListener {\n+    private static final class NoopChannelOutboundListener implements ChannelOutboundListener {\n         @Override\n         public void channelWritable() {\n         }\n \n         @Override\n-        public void closeGracefully() {\n+        public void channelOutboundClosed() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNjg0MQ=="}, "originalCommit": {"oid": "1638ff22a7f630a8b958e1db5119fea700ef72e4"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjU0MzMwNg==", "bodyText": "I am not convinced that the method name should be targetted to the event name that we know about today (assuming we will not have any other case in which we need similar behavior, i.e. to wait for all writes to finish before closure) but this is an internal class and the naming is more about us to understand behavior. So, if you are convinced, lets go ahead.", "url": "https://github.com/apple/servicetalk/pull/923#discussion_r376543306", "createdAt": "2020-02-07T18:36:53Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -459,37 +464,34 @@ public FlushStrategy defaultFlushStrategy() {\n         void channelWritable();\n \n         /**\n-         * Close the channel after the pending writes complete.\n-         *\n+         * Notification that the channel's outbound side has been closed and will no longer accept writes.s\n          * <p>\n-         * Calling {@link #close(Throwable)} after {@link #closeGracefully()} will be ignored.\n-         * <p>\n-         * This event is expected be called from the eventloop.\n+         * Always called from the event loop thread.\n          */\n-        void closeGracefully();\n+        void channelOutboundClosed();\n \n         /**\n          * Notification that the channel has been closed.\n          * <p>\n-         * This may not always be called from the event loop. For example if the channel is closed when a new write\n-         * happens then this method will be called from the writer thread.\n+         * This may not always be called from the event loop thread. For example if the channel is closed when a new\n+         * write happens then this method will be called from the writer thread.\n          *\n          * @param closedException the exception which describes the close rational.\n          */\n-        void close(Throwable closedException);\n+        void channelClosed(Throwable closedException);\n     }\n \n-    private static final class NoopWritableListener implements WritableListener {\n+    private static final class NoopChannelOutboundListener implements ChannelOutboundListener {\n         @Override\n         public void channelWritable() {\n         }\n \n         @Override\n-        public void closeGracefully() {\n+        public void channelOutboundClosed() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNjg0MQ=="}, "originalCommit": {"oid": "1638ff22a7f630a8b958e1db5119fea700ef72e4"}, "originalPosition": 132}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2831, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}