{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyODY1NDE2", "number": 1240, "title": "Add concurrent-api-test module", "bodyText": "Motivation:\nThere is currently a servicetalk-concurrent-test-internal module for low\nlevel testing of concurrent utilities. However there is no user facing\ntesting utility for dealing with concurrent-api primitives.\nModifications:\n\nIntroduce the concurrent-api-test module which has the StepVerifiers\nentry point. There are 3 entry points one for each async source type:\n\nPublisherFirstStep\nSingleFirstStep\nCompletableFirstStep\n\n\n\nEach of these APIs exposes a sequence of further APIs which represents\nthe expected signal flow of each respective source (e.g. onSubscribe,\nonNext*, [onComplete | onError]?). This approach is inspired by\nreactor-test.\nResult:\nUser facing test utilities exist for concurrent-api.", "createdAt": "2020-12-05T01:00:46Z", "url": "https://github.com/apple/servicetalk/pull/1240", "merged": true, "mergeCommit": {"oid": "7905bff1487716cf0aa766e674cc1b244b138f8b"}, "closed": true, "closedAt": "2020-12-16T01:05:58Z", "author": {"login": "Scottmitch"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdkM8BoAFqTU0NjgxOTE1MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmkH8agH2gAyNTMyODY1NDE2OjFiYWU1Y2E2NDJlYWIxYmM1YWI0ZjNkODQ2NmU0MDBmZDY5ZjM4Y2U=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2ODE5MTUx", "url": "https://github.com/apple/servicetalk/pull/1240#pullrequestreview-546819151", "createdAt": "2020-12-08T07:38:05Z", "commit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "state": "COMMENTED", "comments": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNzozODowNVrOIBLHNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwOTo1OTo0MFrOIBRBoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODEwMTU1OA==", "bodyText": "servicetalk-concurrent-api is already defined as api dependency. Does it need to be duplicated as implementation?", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538101558", "createdAt": "2020-12-08T07:38:05Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/build.gradle", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+apply plugin: \"io.servicetalk.servicetalk-gradle-plugin-internal-library\"\n+\n+dependencies {\n+  api project(\":servicetalk-concurrent-api\")\n+\n+  implementation project(\":servicetalk-annotations\")\n+  implementation project(\":servicetalk-concurrent-internal\")\n+  implementation project(\":servicetalk-concurrent-api\") // idleTimeout operator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODEwNTMwNw==", "bodyText": "Consider using ExecutorRule", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538105307", "createdAt": "2020-12-08T07:41:59Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/CompletableStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Completable.failed;\n+import static io.servicetalk.concurrent.api.Completable.never;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class CompletableStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODExNzg1MA==", "bodyText": "Do we need overrides for PublisherSource, SingleSource, and CompletableSource?", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538117850", "createdAt": "2020-12-08T08:04:25Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/StepVerifiers.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.api.test.TimeSources.nanoTimeNormalized;\n+\n+/**\n+ * Create new test utilities to verify each step in the lifecycle of a {@link Publisher}, {@link Single},\n+ * and {@link Completable}. The steps are typically from the perspective of a {@link Subscriber}'s lifecycle.\n+ */\n+public final class StepVerifiers {\n+    private StepVerifiers() {\n+    }\n+\n+    /**\n+     * Create a new {@link PublisherFirstStep}.\n+     * @param source The {@link Publisher} to verify.\n+     * @param <T> The type of {@link Publisher}.\n+     * @return A {@link PublisherFirstStep} that can be used to verify {@code source}'s signal emission(s).\n+     */\n+    public static <T> PublisherFirstStep<T> create(Publisher<T> source) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODEzMjEyNw==", "bodyText": "I see the same pattern we use everywhere else, when we have a static factory class with the same name but in plural form: StepVerifier and StepVerifiers. However, this case looks different to me. These factory methods does not return StepVerifier interface. They return *FirstStep. So, no requirement to follow the pattern.\nWDYT abot the following ideas:\n\nStatic methods on StepVerifier interface.\nSome factory that will have stepVerifier methods instead of create. For example, Verifiers.stepVerifier(...) or Steps.stepVerifier(...).\n\nBecause we usually prefer static imports, having methods with stepVerifier name will help improve readability in tests. Current create(completed()) harder to understand.", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538132127", "createdAt": "2020-12-08T08:26:15Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/StepVerifiers.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.api.test.TimeSources.nanoTimeNormalized;\n+\n+/**\n+ * Create new test utilities to verify each step in the lifecycle of a {@link Publisher}, {@link Single},\n+ * and {@link Completable}. The steps are typically from the perspective of a {@link Subscriber}'s lifecycle.\n+ */\n+public final class StepVerifiers {\n+    private StepVerifiers() {\n+    }\n+\n+    /**\n+     * Create a new {@link PublisherFirstStep}.\n+     * @param source The {@link Publisher} to verify.\n+     * @param <T> The type of {@link Publisher}.\n+     * @return A {@link PublisherFirstStep} that can be used to verify {@code source}'s signal emission(s).\n+     */\n+    public static <T> PublisherFirstStep<T> create(Publisher<T> source) {\n+        return new InlinePublisherFirstStep<>(toSource(source), nanoTimeNormalized());\n+    }\n+\n+    /**\n+     * Create a new {@link SingleFirstStep}.\n+     * @param source The {@link Single} to verify.\n+     * @param <T> The type of {@link Single}.\n+     * @return A {@link SingleFirstStep} that can be used to verify {@code source}'s signal emission(s).\n+     */\n+    public static <T> SingleFirstStep<T> create(Single<T> source) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODEzNTI0Mg==", "bodyText": "It can also be a SingleSource or CompletableSource. Consider listing all of them or avoiding the link. Something like \"This method will trigger a subscribe operation.\" looks enough to me.", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538135242", "createdAt": "2020-12-08T08:30:29Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/StepVerifier.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+\n+import java.time.Duration;\n+\n+/**\n+ * Provides the ability to verify expectations on asynchronous sources.\n+ */\n+public interface StepVerifier {\n+    /**\n+     * Verify the none of the previously declared expectations are violated.\n+     * <p>\n+     * This method will trigger a {@link PublisherSource#subscribe(Subscriber) subscribe} operation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODEzODI4Mw==", "bodyText": "Consider using assertThrows", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538138283", "createdAt": "2020-12-08T08:35:19Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/PublisherStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,649 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.TestPublisher;\n+import io.servicetalk.concurrent.api.TestSubscription;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.hamcrest.Matchers;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessor;\n+import static io.servicetalk.concurrent.api.Publisher.empty;\n+import static io.servicetalk.concurrent.api.Publisher.failed;\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Publisher.never;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class PublisherStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectSubscription() {\n+        create(from(\"foo\"))\n+                .expectSubscription(Assert::assertNotNull)\n+                .expectNext(\"foo\")\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectSubscriptionTimeout() {\n+        assert executor != null;\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try {\n+            verifyException(() -> create(from(\"foo\").publishAndSubscribeOn(executor))\n+                    .expectSubscription(subscription -> {\n+                        try {\n+                            latch.await();\n+                        } catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    })\n+                    .expectNext(\"foo\")\n+                    .expectComplete()\n+                    .verify(ofNanos(10)));\n+        } finally {\n+            latch.countDown();\n+        }\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void emptyItemsNonEmptyPublisher() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(emptyList())\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void emptyItemsEmptyPublisher() {\n+        create(empty())\n+                .expectNext(emptyList())\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void singleItem() {\n+        assertNotNull(create(from(\"foo\"))\n+                .expectNext(\"foo\")\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void singleItemNull() {\n+        assertNotNull(create(from((String) null))\n+                .expectNext((String) null)\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void singleItemDuplicateVerify() throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(2);\n+        StepVerifier verifier = create(from(\"foo\"))\n+                .expectNext(next -> {\n+                    assertEquals(\"foo\", next);\n+                    latch.countDown();\n+                })\n+                .expectComplete();\n+        verifier.verify();\n+        verifier.verify();\n+        assertTrue(latch.await(10, SECONDS));\n+    }\n+\n+    @Test\n+    public void singleItemLargeTimeout() {\n+        assertNotNull(create(from(\"foo\"))\n+                .expectNext(\"foo\")\n+                .expectComplete()\n+                .verify(ofDays(1)));\n+    }\n+\n+    @Test\n+    public void twoItems() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNext(\"foo\", \"bar\")\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void twoItemsIterable() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNext(() -> asList(\"foo\", \"bar\").iterator())\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void justError() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void justErrorPredicate() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(cause -> cause instanceof DeliberateException)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void justErrorConsumer() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(cause -> {\n+                    assertThat(cause, instanceOf(DeliberateException.class));\n+                })\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void errorIgnoreNextFails() {\n+        verifyException(() -> create(from(\"foo\").concat(failed(DELIBERATE_EXCEPTION)))\n+                .expectError(cause -> cause instanceof DeliberateException)\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void completeIgnoreNextConsumer() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void justErrorTimeout() {\n+        verifyException(() -> create(never())\n+                .expectError(DeliberateException.class)\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test\n+    public void onNextThenError() {\n+        create(from(\"foo\").concat(failed(DELIBERATE_EXCEPTION)))\n+                .expectNext(\"foo\")\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void incorrectOnNextExpectation() {\n+        verifyException(() -> create(from(\"foo\"))\n+                    .expectNext(\"bar\")\n+                    .expectComplete()\n+                    .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void timeoutOnNever() {\n+        verifyException(() -> create(never())\n+            .expectComplete()\n+            .verify(ofNanos(10)));\n+    }\n+\n+    @Test\n+    public void expectNextCount() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNextCount(2)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void expectNextConsumer() {\n+        create(from(\"foo\"))\n+                .expectNext(next -> assertEquals(\"foo\", next))\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextConsumerTimeout() {\n+        verifyException(() -> create(from(\"foo\").concat(never()))\n+                .expectNext(next -> assertEquals(\"foo\", next))\n+                .expectComplete()\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextArrayMoreThanActual() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(\"foo\", \"bar\")\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextCollectionMoreThanActual() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(asList(\"foo\", \"bar\"))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextIterableMoreThanActual() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext((Iterable<String>) asList(\"foo\", \"bar\"))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextArrayLessThanActual() {\n+        verifyException(() ->\n+                create(from(\"foo\", \"bar\"))\n+                .expectNext(\"foo\")\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextCollectionLessThanActual() {\n+        verifyException(() ->\n+                create(from(\"foo\", \"bar\"))\n+                        .expectNext(singletonList(\"foo\"))\n+                        .expectComplete()\n+                        .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextIterableLessThanActual() {\n+        verifyException(() ->\n+                create(from(\"foo\", \"bar\"))\n+                        .expectNext((Iterable<String>) singletonList(\"foo\"))\n+                        .expectComplete()\n+                        .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextConsumerFail() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(next -> assertEquals(\"bar\", next))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void expectNextMultiConsumer() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNext(2, nextIterable -> assertThat(nextIterable, contains(\"foo\", \"bar\")))\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextMultiConsumerFail() {\n+        verifyException(() -> create(from(\"foo\", \"bar\"))\n+                .expectNext(2, nextIterable -> assertThat(nextIterable, contains(\"foo\")))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void expectNextMultiConsumerMinComplete() {\n+        create(from(\"foo\"))\n+                .expectNext(1, 2, nextIterable -> assertThat(nextIterable, contains(\"foo\")))\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void expectNextMultiConsumerMinFail() {\n+        create(from(\"foo\").concat(failed(DELIBERATE_EXCEPTION)))\n+                .expectNext(1, 2, nextIterable -> assertThat(nextIterable, contains(\"foo\")))\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void expectNextMultiConsumerZero() {\n+        create(empty())\n+                .expectNext(0, 2, nextIterable -> assertThat(nextIterable, Matchers.empty()))\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextMultiConsumerTimeout() {\n+        verifyException(() -> create(from(\"foo\", \"bar\").concat(never()))\n+                .expectNext(2, nextIterable -> assertThat(nextIterable, contains(\"foo\", \"bar\")))\n+                .expectComplete()\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnErrorWhenOnComplete() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(\"foo\")\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnCompleteWhenOnError() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsAfterNextThenCancelSucceeds() {\n+        create(from(\"foo\").concat(never()))\n+                .expectNext(\"foo\")\n+                .expectNoSignals(ofMillis(100))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsSubscriptionCompleteFail() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNoSignals(ofDays(1))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsSubscriptionCancelSucceeds() {\n+        // expectNoSignals and subscription event are dequeued/processed sequentially on the Subscriber thread\n+        // and the scenario isn't instructed to expect the subscription so we pass the test.\n+        TestSubscription subscription = new TestSubscription();\n+        TestPublisher<String> publisher = new TestPublisher.Builder<String>()\n+                .disableAutoOnSubscribe().build();\n+        create(publisher)\n+                .then(() -> publisher.onSubscribe(subscription))\n+                .expectNoSignals(ofDays(1))\n+                .thenCancel()\n+                .verify();\n+        assertTrue(subscription.isCancelled());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsCompleteFail() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(\"foo\")\n+                .expectNoSignals(ofDays(1))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsErrorFails() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                .expectSubscription(s -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsAfterSubscriptionSucceeds() {\n+        create(never())\n+                .expectSubscription(s -> { })\n+                .expectNoSignals(ofMillis(100))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenCancel() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNext(\"foo\")\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenRequest() {\n+        create(from(\"foo\", \"bar\"))\n+                .thenRequest(Long.MAX_VALUE)\n+                .expectNext(\"foo\", \"bar\")\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenRequestInvalidZero() {\n+        thenRequestInvalid(0);\n+    }\n+\n+    @Test\n+    public void thenRequestInvalidMin() {\n+        thenRequestInvalid(Long.MIN_VALUE);\n+    }\n+\n+    private static void thenRequestInvalid(long invalidN) {\n+        create(from(\"foo\", \"bar\"))\n+                .thenRequest(invalidN)\n+                .expectError(IllegalArgumentException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void multipleRequests() {\n+        TestSubscription subscription = new TestSubscription();\n+        TestPublisher<String> publisher = new TestPublisher.Builder<String>()\n+                .disableAutoOnSubscribe().build();\n+        create(publisher)\n+                .then(() -> publisher.onSubscribe(subscription))\n+                .thenRequest(1)\n+                .thenRequest(2)\n+                .then(() -> {\n+                    assertThat(subscription.requested(), greaterThanOrEqualTo(3L));\n+                    publisher.onNext(\"foo\", \"bar\");\n+                    publisher.onComplete();\n+                })\n+                .expectNext(\"foo\", \"bar\")\n+                .expectComplete()\n+                .verify();\n+        assertThat(subscription.requested(), greaterThanOrEqualTo(5L));\n+    }\n+\n+    @Test\n+    public void requestThenCancel() {\n+        TestSubscription subscription = new TestSubscription();\n+        TestPublisher<String> publisher = new TestPublisher.Builder<String>()\n+                .disableAutoOnSubscribe().build();\n+        create(publisher)\n+                .then(() -> publisher.onSubscribe(subscription))\n+                .thenRequest(100)\n+                .then(() -> {\n+                    assertThat(subscription.requested(), greaterThanOrEqualTo(100L));\n+                    publisher.onNext(\"foo\", \"bar\");\n+                })\n+                .expectNext(\"foo\", \"bar\")\n+                .thenCancel()\n+                .verify();\n+        assertTrue(subscription.isCancelled());\n+    }\n+\n+    @Test\n+    public void thenRun() {\n+        PublisherSource.Processor<String, String> processor = newPublisherProcessor();\n+        create(fromSource(processor))\n+                .then(() -> {\n+                    processor.onNext(\"foo\");\n+                    processor.onNext(\"bar\");\n+                })\n+                .expectNext(\"foo\", \"bar\")\n+                .then(processor::onComplete)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void thenRunThrows() {\n+        create(from(\"foo\"))\n+                .then(() -> {\n+                    throw new IllegalStateException();\n+                })\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void asyncContextOnComplete() {\n+        assert executor != null;\n+        create(from(\"foo\").publishAndSubscribeOn(executor))\n+                .expectSubscription(s -> {\n+                    assertNotNull(s);\n+                    AsyncContext.put(ASYNC_KEY, 10);\n+                })\n+                .expectNext(next -> {\n+                    assertEquals(\"foo\", next);\n+                    assertThat(AsyncContext.get(ASYNC_KEY), is(10));\n+                })\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void asyncContextOnError() {\n+        assert executor != null;\n+        create(from(\"foo\").concat(failed(DELIBERATE_EXCEPTION)).publishAndSubscribeOn(executor))\n+                .expectSubscription(s -> {\n+                    assertNotNull(s);\n+                    AsyncContext.put(ASYNC_KEY, 10);\n+                })\n+                .expectNext(next -> {\n+                    assertEquals(\"foo\", next);\n+                    assertThat(AsyncContext.get(ASYNC_KEY), is(10));\n+                    AsyncContext.put(ASYNC_KEY, 15);\n+                })\n+                .expectError(error -> {\n+                    assertSame(DELIBERATE_EXCEPTION, error);\n+                    assertThat(AsyncContext.get(ASYNC_KEY), is(15));\n+                })\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenAwaitExitsWhenVerifyComplete() {\n+        create(from(\"foo\"))\n+                .thenAwait(ofDays(1))\n+                .expectNext(\"foo\")\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenAwaitRespectsDelaysComplete() {\n+        PublisherSource.Processor<String, String> processor = newPublisherProcessor();\n+        new InlinePublisherFirstStep<>(processor, new DefaultModifiableTimeSource())\n+                .expectSubscription(s -> { })\n+                .expectNoSignals(ofDays(500))\n+                .thenAwait(ofDays(1000))\n+                .then(() -> processor.onNext(\"foo\"))\n+                .expectNext(\"foo\")\n+                .then(processor::onComplete)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void thenAwaitRespectsDelaysEqualsFail() {\n+        thenAwaitRespectsDelaysFail(true);\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void thenAwaitRespectsDelaysGTFail() {\n+        thenAwaitRespectsDelaysFail(false);\n+    }\n+\n+    private static void thenAwaitRespectsDelaysFail(boolean equals) {\n+        PublisherSource.Processor<String, String> processor = newPublisherProcessor();\n+        verifyException(() -> new InlinePublisherFirstStep<>(processor, new DefaultModifiableTimeSource())\n+                .expectSubscription(s -> { })\n+                .expectNoSignals(ofDays(equals ? 1000 : 1001))\n+                .thenAwait(ofDays(1000))\n+                .then(() -> processor.onNext(\"foo\"))\n+                .expectNext(\"foo\")\n+                .then(processor::onComplete)\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    private static void verifyException(Supplier<Duration> verifier) {\n+        verifyException(verifier, PublisherStepVerifierTest.class.getName());\n+    }\n+\n+    static void verifyException(Supplier<Duration> verifier, String classNamePrefix) {\n+        try {\n+            verifier.get();\n+        } catch (AssertionError error) {\n+            StackTraceElement[] stackTraceElements = error.getStackTrace();\n+            if (stackTraceElements.length == 0 || !stackTraceElements[0].getClassName().startsWith(classNamePrefix)) {\n+                // the tests expect AssertionError, we need to throw a different type of exception!\n+                throw new IllegalStateException(\"stacktrace does not start with classNamePrefix: \" + classNamePrefix,\n+                        error);\n+            }\n+            throw error;\n+        }\n+        throw new IllegalStateException(\"expected test to fail, but it didn't\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 647}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE0MDczNg==", "bodyText": "This won't be necessary if verifyException uses assertThrows. assertThrows gives more control over the returned exception and allows to perform additional validataion: msg, cause, etc.\nexpected = AssertionError.class doesn't help to understand which \"expect*\" step causes an error.", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538140736", "createdAt": "2020-12-08T08:39:10Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/CompletableStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Completable.failed;\n+import static io.servicetalk.concurrent.api.Completable.never;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class CompletableStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectCancellable() {\n+        create(completed())\n+                .expectCancellable(Assert::assertNotNull)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE0NDQ0OQ==", "bodyText": "Single -> Completable", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538144449", "createdAt": "2020-12-08T08:44:48Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/CompletableStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Completable.failed;\n+import static io.servicetalk.concurrent.api.Completable.never;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class CompletableStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectCancellable() {\n+        create(completed())\n+                .expectCancellable(Assert::assertNotNull)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectCancellableTimeout() {\n+        assert executor != null;\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try {\n+            verifyException(() -> create(completed().publishAndSubscribeOn(executor))\n+                    .expectCancellable(cancellable -> {\n+                        try {\n+                            latch.await();\n+                        } catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    })\n+                    .expectComplete()\n+                    .verify(ofNanos(10)));\n+        } finally {\n+            latch.countDown();\n+        }\n+    }\n+\n+    @Test\n+    public void onComplete() {\n+        assertNotNull(create(completed())\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void onCompleteDuplicateVerify() throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(2);\n+        StepVerifier verifier = create(completed())\n+                .expectCancellable(cancellable -> {\n+                    assertNotNull(cancellable);\n+                    latch.countDown();\n+                })\n+                .expectComplete();\n+        verifier.verify();\n+        verifier.verify();\n+        assertTrue(latch.await(10, SECONDS));\n+    }\n+\n+    @Test\n+    public void onCompleteLargeTimeout() {\n+        assertNotNull(create(completed())\n+                .expectComplete()\n+                .verify(ofDays(1)));\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void onCompleteTimeout() {\n+        verifyException(() -> create(never())\n+                .expectComplete()\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test\n+    public void onErrorClass() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorPredicate() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> error instanceof DeliberateException)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorConsumer() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> {\n+                    assertThat(error, is(DELIBERATE_EXCEPTION));\n+                })\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnErrorWhenOnComplete() {\n+        verifyException(() -> create(completed())\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnSuccessWhenOnError() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                    .expectComplete()\n+                    .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsSubscriptionCancelSucceeds() {\n+        // expectNoSignals and subscription event are dequeued/processed sequentially on the Subscriber thread\n+        // and the scenario isn't instructed to expect the subscription so we pass the test.\n+        create(never())\n+                .expectNoSignals(ofDays(1))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsCompleteFail() {\n+        verifyException(() -> create(completed())\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsErrorFails() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsAfterSubscriptionSucceeds() {\n+        create(Single.never())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE0OTQ2Ng==", "bodyText": "Consider adding a test for failed(...)).thenCancel()", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538149466", "createdAt": "2020-12-08T08:52:43Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/CompletableStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Completable.failed;\n+import static io.servicetalk.concurrent.api.Completable.never;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class CompletableStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectCancellable() {\n+        create(completed())\n+                .expectCancellable(Assert::assertNotNull)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectCancellableTimeout() {\n+        assert executor != null;\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try {\n+            verifyException(() -> create(completed().publishAndSubscribeOn(executor))\n+                    .expectCancellable(cancellable -> {\n+                        try {\n+                            latch.await();\n+                        } catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    })\n+                    .expectComplete()\n+                    .verify(ofNanos(10)));\n+        } finally {\n+            latch.countDown();\n+        }\n+    }\n+\n+    @Test\n+    public void onComplete() {\n+        assertNotNull(create(completed())\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void onCompleteDuplicateVerify() throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(2);\n+        StepVerifier verifier = create(completed())\n+                .expectCancellable(cancellable -> {\n+                    assertNotNull(cancellable);\n+                    latch.countDown();\n+                })\n+                .expectComplete();\n+        verifier.verify();\n+        verifier.verify();\n+        assertTrue(latch.await(10, SECONDS));\n+    }\n+\n+    @Test\n+    public void onCompleteLargeTimeout() {\n+        assertNotNull(create(completed())\n+                .expectComplete()\n+                .verify(ofDays(1)));\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void onCompleteTimeout() {\n+        verifyException(() -> create(never())\n+                .expectComplete()\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test\n+    public void onErrorClass() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorPredicate() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> error instanceof DeliberateException)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorConsumer() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> {\n+                    assertThat(error, is(DELIBERATE_EXCEPTION));\n+                })\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnErrorWhenOnComplete() {\n+        verifyException(() -> create(completed())\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnSuccessWhenOnError() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                    .expectComplete()\n+                    .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsSubscriptionCancelSucceeds() {\n+        // expectNoSignals and subscription event are dequeued/processed sequentially on the Subscriber thread\n+        // and the scenario isn't instructed to expect the subscription so we pass the test.\n+        create(never())\n+                .expectNoSignals(ofDays(1))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsCompleteFail() {\n+        verifyException(() -> create(completed())\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsErrorFails() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsAfterSubscriptionSucceeds() {\n+        create(Single.never())\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofMillis(100))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenCancel() {\n+        create(completed())\n+                .thenCancel()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE1MjY4NA==", "bodyText": "IIUC, it simulates exception from onSubscribe. Then we should expect onError and the test should not have expected = IllegalStateException.class.\nAlso, consider using DeliberateException.", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538152684", "createdAt": "2020-12-08T08:57:29Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/CompletableStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Completable.failed;\n+import static io.servicetalk.concurrent.api.Completable.never;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class CompletableStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectCancellable() {\n+        create(completed())\n+                .expectCancellable(Assert::assertNotNull)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectCancellableTimeout() {\n+        assert executor != null;\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try {\n+            verifyException(() -> create(completed().publishAndSubscribeOn(executor))\n+                    .expectCancellable(cancellable -> {\n+                        try {\n+                            latch.await();\n+                        } catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    })\n+                    .expectComplete()\n+                    .verify(ofNanos(10)));\n+        } finally {\n+            latch.countDown();\n+        }\n+    }\n+\n+    @Test\n+    public void onComplete() {\n+        assertNotNull(create(completed())\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void onCompleteDuplicateVerify() throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(2);\n+        StepVerifier verifier = create(completed())\n+                .expectCancellable(cancellable -> {\n+                    assertNotNull(cancellable);\n+                    latch.countDown();\n+                })\n+                .expectComplete();\n+        verifier.verify();\n+        verifier.verify();\n+        assertTrue(latch.await(10, SECONDS));\n+    }\n+\n+    @Test\n+    public void onCompleteLargeTimeout() {\n+        assertNotNull(create(completed())\n+                .expectComplete()\n+                .verify(ofDays(1)));\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void onCompleteTimeout() {\n+        verifyException(() -> create(never())\n+                .expectComplete()\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test\n+    public void onErrorClass() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorPredicate() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> error instanceof DeliberateException)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorConsumer() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> {\n+                    assertThat(error, is(DELIBERATE_EXCEPTION));\n+                })\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnErrorWhenOnComplete() {\n+        verifyException(() -> create(completed())\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnSuccessWhenOnError() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                    .expectComplete()\n+                    .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsSubscriptionCancelSucceeds() {\n+        // expectNoSignals and subscription event are dequeued/processed sequentially on the Subscriber thread\n+        // and the scenario isn't instructed to expect the subscription so we pass the test.\n+        create(never())\n+                .expectNoSignals(ofDays(1))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsCompleteFail() {\n+        verifyException(() -> create(completed())\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsErrorFails() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsAfterSubscriptionSucceeds() {\n+        create(Single.never())\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofMillis(100))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenCancel() {\n+        create(completed())\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenRun() {\n+        CompletableSource.Processor processor = newCompletableProcessor();\n+        create(fromSource(processor))\n+                .then(processor::onComplete)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void asyncContextOnError() {\n+        assert executor != null;\n+        create(failed(DELIBERATE_EXCEPTION).publishAndSubscribeOn(executor))\n+                .expectCancellable(s -> {\n+                    assertNotNull(s);\n+                    AsyncContext.put(ASYNC_KEY, 10);\n+                })\n+                .expectError(error -> {\n+                    assertSame(DELIBERATE_EXCEPTION, error);\n+                    assertThat(AsyncContext.get(ASYNC_KEY), is(10));\n+                })\n+                .verify();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void thenRunThrows() {\n+        create(completed())\n+                .then(() -> {\n+                    throw new IllegalStateException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE1NzEwNw==", "bodyText": "This class can be final.\nThis is the only Inline* class that is public. Can we make it pkg-private. If necessary, we should use static factories to create *Step implementations.\nIf it should be public, it misses javadoc.", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538157107", "createdAt": "2020-12-08T09:03:42Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/InlineCompletableFirstStep.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+import io.servicetalk.concurrent.api.test.InlinePublisherSubscriber.NoSignalForDurationEvent;\n+import io.servicetalk.concurrent.api.test.InlinePublisherSubscriber.OnSubscriptionEvent;\n+import io.servicetalk.concurrent.api.test.InlinePublisherSubscriber.OnTerminalCompleteEvent;\n+import io.servicetalk.concurrent.api.test.InlinePublisherSubscriber.OnTerminalErrorClassChecker;\n+import io.servicetalk.concurrent.api.test.InlinePublisherSubscriber.OnTerminalErrorEvent;\n+import io.servicetalk.concurrent.api.test.InlinePublisherSubscriber.OnTerminalErrorPredicate;\n+import io.servicetalk.concurrent.api.test.InlinePublisherSubscriber.VerifyThreadAwaitEvent;\n+import io.servicetalk.concurrent.api.test.InlinePublisherSubscriber.VerifyThreadRunEvent;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+import static io.servicetalk.concurrent.api.test.InlineStepVerifier.PublisherEvent;\n+import static java.util.Objects.requireNonNull;\n+\n+public class InlineCompletableFirstStep implements CompletableFirstStep {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE2MDg1Mg==", "bodyText": "Consider using ExecutorRule", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538160852", "createdAt": "2020-12-08T09:09:05Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/PublisherStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,649 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.TestPublisher;\n+import io.servicetalk.concurrent.api.TestSubscription;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.hamcrest.Matchers;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessor;\n+import static io.servicetalk.concurrent.api.Publisher.empty;\n+import static io.servicetalk.concurrent.api.Publisher.failed;\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Publisher.never;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class PublisherStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE2MDk0Mg==", "bodyText": "Consider using ExecutorRule", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538160942", "createdAt": "2020-12-08T09:09:14Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/SingleStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.SingleSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newSingleProcessor;\n+import static io.servicetalk.concurrent.api.Single.failed;\n+import static io.servicetalk.concurrent.api.Single.never;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SingleStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE2NzM3NQ==", "bodyText": "Consider using DeliberateException", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538167375", "createdAt": "2020-12-08T09:18:05Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/PublisherStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,649 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.TestPublisher;\n+import io.servicetalk.concurrent.api.TestSubscription;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.hamcrest.Matchers;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessor;\n+import static io.servicetalk.concurrent.api.Publisher.empty;\n+import static io.servicetalk.concurrent.api.Publisher.failed;\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Publisher.never;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class PublisherStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectSubscription() {\n+        create(from(\"foo\"))\n+                .expectSubscription(Assert::assertNotNull)\n+                .expectNext(\"foo\")\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectSubscriptionTimeout() {\n+        assert executor != null;\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try {\n+            verifyException(() -> create(from(\"foo\").publishAndSubscribeOn(executor))\n+                    .expectSubscription(subscription -> {\n+                        try {\n+                            latch.await();\n+                        } catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    })\n+                    .expectNext(\"foo\")\n+                    .expectComplete()\n+                    .verify(ofNanos(10)));\n+        } finally {\n+            latch.countDown();\n+        }\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void emptyItemsNonEmptyPublisher() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(emptyList())\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void emptyItemsEmptyPublisher() {\n+        create(empty())\n+                .expectNext(emptyList())\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void singleItem() {\n+        assertNotNull(create(from(\"foo\"))\n+                .expectNext(\"foo\")\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void singleItemNull() {\n+        assertNotNull(create(from((String) null))\n+                .expectNext((String) null)\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void singleItemDuplicateVerify() throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(2);\n+        StepVerifier verifier = create(from(\"foo\"))\n+                .expectNext(next -> {\n+                    assertEquals(\"foo\", next);\n+                    latch.countDown();\n+                })\n+                .expectComplete();\n+        verifier.verify();\n+        verifier.verify();\n+        assertTrue(latch.await(10, SECONDS));\n+    }\n+\n+    @Test\n+    public void singleItemLargeTimeout() {\n+        assertNotNull(create(from(\"foo\"))\n+                .expectNext(\"foo\")\n+                .expectComplete()\n+                .verify(ofDays(1)));\n+    }\n+\n+    @Test\n+    public void twoItems() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNext(\"foo\", \"bar\")\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void twoItemsIterable() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNext(() -> asList(\"foo\", \"bar\").iterator())\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void justError() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void justErrorPredicate() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(cause -> cause instanceof DeliberateException)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void justErrorConsumer() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(cause -> {\n+                    assertThat(cause, instanceOf(DeliberateException.class));\n+                })\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void errorIgnoreNextFails() {\n+        verifyException(() -> create(from(\"foo\").concat(failed(DELIBERATE_EXCEPTION)))\n+                .expectError(cause -> cause instanceof DeliberateException)\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void completeIgnoreNextConsumer() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void justErrorTimeout() {\n+        verifyException(() -> create(never())\n+                .expectError(DeliberateException.class)\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test\n+    public void onNextThenError() {\n+        create(from(\"foo\").concat(failed(DELIBERATE_EXCEPTION)))\n+                .expectNext(\"foo\")\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void incorrectOnNextExpectation() {\n+        verifyException(() -> create(from(\"foo\"))\n+                    .expectNext(\"bar\")\n+                    .expectComplete()\n+                    .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void timeoutOnNever() {\n+        verifyException(() -> create(never())\n+            .expectComplete()\n+            .verify(ofNanos(10)));\n+    }\n+\n+    @Test\n+    public void expectNextCount() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNextCount(2)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void expectNextConsumer() {\n+        create(from(\"foo\"))\n+                .expectNext(next -> assertEquals(\"foo\", next))\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextConsumerTimeout() {\n+        verifyException(() -> create(from(\"foo\").concat(never()))\n+                .expectNext(next -> assertEquals(\"foo\", next))\n+                .expectComplete()\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextArrayMoreThanActual() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(\"foo\", \"bar\")\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextCollectionMoreThanActual() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(asList(\"foo\", \"bar\"))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextIterableMoreThanActual() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext((Iterable<String>) asList(\"foo\", \"bar\"))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextArrayLessThanActual() {\n+        verifyException(() ->\n+                create(from(\"foo\", \"bar\"))\n+                .expectNext(\"foo\")\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextCollectionLessThanActual() {\n+        verifyException(() ->\n+                create(from(\"foo\", \"bar\"))\n+                        .expectNext(singletonList(\"foo\"))\n+                        .expectComplete()\n+                        .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextIterableLessThanActual() {\n+        verifyException(() ->\n+                create(from(\"foo\", \"bar\"))\n+                        .expectNext((Iterable<String>) singletonList(\"foo\"))\n+                        .expectComplete()\n+                        .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextConsumerFail() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(next -> assertEquals(\"bar\", next))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void expectNextMultiConsumer() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNext(2, nextIterable -> assertThat(nextIterable, contains(\"foo\", \"bar\")))\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextMultiConsumerFail() {\n+        verifyException(() -> create(from(\"foo\", \"bar\"))\n+                .expectNext(2, nextIterable -> assertThat(nextIterable, contains(\"foo\")))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void expectNextMultiConsumerMinComplete() {\n+        create(from(\"foo\"))\n+                .expectNext(1, 2, nextIterable -> assertThat(nextIterable, contains(\"foo\")))\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void expectNextMultiConsumerMinFail() {\n+        create(from(\"foo\").concat(failed(DELIBERATE_EXCEPTION)))\n+                .expectNext(1, 2, nextIterable -> assertThat(nextIterable, contains(\"foo\")))\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void expectNextMultiConsumerZero() {\n+        create(empty())\n+                .expectNext(0, 2, nextIterable -> assertThat(nextIterable, Matchers.empty()))\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectNextMultiConsumerTimeout() {\n+        verifyException(() -> create(from(\"foo\", \"bar\").concat(never()))\n+                .expectNext(2, nextIterable -> assertThat(nextIterable, contains(\"foo\", \"bar\")))\n+                .expectComplete()\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnErrorWhenOnComplete() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(\"foo\")\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnCompleteWhenOnError() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsAfterNextThenCancelSucceeds() {\n+        create(from(\"foo\").concat(never()))\n+                .expectNext(\"foo\")\n+                .expectNoSignals(ofMillis(100))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsSubscriptionCompleteFail() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNoSignals(ofDays(1))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsSubscriptionCancelSucceeds() {\n+        // expectNoSignals and subscription event are dequeued/processed sequentially on the Subscriber thread\n+        // and the scenario isn't instructed to expect the subscription so we pass the test.\n+        TestSubscription subscription = new TestSubscription();\n+        TestPublisher<String> publisher = new TestPublisher.Builder<String>()\n+                .disableAutoOnSubscribe().build();\n+        create(publisher)\n+                .then(() -> publisher.onSubscribe(subscription))\n+                .expectNoSignals(ofDays(1))\n+                .thenCancel()\n+                .verify();\n+        assertTrue(subscription.isCancelled());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsCompleteFail() {\n+        verifyException(() -> create(from(\"foo\"))\n+                .expectNext(\"foo\")\n+                .expectNoSignals(ofDays(1))\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsErrorFails() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                .expectSubscription(s -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsAfterSubscriptionSucceeds() {\n+        create(never())\n+                .expectSubscription(s -> { })\n+                .expectNoSignals(ofMillis(100))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenCancel() {\n+        create(from(\"foo\", \"bar\"))\n+                .expectNext(\"foo\")\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenRequest() {\n+        create(from(\"foo\", \"bar\"))\n+                .thenRequest(Long.MAX_VALUE)\n+                .expectNext(\"foo\", \"bar\")\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenRequestInvalidZero() {\n+        thenRequestInvalid(0);\n+    }\n+\n+    @Test\n+    public void thenRequestInvalidMin() {\n+        thenRequestInvalid(Long.MIN_VALUE);\n+    }\n+\n+    private static void thenRequestInvalid(long invalidN) {\n+        create(from(\"foo\", \"bar\"))\n+                .thenRequest(invalidN)\n+                .expectError(IllegalArgumentException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void multipleRequests() {\n+        TestSubscription subscription = new TestSubscription();\n+        TestPublisher<String> publisher = new TestPublisher.Builder<String>()\n+                .disableAutoOnSubscribe().build();\n+        create(publisher)\n+                .then(() -> publisher.onSubscribe(subscription))\n+                .thenRequest(1)\n+                .thenRequest(2)\n+                .then(() -> {\n+                    assertThat(subscription.requested(), greaterThanOrEqualTo(3L));\n+                    publisher.onNext(\"foo\", \"bar\");\n+                    publisher.onComplete();\n+                })\n+                .expectNext(\"foo\", \"bar\")\n+                .expectComplete()\n+                .verify();\n+        assertThat(subscription.requested(), greaterThanOrEqualTo(5L));\n+    }\n+\n+    @Test\n+    public void requestThenCancel() {\n+        TestSubscription subscription = new TestSubscription();\n+        TestPublisher<String> publisher = new TestPublisher.Builder<String>()\n+                .disableAutoOnSubscribe().build();\n+        create(publisher)\n+                .then(() -> publisher.onSubscribe(subscription))\n+                .thenRequest(100)\n+                .then(() -> {\n+                    assertThat(subscription.requested(), greaterThanOrEqualTo(100L));\n+                    publisher.onNext(\"foo\", \"bar\");\n+                })\n+                .expectNext(\"foo\", \"bar\")\n+                .thenCancel()\n+                .verify();\n+        assertTrue(subscription.isCancelled());\n+    }\n+\n+    @Test\n+    public void thenRun() {\n+        PublisherSource.Processor<String, String> processor = newPublisherProcessor();\n+        create(fromSource(processor))\n+                .then(() -> {\n+                    processor.onNext(\"foo\");\n+                    processor.onNext(\"bar\");\n+                })\n+                .expectNext(\"foo\", \"bar\")\n+                .then(processor::onComplete)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void thenRunThrows() {\n+        create(from(\"foo\"))\n+                .then(() -> {\n+                    throw new IllegalStateException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 543}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE2NzY3Ng==", "bodyText": "Consider using DeliberateException", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538167676", "createdAt": "2020-12-08T09:18:33Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/SingleStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.SingleSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newSingleProcessor;\n+import static io.servicetalk.concurrent.api.Single.failed;\n+import static io.servicetalk.concurrent.api.Single.never;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SingleStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectCancellable() {\n+        create(succeeded(\"foo\"))\n+                .expectCancellable(Assert::assertNotNull)\n+                .expectSuccess(\"foo\")\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectCancellableTimeout() {\n+        assert executor != null;\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try {\n+            verifyException(() -> create(completed().publishAndSubscribeOn(executor))\n+                    .expectCancellable(cancellable -> {\n+                        try {\n+                            latch.await();\n+                        } catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    })\n+                    .expectComplete()\n+                    .verify(ofNanos(10)));\n+        } finally {\n+            latch.countDown();\n+        }\n+    }\n+\n+    @Test\n+    public void onSuccessDuplicateVerify() throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(2);\n+        StepVerifier verifier = create(succeeded(\"foo\"))\n+                .expectCancellable(cancellable -> {\n+                    assertNotNull(cancellable);\n+                    latch.countDown();\n+                })\n+                .expectSuccess(\"foo\");\n+        verifier.verify();\n+        verifier.verify();\n+        assertTrue(latch.await(10, SECONDS));\n+    }\n+\n+    @Test\n+    public void onSuccess() {\n+        assertNotNull(create(succeeded(\"foo\"))\n+                .expectSuccess(\"foo\")\n+                .verify());\n+    }\n+\n+    @Test\n+    public void onSuccessNull() {\n+        assertNotNull(create(succeeded(null))\n+                .expectSuccess((String) null)\n+                .verify());\n+    }\n+\n+    @Test\n+    public void onSuccessLargeTimeout() {\n+        assertNotNull(create(succeeded(\"foo\"))\n+                .expectSuccess(\"foo\")\n+                .verify(ofDays(1)));\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void onSuccessTimeout() {\n+        verifyException(() -> create(never())\n+                .expectSuccess(\"foo\")\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test\n+    public void onErrorClass() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorPredicate() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> error instanceof DeliberateException)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorConsumer() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> {\n+                    assertThat(error, is(DELIBERATE_EXCEPTION));\n+                })\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnErrorWhenOnSuccess() {\n+        verifyException(() -> create(succeeded(\"foo\"))\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnSuccessWhenOnError() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                    .expectSuccess(\"foo\")\n+                    .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsSubscriptionCancelSucceeds() {\n+        // expectNoSignals and subscription event are dequeued/processed sequentially on the Subscriber thread\n+        // and the scenario isn't instructed to expect the subscription so we pass the test.\n+        create(never())\n+                .expectNoSignals(ofDays(1))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsSuccessFail() {\n+        verifyException(() -> create(succeeded(\"foo\"))\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectSuccess(\"foo\")\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsErrorFails() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofDays(1))\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsAfterSubscriptionSucceeds() {\n+        create(Single.never())\n+                .expectCancellable(c -> { })\n+                .expectNoSignals(ofMillis(100))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenCancel() {\n+        create(succeeded(\"foo\"))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test\n+    public void thenRun() {\n+        SingleSource.Processor<String, String> processor = newSingleProcessor();\n+        create(fromSource(processor))\n+                .then(() -> processor.onSuccess(\"foo\"))\n+                .expectSuccess(\"foo\")\n+                .verify();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void thenRunThrows() {\n+        create(succeeded(\"foo\"))\n+                .then(() -> {\n+                    throw new IllegalStateException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE2ODYyNw==", "bodyText": "completed -> Single.succeeded", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538168627", "createdAt": "2020-12-08T09:19:47Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/SingleStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.SingleSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newSingleProcessor;\n+import static io.servicetalk.concurrent.api.Single.failed;\n+import static io.servicetalk.concurrent.api.Single.never;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SingleStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectCancellable() {\n+        create(succeeded(\"foo\"))\n+                .expectCancellable(Assert::assertNotNull)\n+                .expectSuccess(\"foo\")\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectCancellableTimeout() {\n+        assert executor != null;\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try {\n+            verifyException(() -> create(completed().publishAndSubscribeOn(executor))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3MTc2OQ==", "bodyText": "This is a popular pattern when users don't need to do anything with the Cancellable, consider adding expectCancellable() overload that will perform non-null check only.", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538171769", "createdAt": "2020-12-08T09:23:57Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/CompletableStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Completable.failed;\n+import static io.servicetalk.concurrent.api.Completable.never;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class CompletableStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectCancellable() {\n+        create(completed())\n+                .expectCancellable(Assert::assertNotNull)\n+                .expectComplete()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectCancellableTimeout() {\n+        assert executor != null;\n+        CountDownLatch latch = new CountDownLatch(1);\n+        try {\n+            verifyException(() -> create(completed().publishAndSubscribeOn(executor))\n+                    .expectCancellable(cancellable -> {\n+                        try {\n+                            latch.await();\n+                        } catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+                    })\n+                    .expectComplete()\n+                    .verify(ofNanos(10)));\n+        } finally {\n+            latch.countDown();\n+        }\n+    }\n+\n+    @Test\n+    public void onComplete() {\n+        assertNotNull(create(completed())\n+                .expectComplete()\n+                .verify());\n+    }\n+\n+    @Test\n+    public void onCompleteDuplicateVerify() throws InterruptedException {\n+        CountDownLatch latch = new CountDownLatch(2);\n+        StepVerifier verifier = create(completed())\n+                .expectCancellable(cancellable -> {\n+                    assertNotNull(cancellable);\n+                    latch.countDown();\n+                })\n+                .expectComplete();\n+        verifier.verify();\n+        verifier.verify();\n+        assertTrue(latch.await(10, SECONDS));\n+    }\n+\n+    @Test\n+    public void onCompleteLargeTimeout() {\n+        assertNotNull(create(completed())\n+                .expectComplete()\n+                .verify(ofDays(1)));\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void onCompleteTimeout() {\n+        verifyException(() -> create(never())\n+                .expectComplete()\n+                .verify(ofNanos(10)));\n+    }\n+\n+    @Test\n+    public void onErrorClass() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(DeliberateException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorPredicate() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> error instanceof DeliberateException)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void onErrorConsumer() {\n+        create(failed(DELIBERATE_EXCEPTION))\n+                .expectError(error -> {\n+                    assertThat(error, is(DELIBERATE_EXCEPTION));\n+                })\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnErrorWhenOnComplete() {\n+        verifyException(() -> create(completed())\n+                .expectError(DeliberateException.class)\n+                .verify());\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void expectOnSuccessWhenOnError() {\n+        verifyException(() -> create(failed(DELIBERATE_EXCEPTION))\n+                    .expectComplete()\n+                    .verify());\n+    }\n+\n+    @Test\n+    public void noSignalsSubscriptionCancelSucceeds() {\n+        // expectNoSignals and subscription event are dequeued/processed sequentially on the Subscriber thread\n+        // and the scenario isn't instructed to expect the subscription so we pass the test.\n+        create(never())\n+                .expectNoSignals(ofDays(1))\n+                .thenCancel()\n+                .verify();\n+    }\n+\n+    @Test(expected = AssertionError.class)\n+    public void noSignalsCompleteFail() {\n+        verifyException(() -> create(completed())\n+                .expectCancellable(c -> { })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3NTg0OA==", "bodyText": "This is a popular pattern when users don't need to do anything with the Subscription, consider adding expectSubscription() overload that will perform a non-null check only.", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538175848", "createdAt": "2020-12-08T09:29:30Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/PublisherStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,649 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.TestPublisher;\n+import io.servicetalk.concurrent.api.TestSubscription;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.hamcrest.Matchers;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessor;\n+import static io.servicetalk.concurrent.api.Publisher.empty;\n+import static io.servicetalk.concurrent.api.Publisher.failed;\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Publisher.never;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.singletonList;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class PublisherStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectSubscription() {\n+        create(from(\"foo\"))\n+                .expectSubscription(Assert::assertNotNull)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3NjE4OQ==", "bodyText": "This is a popular pattern when users don't need to do anything with the Cancellable, consider adding expectCancellable() overload that will perform a non-null check only.", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538176189", "createdAt": "2020-12-08T09:29:56Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/SingleStepVerifierTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.SingleSource;\n+import io.servicetalk.concurrent.api.AsyncContext;\n+import io.servicetalk.concurrent.api.AsyncContextMap;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Executors;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Supplier;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newSingleProcessor;\n+import static io.servicetalk.concurrent.api.Single.failed;\n+import static io.servicetalk.concurrent.api.Single.never;\n+import static io.servicetalk.concurrent.api.Single.succeeded;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.test.StepVerifiers.create;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.time.Duration.ofDays;\n+import static java.time.Duration.ofMillis;\n+import static java.time.Duration.ofNanos;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+\n+public class SingleStepVerifierTest {\n+    private static final AsyncContextMap.Key<Integer> ASYNC_KEY = AsyncContextMap.Key.newKey();\n+    @Nullable\n+    private static Executor executor;\n+\n+    @BeforeClass\n+    public static void beforeClass() {\n+        executor = Executors.newCachedThreadExecutor();\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() throws ExecutionException, InterruptedException {\n+        if (executor != null) {\n+            executor.closeAsync().toFuture().get();\n+        }\n+    }\n+\n+    @Test\n+    public void expectCancellable() {\n+        create(succeeded(\"foo\"))\n+                .expectCancellable(Assert::assertNotNull)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE3OTMxNQ==", "bodyText": "Consider adding expectError() overload that will expect any error for Completable, Publisher, and Single last step.", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538179315", "createdAt": "2020-12-08T09:34:24Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/CompletableLastStep.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.CompletableSource.Subscriber;\n+\n+import java.time.Duration;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Provides the ability to express expectations for the terminal signals (e.g.\n+ * {@link Subscriber#onComplete() onComplete} or {@link Subscriber#onError(Throwable) onError}) of a {@link Subscriber}.\n+ */\n+public interface CompletableLastStep {\n+    /**\n+     * Expect no signals in {@code duration} time.\n+     * @param duration The amount of time to assert that no signals are received.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    CompletableLastStep expectNoSignals(Duration duration);\n+\n+    /**\n+     * Declare an expectation that {@link Subscriber#onError(Throwable) onError} will be the next signal and evaluate it\n+     * with {@code errorPredicate}.\n+     * @param errorPredicate Will be invoked when {@link Subscriber#onError(Throwable) onError} is called and will raise\n+     * a {@link AssertionError} if the predicate returns {@code false}.\n+     * @return An object which allows to verify all expectations.\n+     */\n+    StepVerifier expectError(Predicate<Throwable> errorPredicate);\n+\n+    /**\n+     * Declare an expectation that {@link Subscriber#onError(Throwable) onError} will be the next signal and it will be\n+     * of type {@code errorClass}.\n+     * @param errorClass The type of error which is expected.\n+     * @return An object which allows to verify all expectations.\n+     */\n+    StepVerifier expectError(Class<? extends Throwable> errorClass);\n+\n+    /**\n+     * Declare an expectation that {@link Subscriber#onError(Throwable) onError} will be the next signal and evaluate it\n+     * with {@code errorConsumer}.\n+     * @param errorConsumer Will be invoked when {@link Subscriber#onError(Throwable) onError} is called.\n+     * @return An object which allows to verify all expectations.\n+     */\n+    StepVerifier expectError(Consumer<Throwable> errorConsumer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE4NDgzMg==", "bodyText": "Consider adding expectNext(Predicate) overload to be consistent with expectError(Predicate)", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538184832", "createdAt": "2020-12-08T09:41:52Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/PublisherStep.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.function.Consumer;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provides the ability to express expectations for the {@link Subscriber#onNext(Object)} stages of a\n+ * {@link Subscriber Subscriber}'s lifecycle.\n+ * @param <T> The type of {@link Subscriber}.\n+ */\n+public interface PublisherStep<T> extends PublisherLastStep {\n+    /**\n+     * Declare an expectation that {@code signal} will be the next {@link Subscriber#onNext(Object) signal}.\n+     * @param signal The next signal which is expected.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(@Nullable T signal);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    PublisherStep<T> expectNext(T... signals);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Iterable<? extends T> signals);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Collection<? extends T> signals);\n+\n+    /**\n+     * Declare an expectation that can be asserted when the {@link Subscriber#onNext(Object) onNext} method is invoked.\n+     * @param signalConsumer Consumes the next {@link Subscriber#onNext(Object) onNext} signal.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Consumer<? super T> signalConsumer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE4ODQwOA==", "bodyText": "All collections are Iterable. Do we need an additional overload for Collection?", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538188408", "createdAt": "2020-12-08T09:46:11Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/PublisherStep.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.function.Consumer;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provides the ability to express expectations for the {@link Subscriber#onNext(Object)} stages of a\n+ * {@link Subscriber Subscriber}'s lifecycle.\n+ * @param <T> The type of {@link Subscriber}.\n+ */\n+public interface PublisherStep<T> extends PublisherLastStep {\n+    /**\n+     * Declare an expectation that {@code signal} will be the next {@link Subscriber#onNext(Object) signal}.\n+     * @param signal The next signal which is expected.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(@Nullable T signal);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    PublisherStep<T> expectNext(T... signals);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Iterable<? extends T> signals);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Collection<? extends T> signals);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE4OTUxMw==", "bodyText": "requestN takes long, we should allow n in long range here.", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538189513", "createdAt": "2020-12-08T09:47:38Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/PublisherStep.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.function.Consumer;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provides the ability to express expectations for the {@link Subscriber#onNext(Object)} stages of a\n+ * {@link Subscriber Subscriber}'s lifecycle.\n+ * @param <T> The type of {@link Subscriber}.\n+ */\n+public interface PublisherStep<T> extends PublisherLastStep {\n+    /**\n+     * Declare an expectation that {@code signal} will be the next {@link Subscriber#onNext(Object) signal}.\n+     * @param signal The next signal which is expected.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(@Nullable T signal);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    PublisherStep<T> expectNext(T... signals);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Iterable<? extends T> signals);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Collection<? extends T> signals);\n+\n+    /**\n+     * Declare an expectation that can be asserted when the {@link Subscriber#onNext(Object) onNext} method is invoked.\n+     * @param signalConsumer Consumes the next {@link Subscriber#onNext(Object) onNext} signal.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Consumer<? super T> signalConsumer);\n+\n+    /**\n+     * Expect {@code n} {@link Subscriber#onNext(Object) onNext} signals, and assert their values via\n+     * {@code signalsConsumer}.\n+     * @param n The number of {@link Subscriber#onNext(Object) onNext} signals that are expected.\n+     * @param signalsConsumer A {@link Consumer} that accepts an {@link Collection} which has {@code n} items.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(int n, Consumer<? super Collection<? extends T>> signalsConsumer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE4OTczMA==", "bodyText": "Consider using long instead of int", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538189730", "createdAt": "2020-12-08T09:47:58Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/PublisherStep.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.PublisherSource.Subscription;\n+\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.function.Consumer;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provides the ability to express expectations for the {@link Subscriber#onNext(Object)} stages of a\n+ * {@link Subscriber Subscriber}'s lifecycle.\n+ * @param <T> The type of {@link Subscriber}.\n+ */\n+public interface PublisherStep<T> extends PublisherLastStep {\n+    /**\n+     * Declare an expectation that {@code signal} will be the next {@link Subscriber#onNext(Object) signal}.\n+     * @param signal The next signal which is expected.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(@Nullable T signal);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    PublisherStep<T> expectNext(T... signals);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Iterable<? extends T> signals);\n+\n+    /**\n+     * Declare an expectation that {@code signals} will be the next in-order sequence of\n+     * {@link Subscriber#onNext(Object) signals}.\n+     * @param signals The next signals which are expected in-order.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Collection<? extends T> signals);\n+\n+    /**\n+     * Declare an expectation that can be asserted when the {@link Subscriber#onNext(Object) onNext} method is invoked.\n+     * @param signalConsumer Consumes the next {@link Subscriber#onNext(Object) onNext} signal.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(Consumer<? super T> signalConsumer);\n+\n+    /**\n+     * Expect {@code n} {@link Subscriber#onNext(Object) onNext} signals, and assert their values via\n+     * {@code signalsConsumer}.\n+     * @param n The number of {@link Subscriber#onNext(Object) onNext} signals that are expected.\n+     * @param signalsConsumer A {@link Consumer} that accepts an {@link Collection} which has {@code n} items.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(int n, Consumer<? super Collection<? extends T>> signalsConsumer);\n+\n+    /**\n+     * Expect between {@code [min, max]} {@link Subscriber#onNext(Object) onNext} signals, and assert their values via\n+     * {@code signalsConsumer}.\n+     * @param min The minimum number of {@link Subscriber#onNext(Object) onNext} signals that are required before\n+     * invoking {@code signalsConsumer}. If a terminal signal is processed and the number of accumulated\n+     * {@link Subscriber#onNext(Object) onNext} signals is {@code >=} this value the {@code signalsConsumer} will be\n+     * invoked for verification, otherwise the expectation will fail.\n+     * @param max The maximum number of {@link Subscriber#onNext(Object) onNext} signals that will be accumulated\n+     * before invoking {@code signalsConsumer}.\n+     * @param signalsConsumer A {@link Consumer} that accepts an {@link Collection} which has between\n+     * {@code [min, max]} items and preforms verification.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    PublisherStep<T> expectNext(int min, int max, Consumer<? super Collection<? extends T>> signalsConsumer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE5MDg5Mg==", "bodyText": "Consider adding expectSuccess(Predicate) for consistency with expectError(Predicate)", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538190892", "createdAt": "2020-12-08T09:49:33Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/SingleLastStep.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.SingleSource.Subscriber;\n+\n+import java.time.Duration;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Provides the ability to express expectations for the terminal signals (e.g.\n+ * {@link Subscriber#onSuccess(Object) onSuccess} or {@link Subscriber#onError(Throwable) onError}) of a\n+ * {@link Subscriber}.\n+ * @param <T> The type of {@link Subscriber}.\n+ */\n+public interface SingleLastStep<T> {\n+    /**\n+     * Expect no signals in {@code duration} time.\n+     * @param duration The amount of time to assert that no signals are received.\n+     * @return An object which allows for subsequent expectations to be defined.\n+     */\n+    SingleLastStep<T> expectNoSignals(Duration duration);\n+\n+    /**\n+     * Declare an expectation that {@link Subscriber#onError(Throwable) onError} will be the next signal and evaluate it\n+     * with {@code errorPredicate}.\n+     * @param errorPredicate Will be invoked when {@link Subscriber#onError(Throwable) onError} is called and will raise\n+     * a {@link AssertionError} if the predicate returns {@code false}.\n+     * @return An object which allows to verify all expectations.\n+     */\n+    StepVerifier expectError(Predicate<Throwable> errorPredicate);\n+\n+    /**\n+     * Declare an expectation that {@link Subscriber#onError(Throwable) onError} will be the next signal and it will be\n+     * of type {@code errorClass}.\n+     * @param errorClass The type of error which is expected.\n+     * @return An object which allows to verify all expectations.\n+     */\n+    StepVerifier expectError(Class<? extends Throwable> errorClass);\n+\n+    /**\n+     * Declare an expectation that {@link Subscriber#onError(Throwable) onError} will be the next signal and evaluate it\n+     * with {@code errorConsumer}.\n+     * @param errorConsumer Will be invoked when {@link Subscriber#onError(Throwable) onError} is called.\n+     * @return An object which allows to verify all expectations.\n+     */\n+    StepVerifier expectError(Consumer<Throwable> errorConsumer);\n+\n+    /**\n+     * Declare an expectation that {@link Subscriber#onSuccess(Object) onSuccess} will be the next signal.\n+     * @param onSuccess The expected value of {@link Subscriber#onSuccess(Object) onSuccess}.\n+     * @return An object which allows to verify all expectations.\n+     */\n+    StepVerifier expectSuccess(@Nullable T onSuccess);\n+\n+    /**\n+     * Declare an expectation that {@link Subscriber#onSuccess(Object) onSuccess} will be the next signal and verify it\n+     * with {@code onSuccessConsumer}.\n+     * @param onSuccessConsumer Used to verify {@link Subscriber#onSuccess(Object) onSuccess}.\n+     * @return An object which allows to verify all expectations.\n+     */\n+    StepVerifier expectSuccess(Consumer<? super T> onSuccessConsumer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE5NjgzMA==", "bodyText": "This can overflow if one of them is negative", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538196830", "createdAt": "2020-12-08T09:57:30Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/TimeSource.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.TimeUnit;\n+\n+import static io.servicetalk.concurrent.api.test.TimeUtils.convert;\n+import static io.servicetalk.concurrent.api.test.TimeUtils.toChronoUnit;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+/**\n+ * A time source. This time source can be used to determine when a specific duration of time has passed. This process\n+ * requires saving a start time, and then using a fixed expiration duration:\n+ *\n+ * <pre>\n+ * TimeSource timeSource = timeSource();\n+ * long startTime = timeSource.get();\n+ * doWork();\n+ * boolean expired = timeSource.isExpired(startTime, 100, NANOSECONDS);\n+ * &#47;&#47; If expired is true then at least 100 nanoseconds have passed since startTime\n+ * </pre>\n+ */\n+@FunctionalInterface\n+interface TimeSource {\n+    /**\n+     * Get the current time. The units are determined by {@link #currentTimeUnits()}.\n+     * @return The current time. The units are determined by {@link #currentTimeUnits()}.\n+     */\n+    long currentTime();\n+\n+    /**\n+     * Get the units for {@link #currentTime()}.\n+     * @return The units for {@link #currentTime()}.\n+     */\n+    default TimeUnit currentTimeUnits() {\n+        return NANOSECONDS;\n+    }\n+\n+    /**\n+     * Determine if at least {@code duration} ticks have passed since {@code startTime} time.\n+     *\n+     * @param startTime a past value of {@link #currentTime()} which represents the start time stamp.\n+     * @param duration How much time is permitted to pass before {@code startTime} is considered\n+     * expired. Must be {@code >= 0}.\n+     * @param durationUnit The units for {@code duration}.\n+     * @return {@code true} if at least {@code duration} ticks have passed since {@code startTime} time.\n+     */\n+    default boolean isExpired(long startTime, long duration, TimeUnit durationUnit) {\n+        assert duration >= 0;\n+        return currentTime() - startTime >= currentTimeUnits().convert(duration, durationUnit);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE5ODQzMg==", "bodyText": "It looks more like IllegalArgumentException, not an assertion", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r538198432", "createdAt": "2020-12-08T09:59:40Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/TimeSource.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.TimeUnit;\n+\n+import static io.servicetalk.concurrent.api.test.TimeUtils.convert;\n+import static io.servicetalk.concurrent.api.test.TimeUtils.toChronoUnit;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+/**\n+ * A time source. This time source can be used to determine when a specific duration of time has passed. This process\n+ * requires saving a start time, and then using a fixed expiration duration:\n+ *\n+ * <pre>\n+ * TimeSource timeSource = timeSource();\n+ * long startTime = timeSource.get();\n+ * doWork();\n+ * boolean expired = timeSource.isExpired(startTime, 100, NANOSECONDS);\n+ * &#47;&#47; If expired is true then at least 100 nanoseconds have passed since startTime\n+ * </pre>\n+ */\n+@FunctionalInterface\n+interface TimeSource {\n+    /**\n+     * Get the current time. The units are determined by {@link #currentTimeUnits()}.\n+     * @return The current time. The units are determined by {@link #currentTimeUnits()}.\n+     */\n+    long currentTime();\n+\n+    /**\n+     * Get the units for {@link #currentTime()}.\n+     * @return The units for {@link #currentTime()}.\n+     */\n+    default TimeUnit currentTimeUnits() {\n+        return NANOSECONDS;\n+    }\n+\n+    /**\n+     * Determine if at least {@code duration} ticks have passed since {@code startTime} time.\n+     *\n+     * @param startTime a past value of {@link #currentTime()} which represents the start time stamp.\n+     * @param duration How much time is permitted to pass before {@code startTime} is considered\n+     * expired. Must be {@code >= 0}.\n+     * @param durationUnit The units for {@code duration}.\n+     * @return {@code true} if at least {@code duration} ticks have passed since {@code startTime} time.\n+     */\n+    default boolean isExpired(long startTime, long duration, TimeUnit durationUnit) {\n+        assert duration >= 0;\n+        return currentTime() - startTime >= currentTimeUnits().convert(duration, durationUnit);\n+    }\n+\n+    /**\n+     * Determine if at least {@code expireDuration} ticks have passed since {@code startTime} time.\n+     *\n+     * @param startTime a past value of {@link #currentTime()} which represents the start time stamp.\n+     * @param duration How much time is permitted to pass before {@code startTime} is considered\n+     * expired. Must be {@code >= 0}.\n+     * @return {@code true} if at least {@code expireDuration} ticks have passed since {@code startTime} time.\n+     */\n+    default boolean isExpired(long startTime, Duration duration) {\n+        assert !duration.isNegative();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64421feb99b329e2f9ab2407d114d477dac2b924"}, "originalPosition": 76}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "974574af84fe2ce756aa3fac922c83ce8c4f23dd", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/974574af84fe2ce756aa3fac922c83ce8c4f23dd", "committedDate": "2020-12-08T18:24:54Z", "message": "add null check and use import"}, "afterCommit": {"oid": "8773e41b4568f45b8e08b42655a0aea35a24041f", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/8773e41b4568f45b8e08b42655a0aea35a24041f", "committedDate": "2020-12-11T21:44:36Z", "message": "review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75148784ffc0546f70ed33b8f27ae58b58721581", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/75148784ffc0546f70ed33b8f27ae58b58721581", "committedDate": "2020-12-14T21:07:22Z", "message": "Add concurrent-api-test module\n\nMotivation:\nThere is currently a servicetalk-concurrent-test-internal module for low\nlevel testing of concurrent utilities. However there is no user facing\ntesting utility for dealing with concurrent-api primitives.\n\nModifications:\n- Introduce the concurrent-api-test module which has the StepVerifiers\nentry point. There are 3 entry points one for each async source type:\n  - PublisherFirstStep\n  - SingleFirstStep\n  - CompletableFirstStep\n\nEach of these APIs exposes a sequence of further APIs which represents\nthe expected signal flow of each respective source (e.g. onSubscribe,\nonNext*, [onComplete | onError]?). This approach is inspired by\n[reactor-test](https://projectreactor.io/docs/core/release/reference/index.html#testing).\n\nResult:\nUser facing test utilities exist for concurrent-api."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "694902972f89eb14d7373ba2e60efaf31c765757", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/694902972f89eb14d7373ba2e60efaf31c765757", "committedDate": "2020-12-14T21:07:22Z", "message": "remove state from events to avoid copying the queue, use a List and an index to track current location in each test execution, enhance tests to verify multiple subscription events."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d657eecb13bf3de68b0e0d296407dfbeadbc219e", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/d657eecb13bf3de68b0e0d296407dfbeadbc219e", "committedDate": "2020-12-14T21:07:22Z", "message": "init state for OnNextAggregateEvent upfront"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71a812b09b80d1a842658486021b4a26bda3614e", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/71a812b09b80d1a842658486021b4a26bda3614e", "committedDate": "2020-12-14T21:07:22Z", "message": "allow empty aggregate event"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8623287e7dbbe72c703a641ff59f5dd2937cdfd", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/c8623287e7dbbe72c703a641ff59f5dd2937cdfd", "committedDate": "2020-12-14T21:07:22Z", "message": "add null check and use import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fc5d3f871c52ba49bd1624fc87e7113b5c03660", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/0fc5d3f871c52ba49bd1624fc87e7113b5c03660", "committedDate": "2020-12-14T21:07:22Z", "message": "review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c55e1a13a5a4ab00c6e218fd0922bc4b761a81f2", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/c55e1a13a5a4ab00c6e218fd0922bc4b761a81f2", "committedDate": "2020-12-14T21:07:22Z", "message": "clarify TimeSource methods need monotonic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ae27a2a22eb7e8750a898538412542014eb8743", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/8ae27a2a22eb7e8750a898538412542014eb8743", "committedDate": "2020-12-14T21:07:22Z", "message": "add expectSubscription() method, clarify TimeSource limitations"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1a25efce231cf1191c59b9e02b08bc1dd8d0ba91", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/1a25efce231cf1191c59b9e02b08bc1dd8d0ba91", "committedDate": "2020-12-11T22:46:40Z", "message": "add expectSubscription() method, clarify TimeSource limitations"}, "afterCommit": {"oid": "8ae27a2a22eb7e8750a898538412542014eb8743", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/8ae27a2a22eb7e8750a898538412542014eb8743", "committedDate": "2020-12-14T21:07:22Z", "message": "add expectSubscription() method, clarify TimeSource limitations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86e10ac28dd08988be5d2c828165df73d98bffc1", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/86e10ac28dd08988be5d2c828165df73d98bffc1", "committedDate": "2020-12-15T04:24:31Z", "message": "revert concurrent-api dependency due to intellij issue https://youtrack.jetbrains.com/issue/IDEA-159568"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd3924e6516f128c4bf09afbdef8781f66cace2e", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/dd3924e6516f128c4bf09afbdef8781f66cace2e", "committedDate": "2020-12-15T04:35:21Z", "message": "Use ExecutorRule"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfd4e6954aad874ecd690942bdc6736f097c7218", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/dfd4e6954aad874ecd690942bdc6736f097c7218", "committedDate": "2020-12-15T19:05:53Z", "message": "update TimeSource methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyODE0NzU1", "url": "https://github.com/apple/servicetalk/pull/1240#pullrequestreview-552814755", "createdAt": "2020-12-15T19:50:57Z", "commit": {"oid": "dfd4e6954aad874ecd690942bdc6736f097c7218"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxOTo1MDo1N1rOIGdNwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMDowNTowOVrOIGdxOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY0MTAyNA==", "bodyText": "We discussed offline that isExpired methods should return true if diff between start and current time is more than Long.MAX_VALUE.", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r543641024", "createdAt": "2020-12-15T19:50:57Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/TimeSource.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import java.time.Duration;\n+import java.util.concurrent.TimeUnit;\n+\n+import static io.servicetalk.concurrent.api.test.TimeUtils.convert;\n+import static io.servicetalk.concurrent.api.test.TimeUtils.toChronoUnit;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+/**\n+ * A source of time that can be represented as a {@code long}.\n+ * <p>\n+ * If the underlying time source is monotonic, utility methods are provided to determine if specific duration of time\n+ * has elapsed (aka expired). This process requires saving a start time, and then using a fixed expiration duration:\n+ *\n+ * <pre>\n+ * TimeSource timeSource = timeSource();\n+ * long startTime = timeSource.get();\n+ * doWork();\n+ * boolean expired = timeSource.isExpired(startTime, 100, NANOSECONDS);\n+ * &#47;&#47; If expired is true then at least 100 nanoseconds have passed since startTime\n+ * </pre>\n+ */\n+@FunctionalInterface\n+interface TimeSource {\n+    /**\n+     * Get the current time. The units are determined by {@link #currentTimeUnits()}.\n+     * @return The current time. The units are determined by {@link #currentTimeUnits()}.\n+     */\n+    long currentTime();\n+\n+    /**\n+     * Get the units for {@link #currentTime()}.\n+     * @return The units for {@link #currentTime()}.\n+     */\n+    default TimeUnit currentTimeUnits() {\n+        return NANOSECONDS;\n+    }\n+\n+    /**\n+     * Determine if at least {@code duration} ticks have passed since {@code startTime} time.\n+     * <p>\n+     * If this {@link TimeSource} is not monotonic, and time goes \"backwards\" the behavior of this method is undefined.\n+     * <p>\n+     * Differences between {@code startTime} and {@link #currentTime()} that span greater than 2<sup>63</sup> (~292\n+     * years if {@link #currentTimeUnits()} is {@link TimeUnit#NANOSECONDS}) will not correctly compute elapsed time due\n+     * to numerical overflow.\n+     * @param startTime a past value of {@link #currentTime()} which represents the start time stamp.\n+     * @param duration How much time is permitted to pass before {@code startTime} is considered\n+     * expired. Units are {@link #currentTime()}.\n+     * @return {@code true} if at least {@code duration} ticks have passed since {@code startTime} time.\n+     */\n+    default boolean isExpired(long startTime, long duration) {\n+        return currentTime() - startTime >= duration;\n+    }\n+\n+    /**\n+     * Determine if at least {@code duration} ticks have passed since {@code startTime} time.\n+     * <p>\n+     * If this {@link TimeSource} is not monotonic, and time goes \"backwards\" the behavior of this method is undefined.\n+     * <p>\n+     * Differences between {@code startTime} and {@link #currentTime()} that span greater than 2<sup>63</sup> (~292\n+     * years if {@link #currentTimeUnits()} is {@link TimeUnit#NANOSECONDS}) will not correctly compute elapsed time due\n+     * to numerical overflow.\n+     * @param startTime a past value of {@link #currentTime()} which represents the start time stamp.\n+     * @param duration How much time is permitted to pass before {@code startTime} is considered\n+     * expired.\n+     * @param durationUnit The units for {@code duration}.\n+     * @return {@code true} if at least {@code duration} ticks have passed since {@code startTime} time.\n+     */\n+    default boolean isExpired(long startTime, long duration, TimeUnit durationUnit) {\n+        return currentTime() - startTime >= currentTimeUnits().convert(duration, durationUnit);\n+    }\n+\n+    /**\n+     * Determine if at least {@code expireDuration} ticks have passed since {@code startTime} time.\n+     * <p>\n+     * If this {@link TimeSource} is not monotonic, and time goes \"backwards\" the behavior of this method is undefined.\n+     * <p>\n+     * Differences between {@code startTime} and {@link #currentTime()} that span greater than 2<sup>63</sup> (~292\n+     * years if {@link #currentTimeUnits()} is {@link TimeUnit#NANOSECONDS}) will not correctly compute elapsed time due\n+     * to numerical overflow.\n+     * @param startTime a past value of {@link #currentTime()} which represents the start time stamp.\n+     * @param duration How much time is permitted to pass before {@code startTime} is considered\n+     * expired.\n+     * @return {@code true} if at least {@code expireDuration} ticks have passed since {@code startTime} time.\n+     */\n+    default boolean isExpired(long startTime, Duration duration) {\n+        return currentTime() - startTime >= convert(currentTimeUnits(), duration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfd4e6954aad874ecd690942bdc6736f097c7218"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY1MDEwNA==", "bodyText": "IMHO, FirstSteps is harder to discover compare to previous StepVerifiers factory. Not clear what the FirstSteps should be used for. StepVerifiers terminology is likely more familiar for users.", "url": "https://github.com/apple/servicetalk/pull/1240#discussion_r543650104", "createdAt": "2020-12-15T20:05:09Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/FirstSteps.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.api.test.TimeSources.nanoTimeNormalized;\n+\n+/**\n+ * Create new test utilities to verify each step in the lifecycle of a {@link Publisher}, {@link Single},\n+ * and {@link Completable}. The steps are typically from the perspective of a {@link Subscriber}'s lifecycle.\n+ */\n+public final class FirstSteps {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfd4e6954aad874ecd690942bdc6736f097c7218"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1bae5ca642eab1bc5ab4f3d8466e400fd69f38ce", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/1bae5ca642eab1bc5ab4f3d8466e400fd69f38ce", "committedDate": "2020-12-16T00:51:37Z", "message": "update time source methods"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3366, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}