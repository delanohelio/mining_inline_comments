{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyMzkwOTYy", "number": 919, "title": "Protocol emits payload boundary event", "bodyText": "Motivation\nWriteStreamSubscriber is not aware of payload boundaries, hence when a Channel becomes suddenly inactive (closed or output shutdown) it could only assume the write failed. In case of H2 the codec would perfom an output shutdown after observing and emitting trailers. This output shutdown would race with write publisher completion and occasionally result in WriteStreamSubscriber failing the write with an error even though it actually completed normally.\nModifications\n\nH1/H2 codecs emit payload boundaries via CloseHandler\nCloseHandler triggers a new UserEvent on outbound payload end\nDefaultNettyConnection intercepts above event and notifies WriteListener (WriteStreamSubscriber)\nWriteStreamSubscriber responds to 2 triggers for write source stream completion\n\nResult\nWrites no longer fail due to race between closure of write publisher and H2 end of stream", "createdAt": "2020-01-14T00:44:18Z", "url": "https://github.com/apple/servicetalk/pull/919", "merged": true, "mergeCommit": {"oid": "781dbef3e05330108342d9b5f3a5e67b84da2828"}, "closed": true, "closedAt": "2020-01-15T21:20:36Z", "author": {"login": "jayv"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6F0wQgH2gAyMzYyMzkwOTYyOjQ5MGFhY2UxZTFhZDc2ODJhMTY1NDI3Y2ZlODAzMGU2NjZmMDg2Zjk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb6rzFRgH2gAyMzYyMzkwOTYyOjc4NTBkMTJjODMxZjU4NzFhY2VkYTZjYTAxYjFmYjYwMDJiMGIxODc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "490aace1e1ad7682a165427cfe8030e666f086f9", "author": {"user": {"login": "jayv", "name": "Jo Voordeckers"}}, "url": "https://github.com/apple/servicetalk/commit/490aace1e1ad7682a165427cfe8030e666f086f9", "committedDate": "2020-01-14T00:29:41Z", "message": "Protocol emits payload boundary event\n\n__Motivation__\n\nWriteStreamSubscriber is not aware of payload boundaries, hence when a Channel becomes suddenly inactive (closed or output shutdown) it could only assume the write failed. In case of H2 the codec would perfom an output shutdown after observing and emitting trailers. This output shutdown would race with write publisher completion and occasionally result in WriteStreamSubscriber failing the write with an error even though it actually completed normally.\n\n__Modifications__\n\n- H1/H2 codecs emit payload boundaries via CloseHandler\n- CloseHandler triggers a new UserEvent on outbound payload end\n- DefaultNettyConnection intercepts above event and notifies WriteListener (WriteStreamSubscriber)\n- WriteStreamSubscriber responds to 2 triggers for write source stream completion\n\n__Result__\n\nWrites no longer fail due to race between closure of write publisher and H2 end of stream"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNzg2NzQ3", "url": "https://github.com/apple/servicetalk/pull/919#pullrequestreview-342786747", "createdAt": "2020-01-14T19:34:57Z", "commit": {"oid": "490aace1e1ad7682a165427cfe8030e666f086f9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxOTozNDo1N1rOFdjYmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMTozNTo0M1rOFdmi-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUzMjc2Mg==", "bodyText": "I am trying to understand the implications of having this isCient check here.\nIt seems like we are pushing the design decision of doing one write per request (as opposed to doing batch writes of multiple requests) on the client side down to the close handler implementation. IIUC, this close handler did not assume that till now, what is the reason to introduce this assumption now?", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366532762", "createdAt": "2020-01-14T19:34:57Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -163,6 +163,13 @@ public void protocolPayloadBeginOutbound(final ChannelHandlerContext ctx) {\n \n     @Override\n     public void protocolPayloadEndOutbound(final ChannelHandlerContext ctx) {\n+        if (isClient || has(state, CLOSING)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "490aace1e1ad7682a165427cfe8030e666f086f9"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2MDEwMg==", "bodyText": "At some point we were discussing removing the inconsistency between channelClosedOutbound() and channelClosed() implementations in WriteStreamSubscriber. Do you intend to do it in a follow up PR?", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366560102", "createdAt": "2020-01-14T20:37:51Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -189,6 +189,11 @@ public void channelWritable() {\n         requestMoreIfRequired(subscription);\n     }\n \n+    @Override\n+    public void protocolPayloadComplete() {\n+        onComplete();\n+    }\n+\n     @Override\n     public void channelClosedOutbound() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "490aace1e1ad7682a165427cfe8030e666f086f9"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2MTAwOA==", "bodyText": "This method is expected to be called from the eventloop, so we can add an assert to verify that and directly call promise.sourceTerminated(null)", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366561008", "createdAt": "2020-01-14T20:39:53Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -189,6 +189,11 @@ public void channelWritable() {\n         requestMoreIfRequired(subscription);\n     }\n \n+    @Override\n+    public void protocolPayloadComplete() {\n+        onComplete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "490aace1e1ad7682a165427cfe8030e666f086f9"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2NDgzMw==", "bodyText": "Logically, it looks like we should error out here if we have not seen onSuccess()/onError().\nIs the noop implementation here because in practice we never write Single?", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366564833", "createdAt": "2020-01-14T20:48:47Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java", "diffHunk": "@@ -73,6 +73,11 @@ public void channelWritable() {\n         // No op.\n     }\n \n+    @Override\n+    public void protocolPayloadComplete() {\n+        // No op.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "490aace1e1ad7682a165427cfe8030e666f086f9"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2NzQyOA==", "bodyText": "Since we are synthetically generating an onComplete() we should now verify that we do not write any data after onComplete() is called.", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366567428", "createdAt": "2020-01-14T20:54:59Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -189,6 +189,11 @@ public void channelWritable() {\n         requestMoreIfRequired(subscription);\n     }\n \n+    @Override\n+    public void protocolPayloadComplete() {\n+        onComplete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "490aace1e1ad7682a165427cfe8030e666f086f9"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU2OTk3Mg==", "bodyText": "I think we can leverage pre-existing concepts here instead of introducing protcol and payload knowledge inside WritableListener. What we are after here is essentially \"graceful closure\" which in this case means wait for enqueued writes to finish before closing the listener.\nI would suggest renaming this method to closeGracefully() and renaming existing channelClosed(Throwable) to close(Throwable) so that we clearly can define behaviors for abrupt and graceful closures without introducing the \"protocol concept\" here. If you get around unifying channelClosedOutbound() and channelClosed() as mentioned above then we can also remove channelClosedOutbound().", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366569972", "createdAt": "2020-01-14T21:01:01Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -459,6 +459,21 @@ public FlushStrategy defaultFlushStrategy() {\n          */\n         void channelWritable();\n \n+        /**\n+         * Notifies the end of payload was observed at the transport (not necessarily flushed).\n+         *\n+         * <p>\n+         * This helps coordinate state between the writer and the codec/transport. Even if the writing source may not\n+         * have completed from a Reactive Streams perspective, it means that as far as the codec and transport is\n+         * concerned it considers the write is complete and no further writes can happen. Closing of the transport after\n+         * receiving this event should not be considered a write error since the final buffer was written and\n+         * potentially flushed. A failed write promise after observing this event however indicates the end of payload\n+         * marker may not have been written correctly and should result in an error.\n+         * <p>\n+         * This is event is expected be called from the eventloop.\n+         */\n+        void protocolPayloadComplete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "490aace1e1ad7682a165427cfe8030e666f086f9"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3Mzc2Nw==", "bodyText": "I would avoid adding supposedly protocol specific logic like this to UnsupportedProtocolHandler. IIUC, this is to support H2 so lets create a CloseHandler implementation for H2 and for now we can simply implement this method.", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366573767", "createdAt": "2020-01-14T21:10:21Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CloseHandler.java", "diffHunk": "@@ -260,6 +267,11 @@ public void protocolPayloadBeginOutbound(final ChannelHandlerContext ctx) {\n \n         @Override\n         public void protocolPayloadEndOutbound(final ChannelHandlerContext ctx) {\n+            ctx.pipeline().fireUserEventTriggered(ProtocolPayloadEndEvent.OUTBOUND);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "490aace1e1ad7682a165427cfe8030e666f086f9"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3NDQ3NQ==", "bodyText": "Can you explain the motivation for this change?\nProtocolPayloadEndEvent.OUTBOUND is for write but the comment here suggests it is due to \"repeated reads\".\nIn case you end up removing this change, we can make  the class ProtocolPayloadEndEvent package-private.", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366574475", "createdAt": "2020-01-14T21:12:07Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/FlushStrategyOnServerTest.java", "diffHunk": "@@ -112,19 +125,36 @@ public void flush(final ChannelHandlerContext ctx) {\n             return succeeded(resp);\n         };\n         DefaultHttpExecutionContext httpExecutionContext =\n-                new DefaultHttpExecutionContext(DEFAULT_ALLOCATOR, ioExecutor, executor, executionStrategy);\n-        ReadOnlyHttpServerConfig config = new HttpServerConfig().asReadOnly();\n+                new DefaultHttpExecutionContext(DEFAULT_ALLOCATOR, ioExecutor, executor, param.executionStrategy);\n+\n+        final ReadOnlyHttpServerConfig config = new HttpServerConfig().asReadOnly();\n         serverConnection = initChannel(channel, httpExecutionContext, config,\n-                new TcpServerChannelInitializer(config.tcpConfig()), service, true,\n+                new TcpServerChannelInitializer(config.tcpConfig()) {\n+                    @Override\n+                    public void init(final Channel channel) {\n+                        super.init(channel);\n+                        channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n+                            @Override\n+                            public void userEventTriggered(final ChannelHandlerContext ctx,\n+                                                           final Object evt) throws Exception {\n+                                if (evt == CloseHandler.ProtocolPayloadEndEvent.OUTBOUND) {\n+                                    // Mute payload boundary events for this test with repeated read", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "490aace1e1ad7682a165427cfe8030e666f086f9"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU3NjA5Ng==", "bodyText": "Is the use of enum here just a personal choice or there is a difference between the two approaches?", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366576096", "createdAt": "2020-01-14T21:16:10Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/FlushStrategyOnServerTest.java", "diffHunk": "@@ -112,19 +125,36 @@ public void flush(final ChannelHandlerContext ctx) {\n             return succeeded(resp);\n         };\n         DefaultHttpExecutionContext httpExecutionContext =\n-                new DefaultHttpExecutionContext(DEFAULT_ALLOCATOR, ioExecutor, executor, executionStrategy);\n-        ReadOnlyHttpServerConfig config = new HttpServerConfig().asReadOnly();\n+                new DefaultHttpExecutionContext(DEFAULT_ALLOCATOR, ioExecutor, executor, param.executionStrategy);\n+\n+        final ReadOnlyHttpServerConfig config = new HttpServerConfig().asReadOnly();\n         serverConnection = initChannel(channel, httpExecutionContext, config,\n-                new TcpServerChannelInitializer(config.tcpConfig()), service, true,\n+                new TcpServerChannelInitializer(config.tcpConfig()) {\n+                    @Override\n+                    public void init(final Channel channel) {\n+                        super.init(channel);\n+                        channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n+                            @Override\n+                            public void userEventTriggered(final ChannelHandlerContext ctx,\n+                                                           final Object evt) throws Exception {\n+                                if (evt == CloseHandler.ProtocolPayloadEndEvent.OUTBOUND) {\n+                                    // Mute payload boundary events for this test with repeated read\n+                                    return;\n+                                }\n+                                super.userEventTriggered(ctx, evt);\n+                            }\n+                        });\n+                    }\n+                }, service, true,\n                 UNSUPPORTED_PROTOCOL_CLOSE_HANDLER)\n                 .toFuture().get();\n         serverConnection.process(true);\n         headersFactory = DefaultHttpHeadersFactory.INSTANCE;\n     }\n \n     @Parameters(name = \"{index}: strategy = {0}\")\n-    public static Collection<HttpExecutionStrategy> data() {\n-        return asList(noOffloadsStrategy(), defaultStrategy(), customStrategyBuilder().offloadAll().build());\n+    public static Param[][] data() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "490aace1e1ad7682a165427cfe8030e666f086f9"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU4MjI0NA==", "bodyText": "We are using UnsupportedProtocolHandler which does not implement these callbacks so we are not really verifying whether these callbacks are correct. Should we hold off adding calls to CloseHandler other than protocolPayloadEndOutbound() till we need them?", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366582244", "createdAt": "2020-01-14T21:30:21Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/H2ToStH1ClientDuplexHandler.java", "diffHunk": "@@ -56,15 +57,17 @@\n     @Nullable\n     private HttpRequestMethod method;\n \n-    H2ToStH1ClientDuplexHandler(boolean sslEnabled, BufferAllocator allocator, HttpHeadersFactory headersFactory) {\n-        super(headersFactory);\n+    H2ToStH1ClientDuplexHandler(boolean sslEnabled, BufferAllocator allocator, HttpHeadersFactory headersFactory,\n+                                CloseHandler closeHandler) {\n+        super(headersFactory, closeHandler);\n         this.scheme = sslEnabled ? HttpScheme.HTTPS : HttpScheme.HTTP;\n         this.allocator = allocator;\n     }\n \n     @Override\n     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n         if (msg instanceof HttpRequestMetaData) {\n+            closeHandler.protocolPayloadBeginOutbound(ctx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "490aace1e1ad7682a165427cfe8030e666f086f9"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjU4NDU2OQ==", "bodyText": "Should we add channel.close() in this test?", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366584569", "createdAt": "2020-01-14T21:35:43Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/test/java/io/servicetalk/transport/netty/internal/DefaultNettyConnectionTest.java", "diffHunk": "@@ -500,4 +523,34 @@ public void testChannelInactiveWithNoSubscriberIsQueued() throws Exception {\n         assertThat(subscriber.takeError(), instanceOf(ClosedChannelException.class));\n         conn.onClose().toFuture().get();\n     }\n+\n+    @Test\n+    public void testChannelCloseBeforeWriteComplete() {\n+        writeListener.listen(conn.write(publisher));\n+        Buffer hello1 = newBuffer(\"Hello1\");\n+        publisher.onNext(hello1);\n+        publisher.onNext(TRAILER);\n+        pollChannelAndVerifyWrites(\"Hello1\", TRAILER_MSG);\n+\n+        channel.pipeline().fireChannelInactive();\n+        channel.close();\n+        publisher.onComplete();\n+\n+        writeListener.verifyCompletion();\n+    }\n+\n+    @Test\n+    public void testChannelCloseAfterWriteComplete() {\n+        writeListener.listen(conn.write(publisher));\n+        Buffer hello1 = newBuffer(\"Hello1\");\n+        publisher.onNext(hello1);\n+        publisher.onNext(TRAILER);\n+\n+        pollChannelAndVerifyWrites(\"Hello1\", TRAILER_MSG);\n+\n+        channel.pipeline().fireChannelInactive();\n+        publisher.onComplete();\n+\n+        writeListener.verifyCompletion();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "490aace1e1ad7682a165427cfe8030e666f086f9"}, "originalPosition": 160}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a617beff701cc56eb816c1dab3be71f2098a7887", "author": {"user": {"login": "jayv", "name": "Jo Voordeckers"}}, "url": "https://github.com/apple/servicetalk/commit/a617beff701cc56eb816c1dab3be71f2098a7887", "committedDate": "2020-01-15T01:31:27Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a", "author": {"user": {"login": "jayv", "name": "Jo Voordeckers"}}, "url": "https://github.com/apple/servicetalk/commit/9228c3bc9471d6cc0be5828b6ce67399dfc17a1a", "committedDate": "2020-01-15T02:58:44Z", "message": "Ensure graceful close is not called out of phase"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMzU0OTgy", "url": "https://github.com/apple/servicetalk/pull/919#pullrequestreview-343354982", "createdAt": "2020-01-15T16:33:48Z", "commit": {"oid": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNjozMzo0OFrOFd-m0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNzozMzo1OVrOFeAjfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk3ODc3MQ==", "bodyText": "Since this is only useful for H2, should this be a package private class in htttp-netty module?", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366978771", "createdAt": "2020-01-15T16:33:48Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CloseHandler.java", "diffHunk": "@@ -262,6 +270,69 @@ public void protocolPayloadBeginOutbound(final ChannelHandlerContext ctx) {\n         public void protocolPayloadEndOutbound(final ChannelHandlerContext ctx) {\n         }\n \n+        @Override\n+        public void protocolPayloadEndOutboundSuccess(final ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void protocolClosingInbound(final ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void protocolClosingOutbound(final ChannelHandlerContext ctx) {\n+        }\n+    }\n+\n+    private static final class H2ProtocolHandler extends CloseHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4MTk0Nw==", "bodyText": "Update comments?\nI think we should leave it to the implementations as to how this is implemented and not prescribe the write-flush-close relationships.\nFrom this method perspective, we can say something like: calling close(Throwable) after closeGracefully() will be ignored.", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366981947", "createdAt": "2020-01-15T16:39:25Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -459,6 +458,21 @@ public FlushStrategy defaultFlushStrategy() {\n          */\n         void channelWritable();\n \n+        /**\n+         * Notifies the end of payload was observed at the transport (not necessarily flushed).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4MzI0OA==", "bodyText": "In this case, the subscriber waiting for write completion needs to be notified, so we should call notifyError() here instead of throwing.", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366983248", "createdAt": "2020-01-15T16:41:41Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java", "diffHunk": "@@ -74,21 +82,28 @@ public void channelWritable() {\n     }\n \n     @Override\n-    public void channelClosed(Throwable closedException) {\n+    public void closeGracefully() {\n+        if (terminated == UNSET) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4NTc0Mg==", "bodyText": "Since now we may generate error prematurely, there is a valid scenario where data may arrive post termination. It will be good to add a log indicating that we are ignoring result, when we do.", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366985742", "createdAt": "2020-01-15T16:46:13Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java", "diffHunk": "@@ -51,21 +55,25 @@ public void onSubscribe(Cancellable cancellable) {\n \n     @Override\n     public void onSuccess(@Nullable Object result) {\n-        // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n-        // ordering should be correct.\n-        channel.writeAndFlush(result).addListener(future -> {\n-            Throwable cause = future.cause();\n-            if (cause == null) {\n-                notifyComplete();\n-            } else {\n-                notifyError(cause);\n-            }\n-        });\n+        if (terminatedUpdater.compareAndSet(this, UNSET, PENDING)) {\n+            // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n+            // ordering should be correct.\n+            channel.writeAndFlush(result).addListener(future -> {\n+                Throwable cause = future.cause();\n+                if (cause == null) {\n+                    notifyComplete();\n+                } else {\n+                    notifyError(cause);\n+                }\n+            });\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4NjE1OA==", "bodyText": "Ditto, add a log when we ignore error.", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366986158", "createdAt": "2020-01-15T16:46:58Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java", "diffHunk": "@@ -51,21 +55,25 @@ public void onSubscribe(Cancellable cancellable) {\n \n     @Override\n     public void onSuccess(@Nullable Object result) {\n-        // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n-        // ordering should be correct.\n-        channel.writeAndFlush(result).addListener(future -> {\n-            Throwable cause = future.cause();\n-            if (cause == null) {\n-                notifyComplete();\n-            } else {\n-                notifyError(cause);\n-            }\n-        });\n+        if (terminatedUpdater.compareAndSet(this, UNSET, PENDING)) {\n+            // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n+            // ordering should be correct.\n+            channel.writeAndFlush(result).addListener(future -> {\n+                Throwable cause = future.cause();\n+                if (cause == null) {\n+                    notifyComplete();\n+                } else {\n+                    notifyError(cause);\n+                }\n+            });\n+        }\n     }\n \n     @Override\n     public void onError(Throwable t) {\n-        notifyError(t);\n+        if (terminatedUpdater.compareAndSet(this, UNSET, PENDING)) {\n+            notifyError(t);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4NzczNA==", "bodyText": "nit: We can use a bit more intuitive names:\nAWAITING_RESULT, AWAITING_WRITE_COMPLETION, TERMINATED", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366987734", "createdAt": "2020-01-15T16:49:47Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java", "diffHunk": "@@ -35,6 +35,10 @@\n     @SuppressWarnings(\"unused\")\n     private volatile int terminated;\n \n+    private static final int UNSET = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4ODkzOQ==", "bodyText": "Can we simply do a single atomic update; UNSET -> DONE and move the atomic updates out of notifyComplete() and notifyError()?", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r366988939", "createdAt": "2020-01-15T16:51:59Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java", "diffHunk": "@@ -51,21 +55,25 @@ public void onSubscribe(Cancellable cancellable) {\n \n     @Override\n     public void onSuccess(@Nullable Object result) {\n-        // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n-        // ordering should be correct.\n-        channel.writeAndFlush(result).addListener(future -> {\n-            Throwable cause = future.cause();\n-            if (cause == null) {\n-                notifyComplete();\n-            } else {\n-                notifyError(cause);\n-            }\n-        });\n+        if (terminatedUpdater.compareAndSet(this, UNSET, PENDING)) {\n+            // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n+            // ordering should be correct.\n+            channel.writeAndFlush(result).addListener(future -> {\n+                Throwable cause = future.cause();\n+                if (cause == null) {\n+                    notifyComplete();\n+                } else {\n+                    notifyError(cause);\n+                }\n+            });\n+        }\n     }\n \n     @Override\n     public void onError(Throwable t) {\n-        notifyError(t);\n+        if (terminatedUpdater.compareAndSet(this, UNSET, PENDING)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAwODI4Mg==", "bodyText": "If there are pending writes, we should not prematurely terminate the promise but wait for the promise results which will fail if the channel closed before writes were done. The following would be reasonable to do:\nvoid channelClosed(Throwable cause) {\n    assert eventLoop.inEventLoop();\n    if (hasFlag(CHANNEL_CLOSED)) {\n        return;\n    }\n    if (hasFlag(SUBSCRIBER_TERMINATED)) {\n        setFlag(CHANNEL_CLOSED);\n        // We have already terminated the subscriber (all writes have finished (one has failed)) then we\n        // just close the channel now.\n        closeHandler.closeChannelOutbound(channel);\n    } else if (activeWrites > 0) {\n        // Writes are pending, we will close the channel once writes are done.\n        setFlag(CLOSE_OUTBOUND_ON_SUBSCRIBER_TERMINATION);\n    } else {\n        setFlag(CHANNEL_CLOSED);\n        // subscriber has not terminated, no writes are pending and channel has closed so terminate the\n        // subscriber with a failure.\n        tryFailure(!written ? new AbortedFirstWrite(cause) : cause);\n    }\n}", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r367008282", "createdAt": "2020-01-15T17:29:09Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -307,28 +306,13 @@ void sourceTerminated(@Nullable Throwable cause) {\n \n         void channelClosed(Throwable cause) {\n             assert eventLoop.inEventLoop();\n-            if (hasFlag(CHANNEL_CLOSED) || hasFlag(SUBSCRIBER_TERMINATED)) {\n+            if (hasAnyFlags(CHANNEL_CLOSED, SUBSCRIBER_TERMINATED)) {\n                 setFlag(CHANNEL_CLOSED);\n                 return;\n             }\n             tryFailure(!written ? new AbortedFirstWrite(cause) : cause);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAwOTU1OA==", "bodyText": "This will be reverted if we update the channelClosed() method.", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r367009558", "createdAt": "2020-01-15T17:31:39Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -391,7 +375,7 @@ private boolean setFailure0(Throwable cause) {\n         }\n \n         private void terminateSubscriber(@Nullable Throwable cause) {\n-            if (hasFlag(CLOSE_OUTBOUND_ON_SUBSCRIBER_TERMINATION) || cause != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAwOTc4Mg==", "bodyText": "Maybe just call this method close() now?", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r367009782", "createdAt": "2020-01-15T17:32:05Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -307,28 +306,13 @@ void sourceTerminated(@Nullable Throwable cause) {\n \n         void channelClosed(Throwable cause) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAxMDY4Nw==", "bodyText": "Ok ya makese sense, thanks for the explanation.", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r367010687", "createdAt": "2020-01-15T17:33:59Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -163,6 +163,13 @@ public void protocolPayloadBeginOutbound(final ChannelHandlerContext ctx) {\n \n     @Override\n     public void protocolPayloadEndOutbound(final ChannelHandlerContext ctx) {\n+        if (isClient || has(state, CLOSING)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUzMjc2Mg=="}, "originalCommit": {"oid": "490aace1e1ad7682a165427cfe8030e666f086f9"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c23deea36eca9a6c7e46420dfedb4678de69487", "author": {"user": {"login": "jayv", "name": "Jo Voordeckers"}}, "url": "https://github.com/apple/servicetalk/commit/7c23deea36eca9a6c7e46420dfedb4678de69487", "committedDate": "2020-01-15T19:22:51Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTAwNzAx", "url": "https://github.com/apple/servicetalk/pull/919#pullrequestreview-343500701", "createdAt": "2020-01-15T20:29:44Z", "commit": {"oid": "7c23deea36eca9a6c7e46420dfedb4678de69487"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDoyOTo0NVrOFeFeXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMDozMzowM1rOFeFj9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5MTI5Mg==", "bodyText": "Got it, thanks", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r367091292", "createdAt": "2020-01-15T20:29:45Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CloseHandler.java", "diffHunk": "@@ -262,6 +270,69 @@ public void protocolPayloadBeginOutbound(final ChannelHandlerContext ctx) {\n         public void protocolPayloadEndOutbound(final ChannelHandlerContext ctx) {\n         }\n \n+        @Override\n+        public void protocolPayloadEndOutboundSuccess(final ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void protocolClosingInbound(final ChannelHandlerContext ctx) {\n+        }\n+\n+        @Override\n+        public void protocolClosingOutbound(final ChannelHandlerContext ctx) {\n+        }\n+    }\n+\n+    private static final class H2ProtocolHandler extends CloseHandler {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk3ODc3MQ=="}, "originalCommit": {"oid": "9228c3bc9471d6cc0be5828b6ce67399dfc17a1a"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5MTUwNw==", "bodyText": "is event is => event is", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r367091507", "createdAt": "2020-01-15T20:30:14Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -459,6 +458,16 @@ public FlushStrategy defaultFlushStrategy() {\n          */\n         void channelWritable();\n \n+        /**\n+         * Close the channel after the pending writes complete.\n+         *\n+         * <p>\n+         * Calling {@link #close(Throwable)} after {@link #closeGracefully()} will be ignored.\n+         * <p>\n+         * This is event is expected be called from the eventloop.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c23deea36eca9a6c7e46420dfedb4678de69487"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5MTkxMw==", "bodyText": "Also log the result?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        LOGGER.error(\"Failed to write data after permature close of the WriteListener.\");\n          \n          \n            \n                        LOGGER.error(\"Ignoring write {} as the listener is already closed.\", result);", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r367091913", "createdAt": "2020-01-15T20:31:09Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java", "diffHunk": "@@ -51,21 +58,29 @@ public void onSubscribe(Cancellable cancellable) {\n \n     @Override\n     public void onSuccess(@Nullable Object result) {\n-        // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n-        // ordering should be correct.\n-        channel.writeAndFlush(result).addListener(future -> {\n-            Throwable cause = future.cause();\n-            if (cause == null) {\n-                notifyComplete();\n-            } else {\n-                notifyError(cause);\n-            }\n-        });\n+        if (terminatedUpdater.compareAndSet(this, AWAITING_RESULT, TERMINATED)) {\n+            // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n+            // ordering should be correct.\n+            channel.writeAndFlush(result).addListener(future -> {\n+                Throwable cause = future.cause();\n+                if (cause == null) {\n+                    notifyComplete();\n+                } else {\n+                    notifyError(cause);\n+                }\n+            });\n+        } else {\n+            LOGGER.error(\"Failed to write data after permature close of the WriteListener.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c23deea36eca9a6c7e46420dfedb4678de69487"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA5MjcyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        LOGGER.error(\"Failed to fail subscriber after permature close of the WriteListener.\");\n          \n          \n            \n                        LOGGER.error(\"Ignoring emitted error as the listener is already closed.\", t);", "url": "https://github.com/apple/servicetalk/pull/919#discussion_r367092726", "createdAt": "2020-01-15T20:33:03Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java", "diffHunk": "@@ -51,21 +58,29 @@ public void onSubscribe(Cancellable cancellable) {\n \n     @Override\n     public void onSuccess(@Nullable Object result) {\n-        // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n-        // ordering should be correct.\n-        channel.writeAndFlush(result).addListener(future -> {\n-            Throwable cause = future.cause();\n-            if (cause == null) {\n-                notifyComplete();\n-            } else {\n-                notifyError(cause);\n-            }\n-        });\n+        if (terminatedUpdater.compareAndSet(this, AWAITING_RESULT, TERMINATED)) {\n+            // If we are not on the EventLoop then both the write and the flush will be enqueued on the EventLoop so\n+            // ordering should be correct.\n+            channel.writeAndFlush(result).addListener(future -> {\n+                Throwable cause = future.cause();\n+                if (cause == null) {\n+                    notifyComplete();\n+                } else {\n+                    notifyError(cause);\n+                }\n+            });\n+        } else {\n+            LOGGER.error(\"Failed to write data after permature close of the WriteListener.\");\n+        }\n     }\n \n     @Override\n     public void onError(Throwable t) {\n-        notifyError(t);\n+        if (terminatedUpdater.compareAndSet(this, AWAITING_RESULT, TERMINATED)) {\n+            notifyError(t);\n+        } else {\n+            LOGGER.error(\"Failed to fail subscriber after permature close of the WriteListener.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c23deea36eca9a6c7e46420dfedb4678de69487"}, "originalPosition": 62}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a0292a13c235d28f1a4c7532afdf550e58481d0", "author": {"user": {"login": "jayv", "name": "Jo Voordeckers"}}, "url": "https://github.com/apple/servicetalk/commit/1a0292a13c235d28f1a4c7532afdf550e58481d0", "committedDate": "2020-01-15T20:42:42Z", "message": "Update servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java\n\nCo-Authored-By: Nitesh Kant <nitesh_kant@apple.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84acbf132acbba65dc3abbcdd32ef391882af09a", "author": {"user": {"login": "jayv", "name": "Jo Voordeckers"}}, "url": "https://github.com/apple/servicetalk/commit/84acbf132acbba65dc3abbcdd32ef391882af09a", "committedDate": "2020-01-15T20:43:35Z", "message": "Update servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteSingleSubscriber.java\n\nCo-Authored-By: Nitesh Kant <nitesh_kant@apple.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7850d12c831f5871aceda6ca01b1fb6002b0b187", "author": {"user": {"login": "jayv", "name": "Jo Voordeckers"}}, "url": "https://github.com/apple/servicetalk/commit/7850d12c831f5871aceda6ca01b1fb6002b0b187", "committedDate": "2020-01-15T20:44:15Z", "message": "Address comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3248, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}