{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc5ODI2MTIz", "number": 1141, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNzowOTo1M1rOEjPG4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQwMDowMDozMFrOEsOe_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MzgzMTM2OnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNzowOTo1M1rOHRey7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNzowOTo1M1rOHRey7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA5MjM5Nw==", "bodyText": "@NiteshKant upgrade to TLSv1.3 (client starts writing data earlier than server completes the handshake) helped to discover this issue, resulting in a lot of failed tests: https://ci.servicetalk.io/job/servicetalk-java11-prb/1521/\nMy fix isn't great: 5c5b41c. Open for suggestions.", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r488092397", "createdAt": "2020-09-14T17:09:53Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -470,10 +474,10 @@ private boolean failIfWriteActive(ChannelOutboundListener newChannelOutboundList\n             // It is possible that we have set the writeSubscriber, then the channel becomes inactive, and we will\n             // never notify the write writeSubscriber of the inactive event. So if the channel is inactive we notify\n             // the writeSubscriber.\n-            // It is also possible that Channel is in closing state, we should abort new writes if a closeReason was\n-            // observed:\n+            // It is also possible that Channel is in closing state, we should abort new writes from the client-side\n+            // if a closeReason was observed:\n             CloseEvent closeReason = null;\n-            if (!channel().isActive() || (closeReason = this.closeReason) != null) {\n+            if (!channel().isActive() || (isClient && (closeReason = this.closeReason) != null)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c5b41c32b1f9dd3947bd44042f2f810e0698188"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzgxOTkwOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CloseHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMzoxNDoxNVrOHUeYbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNzo1NzowNVrOHYNUyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMTM0Mg==", "bodyText": "Is this really required?", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r491231342", "createdAt": "2020-09-18T23:14:15Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CloseHandler.java", "diffHunk": "@@ -342,10 +344,18 @@ public void protocolClosingOutbound(final ChannelHandlerContext ctx) {\n         }\n     }\n \n+    private abstract static class NettyUserEvent {\n+\n+        @Override\n+        public String toString() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74744a3fa081d7040442e6ced07945b68dec3691"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE0NjE4NA==", "bodyText": "Not a strong requirement, but makes logs a bit nicer by removing random numbers at the end of these events.", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r495146184", "createdAt": "2020-09-25T17:57:05Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CloseHandler.java", "diffHunk": "@@ -342,10 +344,18 @@ public void protocolClosingOutbound(final ChannelHandlerContext ctx) {\n         }\n     }\n \n+    private abstract static class NettyUserEvent {\n+\n+        @Override\n+        public String toString() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMTM0Mg=="}, "originalCommit": {"oid": "74744a3fa081d7040442e6ced07945b68dec3691"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzgyNTY2OnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMzoxODoxNlrOHUebkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjo0MTo0OVrOHZG4Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMjE0Nw==", "bodyText": "I don't think we should depend on ordering between listener invocation and subscriber termination. Can you explain more what is the issue here and why was it not evident before?", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r491232147", "createdAt": "2020-09-18T23:18:16Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -487,6 +486,9 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n                     ChannelCloseUtils.close(channel, cause);\n                 }\n             }\n+            // Notify listeners after the subscriber is terminated. Otherwise, WriteStreamSubscriber#channelClosed may", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74744a3fa081d7040442e6ced07945b68dec3691"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE0NjIxNg==", "bodyText": "If we invoke listeners before the write is complete, it will trigger protocolPayloadEndOutboundSuccess that initiates connection closure before the write is complete. As the result, the pipeline will see ChannelOutputShutdownEvent and trigger WSS#channelClosed changing the terminal signal from onComplete to onError.\nCloseHandler does not know about the state of WSS to defer closure until the write is complete.", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r495146216", "createdAt": "2020-09-25T17:57:08Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -487,6 +486,9 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n                     ChannelCloseUtils.close(channel, cause);\n                 }\n             }\n+            // Notify listeners after the subscriber is terminated. Otherwise, WriteStreamSubscriber#channelClosed may", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMjE0Nw=="}, "originalCommit": {"oid": "74744a3fa081d7040442e6ced07945b68dec3691"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4OTA5MA==", "bodyText": "Netty invokes listeners after it processes the completion of the promise. I think we should do the same and first complete the subscriber, then notify listeners.", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r496089090", "createdAt": "2020-09-28T16:41:49Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -487,6 +486,9 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n                     ChannelCloseUtils.close(channel, cause);\n                 }\n             }\n+            // Notify listeners after the subscriber is terminated. Otherwise, WriteStreamSubscriber#channelClosed may", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMjE0Nw=="}, "originalCommit": {"oid": "74744a3fa081d7040442e6ced07945b68dec3691"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3MzgzNzY2OnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMzoyNjozNlrOHUeiLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjo0MDoxNFrOHZG0iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMzgzOA==", "bodyText": "I am not convinced this is doing anything useful since we are following first writer-wins with events that can be concurrent and are sequenced through the event loop queue.\nIf this isn't really required for this change, i would prefer considering as a followup", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r491233838", "createdAt": "2020-09-18T23:26:36Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -73,13 +78,21 @@\n      */\n     private int pending;\n \n+    /**\n+     * Original {@link CloseEvent} that initiated closing.\n+     */\n+    @Nullable\n+    private CloseEvent event;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74744a3fa081d7040442e6ced07945b68dec3691"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE0NjI0OA==", "bodyText": "We currently have a similar problem in DefaultNettyConnection. The first close event wins.\nThis is required to understand later how should we close the connection: gracefully or not. Without storing the original reason we can not make a correct decision at the time when we are ready to close.", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r495146248", "createdAt": "2020-09-25T17:57:11Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -73,13 +78,21 @@\n      */\n     private int pending;\n \n+    /**\n+     * Original {@link CloseEvent} that initiated closing.\n+     */\n+    @Nullable\n+    private CloseEvent event;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMzgzOA=="}, "originalCommit": {"oid": "74744a3fa081d7040442e6ced07945b68dec3691"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4ODIwMQ==", "bodyText": "I created a diagram that tells when the state has to be updated. For this PR, it's ok to leave it as-is. In a follow-up PR, to improve understanding of the connection closure, I will add a logic that updates the event here shares it with DefaultNettyConnection.", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r496088201", "createdAt": "2020-09-28T16:40:14Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -73,13 +78,21 @@\n      */\n     private int pending;\n \n+    /**\n+     * Original {@link CloseEvent} that initiated closing.\n+     */\n+    @Nullable\n+    private CloseEvent event;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzMzgzOA=="}, "originalCommit": {"oid": "74744a3fa081d7040442e6ced07945b68dec3691"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Mzg0NzA0OnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMzozMzo1M1rOHUenpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQyMzozMzo1M1rOHUenpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTIzNTIzNw==", "bodyText": "Did you mean to use evt here instead of event as the callers of this method are reading event?", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r491235237", "createdAt": "2020-09-18T23:33:53Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -236,21 +268,31 @@ void userClosing(final Channel channel) {\n \n     // This closes the channel either completely when there are no more outstanding requests to drain or half-closes\n     // when a deferred request was encountered.\n-    private void closeChannelHalfOrFullyOnPayloadEnd(final Channel channel, final CloseEvent evt) {\n+    private void closeChannelHalfOrFullyOnPayloadEnd(final Channel channel, final CloseEvent evt,\n+                                                     final boolean endInbound) {\n+\n         if (idle(pending, state)) {\n-            // close when all pending requests drained\n-            closeChannel(channel, evt);\n-        } else if (!isClient && evt == PROTOCOL_CLOSING_INBOUND) {\n-            // deferred half close after current request is done\n+            if (isClient || has(state, IN_CLOSED) || (event != USER_CLOSING && event != PROTOCOL_CLOSING_OUTBOUND)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74744a3fa081d7040442e6ced07945b68dec3691"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Mzg4OTgwOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwMDoxMDowNFrOHUe-0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjozODoyOFrOHZGv8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0MTE2OQ==", "bodyText": "I am concerned about splitting the state b/w state and event. Can we set SERVER_CLOSING_GRACEFULLY upfront so that we do not have to rely on event here?", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r491241169", "createdAt": "2020-09-19T00:10:04Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -236,21 +268,31 @@ void userClosing(final Channel channel) {\n \n     // This closes the channel either completely when there are no more outstanding requests to drain or half-closes\n     // when a deferred request was encountered.\n-    private void closeChannelHalfOrFullyOnPayloadEnd(final Channel channel, final CloseEvent evt) {\n+    private void closeChannelHalfOrFullyOnPayloadEnd(final Channel channel, final CloseEvent evt,\n+                                                     final boolean endInbound) {\n+\n         if (idle(pending, state)) {\n-            // close when all pending requests drained\n-            closeChannel(channel, evt);\n-        } else if (!isClient && evt == PROTOCOL_CLOSING_INBOUND) {\n-            // deferred half close after current request is done\n+            if (isClient || has(state, IN_CLOSED) || (event != USER_CLOSING && event != PROTOCOL_CLOSING_OUTBOUND)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74744a3fa081d7040442e6ced07945b68dec3691"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE0NjI3OA==", "bodyText": "SERVER_CLOSING_GRACEFULLY used by logic that handles shutdown events and the requirement there is to set this flag only when we shutdown outbound gracefully. I will need another flag if I can not use evt.\nHere we use the originated reason for closure to decide if we need to close gracefully or not.", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r495146278", "createdAt": "2020-09-25T17:57:15Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -236,21 +268,31 @@ void userClosing(final Channel channel) {\n \n     // This closes the channel either completely when there are no more outstanding requests to drain or half-closes\n     // when a deferred request was encountered.\n-    private void closeChannelHalfOrFullyOnPayloadEnd(final Channel channel, final CloseEvent evt) {\n+    private void closeChannelHalfOrFullyOnPayloadEnd(final Channel channel, final CloseEvent evt,\n+                                                     final boolean endInbound) {\n+\n         if (idle(pending, state)) {\n-            // close when all pending requests drained\n-            closeChannel(channel, evt);\n-        } else if (!isClient && evt == PROTOCOL_CLOSING_INBOUND) {\n-            // deferred half close after current request is done\n+            if (isClient || has(state, IN_CLOSED) || (event != USER_CLOSING && event != PROTOCOL_CLOSING_OUTBOUND)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0MTE2OQ=="}, "originalCommit": {"oid": "74744a3fa081d7040442e6ced07945b68dec3691"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4NzAyNA==", "bodyText": "After investigating it more, I'm actually planning to do the opposite. The CLOSING state is not useful in many cases as it does not tell the reason for the closure. I plan to remove CLOSING and use event != null instead of has(state, CLOSING). In some cases, like this one, the event matters.", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r496087024", "createdAt": "2020-09-28T16:38:28Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -236,21 +268,31 @@ void userClosing(final Channel channel) {\n \n     // This closes the channel either completely when there are no more outstanding requests to drain or half-closes\n     // when a deferred request was encountered.\n-    private void closeChannelHalfOrFullyOnPayloadEnd(final Channel channel, final CloseEvent evt) {\n+    private void closeChannelHalfOrFullyOnPayloadEnd(final Channel channel, final CloseEvent evt,\n+                                                     final boolean endInbound) {\n+\n         if (idle(pending, state)) {\n-            // close when all pending requests drained\n-            closeChannel(channel, evt);\n-        } else if (!isClient && evt == PROTOCOL_CLOSING_INBOUND) {\n-            // deferred half close after current request is done\n+            if (isClient || has(state, IN_CLOSED) || (event != USER_CLOSING && event != PROTOCOL_CLOSING_OUTBOUND)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0MTE2OQ=="}, "originalCommit": {"oid": "74744a3fa081d7040442e6ced07945b68dec3691"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Mzg5MTYyOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwMDoxMTo1NlrOHUe_2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwMDoxMTo1NlrOHUe_2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0MTQzMg==", "bodyText": "Can we move this to the receiver of the discard event?", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r491241432", "createdAt": "2020-09-19T00:11:56Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -360,12 +406,50 @@ private void setSocketResetOnClose(final Channel channel) {\n         }\n     }\n \n+    private void serverCloseGracefully(final Channel channel) {\n+        // Perform half-closure as described in https://tools.ietf.org/html/rfc7230#section-6.6\n+        serverHalfCloseInbound(channel);\n+        serverHalfCloseOutbound(channel);\n+    }\n+\n     private void serverHalfCloseInbound(final Channel channel) {\n         assert !isClient;\n-        if (!has(state, IN_CLOSED) && channel instanceof DuplexChannel) {\n-            LOGGER.debug(\"{} Half-Closing INBOUND\", channel);\n+        if (!hasAny(state, DISCARDING_SERVER_INPUT, IN_CLOSED)) {\n+            // Instead of actual half-closure DuplexChannel.shutdownInput() we discard all further inbound data, but\n+            // keep reading to receive FIN from the remote peer.\n+            LOGGER.debug(\"{} Discarding further INBOUND\", channel);\n             state = unset(state, READ);\n-            ((DuplexChannel) channel).shutdownInput().addListener((ChannelFutureListener) this::onHalfClosed);\n+            channel.pipeline().fireUserEventTriggered(DiscardFurtherInboundEvent.INSTANCE);\n+            channel.config().setAutoRead(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74744a3fa081d7040442e6ced07945b68dec3691"}, "originalPosition": 239}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NzczNjc3OnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/ByteToMessageDecoder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMDo0MjoyMlrOHfYDpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNTo0NzowN1rOHgWPZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY2MjA1NQ==", "bodyText": "do we have to expose this method? ByteToMessageDecoder should clean up the cumulation when it is removed from the pipeline, not clear why we need to explicitly call this method.", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502662055", "createdAt": "2020-10-09T20:42:22Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/ByteToMessageDecoder.java", "diffHunk": "@@ -242,7 +242,7 @@ protected ByteBuf swapAndCopyCumulation(final ByteBuf cumulation, final ByteBuf\n     protected void cumulationReset() {\n     }\n \n-    private void releaseCumulation() {\n+    protected final void releaseCumulation() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0e9ec7f110853308c6cff9a2a9289ece7945fe0"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcyNzg2OQ==", "bodyText": "It may have some data in the cumulation buffer. On handlerRemoved event it will fire those pending data through the pipeline. By releasing it manually, we can avoid seeing more data.", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502727869", "createdAt": "2020-10-10T01:25:47Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/ByteToMessageDecoder.java", "diffHunk": "@@ -242,7 +242,7 @@ protected ByteBuf swapAndCopyCumulation(final ByteBuf cumulation, final ByteBuf\n     protected void cumulationReset() {\n     }\n \n-    private void releaseCumulation() {\n+    protected final void releaseCumulation() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY2MjA1NQ=="}, "originalCommit": {"oid": "a0e9ec7f110853308c6cff9a2a9289ece7945fe0"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4MDg2OQ==", "bodyText": "@Scottmitch you were right, when we do replace, netty first adds a new handler after the current one and then removes the existing handler. Therefore, even if we had something in the accumulation buffer, it will be discarded by the new handler. So, we can avoid exposing releaseCumulation() \ud83c\udf89", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r503680869", "createdAt": "2020-10-13T05:47:07Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/ByteToMessageDecoder.java", "diffHunk": "@@ -242,7 +242,7 @@ protected ByteBuf swapAndCopyCumulation(final ByteBuf cumulation, final ByteBuf\n     protected void cumulationReset() {\n     }\n \n-    private void releaseCumulation() {\n+    protected final void releaseCumulation() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY2MjA1NQ=="}, "originalCommit": {"oid": "a0e9ec7f110853308c6cff9a2a9289ece7945fe0"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0Nzg3NzQyOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMTo0MzoxMVrOHfZXvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwMDowMDowOVrOHgRA4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY4MzU4MA==", "bodyText": "reminder @normanmaurer: we should fix half closure in Netty so actions go through the pipeline instead of the channel bypassing handlers.", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502683580", "createdAt": "2020-10-09T21:43:11Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -359,12 +399,49 @@ private void setSocketResetOnClose(final Channel channel) {\n         }\n     }\n \n+    private void serverCloseGracefully(final Channel channel) {\n+        // Perform half-closure as described in https://tools.ietf.org/html/rfc7230#section-6.6\n+        serverHalfCloseInbound(channel);\n+        serverHalfCloseOutbound(channel);\n+    }\n+\n     private void serverHalfCloseInbound(final Channel channel) {\n         assert !isClient;\n-        if (!has(state, IN_CLOSED) && channel instanceof DuplexChannel) {\n-            LOGGER.debug(\"{} Half-Closing INBOUND\", channel);\n+        if (!hasAny(state, DISCARDING_SERVER_INPUT, IN_CLOSED)) {\n+            // Instead of actual half-closure DuplexChannel.shutdownInput() we discard all further inbound data, but\n+            // keep reading to receive FIN from the remote peer.\n+            LOGGER.debug(\"{} Discarding further INBOUND\", channel);\n             state = unset(state, READ);\n-            ((DuplexChannel) channel).shutdownInput().addListener((ChannelFutureListener) this::onHalfClosed);\n+            channel.pipeline().fireUserEventTriggered(DiscardFurtherInboundEvent.INSTANCE);\n+            state = set(state, DISCARDING_SERVER_INPUT);\n+        }\n+    }\n+\n+    private void serverHalfCloseOutbound(final Channel channel) {\n+        assert !isClient && idle(pending, state);\n+        if (!has(state, OUT_CLOSED)) {\n+            state = set(state, CLOSING_SERVER_GRACEFULLY);\n+            LOGGER.debug(\"{} Half-Closing OUTBOUND\", channel);\n+            halfCloseOutbound(channel, false);\n+            // Final channel.close() will happen when FIN (ChannelInputShutdownReadComplete) is received\n+        }\n+    }\n+\n+    private void halfCloseOutbound(final Channel channel, final boolean registerOnHalfClosed) {\n+        SslHandler sslHandler = channel.pipeline().get(SslHandler.class);\n+        if (sslHandler != null) {\n+            // send close_notify: https://tools.ietf.org/html/rfc5246#section-7.2.1\n+            sslHandler.closeOutbound().addListener(f -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71a312d5741d1bc74214a3736893dc0d494a62b6"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcyNzg4NQ==", "bodyText": "There is also ChannelOutputShutdownEvent fired through the pipeline. Can you please clarify what event we need in addition to that?", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502727885", "createdAt": "2020-10-10T01:25:52Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -359,12 +399,49 @@ private void setSocketResetOnClose(final Channel channel) {\n         }\n     }\n \n+    private void serverCloseGracefully(final Channel channel) {\n+        // Perform half-closure as described in https://tools.ietf.org/html/rfc7230#section-6.6\n+        serverHalfCloseInbound(channel);\n+        serverHalfCloseOutbound(channel);\n+    }\n+\n     private void serverHalfCloseInbound(final Channel channel) {\n         assert !isClient;\n-        if (!has(state, IN_CLOSED) && channel instanceof DuplexChannel) {\n-            LOGGER.debug(\"{} Half-Closing INBOUND\", channel);\n+        if (!hasAny(state, DISCARDING_SERVER_INPUT, IN_CLOSED)) {\n+            // Instead of actual half-closure DuplexChannel.shutdownInput() we discard all further inbound data, but\n+            // keep reading to receive FIN from the remote peer.\n+            LOGGER.debug(\"{} Discarding further INBOUND\", channel);\n             state = unset(state, READ);\n-            ((DuplexChannel) channel).shutdownInput().addListener((ChannelFutureListener) this::onHalfClosed);\n+            channel.pipeline().fireUserEventTriggered(DiscardFurtherInboundEvent.INSTANCE);\n+            state = set(state, DISCARDING_SERVER_INPUT);\n+        }\n+    }\n+\n+    private void serverHalfCloseOutbound(final Channel channel) {\n+        assert !isClient && idle(pending, state);\n+        if (!has(state, OUT_CLOSED)) {\n+            state = set(state, CLOSING_SERVER_GRACEFULLY);\n+            LOGGER.debug(\"{} Half-Closing OUTBOUND\", channel);\n+            halfCloseOutbound(channel, false);\n+            // Final channel.close() will happen when FIN (ChannelInputShutdownReadComplete) is received\n+        }\n+    }\n+\n+    private void halfCloseOutbound(final Channel channel, final boolean registerOnHalfClosed) {\n+        SslHandler sslHandler = channel.pipeline().get(SslHandler.class);\n+        if (sslHandler != null) {\n+            // send close_notify: https://tools.ietf.org/html/rfc5246#section-7.2.1\n+            sslHandler.closeOutbound().addListener(f -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY4MzU4MA=="}, "originalCommit": {"oid": "71a312d5741d1bc74214a3736893dc0d494a62b6"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NTg3MA==", "bodyText": "Half closure is an example that bypasses the pipeline (due to organically added support over time). Some handlers would like to participate in state machine of channels (channel initialization/active/open/handshake/wrtiability/queuing/etc.), but in some cases the channel doesn't propagate the events through the pipeline. So for example in this case we have to reach into the pipeline and invoke a specific handler in order to cleanup \"correctly\". Ideally the events can flow through the pipeline so handlers can intercept/interpret these events as necessary.", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r503585870", "createdAt": "2020-10-12T23:37:05Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -359,12 +399,49 @@ private void setSocketResetOnClose(final Channel channel) {\n         }\n     }\n \n+    private void serverCloseGracefully(final Channel channel) {\n+        // Perform half-closure as described in https://tools.ietf.org/html/rfc7230#section-6.6\n+        serverHalfCloseInbound(channel);\n+        serverHalfCloseOutbound(channel);\n+    }\n+\n     private void serverHalfCloseInbound(final Channel channel) {\n         assert !isClient;\n-        if (!has(state, IN_CLOSED) && channel instanceof DuplexChannel) {\n-            LOGGER.debug(\"{} Half-Closing INBOUND\", channel);\n+        if (!hasAny(state, DISCARDING_SERVER_INPUT, IN_CLOSED)) {\n+            // Instead of actual half-closure DuplexChannel.shutdownInput() we discard all further inbound data, but\n+            // keep reading to receive FIN from the remote peer.\n+            LOGGER.debug(\"{} Discarding further INBOUND\", channel);\n             state = unset(state, READ);\n-            ((DuplexChannel) channel).shutdownInput().addListener((ChannelFutureListener) this::onHalfClosed);\n+            channel.pipeline().fireUserEventTriggered(DiscardFurtherInboundEvent.INSTANCE);\n+            state = set(state, DISCARDING_SERVER_INPUT);\n+        }\n+    }\n+\n+    private void serverHalfCloseOutbound(final Channel channel) {\n+        assert !isClient && idle(pending, state);\n+        if (!has(state, OUT_CLOSED)) {\n+            state = set(state, CLOSING_SERVER_GRACEFULLY);\n+            LOGGER.debug(\"{} Half-Closing OUTBOUND\", channel);\n+            halfCloseOutbound(channel, false);\n+            // Final channel.close() will happen when FIN (ChannelInputShutdownReadComplete) is received\n+        }\n+    }\n+\n+    private void halfCloseOutbound(final Channel channel, final boolean registerOnHalfClosed) {\n+        SslHandler sslHandler = channel.pipeline().get(SslHandler.class);\n+        if (sslHandler != null) {\n+            // send close_notify: https://tools.ietf.org/html/rfc5246#section-7.2.1\n+            sslHandler.closeOutbound().addListener(f -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY4MzU4MA=="}, "originalCommit": {"oid": "71a312d5741d1bc74214a3736893dc0d494a62b6"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU5NTIzNA==", "bodyText": "I see. Agreed, some other event prior the output shutdown will be useful for SslHandler to intercept it and emit close_nofity.", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r503595234", "createdAt": "2020-10-13T00:00:09Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -359,12 +399,49 @@ private void setSocketResetOnClose(final Channel channel) {\n         }\n     }\n \n+    private void serverCloseGracefully(final Channel channel) {\n+        // Perform half-closure as described in https://tools.ietf.org/html/rfc7230#section-6.6\n+        serverHalfCloseInbound(channel);\n+        serverHalfCloseOutbound(channel);\n+    }\n+\n     private void serverHalfCloseInbound(final Channel channel) {\n         assert !isClient;\n-        if (!has(state, IN_CLOSED) && channel instanceof DuplexChannel) {\n-            LOGGER.debug(\"{} Half-Closing INBOUND\", channel);\n+        if (!hasAny(state, DISCARDING_SERVER_INPUT, IN_CLOSED)) {\n+            // Instead of actual half-closure DuplexChannel.shutdownInput() we discard all further inbound data, but\n+            // keep reading to receive FIN from the remote peer.\n+            LOGGER.debug(\"{} Discarding further INBOUND\", channel);\n             state = unset(state, READ);\n-            ((DuplexChannel) channel).shutdownInput().addListener((ChannelFutureListener) this::onHalfClosed);\n+            channel.pipeline().fireUserEventTriggered(DiscardFurtherInboundEvent.INSTANCE);\n+            state = set(state, DISCARDING_SERVER_INPUT);\n+        }\n+    }\n+\n+    private void serverHalfCloseOutbound(final Channel channel) {\n+        assert !isClient && idle(pending, state);\n+        if (!has(state, OUT_CLOSED)) {\n+            state = set(state, CLOSING_SERVER_GRACEFULLY);\n+            LOGGER.debug(\"{} Half-Closing OUTBOUND\", channel);\n+            halfCloseOutbound(channel, false);\n+            // Final channel.close() will happen when FIN (ChannelInputShutdownReadComplete) is received\n+        }\n+    }\n+\n+    private void halfCloseOutbound(final Channel channel, final boolean registerOnHalfClosed) {\n+        SslHandler sslHandler = channel.pipeline().get(SslHandler.class);\n+        if (sslHandler != null) {\n+            // send close_notify: https://tools.ietf.org/html/rfc5246#section-7.2.1\n+            sslHandler.closeOutbound().addListener(f -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY4MzU4MA=="}, "originalCommit": {"oid": "71a312d5741d1bc74214a3736893dc0d494a62b6"}, "originalPosition": 255}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0ODAzMTA4OnYy", "diffSide": "RIGHT", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpObjectDecoder.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMzowODo0MVrOHfaz-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwNjowMTo1NlrOHgWi8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwNzE5NA==", "bodyText": "we lose the ability to apply back pressure at this point. which may lead to a surprising \"attack\" vector from the user perspective. Consider adding a comment and reference to s6.6 (client writes before it receives FIN, server responds with RST, client TCP stack doesn't deliver buffered data when RST received).\nDid you explore alternative approaches (e.g. not read at all)? Even if we don't ask to read data for the native transports Netty will read/drain if a FIN/RST is received (via RDHUP), which means we will pickup on the FIN/RST as soon as it is delivered (assuming it is delivered). However if the client has more data to send than can be queued in its sendbuf (or that can fit in the server recvbuf) then the server won't see the FIN_ACK from the client until reading/draining data. However maybe this isn't a problem as if the client continues to read (which is expected) it will eventually see the server's close and should stop trying to write.", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502707194", "createdAt": "2020-10-09T23:08:41Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpObjectDecoder.java", "diffHunk": "@@ -502,6 +505,12 @@ public final void userEventTriggered(final ChannelHandlerContext ctx, final Obje\n                 default:\n                     break;\n             }\n+        } else if (evt instanceof DiscardFurtherInboundEvent) {\n+            resetNow();\n+            releaseCumulation();\n+            ctx.pipeline().replace(HttpObjectDecoder.this, DiscardInboundHandler.INSTANCE.toString(),\n+                    DiscardInboundHandler.INSTANCE);\n+            ctx.channel().config().setAutoRead(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71a312d5741d1bc74214a3736893dc0d494a62b6"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcyODE4Nw==", "bodyText": "Hmm, interesting idea. I thought that we have to keep reading data from the channel to receive FIN in all cases, even if recvbuf is not full. What will happen on the pipeline if we do not request read() anymore but then native transport observes FIN? IIUC, AbstractEpollChannel will never fire ChannelInputShutdownReadComplete if we do not request to read, but we depend on this event in DefaultNettyConnection. Also, will the behavior change with Java NIO transport?\nThe shutdownInput() also discards all new arriving data without applying backpressure. The only difference is that we will never see FIN if we invoke shutdownInput() manually, that's why I have to implement /dev/null handler. And it looks like a safer option, without relying on native transport behavior (RDHUP).", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502728187", "createdAt": "2020-10-10T01:28:08Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpObjectDecoder.java", "diffHunk": "@@ -502,6 +505,12 @@ public final void userEventTriggered(final ChannelHandlerContext ctx, final Obje\n                 default:\n                     break;\n             }\n+        } else if (evt instanceof DiscardFurtherInboundEvent) {\n+            resetNow();\n+            releaseCumulation();\n+            ctx.pipeline().replace(HttpObjectDecoder.this, DiscardInboundHandler.INSTANCE.toString(),\n+                    DiscardInboundHandler.INSTANCE);\n+            ctx.channel().config().setAutoRead(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwNzE5NA=="}, "originalCommit": {"oid": "71a312d5741d1bc74214a3736893dc0d494a62b6"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzY4NTg3NA==", "bodyText": "Discussed offline: OS behaves in a similar way after shutdownInput(). Will keep the existing approach for now.", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r503685874", "createdAt": "2020-10-13T06:01:56Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpObjectDecoder.java", "diffHunk": "@@ -502,6 +505,12 @@ public final void userEventTriggered(final ChannelHandlerContext ctx, final Obje\n                 default:\n                     break;\n             }\n+        } else if (evt instanceof DiscardFurtherInboundEvent) {\n+            resetNow();\n+            releaseCumulation();\n+            ctx.pipeline().replace(HttpObjectDecoder.this, DiscardInboundHandler.INSTANCE.toString(),\n+                    DiscardInboundHandler.INSTANCE);\n+            ctx.channel().config().setAutoRead(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwNzE5NA=="}, "originalCommit": {"oid": "71a312d5741d1bc74214a3736893dc0d494a62b6"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0ODA0NTM3OnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMzoxODowN1rOHfa7yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMzoxODowN1rOHfa7yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwOTE5NQ==", "bodyText": "can you remove the \"keep reading\" point here in case we do something different? Consider describing the problem with shutdownInput() (e.g. client send data, server rst, client sees rst and discards read queue) and that the protocol can handle the closure more gracefully.", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502709195", "createdAt": "2020-10-09T23:18:07Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -359,12 +399,49 @@ private void setSocketResetOnClose(final Channel channel) {\n         }\n     }\n \n+    private void serverCloseGracefully(final Channel channel) {\n+        // Perform half-closure as described in https://tools.ietf.org/html/rfc7230#section-6.6\n+        serverHalfCloseInbound(channel);\n+        serverHalfCloseOutbound(channel);\n+    }\n+\n     private void serverHalfCloseInbound(final Channel channel) {\n         assert !isClient;\n-        if (!has(state, IN_CLOSED) && channel instanceof DuplexChannel) {\n-            LOGGER.debug(\"{} Half-Closing INBOUND\", channel);\n+        if (!hasAny(state, DISCARDING_SERVER_INPUT, IN_CLOSED)) {\n+            // Instead of actual half-closure DuplexChannel.shutdownInput() we discard all further inbound data, but\n+            // keep reading to receive FIN from the remote peer.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71a312d5741d1bc74214a3736893dc0d494a62b6"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0ODA1MTQ1OnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMzoyMjozMlrOHfa_OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMzoyMjozMlrOHfa_OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMDA3Mw==", "bodyText": "USER_CLOSING -> can you plz rename this (and userClosingmethod) to include graceful? not introduced by this PR but it is confusing when the concepts are mixed together.", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502710073", "createdAt": "2020-10-09T23:22:32Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -235,21 +261,31 @@ void userClosing(final Channel channel) {\n \n     // This closes the channel either completely when there are no more outstanding requests to drain or half-closes\n     // when a deferred request was encountered.\n-    private void closeChannelHalfOrFullyOnPayloadEnd(final Channel channel, final CloseEvent evt) {\n+    private void closeChannelHalfOrFullyOnPayloadEnd(final Channel channel, final CloseEvent evt,\n+                                                     final boolean endInbound) {\n+\n         if (idle(pending, state)) {\n-            // close when all pending requests drained\n-            closeChannel(channel, evt);\n-        } else if (!isClient && evt == PROTOCOL_CLOSING_INBOUND) {\n-            // deferred half close after current request is done\n+            if (isClient || has(state, IN_CLOSED) || (evt != USER_CLOSING && evt != PROTOCOL_CLOSING_OUTBOUND)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71a312d5741d1bc74214a3736893dc0d494a62b6"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0ODA2NjM0OnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMzozMzowNFrOHfbHiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQwMToyODoyM1rOHfcGDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMjIwMw==", "bodyText": "consider renaming to avoid \"discard\" because we are assuming what action will be taken as a result of this event but don't control what is being done.\nDISCARDING_SERVER_INPUT -> IN_SHUTDOWN\nDiscardFurtherInboundEvent -> GracefulInputShutdownEvent", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502712203", "createdAt": "2020-10-09T23:33:04Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -359,12 +399,49 @@ private void setSocketResetOnClose(final Channel channel) {\n         }\n     }\n \n+    private void serverCloseGracefully(final Channel channel) {\n+        // Perform half-closure as described in https://tools.ietf.org/html/rfc7230#section-6.6\n+        serverHalfCloseInbound(channel);\n+        serverHalfCloseOutbound(channel);\n+    }\n+\n     private void serverHalfCloseInbound(final Channel channel) {\n         assert !isClient;\n-        if (!has(state, IN_CLOSED) && channel instanceof DuplexChannel) {\n-            LOGGER.debug(\"{} Half-Closing INBOUND\", channel);\n+        if (!hasAny(state, DISCARDING_SERVER_INPUT, IN_CLOSED)) {\n+            // Instead of actual half-closure DuplexChannel.shutdownInput() we discard all further inbound data, but\n+            // keep reading to receive FIN from the remote peer.\n+            LOGGER.debug(\"{} Discarding further INBOUND\", channel);\n             state = unset(state, READ);\n-            ((DuplexChannel) channel).shutdownInput().addListener((ChannelFutureListener) this::onHalfClosed);\n+            channel.pipeline().fireUserEventTriggered(DiscardFurtherInboundEvent.INSTANCE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71a312d5741d1bc74214a3736893dc0d494a62b6"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcyODIwNQ==", "bodyText": "IN_SHUTDOWN may be a bit misleading, because it actually is not shutdown. IN_CLOSED is set when the input is shutdown.\nThe discard of input happens not only for graceful closure but also for other events, like protocol closing inbound/outbound, when we are not expecting more requests. Named it DiscardFurtherInboundEvent because it's kind of a request to discard without saying how exactly it should be discarded.\nHappy to rename, just looking for better alternatives...", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502728205", "createdAt": "2020-10-10T01:28:23Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -359,12 +399,49 @@ private void setSocketResetOnClose(final Channel channel) {\n         }\n     }\n \n+    private void serverCloseGracefully(final Channel channel) {\n+        // Perform half-closure as described in https://tools.ietf.org/html/rfc7230#section-6.6\n+        serverHalfCloseInbound(channel);\n+        serverHalfCloseOutbound(channel);\n+    }\n+\n     private void serverHalfCloseInbound(final Channel channel) {\n         assert !isClient;\n-        if (!has(state, IN_CLOSED) && channel instanceof DuplexChannel) {\n-            LOGGER.debug(\"{} Half-Closing INBOUND\", channel);\n+        if (!hasAny(state, DISCARDING_SERVER_INPUT, IN_CLOSED)) {\n+            // Instead of actual half-closure DuplexChannel.shutdownInput() we discard all further inbound data, but\n+            // keep reading to receive FIN from the remote peer.\n+            LOGGER.debug(\"{} Discarding further INBOUND\", channel);\n             state = unset(state, READ);\n-            ((DuplexChannel) channel).shutdownInput().addListener((ChannelFutureListener) this::onHalfClosed);\n+            channel.pipeline().fireUserEventTriggered(DiscardFurtherInboundEvent.INSTANCE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxMjIwMw=="}, "originalCommit": {"oid": "71a312d5741d1bc74214a3736893dc0d494a62b6"}, "originalPosition": 236}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0ODEwMTA5OnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQwMDowMDozMFrOHfbaYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQwMToyODoyNlrOHfcGEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxNzAyNw==", "bodyText": "not introduced by this PR but the control flow here is somewhat confusing. This method is called before the trailers are actually written, and eventually goes to WriteStreamSubscriber#channelOutboundClosed which calls sourceTerminated, which will complete the promise if activeWrites==0 but since we haven't written yet I assume that is never possible?", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502717027", "createdAt": "2020-10-10T00:00:30Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -162,7 +179,7 @@ public void protocolPayloadBeginOutbound(final ChannelHandlerContext ctx) {\n \n     @Override\n     public void protocolPayloadEndOutbound(final ChannelHandlerContext ctx) {\n-        if (isClient || (has(state, CLOSING) && pending == 0)) {\n+        if (isClient || (closeEvent != null && pending == 0)) {\n             ctx.pipeline().fireUserEventTriggered(OutboundDataEndEvent.INSTANCE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71a312d5741d1bc74214a3736893dc0d494a62b6"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcyODIwOQ==", "bodyText": "Agreed, the flow here is confusing. It was originally introduced in #919 and later improved (there was a bug) in #1155, according to the original logic from #919.\nIIUC this was done specifically for h2. The event is emitted before write, because netty closes the stream in write listener. But not sure if it need to be done in the same way for h1. I had an idea of how to simplify it by merging protocolPayloadEndOutbound and protocolPayloadEndOutboundSuccess together. Implementations of CloseHandler for h1 and h2 are anyway different. But did not have time to experiment. Decided to stop introducing more concurrent PRs for the same part of the codebase.", "url": "https://github.com/apple/servicetalk/pull/1141#discussion_r502728209", "createdAt": "2020-10-10T01:28:26Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/RequestResponseCloseHandler.java", "diffHunk": "@@ -162,7 +179,7 @@ public void protocolPayloadBeginOutbound(final ChannelHandlerContext ctx) {\n \n     @Override\n     public void protocolPayloadEndOutbound(final ChannelHandlerContext ctx) {\n-        if (isClient || (has(state, CLOSING) && pending == 0)) {\n+        if (isClient || (closeEvent != null && pending == 0)) {\n             ctx.pipeline().fireUserEventTriggered(OutboundDataEndEvent.INSTANCE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxNzAyNw=="}, "originalCommit": {"oid": "71a312d5741d1bc74214a3736893dc0d494a62b6"}, "originalPosition": 90}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2561, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}