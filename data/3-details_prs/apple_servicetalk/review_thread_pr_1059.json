{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwMzYzNDAx", "number": 1059, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMjozNzowNVrOD9_v0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMzo0MTo0OVrOD-bX3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzM0MTYyOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMjozNzowNVrOGX1C2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMjozNzowNVrOGX1C2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYzOTUxMg==", "bodyText": "nit: isEmpty() and removeFirst() can be combined into a single call:\n            Object maybeListener;\n            while ((maybeListener = listenersOnWriteBoundaries.pollFirst()) != null) {\n                if (maybeListener != WRITE_BOUNDARY) {\n                    notifyListener(future, maybeListener);\n                }\n            }", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427639512", "createdAt": "2020-05-19T22:37:05Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -420,6 +482,38 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n             }\n         }\n \n+        private void notifyAllListeners(@Nullable Throwable cause) {\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzM0NTMwOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMjozODo0MlrOGX1FBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMDo0ODoyNFrOGX3iww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MDA2OQ==", "bodyText": "did you consider random insertion or removal to be common (I'm assuming removeListener isn't frequently used)? if not consider ArrayDeque which has a lower constant memory overhead (LinkedList = 24 bytes per Node, ArrayDeque = backed by array).", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427640069", "createdAt": "2020-05-19T22:38:42Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -259,11 +265,61 @@ private void requestMoreIfRequired(@Nullable Subscription subscription) {\n         private byte state;\n         @Nullable\n         private Throwable failureCause;\n+        /**\n+         * This deque contains all added listeners within {@link #WRITE_BOUNDARY write boundaries}.\n+         * <pre>\n+         *     {@link #WRITE_BOUNDARY}, listener1, listener2, {@link #WRITE_BOUNDARY}, listener3 ...\n+         * </pre>\n+         * We assume that no listener for a write is added after that write is completed (a.k.a late listeners).\n+         */\n+        private final Deque<Object> listenersOnWriteBoundaries = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4MDQ1MQ==", "bodyText": "ArrayDeque SGTM", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427680451", "createdAt": "2020-05-20T00:48:24Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -259,11 +265,61 @@ private void requestMoreIfRequired(@Nullable Subscription subscription) {\n         private byte state;\n         @Nullable\n         private Throwable failureCause;\n+        /**\n+         * This deque contains all added listeners within {@link #WRITE_BOUNDARY write boundaries}.\n+         * <pre>\n+         *     {@link #WRITE_BOUNDARY}, listener1, listener2, {@link #WRITE_BOUNDARY}, listener3 ...\n+         * </pre>\n+         * We assume that no listener for a write is added after that write is completed (a.k.a late listeners).\n+         */\n+        private final Deque<Object> listenersOnWriteBoundaries = new LinkedList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MDA2OQ=="}, "originalCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzM2MTIzOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMjo0NTo1OFrOGX1O1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMDoxNjowOVrOGYiHuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MjU4MA==", "bodyText": "is it necessary to leave WRITE_BOUNDARY at the head of the queue?  if not we could simplify draining to just stop when null or we hit a WRITE_BOUNDARY\n            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n            Object maybeListener = listenersOnWriteBoundaries.poll();\n            while (maybeListener != null && maybeListener != WRITE_BOUNDARY) {\n                notifyListener(future, maybeListener);\n                maybeListener = listenersOnWriteBoundaries.poll();\n            }\nthe order of the WRITE_BOUNDRY addition relative to channel#write would have to change, not sure if that is a problem? It maybe safer to delineate the boundaries on the leading edge if there are any async listeners added before completion, but given the restrictions on the boundaries I'm not sure if that would be reliable from a sequencing perspective?\n            channel.write(msg, this);\n            if (listenersOnWriteBoundaries.peekLast() != WRITE_BOUNDARY) {\n                listenersOnWriteBoundaries.addLast(WRITE_BOUNDARY);\n            }", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427642580", "createdAt": "2020-05-19T22:45:58Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -420,6 +482,38 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n             }\n         }\n \n+        private void notifyAllListeners(@Nullable Throwable cause) {\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty()) {\n+                Object mayBeListener = listenersOnWriteBoundaries.removeFirst();\n+                if (mayBeListener != WRITE_BOUNDARY) {\n+                    notifyListener(future, mayBeListener);\n+                }\n+            }\n+        }\n+\n+        private void notifyListenersTillNextWrite(@Nullable Throwable cause) {\n+            Object shdBeWriteBoundary = listenersOnWriteBoundaries.removeFirst();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4MTU3MQ==", "bodyText": "Let me try this out, thanks", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427681571", "createdAt": "2020-05-20T00:52:44Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -420,6 +482,38 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n             }\n         }\n \n+        private void notifyAllListeners(@Nullable Throwable cause) {\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty()) {\n+                Object mayBeListener = listenersOnWriteBoundaries.removeFirst();\n+                if (mayBeListener != WRITE_BOUNDARY) {\n+                    notifyListener(future, mayBeListener);\n+                }\n+            }\n+        }\n+\n+        private void notifyListenersTillNextWrite(@Nullable Throwable cause) {\n+            Object shdBeWriteBoundary = listenersOnWriteBoundaries.removeFirst();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MjU4MA=="}, "originalCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwNzExMA==", "bodyText": "Ok doing this will have problems if the write completes synchronously with channel.write() call.\nlistenersOnWriteBoundaries <- empty\nchannel.write()\n   - addListener(listener1) => listenersOnWriteBoundaries (listener1)\n   - writeAndFlush() (internally in the pipeline) => drain  listenersOnWriteBoundaries <- empty\nadd WRITE_BOUNDARY to listenersOnWriteBoundaries\nchannel.write()\n    - addListener(listener2) => listenersOnWriteBoundaries (WRITE_BOUNDARY, listener2)\nflush()\nnotifyListenersTillNextWrite() <- removes WRITE_BOUNDARY and exits", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r428207110", "createdAt": "2020-05-20T18:04:56Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -420,6 +482,38 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n             }\n         }\n \n+        private void notifyAllListeners(@Nullable Throwable cause) {\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty()) {\n+                Object mayBeListener = listenersOnWriteBoundaries.removeFirst();\n+                if (mayBeListener != WRITE_BOUNDARY) {\n+                    notifyListener(future, mayBeListener);\n+                }\n+            }\n+        }\n+\n+        private void notifyListenersTillNextWrite(@Nullable Throwable cause) {\n+            Object shdBeWriteBoundary = listenersOnWriteBoundaries.removeFirst();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MjU4MA=="}, "originalCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwODA4Ng==", "bodyText": "I have replaced the early-return with an assert", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r428208086", "createdAt": "2020-05-20T18:06:38Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -420,6 +482,38 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n             }\n         }\n \n+        private void notifyAllListeners(@Nullable Throwable cause) {\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty()) {\n+                Object mayBeListener = listenersOnWriteBoundaries.removeFirst();\n+                if (mayBeListener != WRITE_BOUNDARY) {\n+                    notifyListener(future, mayBeListener);\n+                }\n+            }\n+        }\n+\n+        private void notifyListenersTillNextWrite(@Nullable Throwable cause) {\n+            Object shdBeWriteBoundary = listenersOnWriteBoundaries.removeFirst();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MjU4MA=="}, "originalCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3ODA0MA==", "bodyText": "good call on the re-entry! Here is a unit test for WriteStreamSubscriberFutureListenersTest to verify correctness here:\n    @Test\n    public void synchronousCompleteWrite() throws Exception {\n        Channel mockChannel = mock(Channel.class);\n        EventLoop mockEventLoop = mock(EventLoop.class);\n        when(mockEventLoop.inEventLoop()).thenReturn(true);\n        when(mockChannel.eventLoop()).thenReturn(mockEventLoop);\n        when(mockChannel.newSucceededFuture()).thenReturn(channel.newSucceededFuture());\n        doAnswer((Answer<Void>) invocation -> {\n            ReferenceCountUtil.release(invocation.getArgument(0));\n            ChannelFutureListener listener = mock(ChannelFutureListener.class);\n            listeners.add(listener);\n            ChannelPromise promise = invocation.getArgument(1);\n            promise.addListener(listener);\n            promise.setSuccess();\n            return null;\n        }).when(mockChannel).write(any(), any());\n        WriteDemandEstimator estimator = WriteDemandEstimators.newDefaultEstimator();\n        TestCompletableSubscriber completableSubscriber = new TestCompletableSubscriber();\n        WriteStreamSubscriber subscriber = new WriteStreamSubscriber(mockChannel, estimator, completableSubscriber,\n                UNSUPPORTED_PROTOCOL_CLOSE_HANDLER);\n        subscriber.onNext(1);\n        verifyListenerInvokedWithSuccess(listeners.take());\n        subscriber.onNext(2);\n        verifyListenerInvokedWithSuccess(listeners.take());\n    }", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r428378040", "createdAt": "2020-05-21T00:16:09Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -420,6 +482,38 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n             }\n         }\n \n+        private void notifyAllListeners(@Nullable Throwable cause) {\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty()) {\n+                Object mayBeListener = listenersOnWriteBoundaries.removeFirst();\n+                if (mayBeListener != WRITE_BOUNDARY) {\n+                    notifyListener(future, mayBeListener);\n+                }\n+            }\n+        }\n+\n+        private void notifyListenersTillNextWrite(@Nullable Throwable cause) {\n+            Object shdBeWriteBoundary = listenersOnWriteBoundaries.removeFirst();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MjU4MA=="}, "originalCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzM2ODYxOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMjo0OTozMFrOGX1TQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMDoyNzozN1rOGYiT2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MzcxMw==", "bodyText": "I see the we assume no late listener comment above but I'm wondering what the negative/costs would be of notifying listeners if they are late. Otherwise if this does happen we may not complete async control flow in some cases. We maybe able to delegate to super to manage notification, however not sure if this will bring up any notification ordering if folks add a listener in a re-entry fashion.", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427643713", "createdAt": "2020-05-19T22:49:30Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -259,11 +265,61 @@ private void requestMoreIfRequired(@Nullable Subscription subscription) {\n         private byte state;\n         @Nullable\n         private Throwable failureCause;\n+        /**\n+         * This deque contains all added listeners within {@link #WRITE_BOUNDARY write boundaries}.\n+         * <pre>\n+         *     {@link #WRITE_BOUNDARY}, listener1, listener2, {@link #WRITE_BOUNDARY}, listener3 ...\n+         * </pre>\n+         * We assume that no listener for a write is added after that write is completed (a.k.a late listeners).\n+         */\n+        private final Deque<Object> listenersOnWriteBoundaries = new LinkedList<>();\n \n         AllWritesPromise(final Channel channel) {\n             super(channel);\n         }\n \n+        @Override\n+        public ChannelPromise addListener(final GenericFutureListener<? extends Future<? super Void>> listener) {\n+            assert channel.eventLoop().inEventLoop();\n+            if (hasFlag(SUBSCRIBER_TERMINATED)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY2NDc4MQ==", "bodyText": "nit: consider simplifying code block to:\n            if (!hasFlag(SUBSCRIBER_TERMINATED)) {\n                listenersOnWriteBoundaries.addLast(listener);\n            }\n            return this;", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427664781", "createdAt": "2020-05-19T23:53:56Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -259,11 +265,61 @@ private void requestMoreIfRequired(@Nullable Subscription subscription) {\n         private byte state;\n         @Nullable\n         private Throwable failureCause;\n+        /**\n+         * This deque contains all added listeners within {@link #WRITE_BOUNDARY write boundaries}.\n+         * <pre>\n+         *     {@link #WRITE_BOUNDARY}, listener1, listener2, {@link #WRITE_BOUNDARY}, listener3 ...\n+         * </pre>\n+         * We assume that no listener for a write is added after that write is completed (a.k.a late listeners).\n+         */\n+        private final Deque<Object> listenersOnWriteBoundaries = new LinkedList<>();\n \n         AllWritesPromise(final Channel channel) {\n             super(channel);\n         }\n \n+        @Override\n+        public ChannelPromise addListener(final GenericFutureListener<? extends Future<? super Void>> listener) {\n+            assert channel.eventLoop().inEventLoop();\n+            if (hasFlag(SUBSCRIBER_TERMINATED)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MzcxMw=="}, "originalCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY4MDM1OQ==", "bodyText": "Re: late listeners\nWhat I was struggling with was that how do we distinguish between a late listener and a listener for the next write.", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427680359", "createdAt": "2020-05-20T00:47:59Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -259,11 +265,61 @@ private void requestMoreIfRequired(@Nullable Subscription subscription) {\n         private byte state;\n         @Nullable\n         private Throwable failureCause;\n+        /**\n+         * This deque contains all added listeners within {@link #WRITE_BOUNDARY write boundaries}.\n+         * <pre>\n+         *     {@link #WRITE_BOUNDARY}, listener1, listener2, {@link #WRITE_BOUNDARY}, listener3 ...\n+         * </pre>\n+         * We assume that no listener for a write is added after that write is completed (a.k.a late listeners).\n+         */\n+        private final Deque<Object> listenersOnWriteBoundaries = new LinkedList<>();\n \n         AllWritesPromise(final Channel channel) {\n             super(channel);\n         }\n \n+        @Override\n+        public ChannelPromise addListener(final GenericFutureListener<? extends Future<? super Void>> listener) {\n+            assert channel.eventLoop().inEventLoop();\n+            if (hasFlag(SUBSCRIBER_TERMINATED)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MzcxMw=="}, "originalCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM4MDAzNw==", "bodyText": "how do we distinguish between a late listener and a listener for the next write.\n\nThis is a good point, I guess we really can't. Now that we are tracking listeners for individual write operations I wonder if AllWritesPromise still makes sense? An alternative would be to allocate new promises and have a shared listener that counts success/failures and manages the state ... wdyt?", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r428380037", "createdAt": "2020-05-21T00:23:33Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -259,11 +265,61 @@ private void requestMoreIfRequired(@Nullable Subscription subscription) {\n         private byte state;\n         @Nullable\n         private Throwable failureCause;\n+        /**\n+         * This deque contains all added listeners within {@link #WRITE_BOUNDARY write boundaries}.\n+         * <pre>\n+         *     {@link #WRITE_BOUNDARY}, listener1, listener2, {@link #WRITE_BOUNDARY}, listener3 ...\n+         * </pre>\n+         * We assume that no listener for a write is added after that write is completed (a.k.a late listeners).\n+         */\n+        private final Deque<Object> listenersOnWriteBoundaries = new LinkedList<>();\n \n         AllWritesPromise(final Channel channel) {\n             super(channel);\n         }\n \n+        @Override\n+        public ChannelPromise addListener(final GenericFutureListener<? extends Future<? super Void>> listener) {\n+            assert channel.eventLoop().inEventLoop();\n+            if (hasFlag(SUBSCRIBER_TERMINATED)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MzcxMw=="}, "originalCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM4MTE0Ng==", "bodyText": "Ya creating new promises is what I thought initially but since it has perf implications, I decided to not make such a drastic change.", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r428381146", "createdAt": "2020-05-21T00:27:37Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -259,11 +265,61 @@ private void requestMoreIfRequired(@Nullable Subscription subscription) {\n         private byte state;\n         @Nullable\n         private Throwable failureCause;\n+        /**\n+         * This deque contains all added listeners within {@link #WRITE_BOUNDARY write boundaries}.\n+         * <pre>\n+         *     {@link #WRITE_BOUNDARY}, listener1, listener2, {@link #WRITE_BOUNDARY}, listener3 ...\n+         * </pre>\n+         * We assume that no listener for a write is added after that write is completed (a.k.a late listeners).\n+         */\n+        private final Deque<Object> listenersOnWriteBoundaries = new LinkedList<>();\n \n         AllWritesPromise(final Channel channel) {\n             super(channel);\n         }\n \n+        @Override\n+        public ChannelPromise addListener(final GenericFutureListener<? extends Future<? super Void>> listener) {\n+            assert channel.eventLoop().inEventLoop();\n+            if (hasFlag(SUBSCRIBER_TERMINATED)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MzcxMw=="}, "originalCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzQ5ODk1OnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMzo1MToyOVrOGX2iog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxODoyNTowNlrOGYYYzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY2NDAzNA==", "bodyText": "nit: consider making this method static", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427664034", "createdAt": "2020-05-19T23:51:29Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -420,6 +480,39 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n             }\n         }\n \n+        private void notifyAllListeners(@Nullable Throwable cause) {\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty()) {\n+                Object mayBeListener = listenersOnWriteBoundaries.removeFirst();\n+                if (mayBeListener != WRITE_BOUNDARY) {\n+                    notifyListener(future, mayBeListener);\n+                }\n+            }\n+        }\n+\n+        private void notifyListenersTillNextWrite(@Nullable Throwable cause) {\n+            assert !listenersOnWriteBoundaries.isEmpty();\n+            Object shdBeWriteBoundary = listenersOnWriteBoundaries.removeFirst();\n+            if (shdBeWriteBoundary != WRITE_BOUNDARY) {\n+                return;\n+            }\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty() && listenersOnWriteBoundaries.peekFirst() != WRITE_BOUNDARY) {\n+                Object shdBeListener = listenersOnWriteBoundaries.removeFirst();\n+                notifyListener(future, shdBeListener);\n+            }\n+        }\n+\n+        @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+        private void notifyListener(final ChannelFuture future, final Object shdBeListener) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84517e5c0193fc159116ca4134faf42f1fdbba9a"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIxODU3Mg==", "bodyText": "Actually, this made me notice that I can use DefaultPromise.notifyListener()  which provides stack overflow protection \ud83c\udf89", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r428218572", "createdAt": "2020-05-20T18:25:06Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -420,6 +480,39 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n             }\n         }\n \n+        private void notifyAllListeners(@Nullable Throwable cause) {\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty()) {\n+                Object mayBeListener = listenersOnWriteBoundaries.removeFirst();\n+                if (mayBeListener != WRITE_BOUNDARY) {\n+                    notifyListener(future, mayBeListener);\n+                }\n+            }\n+        }\n+\n+        private void notifyListenersTillNextWrite(@Nullable Throwable cause) {\n+            assert !listenersOnWriteBoundaries.isEmpty();\n+            Object shdBeWriteBoundary = listenersOnWriteBoundaries.removeFirst();\n+            if (shdBeWriteBoundary != WRITE_BOUNDARY) {\n+                return;\n+            }\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty() && listenersOnWriteBoundaries.peekFirst() != WRITE_BOUNDARY) {\n+                Object shdBeListener = listenersOnWriteBoundaries.removeFirst();\n+                notifyListener(future, shdBeListener);\n+            }\n+        }\n+\n+        @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+        private void notifyListener(final ChannelFuture future, final Object shdBeListener) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY2NDAzNA=="}, "originalCommit": {"oid": "84517e5c0193fc159116ca4134faf42f1fdbba9a"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Mzk2MDAxOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwNDozNTo1NFrOGX68UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxODo0ODoxMFrOGYZZfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczNjE0NQ==", "bodyText": "Consider making this a GenericFutureListener. This was can tighten up the generics for the queue.", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427736145", "createdAt": "2020-05-20T04:35:54Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -67,6 +72,7 @@\n  */\n final class WriteStreamSubscriber implements PublisherSource.Subscriber<Object>, ChannelOutboundListener, Cancellable {\n     private static final Logger LOGGER = LoggerFactory.getLogger(WriteStreamSubscriber.class);\n+    private static final Object WRITE_BOUNDARY = new Object();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84517e5c0193fc159116ca4134faf42f1fdbba9a"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIzNTEzNA==", "bodyText": "good call", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r428235134", "createdAt": "2020-05-20T18:48:10Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -67,6 +72,7 @@\n  */\n final class WriteStreamSubscriber implements PublisherSource.Subscriber<Object>, ChannelOutboundListener, Cancellable {\n     private static final Logger LOGGER = LoggerFactory.getLogger(WriteStreamSubscriber.class);\n+    private static final Object WRITE_BOUNDARY = new Object();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczNjE0NQ=="}, "originalCommit": {"oid": "84517e5c0193fc159116ca4134faf42f1fdbba9a"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Nzg2NzgxOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMzo0MTo0OVrOGYhhGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMzo0MTo0OVrOGYhhGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM2ODE1NA==", "bodyText": "removeFirst() -> pollFirst() (you have already verified there is an item in the queue, you can avoid the null check/exception from remove* method)", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r428368154", "createdAt": "2020-05-20T23:41:49Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -420,6 +481,26 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n             }\n         }\n \n+        private void notifyAllListeners(@Nullable Throwable cause) {\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            GenericFutureListener<?> mayBeListener;\n+            while ((mayBeListener = listenersOnWriteBoundaries.pollFirst()) != null) {\n+                if (mayBeListener != WRITE_BOUNDARY) {\n+                    notifyListener(eventLoop, future, mayBeListener);\n+                }\n+            }\n+        }\n+\n+        private void notifyListenersTillNextWrite(@Nullable Throwable cause) {\n+            Object shdBeWriteBoundary = listenersOnWriteBoundaries.pollFirst();\n+            assert shdBeWriteBoundary == WRITE_BOUNDARY;\n+\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty() && listenersOnWriteBoundaries.peekFirst() != WRITE_BOUNDARY) {\n+                notifyListener(eventLoop, future, listenersOnWriteBoundaries.removeFirst());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cea4eb2599b9e55326573bfb559d71c0d75e7e5"}, "originalPosition": 134}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2757, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}