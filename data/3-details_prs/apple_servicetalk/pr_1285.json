{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyMjM0NjU2", "number": 1285, "title": "Handle `close_notify` TLS alert", "bodyText": "Motivation:\nTLS protocol defined close_notify alert message [1], which notifies that the\nsender will not send any more messages on this connection. SslHandler\ngenerates SslCloseCompletionEvent in this case, then transport emits\nChannelInputShutdownReadComplete event when the FIN is received. There is a\nrace between these 2 user events and sending a new request on the client-side.\nWe MUST close down the connection immediately, discarding any pending writes,\nand preventing new requests. We should also mark that the connection is\nclosing asap to prevent LB from selecting this connection.\n\nhttps://tools.ietf.org/html/rfc5246#section-7.2.1\n\nModifications:\n\nHandle SslCloseCompletionEvent in DefaultNettyConnection;\nAdd tests to verify client and server behavior when SslCloseCompletionEvent\nis received;\n\nResult:\nThe connection transitions to the \"closing\" state as soon as the\nSslCloseCompletionEvent is observed, preventing new writes on this connection\nand failing the first write, making failures retryable.", "createdAt": "2020-12-18T01:41:04Z", "url": "https://github.com/apple/servicetalk/pull/1285", "merged": true, "mergeCommit": {"oid": "142534d37367b975c3000a164eb0c2ed5e6f41cf"}, "closed": true, "closedAt": "2020-12-18T22:12:36Z", "author": {"login": "idelpivnitskiy"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdnOJ2tgFqTU1NTExODY1OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdnfoZoAFqTU1NTg0NDMzNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MTE4NjU4", "url": "https://github.com/apple/servicetalk/pull/1285#pullrequestreview-555118658", "createdAt": "2020-12-18T01:47:43Z", "commit": {"oid": "acf2139a663319fe53eabdc0a80a0bc82e360a97"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMTo0Nzo0M1rOIIP5fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMTo0OTozOFrOIIP8Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUxOTk5OQ==", "bodyText": "@Scottmitch as we discussed here, I will submit a PR to rename it to StepVerifiers.\nI will keep it without static import. In the context of PublisherStepVerifierTest, create(from(\"foo\", \"bar\")) looks ok. But when the test is related to some business logic, things like create(conn.read()) are a bit confusing. Not clear what are we creating. Something like Verifiers.stepVerifier(...) might be a better option.", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545519999", "createdAt": "2020-12-18T01:47:43Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/test/java/io/servicetalk/transport/netty/internal/SslCloseNotifyAlertClientHandlingTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.test.FirstSteps;\n+\n+import org.junit.Test;\n+\n+import java.nio.channels.ClosedChannelException;\n+\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+\n+public class SslCloseNotifyAlertClientHandlingTest extends AbstractSslCloseNotifyAlertHandlingTest {\n+\n+    public SslCloseNotifyAlertClientHandlingTest() throws Exception {\n+        super(true);\n+    }\n+\n+    @Test\n+    public void afterExchangeIdleConnection() {\n+        sendRequest();\n+        FirstSteps.create(conn.read())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf2139a663319fe53eabdc0a80a0bc82e360a97"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyMDY4Nw==", "bodyText": "It looks enough for me to call closeHandler.closeChannelOutbound here. It will generate ChannelOutputShutdownEvent, triggering channelOutboundListener.channelClosed. WDYT?", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545520687", "createdAt": "2020-12-18T01:49:38Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -641,8 +642,17 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n                 connection.closeHandler.channelClosedOutbound(ctx);\n                 connection.channelOutboundListener.channelClosed(StacklessClosedChannelException.newInstance(\n                         DefaultNettyConnection.class, \"userEventTriggered(ChannelOutputShutdownEvent)\"));\n+            } else if (evt == SslCloseCompletionEvent.SUCCESS) {\n+                // Received \"close_notify\" alert from the peer: https://tools.ietf.org/html/rfc5246#section-7.2.1.\n+                // This message notifies that the sender will not send any more messages on this connection.\n+\n+                // Notify close handler first to enhance error reporting and prevent LB from selecting this connection\n+                connection.closeHandler.channelClosedInbound(ctx);\n+                // We MUST respond with a \"close_notify\" alert and close down the connection immediately,\n+                // discarding any pending writes.\n+                connection.closeHandler.closeChannelOutbound(ctx.channel());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf2139a663319fe53eabdc0a80a0bc82e360a97"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MTIwMTI0", "url": "https://github.com/apple/servicetalk/pull/1285#pullrequestreview-555120124", "createdAt": "2020-12-18T01:52:05Z", "commit": {"oid": "acf2139a663319fe53eabdc0a80a0bc82e360a97"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMTo1MjowNVrOIIP_Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMTo1MjowNVrOIIP_Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyMTQzMA==", "bodyText": "An example of when FirstSteps.create overloads for sources are useful. It's a bit annoying to use fromSource everywhere.", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545521430", "createdAt": "2020-12-18T01:52:05Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/test/java/io/servicetalk/transport/netty/internal/SslCloseNotifyAlertClientHandlingTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.test.FirstSteps;\n+\n+import org.junit.Test;\n+\n+import java.nio.channels.ClosedChannelException;\n+\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+\n+public class SslCloseNotifyAlertClientHandlingTest extends AbstractSslCloseNotifyAlertHandlingTest {\n+\n+    public SslCloseNotifyAlertClientHandlingTest() throws Exception {\n+        super(true);\n+    }\n+\n+    @Test\n+    public void afterExchangeIdleConnection() {\n+        sendRequest();\n+        FirstSteps.create(conn.read())\n+                .then(() -> channel.writeInbound(BEGIN))\n+                .expectNext(BEGIN)\n+                .then(() -> channel.writeInbound(END))\n+                .expectNext(END)\n+                .expectComplete()\n+                .verify();\n+        closeNotifyAndVerifyClosing();\n+    }\n+\n+    @Test\n+    public void afterRequestBeforeReadingResponse() {\n+        sendRequest();\n+        FirstSteps.create(conn.read())\n+                .then(this::closeNotifyAndVerifyClosing)\n+                .expectError(ClosedChannelException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void afterRequestWhileReadingResponse() {\n+        sendRequest();\n+        FirstSteps.create(conn.read())\n+                .then(() -> channel.writeInbound(BEGIN))\n+                .expectNext(BEGIN)\n+                .then(this::closeNotifyAndVerifyClosing)\n+                .expectError(ClosedChannelException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void whileWritingRequestBeforeReadingResponse() {\n+        PublisherSource.Processor<String, String> writeSource = newPublisherProcessor();\n+        FirstSteps.create(conn.write(fromSource(writeSource)).merge(conn.read()))\n+                .then(() -> {\n+                    // Start writing request\n+                    writeMsg(writeSource, BEGIN);\n+                    closeNotifyAndVerifyClosing();\n+                })\n+                .expectError(ClosedChannelException.class)\n+                .verify();\n+    }\n+\n+    @Test\n+    public void whileWritingRequestAndReadingResponse() {\n+        PublisherSource.Processor<String, String> writeSource = newPublisherProcessor();\n+        FirstSteps.create(conn.write(fromSource(writeSource)).merge(conn.read()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf2139a663319fe53eabdc0a80a0bc82e360a97"}, "originalPosition": 83}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a7a61cd360f4e8bf8e9733889d1bd82f45b6c3d", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/1a7a61cd360f4e8bf8e9733889d1bd82f45b6c3d", "committedDate": "2020-12-18T02:33:14Z", "message": "Handle `close_notify` TLS alert\n\nMotivation:\n\nTLS protocol defined `close_notify` alert message [1], which notifies that the\nsender will not send any more messages on this connection. `SslHandler`\ngenerates `SslCloseCompletionEvent` in this case, then transport emits\n`ChannelInputShutdownReadComplete` event when the FIN is received. There is a\nrace between these 2 user events and sending a new request on the client-side.\nWe MUST close down the connection immediately, discarding any pending writes,\nand preventing new requests. We should also mark that the connection is\nclosing asap to prevent LB from selecting this connection.\n\n1. https://tools.ietf.org/html/rfc5246#section-7.2.1\n\nModifications:\n\n- Handle `SslCloseCompletionEvent` in `DefaultNettyConnection`;\n- Add tests to verify client and server behavior when `SslCloseCompletionEvent`\nis received;\n\nResult:\n\nThe connection transitions to the \"closing\" state as soon as the\n`SslCloseCompletionEvent` is observed, preventing new writes on this connection\nand failing the first write, making failures retryable."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25568178150c9dcc82df432976bb9f752e50e250", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/25568178150c9dcc82df432976bb9f752e50e250", "committedDate": "2020-12-18T02:34:12Z", "message": "Rename `FirstSteps` -> `StepVerifiers`"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "acf2139a663319fe53eabdc0a80a0bc82e360a97", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/acf2139a663319fe53eabdc0a80a0bc82e360a97", "committedDate": "2020-12-18T01:39:59Z", "message": "Handle `close_notify` TLS alert\n\nMotivation:\n\nTLS protocol defined `close_notify` alert message [1], which notifies that the\nsender will not send any more messages on this connection. `SslHandler`\ngenerates `SslCloseCompletionEvent` in this case, then transport emits\n`ChannelInputShutdownReadComplete` event when the FIN is received. There is a\nrace between these 2 user events and sending a new request on the client-side.\nWe MUST close down the connection immediately, discarding any pending writes,\nand preventing new requests. We should also mark that the connection is\nclosing asap to prevent LB from selecting this connection.\n\n1. https://tools.ietf.org/html/rfc5246#section-7.2.1\n\nModifications:\n\n- Handle `SslCloseCompletionEvent` in `DefaultNettyConnection`;\n- Add tests to verify client and server behavior when `SslCloseCompletionEvent`\nis received;\n\nResult:\n\nThe connection transitions to the \"closing\" state as soon as the\n`SslCloseCompletionEvent` is observed, preventing new writes on this connection\nand failing the first write, making failures retryable."}, "afterCommit": {"oid": "25568178150c9dcc82df432976bb9f752e50e250", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/25568178150c9dcc82df432976bb9f752e50e250", "committedDate": "2020-12-18T02:34:12Z", "message": "Rename `FirstSteps` -> `StepVerifiers`"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MTM1NTcw", "url": "https://github.com/apple/servicetalk/pull/1285#pullrequestreview-555135570", "createdAt": "2020-12-18T02:40:39Z", "commit": {"oid": "25568178150c9dcc82df432976bb9f752e50e250"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMjo0MDozOVrOIIQ5yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMzoxNjozNlrOIIRiQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUzNjQ1Nw==", "bodyText": "this is the first time we are introducing multiple calls to channelClosedInbound. consider clarifying in the API docs that the method is idempotent.", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545536457", "createdAt": "2020-12-18T02:40:39Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -641,8 +642,17 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n                 connection.closeHandler.channelClosedOutbound(ctx);\n                 connection.channelOutboundListener.channelClosed(StacklessClosedChannelException.newInstance(\n                         DefaultNettyConnection.class, \"userEventTriggered(ChannelOutputShutdownEvent)\"));\n+            } else if (evt == SslCloseCompletionEvent.SUCCESS) {\n+                // Received \"close_notify\" alert from the peer: https://tools.ietf.org/html/rfc5246#section-7.2.1.\n+                // This message notifies that the sender will not send any more messages on this connection.\n+\n+                // Notify close handler first to enhance error reporting and prevent LB from selecting this connection\n+                connection.closeHandler.channelClosedInbound(ctx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25568178150c9dcc82df432976bb9f752e50e250"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU0MDUxMw==", "bodyText": "looks like the CloseHandler owns the responsibility of calling shutdownOutput() and the associated state machine around it. for H2 this will currently close the channel more abruptly with close() which may mean the local peer won't finish sending currently buffered/pending data. despite the spec saying close down the connection immediately, discarding any pending writes.we can make a best effort to flush our queues without losing much...\n         @Override\n         void closeChannelOutbound(final Channel channel) {\n-            channel.close();\n+            channel.writeAndFlush(EmptyBuffer.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE);\n         }\nwe may want to inject a similar event at the ServiceTalk layer to catch any inflight signals (which maybe offloaded). however we wouldn't want lack of demand (or cancellation) to prevent the cleanup process (so maybe not worth the trouble). it would be good to test this at the protocol layer as I recall similar misses in Netty.", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545540513", "createdAt": "2020-12-18T02:53:51Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -641,8 +642,17 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n                 connection.closeHandler.channelClosedOutbound(ctx);\n                 connection.channelOutboundListener.channelClosed(StacklessClosedChannelException.newInstance(\n                         DefaultNettyConnection.class, \"userEventTriggered(ChannelOutputShutdownEvent)\"));\n+            } else if (evt == SslCloseCompletionEvent.SUCCESS) {\n+                // Received \"close_notify\" alert from the peer: https://tools.ietf.org/html/rfc5246#section-7.2.1.\n+                // This message notifies that the sender will not send any more messages on this connection.\n+\n+                // Notify close handler first to enhance error reporting and prevent LB from selecting this connection\n+                connection.closeHandler.channelClosedInbound(ctx);\n+                // We MUST respond with a \"close_notify\" alert and close down the connection immediately,\n+                // discarding any pending writes.\n+                connection.closeHandler.closeChannelOutbound(ctx.channel());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyMDY4Nw=="}, "originalCommit": {"oid": "acf2139a663319fe53eabdc0a80a0bc82e360a97"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU0MTA5OQ==", "bodyText": "hooray for new test utilities \ud83c\udf89\nnit: use static import?", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545541099", "createdAt": "2020-12-18T02:55:50Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/test/java/io/servicetalk/transport/netty/internal/AbstractSslCloseNotifyAlertHandlingTest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright \u00a9 2018-2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.test.StepVerifiers;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.logging.api.LogLevel;\n+import io.servicetalk.transport.api.ConnectionInfo.Protocol;\n+import io.servicetalk.transport.netty.internal.NoopTransportObserver.NoopConnectionObserver;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.ssl.SslCloseCompletionEvent;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import static io.servicetalk.buffer.netty.BufferAllocators.DEFAULT_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Executors.immediate;\n+import static io.servicetalk.transport.netty.internal.CloseHandler.forPipelinedRequestResponse;\n+import static io.servicetalk.transport.netty.internal.FlushStrategies.defaultFlushStrategy;\n+import static io.servicetalk.transport.netty.internal.OffloadAllExecutionStrategy.OFFLOAD_ALL_STRATEGY;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+\n+abstract class AbstractSslCloseNotifyAlertHandlingTest {\n+\n+    private static final WireLoggingInitializer WIRE_LOGGING_INITIALIZER =\n+            new WireLoggingInitializer(\"servicetalk-tests-wire-logger\", LogLevel.TRACE, () -> true);\n+\n+    protected static final String BEGIN = \"MSG_BEGIN\";\n+    protected static final String END = \"MSG_END\";\n+\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    protected final EmbeddedDuplexChannel channel;\n+    protected final DefaultNettyConnection<String, String> conn;\n+\n+    AbstractSslCloseNotifyAlertHandlingTest(boolean isClient) throws Exception {\n+        channel = new EmbeddedDuplexChannel(false);\n+        final CloseHandler closeHandler = forPipelinedRequestResponse(isClient, channel.config());\n+        conn = DefaultNettyConnection.<String, String>initChannel(channel, DEFAULT_ALLOCATOR, immediate(),\n+                END::equals, closeHandler, defaultFlushStrategy(), null,\n+                WIRE_LOGGING_INITIALIZER.andThen(ch -> ch.pipeline().addLast(new ChannelDuplexHandler() {\n+                    @Override\n+                    public void channelRead(final ChannelHandlerContext ctx, final Object msg) {\n+                        if (BEGIN.equals(msg)) {\n+                            closeHandler.protocolPayloadBeginInbound(ctx);\n+                        }\n+                        ctx.fireChannelRead(msg);\n+                        if (END.equals(msg)) {\n+                            closeHandler.protocolPayloadEndInbound(ctx);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void write(final ChannelHandlerContext ctx, final Object msg, final ChannelPromise promise) {\n+                        if (BEGIN.equals(msg)) {\n+                            closeHandler.protocolPayloadBeginOutbound(ctx);\n+                        }\n+                        if (END.equals(msg)) {\n+                            closeHandler.protocolPayloadEndOutbound(ctx);\n+                            promise.addListener(f -> {\n+                                if (f.isSuccess()) {\n+                                    closeHandler.protocolPayloadEndOutboundSuccess(ctx);\n+                                }\n+                            });\n+                        }\n+                        ctx.write(msg, promise);\n+                    }\n+                })), OFFLOAD_ALL_STRATEGY, mock(Protocol.class), NoopConnectionObserver.INSTANCE, isClient)\n+                .toFuture().get();\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        try {\n+            // Make sure the connection and channel are closed after each test:\n+            assertThat(\"Underlying Channel is not closed\", channel.isOpen(), is(false));\n+            assertThat(\"Unexpected inbound messages\", channel.inboundMessages(), hasSize(0));\n+            assertThat(\"Unexpected outbound messages\", channel.outboundMessages(), hasSize(0));\n+            StepVerifiers.create(conn.onClose()).expectComplete().verify();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25568178150c9dcc82df432976bb9f752e50e250"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU0MTcxNw==", "bodyText": "OFFLOAD_ALL_STRATEGY -> consider parameterizing to cover different cases (specifically no-offload).", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545541717", "createdAt": "2020-12-18T02:57:56Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/test/java/io/servicetalk/transport/netty/internal/AbstractSslCloseNotifyAlertHandlingTest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+ * Copyright \u00a9 2018-2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.test.StepVerifiers;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.logging.api.LogLevel;\n+import io.servicetalk.transport.api.ConnectionInfo.Protocol;\n+import io.servicetalk.transport.netty.internal.NoopTransportObserver.NoopConnectionObserver;\n+\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.ssl.SslCloseCompletionEvent;\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import static io.servicetalk.buffer.netty.BufferAllocators.DEFAULT_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Executors.immediate;\n+import static io.servicetalk.transport.netty.internal.CloseHandler.forPipelinedRequestResponse;\n+import static io.servicetalk.transport.netty.internal.FlushStrategies.defaultFlushStrategy;\n+import static io.servicetalk.transport.netty.internal.OffloadAllExecutionStrategy.OFFLOAD_ALL_STRATEGY;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+\n+abstract class AbstractSslCloseNotifyAlertHandlingTest {\n+\n+    private static final WireLoggingInitializer WIRE_LOGGING_INITIALIZER =\n+            new WireLoggingInitializer(\"servicetalk-tests-wire-logger\", LogLevel.TRACE, () -> true);\n+\n+    protected static final String BEGIN = \"MSG_BEGIN\";\n+    protected static final String END = \"MSG_END\";\n+\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    protected final EmbeddedDuplexChannel channel;\n+    protected final DefaultNettyConnection<String, String> conn;\n+\n+    AbstractSslCloseNotifyAlertHandlingTest(boolean isClient) throws Exception {\n+        channel = new EmbeddedDuplexChannel(false);\n+        final CloseHandler closeHandler = forPipelinedRequestResponse(isClient, channel.config());\n+        conn = DefaultNettyConnection.<String, String>initChannel(channel, DEFAULT_ALLOCATOR, immediate(),\n+                END::equals, closeHandler, defaultFlushStrategy(), null,\n+                WIRE_LOGGING_INITIALIZER.andThen(ch -> ch.pipeline().addLast(new ChannelDuplexHandler() {\n+                    @Override\n+                    public void channelRead(final ChannelHandlerContext ctx, final Object msg) {\n+                        if (BEGIN.equals(msg)) {\n+                            closeHandler.protocolPayloadBeginInbound(ctx);\n+                        }\n+                        ctx.fireChannelRead(msg);\n+                        if (END.equals(msg)) {\n+                            closeHandler.protocolPayloadEndInbound(ctx);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public void write(final ChannelHandlerContext ctx, final Object msg, final ChannelPromise promise) {\n+                        if (BEGIN.equals(msg)) {\n+                            closeHandler.protocolPayloadBeginOutbound(ctx);\n+                        }\n+                        if (END.equals(msg)) {\n+                            closeHandler.protocolPayloadEndOutbound(ctx);\n+                            promise.addListener(f -> {\n+                                if (f.isSuccess()) {\n+                                    closeHandler.protocolPayloadEndOutboundSuccess(ctx);\n+                                }\n+                            });\n+                        }\n+                        ctx.write(msg, promise);\n+                    }\n+                })), OFFLOAD_ALL_STRATEGY, mock(Protocol.class), NoopConnectionObserver.INSTANCE, isClient)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25568178150c9dcc82df432976bb9f752e50e250"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTU0NjgxOQ==", "bodyText": "can you add a test case that verifies a Retryable exception is delivered if the first write fails due to prior close_notify being received?", "url": "https://github.com/apple/servicetalk/pull/1285#discussion_r545546819", "createdAt": "2020-12-18T03:16:36Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/test/java/io/servicetalk/transport/netty/internal/SslCloseNotifyAlertClientHandlingTest.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.test.StepVerifiers;\n+\n+import org.junit.Test;\n+\n+import java.nio.channels.ClosedChannelException;\n+\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessor;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+\n+public class SslCloseNotifyAlertClientHandlingTest extends AbstractSslCloseNotifyAlertHandlingTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25568178150c9dcc82df432976bb9f752e50e250"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d11b597fed6a619a2bef804a93afedfd444ef61", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/3d11b597fed6a619a2bef804a93afedfd444ef61", "committedDate": "2020-12-18T10:09:29Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1ODQ0MzM3", "url": "https://github.com/apple/servicetalk/pull/1285#pullrequestreview-555844337", "createdAt": "2020-12-18T22:11:28Z", "commit": {"oid": "3d11b597fed6a619a2bef804a93afedfd444ef61"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3399, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}