{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4Mjg4MDE5", "number": 1001, "title": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans", "bodyText": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\nMotivation:\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\nModifications:\n\nModifying ZipkinPublisher to report spans to a Reporter interface.\nMoving the UDP implementation out to a UdpReporter\n\nResult:\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets.", "createdAt": "2020-04-03T17:07:07Z", "url": "https://github.com/apple/servicetalk/pull/1001", "merged": true, "mergeCommit": {"oid": "33a69b6ccf59e71f8f78dd6097ef555db3630a98"}, "closed": true, "closedAt": "2020-04-07T22:42:00Z", "author": {"login": "colestanfield"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcUFO_aAFqTM4NzQ2MTIzNQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcVaSiIABqjMyMTE3MTU5NzQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NDYxMjM1", "url": "https://github.com/apple/servicetalk/pull/1001#pullrequestreview-387461235", "createdAt": "2020-04-03T17:48:34Z", "commit": {"oid": "c338f88e64d8f0ca9277e32f6951a8cb24187014"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNzo0ODozNFrOGAgxIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxODozMDowMlrOGAi9fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5MDA0OQ==", "bodyText": "We do not use Optional anywhere else, can we make localAddress @Nullable instead?", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403190049", "createdAt": "2020-04-03T17:48:34Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -164,29 +84,7 @@ public Builder collectorAddress(SocketAddress collectorAddress) {\n          * @return this.\n          */\n         public Builder localAddress(InetSocketAddress localAddress) {\n-            this.localAddress = localAddress;\n-            return this;\n-        }\n-\n-        /**\n-         * Configures the format.\n-         *\n-         * @param encoder the {@link Encoder} to use.\n-         * @return this.\n-         */\n-        public Builder encoder(Encoder encoder) {\n-            this.encoder = requireNonNull(encoder);\n-            return this;\n-        }\n-\n-        /**\n-         * Configures the transport.\n-         *\n-         * @param transport the {@link Transport} to use.\n-         * @return this.\n-         */\n-        public Builder protocol(Transport transport) {\n-            this.transport = requireNonNull(transport);\n+            this.localAddress = Optional.of(requireNonNull(localAddress));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c338f88e64d8f0ca9277e32f6951a8cb24187014"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5MjMxNg==", "bodyText": "Javadocs on this method are outdated as we do not create a channel here.", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403192316", "createdAt": "2020-04-03T17:51:00Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -195,61 +93,32 @@ public Builder protocol(Transport transport) {\n          * @return An interface which can publish tracing data using the zipkin API.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c338f88e64d8f0ca9277e32f6951a8cb24187014"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5MzQxMw==", "bodyText": "As this class requires a Reporter, we should make it explicit by taking Reporter<Span> as an argument in the build() method. Users can pass in a noop/logging reporter if they like.", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403193413", "createdAt": "2020-04-03T17:52:17Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -195,61 +93,32 @@ public Builder protocol(Transport transport) {\n          * @return An interface which can publish tracing data using the zipkin API.\n          */\n         public ZipkinPublisher build() {\n-            return new ZipkinPublisher(serviceName, collectorAddress, localAddress, encoder, transport);\n-        }\n-    }\n-\n-    private ZipkinPublisher(String serviceName,\n-                            SocketAddress collectorAddress,\n-                            @Nullable InetSocketAddress localAddress,\n-                            Encoder encoder,\n-                            Transport transport) {\n-        requireNonNull(serviceName);\n-        requireNonNull(collectorAddress);\n-        requireNonNull(encoder);\n-        requireNonNull(transport);\n-\n-        endpoint = buildEndpoint(serviceName, localAddress);\n-\n-        group = createEventLoopGroup(1, new DefaultThreadFactory(\"zipkin-publisher\", true));\n-        try {\n-            final Bootstrap bootstrap = transport.buildBootstrap(group, encoder, collectorAddress);\n-            channel = bootstrap.bind(0).sync().channel();\n-        } catch (InterruptedException e) {\n-            currentThread().interrupt(); // Reset the interrupted flag.\n-            throw new IllegalStateException(\"Failed to create \" + transport + \" client\");\n-        } catch (Exception e) {\n-            logger.warn(\"Failed to create {} client\", transport, e);\n-            group.shutdownGracefully(0, 0, SECONDS);\n-            throw e;\n+            if (reporter == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c338f88e64d8f0ca9277e32f6951a8cb24187014"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NTQ5NA==", "bodyText": "Consider moving these non-null checks closer to where they are accepted from the user, i.e. in the Builder", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403195494", "createdAt": "2020-04-03T17:54:33Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -19,141 +19,61 @@\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n+import java.util.Optional;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n \n /**\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n public final class ZipkinPublisher implements InMemorySpanEventListener, Closeable {\n-    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n-    /**\n-     * The default maximum {@link DatagramPacket} size.\n-     */\n-    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048;\n-    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n-            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n+    private final Reporter<Span> reporter;\n     private final Endpoint endpoint;\n-    private final EventLoopGroup group;\n-    private final Channel channel;\n-\n-    /**\n-     * The serialization format for the zipkin write format data.\n-     */\n-    public enum Encoder {\n-        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n-        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n-\n-        final SpanBytesEncoder encoder;\n-\n-        Encoder(SpanBytesEncoder encoder) {\n-            this.encoder = encoder;\n-        }\n-    }\n \n-    /**\n-     * The networking transport to use.\n-     */\n-    public enum Transport {\n-        UDP {\n-            Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress) {\n-                if (!(collectorAddress instanceof InetSocketAddress)) {\n-                    throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n-                            \" is invalid for transport \" + this);\n-                }\n-                return new Bootstrap()\n-                        .group(group)\n-                        .channel(datagramChannel(group))\n-                        .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n-                        .handler(new ChannelOutboundHandlerAdapter() {\n-                            @Override\n-                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n-                                if (msg instanceof Span) {\n-                                    byte[] bytes = encoder.encoder.encode((Span) msg);\n-                                    ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n-                                            (InetSocketAddress) collectorAddress));\n-                                } else {\n-                                    ctx.write(msg, promise);\n-                                }\n-                            }\n-                        });\n-            }\n-        };\n+    private static ZipkinPublisher p = new ZipkinPublisher.Builder(\"\").build();\n \n-        abstract Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress);\n+    private ZipkinPublisher(String serviceName,\n+                            Reporter<Span> reporter,\n+                            Optional<InetSocketAddress> localSocketAddress) {\n+        this.reporter = requireNonNull(reporter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c338f88e64d8f0ca9277e32f6951a8cb24187014"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NTg2OA==", "bodyText": "This can be final", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403195868", "createdAt": "2020-04-03T17:54:58Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -19,141 +19,61 @@\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n+import java.util.Optional;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n \n /**\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n public final class ZipkinPublisher implements InMemorySpanEventListener, Closeable {\n-    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n-    /**\n-     * The default maximum {@link DatagramPacket} size.\n-     */\n-    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048;\n-    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n-            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n+    private final Reporter<Span> reporter;\n     private final Endpoint endpoint;\n-    private final EventLoopGroup group;\n-    private final Channel channel;\n-\n-    /**\n-     * The serialization format for the zipkin write format data.\n-     */\n-    public enum Encoder {\n-        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n-        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n-\n-        final SpanBytesEncoder encoder;\n-\n-        Encoder(SpanBytesEncoder encoder) {\n-            this.encoder = encoder;\n-        }\n-    }\n \n-    /**\n-     * The networking transport to use.\n-     */\n-    public enum Transport {\n-        UDP {\n-            Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress) {\n-                if (!(collectorAddress instanceof InetSocketAddress)) {\n-                    throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n-                            \" is invalid for transport \" + this);\n-                }\n-                return new Bootstrap()\n-                        .group(group)\n-                        .channel(datagramChannel(group))\n-                        .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n-                        .handler(new ChannelOutboundHandlerAdapter() {\n-                            @Override\n-                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n-                                if (msg instanceof Span) {\n-                                    byte[] bytes = encoder.encoder.encode((Span) msg);\n-                                    ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n-                                            (InetSocketAddress) collectorAddress));\n-                                } else {\n-                                    ctx.write(msg, promise);\n-                                }\n-                            }\n-                        });\n-            }\n-        };\n+    private static ZipkinPublisher p = new ZipkinPublisher.Builder(\"\").build();\n \n-        abstract Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress);\n+    private ZipkinPublisher(String serviceName,\n+                            Reporter<Span> reporter,\n+                            Optional<InetSocketAddress> localSocketAddress) {\n+        this.reporter = requireNonNull(reporter);\n+        this.endpoint = buildEndpoint(requireNonNull(serviceName), requireNonNull(localSocketAddress));\n     }\n \n     /**\n      * Builder for {@link ZipkinPublisher}.\n      */\n     public static final class Builder {\n         private String serviceName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c338f88e64d8f0ca9277e32f6951a8cb24187014"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NjUyMA==", "bodyText": "Looks like this is unused.", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403196520", "createdAt": "2020-04-03T17:55:39Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -19,141 +19,61 @@\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n+import java.util.Optional;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n \n /**\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n public final class ZipkinPublisher implements InMemorySpanEventListener, Closeable {\n-    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n-    /**\n-     * The default maximum {@link DatagramPacket} size.\n-     */\n-    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048;\n-    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n-            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n+    private final Reporter<Span> reporter;\n     private final Endpoint endpoint;\n-    private final EventLoopGroup group;\n-    private final Channel channel;\n-\n-    /**\n-     * The serialization format for the zipkin write format data.\n-     */\n-    public enum Encoder {\n-        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n-        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n-\n-        final SpanBytesEncoder encoder;\n-\n-        Encoder(SpanBytesEncoder encoder) {\n-            this.encoder = encoder;\n-        }\n-    }\n \n-    /**\n-     * The networking transport to use.\n-     */\n-    public enum Transport {\n-        UDP {\n-            Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress) {\n-                if (!(collectorAddress instanceof InetSocketAddress)) {\n-                    throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n-                            \" is invalid for transport \" + this);\n-                }\n-                return new Bootstrap()\n-                        .group(group)\n-                        .channel(datagramChannel(group))\n-                        .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n-                        .handler(new ChannelOutboundHandlerAdapter() {\n-                            @Override\n-                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n-                                if (msg instanceof Span) {\n-                                    byte[] bytes = encoder.encoder.encode((Span) msg);\n-                                    ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n-                                            (InetSocketAddress) collectorAddress));\n-                                } else {\n-                                    ctx.write(msg, promise);\n-                                }\n-                            }\n-                        });\n-            }\n-        };\n+    private static ZipkinPublisher p = new ZipkinPublisher.Builder(\"\").build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c338f88e64d8f0ca9277e32f6951a8cb24187014"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NzE1Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private ZipkinPublisher(String serviceName,\n          \n          \n            \n                                        Reporter<Span> reporter,\n          \n          \n            \n                                        Optional<InetSocketAddress> localSocketAddress) {\n          \n          \n            \n                private ZipkinPublisher(final String serviceName,\n          \n          \n            \n                                        final Reporter<Span> reporter,\n          \n          \n            \n                                        final Optional<InetSocketAddress> localSocketAddress) {", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403197152", "createdAt": "2020-04-03T17:56:23Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -19,141 +19,61 @@\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n+import java.util.Optional;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n \n /**\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n public final class ZipkinPublisher implements InMemorySpanEventListener, Closeable {\n-    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n-    /**\n-     * The default maximum {@link DatagramPacket} size.\n-     */\n-    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048;\n-    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n-            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n+    private final Reporter<Span> reporter;\n     private final Endpoint endpoint;\n-    private final EventLoopGroup group;\n-    private final Channel channel;\n-\n-    /**\n-     * The serialization format for the zipkin write format data.\n-     */\n-    public enum Encoder {\n-        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n-        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n-\n-        final SpanBytesEncoder encoder;\n-\n-        Encoder(SpanBytesEncoder encoder) {\n-            this.encoder = encoder;\n-        }\n-    }\n \n-    /**\n-     * The networking transport to use.\n-     */\n-    public enum Transport {\n-        UDP {\n-            Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress) {\n-                if (!(collectorAddress instanceof InetSocketAddress)) {\n-                    throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n-                            \" is invalid for transport \" + this);\n-                }\n-                return new Bootstrap()\n-                        .group(group)\n-                        .channel(datagramChannel(group))\n-                        .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n-                        .handler(new ChannelOutboundHandlerAdapter() {\n-                            @Override\n-                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n-                                if (msg instanceof Span) {\n-                                    byte[] bytes = encoder.encoder.encode((Span) msg);\n-                                    ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n-                                            (InetSocketAddress) collectorAddress));\n-                                } else {\n-                                    ctx.write(msg, promise);\n-                                }\n-                            }\n-                        });\n-            }\n-        };\n+    private static ZipkinPublisher p = new ZipkinPublisher.Builder(\"\").build();\n \n-        abstract Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress);\n+    private ZipkinPublisher(String serviceName,\n+                            Reporter<Span> reporter,\n+                            Optional<InetSocketAddress> localSocketAddress) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c338f88e64d8f0ca9277e32f6951a8cb24187014"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5ODE0NA==", "bodyText": "As this class is not doing any batching, it does not need to worry about flushing. We can move this to the entity(i.e. a Reporter implementation) that will do batching in the future.", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403198144", "createdAt": "2020-04-03T17:57:34Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -278,6 +147,42 @@ public void onSpanFinished(final InMemorySpan span, long durationMicros) {\n             builder.kind(Span.Kind.CLIENT);\n         }\n \n-        channel.writeAndFlush(builder.build());\n+        Span s = builder.build();\n+        reporter.report(s);\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (reporter instanceof Flushable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c338f88e64d8f0ca9277e32f6951a8cb24187014"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5OTIxNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private SocketAddress collectorAddress;\n          \n          \n            \n                    private final SocketAddress collectorAddress;", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403199217", "createdAt": "2020-04-03T17:58:45Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final EventLoopGroup group;\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        group = createEventLoopGroup(1, new DefaultThreadFactory(\"udp-span-reporter\", true));\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            group.shutdownGracefully(0, 0, SECONDS);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    public static final class Builder {\n+        private SocketAddress collectorAddress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c338f88e64d8f0ca9277e32f6951a8cb24187014"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIwMDAyMw==", "bodyText": "Javadocs are required for all public classes and methods.", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403200023", "createdAt": "2020-04-03T17:59:39Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c338f88e64d8f0ca9277e32f6951a8cb24187014"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNDU2Mw==", "bodyText": "Few improvements here (feel free to do as a follow up):\n\nAdd a method on the Builder to accept an ST IoExecutor which can then be converted to a netty EventLoopGroup using this.\nIf the user does not provide an IoExecutor use one from the GlobalExecutionContext\nAdd a method on the Builder to optionally enable wire logging like we do in clients/servers and add a netty LoggingHandler. It is useful to debug network activity.", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403214563", "createdAt": "2020-04-03T18:16:40Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final EventLoopGroup group;\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        group = createEventLoopGroup(1, new DefaultThreadFactory(\"udp-span-reporter\", true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c338f88e64d8f0ca9277e32f6951a8cb24187014"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNTcwMA==", "bodyText": "Can you also make this an AsyncCloseable? If you do close() can just delegate to closeAsync()", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403215700", "createdAt": "2020-04-03T18:18:01Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -19,141 +19,61 @@\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n+import java.util.Optional;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n \n /**\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n public final class ZipkinPublisher implements InMemorySpanEventListener, Closeable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c338f88e64d8f0ca9277e32f6951a8cb24187014"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNjk1Nw==", "bodyText": "As we are always doing writeAndFlush() this isn't really useful?", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403216957", "createdAt": "2020-04-03T18:19:32Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final EventLoopGroup group;\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        group = createEventLoopGroup(1, new DefaultThreadFactory(\"udp-span-reporter\", true));\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            group.shutdownGracefully(0, 0, SECONDS);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    public static final class Builder {\n+        private SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         * @param collectorAddress the collector SocketAddress\n+         * @return new builder\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelOutboundHandlerAdapter() {\n+                    @Override\n+                    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                        if (msg instanceof Span) {\n+                            byte[] bytes = codec.encoder.encode((Span) msg);\n+                            ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n+                                    (InetSocketAddress) collectorAddress));\n+                        } else {\n+                            ctx.write(msg, promise);\n+                        }\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");\n+        }\n+        channel.writeAndFlush(span);\n+    }\n+\n+    @Override\n+    public void flush() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c338f88e64d8f0ca9277e32f6951a8cb24187014"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNzc5NA==", "bodyText": "Once we do use ST's IoExecutor we do not need to manage the lifecycle as either it is global or managed by user.", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403217794", "createdAt": "2020-04-03T18:20:27Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final EventLoopGroup group;\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        group = createEventLoopGroup(1, new DefaultThreadFactory(\"udp-span-reporter\", true));\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            group.shutdownGracefully(0, 0, SECONDS);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    public static final class Builder {\n+        private SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         * @param collectorAddress the collector SocketAddress\n+         * @return new builder\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelOutboundHandlerAdapter() {\n+                    @Override\n+                    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                        if (msg instanceof Span) {\n+                            byte[] bytes = codec.encoder.encode((Span) msg);\n+                            ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n+                                    (InetSocketAddress) collectorAddress));\n+                        } else {\n+                            ctx.write(msg, promise);\n+                        }\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");\n+        }\n+        channel.writeAndFlush(span);\n+    }\n+\n+    @Override\n+    public void flush() {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");\n+        }\n+        channel.flush();\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (closed) {\n+            return;\n+        }\n+        closed = true;\n+        channel.close();\n+        group.shutdownGracefully(0, 1, SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c338f88e64d8f0ca9277e32f6951a8cb24187014"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxOTQ4OA==", "bodyText": "Use the ByteBufAllocator set in the ctx?\nctx.alloc().buffer(bytes.length).writeBytes(bytes)", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403219488", "createdAt": "2020-04-03T18:22:37Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final EventLoopGroup group;\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        group = createEventLoopGroup(1, new DefaultThreadFactory(\"udp-span-reporter\", true));\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            group.shutdownGracefully(0, 0, SECONDS);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    public static final class Builder {\n+        private SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         * @param collectorAddress the collector SocketAddress\n+         * @return new builder\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelOutboundHandlerAdapter() {\n+                    @Override\n+                    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                        if (msg instanceof Span) {\n+                            byte[] bytes = codec.encoder.encode((Span) msg);\n+                            ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c338f88e64d8f0ca9277e32f6951a8cb24187014"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyMDEyMA==", "bodyText": "Also pass the promise to the write call", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403220120", "createdAt": "2020-04-03T18:23:22Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final EventLoopGroup group;\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        group = createEventLoopGroup(1, new DefaultThreadFactory(\"udp-span-reporter\", true));\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            group.shutdownGracefully(0, 0, SECONDS);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    public static final class Builder {\n+        private SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         * @param collectorAddress the collector SocketAddress\n+         * @return new builder\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelOutboundHandlerAdapter() {\n+                    @Override\n+                    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                        if (msg instanceof Span) {\n+                            byte[] bytes = codec.encoder.encode((Span) msg);\n+                            ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n+                                    (InetSocketAddress) collectorAddress));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c338f88e64d8f0ca9277e32f6951a8cb24187014"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyNTk4MA==", "bodyText": "Also make this AsyncCloseable", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r403225980", "createdAt": "2020-04-03T18:30:02Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.concurrent.DefaultThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.io.Flushable;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, Flushable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIwMDAyMw=="}, "originalCommit": {"oid": "c338f88e64d8f0ca9277e32f6951a8cb24187014"}, "originalPosition": 47}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c338f88e64d8f0ca9277e32f6951a8cb24187014", "author": {"user": null}, "url": "https://github.com/apple/servicetalk/commit/c338f88e64d8f0ca9277e32f6951a8cb24187014", "committedDate": "2020-04-02T19:58:23Z", "message": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\n\nMotivation:\n\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\n\nModifications:\n\n- Modifying ZipkinPublisher to report spans to a Reporter<Span> interface.\n- Moving the UDP implementation out to a UdpReporter\n\nResult:\n\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets."}, "afterCommit": {"oid": "eb283b726c00a74057d2ac92c52d6afff316ae57", "author": {"user": null}, "url": "https://github.com/apple/servicetalk/commit/eb283b726c00a74057d2ac92c52d6afff316ae57", "committedDate": "2020-04-06T20:20:35Z", "message": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\n\nMotivation:\n\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\n\nModifications:\n\n- Modifying ZipkinPublisher to report spans to a Reporter<Span> interface.\n- Moving the UDP implementation out to a UdpReporter\n- Moving the default log reporter implementation out to a LoggingReporter\n\nResult:\n\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eb283b726c00a74057d2ac92c52d6afff316ae57", "author": {"user": null}, "url": "https://github.com/apple/servicetalk/commit/eb283b726c00a74057d2ac92c52d6afff316ae57", "committedDate": "2020-04-06T20:20:35Z", "message": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\n\nMotivation:\n\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\n\nModifications:\n\n- Modifying ZipkinPublisher to report spans to a Reporter<Span> interface.\n- Moving the UDP implementation out to a UdpReporter\n- Moving the default log reporter implementation out to a LoggingReporter\n\nResult:\n\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets."}, "afterCommit": {"oid": "04dc92872870995f77ab84bcf855365e92777037", "author": {"user": null}, "url": "https://github.com/apple/servicetalk/commit/04dc92872870995f77ab84bcf855365e92777037", "committedDate": "2020-04-06T20:28:02Z", "message": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\n\nMotivation:\n\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\n\nModifications:\n\n- Modifying ZipkinPublisher to report spans to a Reporter<Span> interface.\n- Moving the UDP implementation out to a UdpReporter\n- Moving the default log reporter implementation out to a LoggingReporter\n\nResult:\n\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NjQyMDg5", "url": "https://github.com/apple/servicetalk/pull/1001#pullrequestreview-388642089", "createdAt": "2020-04-06T21:47:54Z", "commit": {"oid": "04dc92872870995f77ab84bcf855365e92777037"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTo0Nzo1NFrOGBrKEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMjo0NTo0M1rOGBspYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwODg1MQ==", "bodyText": "not sure why this has been pkg-private but it can be private now.", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404408851", "createdAt": "2020-04-06T21:47:54Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04dc92872870995f77ab84bcf855365e92777037"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQwODkyMA==", "bodyText": "Javadocs please \ud83d\ude04", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404408920", "createdAt": "2020-04-06T21:48:03Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04dc92872870995f77ab84bcf855365e92777037"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMDA1NA==", "bodyText": "Retain the \"may block comment\" from the original class?\nNote that this may block while the underlying channel is bound/connected.", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404410054", "createdAt": "2020-04-06T21:50:29Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04dc92872870995f77ab84bcf855365e92777037"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMTg2Mw==", "bodyText": "Mention at what level we will log, reference:\nhttps://github.com/apple/servicetalk/blob/master/servicetalk-http-api/src/main/java/io/servicetalk/http/api/BaseHttpBuilder.java#L77", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404411863", "createdAt": "2020-04-06T21:54:29Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04dc92872870995f77ab84bcf855365e92777037"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMjEzOQ==", "bodyText": "We generally log at Trace level, you can pass the level to the LoggingHandler, default is DEBUG", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404412139", "createdAt": "2020-04-06T21:55:05Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04dc92872870995f77ab84bcf855365e92777037"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMzEzMA==", "bodyText": "Log instead?", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404413130", "createdAt": "2020-04-06T21:56:56Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName));\n+                        }\n+                        ch.pipeline().addLast(new ChannelOutboundHandlerAdapter() {\n+                            @Override\n+                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                                if (msg instanceof Span) {\n+                                    byte[] bytes = codec.encoder.encode((Span) msg);\n+                                    ByteBuf buf = ctx.alloc().buffer(bytes.length).writeBytes(bytes);\n+                                    ctx.write(new DatagramPacket(buf, (InetSocketAddress) collectorAddress), promise);\n+                                } else {\n+                                    ctx.write(msg, promise);\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     *\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");\n+        }\n+        channel.writeAndFlush(span);\n+    }\n+\n+    /**\n+     * Blocking close method delegates to {@link #closeAsync()}).\n+     */\n+    @Override\n+    public void close() {\n+        try {\n+            closeAsync().toFuture().get();\n+        } catch (InterruptedException | ExecutionException e) {\n+            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04dc92872870995f77ab84bcf855365e92777037"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxNTMzNg==", "bodyText": "We still need to close the channel. You can make this class public and use it here:\nreturn new NettyFutureCompletable(channel::closeFuture);\nBetter to create an keep this NettyFutureCompletable instance in the constructor.", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404415336", "createdAt": "2020-04-06T22:02:02Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName));\n+                        }\n+                        ch.pipeline().addLast(new ChannelOutboundHandlerAdapter() {\n+                            @Override\n+                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                                if (msg instanceof Span) {\n+                                    byte[] bytes = codec.encoder.encode((Span) msg);\n+                                    ByteBuf buf = ctx.alloc().buffer(bytes.length).writeBytes(bytes);\n+                                    ctx.write(new DatagramPacket(buf, (InetSocketAddress) collectorAddress), promise);\n+                                } else {\n+                                    ctx.write(msg, promise);\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     *\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");\n+        }\n+        channel.writeAndFlush(span);\n+    }\n+\n+    /**\n+     * Blocking close method delegates to {@link #closeAsync()}).\n+     */\n+    @Override\n+    public void close() {\n+        try {\n+            closeAsync().toFuture().get();\n+        } catch (InterruptedException | ExecutionException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Marks the {@link UdpReporter} as closed to prevent accepting any more {@link Span}s.\n+     *\n+     * @return a {@link Completable} that is completed when close is done.\n+     */\n+    @Override\n+    public Completable closeAsync() {\n+        closed = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04dc92872870995f77ab84bcf855365e92777037"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQyOTEzNQ==", "bodyText": "Once you move to NettyFutureCompletable this issue becomes moot but as a general concept; setting state like this before returning an async source means state change is eager as opposed to the expected lazy semantics from the returned async source.", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404429135", "createdAt": "2020-04-06T22:34:53Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName));\n+                        }\n+                        ch.pipeline().addLast(new ChannelOutboundHandlerAdapter() {\n+                            @Override\n+                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                                if (msg instanceof Span) {\n+                                    byte[] bytes = codec.encoder.encode((Span) msg);\n+                                    ByteBuf buf = ctx.alloc().buffer(bytes.length).writeBytes(bytes);\n+                                    ctx.write(new DatagramPacket(buf, (InetSocketAddress) collectorAddress), promise);\n+                                } else {\n+                                    ctx.write(msg, promise);\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     *\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");\n+        }\n+        channel.writeAndFlush(span);\n+    }\n+\n+    /**\n+     * Blocking close method delegates to {@link #closeAsync()}).\n+     */\n+    @Override\n+    public void close() {\n+        try {\n+            closeAsync().toFuture().get();\n+        } catch (InterruptedException | ExecutionException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Marks the {@link UdpReporter} as closed to prevent accepting any more {@link Span}s.\n+     *\n+     * @return a {@link Completable} that is completed when close is done.\n+     */\n+    @Override\n+    public Completable closeAsync() {\n+        closed = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04dc92872870995f77ab84bcf855365e92777037"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzMDQyOA==", "bodyText": "Once you change closeAsync() below to close the channel, you can just use channel.isActive().", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404430428", "createdAt": "2020-04-06T22:38:22Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName));\n+                        }\n+                        ch.pipeline().addLast(new ChannelOutboundHandlerAdapter() {\n+                            @Override\n+                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                                if (msg instanceof Span) {\n+                                    byte[] bytes = codec.encoder.encode((Span) msg);\n+                                    ByteBuf buf = ctx.alloc().buffer(bytes.length).writeBytes(bytes);\n+                                    ctx.write(new DatagramPacket(buf, (InetSocketAddress) collectorAddress), promise);\n+                                } else {\n+                                    ctx.write(msg, promise);\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     *\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04dc92872870995f77ab84bcf855365e92777037"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzMDY5NA==", "bodyText": "You may want to instead use StacklessClosedChannelException", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404430694", "createdAt": "2020-04-06T22:39:04Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.transport.api.IoExecutor;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ExecutionException;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private volatile boolean closed;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group;\n+        if (builder.ioExecutor != null) {\n+            group = toEventLoopAwareNettyIoExecutor(builder.ioExecutor).eventLoopGroup();\n+        } else {\n+            group = toEventLoopAwareNettyIoExecutor(globalExecutionContext().ioExecutor()).eventLoopGroup();\n+        }\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an IoExecutor to use for writing to the datagram channel.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName));\n+                        }\n+                        ch.pipeline().addLast(new ChannelOutboundHandlerAdapter() {\n+                            @Override\n+                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                                if (msg instanceof Span) {\n+                                    byte[] bytes = codec.encoder.encode((Span) msg);\n+                                    ByteBuf buf = ctx.alloc().buffer(bytes.length).writeBytes(bytes);\n+                                    ctx.write(new DatagramPacket(buf, (InetSocketAddress) collectorAddress), promise);\n+                                } else {\n+                                    ctx.write(msg, promise);\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     *\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (closed) {\n+            throw new IllegalStateException(\"closed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04dc92872870995f77ab84bcf855365e92777037"}, "originalPosition": 202}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzMzI1MQ==", "bodyText": "We should also override closeAsyncGracefully() to correctly delegate the same to the Reporter. Typically we create an AsyncCloseable in the constructor and delegate to it from respective methods. In this case the AsyncCloseable can be created in the constructor like:\ncloseable = AsyncCloseables.toAsyncCloseable(graceful -> {\n    Completable flush = Completable.completed();\n    if (reporter instanceof Flushable) {\n        flush = globalExecutionContext().executor().submit(() -> {\n            try {\n                ((Flushable) reporter).flush();\n            } catch (IOException e) {\n                logger.error(\"Exception while flushing reporter: {}\", e.getMessage(), e);\n            }\n        });\n    }\n    // ST Reporters can implement AsyncCloseable so we wouldn't have to call a blocking close in that case\n    Completable close = Completable.completed();\n    if (reporter instanceof AsyncCloseable) {\n        close = graceful ? ((AsyncCloseable) reporter).closeAsyncGracefully() :\n                ((AsyncCloseable) reporter).closeAsync();\n    } else if (reporter instanceof Closeable) {\n        close = globalExecutionContext().executor().submit(() -> {\n            try {\n                ((Closeable) reporter).close();\n            } catch (IOException e) {\n                logger.error(\"Exception while closing reporter: {}\", e.getMessage(), e);\n            }\n        });\n    }\n    return flush.concat(close);\n});", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404433251", "createdAt": "2020-04-06T22:45:43Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -278,6 +149,53 @@ public void onSpanFinished(final InMemorySpan span, long durationMicros) {\n             builder.kind(Span.Kind.CLIENT);\n         }\n \n-        channel.writeAndFlush(builder.build());\n+        Span s = builder.build();\n+        reporter.report(s);\n+    }\n+\n+    /**\n+     * Attempts to flush and close the configured {@link Reporter}.\n+     *\n+     * @return a {@link Completable} that is completed when the flush and close is done\n+     */\n+    @Override\n+    public Completable closeAsync() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04dc92872870995f77ab84bcf855365e92777037"}, "originalPosition": 311}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "04dc92872870995f77ab84bcf855365e92777037", "author": {"user": null}, "url": "https://github.com/apple/servicetalk/commit/04dc92872870995f77ab84bcf855365e92777037", "committedDate": "2020-04-06T20:28:02Z", "message": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\n\nMotivation:\n\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\n\nModifications:\n\n- Modifying ZipkinPublisher to report spans to a Reporter<Span> interface.\n- Moving the UDP implementation out to a UdpReporter\n- Moving the default log reporter implementation out to a LoggingReporter\n\nResult:\n\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets."}, "afterCommit": {"oid": "cedc692217938361cb918f75d62f7c39b3ff4e91", "author": {"user": null}, "url": "https://github.com/apple/servicetalk/commit/cedc692217938361cb918f75d62f7c39b3ff4e91", "committedDate": "2020-04-07T02:02:40Z", "message": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\n\nMotivation:\n\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\n\nModifications:\n\n- Modifying ZipkinPublisher to report spans to a Reporter<Span> interface.\n- Moving the UDP implementation out to a UdpReporter\n- Moving the default log reporter implementation out to a LoggingReporter\n\nResult:\n\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a714b13acfa948d4ffcecd980af148a723e4eb67", "author": {"user": null}, "url": "https://github.com/apple/servicetalk/commit/a714b13acfa948d4ffcecd980af148a723e4eb67", "committedDate": "2020-04-07T07:29:37Z", "message": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\n\nMotivation:\n\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\n\nModifications:\n\n- Modifying ZipkinPublisher to report spans to a Reporter<Span> interface.\n- Moving the UDP implementation out to a UdpReporter\n- Moving the default log reporter implementation out to a LoggingReporter\n\nResult:\n\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cedc692217938361cb918f75d62f7c39b3ff4e91", "author": {"user": null}, "url": "https://github.com/apple/servicetalk/commit/cedc692217938361cb918f75d62f7c39b3ff4e91", "committedDate": "2020-04-07T02:02:40Z", "message": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\n\nMotivation:\n\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\n\nModifications:\n\n- Modifying ZipkinPublisher to report spans to a Reporter<Span> interface.\n- Moving the UDP implementation out to a UdpReporter\n- Moving the default log reporter implementation out to a LoggingReporter\n\nResult:\n\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets."}, "afterCommit": {"oid": "a714b13acfa948d4ffcecd980af148a723e4eb67", "author": {"user": null}, "url": "https://github.com/apple/servicetalk/commit/a714b13acfa948d4ffcecd980af148a723e4eb67", "committedDate": "2020-04-07T07:29:37Z", "message": "Converting ZipkinPublisher to use a zipkin2.Reporter interface for reporting spans.\n\nMotivation:\n\nThe existing ZipkinPublisher isn\u2019t readily extensible with different off the shelf reporters\nand adopting that interface will allow users to drop in their own reporters.\n\nModifications:\n\n- Modifying ZipkinPublisher to report spans to a Reporter<Span> interface.\n- Moving the UDP implementation out to a UdpReporter\n- Moving the default log reporter implementation out to a LoggingReporter\n\nResult:\n\nZipkinPublisher can now accept other zipkin2 Reporters as publishing targets."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MjgyNzUw", "url": "https://github.com/apple/servicetalk/pull/1001#pullrequestreview-389282750", "createdAt": "2020-04-07T16:22:12Z", "commit": {"oid": "a714b13acfa948d4ffcecd980af148a723e4eb67"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNjoyMjoxM1rOGCLqnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNjoyMjoxM1rOGCLqnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk0MTQ2OA==", "bodyText": "onClose() isn't appropriate here as it does not actually close, also we need to subscribe here as close() is synchronous.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void close() {\n          \n          \n            \n                    closeable.onClose();\n          \n          \n            \n                }\n          \n          \n            \n                public void close() throws Exception {\n          \n          \n            \n                    closeable.closeAsync().toFuture().get();\n          \n          \n            \n                }", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404941468", "createdAt": "2020-04-07T16:22:13Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -278,6 +179,35 @@ public void onSpanFinished(final InMemorySpan span, long durationMicros) {\n             builder.kind(Span.Kind.CLIENT);\n         }\n \n-        channel.writeAndFlush(builder.build());\n+        Span s = builder.build();\n+        reporter.report(s);\n+    }\n+\n+    /**\n+     * Blocking close method delegates to {@link #closeAsync()}.\n+     */\n+    @Override\n+    public void close() {\n+        closeable.onClose();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a714b13acfa948d4ffcecd980af148a723e4eb67"}, "originalPosition": 341}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2aac83d68480ef701171f98fa611d73ee5fd3b81", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/2aac83d68480ef701171f98fa611d73ee5fd3b81", "committedDate": "2020-04-07T16:23:49Z", "message": "Use `closeAsync()` in `close()`"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MzE2OTE2", "url": "https://github.com/apple/servicetalk/pull/1001#pullrequestreview-389316916", "createdAt": "2020-04-07T17:02:38Z", "commit": {"oid": "2aac83d68480ef701171f98fa611d73ee5fd3b81"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzowMjozOVrOGCNX6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzowMzo0M1rOGCNbEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk2OTQ0OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              implementation project(\":servicetalk-concurrent-api-internal\")\n          \n          \n            \n              implementation project(\":servicetalk-concurrent-api-internal\")\n          \n          \n            \n              implementation project(\":servicetalk-concurrent-internal\")", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404969448", "createdAt": "2020-04-07T17:02:39Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/build.gradle", "diffHunk": "@@ -21,12 +21,14 @@ dependencies {\n \n   implementation project(\":servicetalk-annotations\")\n   implementation project(\":servicetalk-transport-netty-internal\")\n+  implementation project(\":servicetalk-concurrent-api-internal\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2aac83d68480ef701171f98fa611d73ee5fd3b81"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk2OTc2Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n          \n          \n            \n            import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n          \n          \n            \n            import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404969766", "createdAt": "2020-04-07T17:03:08Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -15,146 +15,95 @@\n  */\n package io.servicetalk.opentracing.zipkin.publisher;\n \n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpan;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2aac83d68480ef701171f98fa611d73ee5fd3b81"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk3MDI1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return closeable.closeAsync();\n          \n          \n            \n                    return awaitTermination(closeable.closeAsync().toFuture());", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r404970257", "createdAt": "2020-04-07T17:03:43Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -278,6 +179,35 @@ public void onSpanFinished(final InMemorySpan span, long durationMicros) {\n             builder.kind(Span.Kind.CLIENT);\n         }\n \n-        channel.writeAndFlush(builder.build());\n+        Span s = builder.build();\n+        reporter.report(s);\n+    }\n+\n+    /**\n+     * Blocking close method delegates to {@link #closeAsync()}.\n+     */\n+    @Override\n+    public void close() throws Exception {\n+        closeable.closeAsync().toFuture().get();\n+    }\n+\n+    /**\n+     * Attempts to close the configured {@link Reporter}.\n+     *\n+     * @return a {@link Completable} that is completed when the close is done\n+     */\n+    @Override\n+    public Completable closeAsync() {\n+        return closeable.closeAsync();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2aac83d68480ef701171f98fa611d73ee5fd3b81"}, "originalPosition": 350}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2dd7864b573e54ee001fac3951bb45cf365bd160", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/2dd7864b573e54ee001fac3951bb45cf365bd160", "committedDate": "2020-04-07T17:04:47Z", "message": "Correctly implement `close()`"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "694b805723195eafe53859ad64337ba46f74bca7", "author": {"user": null}, "url": "https://github.com/apple/servicetalk/commit/694b805723195eafe53859ad64337ba46f74bca7", "committedDate": "2020-04-07T18:50:49Z", "message": "Properly implementing UdpReporter\u2019s close method"}, "afterCommit": {"oid": "957d185d4db98fb935624c75e44843a1d6691510", "author": {"user": null}, "url": "https://github.com/apple/servicetalk/commit/957d185d4db98fb935624c75e44843a1d6691510", "committedDate": "2020-04-07T19:18:51Z", "message": "Properly implementing UdpReporter\u2019s close method"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "957d185d4db98fb935624c75e44843a1d6691510", "author": {"user": null}, "url": "https://github.com/apple/servicetalk/commit/957d185d4db98fb935624c75e44843a1d6691510", "committedDate": "2020-04-07T19:18:51Z", "message": "Properly implementing UdpReporter\u2019s close method"}, "afterCommit": {"oid": "478bf211dd809661394e56bad48d4a3b919f7a97", "author": {"user": null}, "url": "https://github.com/apple/servicetalk/commit/478bf211dd809661394e56bad48d4a3b919f7a97", "committedDate": "2020-04-07T19:39:41Z", "message": "Properly implementing UdpReporter\u2019s close method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NDc1NTc1", "url": "https://github.com/apple/servicetalk/pull/1001#pullrequestreview-389475575", "createdAt": "2020-04-07T20:43:46Z", "commit": {"oid": "478bf211dd809661394e56bad48d4a3b919f7a97"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMDo0Mzo0NlrOGCVXig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMToxNjowOVrOGCWb_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEwMDQyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            close = ((AsyncCloseable) reporter).closeAsyncGracefully();\n          \n          \n            \n                            close = graceful ? ((AsyncCloseable) reporter).closeAsyncGracefully() :\n          \n          \n            \n                                    ((AsyncCloseable) reporter).closeAsync();", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r405100426", "createdAt": "2020-04-07T20:43:46Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -15,146 +15,96 @@\n  */\n package io.servicetalk.opentracing.zipkin.publisher;\n \n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpan;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanEventListener;\n import io.servicetalk.opentracing.inmemory.api.InMemorySpanLog;\n \n-import io.netty.bootstrap.Bootstrap;\n-import io.netty.buffer.Unpooled;\n-import io.netty.channel.Channel;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOutboundHandlerAdapter;\n-import io.netty.channel.ChannelPromise;\n-import io.netty.channel.EventLoopGroup;\n-import io.netty.channel.FixedRecvByteBufAllocator;\n-import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n-import io.netty.channel.socket.DatagramPacket;\n-import io.netty.util.concurrent.DefaultThreadFactory;\n import io.opentracing.tag.Tags;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import zipkin2.Endpoint;\n import zipkin2.Span;\n-import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n \n import java.io.Closeable;\n-import java.net.InetAddress;\n+import java.io.Flushable;\n+import java.io.IOException;\n import java.net.InetSocketAddress;\n-import java.net.SocketAddress;\n import java.util.Map;\n import javax.annotation.Nullable;\n \n-import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n-import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n-import static io.servicetalk.transport.netty.internal.NettyIoExecutors.createEventLoopGroup;\n-import static java.lang.Thread.currentThread;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n \n /**\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n-public final class ZipkinPublisher implements InMemorySpanEventListener, Closeable {\n-    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n+public final class ZipkinPublisher implements InMemorySpanEventListener, AsyncCloseable, Closeable {\n \n-    /**\n-     * The default maximum {@link DatagramPacket} size.\n-     */\n-    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048;\n-    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n-            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n \n+    private final Reporter<Span> reporter;\n     private final Endpoint endpoint;\n-    private final EventLoopGroup group;\n-    private final Channel channel;\n-\n-    /**\n-     * The serialization format for the zipkin write format data.\n-     */\n-    public enum Encoder {\n-        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n-        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n-\n-        final SpanBytesEncoder encoder;\n-\n-        Encoder(SpanBytesEncoder encoder) {\n-            this.encoder = encoder;\n-        }\n-    }\n-\n-    /**\n-     * The networking transport to use.\n-     */\n-    public enum Transport {\n-        UDP {\n-            Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress) {\n-                if (!(collectorAddress instanceof InetSocketAddress)) {\n-                    throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n-                            \" is invalid for transport \" + this);\n-                }\n-                return new Bootstrap()\n-                        .group(group)\n-                        .channel(datagramChannel(group))\n-                        .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n-                        .handler(new ChannelOutboundHandlerAdapter() {\n-                            @Override\n-                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n-                                if (msg instanceof Span) {\n-                                    byte[] bytes = encoder.encoder.encode((Span) msg);\n-                                    ctx.write(new DatagramPacket(Unpooled.wrappedBuffer(bytes),\n-                                            (InetSocketAddress) collectorAddress));\n-                                } else {\n-                                    ctx.write(msg, promise);\n-                                }\n-                            }\n-                        });\n+    private final ListenableAsyncCloseable closeable;\n+\n+    private ZipkinPublisher(final String serviceName,\n+                            final Reporter<Span> reporter,\n+                            @Nullable final InetSocketAddress localSocketAddress) {\n+        this.reporter = reporter;\n+        this.endpoint = buildEndpoint(serviceName, localSocketAddress);\n+        this.closeable = toAsyncCloseable(graceful -> {\n+            // Some Reporter implementations may batch and need an explicit flush before closing (AsyncReporter)\n+            Completable flush = Completable.completed();\n+            if (graceful && reporter instanceof Flushable) {\n+                flush = globalExecutionContext().executor().submit(() -> {\n+                    try {\n+                        ((Flushable) reporter).flush();\n+                    } catch (IOException e) {\n+                        logger.error(\"Exception while flushing reporter: {}\", e.getMessage(), e);\n+                    }\n+                });\n             }\n-        };\n-\n-        abstract Bootstrap buildBootstrap(EventLoopGroup group, Encoder encoder, SocketAddress collectorAddress);\n+            // ST Reporters can implement AsyncCloseable so we wouldn't have to call a blocking close in that case\n+            Completable close = Completable.completed();\n+            if (reporter instanceof AsyncCloseable) {\n+                close = ((AsyncCloseable) reporter).closeAsyncGracefully();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "478bf211dd809661394e56bad48d4a3b919f7a97"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExNzQ3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Sets an {@link Executor} to use for offloading various tasks. Defaults to the {@link GlobalExecutionContext}\n          \n          \n            \n                     * {@link Executor}.\n          \n          \n            \n                     * Sets an {@link Executor} to use when required. \n          \n      \n    \n    \n  \n\nAvoid stating defaults in documentation.", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r405117470", "createdAt": "2020-04-07T21:15:06Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.GlobalExecutionContext;\n+import io.servicetalk.transport.netty.internal.NettyChannelListenableAsyncCloseable;\n+import io.servicetalk.transport.netty.internal.StacklessClosedChannelException;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LogLevel;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.event.Level;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to a UDP listener with a configurable encoding {@link Codec}.\n+ */\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private final ListenableAsyncCloseable closeable;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group = toEventLoopAwareNettyIoExecutor(\n+                builder.ioExecutor != null ? builder.ioExecutor : globalExecutionContext().ioExecutor()\n+        ).eventLoopGroup();\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+        Executor executor = builder.executor != null ? builder.executor :\n+                globalExecutionContext().executor();\n+        closeable = new NettyChannelListenableAsyncCloseable(channel, executor);\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private Executor executor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an {@link IoExecutor} to use for writing to the datagram channel. Defaults to the\n+         * {@link GlobalExecutionContext} {@link IoExecutor}.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an {@link Executor} to use for offloading various tasks. Defaults to the {@link GlobalExecutionContext}\n+         * {@link Executor}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "478bf211dd809661394e56bad48d4a3b919f7a97"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExNzU3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * @param executor {@link Executor} to offload close to\n          \n          \n            \n                     * @param executor {@link Executor} to use.", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r405117574", "createdAt": "2020-04-07T21:15:18Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.GlobalExecutionContext;\n+import io.servicetalk.transport.netty.internal.NettyChannelListenableAsyncCloseable;\n+import io.servicetalk.transport.netty.internal.StacklessClosedChannelException;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LogLevel;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.event.Level;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to a UDP listener with a configurable encoding {@link Codec}.\n+ */\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private final ListenableAsyncCloseable closeable;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group = toEventLoopAwareNettyIoExecutor(\n+                builder.ioExecutor != null ? builder.ioExecutor : globalExecutionContext().ioExecutor()\n+        ).eventLoopGroup();\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+        Executor executor = builder.executor != null ? builder.executor :\n+                globalExecutionContext().executor();\n+        closeable = new NettyChannelListenableAsyncCloseable(channel, executor);\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private Executor executor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an {@link IoExecutor} to use for writing to the datagram channel. Defaults to the\n+         * {@link GlobalExecutionContext} {@link IoExecutor}.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an {@link Executor} to use for offloading various tasks. Defaults to the {@link GlobalExecutionContext}\n+         * {@link Executor}.\n+         *\n+         * @param executor {@link Executor} to offload close to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "478bf211dd809661394e56bad48d4a3b919f7a97"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExNzk1MA==", "bodyText": "Also override closeAsyncGracefully()\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                @Override\n          \n          \n            \n                public Completable closeAsyncGracefully() {\n          \n          \n            \n                    return closeable.closeAsyncGracefully();\n          \n          \n            \n                }", "url": "https://github.com/apple/servicetalk/pull/1001#discussion_r405117950", "createdAt": "2020-04-07T21:16:09Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.ListenableAsyncCloseable;\n+import io.servicetalk.transport.api.IoExecutor;\n+import io.servicetalk.transport.netty.internal.GlobalExecutionContext;\n+import io.servicetalk.transport.netty.internal.NettyChannelListenableAsyncCloseable;\n+import io.servicetalk.transport.netty.internal.StacklessClosedChannelException;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.FixedRecvByteBufAllocator;\n+import io.netty.channel.MaxMessagesRecvByteBufAllocator;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.handler.logging.LogLevel;\n+import io.netty.handler.logging.LoggingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.slf4j.event.Level;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.RCVBUF_ALLOCATOR;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.transport.netty.internal.BuilderUtils.datagramChannel;\n+import static io.servicetalk.transport.netty.internal.EventLoopAwareNettyIoExecutors.toEventLoopAwareNettyIoExecutor;\n+import static io.servicetalk.transport.netty.internal.GlobalExecutionContext.globalExecutionContext;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to a UDP listener with a configurable encoding {@link Codec}.\n+ */\n+public final class UdpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UdpReporter.class);\n+\n+    private static final int DEFAULT_MAX_DATAGRAM_PACKET_SIZE = 2048; // 2Kib\n+    private static final MaxMessagesRecvByteBufAllocator DEFAULT_RECV_BUF_ALLOCATOR =\n+            new FixedRecvByteBufAllocator(DEFAULT_MAX_DATAGRAM_PACKET_SIZE);\n+\n+    private final Channel channel;\n+    private final ListenableAsyncCloseable closeable;\n+\n+    private UdpReporter(final Builder builder) {\n+        EventLoopGroup group = toEventLoopAwareNettyIoExecutor(\n+                builder.ioExecutor != null ? builder.ioExecutor : globalExecutionContext().ioExecutor()\n+        ).eventLoopGroup();\n+        try {\n+            final Bootstrap bootstrap = buildBootstrap(group, builder.codec, builder.collectorAddress,\n+                    builder.loggerName);\n+            channel = bootstrap.bind(0).sync().channel();\n+        } catch (InterruptedException e) {\n+            currentThread().interrupt(); // Reset the interrupted flag.\n+            throw new IllegalStateException(\"Failed to create UDP client\");\n+        } catch (Exception e) {\n+            logger.warn(\"Failed to create UDP client\", e);\n+            throw e;\n+        }\n+        Executor executor = builder.executor != null ? builder.executor :\n+                globalExecutionContext().executor();\n+        closeable = new NettyChannelListenableAsyncCloseable(channel, executor);\n+    }\n+\n+    /**\n+     * The serialization format for the zipkin write format data.\n+     */\n+    public enum Codec {\n+        JSON_V1(SpanBytesEncoder.JSON_V1), JSON_V2(SpanBytesEncoder.JSON_V2),\n+        THRIFT(SpanBytesEncoder.THRIFT), PROTO3(SpanBytesEncoder.PROTO3);\n+\n+        final SpanBytesEncoder encoder;\n+\n+        Codec(SpanBytesEncoder encoder) {\n+            this.encoder = encoder;\n+        }\n+    }\n+\n+    /**\n+     * A builder to create a new {@link UdpReporter}.\n+     */\n+    public static final class Builder {\n+        private final SocketAddress collectorAddress;\n+        private Codec codec = Codec.JSON_V2;\n+        @Nullable\n+        private IoExecutor ioExecutor;\n+        @Nullable\n+        private Executor executor;\n+        @Nullable\n+        private String loggerName;\n+\n+        /**\n+         * Create a new {@link UdpReporter.Builder} for a given collectorAddress.\n+         *\n+         * @param collectorAddress the collector SocketAddress\n+         */\n+        public Builder(SocketAddress collectorAddress) {\n+            this.collectorAddress = collectorAddress;\n+        }\n+\n+        /**\n+         * Sets the {@link UdpReporter.Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an {@link IoExecutor} to use for writing to the datagram channel. Defaults to the\n+         * {@link GlobalExecutionContext} {@link IoExecutor}.\n+         *\n+         * @param ioExecutor IoExecutor to use to write with.\n+         * @return {@code this}\n+         */\n+        public Builder ioExecutor(IoExecutor ioExecutor) {\n+            this.ioExecutor = requireNonNull(ioExecutor);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets an {@link Executor} to use for offloading various tasks. Defaults to the {@link GlobalExecutionContext}\n+         * {@link Executor}.\n+         *\n+         * @param executor {@link Executor} to offload close to\n+         * @return {@code this}\n+         */\n+        public Builder executor(Executor executor) {\n+            this.executor = executor;\n+            return this;\n+        }\n+\n+        /**\n+         * Enables wire-logging for udp packets sent.\n+         * <p>\n+         * All wire events will be logged at {@link Level#TRACE TRACE} level.\n+         *\n+         * @param loggerName The name of the logger to log wire events.\n+         * @return {@code this}\n+         */\n+        public Builder enableWireLogging(String loggerName) {\n+            this.loggerName = loggerName;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link UdpReporter} instance with this builder's options.\n+         * <p>\n+         * This method may block while the underlying UDP channel is being bound.\n+         *\n+         * @return a new {@link UdpReporter}\n+         */\n+        public UdpReporter build() {\n+            return new UdpReporter(this);\n+        }\n+    }\n+\n+    private Bootstrap buildBootstrap(EventLoopGroup group, Codec codec, SocketAddress collectorAddress,\n+                                     @Nullable String loggerName) {\n+        if (!(collectorAddress instanceof InetSocketAddress)) {\n+            throw new IllegalArgumentException(\"collectorAddress \" + collectorAddress +\n+                    \" is invalid for UDP\");\n+        }\n+        return new Bootstrap()\n+                .group(group)\n+                .channel(datagramChannel(group))\n+                .option(RCVBUF_ALLOCATOR, DEFAULT_RECV_BUF_ALLOCATOR)\n+                .handler(new ChannelInitializer<Channel>() {\n+                    @Override\n+                    protected void initChannel(final Channel ch) {\n+                        if (loggerName != null) {\n+                            ch.pipeline().addLast(new LoggingHandler(loggerName, LogLevel.TRACE));\n+                        }\n+                        ch.pipeline().addLast(new ChannelOutboundHandlerAdapter() {\n+                            @Override\n+                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n+                                if (msg instanceof Span) {\n+                                    byte[] bytes = codec.encoder.encode((Span) msg);\n+                                    ByteBuf buf = ctx.alloc().buffer(bytes.length).writeBytes(bytes);\n+                                    ctx.write(new DatagramPacket(buf, (InetSocketAddress) collectorAddress), promise);\n+                                } else {\n+                                    ctx.write(msg, promise);\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Non-blocking report method.\n+     *\n+     * @param span the span to report\n+     */\n+    @Override\n+    public void report(final Span span) {\n+        if (!channel.isActive()) {\n+            throw new RuntimeException(StacklessClosedChannelException.newInstance(this.getClass(), \"report\"));\n+        }\n+        channel.writeAndFlush(span);\n+    }\n+\n+    /**\n+     * Blocking close method delegates to {@link #closeAsync()}).\n+     */\n+    @Override\n+    public void close() {\n+        awaitTermination(closeable.closeAsync().toFuture());\n+    }\n+\n+    /**\n+     * Marks the {@link UdpReporter} as closed to prevent accepting any more {@link Span}s.\n+     *\n+     * @return a {@link Completable} that is completed when close is done.\n+     */\n+    @Override\n+    public Completable closeAsync() {\n+        return closeable.closeAsync();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "478bf211dd809661394e56bad48d4a3b919f7a97"}, "originalPosition": 251}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "910beb0b06b3219b345dbcdffe0953cb8dc51ef3", "author": {"user": null}, "url": "https://github.com/apple/servicetalk/commit/910beb0b06b3219b345dbcdffe0953cb8dc51ef3", "committedDate": "2020-04-07T21:36:05Z", "message": "Properly implementing UdpReporter\u2019s close method"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "478bf211dd809661394e56bad48d4a3b919f7a97", "author": {"user": null}, "url": "https://github.com/apple/servicetalk/commit/478bf211dd809661394e56bad48d4a3b919f7a97", "committedDate": "2020-04-07T19:39:41Z", "message": "Properly implementing UdpReporter\u2019s close method"}, "afterCommit": {"oid": "910beb0b06b3219b345dbcdffe0953cb8dc51ef3", "author": {"user": null}, "url": "https://github.com/apple/servicetalk/commit/910beb0b06b3219b345dbcdffe0953cb8dc51ef3", "committedDate": "2020-04-07T21:36:05Z", "message": "Properly implementing UdpReporter\u2019s close method"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3585, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}