{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3MTUwODM5", "number": 1049, "title": "Introduce HTTP Zipkin reporter", "bodyText": "Motivation\nWe do not currently provide a zipkin reporter implementation for HTTP collectors. Providing an HTTP reporter using ServiceTalk HTTP client will be useful when ServiceTalk HTTP client is used otherwise in applications.\nModification\nAdd an HttpReporter with configurable batching strategy.\nResult\nUsers can use ServiceTalk HTTP client to publish spans to a Zipkin collector.", "createdAt": "2020-05-13T06:40:27Z", "url": "https://github.com/apple/servicetalk/pull/1049", "merged": true, "mergeCommit": {"oid": "ddef29e3c084cda8a6ebf38284c0cef34a61710b"}, "closed": true, "closedAt": "2020-05-14T17:24:55Z", "author": {"login": "NiteshKant"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcgzCgIgH2gAyNDE3MTUwODM5OmU0ZWZiYjk5ZjYyNDU4NDQxMWI4MTZlOTE4MjYzMTUyMzBkYzU1MDY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABchGCF_AFqTQxMTQ1OTkxNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e4efbb99f624584411b816e91826315230dc5506", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/e4efbb99f624584411b816e91826315230dc5506", "committedDate": "2020-05-13T06:39:33Z", "message": "Introduce HTTP Zipkin reporter\n\n__Motivation__\n\nWe do not currently provide a zipkin reporter implementation for HTTP collectors. Providing an HTTP reporter using ServiceTalk HTTP client will be useful when ServiceTalk HTTP client is used otherwise in applications.\n\n__Modification__\n\nAdd an `HttpReporter` with configurable batching strategy.\n\n__Result__\n\nUsers can use ServiceTalk HTTP client to publish spans to a Zipkin collector."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNzY4OTAw", "url": "https://github.com/apple/servicetalk/pull/1049#pullrequestreview-410768900", "createdAt": "2020-05-13T09:54:43Z", "commit": {"oid": "e4efbb99f624584411b816e91826315230dc5506"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwOTo1NDo0M1rOGUqOnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwOTo1ODo1M1rOGUqYow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMxNjU3NQ==", "bodyText": "private ?", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424316575", "createdAt": "2020-05-13T09:54:43Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/Codec.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+\n+/**\n+ * Zipkin data formats for reporting of {@link Span}s.\n+ */\n+public enum Codec {\n+    /**\n+     * Zipkin V1 JSON format.\n+     */\n+    JSON_V1(SpanBytesEncoder.JSON_V1),\n+    /**\n+     * Zipkin V2 JSON format.\n+     */\n+    JSON_V2(SpanBytesEncoder.JSON_V2),\n+    /**\n+     * Zipkin V2 THRIFT format.\n+     */\n+    THRIFT(SpanBytesEncoder.THRIFT),\n+    /**\n+     * Zipkin V2 protocol buffers V3 format.\n+     */\n+    PROTO3(SpanBytesEncoder.PROTO3);\n+\n+    private final SpanBytesEncoder encoder;\n+\n+    Codec(SpanBytesEncoder encoder) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4efbb99f624584411b816e91826315230dc5506"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMxNzUzNw==", "bodyText": "nit: consider marking as final so we ensure it is really set at some point.", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424317537", "createdAt": "2020-05-13T09:56:18Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final AsyncCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        final HttpClient client = builder.clientBuilder.build();\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final String path;\n+        final CharSequence contentType;\n+        switch (builder.codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + builder.codec);\n+        }\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        Publisher<Buffer> spans;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4efbb99f624584411b816e91826315230dc5506"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDMxOTEzOQ==", "bodyText": "consider storing the value into a static final field and use it in newSpan(...) and verifySpan(...). This way it is less error-prone once we refactor", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424319139", "createdAt": "2020-05-13T09:58:53Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-opentracing-zipkin-publisher/src/test/java/io/servicetalk/opentracing/zipkin/publisher/reporter/SpanUtils.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import zipkin2.Span;\n+\n+import java.util.Map;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+final class SpanUtils {\n+    private SpanUtils() {\n+        // no instances\n+    }\n+\n+    static Span newSpan() {\n+        return Span.newBuilder()\n+                .name(\"test operation\")\n+                .traceId(\"1234\")\n+                .id(2)\n+                .timestamp(123456789L)\n+                .duration(SECONDS.toMicros(1))\n+                .putTag(\"stringKey\", \"string\")\n+                .putTag(\"boolKey\", String.valueOf(true))\n+                .putTag(\"shortKey\", String.valueOf(Short.MAX_VALUE))\n+                .putTag(\"intKey\", String.valueOf(Integer.MAX_VALUE))\n+                .putTag(\"longKey\", String.valueOf(Long.MAX_VALUE))\n+                .putTag(\"floatKey\", String.valueOf(Float.MAX_VALUE))\n+                .putTag(\"doubleKey\", String.valueOf(Double.MAX_VALUE))\n+                .addAnnotation(System.currentTimeMillis() * 1000, \"some event happened\")\n+                .build();\n+    }\n+\n+    static void verifySpan(final Span span) {\n+        assertEquals(\"test operation\", span.name());\n+        assertEquals(\"0000000000001234\", span.traceId());\n+        assertEquals(\"0000000000000002\", span.id());\n+        assertEquals(123456789L, (long) span.timestamp());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4efbb99f624584411b816e91826315230dc5506"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f4583663656a92aae310ebfee570188cf506515", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/0f4583663656a92aae310ebfee570188cf506515", "committedDate": "2020-05-13T16:51:03Z", "message": "Review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMTU1NjAy", "url": "https://github.com/apple/servicetalk/pull/1049#pullrequestreview-411155602", "createdAt": "2020-05-13T17:42:07Z", "commit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxNzo0MjowN1rOGU8mAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxODo1ODo1OFrOGU_aJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYxNzQ3Mg==", "bodyText": "Should it be ListenableAsyncCloseable and GracefulAutoCloseable? The same question for UdpReporter.", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424617472", "createdAt": "2020-05-13T17:42:07Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYxODk2Ng==", "bodyText": "This method may be static.", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424618966", "createdAt": "2020-05-13T17:44:35Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/test/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporterTest.java", "diffHunk": "@@ -71,66 +70,38 @@ public void tearDown() {\n \n     @Test\n     public void testJsonV1RoundTrip() throws Exception {\n-        testRoundTrip(UdpReporter.Codec.JSON_V1, SpanBytesDecoder.JSON_V1);\n+        testRoundTrip(Codec.JSON_V1, SpanBytesDecoder.JSON_V1);\n     }\n \n     @Test\n     public void testJsonV2RoundTrip() throws Exception {\n-        testRoundTrip(UdpReporter.Codec.JSON_V2, SpanBytesDecoder.JSON_V2);\n+        testRoundTrip(Codec.JSON_V2, SpanBytesDecoder.JSON_V2);\n     }\n \n     @Test\n     public void testThriftRoundTrip() throws Exception {\n-        testRoundTrip(UdpReporter.Codec.THRIFT, SpanBytesDecoder.THRIFT);\n+        testRoundTrip(Codec.THRIFT, SpanBytesDecoder.THRIFT);\n     }\n \n     @Test\n     public void testProto3RoundTrip() throws Exception {\n-        testRoundTrip(UdpReporter.Codec.PROTO3, SpanBytesDecoder.PROTO3);\n+        testRoundTrip(Codec.PROTO3, SpanBytesDecoder.PROTO3);\n     }\n \n-    private void testRoundTrip(UdpReporter.Codec codec, SpanBytesDecoder decoder) throws Exception {\n+    private void testRoundTrip(Codec codec, SpanBytesDecoder decoder) throws Exception {\n         try (TestReceiver receiver = new TestReceiver(decoder)) {\n             try (UdpReporter reporter = buildReporter((InetSocketAddress) receiver.channel.localAddress(), codec)) {\n-                Span span = Span.newBuilder()\n-                        .name(\"test operation\")\n-                        .traceId(\"1234\")\n-                        .id(2)\n-                        .timestamp(123456789L)\n-                        .duration(SECONDS.toMicros(1))\n-                        .putTag(\"stringKey\", \"string\")\n-                        .putTag(\"boolKey\", String.valueOf(true))\n-                        .putTag(\"shortKey\", String.valueOf(Short.MAX_VALUE))\n-                        .putTag(\"intKey\", String.valueOf(Integer.MAX_VALUE))\n-                        .putTag(\"longKey\", String.valueOf(Long.MAX_VALUE))\n-                        .putTag(\"floatKey\", String.valueOf(Float.MAX_VALUE))\n-                        .putTag(\"doubleKey\", String.valueOf(Double.MAX_VALUE))\n-                        .addAnnotation(System.currentTimeMillis() * 1000, \"some event happened\")\n-                        .build();\n-                reporter.report(span);\n+                reporter.report(newSpan());\n             }\n \n             Span span = receiver.queue.take();\n \n             assertNotNull(span);\n-            assertEquals(\"test operation\", span.name());\n-            assertEquals(\"0000000000001234\", span.traceId());\n-            assertEquals(\"0000000000000002\", span.id());\n-            assertEquals(123456789L, (long) span.timestamp());\n-            assertEquals(1000 * 1000, (long) span.duration());\n-            Map<String, String> tags = span.tags();\n-            assertEquals(\"string\", tags.get(\"stringKey\"));\n-            assertEquals(Boolean.TRUE.toString(), tags.get(\"boolKey\"));\n-            assertEquals(String.valueOf(Short.MAX_VALUE), tags.get(\"shortKey\"));\n-            assertEquals(String.valueOf(Integer.MAX_VALUE), tags.get(\"intKey\"));\n-            assertEquals(String.valueOf(Long.MAX_VALUE), tags.get(\"longKey\"));\n-            assertEquals(String.valueOf(Float.MAX_VALUE), tags.get(\"floatKey\"));\n-            assertEquals(String.valueOf(Double.MAX_VALUE), tags.get(\"doubleKey\"));\n-            assertTrue(span.annotations().stream().anyMatch(a -> a.value().equals(\"some event happened\")));\n+            verifySpan(span);\n         }\n     }\n \n-    private UdpReporter buildReporter(InetSocketAddress remoteAddress, UdpReporter.Codec codec) {\n+    private UdpReporter buildReporter(InetSocketAddress remoteAddress, Codec codec) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYyMDkyOA==", "bodyText": "Not related to this PR, but while you are here, can you please fix the close() method in line 137? The method is synchronous, but it doesn't wait until close future completes.", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424620928", "createdAt": "2020-05-13T17:47:47Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/test/java/io/servicetalk/opentracing/zipkin/publisher/reporter/UdpReporterTest.java", "diffHunk": "@@ -71,66 +70,38 @@ public void tearDown() {\n \n     @Test\n     public void testJsonV1RoundTrip() throws Exception {\n-        testRoundTrip(UdpReporter.Codec.JSON_V1, SpanBytesDecoder.JSON_V1);\n+        testRoundTrip(Codec.JSON_V1, SpanBytesDecoder.JSON_V1);\n     }\n \n     @Test\n     public void testJsonV2RoundTrip() throws Exception {\n-        testRoundTrip(UdpReporter.Codec.JSON_V2, SpanBytesDecoder.JSON_V2);\n+        testRoundTrip(Codec.JSON_V2, SpanBytesDecoder.JSON_V2);\n     }\n \n     @Test\n     public void testThriftRoundTrip() throws Exception {\n-        testRoundTrip(UdpReporter.Codec.THRIFT, SpanBytesDecoder.THRIFT);\n+        testRoundTrip(Codec.THRIFT, SpanBytesDecoder.THRIFT);\n     }\n \n     @Test\n     public void testProto3RoundTrip() throws Exception {\n-        testRoundTrip(UdpReporter.Codec.PROTO3, SpanBytesDecoder.PROTO3);\n+        testRoundTrip(Codec.PROTO3, SpanBytesDecoder.PROTO3);\n     }\n \n-    private void testRoundTrip(UdpReporter.Codec codec, SpanBytesDecoder decoder) throws Exception {\n+    private void testRoundTrip(Codec codec, SpanBytesDecoder decoder) throws Exception {\n         try (TestReceiver receiver = new TestReceiver(decoder)) {\n             try (UdpReporter reporter = buildReporter((InetSocketAddress) receiver.channel.localAddress(), codec)) {\n-                Span span = Span.newBuilder()\n-                        .name(\"test operation\")\n-                        .traceId(\"1234\")\n-                        .id(2)\n-                        .timestamp(123456789L)\n-                        .duration(SECONDS.toMicros(1))\n-                        .putTag(\"stringKey\", \"string\")\n-                        .putTag(\"boolKey\", String.valueOf(true))\n-                        .putTag(\"shortKey\", String.valueOf(Short.MAX_VALUE))\n-                        .putTag(\"intKey\", String.valueOf(Integer.MAX_VALUE))\n-                        .putTag(\"longKey\", String.valueOf(Long.MAX_VALUE))\n-                        .putTag(\"floatKey\", String.valueOf(Float.MAX_VALUE))\n-                        .putTag(\"doubleKey\", String.valueOf(Double.MAX_VALUE))\n-                        .addAnnotation(System.currentTimeMillis() * 1000, \"some event happened\")\n-                        .build();\n-                reporter.report(span);\n+                reporter.report(newSpan());\n             }\n \n             Span span = receiver.queue.take();\n \n             assertNotNull(span);\n-            assertEquals(\"test operation\", span.name());\n-            assertEquals(\"0000000000001234\", span.traceId());\n-            assertEquals(\"0000000000000002\", span.id());\n-            assertEquals(123456789L, (long) span.timestamp());\n-            assertEquals(1000 * 1000, (long) span.duration());\n-            Map<String, String> tags = span.tags();\n-            assertEquals(\"string\", tags.get(\"stringKey\"));\n-            assertEquals(Boolean.TRUE.toString(), tags.get(\"boolKey\"));\n-            assertEquals(String.valueOf(Short.MAX_VALUE), tags.get(\"shortKey\"));\n-            assertEquals(String.valueOf(Integer.MAX_VALUE), tags.get(\"intKey\"));\n-            assertEquals(String.valueOf(Long.MAX_VALUE), tags.get(\"longKey\"));\n-            assertEquals(String.valueOf(Float.MAX_VALUE), tags.get(\"floatKey\"));\n-            assertEquals(String.valueOf(Double.MAX_VALUE), tags.get(\"doubleKey\"));\n-            assertTrue(span.annotations().stream().anyMatch(a -> a.value().equals(\"some event happened\")));\n+            verifySpan(span);\n         }\n     }\n \n-    private UdpReporter buildReporter(InetSocketAddress remoteAddress, UdpReporter.Codec codec) {\n+    private UdpReporter buildReporter(InetSocketAddress remoteAddress, Codec codec) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYxODk2Ng=="}, "originalCommit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYyMTY5Nw==", "bodyText": "\ud83d\udc4d\nwhile you are here, can you please change the logger name in the same way in UdpReporter?", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424621697", "createdAt": "2020-05-13T17:49:09Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/ZipkinPublisher.java", "diffHunk": "@@ -45,8 +45,7 @@\n  * A publisher of {@link io.opentracing.Span}s to the zipkin transport.\n  */\n public final class ZipkinPublisher implements InMemorySpanEventListener, AsyncCloseable, Closeable {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(ZipkinPublisher.class);\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ZipkinPublisher.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYyOTk5Mg==", "bodyText": "This test misses another verifyRequest after the second reporter.report(newSpan()). To prevent that, consider enhancing newSpan and verifySpan utils to compare a provided name or id. e.g.:\nSpan s = newSnap(\"somename\");\nverifySpan(s, \"somename\");", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424629992", "createdAt": "2020-05-13T18:02:45Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/test/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporterTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.concurrent.api.AsyncCloseables;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.Builder;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesDecoder;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.function.UnaryOperator;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.netty.HttpClients.forSingleAddress;\n+import static io.servicetalk.http.netty.HttpServers.forAddress;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.V1_PATH;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.V2_PATH;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.SpanUtils.newSpan;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.SpanUtils.verifySpan;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static java.time.Duration.ofMillis;\n+import static java.util.Arrays.asList;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(Parameterized.class)\n+public class HttpReporterTest {\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final BlockingQueue<HttpRequest> receivedRequests;\n+    private final ServerContext context;\n+    private final Codec codec;\n+    @Nullable\n+    private HttpReporter reporter;\n+\n+    public HttpReporterTest(final Codec codec) throws Exception {\n+        this.codec = codec;\n+        receivedRequests = new LinkedBlockingQueue<>();\n+        this.context = forAddress(localAddress(0))\n+                .listenBlockingAndAwait((ctx, request, responseFactory) -> {\n+                    receivedRequests.add(request);\n+                    return responseFactory.ok();\n+                });\n+    }\n+\n+    @Parameterized.Parameters(name = \"codec: {0}\")\n+    public static Collection<Codec> data() {\n+        return asList(Codec.values());\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        CompositeCloseable closeable = AsyncCloseables.newCompositeCloseable();\n+        if (reporter != null) {\n+            closeable.append(reporter);\n+        }\n+        closeable.append(context);\n+        closeable.closeGracefully();\n+    }\n+\n+    @Test\n+    public void disableBatching() throws Exception {\n+        HttpReporter reporter = initReporter(Builder::disableSpanBatching);\n+        reporter.report(newSpan());\n+        List<Span> spans = verifyRequest(receivedRequests.take(), false);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(1));\n+        verifySpan(spans.get(0));\n+        reporter.report(newSpan());\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(1));\n+        verifySpan(spans.get(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY0MDU1OQ==", "bodyText": "Consider changing closeable type to CompositeCloseable. Then you can use closeable.close() which does the same.", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424640559", "createdAt": "2020-05-13T18:20:19Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final AsyncCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        final HttpClient client = builder.clientBuilder.build();\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final String path;\n+        final CharSequence contentType;\n+        switch (builder.codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + builder.codec);\n+        }\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        final Publisher<Buffer> spans;\n+        if (builder.disableBatching) {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.maxConcurrentReports);\n+            spans = fromSource(buffer).map(span -> allocator.wrap(spanEncoder.encode(span)));\n+        } else {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.batchSizeHint * builder.maxConcurrentReports);\n+            spans = fromSource(buffer)\n+                    .buffer(forCountOrTime(builder.batchSizeHint, builder.maxBatchDuration,\n+                            () -> new ListAccumulator(builder.batchSizeHint), client.executionContext().executor()))\n+                    .filter(accumulate -> !accumulate.isEmpty())\n+                    .map(bufferedSpans -> allocator.wrap(spanEncoder.encodeList(bufferedSpans)));\n+        }\n+\n+        final CompletableSource.Processor spansTerminated = newCompletableProcessor();\n+        toSource(spans.flatMapCompletable(encodedSpans -> reportSpans(client, encodedSpans, path, contentType),\n+                builder.maxConcurrentReports)).subscribe(spansTerminated);\n+\n+        CompositeCloseable closeable = newCompositeCloseable();\n+        closeable.append(toAsyncCloseable(graceful -> {\n+            closeInitiated = true;\n+            try {\n+                buffer.onComplete();\n+            } catch (Throwable t) {\n+                LOGGER.error(\"Failed to dispose request buffer. Ignoring.\", t);\n+            }\n+            return graceful ? fromSource(spansTerminated) : completed();\n+        }));\n+        closeable.append(client);\n+        this.closeable = closeable;\n+    }\n+\n+    private Completable reportSpans(final HttpClient client, final Buffer encodedSpans, final String path,\n+                                    final CharSequence contentType) {\n+        return client.request(client.post(path).addHeader(CONTENT_TYPE, contentType).payloadBody(encodedSpans))\n+                .ignoreElement()\n+                .onErrorResume(cause -> {\n+                    LOGGER.error(\"Failed to send a span, ignoring.\", cause);\n+                    return completed();\n+                });\n+    }\n+\n+    /**\n+     * A builder to create a new {@link HttpReporter}.\n+     */\n+    public static final class Builder {\n+        private Codec codec = Codec.JSON_V2;\n+        private final SingleAddressHttpClientBuilder<?, ?> clientBuilder;\n+        private boolean disableBatching;\n+        private int batchSizeHint = 16;\n+        private int maxConcurrentReports = 32;\n+        private Duration maxBatchDuration = ofSeconds(30);\n+\n+        /**\n+         * Create a new {@link Builder} using the passed {@link SingleAddressHttpClientBuilder}.\n+         *\n+         * @param clientBuilder the collector SocketAddress\n+         */\n+        public Builder(final SingleAddressHttpClientBuilder<?, ?> clientBuilder) {\n+            this.clientBuilder = clientBuilder;\n+        }\n+\n+        /**\n+         * Sets the {@link Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        public Builder maxConcurrentReports(final int maxConcurrentReports) {\n+            this.maxConcurrentReports = maxConcurrentReports;\n+            return this;\n+        }\n+\n+        /**\n+         * Configure batching of spans before sending it to the zipkin collector.\n+         *\n+         * @param batchSizeHint Hint of how many spans should be batched together.\n+         * @param maxBatchDuration {@link Duration} of time to wait for {@code batchSizeHint} spans in a batch.\n+         * @return {@code this}.\n+         */\n+        public Builder batchSpans(final int batchSizeHint, final Duration maxBatchDuration) {\n+            if (batchSizeHint <= 0) {\n+                throw new IllegalArgumentException(\"batchSizeHint: \" + batchSizeHint + \" (expected > 0)\");\n+            }\n+            disableBatching = false;\n+            this.batchSizeHint = batchSizeHint;\n+            this.maxBatchDuration = requireNonNull(maxBatchDuration);\n+            return this;\n+        }\n+\n+        /**\n+         * Disable batching of spans before sending them to the zipkin collector.\n+         *\n+         * @return {@code this}.\n+         */\n+        public Builder disableSpanBatching() {\n+            disableBatching = true;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link HttpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link HttpReporter}\n+         */\n+        public HttpReporter build() {\n+            return new HttpReporter(this);\n+        }\n+    }\n+\n+    @Override\n+    public void report(final Span span) {\n+        if (closeInitiated) {\n+            throw new IllegalStateException(\"Span: \" + span + \" reported after reporter \" + this + \" is closed.\");\n+        }\n+        buffer.onNext(span);\n+    }\n+\n+    @Override\n+    public void close() {\n+        awaitTermination(closeable.closeAsync().toFuture());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY0Mzc3Ng==", "bodyText": "The Component abstract class also defines check() method that always returns OK. I think we should override this method and return CheckResult.failed(Throwable) after this reporter is closed.", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424643776", "createdAt": "2020-05-13T18:25:36Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYxNzQ3Mg=="}, "originalCommit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY0NDkwNQ==", "bodyText": "Consider providing path and content-type as pkg-private methods on Codec enum.", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424644905", "createdAt": "2020-05-13T18:27:29Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final AsyncCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        final HttpClient client = builder.clientBuilder.build();\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final String path;\n+        final CharSequence contentType;\n+        switch (builder.codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY0NjAzMw==", "bodyText": "Consider saving reference for builder.codec in a final local variable to prevent concurrent state modifications between spanEncoder and switch.", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424646033", "createdAt": "2020-05-13T18:29:11Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final AsyncCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        final HttpClient client = builder.clientBuilder.build();\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY0ODcwMA==", "bodyText": "Consider creating CompositeCloseable upfront and appending the client asap. Then try-catch the whole ctor and close the closeable in case of any errors.", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424648700", "createdAt": "2020-05-13T18:33:41Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final AsyncCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        final HttpClient client = builder.clientBuilder.build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1MDA2Mw==", "bodyText": "No javadoc on this method.", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424650063", "createdAt": "2020-05-13T18:36:09Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final AsyncCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        final HttpClient client = builder.clientBuilder.build();\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final String path;\n+        final CharSequence contentType;\n+        switch (builder.codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + builder.codec);\n+        }\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        final Publisher<Buffer> spans;\n+        if (builder.disableBatching) {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.maxConcurrentReports);\n+            spans = fromSource(buffer).map(span -> allocator.wrap(spanEncoder.encode(span)));\n+        } else {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.batchSizeHint * builder.maxConcurrentReports);\n+            spans = fromSource(buffer)\n+                    .buffer(forCountOrTime(builder.batchSizeHint, builder.maxBatchDuration,\n+                            () -> new ListAccumulator(builder.batchSizeHint), client.executionContext().executor()))\n+                    .filter(accumulate -> !accumulate.isEmpty())\n+                    .map(bufferedSpans -> allocator.wrap(spanEncoder.encodeList(bufferedSpans)));\n+        }\n+\n+        final CompletableSource.Processor spansTerminated = newCompletableProcessor();\n+        toSource(spans.flatMapCompletable(encodedSpans -> reportSpans(client, encodedSpans, path, contentType),\n+                builder.maxConcurrentReports)).subscribe(spansTerminated);\n+\n+        CompositeCloseable closeable = newCompositeCloseable();\n+        closeable.append(toAsyncCloseable(graceful -> {\n+            closeInitiated = true;\n+            try {\n+                buffer.onComplete();\n+            } catch (Throwable t) {\n+                LOGGER.error(\"Failed to dispose request buffer. Ignoring.\", t);\n+            }\n+            return graceful ? fromSource(spansTerminated) : completed();\n+        }));\n+        closeable.append(client);\n+        this.closeable = closeable;\n+    }\n+\n+    private Completable reportSpans(final HttpClient client, final Buffer encodedSpans, final String path,\n+                                    final CharSequence contentType) {\n+        return client.request(client.post(path).addHeader(CONTENT_TYPE, contentType).payloadBody(encodedSpans))\n+                .ignoreElement()\n+                .onErrorResume(cause -> {\n+                    LOGGER.error(\"Failed to send a span, ignoring.\", cause);\n+                    return completed();\n+                });\n+    }\n+\n+    /**\n+     * A builder to create a new {@link HttpReporter}.\n+     */\n+    public static final class Builder {\n+        private Codec codec = Codec.JSON_V2;\n+        private final SingleAddressHttpClientBuilder<?, ?> clientBuilder;\n+        private boolean disableBatching;\n+        private int batchSizeHint = 16;\n+        private int maxConcurrentReports = 32;\n+        private Duration maxBatchDuration = ofSeconds(30);\n+\n+        /**\n+         * Create a new {@link Builder} using the passed {@link SingleAddressHttpClientBuilder}.\n+         *\n+         * @param clientBuilder the collector SocketAddress\n+         */\n+        public Builder(final SingleAddressHttpClientBuilder<?, ?> clientBuilder) {\n+            this.clientBuilder = clientBuilder;\n+        }\n+\n+        /**\n+         * Sets the {@link Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        public Builder maxConcurrentReports(final int maxConcurrentReports) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1NjI4Mw==", "bodyText": "When batching is disabled, does it matter what is the maximum number of items to buffer for the PublisherProcessor? We always subscribe and deliver items asap. Looks like in this case we can avoid having a queue or minimize its size.", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424656283", "createdAt": "2020-05-13T18:46:41Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final AsyncCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        final HttpClient client = builder.clientBuilder.build();\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final String path;\n+        final CharSequence contentType;\n+        switch (builder.codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + builder.codec);\n+        }\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        final Publisher<Buffer> spans;\n+        if (builder.disableBatching) {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.maxConcurrentReports);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1Njc0MQ==", "bodyText": "Can you please left a comment why we need to multiply batchSizeHint and maxConcurrentReports?", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424656741", "createdAt": "2020-05-13T18:47:31Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final AsyncCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        final HttpClient client = builder.clientBuilder.build();\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final String path;\n+        final CharSequence contentType;\n+        switch (builder.codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + builder.codec);\n+        }\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        final Publisher<Buffer> spans;\n+        if (builder.disableBatching) {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.maxConcurrentReports);\n+            spans = fromSource(buffer).map(span -> allocator.wrap(spanEncoder.encode(span)));\n+        } else {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.batchSizeHint * builder.maxConcurrentReports);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MTI2NA==", "bodyText": "This test verifies the same span twice.", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424661264", "createdAt": "2020-05-13T18:55:00Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/test/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporterTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.concurrent.api.AsyncCloseables;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.Builder;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesDecoder;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.function.UnaryOperator;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.netty.HttpClients.forSingleAddress;\n+import static io.servicetalk.http.netty.HttpServers.forAddress;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.V1_PATH;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.V2_PATH;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.SpanUtils.newSpan;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.SpanUtils.verifySpan;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static java.time.Duration.ofMillis;\n+import static java.util.Arrays.asList;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(Parameterized.class)\n+public class HttpReporterTest {\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final BlockingQueue<HttpRequest> receivedRequests;\n+    private final ServerContext context;\n+    private final Codec codec;\n+    @Nullable\n+    private HttpReporter reporter;\n+\n+    public HttpReporterTest(final Codec codec) throws Exception {\n+        this.codec = codec;\n+        receivedRequests = new LinkedBlockingQueue<>();\n+        this.context = forAddress(localAddress(0))\n+                .listenBlockingAndAwait((ctx, request, responseFactory) -> {\n+                    receivedRequests.add(request);\n+                    return responseFactory.ok();\n+                });\n+    }\n+\n+    @Parameterized.Parameters(name = \"codec: {0}\")\n+    public static Collection<Codec> data() {\n+        return asList(Codec.values());\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        CompositeCloseable closeable = AsyncCloseables.newCompositeCloseable();\n+        if (reporter != null) {\n+            closeable.append(reporter);\n+        }\n+        closeable.append(context);\n+        closeable.closeGracefully();\n+    }\n+\n+    @Test\n+    public void disableBatching() throws Exception {\n+        HttpReporter reporter = initReporter(Builder::disableSpanBatching);\n+        reporter.report(newSpan());\n+        List<Span> spans = verifyRequest(receivedRequests.take(), false);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(1));\n+        verifySpan(spans.get(0));\n+        reporter.report(newSpan());\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(1));\n+        verifySpan(spans.get(0));\n+    }\n+\n+    @Test\n+    public void batching() throws Exception {\n+        HttpReporter reporter = initReporter(builder -> builder.batchSpans(2, ofMillis(200)));\n+        reporter.report(newSpan());\n+        reporter.report(newSpan());\n+        List<Span> spans = verifyRequest(receivedRequests.take(), true);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(2));\n+        verifySpan(spans.get(0));\n+        verifySpan(spans.get(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MzU5MA==", "bodyText": "Consider verifying that the second batching request also works as expected and we do not send the old values again.", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424663590", "createdAt": "2020-05-13T18:58:58Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/test/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporterTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.concurrent.api.AsyncCloseables;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.Builder;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesDecoder;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.function.UnaryOperator;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.netty.HttpClients.forSingleAddress;\n+import static io.servicetalk.http.netty.HttpServers.forAddress;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.V1_PATH;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.V2_PATH;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.SpanUtils.newSpan;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.SpanUtils.verifySpan;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static java.time.Duration.ofMillis;\n+import static java.util.Arrays.asList;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(Parameterized.class)\n+public class HttpReporterTest {\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final BlockingQueue<HttpRequest> receivedRequests;\n+    private final ServerContext context;\n+    private final Codec codec;\n+    @Nullable\n+    private HttpReporter reporter;\n+\n+    public HttpReporterTest(final Codec codec) throws Exception {\n+        this.codec = codec;\n+        receivedRequests = new LinkedBlockingQueue<>();\n+        this.context = forAddress(localAddress(0))\n+                .listenBlockingAndAwait((ctx, request, responseFactory) -> {\n+                    receivedRequests.add(request);\n+                    return responseFactory.ok();\n+                });\n+    }\n+\n+    @Parameterized.Parameters(name = \"codec: {0}\")\n+    public static Collection<Codec> data() {\n+        return asList(Codec.values());\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        CompositeCloseable closeable = AsyncCloseables.newCompositeCloseable();\n+        if (reporter != null) {\n+            closeable.append(reporter);\n+        }\n+        closeable.append(context);\n+        closeable.closeGracefully();\n+    }\n+\n+    @Test\n+    public void disableBatching() throws Exception {\n+        HttpReporter reporter = initReporter(Builder::disableSpanBatching);\n+        reporter.report(newSpan());\n+        List<Span> spans = verifyRequest(receivedRequests.take(), false);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(1));\n+        verifySpan(spans.get(0));\n+        reporter.report(newSpan());\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(1));\n+        verifySpan(spans.get(0));\n+    }\n+\n+    @Test\n+    public void batching() throws Exception {\n+        HttpReporter reporter = initReporter(builder -> builder.batchSpans(2, ofMillis(200)));\n+        reporter.report(newSpan());\n+        reporter.report(newSpan());\n+        List<Span> spans = verifyRequest(receivedRequests.take(), true);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(2));\n+        verifySpan(spans.get(0));\n+        verifySpan(spans.get(0));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2MTI2NA=="}, "originalCommit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "originalPosition": 114}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6a328dd6b43e5baf254f530d7fd91fb0a6b0026", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/c6a328dd6b43e5baf254f530d7fd91fb0a6b0026", "committedDate": "2020-05-13T21:18:48Z", "message": "Review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMTQyNjIz", "url": "https://github.com/apple/servicetalk/pull/1049#pullrequestreview-411142623", "createdAt": "2020-05-13T17:24:58Z", "commit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMTo1ODoxNVrOGVE-tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMjoxMjo0MVrOGVFWiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1NDg3MA==", "bodyText": "to put it another way ... a limit is needed for back pressure and bounding memory. buffer is providing an in memory queue and there maybe an impedance mismatch between producing spans inside the application, and the client's ability to consume/send those spans.", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424754870", "createdAt": "2020-05-13T21:58:15Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final AsyncCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        final HttpClient client = builder.clientBuilder.build();\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final String path;\n+        final CharSequence contentType;\n+        switch (builder.codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + builder.codec);\n+        }\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        final Publisher<Buffer> spans;\n+        if (builder.disableBatching) {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.maxConcurrentReports);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1NjI4Mw=="}, "originalCommit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc1ODAwNg==", "bodyText": "since this is best effort, and in practice may not be triggered, does it make sense to drop this this check to avoid providing a false sense of security (e.g. it triggers in tests, but not in real world)?", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424758006", "createdAt": "2020-05-13T22:05:36Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.CheckResult;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+import static zipkin2.CheckResult.OK;\n+import static zipkin2.CheckResult.failed;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final CompositeCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        closeable = newCompositeCloseable();\n+        final HttpClient client = closeable.append(builder.clientBuilder.build());\n+        try {\n+            buffer = initReporter(builder, client);\n+        } catch (Throwable t) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                LOGGER.error(\"Failed to close the client.\", e);\n+            }\n+            throw t;\n+        }\n+    }\n+\n+    @Override\n+    public CheckResult check() {\n+        return closeInitiated ? OK : failed(new IllegalStateException(\"Reporter is closed.\"));\n+    }\n+\n+    @Override\n+    public void report(final Span span) {\n+        if (closeInitiated) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6a328dd6b43e5baf254f530d7fd91fb0a6b0026"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc2MDY5Mw==", "bodyText": "optional: consider removing this additional state and set batchSizeHint < 0 to indicate disabled", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424760693", "createdAt": "2020-05-13T22:11:54Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.CheckResult;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+import static zipkin2.CheckResult.OK;\n+import static zipkin2.CheckResult.failed;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final CompositeCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        closeable = newCompositeCloseable();\n+        final HttpClient client = closeable.append(builder.clientBuilder.build());\n+        try {\n+            buffer = initReporter(builder, client);\n+        } catch (Throwable t) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                LOGGER.error(\"Failed to close the client.\", e);\n+            }\n+            throw t;\n+        }\n+    }\n+\n+    @Override\n+    public CheckResult check() {\n+        return closeInitiated ? OK : failed(new IllegalStateException(\"Reporter is closed.\"));\n+    }\n+\n+    @Override\n+    public void report(final Span span) {\n+        if (closeInitiated) {\n+            throw new IllegalStateException(\"Span: \" + span + \" reported after reporter \" + this + \" is closed.\");\n+        }\n+        buffer.onNext(span);\n+    }\n+\n+    @Override\n+    public void close() {\n+        awaitTermination(closeable.closeAsync().toFuture());\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return closeable.closeAsync();\n+    }\n+\n+    @Override\n+    public Completable closeAsyncGracefully() {\n+        return closeable.closeAsyncGracefully();\n+    }\n+\n+    private PublisherSource.Processor<Span, Span> initReporter(final Builder builder, final HttpClient client) {\n+        final PublisherSource.Processor<Span, Span> buffer;\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        final Publisher<Buffer> spans;\n+        if (builder.disableBatching) {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.maxConcurrentReports);\n+            spans = fromSource(buffer).map(span -> allocator.wrap(spanEncoder.encode(span)));\n+        } else {\n+            // As we send maxConcurrentReports number of parallel requests, each with roughly batchSizeHint number of\n+            // spans, we hold a maximum of that many Spans in-memory that we can send in parallel to the collector.\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.batchSizeHint * builder.maxConcurrentReports);\n+            spans = fromSource(buffer)\n+                    .buffer(forCountOrTime(builder.batchSizeHint, builder.maxBatchDuration,\n+                            () -> new ListAccumulator(builder.batchSizeHint), client.executionContext().executor()))\n+                    .filter(accumulate -> !accumulate.isEmpty())\n+                    .map(bufferedSpans -> allocator.wrap(spanEncoder.encodeList(bufferedSpans)));\n+        }\n+\n+        final CompletableSource.Processor spansTerminated = newCompletableProcessor();\n+        toSource(spans.flatMapCompletable(encodedSpansReporter(client, builder.codec), builder.maxConcurrentReports))\n+                .subscribe(spansTerminated);\n+\n+        closeable.prepend(toAsyncCloseable(graceful -> {\n+            closeInitiated = true;\n+            try {\n+                buffer.onComplete();\n+            } catch (Throwable t) {\n+                LOGGER.error(\"Failed to dispose request buffer. Ignoring.\", t);\n+            }\n+            return graceful ? fromSource(spansTerminated) : completed();\n+        }));\n+\n+        return buffer;\n+    }\n+\n+    private static Function<Buffer, Completable> encodedSpansReporter(final HttpClient client, final Codec codec) {\n+        final String path;\n+        final CharSequence contentType;\n+        switch (codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + codec);\n+        }\n+        return encodedSpans -> client.request(\n+                client.post(path).addHeader(CONTENT_TYPE, contentType).payloadBody(encodedSpans))\n+                .ignoreElement()\n+                .onErrorResume(cause -> {\n+                    LOGGER.error(\"Failed to send a span, ignoring.\", cause);\n+                    return completed();\n+                });\n+    }\n+\n+    /**\n+     * A builder to create a new {@link HttpReporter}.\n+     */\n+    public static final class Builder {\n+        private Codec codec = Codec.JSON_V2;\n+        private final SingleAddressHttpClientBuilder<?, ?> clientBuilder;\n+        private boolean disableBatching;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6a328dd6b43e5baf254f530d7fd91fb0a6b0026"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc2MDk2OA==", "bodyText": "ListAccumulator seems like a very common use case, does it make sense to make this more accessible to avoid future duplication (possibly followup PR)?", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424760968", "createdAt": "2020-05-13T22:12:41Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.CheckResult;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+import static zipkin2.CheckResult.OK;\n+import static zipkin2.CheckResult.failed;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final CompositeCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        closeable = newCompositeCloseable();\n+        final HttpClient client = closeable.append(builder.clientBuilder.build());\n+        try {\n+            buffer = initReporter(builder, client);\n+        } catch (Throwable t) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                LOGGER.error(\"Failed to close the client.\", e);\n+            }\n+            throw t;\n+        }\n+    }\n+\n+    @Override\n+    public CheckResult check() {\n+        return closeInitiated ? OK : failed(new IllegalStateException(\"Reporter is closed.\"));\n+    }\n+\n+    @Override\n+    public void report(final Span span) {\n+        if (closeInitiated) {\n+            throw new IllegalStateException(\"Span: \" + span + \" reported after reporter \" + this + \" is closed.\");\n+        }\n+        buffer.onNext(span);\n+    }\n+\n+    @Override\n+    public void close() {\n+        awaitTermination(closeable.closeAsync().toFuture());\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return closeable.closeAsync();\n+    }\n+\n+    @Override\n+    public Completable closeAsyncGracefully() {\n+        return closeable.closeAsyncGracefully();\n+    }\n+\n+    private PublisherSource.Processor<Span, Span> initReporter(final Builder builder, final HttpClient client) {\n+        final PublisherSource.Processor<Span, Span> buffer;\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        final Publisher<Buffer> spans;\n+        if (builder.disableBatching) {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.maxConcurrentReports);\n+            spans = fromSource(buffer).map(span -> allocator.wrap(spanEncoder.encode(span)));\n+        } else {\n+            // As we send maxConcurrentReports number of parallel requests, each with roughly batchSizeHint number of\n+            // spans, we hold a maximum of that many Spans in-memory that we can send in parallel to the collector.\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.batchSizeHint * builder.maxConcurrentReports);\n+            spans = fromSource(buffer)\n+                    .buffer(forCountOrTime(builder.batchSizeHint, builder.maxBatchDuration,\n+                            () -> new ListAccumulator(builder.batchSizeHint), client.executionContext().executor()))\n+                    .filter(accumulate -> !accumulate.isEmpty())\n+                    .map(bufferedSpans -> allocator.wrap(spanEncoder.encodeList(bufferedSpans)));\n+        }\n+\n+        final CompletableSource.Processor spansTerminated = newCompletableProcessor();\n+        toSource(spans.flatMapCompletable(encodedSpansReporter(client, builder.codec), builder.maxConcurrentReports))\n+                .subscribe(spansTerminated);\n+\n+        closeable.prepend(toAsyncCloseable(graceful -> {\n+            closeInitiated = true;\n+            try {\n+                buffer.onComplete();\n+            } catch (Throwable t) {\n+                LOGGER.error(\"Failed to dispose request buffer. Ignoring.\", t);\n+            }\n+            return graceful ? fromSource(spansTerminated) : completed();\n+        }));\n+\n+        return buffer;\n+    }\n+\n+    private static Function<Buffer, Completable> encodedSpansReporter(final HttpClient client, final Codec codec) {\n+        final String path;\n+        final CharSequence contentType;\n+        switch (codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + codec);\n+        }\n+        return encodedSpans -> client.request(\n+                client.post(path).addHeader(CONTENT_TYPE, contentType).payloadBody(encodedSpans))\n+                .ignoreElement()\n+                .onErrorResume(cause -> {\n+                    LOGGER.error(\"Failed to send a span, ignoring.\", cause);\n+                    return completed();\n+                });\n+    }\n+\n+    /**\n+     * A builder to create a new {@link HttpReporter}.\n+     */\n+    public static final class Builder {\n+        private Codec codec = Codec.JSON_V2;\n+        private final SingleAddressHttpClientBuilder<?, ?> clientBuilder;\n+        private boolean disableBatching;\n+        private int batchSizeHint = 16;\n+        private int maxConcurrentReports = 32;\n+        private Duration maxBatchDuration = ofSeconds(30);\n+\n+        /**\n+         * Create a new {@link Builder} using the passed {@link SingleAddressHttpClientBuilder}.\n+         *\n+         * @param clientBuilder the collector SocketAddress\n+         */\n+        public Builder(final SingleAddressHttpClientBuilder<?, ?> clientBuilder) {\n+            this.clientBuilder = clientBuilder;\n+        }\n+\n+        /**\n+         * Sets the {@link Codec} to encode the Spans with.\n+         *\n+         * @param codec the codec to use for this span.\n+         * @return {@code this}\n+         */\n+        public Builder codec(Codec codec) {\n+            this.codec = requireNonNull(codec);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the maximum number of concurrent requests that will be made to the zipkin collector at any time.\n+         *\n+         * @param maxConcurrentReports maximum number of concurrent requests that will be made to the zipkin collector\n+         * at any time.\n+         * @return {@code this}.\n+         */\n+        public Builder maxConcurrentReports(final int maxConcurrentReports) {\n+            if (maxConcurrentReports <= 0) {\n+                throw new IllegalArgumentException(\"maxConcurrentReports: \" + maxConcurrentReports + \" (expected > 0)\");\n+            }\n+            this.maxConcurrentReports = maxConcurrentReports;\n+            return this;\n+        }\n+\n+        /**\n+         * Configure batching of spans before sending it to the zipkin collector.\n+         *\n+         * @param batchSizeHint Hint of how many spans should be batched together.\n+         * @param maxBatchDuration {@link Duration} of time to wait for {@code batchSizeHint} spans in a batch.\n+         * @return {@code this}.\n+         */\n+        public Builder batchSpans(final int batchSizeHint, final Duration maxBatchDuration) {\n+            if (batchSizeHint <= 0) {\n+                throw new IllegalArgumentException(\"batchSizeHint: \" + batchSizeHint + \" (expected > 0)\");\n+            }\n+            disableBatching = false;\n+            this.batchSizeHint = batchSizeHint;\n+            this.maxBatchDuration = requireNonNull(maxBatchDuration);\n+            return this;\n+        }\n+\n+        /**\n+         * Disable batching of spans before sending them to the zipkin collector.\n+         *\n+         * @return {@code this}.\n+         */\n+        public Builder disableSpanBatching() {\n+            disableBatching = true;\n+            return this;\n+        }\n+\n+        /**\n+         * Builds a new {@link HttpReporter} instance with this builder's options.\n+         *\n+         * @return a new {@link HttpReporter}\n+         */\n+        public HttpReporter build() {\n+            return new HttpReporter(this);\n+        }\n+    }\n+\n+    private static final class ListAccumulator implements Accumulator<Span, List<Span>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6a328dd6b43e5baf254f530d7fd91fb0a6b0026"}, "originalPosition": 270}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExMzQ4ODE0", "url": "https://github.com/apple/servicetalk/pull/1049#pullrequestreview-411348814", "createdAt": "2020-05-13T22:41:07Z", "commit": {"oid": "c6a328dd6b43e5baf254f530d7fd91fb0a6b0026"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMjo0MTowN1rOGVGASQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMjo1MjozNVrOGVGQZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3MTY1Nw==", "bodyText": "I see, thanks for explaining.", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424771657", "createdAt": "2020-05-13T22:41:07Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final AsyncCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        final HttpClient client = builder.clientBuilder.build();\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final String path;\n+        final CharSequence contentType;\n+        switch (builder.codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + builder.codec);\n+        }\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        final Publisher<Buffer> spans;\n+        if (builder.disableBatching) {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.maxConcurrentReports);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1NjI4Mw=="}, "originalCommit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3MjM4NQ==", "bodyText": "Let's use channel.isActive() for UdpReporter#check() as we do for UdpReporter#report(Span)?", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424772385", "createdAt": "2020-05-13T22:43:11Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDYxNzQ3Mg=="}, "originalCommit": {"oid": "0f4583663656a92aae310ebfee570188cf506515"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3MzQwMg==", "bodyText": "Consider also an assert for reporter.check() before assertThrows.", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424773402", "createdAt": "2020-05-13T22:46:03Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/test/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporterTest.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.concurrent.api.AsyncCloseables;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.Builder;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesDecoder;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.function.UnaryOperator;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.netty.HttpClients.forSingleAddress;\n+import static io.servicetalk.http.netty.HttpServers.forAddress;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.V1_PATH;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.V2_PATH;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.SpanUtils.newSpan;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.SpanUtils.verifySpan;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static java.time.Duration.ofMillis;\n+import static java.util.Arrays.asList;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(Parameterized.class)\n+public class HttpReporterTest {\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final BlockingQueue<HttpRequest> receivedRequests;\n+    private final ServerContext context;\n+    private final Codec codec;\n+    @Nullable\n+    private HttpReporter reporter;\n+\n+    public HttpReporterTest(final Codec codec) throws Exception {\n+        this.codec = codec;\n+        receivedRequests = new LinkedBlockingQueue<>();\n+        this.context = forAddress(localAddress(0))\n+                .listenBlockingAndAwait((ctx, request, responseFactory) -> {\n+                    receivedRequests.add(request);\n+                    return responseFactory.ok();\n+                });\n+    }\n+\n+    @Parameterized.Parameters(name = \"codec: {0}\")\n+    public static Collection<Codec> data() {\n+        return asList(Codec.values());\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        CompositeCloseable closeable = AsyncCloseables.newCompositeCloseable();\n+        if (reporter != null) {\n+            closeable.append(reporter);\n+        }\n+        closeable.append(context);\n+        closeable.closeGracefully();\n+    }\n+\n+    @Test\n+    public void disableBatching() throws Exception {\n+        HttpReporter reporter = initReporter(Builder::disableSpanBatching);\n+        reporter.report(newSpan(\"1\"));\n+        List<Span> spans = verifyRequest(receivedRequests.take(), false);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(1));\n+        verifySpan(spans.get(0), \"1\");\n+\n+        reporter.report(newSpan(\"2\"));\n+        List<Span> spans2 = verifyRequest(receivedRequests.take(), false);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(1));\n+        verifySpan(spans2.get(0), \"2\");\n+    }\n+\n+    @Test\n+    public void batching() throws Exception {\n+        HttpReporter reporter = initReporter(builder -> builder.batchSpans(2, ofMillis(200)));\n+        reporter.report(newSpan(\"1\"));\n+        reporter.report(newSpan(\"2\"));\n+        List<Span> spans = verifyRequest(receivedRequests.take(), true);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(2));\n+        verifySpan(spans.get(0), \"1\");\n+        verifySpan(spans.get(1), \"2\");\n+    }\n+\n+    @Test\n+    public void reportAfterClose() {\n+        HttpReporter reporter = initReporter(Builder::disableSpanBatching);\n+        reporter.close();\n+        assertThrows(\"Report post close accepted.\", IllegalStateException.class,\n+                () -> reporter.report(newSpan(\"1\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6a328dd6b43e5baf254f530d7fd91fb0a6b0026"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3NDY0Mw==", "bodyText": "Let's also add a second batching report:\nreporter.report(newSpan(\"3\"));\nreporter.report(newSpan(\"4\"));\nList<Span> spans2 = verifyRequest(receivedRequests.take(), true);\nassertThat(\"Unexpected spans received.\", spans2, hasSize(2));\nverifySpan(spans2.get(0), \"3\");\nverifySpan(spans2.get(1), \"4\");\nIt will confirm that we discard the spans that are already sent.", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424774643", "createdAt": "2020-05-13T22:49:30Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/test/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporterTest.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.concurrent.api.AsyncCloseables;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.HttpRequest;\n+import io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.Builder;\n+import io.servicetalk.transport.api.ServerContext;\n+\n+import org.junit.After;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesDecoder;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.function.UnaryOperator;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.http.netty.HttpClients.forSingleAddress;\n+import static io.servicetalk.http.netty.HttpServers.forAddress;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.V1_PATH;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.HttpReporter.V2_PATH;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.SpanUtils.newSpan;\n+import static io.servicetalk.opentracing.zipkin.publisher.reporter.SpanUtils.verifySpan;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.localAddress;\n+import static io.servicetalk.transport.netty.internal.AddressUtils.serverHostAndPort;\n+import static java.time.Duration.ofMillis;\n+import static java.util.Arrays.asList;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(Parameterized.class)\n+public class HttpReporterTest {\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final BlockingQueue<HttpRequest> receivedRequests;\n+    private final ServerContext context;\n+    private final Codec codec;\n+    @Nullable\n+    private HttpReporter reporter;\n+\n+    public HttpReporterTest(final Codec codec) throws Exception {\n+        this.codec = codec;\n+        receivedRequests = new LinkedBlockingQueue<>();\n+        this.context = forAddress(localAddress(0))\n+                .listenBlockingAndAwait((ctx, request, responseFactory) -> {\n+                    receivedRequests.add(request);\n+                    return responseFactory.ok();\n+                });\n+    }\n+\n+    @Parameterized.Parameters(name = \"codec: {0}\")\n+    public static Collection<Codec> data() {\n+        return asList(Codec.values());\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        CompositeCloseable closeable = AsyncCloseables.newCompositeCloseable();\n+        if (reporter != null) {\n+            closeable.append(reporter);\n+        }\n+        closeable.append(context);\n+        closeable.closeGracefully();\n+    }\n+\n+    @Test\n+    public void disableBatching() throws Exception {\n+        HttpReporter reporter = initReporter(Builder::disableSpanBatching);\n+        reporter.report(newSpan(\"1\"));\n+        List<Span> spans = verifyRequest(receivedRequests.take(), false);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(1));\n+        verifySpan(spans.get(0), \"1\");\n+\n+        reporter.report(newSpan(\"2\"));\n+        List<Span> spans2 = verifyRequest(receivedRequests.take(), false);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(1));\n+        verifySpan(spans2.get(0), \"2\");\n+    }\n+\n+    @Test\n+    public void batching() throws Exception {\n+        HttpReporter reporter = initReporter(builder -> builder.batchSpans(2, ofMillis(200)));\n+        reporter.report(newSpan(\"1\"));\n+        reporter.report(newSpan(\"2\"));\n+        List<Span> spans = verifyRequest(receivedRequests.take(), true);\n+        assertThat(\"Unexpected spans received.\", spans, hasSize(2));\n+        verifySpan(spans.get(0), \"1\");\n+        verifySpan(spans.get(1), \"2\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6a328dd6b43e5baf254f530d7fd91fb0a6b0026"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3NTc0MA==", "bodyText": "Before we ignoreElement, should we log (at warn or error level) any response statuses that are not SUCCESSFUL_2XX?", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424775740", "createdAt": "2020-05-13T22:52:29Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.CheckResult;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+import static zipkin2.CheckResult.OK;\n+import static zipkin2.CheckResult.failed;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final CompositeCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        closeable = newCompositeCloseable();\n+        final HttpClient client = closeable.append(builder.clientBuilder.build());\n+        try {\n+            buffer = initReporter(builder, client);\n+        } catch (Throwable t) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                LOGGER.error(\"Failed to close the client.\", e);\n+            }\n+            throw t;\n+        }\n+    }\n+\n+    @Override\n+    public CheckResult check() {\n+        return closeInitiated ? OK : failed(new IllegalStateException(\"Reporter is closed.\"));\n+    }\n+\n+    @Override\n+    public void report(final Span span) {\n+        if (closeInitiated) {\n+            throw new IllegalStateException(\"Span: \" + span + \" reported after reporter \" + this + \" is closed.\");\n+        }\n+        buffer.onNext(span);\n+    }\n+\n+    @Override\n+    public void close() {\n+        awaitTermination(closeable.closeAsync().toFuture());\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return closeable.closeAsync();\n+    }\n+\n+    @Override\n+    public Completable closeAsyncGracefully() {\n+        return closeable.closeAsyncGracefully();\n+    }\n+\n+    private PublisherSource.Processor<Span, Span> initReporter(final Builder builder, final HttpClient client) {\n+        final PublisherSource.Processor<Span, Span> buffer;\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        final Publisher<Buffer> spans;\n+        if (builder.disableBatching) {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.maxConcurrentReports);\n+            spans = fromSource(buffer).map(span -> allocator.wrap(spanEncoder.encode(span)));\n+        } else {\n+            // As we send maxConcurrentReports number of parallel requests, each with roughly batchSizeHint number of\n+            // spans, we hold a maximum of that many Spans in-memory that we can send in parallel to the collector.\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.batchSizeHint * builder.maxConcurrentReports);\n+            spans = fromSource(buffer)\n+                    .buffer(forCountOrTime(builder.batchSizeHint, builder.maxBatchDuration,\n+                            () -> new ListAccumulator(builder.batchSizeHint), client.executionContext().executor()))\n+                    .filter(accumulate -> !accumulate.isEmpty())\n+                    .map(bufferedSpans -> allocator.wrap(spanEncoder.encodeList(bufferedSpans)));\n+        }\n+\n+        final CompletableSource.Processor spansTerminated = newCompletableProcessor();\n+        toSource(spans.flatMapCompletable(encodedSpansReporter(client, builder.codec), builder.maxConcurrentReports))\n+                .subscribe(spansTerminated);\n+\n+        closeable.prepend(toAsyncCloseable(graceful -> {\n+            closeInitiated = true;\n+            try {\n+                buffer.onComplete();\n+            } catch (Throwable t) {\n+                LOGGER.error(\"Failed to dispose request buffer. Ignoring.\", t);\n+            }\n+            return graceful ? fromSource(spansTerminated) : completed();\n+        }));\n+\n+        return buffer;\n+    }\n+\n+    private static Function<Buffer, Completable> encodedSpansReporter(final HttpClient client, final Codec codec) {\n+        final String path;\n+        final CharSequence contentType;\n+        switch (codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + codec);\n+        }\n+        return encodedSpans -> client.request(\n+                client.post(path).addHeader(CONTENT_TYPE, contentType).payloadBody(encodedSpans))\n+                .ignoreElement()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6a328dd6b43e5baf254f530d7fd91fb0a6b0026"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc3NTc4Mw==", "bodyText": "Consider adding a test that verifies we recover from errors.", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424775783", "createdAt": "2020-05-13T22:52:35Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.opentracing.zipkin.publisher.reporter;\n+\n+import io.servicetalk.buffer.api.Buffer;\n+import io.servicetalk.buffer.api.BufferAllocator;\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.api.AsyncCloseable;\n+import io.servicetalk.concurrent.api.BufferStrategy.Accumulator;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.CompositeCloseable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.HttpClient;\n+import io.servicetalk.http.api.SingleAddressHttpClientBuilder;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import zipkin2.CheckResult;\n+import zipkin2.Component;\n+import zipkin2.Span;\n+import zipkin2.codec.SpanBytesEncoder;\n+import zipkin2.reporter.Reporter;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Function;\n+import javax.annotation.Nonnull;\n+\n+import static io.servicetalk.concurrent.api.AsyncCloseables.newCompositeCloseable;\n+import static io.servicetalk.concurrent.api.AsyncCloseables.toAsyncCloseable;\n+import static io.servicetalk.concurrent.api.BufferStrategies.forCountOrTime;\n+import static io.servicetalk.concurrent.api.Completable.completed;\n+import static io.servicetalk.concurrent.api.Processors.newCompletableProcessor;\n+import static io.servicetalk.concurrent.api.Processors.newPublisherProcessorDropHeadOnOverflow;\n+import static io.servicetalk.concurrent.api.SourceAdapters.fromSource;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.FutureUtils.awaitTermination;\n+import static io.servicetalk.http.api.CharSequences.newAsciiString;\n+import static io.servicetalk.http.api.HttpHeaderNames.CONTENT_TYPE;\n+import static io.servicetalk.http.api.HttpHeaderValues.APPLICATION_JSON;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.Objects.requireNonNull;\n+import static zipkin2.CheckResult.OK;\n+import static zipkin2.CheckResult.failed;\n+\n+/**\n+ * A {@link Span} {@link Reporter} that will publish to an HTTP endpoint with a configurable encoding {@link Codec}.\n+ */\n+public final class HttpReporter extends Component implements Reporter<Span>, AsyncCloseable {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(HttpReporter.class);\n+    static final String V1_PATH = \"/api/v1/spans\";\n+    static final String V2_PATH = \"/api/v2/spans\";\n+    static final CharSequence THRIFT_CONTENT_TYPE = newAsciiString(\"application/x-thrift\");\n+    static final CharSequence PROTO_CONTENT_TYPE = newAsciiString(\"application/protobuf\");\n+\n+    private final PublisherSource.Processor<Span, Span> buffer;\n+    private final CompositeCloseable closeable;\n+\n+    private volatile boolean closeInitiated;\n+\n+    private HttpReporter(final Builder builder) {\n+        closeable = newCompositeCloseable();\n+        final HttpClient client = closeable.append(builder.clientBuilder.build());\n+        try {\n+            buffer = initReporter(builder, client);\n+        } catch (Throwable t) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                LOGGER.error(\"Failed to close the client.\", e);\n+            }\n+            throw t;\n+        }\n+    }\n+\n+    @Override\n+    public CheckResult check() {\n+        return closeInitiated ? OK : failed(new IllegalStateException(\"Reporter is closed.\"));\n+    }\n+\n+    @Override\n+    public void report(final Span span) {\n+        if (closeInitiated) {\n+            throw new IllegalStateException(\"Span: \" + span + \" reported after reporter \" + this + \" is closed.\");\n+        }\n+        buffer.onNext(span);\n+    }\n+\n+    @Override\n+    public void close() {\n+        awaitTermination(closeable.closeAsync().toFuture());\n+    }\n+\n+    @Override\n+    public Completable closeAsync() {\n+        return closeable.closeAsync();\n+    }\n+\n+    @Override\n+    public Completable closeAsyncGracefully() {\n+        return closeable.closeAsyncGracefully();\n+    }\n+\n+    private PublisherSource.Processor<Span, Span> initReporter(final Builder builder, final HttpClient client) {\n+        final PublisherSource.Processor<Span, Span> buffer;\n+        SpanBytesEncoder spanEncoder = builder.codec.spanBytesEncoder();\n+        final BufferAllocator allocator = client.executionContext().bufferAllocator();\n+        final Publisher<Buffer> spans;\n+        if (builder.disableBatching) {\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.maxConcurrentReports);\n+            spans = fromSource(buffer).map(span -> allocator.wrap(spanEncoder.encode(span)));\n+        } else {\n+            // As we send maxConcurrentReports number of parallel requests, each with roughly batchSizeHint number of\n+            // spans, we hold a maximum of that many Spans in-memory that we can send in parallel to the collector.\n+            buffer = newPublisherProcessorDropHeadOnOverflow(builder.batchSizeHint * builder.maxConcurrentReports);\n+            spans = fromSource(buffer)\n+                    .buffer(forCountOrTime(builder.batchSizeHint, builder.maxBatchDuration,\n+                            () -> new ListAccumulator(builder.batchSizeHint), client.executionContext().executor()))\n+                    .filter(accumulate -> !accumulate.isEmpty())\n+                    .map(bufferedSpans -> allocator.wrap(spanEncoder.encodeList(bufferedSpans)));\n+        }\n+\n+        final CompletableSource.Processor spansTerminated = newCompletableProcessor();\n+        toSource(spans.flatMapCompletable(encodedSpansReporter(client, builder.codec), builder.maxConcurrentReports))\n+                .subscribe(spansTerminated);\n+\n+        closeable.prepend(toAsyncCloseable(graceful -> {\n+            closeInitiated = true;\n+            try {\n+                buffer.onComplete();\n+            } catch (Throwable t) {\n+                LOGGER.error(\"Failed to dispose request buffer. Ignoring.\", t);\n+            }\n+            return graceful ? fromSource(spansTerminated) : completed();\n+        }));\n+\n+        return buffer;\n+    }\n+\n+    private static Function<Buffer, Completable> encodedSpansReporter(final HttpClient client, final Codec codec) {\n+        final String path;\n+        final CharSequence contentType;\n+        switch (codec) {\n+            case JSON_V1:\n+                path = V1_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case JSON_V2:\n+                path = V2_PATH;\n+                contentType = APPLICATION_JSON;\n+                break;\n+            case THRIFT:\n+                path = V2_PATH;\n+                contentType = THRIFT_CONTENT_TYPE;\n+                break;\n+            case PROTO3:\n+                path = V2_PATH;\n+                contentType = PROTO_CONTENT_TYPE;\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown codec: \" + codec);\n+        }\n+        return encodedSpans -> client.request(\n+                client.post(path).addHeader(CONTENT_TYPE, contentType).payloadBody(encodedSpans))\n+                .ignoreElement()\n+                .onErrorResume(cause -> {\n+                    LOGGER.error(\"Failed to send a span, ignoring.\", cause);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6a328dd6b43e5baf254f530d7fd91fb0a6b0026"}, "originalPosition": 182}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "258392693fe4b99237f17ccabf1a7a0c026126c3", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/258392693fe4b99237f17ccabf1a7a0c026126c3", "committedDate": "2020-05-14T02:52:09Z", "message": "Review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNDU5OTE0", "url": "https://github.com/apple/servicetalk/pull/1049#pullrequestreview-411459914", "createdAt": "2020-05-14T04:40:49Z", "commit": {"oid": "258392693fe4b99237f17ccabf1a7a0c026126c3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDo0MDo1MFrOGVL0sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDo0MDo1MFrOGVL0sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2Njk5NA==", "bodyText": "That may log any secret header values (auth tokens). Consider not logging all the headers. Status code and maybe a payload body should be enough.", "url": "https://github.com/apple/servicetalk/pull/1049#discussion_r424866994", "createdAt": "2020-05-14T04:40:50Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-opentracing-zipkin-publisher/src/main/java/io/servicetalk/opentracing/zipkin/publisher/reporter/HttpReporter.java", "diffHunk": "@@ -177,6 +179,13 @@ public Completable closeAsyncGracefully() {\n         }\n         return encodedSpans -> client.request(\n                 client.post(path).addHeader(CONTENT_TYPE, contentType).payloadBody(encodedSpans))\n+                .beforeOnSuccess(response -> {\n+                    HttpResponseStatus status = response.status();\n+                    if (status.statusClass() != SUCCESSFUL_2XX) {\n+                        LOGGER.info(\"Unexpected response from the collector. Response headers: {}\",\n+                                response.toString((__, headerValue) -> headerValue));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "258392693fe4b99237f17ccabf1a7a0c026126c3"}, "originalPosition": 33}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3687, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}