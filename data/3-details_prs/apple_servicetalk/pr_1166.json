{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk3MTkxOTUz", "number": 1166, "title": "Add an `EmbeddedChannel` that supports `DuplexChannel` interface", "bodyText": "Motivation:\nRequestResponseCloseHandler requires a Channel to implement DuplexChannel\ninterface. To reliably reproduce some racy behavior on the network we use\nEmbeddedChannel to control all the network events manually, but it does\nnot implement DuplexChannel. Therefore, we can not use it to verify\nthe behavior of RequestResponseCloseHandler.\nModifications:\n\nImplement EmbeddedDuplexChannel test fixture that extends\nEmbeddedChannel and implements DuplexChannel interface;\nUse a new variant in all tests that require an EmbeddedChannel with\nRequestResponseCloseHandler;\nUpdate RequestResponseCloseHandler to support any DuplexChannel\nimplementations that has ALLOW_HALF_CLOSURE socket option enabled;\n\nResult:\nBetter test coverage for RequestResponseCloseHandler, no unexpected\nClassCastException(s) on the pipeline. No test-related code in\nRequestResponseCloseHandler.", "createdAt": "2020-10-03T01:09:28Z", "url": "https://github.com/apple/servicetalk/pull/1166", "merged": true, "mergeCommit": {"oid": "52a8b3d9be63c4a9feb1148c4d5481355a9e1fb9"}, "closed": true, "closedAt": "2020-10-08T21:33:50Z", "author": {"login": "idelpivnitskiy"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdOwAYVAH2gAyNDk3MTkxOTUzOjFlNWU5NmJlN2UyOWNiMDE5YTljZTI3MjdjNTY3Y2Q4ZjI1NGZkYWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQmmd9AH2gAyNDk3MTkxOTUzOmEwZDIxNTg2YTA5NTAzMDhjZjlhZDE2ZTAwMzlmNTY4NzY1NmMwOTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1e5e96be7e29cb019a9ce2727c567cd8f254fdaa", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/1e5e96be7e29cb019a9ce2727c567cd8f254fdaa", "committedDate": "2020-10-03T01:08:02Z", "message": "Add an `EmbeddedChannel` that supports `DuplexChannel` interface\n\nMotivation:\n\n`RequestResponseCloseHandler` requires a `Channel` to implement `DuplexChannel`\ninterface. To reliably reproduce some racy behavior on the network we use\n`EmbeddedChannel` to control all the network events manually, but it does\nnot implement `DuplexChannel`. Therefore, we can not use it to verify\nbehavior of `RequestResponseCloseHandler`.\n\nModifications:\n\n- Implement `EmbeddedDuplexChannel` test fixture that extends\n`EmbeddedChannel` and implements `DuplexChannel` interface;\n- Use a new variant in all tests that require an `EmbeddedChannel` with\n`RequestResponseCloseHandler`;\n- Update `RequestResponseCloseHandler` to support any `DuplexChannel`\nimplementations that has `ALLOW_HALF_CLOSURE` socket option enabled;\n\nResult:\n\nBetter test coverage for `RequestResponseCloseHandler`, no unexpected\n`ClassCastException`(s) on the pipeline."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxNTA4Nzc2", "url": "https://github.com/apple/servicetalk/pull/1166#pullrequestreview-501508776", "createdAt": "2020-10-03T01:11:30Z", "commit": {"oid": "1e5e96be7e29cb019a9ce2727c567cd8f254fdaa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QwMToxMTozMFrOHb-wvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QwMToxMTozMFrOHb-wvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMTg4NQ==", "bodyText": "@normanmaurer is it something you will be interested to see in netty? Implementation can be a bit simplified if we implement DuplexChannel for the existing EmbeddedChannel, or provide EmbeddedDuplexChannel in the same package.", "url": "https://github.com/apple/servicetalk/pull/1166#discussion_r499101885", "createdAt": "2020-10-03T01:11:30Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/testFixtures/java/io/servicetalk/transport/netty/internal/EmbeddedDuplexChannel.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelConfig;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelOutboundBuffer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.DefaultChannelConfig;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.channel.socket.ChannelInputShutdownEvent;\n+import io.netty.channel.socket.ChannelInputShutdownReadComplete;\n+import io.netty.channel.socket.DuplexChannel;\n+import io.netty.channel.socket.SocketChannelConfig;\n+\n+import java.net.SocketAddress;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.ArrayDeque;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.ALLOW_HALF_CLOSURE;\n+\n+/**\n+ * {@link EmbeddedChannel} that implements {@link DuplexChannel}.\n+ */\n+public final class EmbeddedDuplexChannel extends EmbeddedChannel implements DuplexChannel {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e5e96be7e29cb019a9ce2727c567cd8f254fdaa"}, "originalPosition": 50}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ea2664c59b1349132ffccc555429ee62344c586", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/5ea2664c59b1349132ffccc555429ee62344c586", "committedDate": "2020-10-03T15:42:11Z", "message": "Add missed gradle dependency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fda8951f6d5833ae3f3e0260e64a00557c6e0e05", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/fda8951f6d5833ae3f3e0260e64a00557c6e0e05", "committedDate": "2020-10-03T17:54:59Z", "message": "Discard new inbound and complete awaitOutputShutdown on CLOSE event"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b28f1836d087bfdbfcd6d214637aed441a6ca14", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/1b28f1836d087bfdbfcd6d214637aed441a6ca14", "committedDate": "2020-10-05T16:33:24Z", "message": "Release new ref-counted objects after shutdownInput"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MTQ2MTc3", "url": "https://github.com/apple/servicetalk/pull/1166#pullrequestreview-504146177", "createdAt": "2020-10-07T18:15:32Z", "commit": {"oid": "1b28f1836d087bfdbfcd6d214637aed441a6ca14"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxODoxNTozMlrOHd_wEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxOTozOTowM1rOHeCsXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxNTI1MA==", "bodyText": "are there tests that intentionally leave requests open that necessitates this change?", "url": "https://github.com/apple/servicetalk/pull/1166#discussion_r501215250", "createdAt": "2020-10-07T18:15:32Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/FlushStrategyOnServerTest.java", "diffHunk": "@@ -129,7 +129,7 @@ public FlushStrategyOnServerTest(final Param param) throws Exception {\n     @After\n     public void tearDown() throws Exception {\n         try {\n-            serverConnection.closeAsyncGracefully().toFuture().get();\n+            serverConnection.closeAsync().toFuture().get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b28f1836d087bfdbfcd6d214637aed441a6ca14"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIyMzQ0MQ==", "bodyText": "Agreed this belongs in Netty. we should likely also have EmbeddedChannel#config() return something that supports half closure. Currently this method is only present on SocketChannelConfig but perhaps we should  also have a DuplexChannelConfig which extracts out these methods in 5.0.", "url": "https://github.com/apple/servicetalk/pull/1166#discussion_r501223441", "createdAt": "2020-10-07T18:26:09Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/testFixtures/java/io/servicetalk/transport/netty/internal/EmbeddedDuplexChannel.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelConfig;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelOutboundBuffer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.DefaultChannelConfig;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.channel.socket.ChannelInputShutdownEvent;\n+import io.netty.channel.socket.ChannelInputShutdownReadComplete;\n+import io.netty.channel.socket.DuplexChannel;\n+import io.netty.channel.socket.SocketChannelConfig;\n+\n+import java.net.SocketAddress;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.ArrayDeque;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.ALLOW_HALF_CLOSURE;\n+\n+/**\n+ * {@link EmbeddedChannel} that implements {@link DuplexChannel}.\n+ */\n+public final class EmbeddedDuplexChannel extends EmbeddedChannel implements DuplexChannel {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMTg4NQ=="}, "originalCommit": {"oid": "1e5e96be7e29cb019a9ce2727c567cd8f254fdaa"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIzMDkxMw==", "bodyText": "the state is split between EmbeddedChannel and this class. in EmbeddedChannel it is not atomic (perhaps it should be bcz inEventLoop() is always true) and here it is atomic. Ideally this could be consolidated in Netty and use a similar strategy to Socket.java.\nThis doesn't need to block this PR but when/if this goes into Netty we should resolve this.", "url": "https://github.com/apple/servicetalk/pull/1166#discussion_r501230913", "createdAt": "2020-10-07T18:39:08Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/testFixtures/java/io/servicetalk/transport/netty/internal/EmbeddedDuplexChannel.java", "diffHunk": "@@ -0,0 +1,476 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelConfig;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelOutboundBuffer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.DefaultChannelConfig;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.channel.socket.ChannelInputShutdownEvent;\n+import io.netty.channel.socket.ChannelInputShutdownReadComplete;\n+import io.netty.channel.socket.DuplexChannel;\n+import io.netty.channel.socket.SocketChannelConfig;\n+import io.netty.util.ReferenceCountUtil;\n+\n+import java.net.SocketAddress;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.ArrayDeque;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.ALLOW_HALF_CLOSURE;\n+\n+/**\n+ * {@link EmbeddedChannel} that implements {@link DuplexChannel}.\n+ */\n+public final class EmbeddedDuplexChannel extends EmbeddedChannel implements DuplexChannel {\n+\n+    // Use atomics because shutdown may be requested from offloaded thread,\n+    // while EmbeddedEventLoop#inEventLoop() always returns `true`.\n+    private final AtomicBoolean isInputShutdown = new AtomicBoolean();\n+    private final AtomicBoolean isOutputShutdown = new AtomicBoolean();\n+\n+    private final CountDownLatch inputShutdownLatch = new CountDownLatch(1);\n+    private final CountDownLatch outputShutdownLatch = new CountDownLatch(1);\n+\n+    @Nullable\n+    private EmbeddedDuplexChannelConfig config;\n+    @Nullable\n+    private EmbeddedUnsafe unsafe;\n+\n+    /**\n+     * Create a new instance with the pipeline initialized with the specified handlers.\n+     *\n+     * @param handlers the {@link ChannelHandler}s which will be add in the {@link ChannelPipeline}\n+     */\n+    public EmbeddedDuplexChannel(ChannelHandler... handlers) {\n+        super(handlers);\n+    }\n+\n+    @Override\n+    protected void doClose() throws Exception {\n+        super.doClose();\n+        isInputShutdown.set(true);\n+        doShutdownOutput();\n+    }\n+\n+    @Override\n+    public boolean isInputShutdown() {\n+        return isInputShutdown.get();\n+    }\n+\n+    /**\n+     * Awaits completion of {@link #shutdownInput()}.\n+     *\n+     * @throws InterruptedException if the current thread was interrupted\n+     */\n+    public void awaitInputShutdown() throws InterruptedException {\n+        inputShutdownLatch.await();\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownInput() {\n+        return shutdownInput(newPromise());\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownInput(final ChannelPromise promise) {\n+        if (!isOpen()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b28f1836d087bfdbfcd6d214637aed441a6ca14"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIzMjIzOA==", "bodyText": "maybe worth adding a comment these are independent atomic variables and this maybe racy. Not sure it matters for this class usage in tests but consider using approach similar to Socket#isShutdown().", "url": "https://github.com/apple/servicetalk/pull/1166#discussion_r501232238", "createdAt": "2020-10-07T18:41:28Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/testFixtures/java/io/servicetalk/transport/netty/internal/EmbeddedDuplexChannel.java", "diffHunk": "@@ -0,0 +1,476 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelConfig;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelOutboundBuffer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.DefaultChannelConfig;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.channel.socket.ChannelInputShutdownEvent;\n+import io.netty.channel.socket.ChannelInputShutdownReadComplete;\n+import io.netty.channel.socket.DuplexChannel;\n+import io.netty.channel.socket.SocketChannelConfig;\n+import io.netty.util.ReferenceCountUtil;\n+\n+import java.net.SocketAddress;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.ArrayDeque;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.ALLOW_HALF_CLOSURE;\n+\n+/**\n+ * {@link EmbeddedChannel} that implements {@link DuplexChannel}.\n+ */\n+public final class EmbeddedDuplexChannel extends EmbeddedChannel implements DuplexChannel {\n+\n+    // Use atomics because shutdown may be requested from offloaded thread,\n+    // while EmbeddedEventLoop#inEventLoop() always returns `true`.\n+    private final AtomicBoolean isInputShutdown = new AtomicBoolean();\n+    private final AtomicBoolean isOutputShutdown = new AtomicBoolean();\n+\n+    private final CountDownLatch inputShutdownLatch = new CountDownLatch(1);\n+    private final CountDownLatch outputShutdownLatch = new CountDownLatch(1);\n+\n+    @Nullable\n+    private EmbeddedDuplexChannelConfig config;\n+    @Nullable\n+    private EmbeddedUnsafe unsafe;\n+\n+    /**\n+     * Create a new instance with the pipeline initialized with the specified handlers.\n+     *\n+     * @param handlers the {@link ChannelHandler}s which will be add in the {@link ChannelPipeline}\n+     */\n+    public EmbeddedDuplexChannel(ChannelHandler... handlers) {\n+        super(handlers);\n+    }\n+\n+    @Override\n+    protected void doClose() throws Exception {\n+        super.doClose();\n+        isInputShutdown.set(true);\n+        doShutdownOutput();\n+    }\n+\n+    @Override\n+    public boolean isInputShutdown() {\n+        return isInputShutdown.get();\n+    }\n+\n+    /**\n+     * Awaits completion of {@link #shutdownInput()}.\n+     *\n+     * @throws InterruptedException if the current thread was interrupted\n+     */\n+    public void awaitInputShutdown() throws InterruptedException {\n+        inputShutdownLatch.await();\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownInput() {\n+        return shutdownInput(newPromise());\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownInput(final ChannelPromise promise) {\n+        if (!isOpen()) {\n+            promise.setFailure(new ClosedChannelException());\n+            return promise;\n+        }\n+\n+        assert config != null;\n+        if (!config.isAllowHalfClosure()) {\n+            return close(promise);\n+        }\n+\n+        if (isInputShutdown.compareAndSet(false, true)) {\n+            pipeline().fireUserEventTriggered(ChannelInputShutdownEvent.INSTANCE);\n+            super.flushInbound();\n+            pipeline().fireUserEventTriggered(ChannelInputShutdownReadComplete.INSTANCE);\n+            inputShutdownLatch.countDown();\n+        }\n+        promise.setSuccess();\n+        return promise;\n+    }\n+\n+    @Override\n+    public boolean isOutputShutdown() {\n+        return isOutputShutdown.get();\n+    }\n+\n+    /**\n+     * Awaits completion of {@link #shutdownOutput()}.\n+     *\n+     * @throws InterruptedException if the current thread was interrupted\n+     */\n+    public void awaitOutputShutdown() throws InterruptedException {\n+        outputShutdownLatch.await();\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownOutput() {\n+        return shutdownOutput(newPromise());\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownOutput(final ChannelPromise promise) {\n+        if (!isOpen()) {\n+            promise.setFailure(new ClosedChannelException());\n+            return promise;\n+        }\n+\n+        assert config != null;\n+        if (!config.isAllowHalfClosure()) {\n+            return close(promise);\n+        }\n+\n+        assert unsafe != null;\n+        unsafe.shutdownOutput(promise);\n+        return promise;\n+    }\n+\n+    @Override\n+    protected void doShutdownOutput() {\n+        isOutputShutdown.set(true);\n+        outputShutdownLatch.countDown();\n+    }\n+\n+    @Override\n+    public boolean isShutdown() {\n+        return isInputShutdown() && isOutputShutdown();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b28f1836d087bfdbfcd6d214637aed441a6ca14"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI2MzQ1Mw==", "bodyText": "if the input is shutdown real transports will stop producing data (eventually), did you consider force clear/release when shutdown inbound happens to emulate this behavior?", "url": "https://github.com/apple/servicetalk/pull/1166#discussion_r501263453", "createdAt": "2020-10-07T19:39:03Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/testFixtures/java/io/servicetalk/transport/netty/internal/EmbeddedDuplexChannel.java", "diffHunk": "@@ -0,0 +1,476 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelConfig;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelOutboundBuffer;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.DefaultChannelConfig;\n+import io.netty.channel.EventLoop;\n+import io.netty.channel.RecvByteBufAllocator;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.channel.socket.ChannelInputShutdownEvent;\n+import io.netty.channel.socket.ChannelInputShutdownReadComplete;\n+import io.netty.channel.socket.DuplexChannel;\n+import io.netty.channel.socket.SocketChannelConfig;\n+import io.netty.util.ReferenceCountUtil;\n+\n+import java.net.SocketAddress;\n+import java.nio.channels.ClosedChannelException;\n+import java.util.ArrayDeque;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import javax.annotation.Nullable;\n+\n+import static io.netty.channel.ChannelOption.ALLOW_HALF_CLOSURE;\n+\n+/**\n+ * {@link EmbeddedChannel} that implements {@link DuplexChannel}.\n+ */\n+public final class EmbeddedDuplexChannel extends EmbeddedChannel implements DuplexChannel {\n+\n+    // Use atomics because shutdown may be requested from offloaded thread,\n+    // while EmbeddedEventLoop#inEventLoop() always returns `true`.\n+    private final AtomicBoolean isInputShutdown = new AtomicBoolean();\n+    private final AtomicBoolean isOutputShutdown = new AtomicBoolean();\n+\n+    private final CountDownLatch inputShutdownLatch = new CountDownLatch(1);\n+    private final CountDownLatch outputShutdownLatch = new CountDownLatch(1);\n+\n+    @Nullable\n+    private EmbeddedDuplexChannelConfig config;\n+    @Nullable\n+    private EmbeddedUnsafe unsafe;\n+\n+    /**\n+     * Create a new instance with the pipeline initialized with the specified handlers.\n+     *\n+     * @param handlers the {@link ChannelHandler}s which will be add in the {@link ChannelPipeline}\n+     */\n+    public EmbeddedDuplexChannel(ChannelHandler... handlers) {\n+        super(handlers);\n+    }\n+\n+    @Override\n+    protected void doClose() throws Exception {\n+        super.doClose();\n+        isInputShutdown.set(true);\n+        doShutdownOutput();\n+    }\n+\n+    @Override\n+    public boolean isInputShutdown() {\n+        return isInputShutdown.get();\n+    }\n+\n+    /**\n+     * Awaits completion of {@link #shutdownInput()}.\n+     *\n+     * @throws InterruptedException if the current thread was interrupted\n+     */\n+    public void awaitInputShutdown() throws InterruptedException {\n+        inputShutdownLatch.await();\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownInput() {\n+        return shutdownInput(newPromise());\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownInput(final ChannelPromise promise) {\n+        if (!isOpen()) {\n+            promise.setFailure(new ClosedChannelException());\n+            return promise;\n+        }\n+\n+        assert config != null;\n+        if (!config.isAllowHalfClosure()) {\n+            return close(promise);\n+        }\n+\n+        if (isInputShutdown.compareAndSet(false, true)) {\n+            pipeline().fireUserEventTriggered(ChannelInputShutdownEvent.INSTANCE);\n+            super.flushInbound();\n+            pipeline().fireUserEventTriggered(ChannelInputShutdownReadComplete.INSTANCE);\n+            inputShutdownLatch.countDown();\n+        }\n+        promise.setSuccess();\n+        return promise;\n+    }\n+\n+    @Override\n+    public boolean isOutputShutdown() {\n+        return isOutputShutdown.get();\n+    }\n+\n+    /**\n+     * Awaits completion of {@link #shutdownOutput()}.\n+     *\n+     * @throws InterruptedException if the current thread was interrupted\n+     */\n+    public void awaitOutputShutdown() throws InterruptedException {\n+        outputShutdownLatch.await();\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownOutput() {\n+        return shutdownOutput(newPromise());\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdownOutput(final ChannelPromise promise) {\n+        if (!isOpen()) {\n+            promise.setFailure(new ClosedChannelException());\n+            return promise;\n+        }\n+\n+        assert config != null;\n+        if (!config.isAllowHalfClosure()) {\n+            return close(promise);\n+        }\n+\n+        assert unsafe != null;\n+        unsafe.shutdownOutput(promise);\n+        return promise;\n+    }\n+\n+    @Override\n+    protected void doShutdownOutput() {\n+        isOutputShutdown.set(true);\n+        outputShutdownLatch.countDown();\n+    }\n+\n+    @Override\n+    public boolean isShutdown() {\n+        return isInputShutdown() && isOutputShutdown();\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdown() {\n+        return shutdown(newPromise());\n+    }\n+\n+    @Override\n+    public ChannelFuture shutdown(final ChannelPromise promise) {\n+        ChannelFuture shutdownOutputFuture = shutdownOutput();\n+        if (shutdownOutputFuture.isDone()) {\n+            shutdownOutputDone(shutdownOutputFuture, promise);\n+        } else {\n+            shutdownOutputFuture.addListener((ChannelFutureListener) sof -> shutdownOutputDone(sof, promise));\n+        }\n+        return promise;\n+    }\n+\n+    private void shutdownOutputDone(final ChannelFuture shutdownOutputFuture, final ChannelPromise promise) {\n+        ChannelFuture shutdownInputFuture = shutdownInput();\n+        if (shutdownInputFuture.isDone()) {\n+            shutdownDone(shutdownOutputFuture, shutdownInputFuture, promise);\n+        } else {\n+            shutdownInputFuture.addListener((ChannelFutureListener) sif ->\n+                    shutdownDone(shutdownOutputFuture, sif, promise));\n+        }\n+    }\n+\n+    private static void shutdownDone(ChannelFuture shutdownOutputFuture,\n+                                     ChannelFuture shutdownInputFuture,\n+                                     ChannelPromise promise) {\n+        Throwable shutdownOutputCause = shutdownOutputFuture.cause();\n+        Throwable shutdownInputCause = shutdownInputFuture.cause();\n+        if (shutdownOutputCause != null) {\n+            if (shutdownInputCause != null) {\n+                shutdownOutputCause.addSuppressed(shutdownInputCause);\n+            }\n+            promise.setFailure(shutdownOutputCause);\n+        } else if (shutdownInputCause != null) {\n+            promise.setFailure(shutdownInputCause);\n+        } else {\n+            promise.setSuccess();\n+        }\n+    }\n+\n+    @Override\n+    public Queue<Object> inboundMessages() {\n+        if (isInputShutdown.get()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b28f1836d087bfdbfcd6d214637aed441a6ca14"}, "originalPosition": 215}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0d21586a0950308cf9ad16e0039f5687656c094", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/a0d21586a0950308cf9ad16e0039f5687656c094", "committedDate": "2020-10-08T19:18:26Z", "message": "Address comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3502, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}