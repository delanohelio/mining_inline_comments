{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0NTExOTc2", "number": 936, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMDoyNDo1NFrODfUjUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMDoyNDo1NFrODfUjUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTY5MTcwOnYy", "diffSide": "RIGHT", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpObjectEncoder.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMDoyNDo1NFrOFo9Ypg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMTo0OTo0OVrOFqEqLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ5MzA5NA==", "bodyText": "Transport needs direct memory for the outgoing data and after this handler users do not touch buffers anymore. So, this helps to prevent additional copy in transport when users configure buffer allocator to prefer heap memory.\n@normanmaurer as there any specific reason to use buffer method here instead of directBuffer or ioBuffer in similar handler in netty?\nhttps://github.com/netty/netty/blob/fcf55fcf718af1e4cae85eb86cdb679094186aed/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectEncoder.java#L93", "url": "https://github.com/apple/servicetalk/pull/936#discussion_r378493094", "createdAt": "2020-02-12T20:24:54Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpObjectEncoder.java", "diffHunk": "@@ -125,7 +125,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n             // We prefer a direct allocation here because it is expected the resulted encoded Buffer will be written\n             // to a socket. In order to do the write to the socket the memory typically needs to be allocated in direct\n             // memory and will be copied to direct memory if not. Using a direct buffer will avoid the copy.\n-            ByteBuf byteBuf = POOLED_ALLOCATOR.buffer((int) headersEncodedSizeAccumulator);\n+            ByteBuf byteBuf = POOLED_ALLOCATOR.directBuffer((int) headersEncodedSizeAccumulator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f66f66104a2173d468c3dabd36ece04758643090"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODcxNTM4OQ==", "bodyText": "usually we use buffer so the user has pretty much control over what type of buffer is allocated. And by default buffer(...) will return a direct buffer in netty anyway", "url": "https://github.com/apple/servicetalk/pull/936#discussion_r378715389", "createdAt": "2020-02-13T08:36:53Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpObjectEncoder.java", "diffHunk": "@@ -125,7 +125,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n             // We prefer a direct allocation here because it is expected the resulted encoded Buffer will be written\n             // to a socket. In order to do the write to the socket the memory typically needs to be allocated in direct\n             // memory and will be copied to direct memory if not. Using a direct buffer will avoid the copy.\n-            ByteBuf byteBuf = POOLED_ALLOCATOR.buffer((int) headersEncodedSizeAccumulator);\n+            ByteBuf byteBuf = POOLED_ALLOCATOR.directBuffer((int) headersEncodedSizeAccumulator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ5MzA5NA=="}, "originalCommit": {"oid": "f66f66104a2173d468c3dabd36ece04758643090"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAwMDk3NQ==", "bodyText": "Agreed, this is by default in netty. But this \"control\" leads to overhead, because transport needs to copy to direct memory anyway. Not sure about netty, because users may have other handlers between transport and HttpObjectEncoder with their logic, but for ST I think it makes sense to always use direct buffers here.", "url": "https://github.com/apple/servicetalk/pull/936#discussion_r379000975", "createdAt": "2020-02-13T17:13:26Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpObjectEncoder.java", "diffHunk": "@@ -125,7 +125,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n             // We prefer a direct allocation here because it is expected the resulted encoded Buffer will be written\n             // to a socket. In order to do the write to the socket the memory typically needs to be allocated in direct\n             // memory and will be copied to direct memory if not. Using a direct buffer will avoid the copy.\n-            ByteBuf byteBuf = POOLED_ALLOCATOR.buffer((int) headersEncodedSizeAccumulator);\n+            ByteBuf byteBuf = POOLED_ALLOCATOR.directBuffer((int) headersEncodedSizeAccumulator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ5MzA5NA=="}, "originalCommit": {"oid": "f66f66104a2173d468c3dabd36ece04758643090"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA3MzExOA==", "bodyText": "@idelpivnitskiy looks like @normanmaurer is saying that buffer() will anways return direct buffers. Is this change just to be explicit or you found an issue?", "url": "https://github.com/apple/servicetalk/pull/936#discussion_r379073118", "createdAt": "2020-02-13T19:30:43Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpObjectEncoder.java", "diffHunk": "@@ -125,7 +125,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n             // We prefer a direct allocation here because it is expected the resulted encoded Buffer will be written\n             // to a socket. In order to do the write to the socket the memory typically needs to be allocated in direct\n             // memory and will be copied to direct memory if not. Using a direct buffer will avoid the copy.\n-            ByteBuf byteBuf = POOLED_ALLOCATOR.buffer((int) headersEncodedSizeAccumulator);\n+            ByteBuf byteBuf = POOLED_ALLOCATOR.directBuffer((int) headersEncodedSizeAccumulator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ5MzA5NA=="}, "originalCommit": {"oid": "f66f66104a2173d468c3dabd36ece04758643090"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA4Njk0NA==", "bodyText": "@NiteshKant he is saying that this is by default in netty, but the actual type depends on the configuration of the provided buffer allocator or io.netty.noPreferDirectFlag=true system property. This is outgoing path and transport anyway requires direct memory. So, to reduce overhead of copying from heap to direct memory at transport level, we should ignore what users prefer and always use direct buffers here. Their preference of heap memory makes sense only when they allocate buffers in code they control, but not in transport or this encoder.", "url": "https://github.com/apple/servicetalk/pull/936#discussion_r379086944", "createdAt": "2020-02-13T19:58:21Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpObjectEncoder.java", "diffHunk": "@@ -125,7 +125,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n             // We prefer a direct allocation here because it is expected the resulted encoded Buffer will be written\n             // to a socket. In order to do the write to the socket the memory typically needs to be allocated in direct\n             // memory and will be copied to direct memory if not. Using a direct buffer will avoid the copy.\n-            ByteBuf byteBuf = POOLED_ALLOCATOR.buffer((int) headersEncodedSizeAccumulator);\n+            ByteBuf byteBuf = POOLED_ALLOCATOR.directBuffer((int) headersEncodedSizeAccumulator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ5MzA5NA=="}, "originalCommit": {"oid": "f66f66104a2173d468c3dabd36ece04758643090"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY2MDg0NQ==", "bodyText": "got it, thanks!", "url": "https://github.com/apple/servicetalk/pull/936#discussion_r379660845", "createdAt": "2020-02-14T21:49:49Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpObjectEncoder.java", "diffHunk": "@@ -125,7 +125,7 @@ public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)\n             // We prefer a direct allocation here because it is expected the resulted encoded Buffer will be written\n             // to a socket. In order to do the write to the socket the memory typically needs to be allocated in direct\n             // memory and will be copied to direct memory if not. Using a direct buffer will avoid the copy.\n-            ByteBuf byteBuf = POOLED_ALLOCATOR.buffer((int) headersEncodedSizeAccumulator);\n+            ByteBuf byteBuf = POOLED_ALLOCATOR.directBuffer((int) headersEncodedSizeAccumulator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ5MzA5NA=="}, "originalCommit": {"oid": "f66f66104a2173d468c3dabd36ece04758643090"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2847, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}