{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxOTA5NDQ5", "number": 1134, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzowMjoyOFrOEbqYEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzoyNDoxMlrOEbq7qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDQxMjk2OnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/NettyPipelineSslUtils.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzowMjoyOFrOHFuOxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMzozMjoxNlrOHF6WLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc2MjM3NA==", "bodyText": "We should avoid failing the normal operations due to issues with observability. Doing this make the observability failures non-recoverable which isn't desirable as opposed to continuing with degraded observability.", "url": "https://github.com/apple/servicetalk/pull/1134#discussion_r475762374", "createdAt": "2020-08-24T17:02:28Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/NettyPipelineSslUtils.java", "diffHunk": "@@ -60,7 +60,21 @@ public static SSLSession extractSslSessionAndReport(ChannelPipeline pipeline,\n                                                         SslHandshakeCompletionEvent sslEvent,\n                                                         Consumer<Throwable> failureConsumer,\n                                                         boolean shouldReport) {\n-        final SecurityHandshakeObserver observer = shouldReport ? handshakeObserver(pipeline) : null;\n+        final SecurityHandshakeObserver observer;\n+        if (shouldReport) {\n+            try {\n+                observer = handshakeObserver(pipeline);\n+            } catch (Exception e) {\n+                if (!sslEvent.isSuccess()) {\n+                    e.addSuppressed(sslEvent.cause());\n+                }\n+                deliverFailureCause(failureConsumer, e, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f390ff9ad9d0e5d97d5a7c229ba3524ef2d48cc"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3NjYwMg==", "bodyText": "There is nothing that users can do to misconfigure and hit this error. If they pass a custom transport observer, it won't happen. Also, users don't have ways to modify the pipeline.\nThis is only for us, as developers, to make sure that new protocols that we add do not have misconfiguration around observability. Any test that uses SSL for a new protocol will fail if shouldReport is true, but pipeline does not have a handler. It helps to avoid writing an additional test to verify that new protocol reports handshake status to SecurityHandshakeObserver.\nI don't have a strong opinion here, can remove it if it's not necessary.", "url": "https://github.com/apple/servicetalk/pull/1134#discussion_r475876602", "createdAt": "2020-08-24T20:32:19Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/NettyPipelineSslUtils.java", "diffHunk": "@@ -60,7 +60,21 @@ public static SSLSession extractSslSessionAndReport(ChannelPipeline pipeline,\n                                                         SslHandshakeCompletionEvent sslEvent,\n                                                         Consumer<Throwable> failureConsumer,\n                                                         boolean shouldReport) {\n-        final SecurityHandshakeObserver observer = shouldReport ? handshakeObserver(pipeline) : null;\n+        final SecurityHandshakeObserver observer;\n+        if (shouldReport) {\n+            try {\n+                observer = handshakeObserver(pipeline);\n+            } catch (Exception e) {\n+                if (!sslEvent.isSuccess()) {\n+                    e.addSuppressed(sslEvent.cause());\n+                }\n+                deliverFailureCause(failureConsumer, e, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc2MjM3NA=="}, "originalCommit": {"oid": "1f390ff9ad9d0e5d97d5a7c229ba3524ef2d48cc"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk2MDg3Ng==", "bodyText": "known errors are avoidable, unknown errors are the problem with such things. Being pessimistic is better, so will suggest removing.", "url": "https://github.com/apple/servicetalk/pull/1134#discussion_r475960876", "createdAt": "2020-08-24T23:32:16Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/NettyPipelineSslUtils.java", "diffHunk": "@@ -60,7 +60,21 @@ public static SSLSession extractSslSessionAndReport(ChannelPipeline pipeline,\n                                                         SslHandshakeCompletionEvent sslEvent,\n                                                         Consumer<Throwable> failureConsumer,\n                                                         boolean shouldReport) {\n-        final SecurityHandshakeObserver observer = shouldReport ? handshakeObserver(pipeline) : null;\n+        final SecurityHandshakeObserver observer;\n+        if (shouldReport) {\n+            try {\n+                observer = handshakeObserver(pipeline);\n+            } catch (Exception e) {\n+                if (!sslEvent.isSuccess()) {\n+                    e.addSuppressed(sslEvent.cause());\n+                }\n+                deliverFailureCause(failureConsumer, e, null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc2MjM3NA=="}, "originalCommit": {"oid": "1f390ff9ad9d0e5d97d5a7c229ba3524ef2d48cc"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NDUwNDEwOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzoyNDoxMlrOHFvHTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMzozNDoxNVrOHF6bSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3Njg0Nw==", "bodyText": "I was hoping shouldReport to go away. AFAIU, it is required because we are adding the ConnectionObserverHandler conditionally. Can we add the handler unconditionally?\nMy motivation here is to remove conditional code based on instance checks which assumes that an observer is homogeneous => an observer can not be partially NOOP.", "url": "https://github.com/apple/servicetalk/pull/1134#discussion_r475776847", "createdAt": "2020-08-24T17:24:12Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -641,7 +640,7 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n                 connection.nettyChannelPublisher.channelInboundClosed();\n             } else if (evt instanceof SslHandshakeCompletionEvent) {\n                 connection.sslSession = extractSslSessionAndReport(ctx.pipeline(), (SslHandshakeCompletionEvent) evt,\n-                        this::tryFailSubscriber, observer != null);\n+                        this::tryFailSubscriber, observer != NoopConnectionObserver.INSTANCE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f390ff9ad9d0e5d97d5a7c229ba3524ef2d48cc"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3NjYyNQ==", "bodyText": "Because we anyway need to have some NOOP impl, I use an internal NoopTransportObserver as a default when no observer is configured by users. For this case we have an opportunity to optimize and skip unnecessary handlers and operators.\nFor the case when users add a custom observer (even partially NOOP), we don't need to optimize those use-cases. Therefore, a reference check only for out impl is enough.\nInstead of adding ConnectionObserverHandler unconditionally, we can simplify extractSslSessionAndReport and look up for the handler unconditionally. But it will require us to write a test for SecurityHandshakeObserver every time we add a new protocol, as described in my previous comment.", "url": "https://github.com/apple/servicetalk/pull/1134#discussion_r475876625", "createdAt": "2020-08-24T20:32:21Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -641,7 +640,7 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n                 connection.nettyChannelPublisher.channelInboundClosed();\n             } else if (evt instanceof SslHandshakeCompletionEvent) {\n                 connection.sslSession = extractSslSessionAndReport(ctx.pipeline(), (SslHandshakeCompletionEvent) evt,\n-                        this::tryFailSubscriber, observer != null);\n+                        this::tryFailSubscriber, observer != NoopConnectionObserver.INSTANCE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3Njg0Nw=="}, "originalCommit": {"oid": "1f390ff9ad9d0e5d97d5a7c229ba3524ef2d48cc"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk2MjE4NA==", "bodyText": "But it will require us to write a test for SecurityHandshakeObserver every time we add a new protocol\n\nAs adding new protocols is less frequent, I think it is fair to trade-off code clarity in this case.\n\nlook up for the handler unconditionally.\n\nsgtm", "url": "https://github.com/apple/servicetalk/pull/1134#discussion_r475962184", "createdAt": "2020-08-24T23:34:15Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -641,7 +640,7 @@ public void userEventTriggered(ChannelHandlerContext ctx, Object evt) {\n                 connection.nettyChannelPublisher.channelInboundClosed();\n             } else if (evt instanceof SslHandshakeCompletionEvent) {\n                 connection.sslSession = extractSslSessionAndReport(ctx.pipeline(), (SslHandshakeCompletionEvent) evt,\n-                        this::tryFailSubscriber, observer != null);\n+                        this::tryFailSubscriber, observer != NoopConnectionObserver.INSTANCE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc3Njg0Nw=="}, "originalCommit": {"oid": "1f390ff9ad9d0e5d97d5a7c229ba3524ef2d48cc"}, "originalPosition": 112}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2553, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}