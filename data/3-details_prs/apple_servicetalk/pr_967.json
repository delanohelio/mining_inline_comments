{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg4MDA4NTI1", "number": 967, "title": "Ensure `TcpConnector#connect` does not emit error after success", "bodyText": "Motivation\nTcpConnector#connect eagerly terminates the Single when the channel is registered. It also terminates the Single with failure if connect fails.\nThis violates the contract of the Subscriber that there should only be a single termination signal.\nModification\nAs we have to complete the returned Single with the channel as soon as the channel is registered to ensure we do not miss channel events and we also have to propagate connect failures, we can not abide by the Single<Channel> contract. Instead of returning Single<Channel> now returning Single<Connection> and do the translation of Channel -> Connection using a supplied Function.\nResult\nTcpConnector#connect abides by the Subscriber contract.", "createdAt": "2020-03-13T21:45:48Z", "url": "https://github.com/apple/servicetalk/pull/967", "merged": true, "mergeCommit": {"oid": "c4d421fc6f4339c3fc3ac2da75da5962f5df9d0d"}, "closed": true, "closedAt": "2020-03-17T17:03:46Z", "author": {"login": "NiteshKant"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcNXbh3gH2gAyMzg4MDA4NTI1OmRkZjU0N2Q0MzE3MDQ4NmZhN2VmNGNhNDg2NmVjOTIxNTVmMzMyOGM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcOlDTXgH2gAyMzg4MDA4NTI1Ojc4N2VjMzgzNGM4YmMxMmEzM2FhNzUyZDZhMjBlMmU3Y2VkOTI3OTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ddf547d43170486fa7ef4ca4866ec92155f3328c", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/ddf547d43170486fa7ef4ca4866ec92155f3328c", "committedDate": "2020-03-13T21:44:59Z", "message": "Ensure `TcpConnector#connect` does not emit error after success\n\n__Motivation__\n\n`TcpConnector#connect` eagerly terminates the `Single` when the channel is registered. It also terminates the `Single` with failure if connect fails.\nThis violates the contract of the `Subscriber` that there should only be a single termination signal.\n\n__Modification__\n\nAs we have to complete the returned `Single` with the channel as soon as the channel is registered to ensure we do not miss channel events and we also have to propagate connect failures, we can not abide by the `Single<Channel>` contract. Instead of returning `Single<Channel>` now returning `Single<Connection>` and do the translation of `Channel` -> `Connection` using a supplied `Function`.\n\n__Result__\n\n`TcpConnector#connect` abides by the `Subscriber` contract."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1MDU2MDYz", "url": "https://github.com/apple/servicetalk/pull/967#pullrequestreview-375056063", "createdAt": "2020-03-16T09:57:10Z", "commit": {"oid": "ddf547d43170486fa7ef4ca4866ec92155f3328c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwOTo1NzoxMFrOF2soJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwOTo1NzoxMFrOF2soJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg5ODU5Ng==", "bodyText": "nit: is this really what happens ? It seems like it is not blocking and so not await.", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r392898596", "createdAt": "2020-03-16T09:57:10Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-tcp-netty-internal/src/testFixtures/java/io/servicetalk/tcp/netty/internal/TcpClient.java", "diffHunk": "@@ -82,13 +83,24 @@ public TcpClient(TcpClientConfig config) {\n      */\n     public NettyConnection<Buffer, Buffer> connectBlocking(ExecutionContext executionContext, SocketAddress address)\n             throws ExecutionException, InterruptedException {\n-        return TcpConnector.connect(null, address, config, false, executionContext)\n-                .flatMap(channel -> DefaultNettyConnection.<Buffer, Buffer>initChannel(channel,\n+        return connect(executionContext, address).toFuture().get();\n+    }\n+\n+    /**\n+     * Connect and await for the connection.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddf547d43170486fa7ef4ca4866ec92155f3328c"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NjMwNTgy", "url": "https://github.com/apple/servicetalk/pull/967#pullrequestreview-375630582", "createdAt": "2020-03-16T22:41:31Z", "commit": {"oid": "ddf547d43170486fa7ef4ca4866ec92155f3328c"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMjo0MTozMVrOF3IKgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMjo0Nzo1N1rOF3ISnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM0OTc2Mw==", "bodyText": "Consider verifying if connectFuture is already done before applying the listener, as we do in other places:\n\n  \n    \n      servicetalk/servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsServiceDiscoverer.java\n    \n    \n        Lines 370 to 376\n      in\n      e5f4c56\n    \n    \n    \n    \n\n        \n          \n           final Future<List<InetAddress>> addressFuture = resolver.resolveAll(inetHost); \n        \n\n        \n          \n           cancellableForQuery = () -> addressFuture.cancel(true); \n        \n\n        \n          \n           if (addressFuture.isDone()) { \n        \n\n        \n          \n               handleResolveDone0(addressFuture); \n        \n\n        \n          \n           } else { \n        \n\n        \n          \n               addressFuture.addListener((FutureListener<List<InetAddress>>) this::handleResolveDone0); \n        \n\n        \n          \n           }", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393349763", "createdAt": "2020-03-16T22:41:31Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "diffHunk": "@@ -68,67 +76,74 @@ private TcpConnector() {\n      * @param config The {@link ReadOnlyTcpClientConfig} to use while connecting.\n      * @param autoRead if {@code true} auto read will be enabled for new {@link Channel}s.\n      * @param executionContext The {@link ExecutionContext} to use for the returned {@link NettyConnection}.\n+     * @param connectionFactory {@link Function} to create a {@link NettyConnection} asynchronously.\n+     * @param <C> Type of the created connection.\n      * @return A {@link Single} that completes with a new {@link Channel} when connected.\n      */\n-    public static Single<Channel> connect(@Nullable SocketAddress localAddress, Object resolvedRemoteAddress,\n-                                          ReadOnlyTcpClientConfig config, boolean autoRead,\n-                                          ExecutionContext executionContext) {\n+    public static <C extends ListenableAsyncCloseable> Single<C> connect(\n+            final @Nullable SocketAddress localAddress, final Object resolvedRemoteAddress,\n+            final ReadOnlyTcpClientConfig config, final boolean autoRead, final ExecutionContext executionContext,\n+            final Function<Channel, Single<? extends C>> connectionFactory) {\n         requireNonNull(resolvedRemoteAddress);\n         requireNonNull(config);\n         requireNonNull(executionContext);\n-        return new SubscribableSingle<Channel>() {\n+        return new SubscribableSingle<C>() {\n             @Override\n-            protected void handleSubscribe(final Subscriber<? super Channel> subscriber) {\n-                connectFutureToListener(localAddress, resolvedRemoteAddress, subscriber,\n-                        connect0(localAddress, resolvedRemoteAddress, config, autoRead, executionContext, subscriber));\n+            protected void handleSubscribe(final Subscriber<? super C> subscriber) {\n+                ConnectHandler<C> connectHandler = new ConnectHandler<>(subscriber, connectionFactory);\n+                try {\n+                    Future<?> connectFuture = connect0(localAddress, resolvedRemoteAddress, config, autoRead,\n+                            executionContext, connectHandler);\n+                    connectHandler.connectFuture(connectFuture);\n+                    connectFuture.addListener(f -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddf547d43170486fa7ef4ca4866ec92155f3328c"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1MTgzNw==", "bodyText": "SingleSource.Subscriber defines a parameter for onSuccess as @Nullable. Instead of throwing from here, should we propagate onError instead?", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393351837", "createdAt": "2020-03-16T22:47:57Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "diffHunk": "@@ -209,4 +206,87 @@ private NoopNettyAddressResolverGroup() {\n             return NOOP_ADDRESS_RESOLVER;\n         }\n     }\n+\n+    private static final class ConnectHandler<C extends ListenableAsyncCloseable> implements Consumer<Channel> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(ConnectHandler.class);\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<ConnectHandler> terminatedUpdater =\n+                newUpdater(ConnectHandler.class, \"terminated\");\n+\n+        private final DelayedCancellable futureCancellable = new DelayedCancellable();\n+        private final DelayedCancellable flatMapCancellable = new DelayedCancellable();\n+        private final Subscriber<? super C> target;\n+        private final Function<Channel, Single<? extends C>> connectionFactory;\n+\n+        private volatile int terminated;\n+\n+        ConnectHandler(final Subscriber<? super C> target,\n+                       final Function<Channel, Single<? extends C>> connectionFactory) {\n+            this.target = target;\n+            this.connectionFactory = connectionFactory;\n+            target.onSubscribe(() -> {\n+                try {\n+                    futureCancellable.cancel();\n+                } finally {\n+                    flatMapCancellable.cancel();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public void accept(final Channel channel) {\n+            toSource(connectionFactory.apply(channel)\n+                    .subscribeShareContext())\n+                    .subscribe(new Subscriber<C>() {\n+                        @Override\n+                        public void onSubscribe(final Cancellable cancellable) {\n+                            flatMapCancellable.delayedCancellable(cancellable);\n+                        }\n+\n+                        @Override\n+                        public void onSuccess(final C connection) {\n+                            requireNonNull(connection);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddf547d43170486fa7ef4ca4866ec92155f3328c"}, "originalPosition": 226}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4f1cd98ba8a101b240047482564f7303c28b064", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/c4f1cd98ba8a101b240047482564f7303c28b064", "committedDate": "2020-03-17T00:11:43Z", "message": "Review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1ae0305f9655f24e37383e5ab65e73601a3b06e", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/e1ae0305f9655f24e37383e5ab65e73601a3b06e", "committedDate": "2020-03-17T00:12:55Z", "message": "Merge remote-tracking branch 'upstream/master' into connector-fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1NjYzOTIy", "url": "https://github.com/apple/servicetalk/pull/967#pullrequestreview-375663922", "createdAt": "2020-03-17T00:20:38Z", "commit": {"oid": "e1ae0305f9655f24e37383e5ab65e73601a3b06e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMDoyMDozOFrOF3KBUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMDoyMDozOFrOF3KBUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4MDE3OA==", "bodyText": "Do we assume that downstream target Subscriber will handle null instead of a connection? I think it's easy to assume from the caller side that it's expected to receive non-null connection. Was suggesting to invoke target.onError instead of throwing from onSuccess.", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393380178", "createdAt": "2020-03-17T00:20:38Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "diffHunk": "@@ -244,15 +244,16 @@ public void onSubscribe(final Cancellable cancellable) {\n                         }\n \n                         @Override\n-                        public void onSuccess(final C connection) {\n-                            requireNonNull(connection);\n+                        public void onSuccess(@Nullable final C connection) {\n                             if (terminatedUpdater.compareAndSet(ConnectHandler.this, 0, 1)) {\n                                 target.onSuccess(connection);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1ae0305f9655f24e37383e5ab65e73601a3b06e"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1ODE3NTUy", "url": "https://github.com/apple/servicetalk/pull/967#pullrequestreview-375817552", "createdAt": "2020-03-17T08:18:56Z", "commit": {"oid": "e1ae0305f9655f24e37383e5ab65e73601a3b06e"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODoxODo1NlrOF3RxQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODoyMDo0NlrOF3R0mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNzEzOQ==", "bodyText": "nit: This logging message will read a bit strange and may be confusing if connection == null.", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393507139", "createdAt": "2020-03-17T08:18:56Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "diffHunk": "@@ -209,4 +206,88 @@ private NoopNettyAddressResolverGroup() {\n             return NOOP_ADDRESS_RESOLVER;\n         }\n     }\n+\n+    private static final class ConnectHandler<C extends ListenableAsyncCloseable> implements Consumer<Channel> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(ConnectHandler.class);\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<ConnectHandler> terminatedUpdater =\n+                newUpdater(ConnectHandler.class, \"terminated\");\n+\n+        private final DelayedCancellable futureCancellable = new DelayedCancellable();\n+        private final DelayedCancellable flatMapCancellable = new DelayedCancellable();\n+        private final Subscriber<? super C> target;\n+        private final Function<Channel, Single<? extends C>> connectionFactory;\n+\n+        private volatile int terminated;\n+\n+        ConnectHandler(final Subscriber<? super C> target,\n+                       final Function<Channel, Single<? extends C>> connectionFactory) {\n+            this.target = target;\n+            this.connectionFactory = connectionFactory;\n+            target.onSubscribe(() -> {\n+                try {\n+                    futureCancellable.cancel();\n+                } finally {\n+                    flatMapCancellable.cancel();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public void accept(final Channel channel) {\n+            toSource(connectionFactory.apply(channel)\n+                    .subscribeShareContext())\n+                    .subscribe(new Subscriber<C>() {\n+                        @Override\n+                        public void onSubscribe(final Cancellable cancellable) {\n+                            flatMapCancellable.delayedCancellable(cancellable);\n+                        }\n+\n+                        @Override\n+                        public void onSuccess(@Nullable final C connection) {\n+                            if (terminatedUpdater.compareAndSet(ConnectHandler.this, 0, 1)) {\n+                                target.onSuccess(connection);\n+                            } else {\n+                                LOGGER.info(\"Connection {} created for a channel: {} but connect failed previously. \" +\n+                                                \"Closing connection\",\n+                                        connection, channel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1ae0305f9655f24e37383e5ab65e73601a3b06e"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNzk5NA==", "bodyText": "also nit.... All other log messages end with a ..", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393507994", "createdAt": "2020-03-17T08:20:46Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "diffHunk": "@@ -209,4 +206,88 @@ private NoopNettyAddressResolverGroup() {\n             return NOOP_ADDRESS_RESOLVER;\n         }\n     }\n+\n+    private static final class ConnectHandler<C extends ListenableAsyncCloseable> implements Consumer<Channel> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(ConnectHandler.class);\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<ConnectHandler> terminatedUpdater =\n+                newUpdater(ConnectHandler.class, \"terminated\");\n+\n+        private final DelayedCancellable futureCancellable = new DelayedCancellable();\n+        private final DelayedCancellable flatMapCancellable = new DelayedCancellable();\n+        private final Subscriber<? super C> target;\n+        private final Function<Channel, Single<? extends C>> connectionFactory;\n+\n+        private volatile int terminated;\n+\n+        ConnectHandler(final Subscriber<? super C> target,\n+                       final Function<Channel, Single<? extends C>> connectionFactory) {\n+            this.target = target;\n+            this.connectionFactory = connectionFactory;\n+            target.onSubscribe(() -> {\n+                try {\n+                    futureCancellable.cancel();\n+                } finally {\n+                    flatMapCancellable.cancel();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public void accept(final Channel channel) {\n+            toSource(connectionFactory.apply(channel)\n+                    .subscribeShareContext())\n+                    .subscribe(new Subscriber<C>() {\n+                        @Override\n+                        public void onSubscribe(final Cancellable cancellable) {\n+                            flatMapCancellable.delayedCancellable(cancellable);\n+                        }\n+\n+                        @Override\n+                        public void onSuccess(@Nullable final C connection) {\n+                            if (terminatedUpdater.compareAndSet(ConnectHandler.this, 0, 1)) {\n+                                target.onSuccess(connection);\n+                            } else {\n+                                LOGGER.info(\"Connection {} created for a channel: {} but connect failed previously. \" +\n+                                                \"Closing connection\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1ae0305f9655f24e37383e5ab65e73601a3b06e"}, "originalPosition": 230}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "787ec3834c8bc12a33aa752d6a20e2e7ced92794", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/787ec3834c8bc12a33aa752d6a20e2e7ced92794", "committedDate": "2020-03-17T16:11:07Z", "message": "Review comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3320, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}