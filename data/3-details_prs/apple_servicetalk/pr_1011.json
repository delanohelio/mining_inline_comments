{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzMzAxNDky", "number": 1011, "title": "Add Publisher#flatMapMerge operator", "bodyText": "Motivation:\nPublisher#flatMapMerge is a basic building block for each element of a\nPublisher to map into another Publisher.\nModifications:\n\nAdd Publisher#flatMapMerge operator\n\nResult:\nEach item emitted on a Publisher can be mapped to another Publisher.", "createdAt": "2020-04-14T16:54:08Z", "url": "https://github.com/apple/servicetalk/pull/1011", "merged": true, "mergeCommit": {"oid": "21d9ccc0279e8b7433c3453171e92f2de7e9c843"}, "closed": true, "closedAt": "2020-09-29T23:59:18Z", "author": {"login": "Scottmitch"}, "timelineItems": {"totalCount": 48, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcXmd9BgFqTM5MzExODUwNw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdNtCkVgBqjM4MjEyMjc2Njk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMTE4NTA3", "url": "https://github.com/apple/servicetalk/pull/1011#pullrequestreview-393118507", "createdAt": "2020-04-14T16:55:26Z", "commit": {"oid": "be25d527238e4859836a399a243c7b82ea148854"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNjo1NToyNlrOGFYDEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNjo1NToyNlrOGFYDEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5MDA2NA==", "bodyText": "the API here declares this as a hint for future flexibility, but the current implementation will respect this value.", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408290064", "createdAt": "2020-04-14T16:55:26Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Publisher.java", "diffHunk": "@@ -187,6 +187,72 @@ protected Publisher() {\n         return new ResumePublisher<>(this, nextFactory, executor);\n     }\n \n+    /**\n+     * Each element of this {@link Publisher} is mapped into a {@link Publisher} (potentially of a different type) and\n+     * flatten all signals emitted from each mapped {@link Publisher} into the returned {@link Publisher}.\n+     * <pre>{@code\n+     *     ExecutorService e = ...;\n+     *     List<Future<List<R>>> futures = ...; // assume this is thread safe\n+     *     for (T t : resultOfThisPublisher()) {\n+     *         // Note that flatMap process results in parallel.\n+     *         futures.add(e.submit(() -> {\n+     *             return mapper.apply(t); // Asynchronous result is flatten into a value by this operator.\n+     *         }));\n+     *     }\n+     *     List<R> results = new ArrayList<>(futures.size());\n+     *     // This is an approximation, this operator does not provide any ordering guarantees for the results.\n+     *     for (Future<List<R>> future : futures) {\n+     *         List<R> rList = future.get(); // Throws if the processing for this item failed.\n+     *         results.addAll(rList);\n+     *     }\n+     *     return results;\n+     * }</pre>\n+     * @param mapper Convert each item emitted by this {@link Publisher} into another {@link Publisher}.\n+     * each mapped {@link Publisher}.\n+     * @param <R> The type of mapped {@link Publisher}.\n+     * @return A new {@link Publisher} which flattens the emissions from all mapped {@link Publisher}s.\n+     * @see <a href=\"http://reactivex.io/documentation/operators/flatmap.html\">ReactiveX flatMap operator.</a>\n+     */\n+    public final <R> Publisher<R> flatMapMerge(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n+        return flatMapMerge(mapper, false, 16, 64);\n+    }\n+\n+    /**\n+     * Each element of this {@link Publisher} is mapped into a {@link Publisher} (potentially of a different type) and\n+     * flatten all signals emitted from each mapped {@link Publisher} into the returned {@link Publisher}.\n+     * <pre>{@code\n+     *     ExecutorService e = ...;\n+     *     List<Future<List<R>>> futures = ...; // assume this is thread safe\n+     *     for (T t : resultOfThisPublisher()) {\n+     *         // Note that flatMap process results in parallel.\n+     *         futures.add(e.submit(() -> {\n+     *             return mapper.apply(t); // Asynchronous result is flatten into a value by this operator.\n+     *         }));\n+     *     }\n+     *     List<R> results = new ArrayList<>(futures.size());\n+     *     // This is an approximation, this operator does not provide any ordering guarantees for the results.\n+     *     for (Future<List<R>> future : futures) {\n+     *         List<R> rList = future.get(); // Throws if the processing for this item failed.\n+     *         results.addAll(rList);\n+     *     }\n+     *     return results;\n+     * }</pre>\n+     * @param mapper Convert each item emitted by this {@link Publisher} into another {@link Publisher}.\n+     * @param delayError {@code false} if the returned {@link Publisher} should fail as soon as any of the mapped\n+     * {@link Publisher}s fail. {@code true} to wait until this {@link Publisher} terminates to emit any failures from\n+     * the mapped {@link Publisher}s.\n+     * @param maxConcurrency maximum amount of outstanding upstream {@link Subscription#request(long) demand}.\n+     * @param maxMappedDemandHint hint for the maximum amount of {@link Subscription#request(long) demand} for", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be25d527238e4859836a399a243c7b82ea148854"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMjIxODA1", "url": "https://github.com/apple/servicetalk/pull/1011#pullrequestreview-393221805", "createdAt": "2020-04-14T19:15:38Z", "commit": {"oid": "be25d527238e4859836a399a243c7b82ea148854"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOToxNTozOFrOGFdOfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOToxNTozOFrOGFdOfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3NDkwOA==", "bodyText": "how could this ever return false ? FlatMapPublisherSubscriber doesn't have an equals implementation and so this will always return true imho.", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408374908", "createdAt": "2020-04-14T19:15:38Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,681 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (subscribers.add(subscriber)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be25d527238e4859836a399a243c7b82ea148854"}, "originalPosition": 167}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMjI1MDgz", "url": "https://github.com/apple/servicetalk/pull/1011#pullrequestreview-393225083", "createdAt": "2020-04-14T19:20:37Z", "commit": {"oid": "be25d527238e4859836a399a243c7b82ea148854"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOToyMDozN1rOGFdZNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxOToyMzozMVrOGFdfgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3NzY1Mg==", "bodyText": "should we use addSuppressed(...) if delayedCause != null ?", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408377652", "createdAt": "2020-04-14T19:20:37Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,681 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (subscribers.add(subscriber)) {\n+                for (;;) {\n+                    final int prevActiveMappedSources = activeMappedSources;\n+                    if (prevActiveMappedSources < 0) {\n+                        // We have been cancelled, so in this case we don't want to Subscribe and instead\n+                        // just want to discard the Publisher.\n+                        subscribers.remove(subscriber);\n+                        break;\n+                    } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                            prevActiveMappedSources + 1)) {\n+                        publisher.subscribeInternal(subscriber);\n+                        tryRequestMore(subscriber);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable c) {\n+                        if (delayedCause == null) {\n+                            delayedCause = c;\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be25d527238e4859836a399a243c7b82ea148854"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3ODU3NQ==", "bodyText": "wouldn't it be better to call releaseEmittingLock() in a finally block ? Just to ensure we can not end up in a limbo state.", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408378575", "createdAt": "2020-04-14T19:22:12Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,681 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (subscribers.add(subscriber)) {\n+                for (;;) {\n+                    final int prevActiveMappedSources = activeMappedSources;\n+                    if (prevActiveMappedSources < 0) {\n+                        // We have been cancelled, so in this case we don't want to Subscribe and instead\n+                        // just want to discard the Publisher.\n+                        subscribers.remove(subscriber);\n+                        break;\n+                    } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                            prevActiveMappedSources + 1)) {\n+                        publisher.subscribeInternal(subscriber);\n+                        tryRequestMore(subscriber);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable c) {\n+                        if (delayedCause == null) {\n+                            delayedCause = c;\n+                        }\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            if (!pending.offer(item)) {\n+                enqueueAndDrainFail(item);\n+            }\n+            drainPending();\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {\n+            QueueFullException exception = new QueueFullException(\"pending\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private boolean acquireEmittingLock() {\n+            return acquirePendingLock(emittingLockUpdater, this);\n+        }\n+\n+        private boolean releaseEmittingLock() {\n+            return releasePendingLock(emittingLockUpdater, this);\n+        }\n+\n+        private void drainPending() {\n+            long emittedCount = 0;\n+            for (;;) {\n+                if (!acquireEmittingLock()) {\n+                    break;\n+                }\n+                Object t;\n+                while ((t = pending.poll()) != null) {\n+                    if (sendToTarget(t)) {\n+                        ++emittedCount;\n+                    }\n+                }\n+                if (releaseEmittingLock()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be25d527238e4859836a399a243c7b82ea148854"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3OTAwMA==", "bodyText": "same comment as above... I think we want to call this method in a finally block.", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408379000", "createdAt": "2020-04-14T19:23:01Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,681 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (subscribers.add(subscriber)) {\n+                for (;;) {\n+                    final int prevActiveMappedSources = activeMappedSources;\n+                    if (prevActiveMappedSources < 0) {\n+                        // We have been cancelled, so in this case we don't want to Subscribe and instead\n+                        // just want to discard the Publisher.\n+                        subscribers.remove(subscriber);\n+                        break;\n+                    } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                            prevActiveMappedSources + 1)) {\n+                        publisher.subscribeInternal(subscriber);\n+                        tryRequestMore(subscriber);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable c) {\n+                        if (delayedCause == null) {\n+                            delayedCause = c;\n+                        }\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            if (!pending.offer(item)) {\n+                enqueueAndDrainFail(item);\n+            }\n+            drainPending();\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {\n+            QueueFullException exception = new QueueFullException(\"pending\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private boolean acquireEmittingLock() {\n+            return acquirePendingLock(emittingLockUpdater, this);\n+        }\n+\n+        private boolean releaseEmittingLock() {\n+            return releasePendingLock(emittingLockUpdater, this);\n+        }\n+\n+        private void drainPending() {\n+            long emittedCount = 0;\n+            for (;;) {\n+                if (!acquireEmittingLock()) {\n+                    break;\n+                }\n+                Object t;\n+                while ((t = pending.poll()) != null) {\n+                    if (sendToTarget(t)) {\n+                        ++emittedCount;\n+                    }\n+                }\n+                if (releaseEmittingLock()) {\n+                    break;\n+                }\n+            }\n+\n+            if (emittedCount != 0) {\n+                tryRequestMore();\n+            }\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            }\n+            if (item instanceof TerminalNotification) {\n+                targetTerminated = true;\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                CompositeException de = this.delayedError;\n+                if (de != null) {\n+                    de.addAllPendingSuppressed();\n+                    if (terminalNotification.cause() == de) {\n+                        terminalNotification.terminate(target);\n+                    } else {\n+                        terminalNotification.terminate(target, de);\n+                    }\n+                } else {\n+                    terminalNotification.terminate(target);\n+                }\n+                return false;\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            final R rItem = item == NULL_TOKEN ? null : (R) item;\n+            target.onNext(rItem);\n+            return true;\n+        }\n+\n+        private boolean acquireTryRequestMoreLock() {\n+            return acquirePendingLock(tryRequestMoreLockUpdater, this);\n+        }\n+\n+        private boolean releaseTryRequestMoreLock() {\n+            return releasePendingLock(tryRequestMoreLockUpdater, this);\n+        }\n+\n+        private void tryRequestMore(FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (acquireTryRequestMoreLock()) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        final int consumedRequestN = subscriber.requestFromUpstream(\n+                                (int) min(source.maxMappedDemand, availableRequestN));\n+                        assert availableRequestN >= consumedRequestN;\n+                        if (consumedRequestN != availableRequestN) {\n+                            giveBackRequestN(availableRequestN - consumedRequestN);\n+                        }\n+                    }\n+                } finally {\n+                    if (!releaseTryRequestMoreLock()) {\n+                        tryRequestMore();\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void tryRequestMore() {\n+            Throwable delayedCause = null;\n+            for (;;) {\n+                if (!acquireTryRequestMoreLock()) {\n+                    break;\n+                }\n+\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        Iterator<FlatMapPublisherSubscriber<T, R>> itr = subscribers.iterator();\n+                        while (itr.hasNext() && remainingRequestN > 0) {\n+                            remainingRequestN -= itr.next().requestFromUpstream(\n+                                    (int) Math.min(source.maxMappedDemand, remainingRequestN));\n+                        }\n+\n+                        assert availableRequestN >= remainingRequestN && remainingRequestN >= 0;\n+                        if (remainingRequestN > 0) {\n+                            giveBackRequestN(remainingRequestN);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    if (delayedCause == null) {\n+                        delayedCause = cause;\n+                    }\n+                }\n+                if (releaseTryRequestMoreLock()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be25d527238e4859836a399a243c7b82ea148854"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3OTI2NA==", "bodyText": "does this need to be public ?", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408379264", "createdAt": "2020-04-14T19:23:31Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,681 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (subscribers.add(subscriber)) {\n+                for (;;) {\n+                    final int prevActiveMappedSources = activeMappedSources;\n+                    if (prevActiveMappedSources < 0) {\n+                        // We have been cancelled, so in this case we don't want to Subscribe and instead\n+                        // just want to discard the Publisher.\n+                        subscribers.remove(subscriber);\n+                        break;\n+                    } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                            prevActiveMappedSources + 1)) {\n+                        publisher.subscribeInternal(subscriber);\n+                        tryRequestMore(subscriber);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable c) {\n+                        if (delayedCause == null) {\n+                            delayedCause = c;\n+                        }\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            if (!pending.offer(item)) {\n+                enqueueAndDrainFail(item);\n+            }\n+            drainPending();\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {\n+            QueueFullException exception = new QueueFullException(\"pending\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private boolean acquireEmittingLock() {\n+            return acquirePendingLock(emittingLockUpdater, this);\n+        }\n+\n+        private boolean releaseEmittingLock() {\n+            return releasePendingLock(emittingLockUpdater, this);\n+        }\n+\n+        private void drainPending() {\n+            long emittedCount = 0;\n+            for (;;) {\n+                if (!acquireEmittingLock()) {\n+                    break;\n+                }\n+                Object t;\n+                while ((t = pending.poll()) != null) {\n+                    if (sendToTarget(t)) {\n+                        ++emittedCount;\n+                    }\n+                }\n+                if (releaseEmittingLock()) {\n+                    break;\n+                }\n+            }\n+\n+            if (emittedCount != 0) {\n+                tryRequestMore();\n+            }\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            }\n+            if (item instanceof TerminalNotification) {\n+                targetTerminated = true;\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                CompositeException de = this.delayedError;\n+                if (de != null) {\n+                    de.addAllPendingSuppressed();\n+                    if (terminalNotification.cause() == de) {\n+                        terminalNotification.terminate(target);\n+                    } else {\n+                        terminalNotification.terminate(target, de);\n+                    }\n+                } else {\n+                    terminalNotification.terminate(target);\n+                }\n+                return false;\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            final R rItem = item == NULL_TOKEN ? null : (R) item;\n+            target.onNext(rItem);\n+            return true;\n+        }\n+\n+        private boolean acquireTryRequestMoreLock() {\n+            return acquirePendingLock(tryRequestMoreLockUpdater, this);\n+        }\n+\n+        private boolean releaseTryRequestMoreLock() {\n+            return releasePendingLock(tryRequestMoreLockUpdater, this);\n+        }\n+\n+        private void tryRequestMore(FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (acquireTryRequestMoreLock()) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        final int consumedRequestN = subscriber.requestFromUpstream(\n+                                (int) min(source.maxMappedDemand, availableRequestN));\n+                        assert availableRequestN >= consumedRequestN;\n+                        if (consumedRequestN != availableRequestN) {\n+                            giveBackRequestN(availableRequestN - consumedRequestN);\n+                        }\n+                    }\n+                } finally {\n+                    if (!releaseTryRequestMoreLock()) {\n+                        tryRequestMore();\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void tryRequestMore() {\n+            Throwable delayedCause = null;\n+            for (;;) {\n+                if (!acquireTryRequestMoreLock()) {\n+                    break;\n+                }\n+\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        Iterator<FlatMapPublisherSubscriber<T, R>> itr = subscribers.iterator();\n+                        while (itr.hasNext() && remainingRequestN > 0) {\n+                            remainingRequestN -= itr.next().requestFromUpstream(\n+                                    (int) Math.min(source.maxMappedDemand, remainingRequestN));\n+                        }\n+\n+                        assert availableRequestN >= remainingRequestN && remainingRequestN >= 0;\n+                        if (remainingRequestN > 0) {\n+                            giveBackRequestN(remainingRequestN);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    if (delayedCause == null) {\n+                        delayedCause = cause;\n+                    }\n+                }\n+                if (releaseTryRequestMoreLock()) {\n+                    break;\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void giveBackRequestN(final long delta) {\n+            pendingDemandUpdater.addAndGet(this, delta);\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                // Should always be >= 0, but just in case there is a bug in user code that results in multiple terminal\n+                // events we avoid corrupting our internal state.\n+                if (prevActiveMappedSources < 0 || activeMappedSourcesUpdater.compareAndSet(this,\n+                        prevActiveMappedSources, -prevActiveMappedSources)) {\n+                    return prevActiveMappedSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActivePublishers = activeMappedSources;\n+                assert prevActivePublishers != 0;\n+                if (prevActivePublishers > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                            prevActivePublishers - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                        prevActivePublishers + 1)) {\n+                    return prevActivePublishers == -1;\n+                }\n+            }\n+        }\n+\n+        private boolean removeSubscriber(final FlatMapPublisherSubscriber<T, R> subscriber,\n+                                         final long requestNGiveBack) {\n+            if (subscribers.remove(subscriber)) {\n+                if (decrementActiveMappedSources()) {\n+                    return true;\n+                }\n+\n+                assert subscription != null;\n+                subscription.request(1);\n+\n+                if (requestNGiveBack > 0) {\n+                    giveBackRequestN(requestNGiveBack);\n+                    tryRequestMore();\n+                }\n+            }\n+            return false;\n+        }\n+\n+        public static final class FlatMapPublisherSubscriber<T, R> implements Subscriber<R> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be25d527238e4859836a399a243c7b82ea148854"}, "originalPosition": 434}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzA2NTk5", "url": "https://github.com/apple/servicetalk/pull/1011#pullrequestreview-393306599", "createdAt": "2020-04-14T21:24:19Z", "commit": {"oid": "2d533c935383e063a6217ff7cb2d893d6b3abd9f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMToyNDoxOVrOGFhe5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMToyNDoxOVrOGFhe5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0NDY0NQ==", "bodyText": "a key part to understanding the approach is as follows:\nthere is no queuing of signals for the purpose of managing excess demand [1]. instead the demand from downstream is carefully distributed to all mapped publishers. the \"careful\" part means that we need to be able to reclaim demand from mapped publishers when they terminated or are cancelled, otherwise we may deadlock due to not delivering data that was requested. bcz we need to reclaim demand upon cancellation we need to be sure there is no data delivered after this point (to avoid delivering too much data). So the subscription lock provides that coordination and makes sure we only deliver what we are allowed, and give it all back when we terminate/cancel.\n[1] there is an internal queue to manage concurrency requirements of ReactiveStreams (e.g. no concurrent delivery on a Subscriber, this is the same approach taken in Publisher#flatMapMergeSingle)", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r408444645", "createdAt": "2020-04-14T21:24:19Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,675 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (subscribers.add(subscriber)) {\n+                for (;;) {\n+                    final int prevActiveMappedSources = activeMappedSources;\n+                    if (prevActiveMappedSources < 0) {\n+                        // We have been cancelled, so in this case we don't want to Subscribe and instead\n+                        // just want to discard the Publisher.\n+                        subscribers.remove(subscriber);\n+                        break;\n+                    } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                            prevActiveMappedSources + 1)) {\n+                        publisher.subscribeInternal(subscriber);\n+                        tryRequestMore(subscriber);\n+                        break;\n+                    }\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected failure adding to subscriber Set\");\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable c) {\n+                        if (delayedCause == null) {\n+                            delayedCause = c;\n+                        }\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            if (!pending.offer(item)) {\n+                enqueueAndDrainFail(item);\n+            }\n+            drainPending();\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {\n+            QueueFullException exception = new QueueFullException(\"pending\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            long emittedCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingLockUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;\n+                            }\n+                        }\n+                    }\n+                } finally {\n+                    if (releasePendingLock(emittingLockUpdater, this)) {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (emittedCount != 0) {\n+                tryRequestMore();\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            }\n+            if (item instanceof TerminalNotification) {\n+                targetTerminated = true;\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                CompositeException de = this.delayedError;\n+                if (de != null) {\n+                    de.addAllPendingSuppressed();\n+                    if (terminalNotification.cause() == de) {\n+                        terminalNotification.terminate(target);\n+                    } else {\n+                        terminalNotification.terminate(target, de);\n+                    }\n+                } else {\n+                    terminalNotification.terminate(target);\n+                }\n+                return false;\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            final R rItem = item == NULL_TOKEN ? null : (R) item;\n+            target.onNext(rItem);\n+            return true;\n+        }\n+\n+        private void tryRequestMore(FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        final int consumedRequestN = subscriber.requestFromUpstream(\n+                                (int) min(source.maxMappedDemand, availableRequestN));\n+                        assert availableRequestN >= consumedRequestN;\n+                        if (consumedRequestN != availableRequestN) {\n+                            giveBackRequestN(availableRequestN - consumedRequestN);\n+                        }\n+                    }\n+                } finally {\n+                    if (!releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        tryRequestMore();\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void tryRequestMore() {\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        Iterator<FlatMapPublisherSubscriber<T, R>> itr = subscribers.iterator();\n+                        while (itr.hasNext() && remainingRequestN > 0) {\n+                            remainingRequestN -= itr.next().requestFromUpstream(\n+                                    (int) Math.min(source.maxMappedDemand, remainingRequestN));\n+                        }\n+\n+                        assert availableRequestN >= remainingRequestN && remainingRequestN >= 0;\n+                        if (remainingRequestN > 0) {\n+                            giveBackRequestN(remainingRequestN);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    if (delayedCause == null) {\n+                        delayedCause = cause;\n+                    }\n+                } finally {\n+                    if (releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        break;\n+                    }\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void giveBackRequestN(final long delta) {\n+            pendingDemandUpdater.addAndGet(this, delta);\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                // Should always be >= 0, but just in case there is a bug in user code that results in multiple terminal\n+                // events we avoid corrupting our internal state.\n+                if (prevActiveMappedSources < 0 || activeMappedSourcesUpdater.compareAndSet(this,\n+                        prevActiveMappedSources, -prevActiveMappedSources)) {\n+                    return prevActiveMappedSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActivePublishers = activeMappedSources;\n+                assert prevActivePublishers != 0;\n+                if (prevActivePublishers > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                            prevActivePublishers - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                        prevActivePublishers + 1)) {\n+                    return prevActivePublishers == -1;\n+                }\n+            }\n+        }\n+\n+        private boolean removeSubscriber(final FlatMapPublisherSubscriber<T, R> subscriber,\n+                                         final long requestNGiveBack) {\n+            if (subscribers.remove(subscriber)) {\n+                if (decrementActiveMappedSources()) {\n+                    return true;\n+                }\n+\n+                assert subscription != null;\n+                subscription.request(1);\n+\n+                if (requestNGiveBack > 0) {\n+                    giveBackRequestN(requestNGiveBack);\n+                    tryRequestMore();\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private static final class FlatMapPublisherSubscriber<T, R> implements Subscriber<R> {\n+            private static final Subscription CANCELLED = new EmptySubscription();\n+            private static final Subscription CANCEL_PENDING = new EmptySubscription();\n+            private static final Subscription REQUEST_PENDING = new EmptySubscription();\n+            private static final Subscription PROCESSING_REQUEST = new EmptySubscription();\n+            private static final Subscription PROCESSING_ONNEXT = new EmptySubscription();\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicReferenceFieldUpdater<FlatMapPublisherSubscriber, Subscription>\n+                    subscriptionUpdater = newUpdater(FlatMapPublisherSubscriber.class, Subscription.class,\n+                    \"subscription\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> outstandingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"outstandingDemand\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> pendingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"pendingDemand\");\n+\n+            private final FlatMapSubscriber<T, R> parent;\n+\n+            @SuppressWarnings(\"unused\")\n+            @Nullable\n+            private volatile Subscription subscription;\n+            private volatile long pendingDemand;\n+            private volatile long outstandingDemand;\n+\n+            FlatMapPublisherSubscriber(FlatMapSubscriber<T, R> parent) {\n+                this.parent = parent;\n+            }\n+\n+            void cancelFromUpstream() {\n+                for (;;) {\n+                    final Subscription prevSubscription = subscription;\n+                    if (prevSubscription == null) {\n+                        if (subscriptionUpdater.compareAndSet(this, null, CANCELLED)) {\n+                            break;\n+                        }\n+                    } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                        break;\n+                    } else if (prevSubscription == PROCESSING_ONNEXT || prevSubscription == PROCESSING_REQUEST) {\n+                        if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCEL_PENDING)) {\n+                            break;\n+                        }\n+                    } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCELLED)) {\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            int requestFromUpstream(final int n) {\n+                for (;;) {\n+                    final long prevOutstandingDemand = outstandingDemand;\n+                    if (prevOutstandingDemand < 0) {\n+                        return 0; // we have already been cancelled, or terminated\n+                    }\n+                    final int quotaToUse = (int) min(Long.MAX_VALUE - prevOutstandingDemand,\n+                            min(parent.source.maxMappedDemand - prevOutstandingDemand, n));\n+                    if (quotaToUse == 0) {\n+                        if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                                prevOutstandingDemand)) {\n+                            return 0;\n+                        }\n+                    } else if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                            prevOutstandingDemand + quotaToUse)) {\n+                        pendingDemandUpdater.addAndGet(this, quotaToUse);\n+                        for (;;) {\n+                            final Subscription prevSubscription = subscription;\n+                            if (prevSubscription == null) {\n+                                if (subscriptionUpdater.compareAndSet(this, null, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                                break;\n+                            } else if (prevSubscription == REQUEST_PENDING || prevSubscription == PROCESSING_ONNEXT ||\n+                                    prevSubscription == PROCESSING_REQUEST) {\n+                                if (subscriptionUpdater.compareAndSet(this, prevSubscription, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, PROCESSING_REQUEST)) {\n+                                doRequestMore(prevSubscription);\n+                                break;\n+                            }\n+                        }\n+                        return quotaToUse;\n+                    }\n+                }\n+            }\n+\n+            private void doRequestMore(Subscription prevSubscription) {\n+                long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                for (;;) {\n+                    if (availableRequestN > 0) {\n+                        try {\n+                            prevSubscription.request(availableRequestN);\n+                        } catch (Throwable cause) {\n+                            subscription = CANCELLED;\n+                            cancelAndGiveBack(prevSubscription);\n+                            throw cause;\n+                        }\n+                    }\n+\n+                    final Subscription afterLockSubscription = subscription;\n+                    if (afterLockSubscription == PROCESSING_ONNEXT || afterLockSubscription == CANCELLED) {\n+                        // onNext is allowed to interrupt, and will handle any pending cancel/request events\n+                        // after it completes (otherwise we may drop signals).\n+                        break;\n+                    } else if (afterLockSubscription == CANCEL_PENDING) {\n+                        subscription = CANCELLED;\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    } else if (afterLockSubscription == REQUEST_PENDING) {\n+                        if (subscriptionUpdater.compareAndSet(this, REQUEST_PENDING, PROCESSING_REQUEST)) {\n+                            availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                            // continue through next iteration to try to unlock\n+                        }\n+                    } else if (afterLockSubscription == PROCESSING_REQUEST &&\n+                            subscriptionUpdater.compareAndSet(this, PROCESSING_REQUEST, prevSubscription)) {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            private void cancelAndGiveBack(Subscription subscription) {\n+                try {\n+                    subscription.cancel();\n+                } finally {\n+                    giveBackUnusedRequestN();\n+                }\n+            }\n+\n+            private boolean giveBackUnusedRequestN() {\n+                // we need to give back the outstanding amount that has been requested, but not emitted.\n+                // resetting sourceRequestedUpdater must happen unconditionally first, as this stops\n+                // calculateSourceRequested from attempting to request any more.\n+                final long prevOutstandingDemand = outstandingDemandUpdater.getAndSet(this, -1);\n+                return prevOutstandingDemand >= 0 && parent.removeSubscriber(this, prevOutstandingDemand);\n+            }\n+\n+            @Override\n+            public void onSubscribe(final Subscription s) {\n+                for (;;) {\n+                    final Subscription prevSubscription = subscription;\n+                    assert prevSubscription != CANCEL_PENDING && prevSubscription != PROCESSING_ONNEXT &&\n+                            prevSubscription != PROCESSING_REQUEST;\n+                    if (prevSubscription == null) {\n+                        if (subscriptionUpdater.compareAndSet(this, null, s)) {\n+                            break;\n+                        }\n+                    } else if (prevSubscription == REQUEST_PENDING) {\n+                        if (subscriptionUpdater.compareAndSet(this, REQUEST_PENDING, PROCESSING_REQUEST)) {\n+                            doRequestMore(s);\n+                            break;\n+                        }\n+                    } else {\n+                        s.cancel(); // already cancelled or duplicate onSubscribe\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void onNext(@Nullable final R r) {\n+                boolean acquiredLock = false;\n+                for (;;) {\n+                    Subscription prevSubscription = subscription;\n+                    assert prevSubscription != null;\n+                    if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                        // we have already given our undelivered requestN quota up, or will after we unroll process\n+                        // onNext. we are not allowed to deliver more data or else we may violate upstream's requestN.\n+                        break;\n+                    } else if (prevSubscription == PROCESSING_ONNEXT ||\n+                            (acquiredLock = subscriptionUpdater.compareAndSet(this,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d533c935383e063a6217ff7cb2d893d6b3abd9f"}, "originalPosition": 599}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MzU5MDY2", "url": "https://github.com/apple/servicetalk/pull/1011#pullrequestreview-394359066", "createdAt": "2020-04-16T07:19:25Z", "commit": {"oid": "fee3ceaeffb739c1db2c399a5c5a8a3697f6f8be"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNzoxOToyNVrOGGXxDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNzoyNTozMlrOGGX-CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMzNDAzMQ==", "bodyText": "nit: in other places you always start with an uppercase letter while here you dont.", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r409334031", "createdAt": "2020-04-16T07:19:25Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Publisher.java", "diffHunk": "@@ -187,6 +187,72 @@ protected Publisher() {\n         return new ResumePublisher<>(this, nextFactory, executor);\n     }\n \n+    /**\n+     * Each element of this {@link Publisher} is mapped into a {@link Publisher} (potentially of a different type) and\n+     * flatten all signals emitted from each mapped {@link Publisher} into the returned {@link Publisher}.\n+     * <pre>{@code\n+     *     ExecutorService e = ...;\n+     *     List<Future<List<R>>> futures = ...; // assume this is thread safe\n+     *     for (T t : resultOfThisPublisher()) {\n+     *         // Note that flatMap process results in parallel.\n+     *         futures.add(e.submit(() -> {\n+     *             return mapper.apply(t); // Asynchronous result is flatten into a value by this operator.\n+     *         }));\n+     *     }\n+     *     List<R> results = new ArrayList<>(futures.size());\n+     *     // This is an approximation, this operator does not provide any ordering guarantees for the results.\n+     *     for (Future<List<R>> future : futures) {\n+     *         List<R> rList = future.get(); // Throws if the processing for this item failed.\n+     *         results.addAll(rList);\n+     *     }\n+     *     return results;\n+     * }</pre>\n+     * @param mapper Convert each item emitted by this {@link Publisher} into another {@link Publisher}.\n+     * each mapped {@link Publisher}.\n+     * @param <R> The type of mapped {@link Publisher}.\n+     * @return A new {@link Publisher} which flattens the emissions from all mapped {@link Publisher}s.\n+     * @see <a href=\"http://reactivex.io/documentation/operators/flatmap.html\">ReactiveX flatMap operator.</a>\n+     */\n+    public final <R> Publisher<R> flatMapMerge(Function<? super T, ? extends Publisher<? extends R>> mapper) {\n+        return flatMapMerge(mapper, false, 16, 64);\n+    }\n+\n+    /**\n+     * Each element of this {@link Publisher} is mapped into a {@link Publisher} (potentially of a different type) and\n+     * flatten all signals emitted from each mapped {@link Publisher} into the returned {@link Publisher}.\n+     * <pre>{@code\n+     *     ExecutorService e = ...;\n+     *     List<Future<List<R>>> futures = ...; // assume this is thread safe\n+     *     for (T t : resultOfThisPublisher()) {\n+     *         // Note that flatMap process results in parallel.\n+     *         futures.add(e.submit(() -> {\n+     *             return mapper.apply(t); // Asynchronous result is flatten into a value by this operator.\n+     *         }));\n+     *     }\n+     *     List<R> results = new ArrayList<>(futures.size());\n+     *     // This is an approximation, this operator does not provide any ordering guarantees for the results.\n+     *     for (Future<List<R>> future : futures) {\n+     *         List<R> rList = future.get(); // Throws if the processing for this item failed.\n+     *         results.addAll(rList);\n+     *     }\n+     *     return results;\n+     * }</pre>\n+     * @param mapper Convert each item emitted by this {@link Publisher} into another {@link Publisher}.\n+     * @param delayError {@code false} if the returned {@link Publisher} should fail as soon as any of the mapped\n+     * {@link Publisher}s fail. {@code true} to wait until this {@link Publisher} terminates to emit any failures from\n+     * the mapped {@link Publisher}s.\n+     * @param maxConcurrency maximum amount of outstanding upstream {@link Subscription#request(long) demand}.\n+     * @param maxMappedDemandHint hint for the maximum amount of {@link Subscription#request(long) demand} for", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fee3ceaeffb739c1db2c399a5c5a8a3697f6f8be"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMzNTE3Mg==", "bodyText": "I still don't understand how this ever could return false even in an \"inconsistent state\".", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r409335172", "createdAt": "2020-04-16T07:21:35Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,681 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (subscribers.add(subscriber)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3NDkwOA=="}, "originalCommit": {"oid": "be25d527238e4859836a399a243c7b82ea148854"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMzNzM1Mg==", "bodyText": "consider adding this as a comment in the code-base.", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r409337352", "createdAt": "2020-04-16T07:25:32Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,675 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (subscribers.add(subscriber)) {\n+                for (;;) {\n+                    final int prevActiveMappedSources = activeMappedSources;\n+                    if (prevActiveMappedSources < 0) {\n+                        // We have been cancelled, so in this case we don't want to Subscribe and instead\n+                        // just want to discard the Publisher.\n+                        subscribers.remove(subscriber);\n+                        break;\n+                    } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                            prevActiveMappedSources + 1)) {\n+                        publisher.subscribeInternal(subscriber);\n+                        tryRequestMore(subscriber);\n+                        break;\n+                    }\n+                }\n+            } else {\n+                throw new IllegalStateException(\"unexpected failure adding to subscriber Set\");\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable c) {\n+                        if (delayedCause == null) {\n+                            delayedCause = c;\n+                        }\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            if (!pending.offer(item)) {\n+                enqueueAndDrainFail(item);\n+            }\n+            drainPending();\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {\n+            QueueFullException exception = new QueueFullException(\"pending\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            long emittedCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingLockUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;\n+                            }\n+                        }\n+                    }\n+                } finally {\n+                    if (releasePendingLock(emittingLockUpdater, this)) {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (emittedCount != 0) {\n+                tryRequestMore();\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            }\n+            if (item instanceof TerminalNotification) {\n+                targetTerminated = true;\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                CompositeException de = this.delayedError;\n+                if (de != null) {\n+                    de.addAllPendingSuppressed();\n+                    if (terminalNotification.cause() == de) {\n+                        terminalNotification.terminate(target);\n+                    } else {\n+                        terminalNotification.terminate(target, de);\n+                    }\n+                } else {\n+                    terminalNotification.terminate(target);\n+                }\n+                return false;\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            final R rItem = item == NULL_TOKEN ? null : (R) item;\n+            target.onNext(rItem);\n+            return true;\n+        }\n+\n+        private void tryRequestMore(FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        final int consumedRequestN = subscriber.requestFromUpstream(\n+                                (int) min(source.maxMappedDemand, availableRequestN));\n+                        assert availableRequestN >= consumedRequestN;\n+                        if (consumedRequestN != availableRequestN) {\n+                            giveBackRequestN(availableRequestN - consumedRequestN);\n+                        }\n+                    }\n+                } finally {\n+                    if (!releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        tryRequestMore();\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void tryRequestMore() {\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        Iterator<FlatMapPublisherSubscriber<T, R>> itr = subscribers.iterator();\n+                        while (itr.hasNext() && remainingRequestN > 0) {\n+                            remainingRequestN -= itr.next().requestFromUpstream(\n+                                    (int) Math.min(source.maxMappedDemand, remainingRequestN));\n+                        }\n+\n+                        assert availableRequestN >= remainingRequestN && remainingRequestN >= 0;\n+                        if (remainingRequestN > 0) {\n+                            giveBackRequestN(remainingRequestN);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    if (delayedCause == null) {\n+                        delayedCause = cause;\n+                    }\n+                } finally {\n+                    if (releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        break;\n+                    }\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void giveBackRequestN(final long delta) {\n+            pendingDemandUpdater.addAndGet(this, delta);\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                // Should always be >= 0, but just in case there is a bug in user code that results in multiple terminal\n+                // events we avoid corrupting our internal state.\n+                if (prevActiveMappedSources < 0 || activeMappedSourcesUpdater.compareAndSet(this,\n+                        prevActiveMappedSources, -prevActiveMappedSources)) {\n+                    return prevActiveMappedSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActivePublishers = activeMappedSources;\n+                assert prevActivePublishers != 0;\n+                if (prevActivePublishers > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                            prevActivePublishers - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                        prevActivePublishers + 1)) {\n+                    return prevActivePublishers == -1;\n+                }\n+            }\n+        }\n+\n+        private boolean removeSubscriber(final FlatMapPublisherSubscriber<T, R> subscriber,\n+                                         final long requestNGiveBack) {\n+            if (subscribers.remove(subscriber)) {\n+                if (decrementActiveMappedSources()) {\n+                    return true;\n+                }\n+\n+                assert subscription != null;\n+                subscription.request(1);\n+\n+                if (requestNGiveBack > 0) {\n+                    giveBackRequestN(requestNGiveBack);\n+                    tryRequestMore();\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private static final class FlatMapPublisherSubscriber<T, R> implements Subscriber<R> {\n+            private static final Subscription CANCELLED = new EmptySubscription();\n+            private static final Subscription CANCEL_PENDING = new EmptySubscription();\n+            private static final Subscription REQUEST_PENDING = new EmptySubscription();\n+            private static final Subscription PROCESSING_REQUEST = new EmptySubscription();\n+            private static final Subscription PROCESSING_ONNEXT = new EmptySubscription();\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicReferenceFieldUpdater<FlatMapPublisherSubscriber, Subscription>\n+                    subscriptionUpdater = newUpdater(FlatMapPublisherSubscriber.class, Subscription.class,\n+                    \"subscription\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> outstandingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"outstandingDemand\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> pendingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"pendingDemand\");\n+\n+            private final FlatMapSubscriber<T, R> parent;\n+\n+            @SuppressWarnings(\"unused\")\n+            @Nullable\n+            private volatile Subscription subscription;\n+            private volatile long pendingDemand;\n+            private volatile long outstandingDemand;\n+\n+            FlatMapPublisherSubscriber(FlatMapSubscriber<T, R> parent) {\n+                this.parent = parent;\n+            }\n+\n+            void cancelFromUpstream() {\n+                for (;;) {\n+                    final Subscription prevSubscription = subscription;\n+                    if (prevSubscription == null) {\n+                        if (subscriptionUpdater.compareAndSet(this, null, CANCELLED)) {\n+                            break;\n+                        }\n+                    } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                        break;\n+                    } else if (prevSubscription == PROCESSING_ONNEXT || prevSubscription == PROCESSING_REQUEST) {\n+                        if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCEL_PENDING)) {\n+                            break;\n+                        }\n+                    } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCELLED)) {\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            int requestFromUpstream(final int n) {\n+                for (;;) {\n+                    final long prevOutstandingDemand = outstandingDemand;\n+                    if (prevOutstandingDemand < 0) {\n+                        return 0; // we have already been cancelled, or terminated\n+                    }\n+                    final int quotaToUse = (int) min(Long.MAX_VALUE - prevOutstandingDemand,\n+                            min(parent.source.maxMappedDemand - prevOutstandingDemand, n));\n+                    if (quotaToUse == 0) {\n+                        if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                                prevOutstandingDemand)) {\n+                            return 0;\n+                        }\n+                    } else if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                            prevOutstandingDemand + quotaToUse)) {\n+                        pendingDemandUpdater.addAndGet(this, quotaToUse);\n+                        for (;;) {\n+                            final Subscription prevSubscription = subscription;\n+                            if (prevSubscription == null) {\n+                                if (subscriptionUpdater.compareAndSet(this, null, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                                break;\n+                            } else if (prevSubscription == REQUEST_PENDING || prevSubscription == PROCESSING_ONNEXT ||\n+                                    prevSubscription == PROCESSING_REQUEST) {\n+                                if (subscriptionUpdater.compareAndSet(this, prevSubscription, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, PROCESSING_REQUEST)) {\n+                                doRequestMore(prevSubscription);\n+                                break;\n+                            }\n+                        }\n+                        return quotaToUse;\n+                    }\n+                }\n+            }\n+\n+            private void doRequestMore(Subscription prevSubscription) {\n+                long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                for (;;) {\n+                    if (availableRequestN > 0) {\n+                        try {\n+                            prevSubscription.request(availableRequestN);\n+                        } catch (Throwable cause) {\n+                            subscription = CANCELLED;\n+                            cancelAndGiveBack(prevSubscription);\n+                            throw cause;\n+                        }\n+                    }\n+\n+                    final Subscription afterLockSubscription = subscription;\n+                    if (afterLockSubscription == PROCESSING_ONNEXT || afterLockSubscription == CANCELLED) {\n+                        // onNext is allowed to interrupt, and will handle any pending cancel/request events\n+                        // after it completes (otherwise we may drop signals).\n+                        break;\n+                    } else if (afterLockSubscription == CANCEL_PENDING) {\n+                        subscription = CANCELLED;\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    } else if (afterLockSubscription == REQUEST_PENDING) {\n+                        if (subscriptionUpdater.compareAndSet(this, REQUEST_PENDING, PROCESSING_REQUEST)) {\n+                            availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                            // continue through next iteration to try to unlock\n+                        }\n+                    } else if (afterLockSubscription == PROCESSING_REQUEST &&\n+                            subscriptionUpdater.compareAndSet(this, PROCESSING_REQUEST, prevSubscription)) {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            private void cancelAndGiveBack(Subscription subscription) {\n+                try {\n+                    subscription.cancel();\n+                } finally {\n+                    giveBackUnusedRequestN();\n+                }\n+            }\n+\n+            private boolean giveBackUnusedRequestN() {\n+                // we need to give back the outstanding amount that has been requested, but not emitted.\n+                // resetting sourceRequestedUpdater must happen unconditionally first, as this stops\n+                // calculateSourceRequested from attempting to request any more.\n+                final long prevOutstandingDemand = outstandingDemandUpdater.getAndSet(this, -1);\n+                return prevOutstandingDemand >= 0 && parent.removeSubscriber(this, prevOutstandingDemand);\n+            }\n+\n+            @Override\n+            public void onSubscribe(final Subscription s) {\n+                for (;;) {\n+                    final Subscription prevSubscription = subscription;\n+                    assert prevSubscription != CANCEL_PENDING && prevSubscription != PROCESSING_ONNEXT &&\n+                            prevSubscription != PROCESSING_REQUEST;\n+                    if (prevSubscription == null) {\n+                        if (subscriptionUpdater.compareAndSet(this, null, s)) {\n+                            break;\n+                        }\n+                    } else if (prevSubscription == REQUEST_PENDING) {\n+                        if (subscriptionUpdater.compareAndSet(this, REQUEST_PENDING, PROCESSING_REQUEST)) {\n+                            doRequestMore(s);\n+                            break;\n+                        }\n+                    } else {\n+                        s.cancel(); // already cancelled or duplicate onSubscribe\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void onNext(@Nullable final R r) {\n+                boolean acquiredLock = false;\n+                for (;;) {\n+                    Subscription prevSubscription = subscription;\n+                    assert prevSubscription != null;\n+                    if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                        // we have already given our undelivered requestN quota up, or will after we unroll process\n+                        // onNext. we are not allowed to deliver more data or else we may violate upstream's requestN.\n+                        break;\n+                    } else if (prevSubscription == PROCESSING_ONNEXT ||\n+                            (acquiredLock = subscriptionUpdater.compareAndSet(this,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ0NDY0NQ=="}, "originalCommit": {"oid": "2d533c935383e063a6217ff7cb2d893d6b3abd9f"}, "originalPosition": 599}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1MzczMjY4", "url": "https://github.com/apple/servicetalk/pull/1011#pullrequestreview-395373268", "createdAt": "2020-04-17T11:25:15Z", "commit": {"oid": "f1371888e0d42ed60e7c5ce80eb43544b66458e6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMToyNToxNVrOGHKPCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMToyNzoyNVrOGHKSjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE2MDkwNg==", "bodyText": "nit: you could remove the else", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r410160906", "createdAt": "2020-04-17T11:25:15Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * This flatMap implementation doesn't rely upon queuing to manage demand. Instead it leases out demand quota\n+ * (capped by {@link #maxMappedDemand}) mapped {@link Publisher}s and reclaims any unused quota when each mapped\n+ * {@link Publisher} is terminated or cancelled. {@link FlatMapSubscriber.FlatMapPublisherSubscriber} carefully manages\n+ * outstanding demand to ensure when quota is reclaimed there are no subsequent\n+ * {@link Subscriber#onNext(Object) signals} to avoid returning inaccurate amounts which would otherwise result in\n+ * deadlock (under delivering {@link Subscriber#onNext(Object) signals}) or violation of\n+ * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.1\">Reactive Streams\n+ * Specification</a> (over delivering {@link Subscriber#onNext(Object) signals}) to the downstream {@link Subscriber}.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                if (prevActiveMappedSources < 0) {\n+                    // We have been cancelled, so in this case we don't want to Subscribe and instead\n+                    // just want to discard the Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                        prevActiveMappedSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    tryRequestMore(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable c) {\n+                        if (delayedCause == null) {\n+                            delayedCause = c;\n+                        }\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            if (!pending.offer(item)) {\n+                enqueueAndDrainFail(item);\n+            }\n+            drainPending();\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {\n+            QueueFullException exception = new QueueFullException(\"pending\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n+        private void drainPending() {\n+            long emittedCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingLockUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;\n+                            }\n+                        }\n+                    }\n+                } finally {\n+                    if (releasePendingLock(emittingLockUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (emittedCount != 0) {\n+                tryRequestMore();\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            }\n+            if (item instanceof TerminalNotification) {\n+                targetTerminated = true;\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                CompositeException de = this.delayedError;\n+                if (de != null) {\n+                    de.addAllPendingSuppressed();\n+                    if (terminalNotification.cause() == de) {\n+                        terminalNotification.terminate(target);\n+                    } else {\n+                        terminalNotification.terminate(target, de);\n+                    }\n+                } else {\n+                    terminalNotification.terminate(target);\n+                }\n+                return false;\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            final R rItem = item == NULL_TOKEN ? null : (R) item;\n+            target.onNext(rItem);\n+            return true;\n+        }\n+\n+        private void tryRequestMore(FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        final int consumedRequestN = subscriber.requestFromUpstream(\n+                                (int) min(source.maxMappedDemand, availableRequestN));\n+                        assert availableRequestN >= consumedRequestN;\n+                        if (consumedRequestN != availableRequestN) {\n+                            giveBackRequestN(availableRequestN - consumedRequestN);\n+                        }\n+                    }\n+                } finally {\n+                    if (!releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        tryRequestMore();\n+                    }\n+                }\n+            }\n+        }\n+\n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n+        private void tryRequestMore() {\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        Iterator<FlatMapPublisherSubscriber<T, R>> itr = subscribers.iterator();\n+                        while (itr.hasNext() && remainingRequestN > 0) {\n+                            remainingRequestN -= itr.next().requestFromUpstream(\n+                                    (int) Math.min(source.maxMappedDemand, remainingRequestN));\n+                        }\n+\n+                        assert availableRequestN >= remainingRequestN && remainingRequestN >= 0;\n+                        if (remainingRequestN > 0) {\n+                            giveBackRequestN(remainingRequestN);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    if (delayedCause == null) {\n+                        delayedCause = cause;\n+                    }\n+                } finally {\n+                    if (releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void giveBackRequestN(final long delta) {\n+            pendingDemandUpdater.addAndGet(this, delta);\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                // Should always be >= 0, but just in case there is a bug in user code that results in multiple terminal\n+                // events we avoid corrupting our internal state.\n+                if (prevActiveMappedSources < 0 || activeMappedSourcesUpdater.compareAndSet(this,\n+                        prevActiveMappedSources, -prevActiveMappedSources)) {\n+                    return prevActiveMappedSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActivePublishers = activeMappedSources;\n+                assert prevActivePublishers != 0;\n+                if (prevActivePublishers > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                            prevActivePublishers - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                        prevActivePublishers + 1)) {\n+                    return prevActivePublishers == -1;\n+                }\n+            }\n+        }\n+\n+        private boolean removeSubscriber(final FlatMapPublisherSubscriber<T, R> subscriber,\n+                                         final long requestNGiveBack) {\n+            if (subscribers.remove(subscriber)) {\n+                if (decrementActiveMappedSources()) {\n+                    return true;\n+                }\n+\n+                assert subscription != null;\n+                subscription.request(1);\n+\n+                if (requestNGiveBack > 0) {\n+                    giveBackRequestN(requestNGiveBack);\n+                    tryRequestMore();\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private static final class FlatMapPublisherSubscriber<T, R> implements Subscriber<R> {\n+            private static final Subscription CANCELLED = new EmptySubscription();\n+            private static final Subscription CANCEL_PENDING = new EmptySubscription();\n+            private static final Subscription REQUEST_PENDING = new EmptySubscription();\n+            private static final Subscription PROCESSING_REQUEST = new EmptySubscription();\n+            private static final Subscription PROCESSING_ONNEXT = new EmptySubscription();\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicReferenceFieldUpdater<FlatMapPublisherSubscriber, Subscription>\n+                    subscriptionUpdater = newUpdater(FlatMapPublisherSubscriber.class, Subscription.class,\n+                    \"subscription\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> outstandingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"outstandingDemand\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> pendingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"pendingDemand\");\n+\n+            private final FlatMapSubscriber<T, R> parent;\n+\n+            @SuppressWarnings(\"unused\")\n+            @Nullable\n+            private volatile Subscription subscription;\n+            private volatile long pendingDemand;\n+            private volatile long outstandingDemand;\n+\n+            FlatMapPublisherSubscriber(FlatMapSubscriber<T, R> parent) {\n+                this.parent = parent;\n+            }\n+\n+            void cancelFromUpstream() {\n+                for (;;) {\n+                    final Subscription prevSubscription = subscription;\n+                    if (prevSubscription == null) {\n+                        if (subscriptionUpdater.compareAndSet(this, null, CANCELLED)) {\n+                            break;\n+                        }\n+                    } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                        break;\n+                    } else if (prevSubscription == PROCESSING_ONNEXT || prevSubscription == PROCESSING_REQUEST) {\n+                        if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCEL_PENDING)) {\n+                            break;\n+                        }\n+                    } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCELLED)) {\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            int requestFromUpstream(final int n) {\n+                for (;;) {\n+                    final long prevOutstandingDemand = outstandingDemand;\n+                    if (prevOutstandingDemand < 0) {\n+                        return 0; // we have already been cancelled, or terminated\n+                    }\n+                    final int quotaToUse = (int) min(Long.MAX_VALUE - prevOutstandingDemand,\n+                            min(parent.source.maxMappedDemand - prevOutstandingDemand, n));\n+                    if (quotaToUse == 0) {\n+                        if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                                prevOutstandingDemand)) {\n+                            return 0;\n+                        }\n+                    } else if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                            prevOutstandingDemand + quotaToUse)) {\n+                        pendingDemandUpdater.addAndGet(this, quotaToUse);\n+                        for (;;) {\n+                            final Subscription prevSubscription = subscription;\n+                            if (prevSubscription == null) {\n+                                if (subscriptionUpdater.compareAndSet(this, null, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                                break;\n+                            } else if (prevSubscription == REQUEST_PENDING || prevSubscription == PROCESSING_ONNEXT ||\n+                                    prevSubscription == PROCESSING_REQUEST) {\n+                                if (subscriptionUpdater.compareAndSet(this, prevSubscription, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, PROCESSING_REQUEST)) {\n+                                doRequestMore(prevSubscription);\n+                                break;\n+                            }\n+                        }\n+                        return quotaToUse;\n+                    }\n+                }\n+            }\n+\n+            private void doRequestMore(Subscription prevSubscription) {\n+                long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                for (;;) {\n+                    if (availableRequestN > 0) {\n+                        try {\n+                            prevSubscription.request(availableRequestN);\n+                        } catch (Throwable cause) {\n+                            subscription = CANCELLED;\n+                            cancelAndGiveBack(prevSubscription);\n+                            throw cause;\n+                        }\n+                    }\n+\n+                    final Subscription afterLockSubscription = subscription;\n+                    if (afterLockSubscription == PROCESSING_ONNEXT || afterLockSubscription == CANCELLED) {\n+                        // onNext is allowed to interrupt, and will handle any pending cancel/request events\n+                        // after it completes (otherwise we may drop signals).\n+                        break;\n+                    } else if (afterLockSubscription == CANCEL_PENDING) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1371888e0d42ed60e7c5ce80eb43544b66458e6"}, "originalPosition": 553}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE2MTAwOQ==", "bodyText": "nit: you could remove the else", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r410161009", "createdAt": "2020-04-17T11:25:31Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * This flatMap implementation doesn't rely upon queuing to manage demand. Instead it leases out demand quota\n+ * (capped by {@link #maxMappedDemand}) mapped {@link Publisher}s and reclaims any unused quota when each mapped\n+ * {@link Publisher} is terminated or cancelled. {@link FlatMapSubscriber.FlatMapPublisherSubscriber} carefully manages\n+ * outstanding demand to ensure when quota is reclaimed there are no subsequent\n+ * {@link Subscriber#onNext(Object) signals} to avoid returning inaccurate amounts which would otherwise result in\n+ * deadlock (under delivering {@link Subscriber#onNext(Object) signals}) or violation of\n+ * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.1\">Reactive Streams\n+ * Specification</a> (over delivering {@link Subscriber#onNext(Object) signals}) to the downstream {@link Subscriber}.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                if (prevActiveMappedSources < 0) {\n+                    // We have been cancelled, so in this case we don't want to Subscribe and instead\n+                    // just want to discard the Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                        prevActiveMappedSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    tryRequestMore(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable c) {\n+                        if (delayedCause == null) {\n+                            delayedCause = c;\n+                        }\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            if (!pending.offer(item)) {\n+                enqueueAndDrainFail(item);\n+            }\n+            drainPending();\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {\n+            QueueFullException exception = new QueueFullException(\"pending\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n+        private void drainPending() {\n+            long emittedCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingLockUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;\n+                            }\n+                        }\n+                    }\n+                } finally {\n+                    if (releasePendingLock(emittingLockUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (emittedCount != 0) {\n+                tryRequestMore();\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            }\n+            if (item instanceof TerminalNotification) {\n+                targetTerminated = true;\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                CompositeException de = this.delayedError;\n+                if (de != null) {\n+                    de.addAllPendingSuppressed();\n+                    if (terminalNotification.cause() == de) {\n+                        terminalNotification.terminate(target);\n+                    } else {\n+                        terminalNotification.terminate(target, de);\n+                    }\n+                } else {\n+                    terminalNotification.terminate(target);\n+                }\n+                return false;\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            final R rItem = item == NULL_TOKEN ? null : (R) item;\n+            target.onNext(rItem);\n+            return true;\n+        }\n+\n+        private void tryRequestMore(FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        final int consumedRequestN = subscriber.requestFromUpstream(\n+                                (int) min(source.maxMappedDemand, availableRequestN));\n+                        assert availableRequestN >= consumedRequestN;\n+                        if (consumedRequestN != availableRequestN) {\n+                            giveBackRequestN(availableRequestN - consumedRequestN);\n+                        }\n+                    }\n+                } finally {\n+                    if (!releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        tryRequestMore();\n+                    }\n+                }\n+            }\n+        }\n+\n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n+        private void tryRequestMore() {\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        Iterator<FlatMapPublisherSubscriber<T, R>> itr = subscribers.iterator();\n+                        while (itr.hasNext() && remainingRequestN > 0) {\n+                            remainingRequestN -= itr.next().requestFromUpstream(\n+                                    (int) Math.min(source.maxMappedDemand, remainingRequestN));\n+                        }\n+\n+                        assert availableRequestN >= remainingRequestN && remainingRequestN >= 0;\n+                        if (remainingRequestN > 0) {\n+                            giveBackRequestN(remainingRequestN);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    if (delayedCause == null) {\n+                        delayedCause = cause;\n+                    }\n+                } finally {\n+                    if (releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void giveBackRequestN(final long delta) {\n+            pendingDemandUpdater.addAndGet(this, delta);\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                // Should always be >= 0, but just in case there is a bug in user code that results in multiple terminal\n+                // events we avoid corrupting our internal state.\n+                if (prevActiveMappedSources < 0 || activeMappedSourcesUpdater.compareAndSet(this,\n+                        prevActiveMappedSources, -prevActiveMappedSources)) {\n+                    return prevActiveMappedSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActivePublishers = activeMappedSources;\n+                assert prevActivePublishers != 0;\n+                if (prevActivePublishers > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                            prevActivePublishers - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                        prevActivePublishers + 1)) {\n+                    return prevActivePublishers == -1;\n+                }\n+            }\n+        }\n+\n+        private boolean removeSubscriber(final FlatMapPublisherSubscriber<T, R> subscriber,\n+                                         final long requestNGiveBack) {\n+            if (subscribers.remove(subscriber)) {\n+                if (decrementActiveMappedSources()) {\n+                    return true;\n+                }\n+\n+                assert subscription != null;\n+                subscription.request(1);\n+\n+                if (requestNGiveBack > 0) {\n+                    giveBackRequestN(requestNGiveBack);\n+                    tryRequestMore();\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private static final class FlatMapPublisherSubscriber<T, R> implements Subscriber<R> {\n+            private static final Subscription CANCELLED = new EmptySubscription();\n+            private static final Subscription CANCEL_PENDING = new EmptySubscription();\n+            private static final Subscription REQUEST_PENDING = new EmptySubscription();\n+            private static final Subscription PROCESSING_REQUEST = new EmptySubscription();\n+            private static final Subscription PROCESSING_ONNEXT = new EmptySubscription();\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicReferenceFieldUpdater<FlatMapPublisherSubscriber, Subscription>\n+                    subscriptionUpdater = newUpdater(FlatMapPublisherSubscriber.class, Subscription.class,\n+                    \"subscription\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> outstandingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"outstandingDemand\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> pendingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"pendingDemand\");\n+\n+            private final FlatMapSubscriber<T, R> parent;\n+\n+            @SuppressWarnings(\"unused\")\n+            @Nullable\n+            private volatile Subscription subscription;\n+            private volatile long pendingDemand;\n+            private volatile long outstandingDemand;\n+\n+            FlatMapPublisherSubscriber(FlatMapSubscriber<T, R> parent) {\n+                this.parent = parent;\n+            }\n+\n+            void cancelFromUpstream() {\n+                for (;;) {\n+                    final Subscription prevSubscription = subscription;\n+                    if (prevSubscription == null) {\n+                        if (subscriptionUpdater.compareAndSet(this, null, CANCELLED)) {\n+                            break;\n+                        }\n+                    } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                        break;\n+                    } else if (prevSubscription == PROCESSING_ONNEXT || prevSubscription == PROCESSING_REQUEST) {\n+                        if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCEL_PENDING)) {\n+                            break;\n+                        }\n+                    } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCELLED)) {\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            int requestFromUpstream(final int n) {\n+                for (;;) {\n+                    final long prevOutstandingDemand = outstandingDemand;\n+                    if (prevOutstandingDemand < 0) {\n+                        return 0; // we have already been cancelled, or terminated\n+                    }\n+                    final int quotaToUse = (int) min(Long.MAX_VALUE - prevOutstandingDemand,\n+                            min(parent.source.maxMappedDemand - prevOutstandingDemand, n));\n+                    if (quotaToUse == 0) {\n+                        if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                                prevOutstandingDemand)) {\n+                            return 0;\n+                        }\n+                    } else if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                            prevOutstandingDemand + quotaToUse)) {\n+                        pendingDemandUpdater.addAndGet(this, quotaToUse);\n+                        for (;;) {\n+                            final Subscription prevSubscription = subscription;\n+                            if (prevSubscription == null) {\n+                                if (subscriptionUpdater.compareAndSet(this, null, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                                break;\n+                            } else if (prevSubscription == REQUEST_PENDING || prevSubscription == PROCESSING_ONNEXT ||\n+                                    prevSubscription == PROCESSING_REQUEST) {\n+                                if (subscriptionUpdater.compareAndSet(this, prevSubscription, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, PROCESSING_REQUEST)) {\n+                                doRequestMore(prevSubscription);\n+                                break;\n+                            }\n+                        }\n+                        return quotaToUse;\n+                    }\n+                }\n+            }\n+\n+            private void doRequestMore(Subscription prevSubscription) {\n+                long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                for (;;) {\n+                    if (availableRequestN > 0) {\n+                        try {\n+                            prevSubscription.request(availableRequestN);\n+                        } catch (Throwable cause) {\n+                            subscription = CANCELLED;\n+                            cancelAndGiveBack(prevSubscription);\n+                            throw cause;\n+                        }\n+                    }\n+\n+                    final Subscription afterLockSubscription = subscription;\n+                    if (afterLockSubscription == PROCESSING_ONNEXT || afterLockSubscription == CANCELLED) {\n+                        // onNext is allowed to interrupt, and will handle any pending cancel/request events\n+                        // after it completes (otherwise we may drop signals).\n+                        break;\n+                    } else if (afterLockSubscription == CANCEL_PENDING) {\n+                        subscription = CANCELLED;\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    } else if (afterLockSubscription == REQUEST_PENDING) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1371888e0d42ed60e7c5ce80eb43544b66458e6"}, "originalPosition": 557}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE2MTQ2NA==", "bodyText": "nit: define a static field for -1 to make it more clear why this magic number is used.", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r410161464", "createdAt": "2020-04-17T11:26:34Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * This flatMap implementation doesn't rely upon queuing to manage demand. Instead it leases out demand quota\n+ * (capped by {@link #maxMappedDemand}) mapped {@link Publisher}s and reclaims any unused quota when each mapped\n+ * {@link Publisher} is terminated or cancelled. {@link FlatMapSubscriber.FlatMapPublisherSubscriber} carefully manages\n+ * outstanding demand to ensure when quota is reclaimed there are no subsequent\n+ * {@link Subscriber#onNext(Object) signals} to avoid returning inaccurate amounts which would otherwise result in\n+ * deadlock (under delivering {@link Subscriber#onNext(Object) signals}) or violation of\n+ * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.1\">Reactive Streams\n+ * Specification</a> (over delivering {@link Subscriber#onNext(Object) signals}) to the downstream {@link Subscriber}.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                if (prevActiveMappedSources < 0) {\n+                    // We have been cancelled, so in this case we don't want to Subscribe and instead\n+                    // just want to discard the Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                        prevActiveMappedSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    tryRequestMore(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable c) {\n+                        if (delayedCause == null) {\n+                            delayedCause = c;\n+                        }\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            if (!pending.offer(item)) {\n+                enqueueAndDrainFail(item);\n+            }\n+            drainPending();\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {\n+            QueueFullException exception = new QueueFullException(\"pending\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n+        private void drainPending() {\n+            long emittedCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingLockUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;\n+                            }\n+                        }\n+                    }\n+                } finally {\n+                    if (releasePendingLock(emittingLockUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (emittedCount != 0) {\n+                tryRequestMore();\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            }\n+            if (item instanceof TerminalNotification) {\n+                targetTerminated = true;\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                CompositeException de = this.delayedError;\n+                if (de != null) {\n+                    de.addAllPendingSuppressed();\n+                    if (terminalNotification.cause() == de) {\n+                        terminalNotification.terminate(target);\n+                    } else {\n+                        terminalNotification.terminate(target, de);\n+                    }\n+                } else {\n+                    terminalNotification.terminate(target);\n+                }\n+                return false;\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            final R rItem = item == NULL_TOKEN ? null : (R) item;\n+            target.onNext(rItem);\n+            return true;\n+        }\n+\n+        private void tryRequestMore(FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        final int consumedRequestN = subscriber.requestFromUpstream(\n+                                (int) min(source.maxMappedDemand, availableRequestN));\n+                        assert availableRequestN >= consumedRequestN;\n+                        if (consumedRequestN != availableRequestN) {\n+                            giveBackRequestN(availableRequestN - consumedRequestN);\n+                        }\n+                    }\n+                } finally {\n+                    if (!releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        tryRequestMore();\n+                    }\n+                }\n+            }\n+        }\n+\n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n+        private void tryRequestMore() {\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        Iterator<FlatMapPublisherSubscriber<T, R>> itr = subscribers.iterator();\n+                        while (itr.hasNext() && remainingRequestN > 0) {\n+                            remainingRequestN -= itr.next().requestFromUpstream(\n+                                    (int) Math.min(source.maxMappedDemand, remainingRequestN));\n+                        }\n+\n+                        assert availableRequestN >= remainingRequestN && remainingRequestN >= 0;\n+                        if (remainingRequestN > 0) {\n+                            giveBackRequestN(remainingRequestN);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    if (delayedCause == null) {\n+                        delayedCause = cause;\n+                    }\n+                } finally {\n+                    if (releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void giveBackRequestN(final long delta) {\n+            pendingDemandUpdater.addAndGet(this, delta);\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                // Should always be >= 0, but just in case there is a bug in user code that results in multiple terminal\n+                // events we avoid corrupting our internal state.\n+                if (prevActiveMappedSources < 0 || activeMappedSourcesUpdater.compareAndSet(this,\n+                        prevActiveMappedSources, -prevActiveMappedSources)) {\n+                    return prevActiveMappedSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActivePublishers = activeMappedSources;\n+                assert prevActivePublishers != 0;\n+                if (prevActivePublishers > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                            prevActivePublishers - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                        prevActivePublishers + 1)) {\n+                    return prevActivePublishers == -1;\n+                }\n+            }\n+        }\n+\n+        private boolean removeSubscriber(final FlatMapPublisherSubscriber<T, R> subscriber,\n+                                         final long requestNGiveBack) {\n+            if (subscribers.remove(subscriber)) {\n+                if (decrementActiveMappedSources()) {\n+                    return true;\n+                }\n+\n+                assert subscription != null;\n+                subscription.request(1);\n+\n+                if (requestNGiveBack > 0) {\n+                    giveBackRequestN(requestNGiveBack);\n+                    tryRequestMore();\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private static final class FlatMapPublisherSubscriber<T, R> implements Subscriber<R> {\n+            private static final Subscription CANCELLED = new EmptySubscription();\n+            private static final Subscription CANCEL_PENDING = new EmptySubscription();\n+            private static final Subscription REQUEST_PENDING = new EmptySubscription();\n+            private static final Subscription PROCESSING_REQUEST = new EmptySubscription();\n+            private static final Subscription PROCESSING_ONNEXT = new EmptySubscription();\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicReferenceFieldUpdater<FlatMapPublisherSubscriber, Subscription>\n+                    subscriptionUpdater = newUpdater(FlatMapPublisherSubscriber.class, Subscription.class,\n+                    \"subscription\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> outstandingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"outstandingDemand\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> pendingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"pendingDemand\");\n+\n+            private final FlatMapSubscriber<T, R> parent;\n+\n+            @SuppressWarnings(\"unused\")\n+            @Nullable\n+            private volatile Subscription subscription;\n+            private volatile long pendingDemand;\n+            private volatile long outstandingDemand;\n+\n+            FlatMapPublisherSubscriber(FlatMapSubscriber<T, R> parent) {\n+                this.parent = parent;\n+            }\n+\n+            void cancelFromUpstream() {\n+                for (;;) {\n+                    final Subscription prevSubscription = subscription;\n+                    if (prevSubscription == null) {\n+                        if (subscriptionUpdater.compareAndSet(this, null, CANCELLED)) {\n+                            break;\n+                        }\n+                    } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                        break;\n+                    } else if (prevSubscription == PROCESSING_ONNEXT || prevSubscription == PROCESSING_REQUEST) {\n+                        if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCEL_PENDING)) {\n+                            break;\n+                        }\n+                    } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCELLED)) {\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            int requestFromUpstream(final int n) {\n+                for (;;) {\n+                    final long prevOutstandingDemand = outstandingDemand;\n+                    if (prevOutstandingDemand < 0) {\n+                        return 0; // we have already been cancelled, or terminated\n+                    }\n+                    final int quotaToUse = (int) min(Long.MAX_VALUE - prevOutstandingDemand,\n+                            min(parent.source.maxMappedDemand - prevOutstandingDemand, n));\n+                    if (quotaToUse == 0) {\n+                        if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                                prevOutstandingDemand)) {\n+                            return 0;\n+                        }\n+                    } else if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                            prevOutstandingDemand + quotaToUse)) {\n+                        pendingDemandUpdater.addAndGet(this, quotaToUse);\n+                        for (;;) {\n+                            final Subscription prevSubscription = subscription;\n+                            if (prevSubscription == null) {\n+                                if (subscriptionUpdater.compareAndSet(this, null, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                                break;\n+                            } else if (prevSubscription == REQUEST_PENDING || prevSubscription == PROCESSING_ONNEXT ||\n+                                    prevSubscription == PROCESSING_REQUEST) {\n+                                if (subscriptionUpdater.compareAndSet(this, prevSubscription, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, PROCESSING_REQUEST)) {\n+                                doRequestMore(prevSubscription);\n+                                break;\n+                            }\n+                        }\n+                        return quotaToUse;\n+                    }\n+                }\n+            }\n+\n+            private void doRequestMore(Subscription prevSubscription) {\n+                long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                for (;;) {\n+                    if (availableRequestN > 0) {\n+                        try {\n+                            prevSubscription.request(availableRequestN);\n+                        } catch (Throwable cause) {\n+                            subscription = CANCELLED;\n+                            cancelAndGiveBack(prevSubscription);\n+                            throw cause;\n+                        }\n+                    }\n+\n+                    final Subscription afterLockSubscription = subscription;\n+                    if (afterLockSubscription == PROCESSING_ONNEXT || afterLockSubscription == CANCELLED) {\n+                        // onNext is allowed to interrupt, and will handle any pending cancel/request events\n+                        // after it completes (otherwise we may drop signals).\n+                        break;\n+                    } else if (afterLockSubscription == CANCEL_PENDING) {\n+                        subscription = CANCELLED;\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    } else if (afterLockSubscription == REQUEST_PENDING) {\n+                        if (subscriptionUpdater.compareAndSet(this, REQUEST_PENDING, PROCESSING_REQUEST)) {\n+                            availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                            // continue through next iteration to try to unlock\n+                        }\n+                    } else if (afterLockSubscription == PROCESSING_REQUEST &&\n+                            subscriptionUpdater.compareAndSet(this, PROCESSING_REQUEST, prevSubscription)) {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            private void cancelAndGiveBack(Subscription subscription) {\n+                try {\n+                    subscription.cancel();\n+                } finally {\n+                    giveBackUnusedRequestN();\n+                }\n+            }\n+\n+            private boolean giveBackUnusedRequestN() {\n+                // we need to give back the outstanding amount that has been requested, but not emitted.\n+                // resetting sourceRequestedUpdater must happen unconditionally first, as this stops\n+                // calculateSourceRequested from attempting to request any more.\n+                final long prevOutstandingDemand = outstandingDemandUpdater.getAndSet(this, -1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1371888e0d42ed60e7c5ce80eb43544b66458e6"}, "originalPosition": 581}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE2MTgwNA==", "bodyText": "nit: you could remove the else", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r410161804", "createdAt": "2020-04-17T11:27:25Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,694 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * This flatMap implementation doesn't rely upon queuing to manage demand. Instead it leases out demand quota\n+ * (capped by {@link #maxMappedDemand}) mapped {@link Publisher}s and reclaims any unused quota when each mapped\n+ * {@link Publisher} is terminated or cancelled. {@link FlatMapSubscriber.FlatMapPublisherSubscriber} carefully manages\n+ * outstanding demand to ensure when quota is reclaimed there are no subsequent\n+ * {@link Subscriber#onNext(Object) signals} to avoid returning inaccurate amounts which would otherwise result in\n+ * deadlock (under delivering {@link Subscriber#onNext(Object) signals}) or violation of\n+ * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.1\">Reactive Streams\n+ * Specification</a> (over delivering {@link Subscriber#onNext(Object) signals}) to the downstream {@link Subscriber}.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                if (prevActiveMappedSources < 0) {\n+                    // We have been cancelled, so in this case we don't want to Subscribe and instead\n+                    // just want to discard the Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                        prevActiveMappedSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    tryRequestMore(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable c) {\n+                        if (delayedCause == null) {\n+                            delayedCause = c;\n+                        }\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            if (!pending.offer(item)) {\n+                enqueueAndDrainFail(item);\n+            }\n+            drainPending();\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {\n+            QueueFullException exception = new QueueFullException(\"pending\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n+        private void drainPending() {\n+            long emittedCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingLockUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;\n+                            }\n+                        }\n+                    }\n+                } finally {\n+                    if (releasePendingLock(emittingLockUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (emittedCount != 0) {\n+                tryRequestMore();\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            }\n+            if (item instanceof TerminalNotification) {\n+                targetTerminated = true;\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                CompositeException de = this.delayedError;\n+                if (de != null) {\n+                    de.addAllPendingSuppressed();\n+                    if (terminalNotification.cause() == de) {\n+                        terminalNotification.terminate(target);\n+                    } else {\n+                        terminalNotification.terminate(target, de);\n+                    }\n+                } else {\n+                    terminalNotification.terminate(target);\n+                }\n+                return false;\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            final R rItem = item == NULL_TOKEN ? null : (R) item;\n+            target.onNext(rItem);\n+            return true;\n+        }\n+\n+        private void tryRequestMore(FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        final int consumedRequestN = subscriber.requestFromUpstream(\n+                                (int) min(source.maxMappedDemand, availableRequestN));\n+                        assert availableRequestN >= consumedRequestN;\n+                        if (consumedRequestN != availableRequestN) {\n+                            giveBackRequestN(availableRequestN - consumedRequestN);\n+                        }\n+                    }\n+                } finally {\n+                    if (!releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        tryRequestMore();\n+                    }\n+                }\n+            }\n+        }\n+\n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n+        private void tryRequestMore() {\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(tryRequestMoreLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                    if (availableRequestN != 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        Iterator<FlatMapPublisherSubscriber<T, R>> itr = subscribers.iterator();\n+                        while (itr.hasNext() && remainingRequestN > 0) {\n+                            remainingRequestN -= itr.next().requestFromUpstream(\n+                                    (int) Math.min(source.maxMappedDemand, remainingRequestN));\n+                        }\n+\n+                        assert availableRequestN >= remainingRequestN && remainingRequestN >= 0;\n+                        if (remainingRequestN > 0) {\n+                            giveBackRequestN(remainingRequestN);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    if (delayedCause == null) {\n+                        delayedCause = cause;\n+                    }\n+                } finally {\n+                    if (releasePendingLock(tryRequestMoreLockUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void giveBackRequestN(final long delta) {\n+            pendingDemandUpdater.addAndGet(this, delta);\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                // Should always be >= 0, but just in case there is a bug in user code that results in multiple terminal\n+                // events we avoid corrupting our internal state.\n+                if (prevActiveMappedSources < 0 || activeMappedSourcesUpdater.compareAndSet(this,\n+                        prevActiveMappedSources, -prevActiveMappedSources)) {\n+                    return prevActiveMappedSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActivePublishers = activeMappedSources;\n+                assert prevActivePublishers != 0;\n+                if (prevActivePublishers > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                            prevActivePublishers - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActivePublishers,\n+                        prevActivePublishers + 1)) {\n+                    return prevActivePublishers == -1;\n+                }\n+            }\n+        }\n+\n+        private boolean removeSubscriber(final FlatMapPublisherSubscriber<T, R> subscriber,\n+                                         final long requestNGiveBack) {\n+            if (subscribers.remove(subscriber)) {\n+                if (decrementActiveMappedSources()) {\n+                    return true;\n+                }\n+\n+                assert subscription != null;\n+                subscription.request(1);\n+\n+                if (requestNGiveBack > 0) {\n+                    giveBackRequestN(requestNGiveBack);\n+                    tryRequestMore();\n+                }\n+            }\n+            return false;\n+        }\n+\n+        private static final class FlatMapPublisherSubscriber<T, R> implements Subscriber<R> {\n+            private static final Subscription CANCELLED = new EmptySubscription();\n+            private static final Subscription CANCEL_PENDING = new EmptySubscription();\n+            private static final Subscription REQUEST_PENDING = new EmptySubscription();\n+            private static final Subscription PROCESSING_REQUEST = new EmptySubscription();\n+            private static final Subscription PROCESSING_ONNEXT = new EmptySubscription();\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicReferenceFieldUpdater<FlatMapPublisherSubscriber, Subscription>\n+                    subscriptionUpdater = newUpdater(FlatMapPublisherSubscriber.class, Subscription.class,\n+                    \"subscription\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> outstandingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"outstandingDemand\");\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicLongFieldUpdater<FlatMapPublisherSubscriber> pendingDemandUpdater =\n+                    AtomicLongFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"pendingDemand\");\n+\n+            private final FlatMapSubscriber<T, R> parent;\n+\n+            @SuppressWarnings(\"unused\")\n+            @Nullable\n+            private volatile Subscription subscription;\n+            private volatile long pendingDemand;\n+            private volatile long outstandingDemand;\n+\n+            FlatMapPublisherSubscriber(FlatMapSubscriber<T, R> parent) {\n+                this.parent = parent;\n+            }\n+\n+            void cancelFromUpstream() {\n+                for (;;) {\n+                    final Subscription prevSubscription = subscription;\n+                    if (prevSubscription == null) {\n+                        if (subscriptionUpdater.compareAndSet(this, null, CANCELLED)) {\n+                            break;\n+                        }\n+                    } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                        break;\n+                    } else if (prevSubscription == PROCESSING_ONNEXT || prevSubscription == PROCESSING_REQUEST) {\n+                        if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCEL_PENDING)) {\n+                            break;\n+                        }\n+                    } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, CANCELLED)) {\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            int requestFromUpstream(final int n) {\n+                for (;;) {\n+                    final long prevOutstandingDemand = outstandingDemand;\n+                    if (prevOutstandingDemand < 0) {\n+                        return 0; // we have already been cancelled, or terminated\n+                    }\n+                    final int quotaToUse = (int) min(Long.MAX_VALUE - prevOutstandingDemand,\n+                            min(parent.source.maxMappedDemand - prevOutstandingDemand, n));\n+                    if (quotaToUse == 0) {\n+                        if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                                prevOutstandingDemand)) {\n+                            return 0;\n+                        }\n+                    } else if (outstandingDemandUpdater.compareAndSet(this, prevOutstandingDemand,\n+                            prevOutstandingDemand + quotaToUse)) {\n+                        pendingDemandUpdater.addAndGet(this, quotaToUse);\n+                        for (;;) {\n+                            final Subscription prevSubscription = subscription;\n+                            if (prevSubscription == null) {\n+                                if (subscriptionUpdater.compareAndSet(this, null, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                                break;\n+                            } else if (prevSubscription == REQUEST_PENDING || prevSubscription == PROCESSING_ONNEXT ||\n+                                    prevSubscription == PROCESSING_REQUEST) {\n+                                if (subscriptionUpdater.compareAndSet(this, prevSubscription, REQUEST_PENDING)) {\n+                                    break;\n+                                }\n+                            } else if (subscriptionUpdater.compareAndSet(this, prevSubscription, PROCESSING_REQUEST)) {\n+                                doRequestMore(prevSubscription);\n+                                break;\n+                            }\n+                        }\n+                        return quotaToUse;\n+                    }\n+                }\n+            }\n+\n+            private void doRequestMore(Subscription prevSubscription) {\n+                long availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                for (;;) {\n+                    if (availableRequestN > 0) {\n+                        try {\n+                            prevSubscription.request(availableRequestN);\n+                        } catch (Throwable cause) {\n+                            subscription = CANCELLED;\n+                            cancelAndGiveBack(prevSubscription);\n+                            throw cause;\n+                        }\n+                    }\n+\n+                    final Subscription afterLockSubscription = subscription;\n+                    if (afterLockSubscription == PROCESSING_ONNEXT || afterLockSubscription == CANCELLED) {\n+                        // onNext is allowed to interrupt, and will handle any pending cancel/request events\n+                        // after it completes (otherwise we may drop signals).\n+                        break;\n+                    } else if (afterLockSubscription == CANCEL_PENDING) {\n+                        subscription = CANCELLED;\n+                        cancelAndGiveBack(prevSubscription);\n+                        break;\n+                    } else if (afterLockSubscription == REQUEST_PENDING) {\n+                        if (subscriptionUpdater.compareAndSet(this, REQUEST_PENDING, PROCESSING_REQUEST)) {\n+                            availableRequestN = pendingDemandUpdater.getAndSet(this, 0);\n+                            // continue through next iteration to try to unlock\n+                        }\n+                    } else if (afterLockSubscription == PROCESSING_REQUEST &&\n+                            subscriptionUpdater.compareAndSet(this, PROCESSING_REQUEST, prevSubscription)) {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            private void cancelAndGiveBack(Subscription subscription) {\n+                try {\n+                    subscription.cancel();\n+                } finally {\n+                    giveBackUnusedRequestN();\n+                }\n+            }\n+\n+            private boolean giveBackUnusedRequestN() {\n+                // we need to give back the outstanding amount that has been requested, but not emitted.\n+                // resetting sourceRequestedUpdater must happen unconditionally first, as this stops\n+                // calculateSourceRequested from attempting to request any more.\n+                final long prevOutstandingDemand = outstandingDemandUpdater.getAndSet(this, -1);\n+                return prevOutstandingDemand >= 0 && parent.removeSubscriber(this, prevOutstandingDemand);\n+            }\n+\n+            @Override\n+            public void onSubscribe(final Subscription s) {\n+                for (;;) {\n+                    final Subscription prevSubscription = subscription;\n+                    assert prevSubscription != CANCEL_PENDING && prevSubscription != PROCESSING_ONNEXT &&\n+                            prevSubscription != PROCESSING_REQUEST;\n+                    if (prevSubscription == null) {\n+                        if (subscriptionUpdater.compareAndSet(this, null, s)) {\n+                            break;\n+                        }\n+                    } else if (prevSubscription == REQUEST_PENDING) {\n+                        if (subscriptionUpdater.compareAndSet(this, REQUEST_PENDING, PROCESSING_REQUEST)) {\n+                            doRequestMore(s);\n+                            break;\n+                        }\n+                    } else {\n+                        s.cancel(); // already cancelled or duplicate onSubscribe\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void onNext(@Nullable final R r) {\n+                boolean acquiredLock = false;\n+                for (;;) {\n+                    Subscription prevSubscription = subscription;\n+                    assert prevSubscription != null;\n+                    if (prevSubscription == CANCELLED || prevSubscription == CANCEL_PENDING) {\n+                        // we have already given our undelivered requestN quota up, or will after we unroll process\n+                        // onNext. we are not allowed to deliver more data or else we may violate upstream's requestN.\n+                        break;\n+                    } else if (prevSubscription == PROCESSING_ONNEXT ||\n+                            (acquiredLock = subscriptionUpdater.compareAndSet(this,\n+                                    prevSubscription, PROCESSING_ONNEXT))) {\n+                        final long newOutstandingDemand = outstandingDemandUpdater.decrementAndGet(this);\n+                        try {\n+                            parent.enqueueAndDrain(r == null ? NULL_TOKEN : r);\n+                        } finally {\n+                            if (acquiredLock) {\n+                                for (;;) {\n+                                    Subscription afterLockSubscription = subscription;\n+                                    assert afterLockSubscription != PROCESSING_REQUEST;\n+                                    if (afterLockSubscription == CANCEL_PENDING) {\n+                                        subscription = CANCELLED; // this is a terminal state.\n+                                        cancelAndGiveBack(prevSubscription);\n+                                        break;\n+                                    } else if (afterLockSubscription == REQUEST_PENDING) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1371888e0d42ed60e7c5ce80eb43544b66458e6"}, "originalPosition": 632}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "72bc68a5c99278795eb4d7d7b1931f5dade96ded", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/72bc68a5c99278795eb4d7d7b1931f5dade96ded", "committedDate": "2020-04-18T22:06:33Z", "message": "introduce public static and minor cleanup"}, "afterCommit": {"oid": "97d3ca48b7a5e3b67faed9d221eba6d7f6fe5d2b", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/97d3ca48b7a5e3b67faed9d221eba6d7f6fe5d2b", "committedDate": "2020-04-20T16:44:44Z", "message": "minor cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MjQ4MDA4", "url": "https://github.com/apple/servicetalk/pull/1011#pullrequestreview-397248008", "createdAt": "2020-04-21T11:43:42Z", "commit": {"oid": "97d3ca48b7a5e3b67faed9d221eba6d7f6fe5d2b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMTo0Mzo0MlrOGJBSxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMTo0NzozNFrOGJBcPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjExMTU1Ng==", "bodyText": "Is a ConcurrentHashMap good enough as the backing for the Set or do we also need to preserve some sort of \"ordering\" when iterate over all the subscribers later on and so would need some sorted of LinkedHashSet ?", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r412111556", "createdAt": "2020-04-21T11:43:42Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,705 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * This flatMap implementation doesn't rely upon queuing to manage demand. Instead it leases out demand quota\n+ * (capped by {@link #maxMappedDemand}) mapped {@link Publisher}s and reclaims any unused quota when each mapped\n+ * {@link Publisher} is terminated or cancelled. {@link FlatMapSubscriber.FlatMapPublisherSubscriber} carefully manages\n+ * outstanding demand to ensure when quota is reclaimed there are no subsequent\n+ * {@link Subscriber#onNext(Object) signals} to avoid returning inaccurate amounts which would otherwise result in\n+ * deadlock (under delivering {@link Subscriber#onNext(Object) signals}) or violation of\n+ * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.1\">Reactive Streams\n+ * Specification</a> (over delivering {@link Subscriber#onNext(Object) signals}) to the downstream {@link Subscriber}.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97d3ca48b7a5e3b67faed9d221eba6d7f6fe5d2b"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjExMzk4Mw==", "bodyText": "is it possible that cancel() and onNext(...) is called concurrently ? If so just iterating over the subscribers and then call clear() is racy as you may miss some subscribers that were added by onNext(...)", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r412113983", "createdAt": "2020-04-21T11:47:34Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,705 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.EmptySubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Iterator;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.NULL_TOKEN;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.acquirePendingLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releasePendingLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * This flatMap implementation doesn't rely upon queuing to manage demand. Instead it leases out demand quota\n+ * (capped by {@link #maxMappedDemand}) mapped {@link Publisher}s and reclaims any unused quota when each mapped\n+ * {@link Publisher} is terminated or cancelled. {@link FlatMapSubscriber.FlatMapPublisherSubscriber} carefully manages\n+ * outstanding demand to ensure when quota is reclaimed there are no subsequent\n+ * {@link Subscriber#onNext(Object) signals} to avoid returning inaccurate amounts which would otherwise result in\n+ * deadlock (under delivering {@link Subscriber#onNext(Object) signals}) or violation of\n+ * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.1\">Reactive Streams\n+ * Specification</a> (over delivering {@link Subscriber#onNext(Object) signals}) to the downstream {@link Subscriber}.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> tryRequestMoreLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"tryRequestMoreLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int tryRequestMoreLock;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile long pendingDemand;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+\n+        /**\n+         * This variable is only accessed within the \"emitting lock\" so we rely upon this to provide visibility to\n+         * other threads.\n+         */\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> pending;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            pending = newUnboundedMpscQueue(min(2, source.maxConcurrency));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtection);\n+                tryRequestMore();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            // Currently we always request maxConcurrency elements from upstream.\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveMappedSources = activeMappedSources;\n+                if (prevActiveMappedSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either way\n+                    // we don't want to Subscribe or retain a reference to this Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveMappedSources,\n+                        prevActiveMappedSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    tryRequestMore(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97d3ca48b7a5e3b67faed9d221eba6d7f6fe5d2b"}, "originalPosition": 247}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "97d3ca48b7a5e3b67faed9d221eba6d7f6fe5d2b", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/97d3ca48b7a5e3b67faed9d221eba6d7f6fe5d2b", "committedDate": "2020-04-20T16:44:44Z", "message": "minor cleanup"}, "afterCommit": {"oid": "92bd9728f13959c2a21b58c01a9892f352a58c83", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/92bd9728f13959c2a21b58c01a9892f352a58c83", "committedDate": "2020-04-28T04:24:29Z", "message": "Add Publisher#flatMapMerge operator\n\nMotivation:\nPublisher#flatMapMerge is a basic building block for each element of a\nPublisher to map into another Publisher.\n\nModifications:\n- Add Publisher#flatMapMerge operator\n\nResult:\nEach item emitted on a Publisher can be mapped to another Publisher."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "79c852491c17f313ce2a3c9b1ba4ff9a28027bae", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/79c852491c17f313ce2a3c9b1ba4ff9a28027bae", "committedDate": "2020-04-30T22:31:52Z", "message": "update for consistency with flatMapSingle"}, "afterCommit": {"oid": "8741f487dff9c376a1f46524a4d255054ae552a7", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/8741f487dff9c376a1f46524a4d255054ae552a7", "committedDate": "2020-05-05T15:10:24Z", "message": "Add Publisher#flatMapMerge operator\n\nMotivation:\nPublisher#flatMapMerge is a basic building block for each element of a\nPublisher to map into another Publisher.\n\nModifications:\n- Add Publisher#flatMapMerge operator\n\nResult:\nEach item emitted on a Publisher can be mapped to another Publisher."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8741f487dff9c376a1f46524a4d255054ae552a7", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/8741f487dff9c376a1f46524a4d255054ae552a7", "committedDate": "2020-05-05T15:10:24Z", "message": "Add Publisher#flatMapMerge operator\n\nMotivation:\nPublisher#flatMapMerge is a basic building block for each element of a\nPublisher to map into another Publisher.\n\nModifications:\n- Add Publisher#flatMapMerge operator\n\nResult:\nEach item emitted on a Publisher can be mapped to another Publisher."}, "afterCommit": {"oid": "0a8e4d896b6bc94e92d6e307bc37a8e4d1bf2eef", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/0a8e4d896b6bc94e92d6e307bc37a8e4d1bf2eef", "committedDate": "2020-05-09T04:26:54Z", "message": "work in progress, change to queue more instead of manage request n\ndemand"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0a8e4d896b6bc94e92d6e307bc37a8e4d1bf2eef", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/0a8e4d896b6bc94e92d6e307bc37a8e4d1bf2eef", "committedDate": "2020-05-09T04:26:54Z", "message": "work in progress, change to queue more instead of manage request n\ndemand"}, "afterCommit": {"oid": "351eac77ea560506f39d9bac2f7ddf86dd9e4c8c", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/351eac77ea560506f39d9bac2f7ddf86dd9e4c8c", "committedDate": "2020-05-09T18:08:39Z", "message": "work in progress, change to queue more instead of manage request n\ndemand"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "351eac77ea560506f39d9bac2f7ddf86dd9e4c8c", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/351eac77ea560506f39d9bac2f7ddf86dd9e4c8c", "committedDate": "2020-05-09T18:08:39Z", "message": "work in progress, change to queue more instead of manage request n\ndemand"}, "afterCommit": {"oid": "09e9d9a298fb49d0af16dc1e87cd462bd9b240d6", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/09e9d9a298fb49d0af16dc1e87cd462bd9b240d6", "committedDate": "2020-05-09T19:06:01Z", "message": "work in progress, change to queue more instead of manage request n\ndemand"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "09e9d9a298fb49d0af16dc1e87cd462bd9b240d6", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/09e9d9a298fb49d0af16dc1e87cd462bd9b240d6", "committedDate": "2020-05-09T19:06:01Z", "message": "work in progress, change to queue more instead of manage request n\ndemand"}, "afterCommit": {"oid": "61de9bb46a49435bc9961bbcded470dde393c0de", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/61de9bb46a49435bc9961bbcded470dde393c0de", "committedDate": "2020-05-09T21:33:46Z", "message": "work in progress, change to queue more instead of manage request n\ndemand"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "61de9bb46a49435bc9961bbcded470dde393c0de", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/61de9bb46a49435bc9961bbcded470dde393c0de", "committedDate": "2020-05-09T21:33:46Z", "message": "work in progress, change to queue more instead of manage request n\ndemand"}, "afterCommit": {"oid": "e93286d9d832a3cf6275c81edeae08f699ba12bd", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/e93286d9d832a3cf6275c81edeae08f699ba12bd", "committedDate": "2020-05-12T01:12:10Z", "message": "work in progress, change to queue more instead of manage request n\ndemand"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e93286d9d832a3cf6275c81edeae08f699ba12bd", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/e93286d9d832a3cf6275c81edeae08f699ba12bd", "committedDate": "2020-05-12T01:12:10Z", "message": "work in progress, change to queue more instead of manage request n\ndemand"}, "afterCommit": {"oid": "b987f73abbb9fc30953392f71fdff675c8312bc3", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/b987f73abbb9fc30953392f71fdff675c8312bc3", "committedDate": "2020-05-12T01:13:11Z", "message": "work in progress, change to queue more instead of manage request n\ndemand"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b987f73abbb9fc30953392f71fdff675c8312bc3", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/b987f73abbb9fc30953392f71fdff675c8312bc3", "committedDate": "2020-05-12T01:13:11Z", "message": "work in progress, change to queue more instead of manage request n\ndemand"}, "afterCommit": {"oid": "d5c76b6ddd053ac2d3036fa0fabbe46109a42df5", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/d5c76b6ddd053ac2d3036fa0fabbe46109a42df5", "committedDate": "2020-05-12T01:14:16Z", "message": "work in progress, change to queue more instead of manage request n\ndemand"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d5c76b6ddd053ac2d3036fa0fabbe46109a42df5", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/d5c76b6ddd053ac2d3036fa0fabbe46109a42df5", "committedDate": "2020-05-12T01:14:16Z", "message": "work in progress, change to queue more instead of manage request n\ndemand"}, "afterCommit": {"oid": "4e3f43a9ba6d9a7bca080a2fbd350488ae7291ef", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/4e3f43a9ba6d9a7bca080a2fbd350488ae7291ef", "committedDate": "2020-05-12T18:14:07Z", "message": "work in progress, change to queue more instead of manage request n\ndemand"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4e3f43a9ba6d9a7bca080a2fbd350488ae7291ef", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/4e3f43a9ba6d9a7bca080a2fbd350488ae7291ef", "committedDate": "2020-05-12T18:14:07Z", "message": "work in progress, change to queue more instead of manage request n\ndemand"}, "afterCommit": {"oid": "e88151526677fa7d431b21391f783651bbe09d12", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/e88151526677fa7d431b21391f783651bbe09d12", "committedDate": "2020-05-12T21:30:09Z", "message": "work in progress, change to queue more instead of manage request n\ndemand"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e88151526677fa7d431b21391f783651bbe09d12", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/e88151526677fa7d431b21391f783651bbe09d12", "committedDate": "2020-05-12T21:30:09Z", "message": "work in progress, change to queue more instead of manage request n\ndemand"}, "afterCommit": {"oid": "f43cb45b983a07cb11c3cea16b377df2de70c0d6", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/f43cb45b983a07cb11c3cea16b377df2de70c0d6", "committedDate": "2020-05-12T23:45:52Z", "message": "change to queue more instead of manage request n demand. this way we\nensure we make progress at the expense of memory, and less coordination\nmanaging request(n) lending/distribution."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwODE4OTU5", "url": "https://github.com/apple/servicetalk/pull/1011#pullrequestreview-410818959", "createdAt": "2020-05-13T11:08:59Z", "commit": {"oid": "f43cb45b983a07cb11c3cea16b377df2de70c0d6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMTowODo1OVrOGUsmKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QxMTozMDoyNlrOGUtOjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1NTM2OA==", "bodyText": "nit: s/in side/inside/", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424355368", "createdAt": "2020-05-13T11:08:59Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed in side the Subscriber thread", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43cb45b983a07cb11c3cea16b377df2de70c0d6"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM1NTcwNw==", "bodyText": "nit: should we use some \"non default\" initial capacity ?", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424355707", "createdAt": "2020-05-13T11:09:43Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed in side the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            signals = newUnboundedMpscQueue(min(2, source.maxConcurrency * source.maxMappedDemand));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43cb45b983a07cb11c3cea16b377df2de70c0d6"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2MjIxNQ==", "bodyText": "I wonder if we could just use incrementAndGet(...) and decrement again if its not what we expect. This should be cheaper as this will use XADD when on x86\nSomething like:\n            for (;;) {\n                 final int prevActiveSources = activeMappedSources;\n                 if (prevActiveSources < 0) {\n                     // We have been cancelled, or already completed and the active count flipped to negative, either way\n                     // we don't want to Subscribe or retain a reference to this Publisher.\n                     subscribers.remove(subscriber);\n                     break;\n                 // try to optimistically increment and if the outcome is not what we expect rollback\n                 } else  if (activeMappedSourcesUpdater.incrementAndGet(this) ==  prevActiveSources + 1) {\n                     publisher.subscribeInternal(subscriber);\n                     break;\n                 } else {\n                     // rollback\n                     activeMappedSourcesUpdater.decrementAndGet(this)\n                 }\n             }", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424362215", "createdAt": "2020-05-13T11:23:15Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed in side the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            signals = newUnboundedMpscQueue(min(2, source.maxConcurrency * source.maxMappedDemand));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                    FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                drainPending();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            upstreamDemand = source.maxConcurrency;\n+            subscription.request(upstreamDemand);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either way\n+                    // we don't want to Subscribe or retain a reference to this Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43cb45b983a07cb11c3cea16b377df2de70c0d6"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2MzI0MA==", "bodyText": "same comment as above... consider using decrementAndGet(...)", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424363240", "createdAt": "2020-05-13T11:25:24Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed in side the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            signals = newUnboundedMpscQueue(min(2, source.maxConcurrency * source.maxMappedDemand));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                    FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                drainPending();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            upstreamDemand = source.maxConcurrency;\n+            subscription.request(upstreamDemand);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either way\n+                    // we don't want to Subscribe or retain a reference to this Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            pendingDemand = -1;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable cause) {\n+                        delayedCause = catchUnexpected(delayedCause, cause);\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean tryDecrementDemand() {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevPendingDemand, prevPendingDemand - 1)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43cb45b983a07cb11c3cea16b377df2de70c0d6"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2NDY5NA==", "bodyText": "nit: you could remove all the else as in each block you return.", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424364694", "createdAt": "2020-05-13T11:28:17Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed in side the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            signals = newUnboundedMpscQueue(min(2, source.maxConcurrency * source.maxMappedDemand));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                    FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                drainPending();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            upstreamDemand = source.maxConcurrency;\n+            subscription.request(upstreamDemand);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either way\n+                    // we don't want to Subscribe or retain a reference to this Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            pendingDemand = -1;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable cause) {\n+                        delayedCause = catchUnexpected(delayedCause, cause);\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean tryDecrementDemand() {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevPendingDemand, prevPendingDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevPendingDemand < 0) {\n+                        // if we have been cancelled then we avoid delivering any signals, but we still deliver error\n+                        // terminals below by making sure emittedCount == prevPendingDemand.\n+                        pendingDemand = emittedCount = prevPendingDemand;\n+                        signals.clear();\n+                    }\n+                    Object t;\n+                    while (emittedCount < prevPendingDemand && (t = signals.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            delayedCause = catchUnexpected(delayedCause, cause);\n+                        }\n+                    }\n+\n+                    // check if a terminal event is pending, or give back demand.\n+                    if (emittedCount == prevPendingDemand) {\n+                        for (;;) {\n+                            try {\n+                                t = signals.peek();\n+                                if (t == MAPPED_SOURCE_COMPLETE) {\n+                                    signals.poll();\n+                                    tryRequestMoreFromUpstream();\n+                                } else if (t instanceof FlatMapPublisherSubscriber) {\n+                                    signals.poll();\n+                                    ((FlatMapPublisherSubscriber<?, ?>) t).replenishDemandAndClearSignalsQueued();\n+                                } else {\n+                                    break;\n+                                }\n+                            } catch (Throwable cause) {\n+                                delayedCause = catchUnexpected(delayedCause, cause);\n+                            }\n+                        }\n+\n+                        if (t instanceof TerminalNotification) {\n+                            sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                        } else {\n+                            t = terminalNotification;\n+                            if (t != null && t != complete()) { // don't wait for demand to process an error\n+                                sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                            }\n+                        }\n+                    } else {\n+                        assert emittedCount < prevPendingDemand;\n+                        pendingDemandUpdater.accumulateAndGet(this, prevPendingDemand - emittedCount,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                } finally {\n+                    tryAcquire = !releaseLock(emittingLockUpdater, this);\n+                }\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void tryRequestMoreFromUpstream() {\n+            if (--upstreamDemand == 0) { // heuristic to replenish demand when it is exhausted.\n+                assert subscription != null;\n+                upstreamDemand = source.maxConcurrency;\n+                subscription.request(source.maxConcurrency);\n+            }\n+        }\n+\n+        private static boolean needsDemand(Object item) {\n+            return item != MAPPED_SOURCE_COMPLETE &&\n+                    !(item instanceof FlatMapPublisherSubscriber) && !(item instanceof TerminalNotification);\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            } else if (item == MAPPED_SOURCE_COMPLETE) {\n+                tryRequestMoreFromUpstream();\n+                return false;\n+            } else if (item instanceof TerminalNotification) {\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                sendToTarget(terminalNotification);\n+                return false;\n+            } else if (item instanceof FlatMapPublisherSubscriber) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43cb45b983a07cb11c3cea16b377df2de70c0d6"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2NTE1Nw==", "bodyText": "same comment as above... consider using addAndGet(...) for XADD.", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424365157", "createdAt": "2020-05-13T11:29:16Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed in side the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            signals = newUnboundedMpscQueue(min(2, source.maxConcurrency * source.maxMappedDemand));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                    FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                drainPending();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            upstreamDemand = source.maxConcurrency;\n+            subscription.request(upstreamDemand);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either way\n+                    // we don't want to Subscribe or retain a reference to this Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            pendingDemand = -1;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable cause) {\n+                        delayedCause = catchUnexpected(delayedCause, cause);\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean tryDecrementDemand() {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevPendingDemand, prevPendingDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevPendingDemand < 0) {\n+                        // if we have been cancelled then we avoid delivering any signals, but we still deliver error\n+                        // terminals below by making sure emittedCount == prevPendingDemand.\n+                        pendingDemand = emittedCount = prevPendingDemand;\n+                        signals.clear();\n+                    }\n+                    Object t;\n+                    while (emittedCount < prevPendingDemand && (t = signals.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            delayedCause = catchUnexpected(delayedCause, cause);\n+                        }\n+                    }\n+\n+                    // check if a terminal event is pending, or give back demand.\n+                    if (emittedCount == prevPendingDemand) {\n+                        for (;;) {\n+                            try {\n+                                t = signals.peek();\n+                                if (t == MAPPED_SOURCE_COMPLETE) {\n+                                    signals.poll();\n+                                    tryRequestMoreFromUpstream();\n+                                } else if (t instanceof FlatMapPublisherSubscriber) {\n+                                    signals.poll();\n+                                    ((FlatMapPublisherSubscriber<?, ?>) t).replenishDemandAndClearSignalsQueued();\n+                                } else {\n+                                    break;\n+                                }\n+                            } catch (Throwable cause) {\n+                                delayedCause = catchUnexpected(delayedCause, cause);\n+                            }\n+                        }\n+\n+                        if (t instanceof TerminalNotification) {\n+                            sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                        } else {\n+                            t = terminalNotification;\n+                            if (t != null && t != complete()) { // don't wait for demand to process an error\n+                                sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                            }\n+                        }\n+                    } else {\n+                        assert emittedCount < prevPendingDemand;\n+                        pendingDemandUpdater.accumulateAndGet(this, prevPendingDemand - emittedCount,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                } finally {\n+                    tryAcquire = !releaseLock(emittingLockUpdater, this);\n+                }\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void tryRequestMoreFromUpstream() {\n+            if (--upstreamDemand == 0) { // heuristic to replenish demand when it is exhausted.\n+                assert subscription != null;\n+                upstreamDemand = source.maxConcurrency;\n+                subscription.request(source.maxConcurrency);\n+            }\n+        }\n+\n+        private static boolean needsDemand(Object item) {\n+            return item != MAPPED_SOURCE_COMPLETE &&\n+                    !(item instanceof FlatMapPublisherSubscriber) && !(item instanceof TerminalNotification);\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            } else if (item == MAPPED_SOURCE_COMPLETE) {\n+                tryRequestMoreFromUpstream();\n+                return false;\n+            } else if (item instanceof TerminalNotification) {\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                sendToTarget(terminalNotification);\n+                return false;\n+            } else if (item instanceof FlatMapPublisherSubscriber) {\n+                ((FlatMapPublisherSubscriber<?, ?>) item).replenishDemandAndClearSignalsQueued();\n+                return false;\n+            }\n+            target.onNext(unwrapNullUnchecked(item));\n+            return true;\n+        }\n+\n+        private void sendToTarget(TerminalNotification terminalNotification) {\n+            signals.clear();\n+            targetTerminated = true;\n+            CompositeException de = this.delayedError;\n+            if (de != null) {\n+                de.finishAndThrow();\n+                if (terminalNotification.cause() == de) {\n+                    terminalNotification.terminate(target);\n+                } else {\n+                    terminalNotification.terminate(target, de);\n+                }\n+            } else {\n+                terminalNotification.terminate(target);\n+            }\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                assert prevActiveSources >= 0; // otherwise we have seen multiple onComplete signals\n+                if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, -prevActiveSources)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43cb45b983a07cb11c3cea16b377df2de70c0d6"}, "originalPosition": 416}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2NTQzOA==", "bodyText": "same comment as above... consider using incrementAndGet() / decrementAndGet()", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424365438", "createdAt": "2020-05-13T11:29:52Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed in side the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            signals = newUnboundedMpscQueue(min(2, source.maxConcurrency * source.maxMappedDemand));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>());\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                    FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                drainPending();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            upstreamDemand = source.maxConcurrency;\n+            subscription.request(upstreamDemand);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either way\n+                    // we don't want to Subscribe or retain a reference to this Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            pendingDemand = -1;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable cause) {\n+                        delayedCause = catchUnexpected(delayedCause, cause);\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean tryDecrementDemand() {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevPendingDemand, prevPendingDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevPendingDemand < 0) {\n+                        // if we have been cancelled then we avoid delivering any signals, but we still deliver error\n+                        // terminals below by making sure emittedCount == prevPendingDemand.\n+                        pendingDemand = emittedCount = prevPendingDemand;\n+                        signals.clear();\n+                    }\n+                    Object t;\n+                    while (emittedCount < prevPendingDemand && (t = signals.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            delayedCause = catchUnexpected(delayedCause, cause);\n+                        }\n+                    }\n+\n+                    // check if a terminal event is pending, or give back demand.\n+                    if (emittedCount == prevPendingDemand) {\n+                        for (;;) {\n+                            try {\n+                                t = signals.peek();\n+                                if (t == MAPPED_SOURCE_COMPLETE) {\n+                                    signals.poll();\n+                                    tryRequestMoreFromUpstream();\n+                                } else if (t instanceof FlatMapPublisherSubscriber) {\n+                                    signals.poll();\n+                                    ((FlatMapPublisherSubscriber<?, ?>) t).replenishDemandAndClearSignalsQueued();\n+                                } else {\n+                                    break;\n+                                }\n+                            } catch (Throwable cause) {\n+                                delayedCause = catchUnexpected(delayedCause, cause);\n+                            }\n+                        }\n+\n+                        if (t instanceof TerminalNotification) {\n+                            sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                        } else {\n+                            t = terminalNotification;\n+                            if (t != null && t != complete()) { // don't wait for demand to process an error\n+                                sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                            }\n+                        }\n+                    } else {\n+                        assert emittedCount < prevPendingDemand;\n+                        pendingDemandUpdater.accumulateAndGet(this, prevPendingDemand - emittedCount,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                } finally {\n+                    tryAcquire = !releaseLock(emittingLockUpdater, this);\n+                }\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void tryRequestMoreFromUpstream() {\n+            if (--upstreamDemand == 0) { // heuristic to replenish demand when it is exhausted.\n+                assert subscription != null;\n+                upstreamDemand = source.maxConcurrency;\n+                subscription.request(source.maxConcurrency);\n+            }\n+        }\n+\n+        private static boolean needsDemand(Object item) {\n+            return item != MAPPED_SOURCE_COMPLETE &&\n+                    !(item instanceof FlatMapPublisherSubscriber) && !(item instanceof TerminalNotification);\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            } else if (item == MAPPED_SOURCE_COMPLETE) {\n+                tryRequestMoreFromUpstream();\n+                return false;\n+            } else if (item instanceof TerminalNotification) {\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                sendToTarget(terminalNotification);\n+                return false;\n+            } else if (item instanceof FlatMapPublisherSubscriber) {\n+                ((FlatMapPublisherSubscriber<?, ?>) item).replenishDemandAndClearSignalsQueued();\n+                return false;\n+            }\n+            target.onNext(unwrapNullUnchecked(item));\n+            return true;\n+        }\n+\n+        private void sendToTarget(TerminalNotification terminalNotification) {\n+            signals.clear();\n+            targetTerminated = true;\n+            CompositeException de = this.delayedError;\n+            if (de != null) {\n+                de.finishAndThrow();\n+                if (terminalNotification.cause() == de) {\n+                    terminalNotification.terminate(target);\n+                } else {\n+                    terminalNotification.terminate(target, de);\n+                }\n+            } else {\n+                terminalNotification.terminate(target);\n+            }\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                assert prevActiveSources >= 0; // otherwise we have seen multiple onComplete signals\n+                if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, -prevActiveSources)) {\n+                    return prevActiveSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                assert prevActiveSources != 0;\n+                if (prevActiveSources > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    return prevActiveSources == -1;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43cb45b983a07cb11c3cea16b377df2de70c0d6"}, "originalPosition": 432}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2NTcxMA==", "bodyText": "nit: final ?", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r424365710", "createdAt": "2020-05-13T11:30:26Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/test/java/io/servicetalk/concurrent/api/PublisherFlatMapMergeTest.java", "diffHunk": "@@ -0,0 +1,799 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DeliberateException;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.IntStream;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.PublisherSource.Subscription;\n+import static io.servicetalk.concurrent.api.Publisher.from;\n+import static io.servicetalk.concurrent.api.Publisher.range;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.api.VerificationTestUtils.verifyOriginalAndSuppressedCauses;\n+import static io.servicetalk.concurrent.api.VerificationTestUtils.verifySuppressed;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.empty;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.sameInstance;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+public class PublisherFlatMapMergeTest {\n+    private static final long TERMINAL_POLL_MS = 10;\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+    @Nullable\n+    private static ExecutorService executorService;\n+    @Nullable\n+    private static Executor executor;\n+\n+    private final TestCollectingPublisherSubscriber<Integer> subscriber = new TestCollectingPublisherSubscriber<>();\n+    private TestPublisher<Integer> publisher = new TestPublisher<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f43cb45b983a07cb11c3cea16b377df2de70c0d6"}, "originalPosition": 77}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b887c5c082f7b805093d950b5486b5ece36a6fff", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/b887c5c082f7b805093d950b5486b5ece36a6fff", "committedDate": "2020-05-13T17:10:14Z", "message": "review comments"}, "afterCommit": {"oid": "7093c619b2f0d19dc4a3f7373d86e0f0171f624f", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/7093c619b2f0d19dc4a3f7373d86e0f0171f624f", "committedDate": "2020-05-15T20:58:47Z", "message": "update transferPendingToSuppressed() method name"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7093c619b2f0d19dc4a3f7373d86e0f0171f624f", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/7093c619b2f0d19dc4a3f7373d86e0f0171f624f", "committedDate": "2020-05-15T20:58:47Z", "message": "update transferPendingToSuppressed() method name"}, "afterCommit": {"oid": "9996ed4b5a3cd8db65bfe1d2c33d042fd0461a7d", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/9996ed4b5a3cd8db65bfe1d2c33d042fd0461a7d", "committedDate": "2020-06-17T00:44:52Z", "message": "update transferPendingToSuppressed() method name"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1ODgzMzYz", "url": "https://github.com/apple/servicetalk/pull/1011#pullrequestreview-425883363", "createdAt": "2020-06-08T02:20:51Z", "commit": {"oid": "7093c619b2f0d19dc4a3f7373d86e0f0171f624f"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMjoyMDo1MVrOGgNmkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMDo0ODo0M1rOGnVjSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMDQ4MQ==", "bodyText": "(potentially of a different type)\n\nFrom the perspective of this method, the types are different (T and R) whether in reality T == R is kindda irrelevant. Do we need to mention this here?", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r436430481", "createdAt": "2020-06-08T02:20:51Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Publisher.java", "diffHunk": "@@ -188,6 +188,156 @@ protected Publisher() {\n         return new ResumePublisher<>(this, nextFactory, executor);\n     }\n \n+    /**\n+     * Each element of this {@link Publisher} is mapped into a {@link Publisher} (potentially of a different type) and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7093c619b2f0d19dc4a3f7373d86e0f0171f624f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMDk0NA==", "bodyText": "The language here is different than flatMapMergeSingle in general which is like:\n     * Turns every item emitted by this {@link Publisher} into a {@link Single} and emits the items emitted by each of\n     * those {@link Single}s.\n\nCan we be consistent?\nAlso: it is missing the relevant part of the doc from flatMapMergeSingle:\n\"To control the amount of concurrent processing done by this operator see\"", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r436430944", "createdAt": "2020-06-08T02:24:10Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Publisher.java", "diffHunk": "@@ -188,6 +188,156 @@ protected Publisher() {\n         return new ResumePublisher<>(this, nextFactory, executor);\n     }\n \n+    /**\n+     * Each element of this {@link Publisher} is mapped into a {@link Publisher} (potentially of a different type) and", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMDQ4MQ=="}, "originalCommit": {"oid": "7093c619b2f0d19dc4a3f7373d86e0f0171f624f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMjEyMg==", "bodyText": "As we are explicitly creating a new Subscriber for each onNext, why do we need explicit Set semantics? Is the intent here, faster lookups?", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r436432122", "createdAt": "2020-06-08T02:31:31Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7093c619b2f0d19dc4a3f7373d86e0f0171f624f"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMjQxMg==", "bodyText": "nit: use the name sourceRequested as we use elsewhere?", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r436432412", "createdAt": "2020-06-08T02:33:39Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7093c619b2f0d19dc4a3f7373d86e0f0171f624f"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzNjM3OQ==", "bodyText": "I think it is super confusing to add the subscriber itself to the signals queue.", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r436436379", "createdAt": "2020-06-08T02:58:13Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            signals = newUnboundedMpscQueue(min(2, source.maxConcurrency * source.maxMappedDemand));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>(min(16, source.maxConcurrency)));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                    FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                drainPending();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            upstreamDemand = source.maxConcurrency;\n+            subscription.request(upstreamDemand);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either way\n+                    // we don't want to Subscribe or retain a reference to this Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            pendingDemand = -1;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable cause) {\n+                        delayedCause = catchUnexpected(delayedCause, cause);\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean tryDecrementDemand() {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevPendingDemand, prevPendingDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevPendingDemand < 0) {\n+                        // if we have been cancelled then we avoid delivering any signals, but we still deliver error\n+                        // terminals below by making sure emittedCount == prevPendingDemand.\n+                        pendingDemand = emittedCount = prevPendingDemand;\n+                        signals.clear();\n+                    }\n+                    Object t;\n+                    while (emittedCount < prevPendingDemand && (t = signals.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            delayedCause = catchUnexpected(delayedCause, cause);\n+                        }\n+                    }\n+\n+                    // check if a terminal event is pending, or give back demand.\n+                    if (emittedCount == prevPendingDemand) {\n+                        for (;;) {\n+                            try {\n+                                t = signals.peek();\n+                                if (t == MAPPED_SOURCE_COMPLETE) {\n+                                    signals.poll();\n+                                    tryRequestMoreFromUpstream();\n+                                } else if (t instanceof FlatMapPublisherSubscriber) {\n+                                    signals.poll();\n+                                    ((FlatMapPublisherSubscriber<?, ?>) t).replenishDemandAndClearSignalsQueued();\n+                                } else {\n+                                    break;\n+                                }\n+                            } catch (Throwable cause) {\n+                                delayedCause = catchUnexpected(delayedCause, cause);\n+                            }\n+                        }\n+\n+                        if (t instanceof TerminalNotification) {\n+                            sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                        } else {\n+                            t = terminalNotification;\n+                            if (t != null && t != complete()) { // don't wait for demand to process an error\n+                                sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                            }\n+                        }\n+                    } else {\n+                        assert emittedCount < prevPendingDemand;\n+                        pendingDemandUpdater.accumulateAndGet(this, prevPendingDemand - emittedCount,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                } finally {\n+                    tryAcquire = !releaseLock(emittingLockUpdater, this);\n+                }\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void tryRequestMoreFromUpstream() {\n+            if (--upstreamDemand == 0) { // heuristic to replenish demand when it is exhausted.\n+                assert subscription != null;\n+                upstreamDemand = source.maxConcurrency;\n+                subscription.request(source.maxConcurrency);\n+            }\n+        }\n+\n+        private static boolean needsDemand(Object item) {\n+            return item != MAPPED_SOURCE_COMPLETE &&\n+                    !(item instanceof FlatMapPublisherSubscriber) && !(item instanceof TerminalNotification);\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            if (targetTerminated) {\n+                // No notifications past terminal/cancelled\n+                return false;\n+            } else if (item == MAPPED_SOURCE_COMPLETE) {\n+                tryRequestMoreFromUpstream();\n+                return false;\n+            } else if (item instanceof TerminalNotification) {\n+                // Load the terminal notification in case an error happened after an onComplete and we override the\n+                // terminal value.\n+                TerminalNotification terminalNotification = this.terminalNotification;\n+                assert terminalNotification != null;\n+                sendToTarget(terminalNotification);\n+                return false;\n+            } else if (item instanceof FlatMapPublisherSubscriber) {\n+                ((FlatMapPublisherSubscriber<?, ?>) item).replenishDemandAndClearSignalsQueued();\n+                return false;\n+            }\n+            target.onNext(unwrapNullUnchecked(item));\n+            return true;\n+        }\n+\n+        private void sendToTarget(TerminalNotification terminalNotification) {\n+            signals.clear();\n+            targetTerminated = true;\n+            CompositeException de = this.delayedError;\n+            if (de != null) {\n+                de.transferPendingToSuppressed();\n+                if (terminalNotification.cause() == de) {\n+                    terminalNotification.terminate(target);\n+                } else {\n+                    terminalNotification.terminate(target, de);\n+                }\n+            } else {\n+                terminalNotification.terminate(target);\n+            }\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                assert prevActiveSources >= 0; // otherwise we have seen multiple onComplete signals\n+                if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, -prevActiveSources)) {\n+                    return prevActiveSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                assert prevActiveSources != 0;\n+                if (prevActiveSources > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    return prevActiveSources == -1;\n+                }\n+            }\n+        }\n+\n+        private boolean removeSubscriber(final FlatMapPublisherSubscriber<T, R> subscriber) {\n+            return subscribers.remove(subscriber) && decrementActiveMappedSources();\n+        }\n+\n+        private static final class FlatMapPublisherSubscriber<T, R> implements Subscriber<R> {\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicIntegerFieldUpdater<FlatMapPublisherSubscriber> pendingOnNextUpdater =\n+                    AtomicIntegerFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"pendingOnNext\");\n+\n+            private final FlatMapSubscriber<T, R> parent;\n+            private final DelayedSubscription subscription;\n+            private volatile int pendingOnNext;\n+            /**\n+             * visibility provided by the {@link Subscriber} thread in {@link #onNext(Object)}, and then by\n+             * {@link #pendingDemand} when written to from {@link #replenishDemandAndClearSignalsQueued()} (potentially\n+             * called by a different thread). Demand is exhausted before {@link #replenishDemandAndClearSignalsQueued()}\n+             * is called, and that method triggers {@link #request(long)} and\n+             * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.1\">there\u2019s a\n+             * happens-before relationship between requesting elements and receiving elements</a>.\n+             */\n+            private boolean signalsQueued;\n+\n+            FlatMapPublisherSubscriber(FlatMapSubscriber<T, R> parent) {\n+                this.parent = parent;\n+                subscription = new DelayedSubscription();\n+            }\n+\n+            void cancelFromUpstream() {\n+                subscription.cancel();\n+            }\n+\n+            void replenishDemandAndClearSignalsQueued() {\n+                // clearSignalsQueued must be before pendingOnNext for visibility with onNext.\n+                clearSignalsQueued();\n+                final int prevPendingOnNext = pendingOnNextUpdater.getAndSet(this, 0);\n+                if (prevPendingOnNext > 0) {\n+                    subscription.request(prevPendingOnNext);\n+                }\n+            }\n+\n+            void clearSignalsQueued() {\n+                signalsQueued = false;\n+            }\n+\n+            void markSignalsQueued() {\n+                signalsQueued = true;\n+            }\n+\n+            boolean hasSignalsQueued() {\n+                return signalsQueued;\n+            }\n+\n+            @Override\n+            public void onSubscribe(final Subscription s) {\n+                subscription.delayedSubscription(ConcurrentSubscription.wrap(s));\n+                subscription.request(parent.source.maxMappedDemand);\n+            }\n+\n+            @Override\n+            public void onNext(@Nullable final R r) {\n+                // pendingOnNext must be updated before tryEmitItem for visibility of signalsQueued. signalsQueued\n+                // is updated in replenishDemandAndClearSignalsQueued (potentially from another thread) before\n+                // pendingOnNext is reset and we want signalsQueued to be visible to this thread.\n+                //\n+                // Heuristic which triggers replenishDemandAndClearSignalsQueued when demand is consumed. It must be\n+                // when all demand is consumed in order for clearSignalsQueued to work properly.\n+                final boolean doReplenish = pendingOnNextUpdater.incrementAndGet(this) == parent.source.maxMappedDemand;\n+                parent.tryEmitItem(wrapNull(r), this);\n+                if (doReplenish) {\n+                    parent.tryEmitItem(this, this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7093c619b2f0d19dc4a3f7373d86e0f0171f624f"}, "originalPosition": 505}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzODA0MA==", "bodyText": "The approach here to account for the delta between requested and sourceRequested is different than flatMapMergeSingle(). What is the reason to take a different approach as opposed to the established approach which enables reuse of existing utilities => SubscriberUtils.calculateSourceRequested()?", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r436438040", "createdAt": "2020-06-08T03:08:46Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7093c619b2f0d19dc4a3f7373d86e0f0171f624f"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkwMDc0Ng==", "bodyText": "It seems we are only requesting more from upstream if all the previously emitted Publishers from flatMap have completed. This means that one pending work can hold up from potentially doing more work. Is this intentional?", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r443900746", "createdAt": "2020-06-23T00:48:43Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            signals = newUnboundedMpscQueue(min(2, source.maxConcurrency * source.maxMappedDemand));\n+            subscribers = newSetFromMap(new ConcurrentHashMap<>(min(16, source.maxConcurrency)));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                    FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                drainPending();\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            upstreamDemand = source.maxConcurrency;\n+            subscription.request(upstreamDemand);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            final boolean added = subscribers.add(subscriber);\n+            assert added; // FlatMapPublisherSubscriber relies upon object equality and should never fail.\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either way\n+                    // we don't want to Subscribe or retain a reference to this Publisher.\n+                    subscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            Throwable delayedCause = null;\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            pendingDemand = -1;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                for (FlatMapPublisherSubscriber<T, R> subscriber : subscribers) {\n+                    try {\n+                        subscriber.cancelFromUpstream();\n+                    } catch (Throwable cause) {\n+                        delayedCause = catchUnexpected(delayedCause, cause);\n+                    }\n+                }\n+                subscribers.clear();\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private boolean tryDecrementDemand() {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevPendingDemand, prevPendingDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevPendingDemand < 0) {\n+                        // if we have been cancelled then we avoid delivering any signals, but we still deliver error\n+                        // terminals below by making sure emittedCount == prevPendingDemand.\n+                        pendingDemand = emittedCount = prevPendingDemand;\n+                        signals.clear();\n+                    }\n+                    Object t;\n+                    while (emittedCount < prevPendingDemand && (t = signals.poll()) != null) {\n+                        try {\n+                            if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            delayedCause = catchUnexpected(delayedCause, cause);\n+                        }\n+                    }\n+\n+                    // check if a terminal event is pending, or give back demand.\n+                    if (emittedCount == prevPendingDemand) {\n+                        for (;;) {\n+                            try {\n+                                t = signals.peek();\n+                                if (t == MAPPED_SOURCE_COMPLETE) {\n+                                    signals.poll();\n+                                    tryRequestMoreFromUpstream();\n+                                } else if (t instanceof FlatMapPublisherSubscriber) {\n+                                    signals.poll();\n+                                    ((FlatMapPublisherSubscriber<?, ?>) t).replenishDemandAndClearSignalsQueued();\n+                                } else {\n+                                    break;\n+                                }\n+                            } catch (Throwable cause) {\n+                                delayedCause = catchUnexpected(delayedCause, cause);\n+                            }\n+                        }\n+\n+                        if (t instanceof TerminalNotification) {\n+                            sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                        } else {\n+                            t = terminalNotification;\n+                            if (t != null && t != complete()) { // don't wait for demand to process an error\n+                                sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                            }\n+                        }\n+                    } else {\n+                        assert emittedCount < prevPendingDemand;\n+                        pendingDemandUpdater.accumulateAndGet(this, prevPendingDemand - emittedCount,\n+                                FlowControlUtils::addWithOverflowProtection);\n+                    }\n+                } finally {\n+                    tryAcquire = !releaseLock(emittingLockUpdater, this);\n+                }\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void tryRequestMoreFromUpstream() {\n+            if (--upstreamDemand == 0) { // heuristic to replenish demand when it is exhausted.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9996ed4b5a3cd8db65bfe1d2c33d042fd0461a7d"}, "originalPosition": 362}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MDgxNjk5", "url": "https://github.com/apple/servicetalk/pull/1011#pullrequestreview-436081699", "createdAt": "2020-06-23T19:16:32Z", "commit": {"oid": "9996ed4b5a3cd8db65bfe1d2c33d042fd0461a7d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxOToxNjozMlrOGn3HxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxOToxNjozMlrOGn3HxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ1MDc1Ng==", "bodyText": "This approach of child Publishers requesting maxMappedDemand irrespective of downstream demand will tend to have larger buffers irrespective of how items are requested.\nAn alternative approach could be to take a minMappedDemand and then split the downstream demand across maxConcurrency number of sources.\n\nFor maxConcurrency == 8 and downstream demand 16; we request 2 from each child Publisher.\nEach time a child Publisher emits as much as requested we split the remaining demand again in maxConcurrency. If maxConcurrency > downstream demand then request minMappedDemand.\n\nThis approach should result in smaller queues since we request depending on actual downstream demand as opposed to static maxMappedDemand. Additionally, we can default to lower defaults; maxConcurrency: 8 and minMappedDemand: 1. The negative is that if we do not have as many items as maxConcurrency we end up requesting in smaller chunks.\nWDYT?", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r444450756", "createdAt": "2020-06-23T19:16:32Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,547 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.min;\n+import static java.util.Collections.newSetFromMap;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int maxMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 16, 64, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int maxMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (maxMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"maxMappedDemand: \" + maxMappedDemand + \" (expected >0)\");\n+        }\n+        this.maxMappedDemand = maxMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        private int upstreamDemand;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final Set<FlatMapPublisherSubscriber<T, R>> subscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            // Start with a small capacity as maxConcurrency can be large.\n+            signals = newUnboundedMpscQueue(min(2, source.maxConcurrency * source.maxMappedDemand));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9996ed4b5a3cd8db65bfe1d2c33d042fd0461a7d"}, "originalPosition": 128}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "18568eaa6237544efe0df0ecf7902cb9c19d3e4d", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/18568eaa6237544efe0df0ecf7902cb9c19d3e4d", "committedDate": "2020-07-07T22:03:49Z", "message": "review comments"}, "afterCommit": {"oid": "22d13254273fbefa315134f571f9397f0d29bbd9", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/22d13254273fbefa315134f571f9397f0d29bbd9", "committedDate": "2020-07-09T05:32:04Z", "message": "first cut, adjust mapped demand to account for downstream demand"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "22d13254273fbefa315134f571f9397f0d29bbd9", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/22d13254273fbefa315134f571f9397f0d29bbd9", "committedDate": "2020-07-09T05:32:04Z", "message": "first cut, adjust mapped demand to account for downstream demand"}, "afterCommit": {"oid": "899fd50f31612ccaede56a21176897600a3c0dfb", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/899fd50f31612ccaede56a21176897600a3c0dfb", "committedDate": "2020-07-09T05:56:27Z", "message": "first cut, adjust mapped demand to account for downstream demand"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "899fd50f31612ccaede56a21176897600a3c0dfb", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/899fd50f31612ccaede56a21176897600a3c0dfb", "committedDate": "2020-07-09T05:56:27Z", "message": "first cut, adjust mapped demand to account for downstream demand"}, "afterCommit": {"oid": "d093ba0ab90f1f68b8283cae0bf7b481f84cd338", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/d093ba0ab90f1f68b8283cae0bf7b481f84cd338", "committedDate": "2020-07-09T06:13:01Z", "message": "first cut, adjust mapped demand to account for downstream demand"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d093ba0ab90f1f68b8283cae0bf7b481f84cd338", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/d093ba0ab90f1f68b8283cae0bf7b481f84cd338", "committedDate": "2020-07-09T06:13:01Z", "message": "first cut, adjust mapped demand to account for downstream demand"}, "afterCommit": {"oid": "5c7a1b18a399929747b22e7c2d8ea16740b227d1", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/5c7a1b18a399929747b22e7c2d8ea16740b227d1", "committedDate": "2020-07-09T15:44:57Z", "message": "first cut, adjust mapped demand to account for downstream demand"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5c7a1b18a399929747b22e7c2d8ea16740b227d1", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/5c7a1b18a399929747b22e7c2d8ea16740b227d1", "committedDate": "2020-07-09T15:44:57Z", "message": "first cut, adjust mapped demand to account for downstream demand"}, "afterCommit": {"oid": "0fa00306b986d647b69e9ead71e915494ea62db2", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/0fa00306b986d647b69e9ead71e915494ea62db2", "committedDate": "2020-07-11T14:11:41Z", "message": "first cut, adjust mapped demand to account for downstream demand"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0fa00306b986d647b69e9ead71e915494ea62db2", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/0fa00306b986d647b69e9ead71e915494ea62db2", "committedDate": "2020-07-11T14:11:41Z", "message": "first cut, adjust mapped demand to account for downstream demand"}, "afterCommit": {"oid": "75967e13b40d74222d713365f3b7a28068ce30b6", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/75967e13b40d74222d713365f3b7a28068ce30b6", "committedDate": "2020-07-29T00:25:48Z", "message": "first cut, adjust mapped demand to account for downstream demand"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "75967e13b40d74222d713365f3b7a28068ce30b6", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/75967e13b40d74222d713365f3b7a28068ce30b6", "committedDate": "2020-07-29T00:25:48Z", "message": "first cut, adjust mapped demand to account for downstream demand"}, "afterCommit": {"oid": "5bf903babe582ed3a0eba43fe2b5ccf19653a19c", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/5bf903babe582ed3a0eba43fe2b5ccf19653a19c", "committedDate": "2020-07-29T00:30:17Z", "message": "first cut, adjust mapped demand to account for downstream demand"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MzIwMzI4", "url": "https://github.com/apple/servicetalk/pull/1011#pullrequestreview-455320328", "createdAt": "2020-07-25T22:59:05Z", "commit": {"oid": "0fa00306b986d647b69e9ead71e915494ea62db2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQyMjo1OTowNVrOG3H7uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wMlQyMDo1Mjo1N1rOG6nxvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ1NDg0MQ==", "bodyText": "The signalsQueued flag here is to essentially cache the state that there is not enough pendingDemand to emit, rite?\nThis will be effective for cases when demand < maxConcurrency. Seems pretty premature (1 volatile read/cas vs extra state management) for a specific case or am I missing something?", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r460454841", "createdAt": "2020-07-25T22:59:05Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,661 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     to manage the {@link FlatMapSubscriber#hungrySubscribers} queue (e.g. network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * {@link FlatMapSubscriber#hungrySubscribers queue} management.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int minMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int minMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (minMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"minMappedDemand: \" + minMappedDemand + \" (expected >0)\");\n+        }\n+        this.minMappedDemand = minMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> requestingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"requestingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int requestingLock;\n+        private volatile long pendingDemand;\n+        private volatile long mappedDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final DynamicCompositeCancellable cancellableSubscribers;\n+        private final Queue<FlatMapPublisherSubscriber<T, R>> hungrySubscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            signals = newUnboundedMpscQueue(4);\n+            hungrySubscribers = newUnboundedMpscQueue(4);\n+            cancellableSubscribers = new SetDynamicCompositeCancellable(min(16, source.maxConcurrency));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                // If we transitioned from no demand, to some demand, then we should try to drain the queues which\n+                // may have signals pending due to previous over-request.\n+                if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                    drainPending();\n+                }\n+                if (mappedDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtection) == 0) {\n+                    distributeMappedDemand();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (!cancellableSubscribers.add(subscriber)) {\n+                return;\n+            }\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either\n+                    // way we don't want to Subscribe or retain a reference to this Publisher.\n+                    cancellableSubscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private long reserveMappedDemand() {\n+            return mappedDemandUpdater.getAndSet(this, 0);\n+        }\n+\n+        private int reserveMappedDemandQuota() {\n+            for (;;) {\n+                final long prevDemand = mappedDemand;\n+                if (prevDemand <= 0) {\n+                    return 0;\n+                }\n+                final int quota = calculateRequestNQuota(prevDemand);\n+                if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - quota)) {\n+                    return quota;\n+                }\n+            }\n+        }\n+\n+        private void distributeMappedDemand(FlatMapPublisherSubscriber<T, R> hungrySubscriber) {\n+            final int quota = reserveMappedDemandQuota();\n+            if (quota > 0) {\n+                final int usedQuota = hungrySubscriber.request(quota);\n+                if (usedQuota < quota && mappedDemandUpdater.getAndAccumulate(this, quota - usedQuota,\n+                        FlowControlUtils::addWithOverflowProtection) == 0) {\n+                    // If we gave some back and transitioned from 0 demand, we need to try to distribute demand\n+                    // in case other hungry subscribers were added in the mean time\n+                    // (since we have not acquired the requestingLock).\n+                    distributeMappedDemand();\n+                }\n+            } else { // slow path. no demand, add to queue and process later when demand arrives.\n+                hungrySubscribers.add(hungrySubscriber);\n+                distributeMappedDemand();\n+            }\n+        }\n+\n+        private void distributeMappedDemand() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            while (tryAcquire && tryAcquireLock(requestingLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = reserveMappedDemand();\n+                    if (availableRequestN > 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        final int quota = calculateRequestNQuota(availableRequestN);\n+                        FlatMapPublisherSubscriber<T, R> hungrySubscriber;\n+                        while ((hungrySubscriber = hungrySubscribers.poll()) != null) {\n+                            remainingRequestN -= hungrySubscriber.request(quota);\n+                        }\n+                        if (remainingRequestN > 0) {\n+                            mappedDemandUpdater.accumulateAndGet(this, remainingRequestN,\n+                                    FlowControlUtils::addWithOverflowProtection);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    delayedCause = catchUnexpected(delayedCause, cause);\n+                } finally {\n+                    tryAcquire = !releaseLock(requestingLockUpdater, this);\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private int calculateRequestNQuota(long availableRequestN) {\n+            // Get an approximate quota to distribute to each active mapped subscriber. If\n+            // activeMappedSources changes (subscriber added or terminated) we will re-distribute.\n+            final int prevActiveSources = activeMappedSources;\n+            return (int) min(Integer.MAX_VALUE,\n+                    max(prevActiveSources > 0 ? availableRequestN / prevActiveSources : availableRequestN,\n+                            source.minMappedDemand));\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            pendingDemand = -1;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                cancellableSubscribers.cancel();\n+                // Don't bother clearing out hungrySubscribers or signals (which require additional concurrency control)\n+                // because it is assumed this Subscriber will be dereferenced and eligible for GC [1].\n+                // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.13\n+            }\n+        }\n+\n+        private boolean tryDecrementPendingDemand() {\n+            for (;;) {\n+                final long prevDemand = pendingDemand;\n+                if (prevDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevDemand, prevDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementPendingDemand())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fa00306b986d647b69e9ead71e915494ea62db2"}, "originalPosition": 355}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ1NTc0OQ==", "bodyText": "but we still deliver error\n\ndo we need to?", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r460455749", "createdAt": "2020-07-25T23:12:13Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,661 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     to manage the {@link FlatMapSubscriber#hungrySubscribers} queue (e.g. network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * {@link FlatMapSubscriber#hungrySubscribers queue} management.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int minMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int minMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (minMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"minMappedDemand: \" + minMappedDemand + \" (expected >0)\");\n+        }\n+        this.minMappedDemand = minMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> requestingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"requestingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int requestingLock;\n+        private volatile long pendingDemand;\n+        private volatile long mappedDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final DynamicCompositeCancellable cancellableSubscribers;\n+        private final Queue<FlatMapPublisherSubscriber<T, R>> hungrySubscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            signals = newUnboundedMpscQueue(4);\n+            hungrySubscribers = newUnboundedMpscQueue(4);\n+            cancellableSubscribers = new SetDynamicCompositeCancellable(min(16, source.maxConcurrency));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                // If we transitioned from no demand, to some demand, then we should try to drain the queues which\n+                // may have signals pending due to previous over-request.\n+                if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                    drainPending();\n+                }\n+                if (mappedDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtection) == 0) {\n+                    distributeMappedDemand();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (!cancellableSubscribers.add(subscriber)) {\n+                return;\n+            }\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either\n+                    // way we don't want to Subscribe or retain a reference to this Publisher.\n+                    cancellableSubscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private long reserveMappedDemand() {\n+            return mappedDemandUpdater.getAndSet(this, 0);\n+        }\n+\n+        private int reserveMappedDemandQuota() {\n+            for (;;) {\n+                final long prevDemand = mappedDemand;\n+                if (prevDemand <= 0) {\n+                    return 0;\n+                }\n+                final int quota = calculateRequestNQuota(prevDemand);\n+                if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - quota)) {\n+                    return quota;\n+                }\n+            }\n+        }\n+\n+        private void distributeMappedDemand(FlatMapPublisherSubscriber<T, R> hungrySubscriber) {\n+            final int quota = reserveMappedDemandQuota();\n+            if (quota > 0) {\n+                final int usedQuota = hungrySubscriber.request(quota);\n+                if (usedQuota < quota && mappedDemandUpdater.getAndAccumulate(this, quota - usedQuota,\n+                        FlowControlUtils::addWithOverflowProtection) == 0) {\n+                    // If we gave some back and transitioned from 0 demand, we need to try to distribute demand\n+                    // in case other hungry subscribers were added in the mean time\n+                    // (since we have not acquired the requestingLock).\n+                    distributeMappedDemand();\n+                }\n+            } else { // slow path. no demand, add to queue and process later when demand arrives.\n+                hungrySubscribers.add(hungrySubscriber);\n+                distributeMappedDemand();\n+            }\n+        }\n+\n+        private void distributeMappedDemand() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            while (tryAcquire && tryAcquireLock(requestingLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = reserveMappedDemand();\n+                    if (availableRequestN > 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        final int quota = calculateRequestNQuota(availableRequestN);\n+                        FlatMapPublisherSubscriber<T, R> hungrySubscriber;\n+                        while ((hungrySubscriber = hungrySubscribers.poll()) != null) {\n+                            remainingRequestN -= hungrySubscriber.request(quota);\n+                        }\n+                        if (remainingRequestN > 0) {\n+                            mappedDemandUpdater.accumulateAndGet(this, remainingRequestN,\n+                                    FlowControlUtils::addWithOverflowProtection);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    delayedCause = catchUnexpected(delayedCause, cause);\n+                } finally {\n+                    tryAcquire = !releaseLock(requestingLockUpdater, this);\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private int calculateRequestNQuota(long availableRequestN) {\n+            // Get an approximate quota to distribute to each active mapped subscriber. If\n+            // activeMappedSources changes (subscriber added or terminated) we will re-distribute.\n+            final int prevActiveSources = activeMappedSources;\n+            return (int) min(Integer.MAX_VALUE,\n+                    max(prevActiveSources > 0 ? availableRequestN / prevActiveSources : availableRequestN,\n+                            source.minMappedDemand));\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            pendingDemand = -1;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                cancellableSubscribers.cancel();\n+                // Don't bother clearing out hungrySubscribers or signals (which require additional concurrency control)\n+                // because it is assumed this Subscriber will be dereferenced and eligible for GC [1].\n+                // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.13\n+            }\n+        }\n+\n+        private boolean tryDecrementPendingDemand() {\n+            for (;;) {\n+                final long prevDemand = pendingDemand;\n+                if (prevDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevDemand, prevDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementPendingDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else if (item == MAPPED_SOURCE_COMPLETE) {\n+                        requestMoreFromUpstream(1);\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            int mappedSourcesCompleted = 0;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevDemand < 0) {\n+                        // if we have been cancelled then we avoid delivering any signals, but we still deliver error", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fa00306b986d647b69e9ead71e915494ea62db2"}, "originalPosition": 405}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEyMjE0NA==", "bodyText": "My suggestion was to be fair by distributing the availableRequestN into maxConcurrency. This approach is partial towards early Publishers as it is distributing demand into active sources. The effect is magnified for the below pathological case:\nCountDownLatch latch = new CountDownLatch(1);\nSourceAdapters.toSource(Publisher.range(1, 100)\n        .flatMapMerge(integer -> {\n            System.out.println(\"Emitting next publisher for integer: \" + integer);\n            return Publisher.<Integer>never().beforeRequest(n -> System.out.println(\"Item: \" + integer + \", requested => \" + n));\n        }, 5, 1))\n        .subscribe(new PublisherSource.Subscriber<Integer>() {\n            @Override\n            public void onSubscribe(final PublisherSource.Subscription subscription) {\n                subscription.request(10);\n            }\n\n            @Override\n            public void onNext(@Nullable final Integer integer) {\n                System.out.println(\"Next => \" + integer);\n            }\n\n            @Override\n            public void onError(final Throwable t) {\n                latch.countDown();\n            }\n\n            @Override\n            public void onComplete() {\n                latch.countDown();\n            }\n        });\nlatch.await();\nThe above results in only requesting from the first source. Perhaps an easy fix is to always request 1 but it is still unfair. Are there any reservations to distribute based on maxConcurrency as opposed to active sources?", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r464122144", "createdAt": "2020-08-02T20:51:02Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,661 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     to manage the {@link FlatMapSubscriber#hungrySubscribers} queue (e.g. network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * {@link FlatMapSubscriber#hungrySubscribers queue} management.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int minMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int minMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (minMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"minMappedDemand: \" + minMappedDemand + \" (expected >0)\");\n+        }\n+        this.minMappedDemand = minMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> requestingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"requestingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int requestingLock;\n+        private volatile long pendingDemand;\n+        private volatile long mappedDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final DynamicCompositeCancellable cancellableSubscribers;\n+        private final Queue<FlatMapPublisherSubscriber<T, R>> hungrySubscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            signals = newUnboundedMpscQueue(4);\n+            hungrySubscribers = newUnboundedMpscQueue(4);\n+            cancellableSubscribers = new SetDynamicCompositeCancellable(min(16, source.maxConcurrency));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                // If we transitioned from no demand, to some demand, then we should try to drain the queues which\n+                // may have signals pending due to previous over-request.\n+                if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                    drainPending();\n+                }\n+                if (mappedDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtection) == 0) {\n+                    distributeMappedDemand();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (!cancellableSubscribers.add(subscriber)) {\n+                return;\n+            }\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either\n+                    // way we don't want to Subscribe or retain a reference to this Publisher.\n+                    cancellableSubscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private long reserveMappedDemand() {\n+            return mappedDemandUpdater.getAndSet(this, 0);\n+        }\n+\n+        private int reserveMappedDemandQuota() {\n+            for (;;) {\n+                final long prevDemand = mappedDemand;\n+                if (prevDemand <= 0) {\n+                    return 0;\n+                }\n+                final int quota = calculateRequestNQuota(prevDemand);\n+                if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - quota)) {\n+                    return quota;\n+                }\n+            }\n+        }\n+\n+        private void distributeMappedDemand(FlatMapPublisherSubscriber<T, R> hungrySubscriber) {\n+            final int quota = reserveMappedDemandQuota();\n+            if (quota > 0) {\n+                final int usedQuota = hungrySubscriber.request(quota);\n+                if (usedQuota < quota && mappedDemandUpdater.getAndAccumulate(this, quota - usedQuota,\n+                        FlowControlUtils::addWithOverflowProtection) == 0) {\n+                    // If we gave some back and transitioned from 0 demand, we need to try to distribute demand\n+                    // in case other hungry subscribers were added in the mean time\n+                    // (since we have not acquired the requestingLock).\n+                    distributeMappedDemand();\n+                }\n+            } else { // slow path. no demand, add to queue and process later when demand arrives.\n+                hungrySubscribers.add(hungrySubscriber);\n+                distributeMappedDemand();\n+            }\n+        }\n+\n+        private void distributeMappedDemand() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            while (tryAcquire && tryAcquireLock(requestingLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = reserveMappedDemand();\n+                    if (availableRequestN > 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        final int quota = calculateRequestNQuota(availableRequestN);\n+                        FlatMapPublisherSubscriber<T, R> hungrySubscriber;\n+                        while ((hungrySubscriber = hungrySubscribers.poll()) != null) {\n+                            remainingRequestN -= hungrySubscriber.request(quota);\n+                        }\n+                        if (remainingRequestN > 0) {\n+                            mappedDemandUpdater.accumulateAndGet(this, remainingRequestN,\n+                                    FlowControlUtils::addWithOverflowProtection);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    delayedCause = catchUnexpected(delayedCause, cause);\n+                } finally {\n+                    tryAcquire = !releaseLock(requestingLockUpdater, this);\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private int calculateRequestNQuota(long availableRequestN) {\n+            // Get an approximate quota to distribute to each active mapped subscriber. If\n+            // activeMappedSources changes (subscriber added or terminated) we will re-distribute.\n+            final int prevActiveSources = activeMappedSources;\n+            return (int) min(Integer.MAX_VALUE,\n+                    max(prevActiveSources > 0 ? availableRequestN / prevActiveSources : availableRequestN,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bf903babe582ed3a0eba43fe2b5ccf19653a19c"}, "originalPosition": 317}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEyMjMwMQ==", "bodyText": "The subscription is a ConcurrentSubscription which means we can concurrently request more items. Can we go to a simpler model of not going through the queue to request more items from upstream and instead just request(1) every time a source completes?", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r464122301", "createdAt": "2020-08-02T20:52:57Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,661 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     to manage the {@link FlatMapSubscriber#hungrySubscribers} queue (e.g. network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * {@link FlatMapSubscriber#hungrySubscribers queue} management.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int minMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int minMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (minMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"minMappedDemand: \" + minMappedDemand + \" (expected >0)\");\n+        }\n+        this.minMappedDemand = minMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> requestingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"requestingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int requestingLock;\n+        private volatile long pendingDemand;\n+        private volatile long mappedDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final DynamicCompositeCancellable cancellableSubscribers;\n+        private final Queue<FlatMapPublisherSubscriber<T, R>> hungrySubscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            signals = newUnboundedMpscQueue(4);\n+            hungrySubscribers = newUnboundedMpscQueue(4);\n+            cancellableSubscribers = new SetDynamicCompositeCancellable(min(16, source.maxConcurrency));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                // If we transitioned from no demand, to some demand, then we should try to drain the queues which\n+                // may have signals pending due to previous over-request.\n+                if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                    drainPending();\n+                }\n+                if (mappedDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtection) == 0) {\n+                    distributeMappedDemand();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (!cancellableSubscribers.add(subscriber)) {\n+                return;\n+            }\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either\n+                    // way we don't want to Subscribe or retain a reference to this Publisher.\n+                    cancellableSubscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private long reserveMappedDemand() {\n+            return mappedDemandUpdater.getAndSet(this, 0);\n+        }\n+\n+        private int reserveMappedDemandQuota() {\n+            for (;;) {\n+                final long prevDemand = mappedDemand;\n+                if (prevDemand <= 0) {\n+                    return 0;\n+                }\n+                final int quota = calculateRequestNQuota(prevDemand);\n+                if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - quota)) {\n+                    return quota;\n+                }\n+            }\n+        }\n+\n+        private void distributeMappedDemand(FlatMapPublisherSubscriber<T, R> hungrySubscriber) {\n+            final int quota = reserveMappedDemandQuota();\n+            if (quota > 0) {\n+                final int usedQuota = hungrySubscriber.request(quota);\n+                if (usedQuota < quota && mappedDemandUpdater.getAndAccumulate(this, quota - usedQuota,\n+                        FlowControlUtils::addWithOverflowProtection) == 0) {\n+                    // If we gave some back and transitioned from 0 demand, we need to try to distribute demand\n+                    // in case other hungry subscribers were added in the mean time\n+                    // (since we have not acquired the requestingLock).\n+                    distributeMappedDemand();\n+                }\n+            } else { // slow path. no demand, add to queue and process later when demand arrives.\n+                hungrySubscribers.add(hungrySubscriber);\n+                distributeMappedDemand();\n+            }\n+        }\n+\n+        private void distributeMappedDemand() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            while (tryAcquire && tryAcquireLock(requestingLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = reserveMappedDemand();\n+                    if (availableRequestN > 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        final int quota = calculateRequestNQuota(availableRequestN);\n+                        FlatMapPublisherSubscriber<T, R> hungrySubscriber;\n+                        while ((hungrySubscriber = hungrySubscribers.poll()) != null) {\n+                            remainingRequestN -= hungrySubscriber.request(quota);\n+                        }\n+                        if (remainingRequestN > 0) {\n+                            mappedDemandUpdater.accumulateAndGet(this, remainingRequestN,\n+                                    FlowControlUtils::addWithOverflowProtection);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    delayedCause = catchUnexpected(delayedCause, cause);\n+                } finally {\n+                    tryAcquire = !releaseLock(requestingLockUpdater, this);\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private int calculateRequestNQuota(long availableRequestN) {\n+            // Get an approximate quota to distribute to each active mapped subscriber. If\n+            // activeMappedSources changes (subscriber added or terminated) we will re-distribute.\n+            final int prevActiveSources = activeMappedSources;\n+            return (int) min(Integer.MAX_VALUE,\n+                    max(prevActiveSources > 0 ? availableRequestN / prevActiveSources : availableRequestN,\n+                            source.minMappedDemand));\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            pendingDemand = -1;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                cancellableSubscribers.cancel();\n+                // Don't bother clearing out hungrySubscribers or signals (which require additional concurrency control)\n+                // because it is assumed this Subscriber will be dereferenced and eligible for GC [1].\n+                // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.13\n+            }\n+        }\n+\n+        private boolean tryDecrementPendingDemand() {\n+            for (;;) {\n+                final long prevDemand = pendingDemand;\n+                if (prevDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevDemand, prevDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementPendingDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else if (item == MAPPED_SOURCE_COMPLETE) {\n+                        requestMoreFromUpstream(1);\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, true, true);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            int mappedSourcesCompleted = 0;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevDemand < 0) {\n+                        // if we have been cancelled then we avoid delivering any signals, but we still deliver error\n+                        // terminals below by making sure emittedCount == prevDemand.\n+                        pendingDemand = emittedCount = prevDemand;\n+                        signals.clear();\n+                    }\n+                    Object t;\n+                    while (emittedCount < prevDemand && (t = signals.poll()) != null) {\n+                        try {\n+                            if (t == MAPPED_SOURCE_COMPLETE) {\n+                                ++mappedSourcesCompleted;\n+                            } else if (sendToTarget(t)) {\n+                                ++emittedCount;\n+                            }\n+                        } catch (Throwable cause) {\n+                            delayedCause = catchUnexpected(delayedCause, cause);\n+                        }\n+                    }\n+\n+                    // check if a terminal event is pending, or give back demand.\n+                    if (emittedCount == prevDemand) {\n+                        for (;;) {\n+                            try {\n+                                t = signals.peek();\n+                                if (t == MAPPED_SOURCE_COMPLETE) {\n+                                    signals.poll();\n+                                    ++mappedSourcesCompleted;\n+                                } else if (t instanceof FlatMapPublisherSubscriber) {\n+                                    signals.poll();\n+                                    @SuppressWarnings(\"unchecked\")\n+                                    final FlatMapPublisherSubscriber<T, R> hungrySubscriber =\n+                                            (FlatMapPublisherSubscriber<T, R>) t;\n+                                    distributeMappedDemand(hungrySubscriber);\n+                                } else {\n+                                    break;\n+                                }\n+                            } catch (Throwable cause) {\n+                                delayedCause = catchUnexpected(delayedCause, cause);\n+                            }\n+                        }\n+\n+                        if (t instanceof TerminalNotification) {\n+                            sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                        } else {\n+                            t = terminalNotification;\n+                            if (t != null && t != complete()) { // don't wait for demand to process an error\n+                                sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                            }\n+                        }\n+                    } else {\n+                        assert emittedCount < prevDemand;\n+                        pendingDemandUpdater.accumulateAndGet(this, prevDemand - emittedCount,\n+                                FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+                    }\n+                } finally {\n+                    tryAcquire = !releaseLock(emittingLockUpdater, this);\n+                }\n+            }\n+\n+            if (mappedSourcesCompleted != 0) {\n+                requestMoreFromUpstream(mappedSourcesCompleted);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bf903babe582ed3a0eba43fe2b5ccf19653a19c"}, "originalPosition": 464}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2917bd67cb508f04711c60c2d859adbfd0a026fd", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/2917bd67cb508f04711c60c2d859adbfd0a026fd", "committedDate": "2020-08-05T21:18:08Z", "message": "correct javadocs for FLowControlUtils method"}, "afterCommit": {"oid": "bc190ba77b5383b92ac7567c2bb0083834d93c2b", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/bc190ba77b5383b92ac7567c2bb0083834d93c2b", "committedDate": "2020-08-05T22:56:48Z", "message": "correct javadocs for FLowControlUtils method"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bc190ba77b5383b92ac7567c2bb0083834d93c2b", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/bc190ba77b5383b92ac7567c2bb0083834d93c2b", "committedDate": "2020-08-05T22:56:48Z", "message": "correct javadocs for FLowControlUtils method"}, "afterCommit": {"oid": "dbd705d1b7ef776dc0d9b08bc4d2dca163020ff0", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/dbd705d1b7ef776dc0d9b08bc4d2dca163020ff0", "committedDate": "2020-09-15T20:55:26Z", "message": "remove hungrySubscriber queue, make sure we always give demand to mapped sources optimistically to avoid deadlock"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MTQ0Mjc5", "url": "https://github.com/apple/servicetalk/pull/1011#pullrequestreview-478144279", "createdAt": "2020-08-29T17:47:53Z", "commit": {"oid": "bc190ba77b5383b92ac7567c2bb0083834d93c2b"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQxNzo0Nzo1M1rOHJc7bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwMToxMzo0NVrOHXxqSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTY3MzE5OQ==", "bodyText": "Looks like these suppressions aren't required anymore.", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r479673199", "createdAt": "2020-08-29T17:47:53Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,688 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     to manage the {@link FlatMapSubscriber#hungrySubscribers} queue (e.g. network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * {@link FlatMapSubscriber#hungrySubscribers queue} management.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int minMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int minMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (minMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"minMappedDemand: \" + minMappedDemand + \" (expected >0)\");\n+        }\n+        this.minMappedDemand = minMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> requestingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"requestingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc190ba77b5383b92ac7567c2bb0083834d93c2b"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ4Mjc3Mw==", "bodyText": "The return type is effectively used as  boolean as we do not consume partial n. Can we change this to a boolean?", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r491482773", "createdAt": "2020-09-19T18:54:01Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     for managing demand through the {@link FlatMapSubscriber#signals} queue (network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * managing demand through the {@link FlatMapSubscriber#signals} queue.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private static final int MIN_MAPPED_DEMAND = 1;\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+        private volatile long mappedDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final DynamicCompositeCancellable cancellableSubscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            signals = newUnboundedMpscQueue(4);\n+            cancellableSubscribers = new SetDynamicCompositeCancellable(min(16, source.maxConcurrency));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true, true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                // If we transitioned from no demand, to some demand, then we should try to drain the queues which\n+                // may have signals pending due to previous over-request.\n+                if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                    drainPending();\n+                }\n+                incMappedDemand(n);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (!cancellableSubscribers.add(subscriber)) {\n+                return;\n+            }\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either\n+                    // way we don't want to Subscribe or retain a reference to this Publisher.\n+                    cancellableSubscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, true)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean fromUpstream) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, !fromUpstream, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(!fromUpstream, true);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void incMappedDemand(long n) {\n+            assert n > 0;\n+            mappedDemandUpdater.getAndAccumulate(this, n, FlowControlUtils::addWithUnderOverflowProtection);\n+        }\n+\n+        private int reserveMappedDemandQuota() {\n+            for (;;) {\n+                final long prevDemand = mappedDemand;\n+                if (prevDemand <= 0) {\n+                    // mappedDemand is allowed to go negative here in order to distribute MIN_MAPPED_DEMAND demand to\n+                    // each source. This is to avoid a single mapped source (or set of sources) not making any progress\n+                    // with the demand they were given, taking demand away from sources that could make progress. The\n+                    // negative value ensures that if a source completes with unused demand it doesn't result in\n+                    // artificially giving back \"negative\" demand and keeps the maximum queue size should be bound\n+                    // to (maxConcurrency * minMappedDemand).\n+                    if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - MIN_MAPPED_DEMAND)) {\n+                        return MIN_MAPPED_DEMAND;\n+                    }\n+                } else {\n+                    final int quota = calculateRequestNQuota(prevDemand);\n+                    if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - quota)) {\n+                        return quota;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void distributeMappedDemand(FlatMapPublisherSubscriber<T, R> hungrySubscriber) {\n+            final int quota = reserveMappedDemandQuota();\n+            final int usedQuota = hungrySubscriber.request(quota);\n+            if (usedQuota < quota) {\n+                incMappedDemand(quota - usedQuota);\n+            }\n+        }\n+\n+        private int calculateRequestNQuota(long availableRequestN) {\n+            // Get an approximate quota to distribute to each active mapped subscriber.\n+            return (int) min(Integer.MAX_VALUE, max(availableRequestN / source.maxConcurrency, MIN_MAPPED_DEMAND));\n+        }\n+\n+        private void doCancel(boolean cancelSubscription, boolean invalidatePendingDemand) {\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            if (invalidatePendingDemand) {\n+                pendingDemand = -1;\n+            }\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                cancellableSubscribers.cancel();\n+                // Don't bother clearing out signals (which require additional concurrency control) because it is\n+                // assumed this Subscriber will be dereferenced and eligible for GC [1].\n+                // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.13\n+            }\n+        }\n+\n+        private boolean tryDecrementPendingDemand() {\n+            for (;;) {\n+                final long prevDemand = pendingDemand;\n+                if (prevDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevDemand, prevDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                boolean mappedSourcesCompleted = false;\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementPendingDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else if (item == MAPPED_SOURCE_COMPLETE) {\n+                        mappedSourcesCompleted = true;\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+                if (mappedSourcesCompleted) { // request more from upstream outside the critical section.\n+                    requestMoreFromUpstream(1);\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, false);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            int mappedSourcesCompleted = 0;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevDemand < 0) {\n+                        pendingDemand = prevDemand;\n+                        // Don't wait for demand to deliver the terminalNotification if present. The queued signals\n+                        // maybe from optimistic demand, but the error is from an event that needs immediate propagation\n+                        // (e.g. illegal requestN, failure to enqueue).\n+                        TerminalNotification t = terminalNotification;\n+                        if (t != null && t != complete()) {\n+                            sendToTarget(t); // if this throws its OK as we have terminated\n+                        }\n+                    } else {\n+                        Object t;\n+                        while (emittedCount < prevDemand && (t = signals.poll()) != null) {\n+                            try {\n+                                if (t == MAPPED_SOURCE_COMPLETE) {\n+                                    ++mappedSourcesCompleted;\n+                                } else if (sendToTarget(t)) {\n+                                    ++emittedCount;\n+                                }\n+                            } catch (Throwable cause) {\n+                                delayedCause = catchUnexpected(delayedCause, cause);\n+                            }\n+                        }\n+\n+                        // check if a terminal event is pending, or give back demand.\n+                        if (emittedCount == prevDemand) {\n+                            for (;;) {\n+                                try {\n+                                    t = signals.peek();\n+                                    if (t == MAPPED_SOURCE_COMPLETE) {\n+                                        signals.poll();\n+                                        ++mappedSourcesCompleted;\n+                                    } else if (t instanceof FlatMapPublisherSubscriber) {\n+                                        signals.poll();\n+                                        @SuppressWarnings(\"unchecked\")\n+                                        final FlatMapPublisherSubscriber<T, R> hungrySubscriber =\n+                                                (FlatMapPublisherSubscriber<T, R>) t;\n+                                        distributeMappedDemand(hungrySubscriber);\n+                                    } else {\n+                                        break;\n+                                    }\n+                                } catch (Throwable cause) {\n+                                    delayedCause = catchUnexpected(delayedCause, cause);\n+                                }\n+                            }\n+\n+                            if (t instanceof TerminalNotification) {\n+                                sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                            }\n+                        } else {\n+                            assert emittedCount < prevDemand;\n+                            pendingDemandUpdater.accumulateAndGet(this, prevDemand - emittedCount,\n+                                    FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+                        }\n+                    }\n+                } finally {\n+                    tryAcquire = !releaseLock(emittingLockUpdater, this);\n+                }\n+            }\n+\n+            if (mappedSourcesCompleted != 0) {\n+                requestMoreFromUpstream(mappedSourcesCompleted);\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void requestMoreFromUpstream(int mappedSourcesCompleted) {\n+            assert mappedSourcesCompleted > 0;\n+            assert subscription != null;\n+            subscription.request(mappedSourcesCompleted);\n+        }\n+\n+        private static boolean needsDemand(Object item) {\n+            return item != MAPPED_SOURCE_COMPLETE &&\n+                    !(item instanceof FlatMapPublisherSubscriber) && !(item instanceof TerminalNotification);\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            assert item != MAPPED_SOURCE_COMPLETE;\n+            if (targetTerminated) {\n+                return false;\n+            } else if (item instanceof TerminalNotification) {\n+                TerminalNotification terminalNotification;\n+                if (item == complete() && (terminalNotification = this.terminalNotification) != null) {\n+                    // Load the terminal notification in case an error happened after an onComplete and we override the\n+                    // terminal value.\n+                    sendToTarget(terminalNotification);\n+                } else {\n+                    sendToTarget((TerminalNotification) item);\n+                }\n+                return false;\n+            } else if (item instanceof FlatMapPublisherSubscriber) {\n+                @SuppressWarnings(\"unchecked\")\n+                final FlatMapPublisherSubscriber<T, R> hungrySubscriber = (FlatMapPublisherSubscriber<T, R>) item;\n+                distributeMappedDemand(hungrySubscriber);\n+                return false;\n+            }\n+            target.onNext(unwrapNullUnchecked(item));\n+            return true;\n+        }\n+\n+        private void sendToTarget(TerminalNotification terminalNotification) {\n+            signals.clear();\n+            targetTerminated = true;\n+            CompositeException de = this.delayedError;\n+            if (de != null) {\n+                de.transferPendingToSuppressed();\n+                if (terminalNotification.cause() == de) {\n+                    terminalNotification.terminate(target);\n+                } else {\n+                    terminalNotification.terminate(target, de);\n+                }\n+            } else {\n+                terminalNotification.terminate(target);\n+            }\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                assert prevActiveSources >= 0; // otherwise we have seen multiple onComplete signals\n+                if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, -prevActiveSources)) {\n+                    return prevActiveSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                assert prevActiveSources != 0;\n+                if (prevActiveSources > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    return prevActiveSources == -1;\n+                }\n+            }\n+        }\n+\n+        private boolean removeSubscriber(final FlatMapPublisherSubscriber<T, R> subscriber, int unusedDemand) {\n+            if (cancellableSubscribers.remove(subscriber) && decrementActiveMappedSources()) {\n+                return true;\n+            } else if (unusedDemand > 0) {\n+                incMappedDemand(unusedDemand);\n+            }\n+            return false;\n+        }\n+\n+        private static final class FlatMapPublisherSubscriber<T, R> implements Subscriber<R>, Cancellable {\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicIntegerFieldUpdater<FlatMapPublisherSubscriber> pendingDemandUpdater =\n+                    AtomicIntegerFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"innerPendingDemand\");\n+\n+            private final FlatMapSubscriber<T, R> parent;\n+            private final DelayedSubscription subscription;\n+            private volatile int innerPendingDemand;\n+            /**\n+             * visibility provided by the {@link Subscriber} thread in {@link #onNext(Object)}, and\n+             * demand is exhausted before {@link #request(long)} is called, and that method triggers\n+             * {@link Subscription#request(long)} which provides a\n+             * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.1\">\n+             * happens-before relationship between requesting elements and receiving elements</a>.\n+             */\n+            private boolean signalsQueued;\n+\n+            FlatMapPublisherSubscriber(FlatMapSubscriber<T, R> parent) {\n+                this.parent = parent;\n+                subscription = new DelayedSubscription();\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                subscription.cancel();\n+            }\n+\n+            int request(int n) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf1824e3eb85a637139297c89e4c9e3c2ed5533"}, "originalPosition": 542}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ4MzA0NQ==", "bodyText": "Ok lets add a comment explaining that this is done to preserve order per Subscriber.", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r491483045", "createdAt": "2020-09-19T18:56:59Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,661 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     to manage the {@link FlatMapSubscriber#hungrySubscribers} queue (e.g. network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * {@link FlatMapSubscriber#hungrySubscribers queue} management.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final int minMappedDemand;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, int minMappedDemand, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        if (minMappedDemand <= 0) {\n+            throw new IllegalArgumentException(\"minMappedDemand: \" + minMappedDemand + \" (expected >0)\");\n+        }\n+        this.minMappedDemand = minMappedDemand;\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> requestingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"requestingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int requestingLock;\n+        private volatile long pendingDemand;\n+        private volatile long mappedDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final DynamicCompositeCancellable cancellableSubscribers;\n+        private final Queue<FlatMapPublisherSubscriber<T, R>> hungrySubscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            signals = newUnboundedMpscQueue(4);\n+            hungrySubscribers = newUnboundedMpscQueue(4);\n+            cancellableSubscribers = new SetDynamicCompositeCancellable(min(16, source.maxConcurrency));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                // If we transitioned from no demand, to some demand, then we should try to drain the queues which\n+                // may have signals pending due to previous over-request.\n+                if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                    drainPending();\n+                }\n+                if (mappedDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtection) == 0) {\n+                    distributeMappedDemand();\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (!cancellableSubscribers.add(subscriber)) {\n+                return;\n+            }\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either\n+                    // way we don't want to Subscribe or retain a reference to this Publisher.\n+                    cancellableSubscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, false, false)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean overrideComplete,\n+                                 boolean cancelSubscriberIfNecessary) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, overrideComplete, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(cancelSubscriberIfNecessary);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private long reserveMappedDemand() {\n+            return mappedDemandUpdater.getAndSet(this, 0);\n+        }\n+\n+        private int reserveMappedDemandQuota() {\n+            for (;;) {\n+                final long prevDemand = mappedDemand;\n+                if (prevDemand <= 0) {\n+                    return 0;\n+                }\n+                final int quota = calculateRequestNQuota(prevDemand);\n+                if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - quota)) {\n+                    return quota;\n+                }\n+            }\n+        }\n+\n+        private void distributeMappedDemand(FlatMapPublisherSubscriber<T, R> hungrySubscriber) {\n+            final int quota = reserveMappedDemandQuota();\n+            if (quota > 0) {\n+                final int usedQuota = hungrySubscriber.request(quota);\n+                if (usedQuota < quota && mappedDemandUpdater.getAndAccumulate(this, quota - usedQuota,\n+                        FlowControlUtils::addWithOverflowProtection) == 0) {\n+                    // If we gave some back and transitioned from 0 demand, we need to try to distribute demand\n+                    // in case other hungry subscribers were added in the mean time\n+                    // (since we have not acquired the requestingLock).\n+                    distributeMappedDemand();\n+                }\n+            } else { // slow path. no demand, add to queue and process later when demand arrives.\n+                hungrySubscribers.add(hungrySubscriber);\n+                distributeMappedDemand();\n+            }\n+        }\n+\n+        private void distributeMappedDemand() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            while (tryAcquire && tryAcquireLock(requestingLockUpdater, this)) {\n+                try {\n+                    final long availableRequestN = reserveMappedDemand();\n+                    if (availableRequestN > 0) {\n+                        long remainingRequestN = availableRequestN;\n+                        final int quota = calculateRequestNQuota(availableRequestN);\n+                        FlatMapPublisherSubscriber<T, R> hungrySubscriber;\n+                        while ((hungrySubscriber = hungrySubscribers.poll()) != null) {\n+                            remainingRequestN -= hungrySubscriber.request(quota);\n+                        }\n+                        if (remainingRequestN > 0) {\n+                            mappedDemandUpdater.accumulateAndGet(this, remainingRequestN,\n+                                    FlowControlUtils::addWithOverflowProtection);\n+                        }\n+                    }\n+                } catch (Throwable cause) {\n+                    delayedCause = catchUnexpected(delayedCause, cause);\n+                } finally {\n+                    tryAcquire = !releaseLock(requestingLockUpdater, this);\n+                }\n+            }\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private int calculateRequestNQuota(long availableRequestN) {\n+            // Get an approximate quota to distribute to each active mapped subscriber. If\n+            // activeMappedSources changes (subscriber added or terminated) we will re-distribute.\n+            final int prevActiveSources = activeMappedSources;\n+            return (int) min(Integer.MAX_VALUE,\n+                    max(prevActiveSources > 0 ? availableRequestN / prevActiveSources : availableRequestN,\n+                            source.minMappedDemand));\n+        }\n+\n+        private void doCancel(boolean cancelSubscription) {\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            pendingDemand = -1;\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                cancellableSubscribers.cancel();\n+                // Don't bother clearing out hungrySubscribers or signals (which require additional concurrency control)\n+                // because it is assumed this Subscriber will be dereferenced and eligible for GC [1].\n+                // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.13\n+            }\n+        }\n+\n+        private boolean tryDecrementPendingDemand() {\n+            for (;;) {\n+                final long prevDemand = pendingDemand;\n+                if (prevDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevDemand, prevDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementPendingDemand())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ1NDg0MQ=="}, "originalCommit": {"oid": "0fa00306b986d647b69e9ead71e915494ea62db2"}, "originalPosition": 355}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTQ4MzE0Mw==", "bodyText": "nit: we are attempting drain upon release which is the typical pattern. Suggest removing the comment.", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r491483143", "createdAt": "2020-09-19T18:58:14Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     for managing demand through the {@link FlatMapSubscriber#signals} queue (network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * managing demand through the {@link FlatMapSubscriber#signals} queue.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private static final int MIN_MAPPED_DEMAND = 1;\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+        private volatile long mappedDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final DynamicCompositeCancellable cancellableSubscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            signals = newUnboundedMpscQueue(4);\n+            cancellableSubscribers = new SetDynamicCompositeCancellable(min(16, source.maxConcurrency));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true, true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                // If we transitioned from no demand, to some demand, then we should try to drain the queues which\n+                // may have signals pending due to previous over-request.\n+                if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                    drainPending();\n+                }\n+                incMappedDemand(n);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (!cancellableSubscribers.add(subscriber)) {\n+                return;\n+            }\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either\n+                    // way we don't want to Subscribe or retain a reference to this Publisher.\n+                    cancellableSubscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, true)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean fromUpstream) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, !fromUpstream, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(!fromUpstream, true);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void incMappedDemand(long n) {\n+            assert n > 0;\n+            mappedDemandUpdater.getAndAccumulate(this, n, FlowControlUtils::addWithUnderOverflowProtection);\n+        }\n+\n+        private int reserveMappedDemandQuota() {\n+            for (;;) {\n+                final long prevDemand = mappedDemand;\n+                if (prevDemand <= 0) {\n+                    // mappedDemand is allowed to go negative here in order to distribute MIN_MAPPED_DEMAND demand to\n+                    // each source. This is to avoid a single mapped source (or set of sources) not making any progress\n+                    // with the demand they were given, taking demand away from sources that could make progress. The\n+                    // negative value ensures that if a source completes with unused demand it doesn't result in\n+                    // artificially giving back \"negative\" demand and keeps the maximum queue size should be bound\n+                    // to (maxConcurrency * minMappedDemand).\n+                    if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - MIN_MAPPED_DEMAND)) {\n+                        return MIN_MAPPED_DEMAND;\n+                    }\n+                } else {\n+                    final int quota = calculateRequestNQuota(prevDemand);\n+                    if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - quota)) {\n+                        return quota;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void distributeMappedDemand(FlatMapPublisherSubscriber<T, R> hungrySubscriber) {\n+            final int quota = reserveMappedDemandQuota();\n+            final int usedQuota = hungrySubscriber.request(quota);\n+            if (usedQuota < quota) {\n+                incMappedDemand(quota - usedQuota);\n+            }\n+        }\n+\n+        private int calculateRequestNQuota(long availableRequestN) {\n+            // Get an approximate quota to distribute to each active mapped subscriber.\n+            return (int) min(Integer.MAX_VALUE, max(availableRequestN / source.maxConcurrency, MIN_MAPPED_DEMAND));\n+        }\n+\n+        private void doCancel(boolean cancelSubscription, boolean invalidatePendingDemand) {\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            if (invalidatePendingDemand) {\n+                pendingDemand = -1;\n+            }\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                cancellableSubscribers.cancel();\n+                // Don't bother clearing out signals (which require additional concurrency control) because it is\n+                // assumed this Subscriber will be dereferenced and eligible for GC [1].\n+                // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.13\n+            }\n+        }\n+\n+        private boolean tryDecrementPendingDemand() {\n+            for (;;) {\n+                final long prevDemand = pendingDemand;\n+                if (prevDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevDemand, prevDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                boolean mappedSourcesCompleted = false;\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementPendingDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf1824e3eb85a637139297c89e4c9e3c2ed5533"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4MzI0OQ==", "bodyText": "As the subscription in this case is wrapped into a ConcurrentSubscription, I don't think there is a need to go through the queue for MAPPED_SOURCE_COMPLETE. Each completion can just request(1) and the batching if any could come from ConcurrentSubscription. Removing this special item will reduce the conditionals in the drain loop thus reducing cognitive overhead.", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r494683249", "createdAt": "2020-09-25T00:35:20Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     for managing demand through the {@link FlatMapSubscriber#signals} queue (network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * managing demand through the {@link FlatMapSubscriber#signals} queue.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private static final int MIN_MAPPED_DEMAND = 1;\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+        private volatile long mappedDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final DynamicCompositeCancellable cancellableSubscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            signals = newUnboundedMpscQueue(4);\n+            cancellableSubscribers = new SetDynamicCompositeCancellable(min(16, source.maxConcurrency));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true, true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                // If we transitioned from no demand, to some demand, then we should try to drain the queues which\n+                // may have signals pending due to previous over-request.\n+                if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                    drainPending();\n+                }\n+                incMappedDemand(n);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (!cancellableSubscribers.add(subscriber)) {\n+                return;\n+            }\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either\n+                    // way we don't want to Subscribe or retain a reference to this Publisher.\n+                    cancellableSubscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, true)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean fromUpstream) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, !fromUpstream, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(!fromUpstream, true);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void incMappedDemand(long n) {\n+            assert n > 0;\n+            mappedDemandUpdater.getAndAccumulate(this, n, FlowControlUtils::addWithUnderOverflowProtection);\n+        }\n+\n+        private int reserveMappedDemandQuota() {\n+            for (;;) {\n+                final long prevDemand = mappedDemand;\n+                if (prevDemand <= 0) {\n+                    // mappedDemand is allowed to go negative here in order to distribute MIN_MAPPED_DEMAND demand to\n+                    // each source. This is to avoid a single mapped source (or set of sources) not making any progress\n+                    // with the demand they were given, taking demand away from sources that could make progress. The\n+                    // negative value ensures that if a source completes with unused demand it doesn't result in\n+                    // artificially giving back \"negative\" demand and keeps the maximum queue size should be bound\n+                    // to (maxConcurrency * minMappedDemand).\n+                    if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - MIN_MAPPED_DEMAND)) {\n+                        return MIN_MAPPED_DEMAND;\n+                    }\n+                } else {\n+                    final int quota = calculateRequestNQuota(prevDemand);\n+                    if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - quota)) {\n+                        return quota;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void distributeMappedDemand(FlatMapPublisherSubscriber<T, R> hungrySubscriber) {\n+            final int quota = reserveMappedDemandQuota();\n+            final int usedQuota = hungrySubscriber.request(quota);\n+            if (usedQuota < quota) {\n+                incMappedDemand(quota - usedQuota);\n+            }\n+        }\n+\n+        private int calculateRequestNQuota(long availableRequestN) {\n+            // Get an approximate quota to distribute to each active mapped subscriber.\n+            return (int) min(Integer.MAX_VALUE, max(availableRequestN / source.maxConcurrency, MIN_MAPPED_DEMAND));\n+        }\n+\n+        private void doCancel(boolean cancelSubscription, boolean invalidatePendingDemand) {\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            if (invalidatePendingDemand) {\n+                pendingDemand = -1;\n+            }\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                cancellableSubscribers.cancel();\n+                // Don't bother clearing out signals (which require additional concurrency control) because it is\n+                // assumed this Subscriber will be dereferenced and eligible for GC [1].\n+                // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.13\n+            }\n+        }\n+\n+        private boolean tryDecrementPendingDemand() {\n+            for (;;) {\n+                final long prevDemand = pendingDemand;\n+                if (prevDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevDemand, prevDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                boolean mappedSourcesCompleted = false;\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementPendingDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else if (item == MAPPED_SOURCE_COMPLETE) {\n+                        mappedSourcesCompleted = true;\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+                if (mappedSourcesCompleted) { // request more from upstream outside the critical section.\n+                    requestMoreFromUpstream(1);\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, false);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            int mappedSourcesCompleted = 0;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevDemand < 0) {\n+                        pendingDemand = prevDemand;\n+                        // Don't wait for demand to deliver the terminalNotification if present. The queued signals\n+                        // maybe from optimistic demand, but the error is from an event that needs immediate propagation\n+                        // (e.g. illegal requestN, failure to enqueue).\n+                        TerminalNotification t = terminalNotification;\n+                        if (t != null && t != complete()) {\n+                            sendToTarget(t); // if this throws its OK as we have terminated\n+                        }\n+                    } else {\n+                        Object t;\n+                        while (emittedCount < prevDemand && (t = signals.poll()) != null) {\n+                            try {\n+                                if (t == MAPPED_SOURCE_COMPLETE) {\n+                                    ++mappedSourcesCompleted;\n+                                } else if (sendToTarget(t)) {\n+                                    ++emittedCount;\n+                                }\n+                            } catch (Throwable cause) {\n+                                delayedCause = catchUnexpected(delayedCause, cause);\n+                            }\n+                        }\n+\n+                        // check if a terminal event is pending, or give back demand.\n+                        if (emittedCount == prevDemand) {\n+                            for (;;) {\n+                                try {\n+                                    t = signals.peek();\n+                                    if (t == MAPPED_SOURCE_COMPLETE) {\n+                                        signals.poll();\n+                                        ++mappedSourcesCompleted;\n+                                    } else if (t instanceof FlatMapPublisherSubscriber) {\n+                                        signals.poll();\n+                                        @SuppressWarnings(\"unchecked\")\n+                                        final FlatMapPublisherSubscriber<T, R> hungrySubscriber =\n+                                                (FlatMapPublisherSubscriber<T, R>) t;\n+                                        distributeMappedDemand(hungrySubscriber);\n+                                    } else {\n+                                        break;\n+                                    }\n+                                } catch (Throwable cause) {\n+                                    delayedCause = catchUnexpected(delayedCause, cause);\n+                                }\n+                            }\n+\n+                            if (t instanceof TerminalNotification) {\n+                                sendToTarget((TerminalNotification) t); // if this throws its OK as we have terminated\n+                            }\n+                        } else {\n+                            assert emittedCount < prevDemand;\n+                            pendingDemandUpdater.accumulateAndGet(this, prevDemand - emittedCount,\n+                                    FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n+                        }\n+                    }\n+                } finally {\n+                    tryAcquire = !releaseLock(emittingLockUpdater, this);\n+                }\n+            }\n+\n+            if (mappedSourcesCompleted != 0) {\n+                requestMoreFromUpstream(mappedSourcesCompleted);\n+            }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void requestMoreFromUpstream(int mappedSourcesCompleted) {\n+            assert mappedSourcesCompleted > 0;\n+            assert subscription != null;\n+            subscription.request(mappedSourcesCompleted);\n+        }\n+\n+        private static boolean needsDemand(Object item) {\n+            return item != MAPPED_SOURCE_COMPLETE &&\n+                    !(item instanceof FlatMapPublisherSubscriber) && !(item instanceof TerminalNotification);\n+        }\n+\n+        private boolean sendToTarget(Object item) {\n+            assert item != MAPPED_SOURCE_COMPLETE;\n+            if (targetTerminated) {\n+                return false;\n+            } else if (item instanceof TerminalNotification) {\n+                TerminalNotification terminalNotification;\n+                if (item == complete() && (terminalNotification = this.terminalNotification) != null) {\n+                    // Load the terminal notification in case an error happened after an onComplete and we override the\n+                    // terminal value.\n+                    sendToTarget(terminalNotification);\n+                } else {\n+                    sendToTarget((TerminalNotification) item);\n+                }\n+                return false;\n+            } else if (item instanceof FlatMapPublisherSubscriber) {\n+                @SuppressWarnings(\"unchecked\")\n+                final FlatMapPublisherSubscriber<T, R> hungrySubscriber = (FlatMapPublisherSubscriber<T, R>) item;\n+                distributeMappedDemand(hungrySubscriber);\n+                return false;\n+            }\n+            target.onNext(unwrapNullUnchecked(item));\n+            return true;\n+        }\n+\n+        private void sendToTarget(TerminalNotification terminalNotification) {\n+            signals.clear();\n+            targetTerminated = true;\n+            CompositeException de = this.delayedError;\n+            if (de != null) {\n+                de.transferPendingToSuppressed();\n+                if (terminalNotification.cause() == de) {\n+                    terminalNotification.terminate(target);\n+                } else {\n+                    terminalNotification.terminate(target, de);\n+                }\n+            } else {\n+                terminalNotification.terminate(target);\n+            }\n+        }\n+\n+        private boolean terminateActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                assert prevActiveSources >= 0; // otherwise we have seen multiple onComplete signals\n+                if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, -prevActiveSources)) {\n+                    return prevActiveSources == 0;\n+                }\n+            }\n+        }\n+\n+        private boolean decrementActiveMappedSources() {\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                assert prevActiveSources != 0;\n+                if (prevActiveSources > 0) {\n+                    if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources - 1)) {\n+                        return false;\n+                    }\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    return prevActiveSources == -1;\n+                }\n+            }\n+        }\n+\n+        private boolean removeSubscriber(final FlatMapPublisherSubscriber<T, R> subscriber, int unusedDemand) {\n+            if (cancellableSubscribers.remove(subscriber) && decrementActiveMappedSources()) {\n+                return true;\n+            } else if (unusedDemand > 0) {\n+                incMappedDemand(unusedDemand);\n+            }\n+            return false;\n+        }\n+\n+        private static final class FlatMapPublisherSubscriber<T, R> implements Subscriber<R>, Cancellable {\n+            @SuppressWarnings(\"rawtypes\")\n+            private static final AtomicIntegerFieldUpdater<FlatMapPublisherSubscriber> pendingDemandUpdater =\n+                    AtomicIntegerFieldUpdater.newUpdater(FlatMapPublisherSubscriber.class, \"innerPendingDemand\");\n+\n+            private final FlatMapSubscriber<T, R> parent;\n+            private final DelayedSubscription subscription;\n+            private volatile int innerPendingDemand;\n+            /**\n+             * visibility provided by the {@link Subscriber} thread in {@link #onNext(Object)}, and\n+             * demand is exhausted before {@link #request(long)} is called, and that method triggers\n+             * {@link Subscription#request(long)} which provides a\n+             * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.1\">\n+             * happens-before relationship between requesting elements and receiving elements</a>.\n+             */\n+            private boolean signalsQueued;\n+\n+            FlatMapPublisherSubscriber(FlatMapSubscriber<T, R> parent) {\n+                this.parent = parent;\n+                subscription = new DelayedSubscription();\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                subscription.cancel();\n+            }\n+\n+            int request(int n) {\n+                assert n > 0;\n+                if (!pendingDemandUpdater.compareAndSet(this, 0, n)) {\n+                    return 0;\n+                }\n+                signalsQueued = false;\n+                subscription.request(n);\n+                return n;\n+            }\n+\n+            void markSignalsQueued() {\n+                signalsQueued = true;\n+            }\n+\n+            boolean hasSignalsQueued() {\n+                return signalsQueued;\n+            }\n+\n+            @Override\n+            public void onSubscribe(final Subscription s) {\n+                subscription.delayedSubscription(ConcurrentSubscription.wrap(s));\n+                // RequestN management for mapped sources is \"approximate\" as it is divided between mapped sources. More\n+                // demand may be distributed than is requested from downstream in order to avoid deadlock scenarios.\n+                // To accommodate for the \"approximate\" mapped demand we maintain a signal queue (bounded by the\n+                // concurrency). This presents an opportunity to decouple downstream requestN requests from iterating\n+                // all active mapped sources and instead optimistically give out demand here and replenish demand after\n+                // signals are delivered to the downstream subscriber (based upon available demand is available).\n+                parent.distributeMappedDemand(this);\n+            }\n+\n+            @Override\n+            public void onNext(@Nullable final R r) {\n+                parent.tryEmitItem(wrapNull(r), this);\n+                final int pendingDemand = pendingDemandUpdater.decrementAndGet(this);\n+                if (pendingDemand == 0) {\n+                    // Emit this item to signify this Subscriber is hungry for more demand when it is available.\n+                    parent.tryEmitItem(this, this);\n+                } else if (pendingDemand < 0) {\n+                    throw new IllegalStateException(\"Too many onNext signals for Subscriber: \" + this +\n+                            \" pendingDemand: \" + pendingDemand);\n+                }\n+            }\n+\n+            @Override\n+            public void onError(final Throwable t) {\n+                if (!parent.source.delayError) {\n+                    // Make sure errors aren't delivered out of order relative to onNext signals which maybe queued.\n+                    try {\n+                        parent.doCancel(true, false);\n+                    } finally {\n+                        parent.tryEmitItem(TerminalNotification.error(t), this);\n+                    }\n+                } else {\n+                    CompositeException de = parent.delayedError;\n+                    if (de == null) {\n+                        de = new CompositeException(t);\n+                        if (!delayedErrorUpdater.compareAndSet(parent, null, de)) {\n+                            de = parent.delayedError;\n+                            assert de != null;\n+                            de.add(t);\n+                        }\n+                    } else {\n+                        de.add(t);\n+                    }\n+                    if (parent.removeSubscriber(this, pendingDemandUpdater.getAndSet(this, -1))) {\n+                        parent.enqueueAndDrain(TerminalNotification.error(de));\n+                    } else {\n+                        parent.tryEmitItem(MAPPED_SOURCE_COMPLETE, this);\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void onComplete() {\n+                if (parent.removeSubscriber(this, pendingDemandUpdater.getAndSet(this, -1))) {\n+                    parent.enqueueAndDrain(complete());\n+                } else {\n+                    parent.tryEmitItem(MAPPED_SOURCE_COMPLETE, this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf1824e3eb85a637139297c89e4c9e3c2ed5533"}, "originalPosition": 619}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY4NzQ1NA==", "bodyText": "Unrelated but the DynamicCompositeCancellable also return true if they were not able to add the Cancellable. Perhaps that is a bug.", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r494687454", "createdAt": "2020-09-25T00:50:46Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     for managing demand through the {@link FlatMapSubscriber#signals} queue (network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * managing demand through the {@link FlatMapSubscriber#signals} queue.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private static final int MIN_MAPPED_DEMAND = 1;\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+        private volatile long mappedDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final DynamicCompositeCancellable cancellableSubscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            signals = newUnboundedMpscQueue(4);\n+            cancellableSubscribers = new SetDynamicCompositeCancellable(min(16, source.maxConcurrency));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true, true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                // If we transitioned from no demand, to some demand, then we should try to drain the queues which\n+                // may have signals pending due to previous over-request.\n+                if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                    drainPending();\n+                }\n+                incMappedDemand(n);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (!cancellableSubscribers.add(subscriber)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf1824e3eb85a637139297c89e4c9e3c2ed5533"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5MjkzOA==", "bodyText": "I don't think this is required, i.e. have dual mode whether errors skip the queue or not based on pendingDemand being negative.\nThe context is spread out to call-sites of doCancel() and makes the control flow too hard to follow.", "url": "https://github.com/apple/servicetalk/pull/1011#discussion_r494692938", "createdAt": "2020-09-25T01:13:45Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapMerge.java", "diffHunk": "@@ -0,0 +1,624 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.internal.ConcurrentSubscription;\n+import io.servicetalk.concurrent.internal.DelayedSubscription;\n+import io.servicetalk.concurrent.internal.FlowControlUtils;\n+import io.servicetalk.concurrent.internal.QueueFullException;\n+import io.servicetalk.concurrent.internal.TerminalNotification;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+import javax.annotation.Nullable;\n+\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.unwrapNullUnchecked;\n+import static io.servicetalk.concurrent.api.SubscriberApiUtils.wrapNull;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.releaseLock;\n+import static io.servicetalk.concurrent.internal.ConcurrentUtils.tryAcquireLock;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.checkDuplicateSubscription;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.SubscriberUtils.trySetTerminal;\n+import static io.servicetalk.concurrent.internal.TerminalNotification.complete;\n+import static io.servicetalk.concurrent.internal.ThrowableUtils.catchUnexpected;\n+import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.lang.Math.max;\n+import static java.lang.Math.min;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+\n+/**\n+ * Implementation of {@link Publisher#flatMapMerge(Function)}.\n+ * <p>\n+ * This implementation makes some trade-offs that may have performance/memory impacts. Demand distributed to mapped\n+ * {@link Publisher}s is dynamic and correlates to downstream demand. This dynamic behavior is targeted toward use cases\n+ * where:\n+ * <ul>\n+ *     <li>{@link Subscriber#onNext(Object) onNext Objects} consume non trivial amount of memory relative to the memory\n+ *     for managing demand through the {@link FlatMapSubscriber#signals} queue (network buffer, serialized POJO)</li>\n+ *     <li>downstream demand is available before signals from mapped sources are available\n+ *     (e.g. over a network boundary)</li>\n+ * </ul>\n+ * Scenarios where downstream demand is provided in small/slow increments relative to the amount of signals from mapped\n+ * Sources, or mapped Sources are backed by in memory content are expected to incur some additional overhead for\n+ * managing demand through the {@link FlatMapSubscriber#signals} queue.\n+ *\n+ * @param <T> Type of original {@link Publisher}.\n+ * @param <R> Type of {@link Publisher} returned by the operator.\n+ */\n+final class PublisherFlatMapMerge<T, R> extends AbstractAsynchronousPublisherOperator<T, R> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(PublisherFlatMapMerge.class);\n+    private static final int MIN_MAPPED_DEMAND = 1;\n+    private final Function<? super T, ? extends Publisher<? extends R>> mapper;\n+    private final int maxConcurrency;\n+    private final boolean delayError;\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, Executor executor) {\n+        this(original, mapper, delayError, 8, executor);\n+    }\n+\n+    PublisherFlatMapMerge(Publisher<T> original, Function<? super T, ? extends Publisher<? extends R>> mapper,\n+                          boolean delayError, int maxConcurrency, Executor executor) {\n+        super(original, executor);\n+        this.mapper = requireNonNull(mapper);\n+        if (maxConcurrency <= 0) {\n+            throw new IllegalArgumentException(\"maxConcurrency: \" + maxConcurrency + \" (expected >0)\");\n+        }\n+        this.maxConcurrency = maxConcurrency;\n+        this.delayError = delayError;\n+    }\n+\n+    @Override\n+    public Subscriber<? super T> apply(final Subscriber<? super R> subscriber) {\n+        return new FlatMapSubscriber<>(this, subscriber);\n+    }\n+\n+    private static final class FlatMapSubscriber<T, R> implements Subscriber<T>, Subscription {\n+        private static final Object MAPPED_SOURCE_COMPLETE = new Object();\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, CompositeException> delayedErrorUpdater =\n+                newUpdater(FlatMapSubscriber.class, CompositeException.class, \"delayedError\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> emittingLockUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"emittingLock\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> mappedDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"mappedDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicLongFieldUpdater<FlatMapSubscriber> pendingDemandUpdater =\n+                AtomicLongFieldUpdater.newUpdater(FlatMapSubscriber.class, \"pendingDemand\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<FlatMapSubscriber> activeMappedSourcesUpdater =\n+                AtomicIntegerFieldUpdater.newUpdater(FlatMapSubscriber.class, \"activeMappedSources\");\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicReferenceFieldUpdater<FlatMapSubscriber, TerminalNotification>\n+                terminalNotificationUpdater = newUpdater(FlatMapSubscriber.class, TerminalNotification.class,\n+                \"terminalNotification\");\n+\n+        @SuppressWarnings(\"unused\")\n+        @Nullable\n+        private volatile TerminalNotification terminalNotification;\n+        @Nullable\n+        private volatile CompositeException delayedError;\n+        @SuppressWarnings(\"unused\")\n+        private volatile int emittingLock;\n+        private volatile int activeMappedSources;\n+        private volatile long pendingDemand;\n+        private volatile long mappedDemand;\n+\n+        // protected by emitting lock, or only accessed inside the Subscriber thread\n+        private boolean targetTerminated;\n+        @Nullable\n+        private Subscription subscription;\n+\n+        private final Subscriber<? super R> target;\n+        private final Queue<Object> signals;\n+        private final PublisherFlatMapMerge<T, R> source;\n+        private final DynamicCompositeCancellable cancellableSubscribers;\n+\n+        FlatMapSubscriber(PublisherFlatMapMerge<T, R> source, Subscriber<? super R> target) {\n+            this.source = source;\n+            this.target = target;\n+            signals = newUnboundedMpscQueue(4);\n+            cancellableSubscribers = new SetDynamicCompositeCancellable(min(16, source.maxConcurrency));\n+        }\n+\n+        @Override\n+        public void cancel() {\n+            doCancel(true, true);\n+        }\n+\n+        @Override\n+        public void request(final long n) {\n+            assert subscription != null;\n+            if (!isRequestNValid(n)) {\n+                subscription.request(n);\n+            } else {\n+                // If we transitioned from no demand, to some demand, then we should try to drain the queues which\n+                // may have signals pending due to previous over-request.\n+                if (pendingDemandUpdater.getAndAccumulate(this, n,\n+                        FlowControlUtils::addWithOverflowProtectionIfNotNegative) == 0) {\n+                    drainPending();\n+                }\n+                incMappedDemand(n);\n+            }\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Subscription s) {\n+            if (!checkDuplicateSubscription(subscription, s)) {\n+                return;\n+            }\n+\n+            // We assume that FlatMapSubscriber#cancel() will never be called before this method, and therefore we\n+            // don't have to worry about being cancelled before the onSubscribe method is called.\n+            subscription = ConcurrentSubscription.wrap(s);\n+            target.onSubscribe(this);\n+\n+            subscription.request(source.maxConcurrency);\n+        }\n+\n+        @Override\n+        public void onNext(@Nullable final T t) {\n+            final Publisher<? extends R> publisher = requireNonNull(source.mapper.apply(t));\n+            FlatMapPublisherSubscriber<T, R> subscriber = new FlatMapPublisherSubscriber<>(this);\n+            if (!cancellableSubscribers.add(subscriber)) {\n+                return;\n+            }\n+            for (;;) {\n+                final int prevActiveSources = activeMappedSources;\n+                if (prevActiveSources < 0) {\n+                    // We have been cancelled, or already completed and the active count flipped to negative, either\n+                    // way we don't want to Subscribe or retain a reference to this Publisher.\n+                    cancellableSubscribers.remove(subscriber);\n+                    break;\n+                } else if (activeMappedSourcesUpdater.compareAndSet(this, prevActiveSources, prevActiveSources + 1)) {\n+                    publisher.subscribeInternal(subscriber);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            if (!onError0(t, true)) {\n+                LOGGER.debug(\"Already terminated/cancelled, ignoring error notification.\", t);\n+            }\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            // Setting terminal must be done before terminateActiveMappedSources to ensure visibility of the terminal.\n+            final boolean setTerminal = trySetTerminal(complete(), false, terminalNotificationUpdater, this);\n+            final boolean allSourcesTerminated = terminateActiveMappedSources();\n+            if (setTerminal && allSourcesTerminated) {\n+                enqueueAndDrain(complete());\n+            }\n+        }\n+\n+        private boolean onError0(Throwable throwable, boolean fromUpstream) {\n+            final TerminalNotification notification = TerminalNotification.error(throwable);\n+            if (trySetTerminal(notification, !fromUpstream, terminalNotificationUpdater, this)) {\n+                try {\n+                    doCancel(!fromUpstream, true);\n+                } finally {\n+                    enqueueAndDrain(notification);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        private void incMappedDemand(long n) {\n+            assert n > 0;\n+            mappedDemandUpdater.getAndAccumulate(this, n, FlowControlUtils::addWithUnderOverflowProtection);\n+        }\n+\n+        private int reserveMappedDemandQuota() {\n+            for (;;) {\n+                final long prevDemand = mappedDemand;\n+                if (prevDemand <= 0) {\n+                    // mappedDemand is allowed to go negative here in order to distribute MIN_MAPPED_DEMAND demand to\n+                    // each source. This is to avoid a single mapped source (or set of sources) not making any progress\n+                    // with the demand they were given, taking demand away from sources that could make progress. The\n+                    // negative value ensures that if a source completes with unused demand it doesn't result in\n+                    // artificially giving back \"negative\" demand and keeps the maximum queue size should be bound\n+                    // to (maxConcurrency * minMappedDemand).\n+                    if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - MIN_MAPPED_DEMAND)) {\n+                        return MIN_MAPPED_DEMAND;\n+                    }\n+                } else {\n+                    final int quota = calculateRequestNQuota(prevDemand);\n+                    if (mappedDemandUpdater.compareAndSet(this, prevDemand, prevDemand - quota)) {\n+                        return quota;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void distributeMappedDemand(FlatMapPublisherSubscriber<T, R> hungrySubscriber) {\n+            final int quota = reserveMappedDemandQuota();\n+            final int usedQuota = hungrySubscriber.request(quota);\n+            if (usedQuota < quota) {\n+                incMappedDemand(quota - usedQuota);\n+            }\n+        }\n+\n+        private int calculateRequestNQuota(long availableRequestN) {\n+            // Get an approximate quota to distribute to each active mapped subscriber.\n+            return (int) min(Integer.MAX_VALUE, max(availableRequestN / source.maxConcurrency, MIN_MAPPED_DEMAND));\n+        }\n+\n+        private void doCancel(boolean cancelSubscription, boolean invalidatePendingDemand) {\n+            // Prevent future onNext operations from adding to subscribers which otherwise may result in\n+            // not cancelling mapped Subscriptions. This should be Integer.MIN_VALUE to prevent subsequent mapped\n+            // source completion from incrementing the count to 0 or positive as terminateActiveMappedSources flips\n+            // the count to negative to signal to mapped sources we have completed.\n+            activeMappedSources = Integer.MIN_VALUE;\n+            if (invalidatePendingDemand) {\n+                pendingDemand = -1;\n+            }\n+            try {\n+                if (cancelSubscription) {\n+                    assert subscription != null;\n+                    subscription.cancel();\n+                }\n+            } finally {\n+                cancellableSubscribers.cancel();\n+                // Don't bother clearing out signals (which require additional concurrency control) because it is\n+                // assumed this Subscriber will be dereferenced and eligible for GC [1].\n+                // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.13\n+            }\n+        }\n+\n+        private boolean tryDecrementPendingDemand() {\n+            for (;;) {\n+                final long prevDemand = pendingDemand;\n+                if (prevDemand <= 0) {\n+                    return false;\n+                } else if (pendingDemandUpdater.compareAndSet(this, prevDemand, prevDemand - 1)) {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        private void tryEmitItem(Object item, FlatMapPublisherSubscriber<T, R> subscriber) {\n+            if (tryAcquireLock(emittingLockUpdater, this)) { // fast path. no concurrency, try to skip the queue.\n+                boolean mappedSourcesCompleted = false;\n+                try {\n+                    if (subscriber.hasSignalsQueued() || (needsDemand(item) && !tryDecrementPendingDemand())) {\n+                        subscriber.markSignalsQueued();\n+                        enqueueItem(item); // drain isn't necessary. when demand arrives a drain will be attempted.\n+                    } else if (item == MAPPED_SOURCE_COMPLETE) {\n+                        mappedSourcesCompleted = true;\n+                    } else {\n+                        final boolean demandConsumed = sendToTarget(item);\n+                        assert demandConsumed == needsDemand(item);\n+                    }\n+                } finally {\n+                    if (!releaseLock(emittingLockUpdater, this)) {\n+                        drainPending();\n+                    }\n+                }\n+                if (mappedSourcesCompleted) { // request more from upstream outside the critical section.\n+                    requestMoreFromUpstream(1);\n+                }\n+            } else { // slow path. there is concurrency, go through the queue to avoid concurrent delivery.\n+                subscriber.markSignalsQueued();\n+                enqueueAndDrain(item);\n+            }\n+        }\n+\n+        private void enqueueItem(Object item) {\n+            if (!signals.offer(item)) {\n+                enqueueFailed(item);\n+            }\n+        }\n+\n+        private void enqueueAndDrain(Object item) {\n+            enqueueItem(item);\n+            drainPending();\n+        }\n+\n+        private void enqueueFailed(Object item) {\n+            QueueFullException exception = new QueueFullException(\"signals\");\n+            if (item instanceof TerminalNotification) {\n+                LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n+                throw exception;\n+            } else {\n+                onError0(exception, false);\n+            }\n+        }\n+\n+        private void drainPending() {\n+            Throwable delayedCause = null;\n+            boolean tryAcquire = true;\n+            int mappedSourcesCompleted = 0;\n+            while (tryAcquire && tryAcquireLock(emittingLockUpdater, this)) {\n+                try {\n+                    final long prevDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                    long emittedCount = 0;\n+                    if (prevDemand < 0) {\n+                        pendingDemand = prevDemand;\n+                        // Don't wait for demand to deliver the terminalNotification if present. The queued signals", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acf1824e3eb85a637139297c89e4c9e3c2ed5533"}, "originalPosition": 365}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64ef837e515755872016c7f19ae0d6dbc1ddec75", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/64ef837e515755872016c7f19ae0d6dbc1ddec75", "committedDate": "2020-09-29T19:06:32Z", "message": "Add Publisher#flatMapMerge operator\n\nMotivation:\nPublisher#flatMapMerge is a basic building block for each element of a\nPublisher to map into another Publisher.\n\nModifications:\n- Add Publisher#flatMapMerge operator\n\nResult:\nEach item emitted on a Publisher can be mapped to another Publisher."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d9dc5013d4d2ba4e4cd90dda1a3b60c67fde92c", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/0d9dc5013d4d2ba4e4cd90dda1a3b60c67fde92c", "committedDate": "2020-09-29T19:06:32Z", "message": "change to queue more instead of manage request n demand. this way we\nensure we make progress at the expense of memory, and less coordination\nmanaging request(n) lending/distribution."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a998b67385a3a58aa1e25feef1b30b2d58fd0e00", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/a998b67385a3a58aa1e25feef1b30b2d58fd0e00", "committedDate": "2020-09-29T19:06:32Z", "message": "review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75db20e0be1a43ca3c81d5c7a32fe262dca1072f", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/75db20e0be1a43ca3c81d5c7a32fe262dca1072f", "committedDate": "2020-09-29T19:06:32Z", "message": "update transferPendingToSuppressed() method name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee838d0460174656bb32c7b1aa740524c7236b18", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/ee838d0460174656bb32c7b1aa740524c7236b18", "committedDate": "2020-09-29T19:06:32Z", "message": "review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d20fd92e86eede6b920d306d393255178b632d3d", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/d20fd92e86eede6b920d306d393255178b632d3d", "committedDate": "2020-09-29T19:06:32Z", "message": "first cut, adjust mapped demand to account for downstream demand"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07cecbf0813869f0ea823a0f228aa3696ddb9658", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/07cecbf0813869f0ea823a0f228aa3696ddb9658", "committedDate": "2020-09-29T19:06:32Z", "message": "review comments, correct mapped request demand distribution, out of order mapped error delivery"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1f62532eb2d79c735b1a19dd2e02ca938aae79f", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/e1f62532eb2d79c735b1a19dd2e02ca938aae79f", "committedDate": "2020-09-29T19:06:32Z", "message": "correct javadocs for FLowControlUtils method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef94510d7e204a7c4bd676224c80787530cc9b0c", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/ef94510d7e204a7c4bd676224c80787530cc9b0c", "committedDate": "2020-09-29T19:06:32Z", "message": "remove hungrySubscriber queue, make sure we always give demand to mapped sources optimistically to avoid deadlock"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed385f2feacc426891bb2ba9c36c820df1a23e6c", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/ed385f2feacc426891bb2ba9c36c820df1a23e6c", "committedDate": "2020-09-29T19:06:32Z", "message": "remove method in mapped subscriber"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d9c3247541030744fc3386799099fadcc28431d", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/9d9c3247541030744fc3386799099fadcc28431d", "committedDate": "2020-09-29T19:06:33Z", "message": "review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "acf1824e3eb85a637139297c89e4c9e3c2ed5533", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/acf1824e3eb85a637139297c89e4c9e3c2ed5533", "committedDate": "2020-09-16T00:25:00Z", "message": "remove method in mapped subscriber"}, "afterCommit": {"oid": "9d9c3247541030744fc3386799099fadcc28431d", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/9d9c3247541030744fc3386799099fadcc28431d", "committedDate": "2020-09-29T19:06:33Z", "message": "review comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3607, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}