{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3MjkwMTEw", "number": 993, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNjoyMTo1MVrODuB3JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNjoyMTo1MVrODuB3JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5NTkxNTg5OnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/ForEachSubscriber.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNjoyMTo1MVrOF_zIpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNzoxNToyOVrOF_1Pdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ0MjQwNA==", "bodyText": "Looks like we can just extend DelayedCancellable now.\nfinal class ForEachSubscriber<T> extends DelayedCancellable implements Subscriber<T> {\n\n    @Override\n    public void onSubscribe(Subscription s) {\n        s.request(Long.MAX_VALUE);\n        delayedCancellable(s);\n    }\n}\nAlso for all other classes in this PR", "url": "https://github.com/apple/servicetalk/pull/993#discussion_r402442404", "createdAt": "2020-04-02T16:21:51Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/ForEachSubscriber.java", "diffHunk": "@@ -40,11 +39,12 @@\n \n     @Override\n     public void onSubscribe(Subscription s) {\n-        // We wrap the subscription into ConcurrentSubscription as cancel on SequentialCancellable (this) can be\n+        // We wrap the subscription into DelayedCancellable as cancel on SequentialCancellable (this) can be\n         // concurrent with the request-n below.\n-        ConcurrentSubscription cs = wrap(s);\n-        nextCancellable(cs::cancel);\n-        cs.request(Long.MAX_VALUE);\n+        DelayedCancellable delayedCancellable = new DelayedCancellable();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd614798b4dcc02cecfc298b0f08003f123551c2"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ2MTM0MA==", "bodyText": "hum good point ... I will change this class to extend DelayedCancellable. however in the other cases where the Cancellable isn't exposed externally I think it makes more sense to keep to the local allocation in onSubscribe as the memory can be reclaimed asap, and may even be stack allocated because it is local scope and doesn't escape.", "url": "https://github.com/apple/servicetalk/pull/993#discussion_r402461340", "createdAt": "2020-04-02T16:50:29Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/ForEachSubscriber.java", "diffHunk": "@@ -40,11 +39,12 @@\n \n     @Override\n     public void onSubscribe(Subscription s) {\n-        // We wrap the subscription into ConcurrentSubscription as cancel on SequentialCancellable (this) can be\n+        // We wrap the subscription into DelayedCancellable as cancel on SequentialCancellable (this) can be\n         // concurrent with the request-n below.\n-        ConcurrentSubscription cs = wrap(s);\n-        nextCancellable(cs::cancel);\n-        cs.request(Long.MAX_VALUE);\n+        DelayedCancellable delayedCancellable = new DelayedCancellable();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ0MjQwNA=="}, "originalCommit": {"oid": "cd614798b4dcc02cecfc298b0f08003f123551c2"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3NjkxOA==", "bodyText": "actually forget what I said ... the DelayedCancellable does escape to the Subscriber ... change made!", "url": "https://github.com/apple/servicetalk/pull/993#discussion_r402476918", "createdAt": "2020-04-02T17:15:29Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/ForEachSubscriber.java", "diffHunk": "@@ -40,11 +39,12 @@\n \n     @Override\n     public void onSubscribe(Subscription s) {\n-        // We wrap the subscription into ConcurrentSubscription as cancel on SequentialCancellable (this) can be\n+        // We wrap the subscription into DelayedCancellable as cancel on SequentialCancellable (this) can be\n         // concurrent with the request-n below.\n-        ConcurrentSubscription cs = wrap(s);\n-        nextCancellable(cs::cancel);\n-        cs.request(Long.MAX_VALUE);\n+        DelayedCancellable delayedCancellable = new DelayedCancellable();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ0MjQwNA=="}, "originalCommit": {"oid": "cd614798b4dcc02cecfc298b0f08003f123551c2"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2642, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}