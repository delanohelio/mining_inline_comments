{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3ODgzNTE0", "number": 943, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMDozNToxM1rODhujVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMDo1NTozNVrODhux0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NjkyMzA5OnYy", "diffSide": "RIGHT", "path": "servicetalk-grpc-protobuf/src/main/java/io/servicetalk/grpc/protobuf/ProtoBufSerializationProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMDozNToxM1rOFsoBWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMzoxMDo0OFrOFsqaOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNzM2OQ==", "bodyText": "Is this check necessary since we will only be in this else block if toDeserialize.nioBufferCount() > 1?", "url": "https://github.com/apple/servicetalk/pull/943#discussion_r382337369", "createdAt": "2020-02-21T00:35:13Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-grpc-protobuf/src/main/java/io/servicetalk/grpc/protobuf/ProtoBufSerializationProvider.java", "diffHunk": "@@ -146,7 +150,22 @@ private static boolean isCompressed(Buffer buffer) throws SerializationException\n \n                     final T t;\n                     try {\n-                        t = parser.parseFrom(toDeserialize.toNioBuffer(toDeserialize.readerIndex(), lengthOfData));\n+                        final CodedInputStream in;\n+                        if (toDeserialize.nioBufferCount() == 1) {\n+                            in = CodedInputStream.newInstance(toDeserialize.toNioBuffer(toDeserialize.readerIndex(),\n+                                    lengthOfData));\n+                        } else {\n+                            // Aggregated payload body may consist of multiple Buffers. In this case,\n+                            // CompositeBuffer.toNioBuffer(idx, length) may return a single ByteBuffer (when requested\n+                            // length < components[0].length) or create a new ByteBuffer and copy multiple components\n+                            // into it. Later, proto parser will copy data from this temporary ByteBuffer again.\n+                            // To avoid unnecessary copying, we use newCodedInputStream(buffers, lengthOfData).\n+                            final ByteBuffer[] buffers = toDeserialize.toNioBuffers(toDeserialize.readerIndex(),\n+                                    lengthOfData);\n+                            in = buffers.length == 1 ? CodedInputStream.newInstance(buffers[0]) :", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ce88ebbf332e284532c9d794815948ee1096d0f"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NjUwNg==", "bodyText": "Yes, this is described in the comment above. toDeserialize.nioBufferCount() does not account for a requested length. We may be in a situation when the CompositeBuffer has 2 or more buffers internally (and those buffers may contain multiple proto messages), but we request only a few bytes (single proto message) that could be read from the first internal buffer. In this case, toDeserialize.toNioBuffers(..., length) may return an array that has only the first internal ByteBuffer, not all the internal buffers.", "url": "https://github.com/apple/servicetalk/pull/943#discussion_r382376506", "createdAt": "2020-02-21T03:10:48Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-grpc-protobuf/src/main/java/io/servicetalk/grpc/protobuf/ProtoBufSerializationProvider.java", "diffHunk": "@@ -146,7 +150,22 @@ private static boolean isCompressed(Buffer buffer) throws SerializationException\n \n                     final T t;\n                     try {\n-                        t = parser.parseFrom(toDeserialize.toNioBuffer(toDeserialize.readerIndex(), lengthOfData));\n+                        final CodedInputStream in;\n+                        if (toDeserialize.nioBufferCount() == 1) {\n+                            in = CodedInputStream.newInstance(toDeserialize.toNioBuffer(toDeserialize.readerIndex(),\n+                                    lengthOfData));\n+                        } else {\n+                            // Aggregated payload body may consist of multiple Buffers. In this case,\n+                            // CompositeBuffer.toNioBuffer(idx, length) may return a single ByteBuffer (when requested\n+                            // length < components[0].length) or create a new ByteBuffer and copy multiple components\n+                            // into it. Later, proto parser will copy data from this temporary ByteBuffer again.\n+                            // To avoid unnecessary copying, we use newCodedInputStream(buffers, lengthOfData).\n+                            final ByteBuffer[] buffers = toDeserialize.toNioBuffers(toDeserialize.readerIndex(),\n+                                    lengthOfData);\n+                            in = buffers.length == 1 ? CodedInputStream.newInstance(buffers[0]) :", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNzM2OQ=="}, "originalCommit": {"oid": "2ce88ebbf332e284532c9d794815948ee1096d0f"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2Njk1NDU1OnYy", "diffSide": "RIGHT", "path": "servicetalk-grpc-protobuf/src/main/java/io/servicetalk/grpc/protobuf/ProtoBufSerializationProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMDo1Mjo0M1rOFsoUFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMjo1NzoyMlrOFsqOCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0MjE2NA==", "bodyText": "Wondering why we can not use ByteString.unsafeWrap() and aliasing for toDeserialize.nioBufferCount() == 1 case also? We are pretty sure that the buffer will not be mutated between creation of CodedInputStream and usage by the parser.", "url": "https://github.com/apple/servicetalk/pull/943#discussion_r382342164", "createdAt": "2020-02-21T00:52:43Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-grpc-protobuf/src/main/java/io/servicetalk/grpc/protobuf/ProtoBufSerializationProvider.java", "diffHunk": "@@ -186,6 +205,23 @@ private static boolean isCompressed(Buffer buffer) throws SerializationException\n             }\n         }\n \n+        private static CodedInputStream newCodedInputStream(final ByteBuffer[] buffers, final int lengthOfData) {\n+            // Because we allocated a new internal ByteBuffer that will never be mutated we may just wrap it and\n+            // enable aliasing to avoid an extra copying inside parser for a deserialized message.\n+            final CodedInputStream in = unsafeWrap(mergeByteBuffers(buffers, lengthOfData)).newCodedInput();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ce88ebbf332e284532c9d794815948ee1096d0f"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3MzM4Ng==", "bodyText": "If toDeserialize.nioBufferCount() == 1, the Buffer will not create a new copy when we do toDeserialize.toNioBuffer(...). Instead, it will return a ByteBuffer wrapper that shares the same internal array.\nBecause users have a way to access the original Buffer using http filters, we can not guarantee that they do not modify the internal array. Therefore, by default we need to be safe. However, we can provide a configuration option for ProtoBufSerializationProviderBuilder and GrpcClientBuilder/GrpcServerBuilder to do zero-copying deserialization when users sure that they do not touch the payload body in any other way.", "url": "https://github.com/apple/servicetalk/pull/943#discussion_r382373386", "createdAt": "2020-02-21T02:57:22Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-grpc-protobuf/src/main/java/io/servicetalk/grpc/protobuf/ProtoBufSerializationProvider.java", "diffHunk": "@@ -186,6 +205,23 @@ private static boolean isCompressed(Buffer buffer) throws SerializationException\n             }\n         }\n \n+        private static CodedInputStream newCodedInputStream(final ByteBuffer[] buffers, final int lengthOfData) {\n+            // Because we allocated a new internal ByteBuffer that will never be mutated we may just wrap it and\n+            // enable aliasing to avoid an extra copying inside parser for a deserialized message.\n+            final CodedInputStream in = unsafeWrap(mergeByteBuffers(buffers, lengthOfData)).newCodedInput();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0MjE2NA=="}, "originalCommit": {"oid": "2ce88ebbf332e284532c9d794815948ee1096d0f"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2Njk2MDE5OnYy", "diffSide": "RIGHT", "path": "servicetalk-grpc-protobuf/src/main/java/io/servicetalk/grpc/protobuf/ProtoBufSerializationProviderBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMDo1NTozNVrOFsoXkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMzoxOToyNFrOFsqhgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0MzA1Ng==", "bodyText": "If the size is not memoized, getSerializedSize() will use reflection to calculate the size. Is that worth the size optimization here?", "url": "https://github.com/apple/servicetalk/pull/943#discussion_r382343056", "createdAt": "2020-02-21T00:55:35Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-grpc-protobuf/src/main/java/io/servicetalk/grpc/protobuf/ProtoBufSerializationProviderBuilder.java", "diffHunk": "@@ -155,7 +157,7 @@ public GrpcSerializationProvider build() {\n         @Override\n         public Buffer serialize(final HttpHeaders headers, final T value, final BufferAllocator allocator) {\n             addContentHeaders(headers);\n-            return serializer.serialize(value, allocator);\n+            return serializer.serialize(value, allocator, METADATA_SIZE + value.getSerializedSize());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ce88ebbf332e284532c9d794815948ee1096d0f"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3ODM2OA==", "bodyText": "We invoke getSerializedSize() anyway to fill in the metadata later. So, we do not pay the reflection cost twice. Without this, profiling shows that we frequently expand the buffer during writeTo because it can not fit the serialized proto.", "url": "https://github.com/apple/servicetalk/pull/943#discussion_r382378368", "createdAt": "2020-02-21T03:19:24Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-grpc-protobuf/src/main/java/io/servicetalk/grpc/protobuf/ProtoBufSerializationProviderBuilder.java", "diffHunk": "@@ -155,7 +157,7 @@ public GrpcSerializationProvider build() {\n         @Override\n         public Buffer serialize(final HttpHeaders headers, final T value, final BufferAllocator allocator) {\n             addContentHeaders(headers);\n-            return serializer.serialize(value, allocator);\n+            return serializer.serialize(value, allocator, METADATA_SIZE + value.getSerializedSize());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0MzA1Ng=="}, "originalCommit": {"oid": "2ce88ebbf332e284532c9d794815948ee1096d0f"}, "originalPosition": 23}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2863, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}