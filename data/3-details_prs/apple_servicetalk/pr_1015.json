{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzNDA2NzU5", "number": 1015, "title": "ConcurrentSubscripiton avoid concurrent access for invalid demand", "bodyText": "Motivation:\nConcurrentSubscription currently propagates invalid demand without any\nconcurrency protection. In general this is invalid use of the API but\nmay invalidate underlying data structures that are not thread safe and\nresult in undefined results.\nModifications:\n\nUse a simpler locking scheme inspired by Publisher#flatMapMerge design\nwhich allows for re-entry and also notification is another thread has\nattempted to acquire the lock which will trigger re-processing.\n\nResult:\nConcurrentSubscripiton no longer allows any concurrent access and uses a\nmore common/shareable locking utility.", "createdAt": "2020-04-14T20:48:57Z", "url": "https://github.com/apple/servicetalk/pull/1015", "merged": true, "mergeCommit": {"oid": "e57a01cb051eb87de0657de7fb814c85b512716f"}, "closed": true, "closedAt": "2020-05-05T01:40:44Z", "author": {"login": "Scottmitch"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcXx5CFgFqTM5MzQ3OTk5NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABceJ8a2gFqTQwNTQ1MTM3Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzNDc5OTk1", "url": "https://github.com/apple/servicetalk/pull/1015#pullrequestreview-393479995", "createdAt": "2020-04-15T06:11:16Z", "commit": {"oid": "d7a6ca3fad3fd46ba377f7e97ae4d492919886f0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNjoxMToxNlrOGFrGqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwNjoxMzo1NVrOGFrJ8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwMjI4Mg==", "bodyText": "nit: consider define a static field for 0 so its a bit less of a magic number", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r408602282", "createdAt": "2020-04-15T06:11:16Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "diffHunk": "@@ -36,6 +37,49 @@ private ConcurrentUtils() {\n         // No instances.\n     }\n \n+    /**\n+     * Acquire a lock that allows reentry and attempts to acquire the lock while it is\n+     * held can be detected by {@link #releasePendingReentrantLock(AtomicLongFieldUpdater, long, Object)}.\n+     * @param lockUpdater The {@link AtomicLongFieldUpdater} used to control the lock state.\n+     * @param owner The owner of the lock object.\n+     * @param <T> The type of object that owns the lock.\n+     * @return {@code 0} if the acquire was unsuccessful, otherwise an identifier that must be passed to a subsequent\n+     * call of {@link #releasePendingReentrantLock(AtomicLongFieldUpdater, long, Object)}.\n+     */\n+    public static <T> long acquirePendingReentrantLock(final AtomicLongFieldUpdater<T> lockUpdater, final T owner) {\n+        final long threadId = Thread.currentThread().getId();\n+        for (;;) {\n+            final long prevThreadId = lockUpdater.get(owner);\n+            if (prevThreadId == 0) {\n+                if (lockUpdater.compareAndSet(owner, 0, threadId)) {\n+                    return threadId;\n+                }\n+            } else if (prevThreadId == threadId || prevThreadId == -threadId) {\n+                return -threadId;\n+            } else if (lockUpdater.compareAndSet(owner, prevThreadId,\n+                    prevThreadId > 0 ? -prevThreadId : prevThreadId)) {\n+                return 0;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Release a lock that was previously acquired via\n+     * {@link #acquirePendingReentrantLock(AtomicLongFieldUpdater, Object)}.\n+     * @param lockUpdater The {@link AtomicLongFieldUpdater} used to control the lock state.\n+     * @param acquireId The value returned from the previous call to\n+     * {@link #acquirePendingReentrantLock(AtomicLongFieldUpdater, Object)}.\n+     * @param owner The owner of the lock object.\n+     * @param <T> The type of object that owns the lock.\n+     * @return {@code true} if the lock was released, or this method call corresponds to a prior re-entrant call\n+     * to {@link #acquirePendingReentrantLock(AtomicLongFieldUpdater, Object)}.\n+     */\n+    public static <T> boolean releasePendingReentrantLock(final AtomicLongFieldUpdater<T> lockUpdater,\n+                                                          final long acquireId, final T owner) {\n+        assert acquireId != 0;\n+        return acquireId < 0 || lockUpdater.getAndSet(owner, 0) == acquireId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7a6ca3fad3fd46ba377f7e97ae4d492919886f0"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwMjc2Nw==", "bodyText": "nit: Imho chaining stuff like this is really not readable. Consider using a branch", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r408602767", "createdAt": "2020-04-15T06:12:51Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentSubscription.java", "diffHunk": "@@ -71,74 +74,59 @@ public static ConcurrentSubscription wrap(Subscription subscription) {\n     @Override\n     public void request(long n) {\n         if (!isRequestNValid(n)) {\n-            // With invalid input we don't attempt to enforce concurrency and rely upon the subscription\n-            // to enforce the specification rules [1].\n-            // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.1/README.md#3.9.\n-            subscription.request(n);\n-            return;\n-        }\n-        final Thread currentThread = Thread.currentThread();\n-        if (currentThread == subscriptionLockOwner) {\n-            subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                    FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-            return;\n-        }\n-        do {\n-            if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                // It is possible that we picked up a negative value from the queue on the previous iteration because\n-                // we have been cancelled in another thread, and in this case we don't want to increment the queue and\n-                // instead we just set to MIN_VALUE again and try to re-acquire the lock in case we raced again.\n-                if (n < 0) {\n-                    subscriptionRequestQueueUpdater.set(this, Long.MIN_VALUE);\n-                } else {\n-                    subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                            FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-                }\n-                if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                    return;\n-                }\n-                // We previously added our n contribution to the queue, but now that we have acquired the lock\n-                // we are responsible for draining the queue.\n-                n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                if (n == 0) {\n-                    // It is possible that the previous consumer has released the lock, and drained the queue before we\n-                    // acquired the lock and drained the queue. This means we have acquired the lock, but the queue has\n-                    // already been drained to 0. We should release the lock, try to drain the queue again, and then\n-                    // loop to acquire the lock if there are elements to drain.\n-                    subscriptionLockOwner = null;\n-                    n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                    if (n == 0) {\n-                        return;\n-                    } else {\n-                        continue;\n-                    }\n+            pendingDemand = mapInvalidRequestN(n);\n+        } else {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand < 0 ||\n+                        pendingDemandUpdater.compareAndSet(this, prevPendingDemand,\n+                                prevPendingDemand + min(Long.MAX_VALUE - prevPendingDemand, n))) {\n+                    break;\n                 }\n             }\n-            if (n < 0) {\n-                subscription.cancel();\n-                return; // Don't set subscriptionLockOwner = 0 ... we don't want to request any more!\n+        }\n+        Throwable delayedCause = null;\n+        for (;;) {\n+            final long acquireId = acquirePendingReentrantLock(subscriptionLockUpdater, this);\n+            if (acquireId == 0) {\n+                break;\n             }\n+\n             try {\n-                subscription.request(n);\n+                final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                if (prevPendingDemand == CANCELLED) {\n+                    subscription.cancel();\n+                } else if (prevPendingDemand != 0) {\n+                    subscription.request(prevPendingDemand);\n+                }\n+            } catch (Throwable cause) {\n+                if (delayedCause == null) {\n+                    delayedCause = cause;\n+                }\n             } finally {\n-                subscriptionLockOwner = null;\n+                if (releasePendingReentrantLock(subscriptionLockUpdater, acquireId, this)) {\n+                    break;\n+                }\n             }\n-            n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-        } while (n != 0);\n+        }\n+\n+        if (delayedCause != null) {\n+            throwException(delayedCause);\n+        }\n     }\n \n     @Override\n     public void cancel() {\n-        // Set the queue to MIN_VALUE and this will be detected in request(n).\n-        // We unconditionally set this value just in case there is re-entry with request(n) we will avoid calling\n-        // the subscription's request(n) after cancel().\n-        subscriptionRequestQueueUpdater.set(this, Long.MIN_VALUE);\n-\n-        final Thread currentThread = Thread.currentThread();\n-        final Thread subscriptionLockOwner = this.subscriptionLockOwner;\n-        if (subscriptionLockOwner == currentThread || subscriptionLockOwnerUpdater.compareAndSet(this, null,\n-                currentThread)) {\n+        pendingDemand = CANCELLED;\n+        if (acquirePendingReentrantLock(subscriptionLockUpdater, this) != 0) {\n             subscription.cancel();\n+            // poison subscriptionLockUpdater\n         }\n     }\n+\n+    private static long mapInvalidRequestN(long n) {\n+        // We map zero to a negative number because zero could later be overwritten by a subsequent legit value of\n+        // n, and we want to ensure the invalid use gets propagated.\n+        return n == CANCELLED ? CANCELLED + 1 : n == 0 ? -1 : n;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7a6ca3fad3fd46ba377f7e97ae4d492919886f0"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwMjk0Nw==", "bodyText": "should we use addSuppressed(...) if delayCause != null ?", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r408602947", "createdAt": "2020-04-15T06:13:24Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentSubscription.java", "diffHunk": "@@ -71,74 +74,59 @@ public static ConcurrentSubscription wrap(Subscription subscription) {\n     @Override\n     public void request(long n) {\n         if (!isRequestNValid(n)) {\n-            // With invalid input we don't attempt to enforce concurrency and rely upon the subscription\n-            // to enforce the specification rules [1].\n-            // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.1/README.md#3.9.\n-            subscription.request(n);\n-            return;\n-        }\n-        final Thread currentThread = Thread.currentThread();\n-        if (currentThread == subscriptionLockOwner) {\n-            subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                    FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-            return;\n-        }\n-        do {\n-            if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                // It is possible that we picked up a negative value from the queue on the previous iteration because\n-                // we have been cancelled in another thread, and in this case we don't want to increment the queue and\n-                // instead we just set to MIN_VALUE again and try to re-acquire the lock in case we raced again.\n-                if (n < 0) {\n-                    subscriptionRequestQueueUpdater.set(this, Long.MIN_VALUE);\n-                } else {\n-                    subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                            FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-                }\n-                if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                    return;\n-                }\n-                // We previously added our n contribution to the queue, but now that we have acquired the lock\n-                // we are responsible for draining the queue.\n-                n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                if (n == 0) {\n-                    // It is possible that the previous consumer has released the lock, and drained the queue before we\n-                    // acquired the lock and drained the queue. This means we have acquired the lock, but the queue has\n-                    // already been drained to 0. We should release the lock, try to drain the queue again, and then\n-                    // loop to acquire the lock if there are elements to drain.\n-                    subscriptionLockOwner = null;\n-                    n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                    if (n == 0) {\n-                        return;\n-                    } else {\n-                        continue;\n-                    }\n+            pendingDemand = mapInvalidRequestN(n);\n+        } else {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand < 0 ||\n+                        pendingDemandUpdater.compareAndSet(this, prevPendingDemand,\n+                                prevPendingDemand + min(Long.MAX_VALUE - prevPendingDemand, n))) {\n+                    break;\n                 }\n             }\n-            if (n < 0) {\n-                subscription.cancel();\n-                return; // Don't set subscriptionLockOwner = 0 ... we don't want to request any more!\n+        }\n+        Throwable delayedCause = null;\n+        for (;;) {\n+            final long acquireId = acquirePendingReentrantLock(subscriptionLockUpdater, this);\n+            if (acquireId == 0) {\n+                break;\n             }\n+\n             try {\n-                subscription.request(n);\n+                final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                if (prevPendingDemand == CANCELLED) {\n+                    subscription.cancel();\n+                } else if (prevPendingDemand != 0) {\n+                    subscription.request(prevPendingDemand);\n+                }\n+            } catch (Throwable cause) {\n+                if (delayedCause == null) {\n+                    delayedCause = cause;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7a6ca3fad3fd46ba377f7e97ae4d492919886f0"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYwMzEyMg==", "bodyText": "nit: why this change ?", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r408603122", "createdAt": "2020-04-15T06:13:55Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/test/java/io/servicetalk/concurrent/api/PublisherFlatMapSingleTest.java", "diffHunk": "@@ -67,7 +67,7 @@\n \n public class PublisherFlatMapSingleTest {\n     @Rule\n-    public final Timeout timeout = new ServiceTalkTestTimeout(30, SECONDS);\n+    public final Timeout timeout = new ServiceTalkTestTimeout();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7a6ca3fad3fd46ba377f7e97ae4d492919886f0"}, "originalPosition": 18}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c974240d6d098a9132e886e3ac5c87675949f275", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/c974240d6d098a9132e886e3ac5c87675949f275", "committedDate": "2020-04-16T01:33:40Z", "message": "suppress warning"}, "afterCommit": {"oid": "825e5c2c280ab021b10aefbeeb761f4513703fd5", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/825e5c2c280ab021b10aefbeeb761f4513703fd5", "committedDate": "2020-04-28T03:56:06Z", "message": "ConcurrentSubscripiton avoid concurrent access for invalid demand\n\nMotivation:\nConcurrentSubscription currently propagates invalid demand without any\nconcurrency protection. In general this is invalid use of the API but\nmay invalidate underlying data structures that are not thread safe and\nresult in undefined results.\n\nModifications:\n- Use a simpler locking scheme inspired by Publisher#flatMapMerge design\nwhich allows for re-entry and also notification is another thread has\nattempted to acquire the lock which will trigger re-processing.\n\nResult:\nConcurrentSubscripiton no longer allows any concurrent access and uses a\nmore common/shareable locking utility."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "825e5c2c280ab021b10aefbeeb761f4513703fd5", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/825e5c2c280ab021b10aefbeeb761f4513703fd5", "committedDate": "2020-04-28T03:56:06Z", "message": "ConcurrentSubscripiton avoid concurrent access for invalid demand\n\nMotivation:\nConcurrentSubscription currently propagates invalid demand without any\nconcurrency protection. In general this is invalid use of the API but\nmay invalidate underlying data structures that are not thread safe and\nresult in undefined results.\n\nModifications:\n- Use a simpler locking scheme inspired by Publisher#flatMapMerge design\nwhich allows for re-entry and also notification is another thread has\nattempted to acquire the lock which will trigger re-processing.\n\nResult:\nConcurrentSubscripiton no longer allows any concurrent access and uses a\nmore common/shareable locking utility."}, "afterCommit": {"oid": "71b94a4a2c3d55e01781b69866d54807a7c64501", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/71b94a4a2c3d55e01781b69866d54807a7c64501", "committedDate": "2020-04-28T04:37:08Z", "message": "ConcurrentSubscripiton avoid concurrent access for invalid demand\n\nMotivation:\nConcurrentSubscription currently propagates invalid demand without any\nconcurrency protection. In general this is invalid use of the API but\nmay invalidate underlying data structures that are not thread safe and\nresult in undefined results.\n\nModifications:\n- Use a simpler locking scheme inspired by Publisher#flatMapMerge design\nwhich allows for re-entry and also notification is another thread has\nattempted to acquire the lock which will trigger re-processing.\n\nResult:\nConcurrentSubscripiton no longer allows any concurrent access and uses a\nmore common/shareable locking utility."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "71b94a4a2c3d55e01781b69866d54807a7c64501", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/71b94a4a2c3d55e01781b69866d54807a7c64501", "committedDate": "2020-04-28T04:37:08Z", "message": "ConcurrentSubscripiton avoid concurrent access for invalid demand\n\nMotivation:\nConcurrentSubscription currently propagates invalid demand without any\nconcurrency protection. In general this is invalid use of the API but\nmay invalidate underlying data structures that are not thread safe and\nresult in undefined results.\n\nModifications:\n- Use a simpler locking scheme inspired by Publisher#flatMapMerge design\nwhich allows for re-entry and also notification is another thread has\nattempted to acquire the lock which will trigger re-processing.\n\nResult:\nConcurrentSubscripiton no longer allows any concurrent access and uses a\nmore common/shareable locking utility."}, "afterCommit": {"oid": "064f892a42d2c6f8925d779057ad8936dc0bc0c6", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/064f892a42d2c6f8925d779057ad8936dc0bc0c6", "committedDate": "2020-04-28T04:55:23Z", "message": "ConcurrentSubscripiton avoid concurrent access for invalid demand\n\nMotivation:\nConcurrentSubscription currently propagates invalid demand without any\nconcurrency protection. In general this is invalid use of the API but\nmay invalidate underlying data structures that are not thread safe and\nresult in undefined results.\n\nModifications:\n- Use a simpler locking scheme inspired by Publisher#flatMapMerge design\nwhich allows for re-entry and also notification is another thread has\nattempted to acquire the lock which will trigger re-processing.\n\nResult:\nConcurrentSubscripiton no longer allows any concurrent access and uses a\nmore common/shareable locking utility."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyOTI5MzYx", "url": "https://github.com/apple/servicetalk/pull/1015#pullrequestreview-402929361", "createdAt": "2020-04-29T18:28:00Z", "commit": {"oid": "064f892a42d2c6f8925d779057ad8936dc0bc0c6"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODoyODowMVrOGOLnOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxODo1OTo1NVrOGOMxEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMzUxMg==", "bodyText": "thread IDs are reusable upon thread termination[1]. So, if a thread dies while acquiring the lock, this method will not be able to identify that situation. Did you consider this?\n[1]\n    /**\n     * Returns the identifier of this Thread.  The thread ID is a positive\n     * {@code long} number generated when this thread was created.\n     * The thread ID is unique and remains unchanged during its lifetime.\n     * When a thread is terminated, this thread ID may be reused.\n     *\n     * @return this thread's ID.\n     * @since 1.5\n     */\n    public long getId() {\n        return tid;\n    }", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417523512", "createdAt": "2020-04-29T18:28:01Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "diffHunk": "@@ -65,6 +76,49 @@ private ConcurrentUtils() {\n         return lockUpdater.getAndSet(owner, CONCURRENT_IDLE) == CONCURRENT_EMITTING;\n     }\n \n+    /**\n+     * Acquire a lock that allows reentry and attempts to acquire the lock while it is\n+     * held can be detected by {@link #releaseReentrantLock(AtomicLongFieldUpdater, long, Object)}.\n+     * @param lockUpdater The {@link AtomicLongFieldUpdater} used to control the lock state.\n+     * @param owner The owner of the lock object.\n+     * @param <T> The type of object that owns the lock.\n+     * @return {@code 0} if the acquire was unsuccessful, otherwise an identifier that must be passed to a subsequent\n+     * call of {@link #releaseReentrantLock(AtomicLongFieldUpdater, long, Object)}.\n+     */\n+    public static <T> long tryAcquireReentrantLock(final AtomicLongFieldUpdater<T> lockUpdater, final T owner) {\n+        final long threadId = Thread.currentThread().getId();\n+        for (;;) {\n+            final long prevThreadId = lockUpdater.get(owner);\n+            if (prevThreadId == REENTRANT_LOCK_ZERO_THREAD_ID) {\n+                if (lockUpdater.compareAndSet(owner, REENTRANT_LOCK_ZERO_THREAD_ID, threadId)) {\n+                    return threadId;\n+                }\n+            } else if (prevThreadId == threadId || prevThreadId == -threadId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "064f892a42d2c6f8925d779057ad8936dc0bc0c6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyOTk4NA==", "bodyText": "Is this any different than:\npendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtectionIfNotNegative);", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417529984", "createdAt": "2020-04-29T18:39:00Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentSubscription.java", "diffHunk": "@@ -71,74 +70,58 @@ public static ConcurrentSubscription wrap(Subscription subscription) {\n     @Override\n     public void request(long n) {\n         if (!isRequestNValid(n)) {\n-            // With invalid input we don't attempt to enforce concurrency and rely upon the subscription\n-            // to enforce the specification rules [1].\n-            // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.1/README.md#3.9.\n-            subscription.request(n);\n-            return;\n-        }\n-        final Thread currentThread = Thread.currentThread();\n-        if (currentThread == subscriptionLockOwner) {\n-            subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                    FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-            return;\n-        }\n-        do {\n-            if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                // It is possible that we picked up a negative value from the queue on the previous iteration because\n-                // we have been cancelled in another thread, and in this case we don't want to increment the queue and\n-                // instead we just set to MIN_VALUE again and try to re-acquire the lock in case we raced again.\n-                if (n < 0) {\n-                    subscriptionRequestQueueUpdater.set(this, Long.MIN_VALUE);\n-                } else {\n-                    subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                            FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-                }\n-                if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                    return;\n-                }\n-                // We previously added our n contribution to the queue, but now that we have acquired the lock\n-                // we are responsible for draining the queue.\n-                n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                if (n == 0) {\n-                    // It is possible that the previous consumer has released the lock, and drained the queue before we\n-                    // acquired the lock and drained the queue. This means we have acquired the lock, but the queue has\n-                    // already been drained to 0. We should release the lock, try to drain the queue again, and then\n-                    // loop to acquire the lock if there are elements to drain.\n-                    subscriptionLockOwner = null;\n-                    n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                    if (n == 0) {\n-                        return;\n-                    } else {\n-                        continue;\n-                    }\n+            pendingDemand = mapInvalidRequestN(n);\n+        } else {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand < 0 ||\n+                        pendingDemandUpdater.compareAndSet(this, prevPendingDemand,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "064f892a42d2c6f8925d779057ad8936dc0bc0c6"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUzNjc0OQ==", "bodyText": "Strangely there are no tests for ConcurrentSubscription \ud83d\ude2d .. can we add now since we are modifying the implementation?", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417536749", "createdAt": "2020-04-29T18:50:34Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentSubscription.java", "diffHunk": "@@ -33,21 +35,18 @@\n  * </a> rule. It also allows a custom {@link Cancellable} to be used in the event that there maybe multiple cancel\n  * operations which are linked, but we still need to prevent concurrent invocation of the {@link Subscription#cancel()}\n  * and {@link Subscription#cancel()} methods.\n- * <p>\n- * Be aware with invalid input to {@link #request(long)} we don't attempt to enforce concurrency and rely upon the\n- * subscription to enforce the specification\n- * <a href=\"https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.1/README.md#3.9\">3.9</a> rule.\n  */\n public class ConcurrentSubscription implements Subscription {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "064f892a42d2c6f8925d779057ad8936dc0bc0c6"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUzODM4OA==", "bodyText": "Do we need to allow reentrancy here? I am aware that request(n) can be reentrant but it seems like we can avoid allowing reentrancy and just request more when unrolling the stack like we usually do with other concurrent-queue-drain-pattern elsewhere. Am I missing something here?\n@Override\npublic void request(long n) {\n    if (!isRequestNValid(n)) {\n        pendingDemand = mapInvalidRequestN(n);\n    } else {\n        pendingDemandUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n    }\n    do {\n        if (!tryAcquireLock(subscriptionLockUpdater, this)) {\n            break;\n        }\n\n        final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n        if (prevPendingDemand == CANCELLED) {\n            subscription.cancel();\n        } else if (prevPendingDemand != 0) {\n            subscription.request(prevPendingDemand);\n        }\n    } while (!releaseLock(subscriptionLockUpdater, this));\n}\n\n@Override\npublic void cancel() {\n    pendingDemand = CANCELLED;\n    if (tryAcquireLock(subscriptionLockUpdater, this)) {\n        subscription.cancel();\n        // poison subscriptionLockUpdater\n    }\n}", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417538388", "createdAt": "2020-04-29T18:53:16Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentSubscription.java", "diffHunk": "@@ -71,74 +70,58 @@ public static ConcurrentSubscription wrap(Subscription subscription) {\n     @Override\n     public void request(long n) {\n         if (!isRequestNValid(n)) {\n-            // With invalid input we don't attempt to enforce concurrency and rely upon the subscription\n-            // to enforce the specification rules [1].\n-            // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.1/README.md#3.9.\n-            subscription.request(n);\n-            return;\n-        }\n-        final Thread currentThread = Thread.currentThread();\n-        if (currentThread == subscriptionLockOwner) {\n-            subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                    FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-            return;\n-        }\n-        do {\n-            if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                // It is possible that we picked up a negative value from the queue on the previous iteration because\n-                // we have been cancelled in another thread, and in this case we don't want to increment the queue and\n-                // instead we just set to MIN_VALUE again and try to re-acquire the lock in case we raced again.\n-                if (n < 0) {\n-                    subscriptionRequestQueueUpdater.set(this, Long.MIN_VALUE);\n-                } else {\n-                    subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                            FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-                }\n-                if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                    return;\n-                }\n-                // We previously added our n contribution to the queue, but now that we have acquired the lock\n-                // we are responsible for draining the queue.\n-                n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                if (n == 0) {\n-                    // It is possible that the previous consumer has released the lock, and drained the queue before we\n-                    // acquired the lock and drained the queue. This means we have acquired the lock, but the queue has\n-                    // already been drained to 0. We should release the lock, try to drain the queue again, and then\n-                    // loop to acquire the lock if there are elements to drain.\n-                    subscriptionLockOwner = null;\n-                    n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                    if (n == 0) {\n-                        return;\n-                    } else {\n-                        continue;\n-                    }\n+            pendingDemand = mapInvalidRequestN(n);\n+        } else {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand < 0 ||\n+                        pendingDemandUpdater.compareAndSet(this, prevPendingDemand,\n+                                prevPendingDemand + min(Long.MAX_VALUE - prevPendingDemand, n))) {\n+                    break;\n                 }\n             }\n-            if (n < 0) {\n-                subscription.cancel();\n-                return; // Don't set subscriptionLockOwner = 0 ... we don't want to request any more!\n+        }\n+        Throwable delayedCause = null;\n+        boolean tryAcquire;\n+        do {\n+            final long acquireId = tryAcquireReentrantLock(subscriptionLockUpdater, this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "064f892a42d2c6f8925d779057ad8936dc0bc0c6"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU0MTk4NA==", "bodyText": "Do we need to delay the throw from here?", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417541984", "createdAt": "2020-04-29T18:59:08Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentSubscription.java", "diffHunk": "@@ -71,74 +70,58 @@ public static ConcurrentSubscription wrap(Subscription subscription) {\n     @Override\n     public void request(long n) {\n         if (!isRequestNValid(n)) {\n-            // With invalid input we don't attempt to enforce concurrency and rely upon the subscription\n-            // to enforce the specification rules [1].\n-            // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.1/README.md#3.9.\n-            subscription.request(n);\n-            return;\n-        }\n-        final Thread currentThread = Thread.currentThread();\n-        if (currentThread == subscriptionLockOwner) {\n-            subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                    FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-            return;\n-        }\n-        do {\n-            if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                // It is possible that we picked up a negative value from the queue on the previous iteration because\n-                // we have been cancelled in another thread, and in this case we don't want to increment the queue and\n-                // instead we just set to MIN_VALUE again and try to re-acquire the lock in case we raced again.\n-                if (n < 0) {\n-                    subscriptionRequestQueueUpdater.set(this, Long.MIN_VALUE);\n-                } else {\n-                    subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                            FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-                }\n-                if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                    return;\n-                }\n-                // We previously added our n contribution to the queue, but now that we have acquired the lock\n-                // we are responsible for draining the queue.\n-                n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                if (n == 0) {\n-                    // It is possible that the previous consumer has released the lock, and drained the queue before we\n-                    // acquired the lock and drained the queue. This means we have acquired the lock, but the queue has\n-                    // already been drained to 0. We should release the lock, try to drain the queue again, and then\n-                    // loop to acquire the lock if there are elements to drain.\n-                    subscriptionLockOwner = null;\n-                    n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                    if (n == 0) {\n-                        return;\n-                    } else {\n-                        continue;\n-                    }\n+            pendingDemand = mapInvalidRequestN(n);\n+        } else {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand < 0 ||\n+                        pendingDemandUpdater.compareAndSet(this, prevPendingDemand,\n+                                prevPendingDemand + min(Long.MAX_VALUE - prevPendingDemand, n))) {\n+                    break;\n                 }\n             }\n-            if (n < 0) {\n-                subscription.cancel();\n-                return; // Don't set subscriptionLockOwner = 0 ... we don't want to request any more!\n+        }\n+        Throwable delayedCause = null;\n+        boolean tryAcquire;\n+        do {\n+            final long acquireId = tryAcquireReentrantLock(subscriptionLockUpdater, this);\n+            if (acquireId == 0) {\n+                break;\n             }\n+\n             try {\n-                subscription.request(n);\n+                final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                if (prevPendingDemand == CANCELLED) {\n+                    subscription.cancel();\n+                } else if (prevPendingDemand != 0) {\n+                    subscription.request(prevPendingDemand);\n+                }\n+            } catch (Throwable cause) {\n+                if (delayedCause == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "064f892a42d2c6f8925d779057ad8936dc0bc0c6"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU0MjQxOA==", "bodyText": "Perhaps we do not need to release if we throw, effectively poisoning the lock.", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r417542418", "createdAt": "2020-04-29T18:59:55Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentSubscription.java", "diffHunk": "@@ -71,74 +70,58 @@ public static ConcurrentSubscription wrap(Subscription subscription) {\n     @Override\n     public void request(long n) {\n         if (!isRequestNValid(n)) {\n-            // With invalid input we don't attempt to enforce concurrency and rely upon the subscription\n-            // to enforce the specification rules [1].\n-            // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.1/README.md#3.9.\n-            subscription.request(n);\n-            return;\n-        }\n-        final Thread currentThread = Thread.currentThread();\n-        if (currentThread == subscriptionLockOwner) {\n-            subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                    FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-            return;\n-        }\n-        do {\n-            if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                // It is possible that we picked up a negative value from the queue on the previous iteration because\n-                // we have been cancelled in another thread, and in this case we don't want to increment the queue and\n-                // instead we just set to MIN_VALUE again and try to re-acquire the lock in case we raced again.\n-                if (n < 0) {\n-                    subscriptionRequestQueueUpdater.set(this, Long.MIN_VALUE);\n-                } else {\n-                    subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                            FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-                }\n-                if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                    return;\n-                }\n-                // We previously added our n contribution to the queue, but now that we have acquired the lock\n-                // we are responsible for draining the queue.\n-                n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                if (n == 0) {\n-                    // It is possible that the previous consumer has released the lock, and drained the queue before we\n-                    // acquired the lock and drained the queue. This means we have acquired the lock, but the queue has\n-                    // already been drained to 0. We should release the lock, try to drain the queue again, and then\n-                    // loop to acquire the lock if there are elements to drain.\n-                    subscriptionLockOwner = null;\n-                    n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                    if (n == 0) {\n-                        return;\n-                    } else {\n-                        continue;\n-                    }\n+            pendingDemand = mapInvalidRequestN(n);\n+        } else {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand < 0 ||\n+                        pendingDemandUpdater.compareAndSet(this, prevPendingDemand,\n+                                prevPendingDemand + min(Long.MAX_VALUE - prevPendingDemand, n))) {\n+                    break;\n                 }\n             }\n-            if (n < 0) {\n-                subscription.cancel();\n-                return; // Don't set subscriptionLockOwner = 0 ... we don't want to request any more!\n+        }\n+        Throwable delayedCause = null;\n+        boolean tryAcquire;\n+        do {\n+            final long acquireId = tryAcquireReentrantLock(subscriptionLockUpdater, this);\n+            if (acquireId == 0) {\n+                break;\n             }\n+\n             try {\n-                subscription.request(n);\n+                final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                if (prevPendingDemand == CANCELLED) {\n+                    subscription.cancel();\n+                } else if (prevPendingDemand != 0) {\n+                    subscription.request(prevPendingDemand);\n+                }\n+            } catch (Throwable cause) {\n+                if (delayedCause == null) {\n+                    delayedCause = cause;\n+                }\n             } finally {\n-                subscriptionLockOwner = null;\n+                tryAcquire = !releaseReentrantLock(subscriptionLockUpdater, acquireId, this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "064f892a42d2c6f8925d779057ad8936dc0bc0c6"}, "originalPosition": 126}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MjY5NTYx", "url": "https://github.com/apple/servicetalk/pull/1015#pullrequestreview-405269561", "createdAt": "2020-05-04T19:10:11Z", "commit": {"oid": "02f122472e10d09caf72e710213e3dd9519fd907"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxOToxMDoxMVrOGQORYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxOTozOTo1NlrOGQPTTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY2NDIyNw==", "bodyText": "Add an assert for releasing acquiredId2?\nassertTrue(releaseReentrantLock(reentrantLockUpdater, acquireId2, this));", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r419664227", "createdAt": "2020-05-04T19:10:11Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/test/java/io/servicetalk/concurrent/api/ConcurrentUtilsTest.java", "diffHunk": "@@ -56,13 +66,22 @@ public void tearDown() throws Exception {\n     }\n \n     @Test\n-    public void singleThread() {\n+    public void lockSingleThread() {\n         assertTrue(tryAcquireLock(lockUpdater, this));\n         assertTrue(releaseLock(lockUpdater, this));\n     }\n \n     @Test\n-    public void pendingFromDifferentThread() throws Exception {\n+    public void reentrantLockSingleThread() {\n+        long acquireId = tryAcquireReentrantLock(reentrantLockUpdater, this);\n+        assertThat(acquireId, greaterThan(0L));\n+        long acquireId2 = tryAcquireReentrantLock(reentrantLockUpdater, this);\n+        assertThat(acquireId2, is(-acquireId));\n+        assertTrue(releaseReentrantLock(reentrantLockUpdater, acquireId, this));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02f122472e10d09caf72e710213e3dd9519fd907"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY3NzU2OQ==", "bodyText": "Ok so I think this means that this method must only be called when used with try-finally and not across thread boundaries like we do in NettyPipelinedConnection.  If there are inherent assumptions like this then either we should mention it in the method name or in javadocs.", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r419677569", "createdAt": "2020-05-04T19:33:45Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "diffHunk": "@@ -65,6 +76,49 @@ private ConcurrentUtils() {\n         return lockUpdater.getAndSet(owner, CONCURRENT_IDLE) == CONCURRENT_EMITTING;\n     }\n \n+    /**\n+     * Acquire a lock that allows reentry and attempts to acquire the lock while it is\n+     * held can be detected by {@link #releaseReentrantLock(AtomicLongFieldUpdater, long, Object)}.\n+     * @param lockUpdater The {@link AtomicLongFieldUpdater} used to control the lock state.\n+     * @param owner The owner of the lock object.\n+     * @param <T> The type of object that owns the lock.\n+     * @return {@code 0} if the acquire was unsuccessful, otherwise an identifier that must be passed to a subsequent\n+     * call of {@link #releaseReentrantLock(AtomicLongFieldUpdater, long, Object)}.\n+     */\n+    public static <T> long tryAcquireReentrantLock(final AtomicLongFieldUpdater<T> lockUpdater, final T owner) {\n+        final long threadId = Thread.currentThread().getId();\n+        for (;;) {\n+            final long prevThreadId = lockUpdater.get(owner);\n+            if (prevThreadId == REENTRANT_LOCK_ZERO_THREAD_ID) {\n+                if (lockUpdater.compareAndSet(owner, REENTRANT_LOCK_ZERO_THREAD_ID, threadId)) {\n+                    return threadId;\n+                }\n+            } else if (prevThreadId == threadId || prevThreadId == -threadId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMzUxMg=="}, "originalCommit": {"oid": "064f892a42d2c6f8925d779057ad8936dc0bc0c6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY4MTEwMA==", "bodyText": "I am still not sure about the approach here of continuing to call the subscription if a previous call to it threw. If we are not comfortable about poisoning the lock then an alternate is to set the pending = CANCELLED and hence ignoring any subsequent calls. If we do this, then the fast-path in request(n) can also avoid calling drain() from inside a finally block.", "url": "https://github.com/apple/servicetalk/pull/1015#discussion_r419681100", "createdAt": "2020-05-04T19:39:56Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentSubscription.java", "diffHunk": "@@ -71,74 +70,58 @@ public static ConcurrentSubscription wrap(Subscription subscription) {\n     @Override\n     public void request(long n) {\n         if (!isRequestNValid(n)) {\n-            // With invalid input we don't attempt to enforce concurrency and rely upon the subscription\n-            // to enforce the specification rules [1].\n-            // [1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.1/README.md#3.9.\n-            subscription.request(n);\n-            return;\n-        }\n-        final Thread currentThread = Thread.currentThread();\n-        if (currentThread == subscriptionLockOwner) {\n-            subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                    FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-            return;\n-        }\n-        do {\n-            if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                // It is possible that we picked up a negative value from the queue on the previous iteration because\n-                // we have been cancelled in another thread, and in this case we don't want to increment the queue and\n-                // instead we just set to MIN_VALUE again and try to re-acquire the lock in case we raced again.\n-                if (n < 0) {\n-                    subscriptionRequestQueueUpdater.set(this, Long.MIN_VALUE);\n-                } else {\n-                    subscriptionRequestQueueUpdater.accumulateAndGet(this, n,\n-                            FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-                }\n-                if (!subscriptionLockOwnerUpdater.compareAndSet(this, null, currentThread)) {\n-                    return;\n-                }\n-                // We previously added our n contribution to the queue, but now that we have acquired the lock\n-                // we are responsible for draining the queue.\n-                n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                if (n == 0) {\n-                    // It is possible that the previous consumer has released the lock, and drained the queue before we\n-                    // acquired the lock and drained the queue. This means we have acquired the lock, but the queue has\n-                    // already been drained to 0. We should release the lock, try to drain the queue again, and then\n-                    // loop to acquire the lock if there are elements to drain.\n-                    subscriptionLockOwner = null;\n-                    n = subscriptionRequestQueueUpdater.getAndSet(this, 0);\n-                    if (n == 0) {\n-                        return;\n-                    } else {\n-                        continue;\n-                    }\n+            pendingDemand = mapInvalidRequestN(n);\n+        } else {\n+            for (;;) {\n+                final long prevPendingDemand = pendingDemand;\n+                if (prevPendingDemand < 0 ||\n+                        pendingDemandUpdater.compareAndSet(this, prevPendingDemand,\n+                                prevPendingDemand + min(Long.MAX_VALUE - prevPendingDemand, n))) {\n+                    break;\n                 }\n             }\n-            if (n < 0) {\n-                subscription.cancel();\n-                return; // Don't set subscriptionLockOwner = 0 ... we don't want to request any more!\n+        }\n+        Throwable delayedCause = null;\n+        boolean tryAcquire;\n+        do {\n+            final long acquireId = tryAcquireReentrantLock(subscriptionLockUpdater, this);\n+            if (acquireId == 0) {\n+                break;\n             }\n+\n             try {\n-                subscription.request(n);\n+                final long prevPendingDemand = pendingDemandUpdater.getAndSet(this, 0);\n+                if (prevPendingDemand == CANCELLED) {\n+                    subscription.cancel();\n+                } else if (prevPendingDemand != 0) {\n+                    subscription.request(prevPendingDemand);\n+                }\n+            } catch (Throwable cause) {\n+                if (delayedCause == null) {\n+                    delayedCause = cause;\n+                }\n             } finally {\n-                subscriptionLockOwner = null;\n+                tryAcquire = !releaseReentrantLock(subscriptionLockUpdater, acquireId, this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU0MjQxOA=="}, "originalCommit": {"oid": "064f892a42d2c6f8925d779057ad8936dc0bc0c6"}, "originalPosition": 126}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "02f122472e10d09caf72e710213e3dd9519fd907", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/02f122472e10d09caf72e710213e3dd9519fd907", "committedDate": "2020-05-02T15:01:37Z", "message": "add more tests"}, "afterCommit": {"oid": "d259d2c933b0adf9b4615d551b586e16f4003cf2", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/d259d2c933b0adf9b4615d551b586e16f4003cf2", "committedDate": "2020-05-04T21:02:23Z", "message": "review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8de868c4f849a44028cc4111f397379ac25b73b9", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/8de868c4f849a44028cc4111f397379ac25b73b9", "committedDate": "2020-05-04T22:50:12Z", "message": "ConcurrentSubscripiton avoid concurrent access for invalid demand\n\nMotivation:\nConcurrentSubscription currently propagates invalid demand without any\nconcurrency protection. In general this is invalid use of the API but\nmay invalidate underlying data structures that are not thread safe and\nresult in undefined results.\n\nModifications:\n- Use a simpler locking scheme inspired by Publisher#flatMapMerge design\nwhich allows for re-entry and also notification is another thread has\nattempted to acquire the lock which will trigger re-processing.\n\nResult:\nConcurrentSubscripiton no longer allows any concurrent access and uses a\nmore common/shareable locking utility."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "814dfa7d50f3c0cf9b564d1746ec6a636226af19", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/814dfa7d50f3c0cf9b564d1746ec6a636226af19", "committedDate": "2020-05-04T22:50:15Z", "message": "review feedback, tests, benchmark"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a372625d278af249a43030a211bc551893c62f2d", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/a372625d278af249a43030a211bc551893c62f2d", "committedDate": "2020-05-04T22:50:15Z", "message": "add fast path for no concurrency case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52b7130f2cb166c8819c580b49a34f11759c7d3a", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/52b7130f2cb166c8819c580b49a34f11759c7d3a", "committedDate": "2020-05-04T22:50:15Z", "message": "add more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71165d8e8ee4bd0e0e8362676335d74ad267c7f1", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/71165d8e8ee4bd0e0e8362676335d74ad267c7f1", "committedDate": "2020-05-04T22:50:15Z", "message": "more tests, split benchmarks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39cbe87a498513821420be402b3975ea39cf0e40", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/39cbe87a498513821420be402b3975ea39cf0e40", "committedDate": "2020-05-04T22:50:15Z", "message": "fix comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14ab4d2aba32b9090d5e4e2e009324a3672de9a7", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/14ab4d2aba32b9090d5e4e2e009324a3672de9a7", "committedDate": "2020-05-04T22:50:15Z", "message": "add more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c9f9252f3f59df6788f99b2cca4c8d9c865d8e4", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/5c9f9252f3f59df6788f99b2cca4c8d9c865d8e4", "committedDate": "2020-05-04T22:50:15Z", "message": "review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d259d2c933b0adf9b4615d551b586e16f4003cf2", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/d259d2c933b0adf9b4615d551b586e16f4003cf2", "committedDate": "2020-05-04T21:02:23Z", "message": "review comments"}, "afterCommit": {"oid": "5c9f9252f3f59df6788f99b2cca4c8d9c865d8e4", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/5c9f9252f3f59df6788f99b2cca4c8d9c865d8e4", "committedDate": "2020-05-04T22:50:15Z", "message": "review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "daf1ab72d5276adc774fe32e00c1563f6819c064", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/daf1ab72d5276adc774fe32e00c1563f6819c064", "committedDate": "2020-05-05T01:22:55Z", "message": "relax locking release strategy and exception catching"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NDUxMzcz", "url": "https://github.com/apple/servicetalk/pull/1015#pullrequestreview-405451373", "createdAt": "2020-05-05T01:38:57Z", "commit": {"oid": "1b93593b914b46b66c17759f4c337cb831bbcdfd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3622, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}