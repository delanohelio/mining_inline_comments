{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1NjQxOTQ5", "number": 1046, "title": "DelayedSubscription no longer uses ConcurrentSubscription internally", "bodyText": "Motivation:\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\nModifications:\n\nDelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nLess object allocation overhead introduced by DelayedSubscription.", "createdAt": "2020-05-09T23:01:13Z", "url": "https://github.com/apple/servicetalk/pull/1046", "merged": true, "mergeCommit": {"oid": "ca502e9976b526bd5facd9c64d05f4cf3e80f4f1"}, "closed": true, "closedAt": "2020-05-12T21:09:23Z", "author": {"login": "Scottmitch"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcfx_ELABqjMzMTk5MzE5MTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcgqCEiAH2gAyNDE1NjQxOTQ5OjFjYTMzYmMwNDczNTUxOWEzMWQ3ZWYwYjUyMmJkZmM0ZThmNzRjZWE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0168caeb49901b37ba8c3e6424193b3f26da7f4c", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/0168caeb49901b37ba8c3e6424193b3f26da7f4c", "committedDate": "2020-05-09T23:00:50Z", "message": "DelayedSubscription status and ConcurrentSubscription removal\n\nMotivation:\nDelayedSubscription#delayedSubscription doesn't indicate if the\nsubscription was successfully set. Users of this API may need to take\naction based upon this status (e.g. request more data upstream or not).\n\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription#delayedSubscription to return a boolean which\nindicates if the operation was successful.\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nMore status from DelayedSubscription and less object allocation overhead\nintroduced by DelayedSubscription."}, "afterCommit": {"oid": "015749c3379424f79525cb3a58daffaca113b09c", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/015749c3379424f79525cb3a58daffaca113b09c", "committedDate": "2020-05-10T02:51:48Z", "message": "DelayedSubscription status and ConcurrentSubscription removal\n\nMotivation:\nDelayedSubscription#delayedSubscription doesn't indicate if the\nsubscription was successfully set. Users of this API may need to take\naction based upon this status (e.g. request more data upstream or not).\n\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription#delayedSubscription to return a boolean which\nindicates if the operation was successful.\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nMore status from DelayedSubscription and less object allocation overhead\nintroduced by DelayedSubscription."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "015749c3379424f79525cb3a58daffaca113b09c", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/015749c3379424f79525cb3a58daffaca113b09c", "committedDate": "2020-05-10T02:51:48Z", "message": "DelayedSubscription status and ConcurrentSubscription removal\n\nMotivation:\nDelayedSubscription#delayedSubscription doesn't indicate if the\nsubscription was successfully set. Users of this API may need to take\naction based upon this status (e.g. request more data upstream or not).\n\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription#delayedSubscription to return a boolean which\nindicates if the operation was successful.\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nMore status from DelayedSubscription and less object allocation overhead\nintroduced by DelayedSubscription."}, "afterCommit": {"oid": "d23e3ce4972aec62c6c873de0753b609814e6d77", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/d23e3ce4972aec62c6c873de0753b609814e6d77", "committedDate": "2020-05-10T02:55:03Z", "message": "DelayedSubscription status and ConcurrentSubscription removal\n\nMotivation:\nDelayedSubscription#delayedSubscription doesn't indicate if the\nsubscription was successfully set. Users of this API may need to take\naction based upon this status (e.g. request more data upstream or not).\n\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription#delayedSubscription to return a boolean which\nindicates if the operation was successful.\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nMore status from DelayedSubscription and less object allocation overhead\nintroduced by DelayedSubscription."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d23e3ce4972aec62c6c873de0753b609814e6d77", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/d23e3ce4972aec62c6c873de0753b609814e6d77", "committedDate": "2020-05-10T02:55:03Z", "message": "DelayedSubscription status and ConcurrentSubscription removal\n\nMotivation:\nDelayedSubscription#delayedSubscription doesn't indicate if the\nsubscription was successfully set. Users of this API may need to take\naction based upon this status (e.g. request more data upstream or not).\n\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription#delayedSubscription to return a boolean which\nindicates if the operation was successful.\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nMore status from DelayedSubscription and less object allocation overhead\nintroduced by DelayedSubscription."}, "afterCommit": {"oid": "27248b97dd20cff013b118323f2fcf0811648678", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/27248b97dd20cff013b118323f2fcf0811648678", "committedDate": "2020-05-10T02:59:10Z", "message": "DelayedSubscription status and ConcurrentSubscription removal\n\nMotivation:\nDelayedSubscription#delayedSubscription doesn't indicate if the\nsubscription was successfully set. Users of this API may need to take\naction based upon this status (e.g. request more data upstream or not).\n\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription#delayedSubscription to return a boolean which\nindicates if the operation was successful.\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nMore status from DelayedSubscription and less object allocation overhead\nintroduced by DelayedSubscription."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "27248b97dd20cff013b118323f2fcf0811648678", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/27248b97dd20cff013b118323f2fcf0811648678", "committedDate": "2020-05-10T02:59:10Z", "message": "DelayedSubscription status and ConcurrentSubscription removal\n\nMotivation:\nDelayedSubscription#delayedSubscription doesn't indicate if the\nsubscription was successfully set. Users of this API may need to take\naction based upon this status (e.g. request more data upstream or not).\n\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription#delayedSubscription to return a boolean which\nindicates if the operation was successful.\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nMore status from DelayedSubscription and less object allocation overhead\nintroduced by DelayedSubscription."}, "afterCommit": {"oid": "2675899f2f37ccc9ba4f968dae221cc4b9303845", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/2675899f2f37ccc9ba4f968dae221cc4b9303845", "committedDate": "2020-05-10T03:03:00Z", "message": "DelayedSubscription status and ConcurrentSubscription removal\n\nMotivation:\nDelayedSubscription#delayedSubscription doesn't indicate if the\nsubscription was successfully set. Users of this API may need to take\naction based upon this status (e.g. request more data upstream or not).\n\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription#delayedSubscription to return a boolean which\nindicates if the operation was successful.\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nMore status from DelayedSubscription and less object allocation overhead\nintroduced by DelayedSubscription."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2675899f2f37ccc9ba4f968dae221cc4b9303845", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/2675899f2f37ccc9ba4f968dae221cc4b9303845", "committedDate": "2020-05-10T03:03:00Z", "message": "DelayedSubscription status and ConcurrentSubscription removal\n\nMotivation:\nDelayedSubscription#delayedSubscription doesn't indicate if the\nsubscription was successfully set. Users of this API may need to take\naction based upon this status (e.g. request more data upstream or not).\n\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription#delayedSubscription to return a boolean which\nindicates if the operation was successful.\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nMore status from DelayedSubscription and less object allocation overhead\nintroduced by DelayedSubscription."}, "afterCommit": {"oid": "fd20c144317fe13c6faf85623e8f6fb1db7eac0f", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/fd20c144317fe13c6faf85623e8f6fb1db7eac0f", "committedDate": "2020-05-10T03:04:52Z", "message": "DelayedSubscription status and ConcurrentSubscription removal\n\nMotivation:\nDelayedSubscription#delayedSubscription doesn't indicate if the\nsubscription was successfully set. Users of this API may need to take\naction based upon this status (e.g. request more data upstream or not).\n\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription#delayedSubscription to return a boolean which\nindicates if the operation was successful.\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nMore status from DelayedSubscription and less object allocation overhead\nintroduced by DelayedSubscription."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5Mzk4NTIw", "url": "https://github.com/apple/servicetalk/pull/1046#pullrequestreview-409398520", "createdAt": "2020-05-11T17:54:33Z", "commit": {"oid": "fd20c144317fe13c6faf85623e8f6fb1db7eac0f"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNzo1NDozM1rOGTnE6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNzo1NDozM1rOGTnE6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIxNjM2Mg==", "bodyText": "nit: I like to use << 1 etc", "url": "https://github.com/apple/servicetalk/pull/1046#discussion_r423216362", "createdAt": "2020-05-11T17:54:33Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java", "diffHunk": "@@ -18,84 +18,104 @@\n import io.servicetalk.concurrent.PublisherSource.Subscription;\n \n import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n import javax.annotation.Nullable;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n-import static io.servicetalk.concurrent.internal.EmptySubscription.EMPTY_SUBSCRIPTION;\n-import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n import static java.lang.Long.MIN_VALUE;\n-import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n \n /**\n  * A {@link Subscription} which serves as a placeholder until the \"real\" {@link Subscription} is available.\n  */\n public final class DelayedSubscription implements Subscription {\n-    private static final AtomicReferenceFieldUpdater<DelayedSubscription, Subscription> currentUpdater =\n-            newUpdater(DelayedSubscription.class, Subscription.class, \"current\");\n+    private static final long SUBSCRIPTION_SETTING = MIN_VALUE;\n+    private static final long SUBSCRIPTION_SET = MIN_VALUE + 1;\n+    private static final long SUBSCRIPTION_CANCEL_PENDING = MIN_VALUE + 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd20c144317fe13c6faf85623e8f6fb1db7eac0f"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NjExNzc5", "url": "https://github.com/apple/servicetalk/pull/1046#pullrequestreview-409611779", "createdAt": "2020-05-12T00:02:47Z", "commit": {"oid": "fd20c144317fe13c6faf85623e8f6fb1db7eac0f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwMDowMjo0N1rOGTxg1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwMDowMjo0N1rOGTxg1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM4NzM1MA==", "bodyText": "Considering the case:\n\nInitial requested == 0\nThread 1 invokes delayedSubscription, does requested = SUBSCRIPTION_SETTING.\nThread 2 does request(0), does requested = -1.\nThread 1 goes to the next for loop iteration and does delayedSubscription.request(-1) because prevRequested == -1.\nWhile both values 0 and -1 are illegal according to rule 3.9 it doesn't sound right that we change the original n value from 0 to -1. I'm not sure if this is acceptable or not.\nIf not, consider having another state that will represent request(0): REQUESTED_ZERO = SUBSCRIPTION_CANCEL_PENDING + 1.", "url": "https://github.com/apple/servicetalk/pull/1046#discussion_r423387350", "createdAt": "2020-05-12T00:02:47Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java", "diffHunk": "@@ -18,84 +18,104 @@\n import io.servicetalk.concurrent.PublisherSource.Subscription;\n \n import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n import javax.annotation.Nullable;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n-import static io.servicetalk.concurrent.internal.EmptySubscription.EMPTY_SUBSCRIPTION;\n-import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n import static java.lang.Long.MIN_VALUE;\n-import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n \n /**\n  * A {@link Subscription} which serves as a placeholder until the \"real\" {@link Subscription} is available.\n  */\n public final class DelayedSubscription implements Subscription {\n-    private static final AtomicReferenceFieldUpdater<DelayedSubscription, Subscription> currentUpdater =\n-            newUpdater(DelayedSubscription.class, Subscription.class, \"current\");\n+    private static final long SUBSCRIPTION_SETTING = MIN_VALUE;\n+    private static final long SUBSCRIPTION_SET = MIN_VALUE + 1;\n+    private static final long SUBSCRIPTION_CANCEL_PENDING = MIN_VALUE + 2;\n+    private static final long INVALID_GREATEST_VALUE = SUBSCRIPTION_CANCEL_PENDING;\n     private static final AtomicLongFieldUpdater<DelayedSubscription> requestedUpdater =\n-            AtomicLongFieldUpdater.newUpdater(DelayedSubscription.class, \"requested\");\n+            newUpdater(DelayedSubscription.class, \"requested\");\n \n-    @SuppressWarnings(\"unused\")\n     @Nullable\n-    private volatile Subscription current;\n-    @SuppressWarnings({\"unused\", \"FieldCanBeLocal\"})\n+    private Subscription subscription;\n     private volatile long requested;\n \n     /**\n      * Set the delayed {@link Subscription}. This method can only be called a single time and\n      * subsequent calls will result in {@link #cancel()} being called on {@code delayedSubscription}.\n      *\n      * @param delayedSubscription The delayed {@link Subscription}.\n+     * @return {@code true} if {@code delayedSubscription} was accepted as the delayed subscription. {@code false} if\n+     * this method had already been called and {@code delayedSubscription} has been {@link #cancel() cancelled}.\n      */\n-    public void delayedSubscription(Subscription delayedSubscription) {\n-        // Temporarily wrap in a ConcurrentSubscription to prevent concurrent invocation between this thread and\n-        // a thread which may be interacting with this class's Subscription API.\n-        final Subscription concurrentSubscription = wrap(delayedSubscription);\n-        if (!currentUpdater.compareAndSet(this, null, concurrentSubscription)) {\n-            delayedSubscription.cancel();\n-        } else {\n-            tryDrainRequested(concurrentSubscription);\n-\n-            // Unwrap the concurrent subscription because there will be no more concurrency.\n-            currentUpdater.compareAndSet(this, concurrentSubscription, delayedSubscription);\n+    public boolean delayedSubscription(Subscription delayedSubscription) {\n+        requireNonNull(delayedSubscription);\n+        for (;;) {\n+            final long prevRequested = requested;\n+            if (prevRequested <= INVALID_GREATEST_VALUE) {\n+                delayedSubscription.cancel();\n+                return false;\n+            } else if (requestedUpdater.compareAndSet(this, prevRequested, SUBSCRIPTION_SETTING)) {\n+                if (prevRequested != 0) {\n+                    delayedSubscription.request(prevRequested);\n+                }\n+                // Set the subscription before CAS to make it visible to the thread interacting with the Subscription.\n+                // The Subscription thread won't use the state unless the CAS to SUBSCRIPTION_SET is successful, so\n+                // there will be no concurrency introduced by this operation.\n+                subscription = delayedSubscription;\n+                if (requestedUpdater.compareAndSet(this, SUBSCRIPTION_SETTING, SUBSCRIPTION_SET)) {\n+                    return true;\n+                }\n+            }\n         }\n     }\n \n     @Override\n     public void request(long n) {\n-        Subscription current = this.current;\n-        if (current != null) {\n-            current.request(n);\n-        } else {\n-            if (isRequestNValid(n)) {\n-                requestedUpdater.accumulateAndGet(this, n, FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-            } else {\n-                // Although 0 is invalid we use it to signify that we have drained the pending request count,\n-                // so in this case we use MIN_VALUE so we can still pass through an invalid number only once.\n-                requested = n == 0 ? MIN_VALUE : n;\n-            }\n-            current = this.current;\n-            if (current != null) {\n-                tryDrainRequested(current);\n+        for (;;) {\n+            final long prevRequested = requested;\n+            if (prevRequested == SUBSCRIPTION_SET) {\n+                assert subscription != null;\n+                subscription.request(n);\n+                break;\n+            } else if (prevRequested == SUBSCRIPTION_SETTING) {\n+                if (requestedUpdater.compareAndSet(this, SUBSCRIPTION_SETTING, addRequestN(0, n))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd20c144317fe13c6faf85623e8f6fb1db7eac0f"}, "originalPosition": 101}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NjIzMjA4", "url": "https://github.com/apple/servicetalk/pull/1046#pullrequestreview-409623208", "createdAt": "2020-05-12T00:37:26Z", "commit": {"oid": "fd20c144317fe13c6faf85623e8f6fb1db7eac0f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwMDozNzoyNlrOGTyH5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwMDozNzoyNlrOGTyH5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM5NzM0OQ==", "bodyText": "I did a quick check on usages of this method and we always call it from onSubscribe(). Can we simply disallow calling this method twice? This will do two things:\n\nFail fast for unexpected usage (we do not expect this to be called more than once)\nSimplify contract (returned boolean should always be true)", "url": "https://github.com/apple/servicetalk/pull/1046#discussion_r423397349", "createdAt": "2020-05-12T00:37:26Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java", "diffHunk": "@@ -18,84 +18,104 @@\n import io.servicetalk.concurrent.PublisherSource.Subscription;\n \n import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n import javax.annotation.Nullable;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n-import static io.servicetalk.concurrent.internal.EmptySubscription.EMPTY_SUBSCRIPTION;\n-import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n import static java.lang.Long.MIN_VALUE;\n-import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n \n /**\n  * A {@link Subscription} which serves as a placeholder until the \"real\" {@link Subscription} is available.\n  */\n public final class DelayedSubscription implements Subscription {\n-    private static final AtomicReferenceFieldUpdater<DelayedSubscription, Subscription> currentUpdater =\n-            newUpdater(DelayedSubscription.class, Subscription.class, \"current\");\n+    private static final long SUBSCRIPTION_SETTING = MIN_VALUE;\n+    private static final long SUBSCRIPTION_SET = MIN_VALUE + 1;\n+    private static final long SUBSCRIPTION_CANCEL_PENDING = MIN_VALUE + 2;\n+    private static final long INVALID_GREATEST_VALUE = SUBSCRIPTION_CANCEL_PENDING;\n     private static final AtomicLongFieldUpdater<DelayedSubscription> requestedUpdater =\n-            AtomicLongFieldUpdater.newUpdater(DelayedSubscription.class, \"requested\");\n+            newUpdater(DelayedSubscription.class, \"requested\");\n \n-    @SuppressWarnings(\"unused\")\n     @Nullable\n-    private volatile Subscription current;\n-    @SuppressWarnings({\"unused\", \"FieldCanBeLocal\"})\n+    private Subscription subscription;\n     private volatile long requested;\n \n     /**\n      * Set the delayed {@link Subscription}. This method can only be called a single time and\n      * subsequent calls will result in {@link #cancel()} being called on {@code delayedSubscription}.\n      *\n      * @param delayedSubscription The delayed {@link Subscription}.\n+     * @return {@code true} if {@code delayedSubscription} was accepted as the delayed subscription. {@code false} if\n+     * this method had already been called and {@code delayedSubscription} has been {@link #cancel() cancelled}.\n      */\n-    public void delayedSubscription(Subscription delayedSubscription) {\n-        // Temporarily wrap in a ConcurrentSubscription to prevent concurrent invocation between this thread and\n-        // a thread which may be interacting with this class's Subscription API.\n-        final Subscription concurrentSubscription = wrap(delayedSubscription);\n-        if (!currentUpdater.compareAndSet(this, null, concurrentSubscription)) {\n-            delayedSubscription.cancel();\n-        } else {\n-            tryDrainRequested(concurrentSubscription);\n-\n-            // Unwrap the concurrent subscription because there will be no more concurrency.\n-            currentUpdater.compareAndSet(this, concurrentSubscription, delayedSubscription);\n+    public boolean delayedSubscription(Subscription delayedSubscription) {\n+        requireNonNull(delayedSubscription);\n+        for (;;) {\n+            final long prevRequested = requested;\n+            if (prevRequested <= INVALID_GREATEST_VALUE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd20c144317fe13c6faf85623e8f6fb1db7eac0f"}, "originalPosition": 60}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fd20c144317fe13c6faf85623e8f6fb1db7eac0f", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/fd20c144317fe13c6faf85623e8f6fb1db7eac0f", "committedDate": "2020-05-10T03:04:52Z", "message": "DelayedSubscription status and ConcurrentSubscription removal\n\nMotivation:\nDelayedSubscription#delayedSubscription doesn't indicate if the\nsubscription was successfully set. Users of this API may need to take\naction based upon this status (e.g. request more data upstream or not).\n\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription#delayedSubscription to return a boolean which\nindicates if the operation was successful.\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nMore status from DelayedSubscription and less object allocation overhead\nintroduced by DelayedSubscription."}, "afterCommit": {"oid": "5b9d23b5795c9a4291fe2abeff99430c866cc4c7", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/5b9d23b5795c9a4291fe2abeff99430c866cc4c7", "committedDate": "2020-05-12T00:57:37Z", "message": "DelayedSubscription ConcurrentSubscription removal\n\nMotivation:\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nLess object allocation overhead introduced by DelayedSubscription."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1805508ccdd26b5696800e275d1a5b3ce254159c", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/1805508ccdd26b5696800e275d1a5b3ce254159c", "committedDate": "2020-05-12T00:58:44Z", "message": "DelayedSubscription no longer uses ConcurrentSubscription internally\n\nMotivation:\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nLess object allocation overhead introduced by DelayedSubscription."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5b9d23b5795c9a4291fe2abeff99430c866cc4c7", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/5b9d23b5795c9a4291fe2abeff99430c866cc4c7", "committedDate": "2020-05-12T00:57:37Z", "message": "DelayedSubscription ConcurrentSubscription removal\n\nMotivation:\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nLess object allocation overhead introduced by DelayedSubscription."}, "afterCommit": {"oid": "1805508ccdd26b5696800e275d1a5b3ce254159c", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/1805508ccdd26b5696800e275d1a5b3ce254159c", "committedDate": "2020-05-12T00:58:44Z", "message": "DelayedSubscription no longer uses ConcurrentSubscription internally\n\nMotivation:\nDelayedSubscription allocates a ConcurrentSubscription internally to\navoid concurrent access on the subscrption when setting the delayed\nsubscription. This introdcues additional object allocations that can be\navoided.\n\nModifications:\n- DelayedSubscription no longer uses ConcurrentSubscription\n\nResult:\nLess object allocation overhead introduced by DelayedSubscription."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwMjA2ODI3", "url": "https://github.com/apple/servicetalk/pull/1046#pullrequestreview-410206827", "createdAt": "2020-05-12T16:17:20Z", "commit": {"oid": "1805508ccdd26b5696800e275d1a5b3ce254159c"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNjoxNzoyMFrOGUOg3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxOTowNzoyMVrOGUU-XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg2MjQ5Mw==", "bodyText": "more aggressive breaking change that could potentially break downstream onSubscribe propagation such that a subsequent onError is called without a prior onSubscribe\n\nThe scenario we are talking about is when onSubscribe() is called twice. Presumably the first onSubscribe() correctly went through to downstream, if so, then sending it the second time isn't really expected. Additionally, silently cancelling the Subscription is arguably less useful than bubbling up the error.\nDeferring the change sounds good if we are not going out of our way to support it.", "url": "https://github.com/apple/servicetalk/pull/1046#discussion_r423862493", "createdAt": "2020-05-12T16:17:20Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java", "diffHunk": "@@ -18,84 +18,104 @@\n import io.servicetalk.concurrent.PublisherSource.Subscription;\n \n import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n import javax.annotation.Nullable;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n-import static io.servicetalk.concurrent.internal.EmptySubscription.EMPTY_SUBSCRIPTION;\n-import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n import static java.lang.Long.MIN_VALUE;\n-import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n \n /**\n  * A {@link Subscription} which serves as a placeholder until the \"real\" {@link Subscription} is available.\n  */\n public final class DelayedSubscription implements Subscription {\n-    private static final AtomicReferenceFieldUpdater<DelayedSubscription, Subscription> currentUpdater =\n-            newUpdater(DelayedSubscription.class, Subscription.class, \"current\");\n+    private static final long SUBSCRIPTION_SETTING = MIN_VALUE;\n+    private static final long SUBSCRIPTION_SET = MIN_VALUE + 1;\n+    private static final long SUBSCRIPTION_CANCEL_PENDING = MIN_VALUE + 2;\n+    private static final long INVALID_GREATEST_VALUE = SUBSCRIPTION_CANCEL_PENDING;\n     private static final AtomicLongFieldUpdater<DelayedSubscription> requestedUpdater =\n-            AtomicLongFieldUpdater.newUpdater(DelayedSubscription.class, \"requested\");\n+            newUpdater(DelayedSubscription.class, \"requested\");\n \n-    @SuppressWarnings(\"unused\")\n     @Nullable\n-    private volatile Subscription current;\n-    @SuppressWarnings({\"unused\", \"FieldCanBeLocal\"})\n+    private Subscription subscription;\n     private volatile long requested;\n \n     /**\n      * Set the delayed {@link Subscription}. This method can only be called a single time and\n      * subsequent calls will result in {@link #cancel()} being called on {@code delayedSubscription}.\n      *\n      * @param delayedSubscription The delayed {@link Subscription}.\n+     * @return {@code true} if {@code delayedSubscription} was accepted as the delayed subscription. {@code false} if\n+     * this method had already been called and {@code delayedSubscription} has been {@link #cancel() cancelled}.\n      */\n-    public void delayedSubscription(Subscription delayedSubscription) {\n-        // Temporarily wrap in a ConcurrentSubscription to prevent concurrent invocation between this thread and\n-        // a thread which may be interacting with this class's Subscription API.\n-        final Subscription concurrentSubscription = wrap(delayedSubscription);\n-        if (!currentUpdater.compareAndSet(this, null, concurrentSubscription)) {\n-            delayedSubscription.cancel();\n-        } else {\n-            tryDrainRequested(concurrentSubscription);\n-\n-            // Unwrap the concurrent subscription because there will be no more concurrency.\n-            currentUpdater.compareAndSet(this, concurrentSubscription, delayedSubscription);\n+    public boolean delayedSubscription(Subscription delayedSubscription) {\n+        requireNonNull(delayedSubscription);\n+        for (;;) {\n+            final long prevRequested = requested;\n+            if (prevRequested <= INVALID_GREATEST_VALUE) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM5NzM0OQ=="}, "originalCommit": {"oid": "fd20c144317fe13c6faf85623e8f6fb1db7eac0f"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzg3NTQzMA==", "bodyText": "nit: INVALID_SMALLEST_VALUE is more appropriate as these are all negative values.", "url": "https://github.com/apple/servicetalk/pull/1046#discussion_r423875430", "createdAt": "2020-05-12T16:35:56Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java", "diffHunk": "@@ -18,28 +18,26 @@\n import io.servicetalk.concurrent.PublisherSource.Subscription;\n \n import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n import javax.annotation.Nullable;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n-import static io.servicetalk.concurrent.internal.EmptySubscription.EMPTY_SUBSCRIPTION;\n-import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n import static java.lang.Long.MIN_VALUE;\n-import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n \n /**\n  * A {@link Subscription} which serves as a placeholder until the \"real\" {@link Subscription} is available.\n  */\n public final class DelayedSubscription implements Subscription {\n-    private static final AtomicReferenceFieldUpdater<DelayedSubscription, Subscription> currentUpdater =\n-            newUpdater(DelayedSubscription.class, Subscription.class, \"current\");\n+    private static final long SUBSCRIPTION_SETTING = MIN_VALUE;\n+    private static final long SUBSCRIPTION_SET = MIN_VALUE + 1;\n+    private static final long SUBSCRIPTION_CANCEL_PENDING = MIN_VALUE + 2;\n+    private static final long INVALID_GREATEST_VALUE = SUBSCRIPTION_CANCEL_PENDING;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1805508ccdd26b5696800e275d1a5b3ce254159c"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk2ODM0OA==", "bodyText": "If you merge requested and Subscription fields in a single Object state then you can simplify the state-machine and reduce fields here.\n(requested handling may be simplified, I haven't thought about it, but this gives the idea of what I am suggesting)\npublic final class DelayedSubscription implements Subscription {\n    private static final AtomicReferenceFieldUpdater<DelayedSubscription, Object> stateUpdater =\n            AtomicReferenceFieldUpdater.newUpdater(DelayedSubscription.class, Object.class, \"state\");\n    private static final Object STATE_CANCELLED = new Object();\n    private static final Object STATE_TERMINATED = new Object();\n    private volatile Object state = 0L;\n\n    /**\n     * Set the delayed {@link Subscription}. This method can only be called a single time and\n     * subsequent calls will result in {@link #cancel()} being called on {@code delayedSubscription}.\n     *\n     * @param delayedSubscription The delayed {@link Subscription}.\n     */\n    public void delayedSubscription(Subscription delayedSubscription) {\n        requireNonNull(delayedSubscription);\n        for (;;) {\n            final Object cState = state;\n            if (cState == STATE_TERMINATED || cState instanceof Subscription) {\n                delayedSubscription.cancel();\n                return;\n            }\n            if (cState == STATE_CANCELLED && stateUpdater.compareAndSet(this, cState, STATE_TERMINATED)) {\n                delayedSubscription.cancel();\n                return;\n            }\n\n            if (cState instanceof Long && stateUpdater.compareAndSet(this, cState, 0L)) {\n                long requested = (Long) cState;\n                if (requested > 0 || requested == MIN_VALUE) {\n                    delayedSubscription.request(requested);\n                }\n                if (stateUpdater.compareAndSet(this, 0L, delayedSubscription)) {\n                    break;\n                }\n            }\n        }\n    }\n\n    @Override\n    public void request(long n) {\n        for (;;) {\n            final Object cState = state;\n            if (cState == STATE_CANCELLED || cState == STATE_TERMINATED) {\n                return;\n            }\n            if (cState instanceof Subscription) {\n                Subscription s = (Subscription) cState;\n                s.request(n);\n                return;\n            }\n            if (cState instanceof Long) {\n                Long prevReq = (Long) cState;\n                if (n > 0 &&\n                        stateUpdater.compareAndSet(this, cState, addWithOverflowProtectionIfNotNegative(prevReq, n))\n                        || n <= 0 && stateUpdater.compareAndSet(this, cState, MIN_VALUE)) {\n                    break;\n                }\n            }\n        }\n    }\n\n    @Override\n    public void cancel() {\n        for (;;) {\n            final Object cState = state;\n            if (cState == STATE_CANCELLED || cState == STATE_TERMINATED) {\n                return;\n            }\n            if (cState instanceof Subscription) {\n                Subscription s = (Subscription) cState;\n                s.cancel();\n                return;\n            }\n            if (cState instanceof Long && stateUpdater.compareAndSet(this, cState, STATE_CANCELLED)) {\n                return;\n            }\n        }\n    }\n}", "url": "https://github.com/apple/servicetalk/pull/1046#discussion_r423968348", "createdAt": "2020-05-12T19:07:21Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/DelayedSubscription.java", "diffHunk": "@@ -18,28 +18,26 @@\n import io.servicetalk.concurrent.PublisherSource.Subscription;\n \n import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n-import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n import javax.annotation.Nullable;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentSubscription.wrap;\n-import static io.servicetalk.concurrent.internal.EmptySubscription.EMPTY_SUBSCRIPTION;\n-import static io.servicetalk.concurrent.internal.SubscriberUtils.isRequestNValid;\n+import static io.servicetalk.concurrent.internal.FlowControlUtils.addWithOverflowProtection;\n import static java.lang.Long.MIN_VALUE;\n-import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicLongFieldUpdater.newUpdater;\n \n /**\n  * A {@link Subscription} which serves as a placeholder until the \"real\" {@link Subscription} is available.\n  */\n public final class DelayedSubscription implements Subscription {\n-    private static final AtomicReferenceFieldUpdater<DelayedSubscription, Subscription> currentUpdater =\n-            newUpdater(DelayedSubscription.class, Subscription.class, \"current\");\n+    private static final long SUBSCRIPTION_SETTING = MIN_VALUE;\n+    private static final long SUBSCRIPTION_SET = MIN_VALUE + 1;\n+    private static final long SUBSCRIPTION_CANCEL_PENDING = MIN_VALUE + 2;\n+    private static final long INVALID_GREATEST_VALUE = SUBSCRIPTION_CANCEL_PENDING;\n     private static final AtomicLongFieldUpdater<DelayedSubscription> requestedUpdater =\n-            AtomicLongFieldUpdater.newUpdater(DelayedSubscription.class, \"requested\");\n+            newUpdater(DelayedSubscription.class, \"requested\");\n \n-    @SuppressWarnings(\"unused\")\n     @Nullable\n-    private volatile Subscription current;\n-    @SuppressWarnings({\"unused\", \"FieldCanBeLocal\"})\n+    private Subscription subscription;\n     private volatile long requested;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1805508ccdd26b5696800e275d1a5b3ce254159c"}, "originalPosition": 35}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ca33bc04735519a31d7ef0b522bdfc4e8f74cea", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/1ca33bc04735519a31d7ef0b522bdfc4e8f74cea", "committedDate": "2020-05-12T20:09:56Z", "message": "INVALID_GREATEST_VALUE -> GREATEST_CONTROL_VALUE"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3680, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}