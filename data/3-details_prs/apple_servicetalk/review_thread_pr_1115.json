{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYxNzcwNzUy", "number": 1115, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMjowMzo0M1rOEUxb5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzoxMjoyOVrOEVPcPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMjE2OTMyOnYy", "diffSide": "RIGHT", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultSingleAddressHttpClientBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMjowMzo0M1rOG7KLjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzoxOTo0MFrOG7qBlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4NTk2NQ==", "bodyText": "It was pre-existing, but let's switch to beforeOnNext here to make sure we always clear the error-state earlier.", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r464685965", "createdAt": "2020-08-03T22:03:43Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultSingleAddressHttpClientBuilder.java", "diffHunk": "@@ -213,33 +209,37 @@ private DefaultSingleAddressHttpClientBuilder(@Nullable final U address,\n         final DefaultSingleAddressHttpClientBuilder<U, R> builder;\n         final HttpExecutionContext executionContext;\n         final StreamingHttpRequestResponseFactory reqRespFactory;\n+        final ServiceDiscoveryRetryStrategy<R, ? super ServiceDiscovererEvent<R>> serviceDiscovererRetryStrategy;\n         @Nullable\n         final U proxyAddress;\n \n-        HttpClientBuildContext(final DefaultSingleAddressHttpClientBuilder<U, R> builder,\n-                               final HttpExecutionContext executionContext,\n-                               final StreamingHttpRequestResponseFactory reqRespFactory,\n-                               @Nullable final U proxyAddress) {\n+        HttpClientBuildContext(\n+                final DefaultSingleAddressHttpClientBuilder<U, R> builder, final HttpExecutionContext executionContext,\n+                final StreamingHttpRequestResponseFactory reqRespFactory,\n+                @Nullable final ServiceDiscoveryRetryStrategy<R, ? super ServiceDiscovererEvent<R>> sdRetryStrategy,\n+                @Nullable final U proxyAddress) {\n             this.builder = builder;\n             this.executionContext = executionContext;\n             this.reqRespFactory = reqRespFactory;\n+            this.serviceDiscovererRetryStrategy = sdRetryStrategy == null ?\n+                    DefaultServiceDiscoveryRetryStrategy.Builder.<R>withDefaults(executionContext.executor(),\n+                            ofSeconds(60)).build() : sdRetryStrategy;\n             this.proxyAddress = proxyAddress;\n         }\n \n         Publisher<? extends ServiceDiscovererEvent<R>> discover() {\n             assert builder.address != null : \"Attempted to buildStreaming with an unknown address\";\n-            return builder.serviceDiscoverer.discover(\n-                    proxyAddress != null ? proxyAddress : builder.address);\n+            final Publisher<? extends ServiceDiscovererEvent<R>> sdEvents =\n+                    builder.serviceDiscoverer.discover(proxyAddress != null ? proxyAddress : builder.address);\n+            return serviceDiscovererRetryStrategy.apply(sdEvents);\n         }\n \n         Publisher<? extends ServiceDiscovererEvent<R>> discover(final SdStatusCompletable sdStatus) {\n             assert builder.address != null : \"Attempted to buildStreaming with an unknown address\";\n-            final BiIntFunction<Throwable, ? extends Completable> retryWhen = builder.serviceDiscovererRetryStrategy;\n-            return builder.serviceDiscoverer.discover(proxyAddress != null ? proxyAddress : builder.address)\n-                    .retryWhen((i, t) -> {\n-                        sdStatus.nextError(t);\n-                        return retryWhen.apply(i, t);\n-                    }).whenOnNext(__ -> sdStatus.resetError());\n+            final Publisher<? extends ServiceDiscovererEvent<R>> sdEvents =\n+                    builder.serviceDiscoverer.discover(proxyAddress != null ? proxyAddress : builder.address);\n+            return serviceDiscovererRetryStrategy.apply(sdEvents.beforeOnError(sdStatus::nextError))\n+                    .whenOnNext(__ -> sdStatus.resetError());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "253b274645a92923b2d8a2fe7aca54f220833b47"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNzcwMA==", "bodyText": "whenOnNext is an alias for beforeOnNext, but being explicit is better.", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r465207700", "createdAt": "2020-08-04T17:19:40Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultSingleAddressHttpClientBuilder.java", "diffHunk": "@@ -213,33 +209,37 @@ private DefaultSingleAddressHttpClientBuilder(@Nullable final U address,\n         final DefaultSingleAddressHttpClientBuilder<U, R> builder;\n         final HttpExecutionContext executionContext;\n         final StreamingHttpRequestResponseFactory reqRespFactory;\n+        final ServiceDiscoveryRetryStrategy<R, ? super ServiceDiscovererEvent<R>> serviceDiscovererRetryStrategy;\n         @Nullable\n         final U proxyAddress;\n \n-        HttpClientBuildContext(final DefaultSingleAddressHttpClientBuilder<U, R> builder,\n-                               final HttpExecutionContext executionContext,\n-                               final StreamingHttpRequestResponseFactory reqRespFactory,\n-                               @Nullable final U proxyAddress) {\n+        HttpClientBuildContext(\n+                final DefaultSingleAddressHttpClientBuilder<U, R> builder, final HttpExecutionContext executionContext,\n+                final StreamingHttpRequestResponseFactory reqRespFactory,\n+                @Nullable final ServiceDiscoveryRetryStrategy<R, ? super ServiceDiscovererEvent<R>> sdRetryStrategy,\n+                @Nullable final U proxyAddress) {\n             this.builder = builder;\n             this.executionContext = executionContext;\n             this.reqRespFactory = reqRespFactory;\n+            this.serviceDiscovererRetryStrategy = sdRetryStrategy == null ?\n+                    DefaultServiceDiscoveryRetryStrategy.Builder.<R>withDefaults(executionContext.executor(),\n+                            ofSeconds(60)).build() : sdRetryStrategy;\n             this.proxyAddress = proxyAddress;\n         }\n \n         Publisher<? extends ServiceDiscovererEvent<R>> discover() {\n             assert builder.address != null : \"Attempted to buildStreaming with an unknown address\";\n-            return builder.serviceDiscoverer.discover(\n-                    proxyAddress != null ? proxyAddress : builder.address);\n+            final Publisher<? extends ServiceDiscovererEvent<R>> sdEvents =\n+                    builder.serviceDiscoverer.discover(proxyAddress != null ? proxyAddress : builder.address);\n+            return serviceDiscovererRetryStrategy.apply(sdEvents);\n         }\n \n         Publisher<? extends ServiceDiscovererEvent<R>> discover(final SdStatusCompletable sdStatus) {\n             assert builder.address != null : \"Attempted to buildStreaming with an unknown address\";\n-            final BiIntFunction<Throwable, ? extends Completable> retryWhen = builder.serviceDiscovererRetryStrategy;\n-            return builder.serviceDiscoverer.discover(proxyAddress != null ? proxyAddress : builder.address)\n-                    .retryWhen((i, t) -> {\n-                        sdStatus.nextError(t);\n-                        return retryWhen.apply(i, t);\n-                    }).whenOnNext(__ -> sdStatus.resetError());\n+            final Publisher<? extends ServiceDiscovererEvent<R>> sdEvents =\n+                    builder.serviceDiscoverer.discover(proxyAddress != null ? proxyAddress : builder.address);\n+            return serviceDiscovererRetryStrategy.apply(sdEvents.beforeOnError(sdStatus::nextError))\n+                    .whenOnNext(__ -> sdStatus.resetError());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4NTk2NQ=="}, "originalCommit": {"oid": "253b274645a92923b2d8a2fe7aca54f220833b47"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMjE5OTMyOnYy", "diffSide": "RIGHT", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMjoxNTo0MFrOG7KdSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMjoxNTo0MFrOG7KdSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5MDUwNw==", "bodyText": "Missed javadoc", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r464690507", "createdAt": "2020-08-03T22:15:40Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscoverer;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.partition.PartitionAttributes;\n+import io.servicetalk.client.api.partition.PartitionedServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.BiIntFunction;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.UnaryOperator;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.RetryStrategies.retryWithExponentialBackoffAndJitter;\n+import static java.lang.Math.ceil;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default implementation for {@link ServiceDiscoveryRetryStrategy}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+ */\n+public final class DefaultServiceDiscoveryRetryStrategy<ResolvedAddress,\n+        E extends ServiceDiscovererEvent<ResolvedAddress>>\n+        implements ServiceDiscoveryRetryStrategy<ResolvedAddress, E> {\n+    private final int retainTillReceivePercentage;\n+    private final UnaryOperator<E> flipAvailability;\n+    private final BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+\n+    private DefaultServiceDiscoveryRetryStrategy(final int retainTillReceivePercentage,\n+                                                 final UnaryOperator<E> flipAvailability,\n+                                                 final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+        this.retainTillReceivePercentage = retainTillReceivePercentage;\n+        this.flipAvailability = requireNonNull(flipAvailability);\n+        this.retryStrategy = requireNonNull(retryStrategy);\n+    }\n+\n+    @Override\n+    public Publisher<? extends E> apply(final Publisher<? extends E> sdEvents) {\n+        return defer(() -> {\n+            EventsCache<ResolvedAddress, E> eventsCache =\n+                    new EventsCache<>(retainTillReceivePercentage, flipAvailability);\n+            return sdEvents.flatMapConcatIterable(eventsCache::consume)\n+                    .beforeOnError(__ -> eventsCache.errorSeen())\n+                    .retryWhen(retryStrategy);\n+        });\n+    }\n+\n+    /**\n+     * A builder to build instances of {@link DefaultServiceDiscoveryRetryStrategy}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution.\n+     * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+     */\n+    public static final class Builder<ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> {\n+        // There is no reason for the choice of 75%, it is arbitrary and can be configured by users.\n+        private int retainTillReceivePercentage = 75;\n+        private BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        private Builder(final BiIntFunction<Throwable, ? extends Completable> retryStrategy,\n+                        final UnaryOperator<E> flipAvailability) {\n+            this.retryStrategy = retryStrategy;\n+            this.flipAvailability = requireNonNull(flipAvailability);\n+        }\n+\n+        /**\n+         * A {@link Publisher} returned from {@link ServiceDiscoverer#discover(Object)} may fail transiently leaving the\n+         * consumer of these events with an option of either disposing the addresses that were provided before the\n+         * error or retain them till a retry succeeds. This option enables retention of addresses after an error is\n+         * observed till the total number of received addresses after an error is {@code retainTillReceivePercentage}\n+         * percent of the addresses that were available before the error was received.\n+         *\n+         * @param retainTillReceivePercentage A percentage of addresses that were received before an error that should\n+         * be received after a success, after which unreceived addresses are removed by sending appropriate\n+         * {@link ServiceDiscovererEvent}s. When set to {@code 0}, addresses are not retained.\n+         * @return {@code this}.\n+         */\n+        public Builder<ResolvedAddress, E> retainAddressesTillSuccess(final int retainTillReceivePercentage) {\n+            if (retainTillReceivePercentage < 0) {\n+                throw new IllegalArgumentException(\"retainTillReceivePercentage: \" + retainTillReceivePercentage +\n+                        \" (expected >= 0)\");\n+            }\n+            this.retainTillReceivePercentage = retainTillReceivePercentage;\n+            return this;\n+        }\n+\n+        public Builder<ResolvedAddress, E> retryStrategy(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "253b274645a92923b2d8a2fe7aca54f220833b47"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMjIwMzEyOnYy", "diffSide": "RIGHT", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMjoxNzoyM1rOG7Kfig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTowMzo1MVrOG7tjvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5MTA4Mg==", "bodyText": "using the passed {@link BiFunction}\n\nThis method doesn't take any arguments, should we say \"pre-configured\" instead of \"passed\" or reword in any other way?", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r464691082", "createdAt": "2020-08-03T22:17:23Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscoverer;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.partition.PartitionAttributes;\n+import io.servicetalk.client.api.partition.PartitionedServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.BiIntFunction;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.UnaryOperator;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.RetryStrategies.retryWithExponentialBackoffAndJitter;\n+import static java.lang.Math.ceil;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default implementation for {@link ServiceDiscoveryRetryStrategy}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+ */\n+public final class DefaultServiceDiscoveryRetryStrategy<ResolvedAddress,\n+        E extends ServiceDiscovererEvent<ResolvedAddress>>\n+        implements ServiceDiscoveryRetryStrategy<ResolvedAddress, E> {\n+    private final int retainTillReceivePercentage;\n+    private final UnaryOperator<E> flipAvailability;\n+    private final BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+\n+    private DefaultServiceDiscoveryRetryStrategy(final int retainTillReceivePercentage,\n+                                                 final UnaryOperator<E> flipAvailability,\n+                                                 final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+        this.retainTillReceivePercentage = retainTillReceivePercentage;\n+        this.flipAvailability = requireNonNull(flipAvailability);\n+        this.retryStrategy = requireNonNull(retryStrategy);\n+    }\n+\n+    @Override\n+    public Publisher<? extends E> apply(final Publisher<? extends E> sdEvents) {\n+        return defer(() -> {\n+            EventsCache<ResolvedAddress, E> eventsCache =\n+                    new EventsCache<>(retainTillReceivePercentage, flipAvailability);\n+            return sdEvents.flatMapConcatIterable(eventsCache::consume)\n+                    .beforeOnError(__ -> eventsCache.errorSeen())\n+                    .retryWhen(retryStrategy);\n+        });\n+    }\n+\n+    /**\n+     * A builder to build instances of {@link DefaultServiceDiscoveryRetryStrategy}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution.\n+     * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+     */\n+    public static final class Builder<ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> {\n+        // There is no reason for the choice of 75%, it is arbitrary and can be configured by users.\n+        private int retainTillReceivePercentage = 75;\n+        private BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        private Builder(final BiIntFunction<Throwable, ? extends Completable> retryStrategy,\n+                        final UnaryOperator<E> flipAvailability) {\n+            this.retryStrategy = retryStrategy;\n+            this.flipAvailability = requireNonNull(flipAvailability);\n+        }\n+\n+        /**\n+         * A {@link Publisher} returned from {@link ServiceDiscoverer#discover(Object)} may fail transiently leaving the\n+         * consumer of these events with an option of either disposing the addresses that were provided before the\n+         * error or retain them till a retry succeeds. This option enables retention of addresses after an error is\n+         * observed till the total number of received addresses after an error is {@code retainTillReceivePercentage}\n+         * percent of the addresses that were available before the error was received.\n+         *\n+         * @param retainTillReceivePercentage A percentage of addresses that were received before an error that should\n+         * be received after a success, after which unreceived addresses are removed by sending appropriate\n+         * {@link ServiceDiscovererEvent}s. When set to {@code 0}, addresses are not retained.\n+         * @return {@code this}.\n+         */\n+        public Builder<ResolvedAddress, E> retainAddressesTillSuccess(final int retainTillReceivePercentage) {\n+            if (retainTillReceivePercentage < 0) {\n+                throw new IllegalArgumentException(\"retainTillReceivePercentage: \" + retainTillReceivePercentage +\n+                        \" (expected >= 0)\");\n+            }\n+            this.retainTillReceivePercentage = retainTillReceivePercentage;\n+            return this;\n+        }\n+\n+        public Builder<ResolvedAddress, E> retryStrategy(\n+                final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+            this.retryStrategy = requireNonNull(retryStrategy);\n+            return this;\n+        }\n+\n+        /**\n+         * Creates a new {@link ServiceDiscoveryRetryStrategy} using the passed {@link BiFunction} which is applied", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "253b274645a92923b2d8a2fe7aca54f220833b47"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI2NTU5OQ==", "bodyText": "My bad; this was left over from a refactor.", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r465265599", "createdAt": "2020-08-04T19:03:51Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscoverer;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.partition.PartitionAttributes;\n+import io.servicetalk.client.api.partition.PartitionedServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.BiIntFunction;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.UnaryOperator;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.RetryStrategies.retryWithExponentialBackoffAndJitter;\n+import static java.lang.Math.ceil;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default implementation for {@link ServiceDiscoveryRetryStrategy}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+ */\n+public final class DefaultServiceDiscoveryRetryStrategy<ResolvedAddress,\n+        E extends ServiceDiscovererEvent<ResolvedAddress>>\n+        implements ServiceDiscoveryRetryStrategy<ResolvedAddress, E> {\n+    private final int retainTillReceivePercentage;\n+    private final UnaryOperator<E> flipAvailability;\n+    private final BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+\n+    private DefaultServiceDiscoveryRetryStrategy(final int retainTillReceivePercentage,\n+                                                 final UnaryOperator<E> flipAvailability,\n+                                                 final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+        this.retainTillReceivePercentage = retainTillReceivePercentage;\n+        this.flipAvailability = requireNonNull(flipAvailability);\n+        this.retryStrategy = requireNonNull(retryStrategy);\n+    }\n+\n+    @Override\n+    public Publisher<? extends E> apply(final Publisher<? extends E> sdEvents) {\n+        return defer(() -> {\n+            EventsCache<ResolvedAddress, E> eventsCache =\n+                    new EventsCache<>(retainTillReceivePercentage, flipAvailability);\n+            return sdEvents.flatMapConcatIterable(eventsCache::consume)\n+                    .beforeOnError(__ -> eventsCache.errorSeen())\n+                    .retryWhen(retryStrategy);\n+        });\n+    }\n+\n+    /**\n+     * A builder to build instances of {@link DefaultServiceDiscoveryRetryStrategy}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution.\n+     * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+     */\n+    public static final class Builder<ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> {\n+        // There is no reason for the choice of 75%, it is arbitrary and can be configured by users.\n+        private int retainTillReceivePercentage = 75;\n+        private BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        private Builder(final BiIntFunction<Throwable, ? extends Completable> retryStrategy,\n+                        final UnaryOperator<E> flipAvailability) {\n+            this.retryStrategy = retryStrategy;\n+            this.flipAvailability = requireNonNull(flipAvailability);\n+        }\n+\n+        /**\n+         * A {@link Publisher} returned from {@link ServiceDiscoverer#discover(Object)} may fail transiently leaving the\n+         * consumer of these events with an option of either disposing the addresses that were provided before the\n+         * error or retain them till a retry succeeds. This option enables retention of addresses after an error is\n+         * observed till the total number of received addresses after an error is {@code retainTillReceivePercentage}\n+         * percent of the addresses that were available before the error was received.\n+         *\n+         * @param retainTillReceivePercentage A percentage of addresses that were received before an error that should\n+         * be received after a success, after which unreceived addresses are removed by sending appropriate\n+         * {@link ServiceDiscovererEvent}s. When set to {@code 0}, addresses are not retained.\n+         * @return {@code this}.\n+         */\n+        public Builder<ResolvedAddress, E> retainAddressesTillSuccess(final int retainTillReceivePercentage) {\n+            if (retainTillReceivePercentage < 0) {\n+                throw new IllegalArgumentException(\"retainTillReceivePercentage: \" + retainTillReceivePercentage +\n+                        \" (expected >= 0)\");\n+            }\n+            this.retainTillReceivePercentage = retainTillReceivePercentage;\n+            return this;\n+        }\n+\n+        public Builder<ResolvedAddress, E> retryStrategy(\n+                final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+            this.retryStrategy = requireNonNull(retryStrategy);\n+            return this;\n+        }\n+\n+        /**\n+         * Creates a new {@link ServiceDiscoveryRetryStrategy} using the passed {@link BiFunction} which is applied", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5MTA4Mg=="}, "originalCommit": {"oid": "253b274645a92923b2d8a2fe7aca54f220833b47"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMjIzMjUzOnYy", "diffSide": "RIGHT", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMjozMDowN1rOG7KxFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxOTozMzo1MlrOG7uqJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5NTU3NA==", "bodyText": "Why - 1 is required here? 10 is still allowed value for retryWithExponentialBackoffAndJitter.", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r464695574", "createdAt": "2020-08-03T22:30:07Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscoverer;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.partition.PartitionAttributes;\n+import io.servicetalk.client.api.partition.PartitionedServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.BiIntFunction;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.UnaryOperator;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.RetryStrategies.retryWithExponentialBackoffAndJitter;\n+import static java.lang.Math.ceil;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default implementation for {@link ServiceDiscoveryRetryStrategy}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+ */\n+public final class DefaultServiceDiscoveryRetryStrategy<ResolvedAddress,\n+        E extends ServiceDiscovererEvent<ResolvedAddress>>\n+        implements ServiceDiscoveryRetryStrategy<ResolvedAddress, E> {\n+    private final int retainTillReceivePercentage;\n+    private final UnaryOperator<E> flipAvailability;\n+    private final BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+\n+    private DefaultServiceDiscoveryRetryStrategy(final int retainTillReceivePercentage,\n+                                                 final UnaryOperator<E> flipAvailability,\n+                                                 final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+        this.retainTillReceivePercentage = retainTillReceivePercentage;\n+        this.flipAvailability = requireNonNull(flipAvailability);\n+        this.retryStrategy = requireNonNull(retryStrategy);\n+    }\n+\n+    @Override\n+    public Publisher<? extends E> apply(final Publisher<? extends E> sdEvents) {\n+        return defer(() -> {\n+            EventsCache<ResolvedAddress, E> eventsCache =\n+                    new EventsCache<>(retainTillReceivePercentage, flipAvailability);\n+            return sdEvents.flatMapConcatIterable(eventsCache::consume)\n+                    .beforeOnError(__ -> eventsCache.errorSeen())\n+                    .retryWhen(retryStrategy);\n+        });\n+    }\n+\n+    /**\n+     * A builder to build instances of {@link DefaultServiceDiscoveryRetryStrategy}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution.\n+     * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+     */\n+    public static final class Builder<ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> {\n+        // There is no reason for the choice of 75%, it is arbitrary and can be configured by users.\n+        private int retainTillReceivePercentage = 75;\n+        private BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        private Builder(final BiIntFunction<Throwable, ? extends Completable> retryStrategy,\n+                        final UnaryOperator<E> flipAvailability) {\n+            this.retryStrategy = retryStrategy;\n+            this.flipAvailability = requireNonNull(flipAvailability);\n+        }\n+\n+        /**\n+         * A {@link Publisher} returned from {@link ServiceDiscoverer#discover(Object)} may fail transiently leaving the\n+         * consumer of these events with an option of either disposing the addresses that were provided before the\n+         * error or retain them till a retry succeeds. This option enables retention of addresses after an error is\n+         * observed till the total number of received addresses after an error is {@code retainTillReceivePercentage}\n+         * percent of the addresses that were available before the error was received.\n+         *\n+         * @param retainTillReceivePercentage A percentage of addresses that were received before an error that should\n+         * be received after a success, after which unreceived addresses are removed by sending appropriate\n+         * {@link ServiceDiscovererEvent}s. When set to {@code 0}, addresses are not retained.\n+         * @return {@code this}.\n+         */\n+        public Builder<ResolvedAddress, E> retainAddressesTillSuccess(final int retainTillReceivePercentage) {\n+            if (retainTillReceivePercentage < 0) {\n+                throw new IllegalArgumentException(\"retainTillReceivePercentage: \" + retainTillReceivePercentage +\n+                        \" (expected >= 0)\");\n+            }\n+            this.retainTillReceivePercentage = retainTillReceivePercentage;\n+            return this;\n+        }\n+\n+        public Builder<ResolvedAddress, E> retryStrategy(\n+                final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+            this.retryStrategy = requireNonNull(retryStrategy);\n+            return this;\n+        }\n+\n+        /**\n+         * Creates a new {@link ServiceDiscoveryRetryStrategy} using the passed {@link BiFunction} which is applied\n+         * as-is using {@link Publisher#retryWhen(BiIntFunction)} on the {@link Publisher} passed to\n+         * {@link DefaultServiceDiscoveryRetryStrategy#apply(Publisher)}.\n+         *\n+         * @return A new {@link ServiceDiscoveryRetryStrategy}.\n+         */\n+        public ServiceDiscoveryRetryStrategy<ResolvedAddress, E> build() {\n+            return new DefaultServiceDiscoveryRetryStrategy<>(retainTillReceivePercentage, flipAvailability,\n+                    retryStrategy);\n+        }\n+\n+        /**\n+         * Creates a new builder that uses default retries.\n+         *\n+         * @param executor {@link Executor} to use for retry backoffs.\n+         * @param initialDelay {@link Duration} to use as initial delay for backoffs.\n+         * @param <ResolvedAddress> The type of address after resolution.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress, ServiceDiscovererEvent<ResolvedAddress>>\n+        withDefaults(final Executor executor, final Duration initialDelay) {\n+            return new Builder<>(new IndefiniteRetryStrategy(executor, initialDelay),\n+                    evt -> new DefaultServiceDiscovererEvent<>(evt.address(), !evt.isAvailable()));\n+        }\n+\n+        /**\n+         * Creates a new builder that uses default retries.\n+         *\n+         * @param executor {@link Executor} to use for retry backoffs.\n+         * @param initialDelay {@link Duration} to use as initial delay for backoffs.\n+         * @param <ResolvedAddress> The type of address after resolution.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress, PartitionedServiceDiscovererEvent<ResolvedAddress>>\n+        withDefaultsForPartitions(final Executor executor, final Duration initialDelay) {\n+            return new Builder<>(new IndefiniteRetryStrategy(executor, initialDelay),\n+                    evt -> new PartitionedServiceDiscovererEvent<ResolvedAddress>() {\n+                        @Override\n+                        public PartitionAttributes partitionAddress() {\n+                            return evt.partitionAddress();\n+                        }\n+\n+                        @Override\n+                        public ResolvedAddress address() {\n+                            return evt.address();\n+                        }\n+\n+                        @Override\n+                        public boolean isAvailable() {\n+                            return !evt.isAvailable();\n+                        }\n+                    });\n+        }\n+\n+        /**\n+         * Creates a new builder that uses default retries.\n+         *\n+         * @param executor {@link Executor} to use for retry backoffs.\n+         * @param initialDelay {@link Duration} to use as initial delay for backoffs.\n+         * @param flipAvailability {@link UnaryOperator} that returns a new {@link ServiceDiscovererEvent} that is the\n+         * same as the passed {@link ServiceDiscovererEvent} but with {@link ServiceDiscovererEvent#isAvailable()} value\n+         * flipped.\n+         * @param <ResolvedAddress> The type of address after resolution.\n+         * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> Builder<ResolvedAddress, E>\n+        withDefaults(final Executor executor, final Duration initialDelay, final UnaryOperator<E> flipAvailability) {\n+            return new Builder<>(new IndefiniteRetryStrategy(executor, initialDelay), flipAvailability);\n+        }\n+    }\n+\n+    private static final class EventsCache<R, E extends ServiceDiscovererEvent<R>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final Map NONE_RETAINED = emptyMap();\n+\n+        private Map<R, E> retainedAddresses = noneRetained();\n+        private int targetSize;\n+        private final Map<R, E> activeAddresses = new HashMap<>();\n+        private final int retainTillReceivePercentage;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        EventsCache(final int retainTillReceivePercentage, final UnaryOperator<E> flipAvailability) {\n+            this.retainTillReceivePercentage = retainTillReceivePercentage;\n+            this.flipAvailability = flipAvailability;\n+        }\n+\n+        void errorSeen() {\n+            if (retainedAddresses == NONE_RETAINED) {\n+                retainedAddresses = new HashMap<>(activeAddresses);\n+            } else {\n+                retainedAddresses.putAll(activeAddresses);\n+            }\n+            targetSize = (int) (ceil(retainTillReceivePercentage / 100d) * activeAddresses.size());\n+            activeAddresses.clear();\n+        }\n+\n+        Iterable<E> consume(final E event) {\n+            final R address = event.address();\n+            if (retainedAddresses == NONE_RETAINED) {\n+                if (event.isAvailable()) {\n+                    activeAddresses.put(address, event);\n+                } else {\n+                    activeAddresses.remove(address);\n+                }\n+                return singletonList(event);\n+            }\n+\n+            // we have seen an error and have not fully drained the retained address list\n+            if (event.isAvailable()) {\n+                // new address after a retry\n+                activeAddresses.put(address, event);\n+                final boolean removed = retainedAddresses.remove(address) != null;\n+                if (activeAddresses.size() == targetSize) {\n+                    final List<E> allEvents = new ArrayList<>(retainedAddresses.size() + (removed ? 0 : 1));\n+                    if (!removed) {\n+                        allEvents.add(event);\n+                    }\n+                    for (E removalEvent : retainedAddresses.values()) {\n+                        allEvents.add(flipAvailability.apply(removalEvent));\n+                    }\n+                    retainedAddresses = noneRetained();\n+                    targetSize = 0;\n+                    return allEvents;\n+                }\n+                // If we already had it in retained addresses, then the event can be ignored as the consumer of events\n+                // already knows about the address\n+                return removed ? emptyList() : singletonList(event);\n+            }\n+            // removal must be for a previously added address which would have already removed from the retained\n+            // address list, so we do not need to touch the retainedAddresses\n+            activeAddresses.remove(address);\n+            return singletonList(event);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private static <R, E extends ServiceDiscovererEvent<R>> Map<R, E> noneRetained() {\n+            return NONE_RETAINED;\n+        }\n+    }\n+\n+    private static final class IndefiniteRetryStrategy implements BiIntFunction<Throwable, Completable> {\n+        private static final int MAX_RETRIES = 10;\n+        private final BiIntFunction<Throwable, Completable> delegate;\n+\n+        IndefiniteRetryStrategy(final Executor executor, final Duration initialDelay) {\n+            delegate = retryWithExponentialBackoffAndJitter(MAX_RETRIES, __ -> true, initialDelay, executor);\n+        }\n+\n+        @Override\n+        public Completable apply(final int count, final Throwable cause) {\n+            // As we are retrying indefinitely (unless closed), cap the backoff on MAX_RETRIES retries to avoid\n+            // impractical backoffs\n+            return delegate.apply(count % (MAX_RETRIES - 1), cause);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "253b274645a92923b2d8a2fe7aca54f220833b47"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI4MzYyMg==", "bodyText": "hmm .. ya we can use MAX_RETRIES too but we should not let the count % MAX_RETRIES to be 0 as that will trip retryWithExponentialBackoffAndJitter. Let me fix that", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r465283622", "createdAt": "2020-08-04T19:33:52Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "diffHunk": "@@ -0,0 +1,278 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscoverer;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.partition.PartitionAttributes;\n+import io.servicetalk.client.api.partition.PartitionedServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.BiIntFunction;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.UnaryOperator;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.RetryStrategies.retryWithExponentialBackoffAndJitter;\n+import static java.lang.Math.ceil;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default implementation for {@link ServiceDiscoveryRetryStrategy}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+ */\n+public final class DefaultServiceDiscoveryRetryStrategy<ResolvedAddress,\n+        E extends ServiceDiscovererEvent<ResolvedAddress>>\n+        implements ServiceDiscoveryRetryStrategy<ResolvedAddress, E> {\n+    private final int retainTillReceivePercentage;\n+    private final UnaryOperator<E> flipAvailability;\n+    private final BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+\n+    private DefaultServiceDiscoveryRetryStrategy(final int retainTillReceivePercentage,\n+                                                 final UnaryOperator<E> flipAvailability,\n+                                                 final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+        this.retainTillReceivePercentage = retainTillReceivePercentage;\n+        this.flipAvailability = requireNonNull(flipAvailability);\n+        this.retryStrategy = requireNonNull(retryStrategy);\n+    }\n+\n+    @Override\n+    public Publisher<? extends E> apply(final Publisher<? extends E> sdEvents) {\n+        return defer(() -> {\n+            EventsCache<ResolvedAddress, E> eventsCache =\n+                    new EventsCache<>(retainTillReceivePercentage, flipAvailability);\n+            return sdEvents.flatMapConcatIterable(eventsCache::consume)\n+                    .beforeOnError(__ -> eventsCache.errorSeen())\n+                    .retryWhen(retryStrategy);\n+        });\n+    }\n+\n+    /**\n+     * A builder to build instances of {@link DefaultServiceDiscoveryRetryStrategy}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution.\n+     * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+     */\n+    public static final class Builder<ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> {\n+        // There is no reason for the choice of 75%, it is arbitrary and can be configured by users.\n+        private int retainTillReceivePercentage = 75;\n+        private BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        private Builder(final BiIntFunction<Throwable, ? extends Completable> retryStrategy,\n+                        final UnaryOperator<E> flipAvailability) {\n+            this.retryStrategy = retryStrategy;\n+            this.flipAvailability = requireNonNull(flipAvailability);\n+        }\n+\n+        /**\n+         * A {@link Publisher} returned from {@link ServiceDiscoverer#discover(Object)} may fail transiently leaving the\n+         * consumer of these events with an option of either disposing the addresses that were provided before the\n+         * error or retain them till a retry succeeds. This option enables retention of addresses after an error is\n+         * observed till the total number of received addresses after an error is {@code retainTillReceivePercentage}\n+         * percent of the addresses that were available before the error was received.\n+         *\n+         * @param retainTillReceivePercentage A percentage of addresses that were received before an error that should\n+         * be received after a success, after which unreceived addresses are removed by sending appropriate\n+         * {@link ServiceDiscovererEvent}s. When set to {@code 0}, addresses are not retained.\n+         * @return {@code this}.\n+         */\n+        public Builder<ResolvedAddress, E> retainAddressesTillSuccess(final int retainTillReceivePercentage) {\n+            if (retainTillReceivePercentage < 0) {\n+                throw new IllegalArgumentException(\"retainTillReceivePercentage: \" + retainTillReceivePercentage +\n+                        \" (expected >= 0)\");\n+            }\n+            this.retainTillReceivePercentage = retainTillReceivePercentage;\n+            return this;\n+        }\n+\n+        public Builder<ResolvedAddress, E> retryStrategy(\n+                final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+            this.retryStrategy = requireNonNull(retryStrategy);\n+            return this;\n+        }\n+\n+        /**\n+         * Creates a new {@link ServiceDiscoveryRetryStrategy} using the passed {@link BiFunction} which is applied\n+         * as-is using {@link Publisher#retryWhen(BiIntFunction)} on the {@link Publisher} passed to\n+         * {@link DefaultServiceDiscoveryRetryStrategy#apply(Publisher)}.\n+         *\n+         * @return A new {@link ServiceDiscoveryRetryStrategy}.\n+         */\n+        public ServiceDiscoveryRetryStrategy<ResolvedAddress, E> build() {\n+            return new DefaultServiceDiscoveryRetryStrategy<>(retainTillReceivePercentage, flipAvailability,\n+                    retryStrategy);\n+        }\n+\n+        /**\n+         * Creates a new builder that uses default retries.\n+         *\n+         * @param executor {@link Executor} to use for retry backoffs.\n+         * @param initialDelay {@link Duration} to use as initial delay for backoffs.\n+         * @param <ResolvedAddress> The type of address after resolution.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress, ServiceDiscovererEvent<ResolvedAddress>>\n+        withDefaults(final Executor executor, final Duration initialDelay) {\n+            return new Builder<>(new IndefiniteRetryStrategy(executor, initialDelay),\n+                    evt -> new DefaultServiceDiscovererEvent<>(evt.address(), !evt.isAvailable()));\n+        }\n+\n+        /**\n+         * Creates a new builder that uses default retries.\n+         *\n+         * @param executor {@link Executor} to use for retry backoffs.\n+         * @param initialDelay {@link Duration} to use as initial delay for backoffs.\n+         * @param <ResolvedAddress> The type of address after resolution.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress, PartitionedServiceDiscovererEvent<ResolvedAddress>>\n+        withDefaultsForPartitions(final Executor executor, final Duration initialDelay) {\n+            return new Builder<>(new IndefiniteRetryStrategy(executor, initialDelay),\n+                    evt -> new PartitionedServiceDiscovererEvent<ResolvedAddress>() {\n+                        @Override\n+                        public PartitionAttributes partitionAddress() {\n+                            return evt.partitionAddress();\n+                        }\n+\n+                        @Override\n+                        public ResolvedAddress address() {\n+                            return evt.address();\n+                        }\n+\n+                        @Override\n+                        public boolean isAvailable() {\n+                            return !evt.isAvailable();\n+                        }\n+                    });\n+        }\n+\n+        /**\n+         * Creates a new builder that uses default retries.\n+         *\n+         * @param executor {@link Executor} to use for retry backoffs.\n+         * @param initialDelay {@link Duration} to use as initial delay for backoffs.\n+         * @param flipAvailability {@link UnaryOperator} that returns a new {@link ServiceDiscovererEvent} that is the\n+         * same as the passed {@link ServiceDiscovererEvent} but with {@link ServiceDiscovererEvent#isAvailable()} value\n+         * flipped.\n+         * @param <ResolvedAddress> The type of address after resolution.\n+         * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> Builder<ResolvedAddress, E>\n+        withDefaults(final Executor executor, final Duration initialDelay, final UnaryOperator<E> flipAvailability) {\n+            return new Builder<>(new IndefiniteRetryStrategy(executor, initialDelay), flipAvailability);\n+        }\n+    }\n+\n+    private static final class EventsCache<R, E extends ServiceDiscovererEvent<R>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final Map NONE_RETAINED = emptyMap();\n+\n+        private Map<R, E> retainedAddresses = noneRetained();\n+        private int targetSize;\n+        private final Map<R, E> activeAddresses = new HashMap<>();\n+        private final int retainTillReceivePercentage;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        EventsCache(final int retainTillReceivePercentage, final UnaryOperator<E> flipAvailability) {\n+            this.retainTillReceivePercentage = retainTillReceivePercentage;\n+            this.flipAvailability = flipAvailability;\n+        }\n+\n+        void errorSeen() {\n+            if (retainedAddresses == NONE_RETAINED) {\n+                retainedAddresses = new HashMap<>(activeAddresses);\n+            } else {\n+                retainedAddresses.putAll(activeAddresses);\n+            }\n+            targetSize = (int) (ceil(retainTillReceivePercentage / 100d) * activeAddresses.size());\n+            activeAddresses.clear();\n+        }\n+\n+        Iterable<E> consume(final E event) {\n+            final R address = event.address();\n+            if (retainedAddresses == NONE_RETAINED) {\n+                if (event.isAvailable()) {\n+                    activeAddresses.put(address, event);\n+                } else {\n+                    activeAddresses.remove(address);\n+                }\n+                return singletonList(event);\n+            }\n+\n+            // we have seen an error and have not fully drained the retained address list\n+            if (event.isAvailable()) {\n+                // new address after a retry\n+                activeAddresses.put(address, event);\n+                final boolean removed = retainedAddresses.remove(address) != null;\n+                if (activeAddresses.size() == targetSize) {\n+                    final List<E> allEvents = new ArrayList<>(retainedAddresses.size() + (removed ? 0 : 1));\n+                    if (!removed) {\n+                        allEvents.add(event);\n+                    }\n+                    for (E removalEvent : retainedAddresses.values()) {\n+                        allEvents.add(flipAvailability.apply(removalEvent));\n+                    }\n+                    retainedAddresses = noneRetained();\n+                    targetSize = 0;\n+                    return allEvents;\n+                }\n+                // If we already had it in retained addresses, then the event can be ignored as the consumer of events\n+                // already knows about the address\n+                return removed ? emptyList() : singletonList(event);\n+            }\n+            // removal must be for a previously added address which would have already removed from the retained\n+            // address list, so we do not need to touch the retainedAddresses\n+            activeAddresses.remove(address);\n+            return singletonList(event);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private static <R, E extends ServiceDiscovererEvent<R>> Map<R, E> noneRetained() {\n+            return NONE_RETAINED;\n+        }\n+    }\n+\n+    private static final class IndefiniteRetryStrategy implements BiIntFunction<Throwable, Completable> {\n+        private static final int MAX_RETRIES = 10;\n+        private final BiIntFunction<Throwable, Completable> delegate;\n+\n+        IndefiniteRetryStrategy(final Executor executor, final Duration initialDelay) {\n+            delegate = retryWithExponentialBackoffAndJitter(MAX_RETRIES, __ -> true, initialDelay, executor);\n+        }\n+\n+        @Override\n+        public Completable apply(final int count, final Throwable cause) {\n+            // As we are retrying indefinitely (unless closed), cap the backoff on MAX_RETRIES retries to avoid\n+            // impractical backoffs\n+            return delegate.apply(count % (MAX_RETRIES - 1), cause);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY5NTU3NA=="}, "originalCommit": {"oid": "253b274645a92923b2d8a2fe7aca54f220833b47"}, "originalPosition": 275}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMjI2ODg0OnYy", "diffSide": "RIGHT", "path": "servicetalk-http-api/src/test/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategyTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMjo0NjozNlrOG7LGJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMjo0NjozNlrOG7LGJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcwMDk2Nw==", "bodyText": "The executor should be closed after the test.", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r464700967", "createdAt": "2020-08-03T22:46:36Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-api/src/test/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategyTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.TestExecutor;\n+import io.servicetalk.concurrent.api.TestPublisher;\n+import io.servicetalk.concurrent.api.TestPublisherSubscriber;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.DefaultServiceDiscoveryRetryStrategy.Builder;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.util.List;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.lang.Long.MAX_VALUE;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+public class DefaultServiceDiscoveryRetryStrategyTest {\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final TestExecutor executor;\n+    private final LinkedBlockingQueue<TestPublisher<ServiceDiscovererEvent<String>>> pubs;\n+    private final TestPublisherSubscriber<ServiceDiscovererEvent<String>> subscriber;\n+\n+    public DefaultServiceDiscoveryRetryStrategyTest() {\n+        executor = new TestExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "253b274645a92923b2d8a2fe7aca54f220833b47"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMjI5OTM5OnYy", "diffSide": "RIGHT", "path": "servicetalk-http-api/src/test/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategyTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMzowMToxNFrOG7LYGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxODo1MjoyOFrOG7tMwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcwNTU2Mg==", "bodyText": "Consider testing a use-case for retainAddressesTillSuccess(0).", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r464705562", "createdAt": "2020-08-03T23:01:14Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-api/src/test/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategyTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.TestExecutor;\n+import io.servicetalk.concurrent.api.TestPublisher;\n+import io.servicetalk.concurrent.api.TestPublisherSubscriber;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.DefaultServiceDiscoveryRetryStrategy.Builder;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.util.List;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.lang.Long.MAX_VALUE;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+public class DefaultServiceDiscoveryRetryStrategyTest {\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final TestExecutor executor;\n+    private final LinkedBlockingQueue<TestPublisher<ServiceDiscovererEvent<String>>> pubs;\n+    private final TestPublisherSubscriber<ServiceDiscovererEvent<String>> subscriber;\n+\n+    public DefaultServiceDiscoveryRetryStrategyTest() {\n+        executor = new TestExecutor();\n+        ServiceDiscoveryRetryStrategy<String, ServiceDiscovererEvent<String>> strategy =\n+                Builder.<String>withDefaults(executor, ofSeconds(1)).retainAddressesTillSuccess(75).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "253b274645a92923b2d8a2fe7aca54f220833b47"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1OTcxMg==", "bodyText": "Good call; there was a bug \ud83d\ude04\nif (activeAddresses.size() == targetSize) should be if (activeAddresses.size() >= targetSize)", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r465259712", "createdAt": "2020-08-04T18:52:28Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-api/src/test/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategyTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.TestExecutor;\n+import io.servicetalk.concurrent.api.TestPublisher;\n+import io.servicetalk.concurrent.api.TestPublisherSubscriber;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.DefaultServiceDiscoveryRetryStrategy.Builder;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.util.List;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.lang.Long.MAX_VALUE;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+public class DefaultServiceDiscoveryRetryStrategyTest {\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final TestExecutor executor;\n+    private final LinkedBlockingQueue<TestPublisher<ServiceDiscovererEvent<String>>> pubs;\n+    private final TestPublisherSubscriber<ServiceDiscovererEvent<String>> subscriber;\n+\n+    public DefaultServiceDiscoveryRetryStrategyTest() {\n+        executor = new TestExecutor();\n+        ServiceDiscoveryRetryStrategy<String, ServiceDiscovererEvent<String>> strategy =\n+                Builder.<String>withDefaults(executor, ofSeconds(1)).retainAddressesTillSuccess(75).build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcwNTU2Mg=="}, "originalCommit": {"oid": "253b274645a92923b2d8a2fe7aca54f220833b47"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwMjMwMjMxOnYy", "diffSide": "RIGHT", "path": "servicetalk-http-api/src/test/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategyTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMzowMjozOFrOG7LZxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QyMzowMjozOFrOG7LZxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcwNTk4OA==", "bodyText": "The comment above says \"should evict addr2\", but evt1 is also evicted. Can you please clarify why this is expected?", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r464705988", "createdAt": "2020-08-03T23:02:38Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-api/src/test/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategyTest.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.TestExecutor;\n+import io.servicetalk.concurrent.api.TestPublisher;\n+import io.servicetalk.concurrent.api.TestPublisherSubscriber;\n+import io.servicetalk.concurrent.internal.ServiceTalkTestTimeout;\n+import io.servicetalk.http.api.DefaultServiceDiscoveryRetryStrategy.Builder;\n+\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+\n+import java.util.List;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.internal.DeliberateException.DELIBERATE_EXCEPTION;\n+import static java.lang.Long.MAX_VALUE;\n+import static java.time.Duration.ofSeconds;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+\n+public class DefaultServiceDiscoveryRetryStrategyTest {\n+    @Rule\n+    public final Timeout timeout = new ServiceTalkTestTimeout();\n+\n+    private final TestExecutor executor;\n+    private final LinkedBlockingQueue<TestPublisher<ServiceDiscovererEvent<String>>> pubs;\n+    private final TestPublisherSubscriber<ServiceDiscovererEvent<String>> subscriber;\n+\n+    public DefaultServiceDiscoveryRetryStrategyTest() {\n+        executor = new TestExecutor();\n+        ServiceDiscoveryRetryStrategy<String, ServiceDiscovererEvent<String>> strategy =\n+                Builder.<String>withDefaults(executor, ofSeconds(1)).retainAddressesTillSuccess(75).build();\n+        pubs = new LinkedBlockingQueue<>();\n+        subscriber = new TestPublisherSubscriber<>();\n+        toSource(strategy.apply(defer(() -> {\n+            final TestPublisher<ServiceDiscovererEvent<String>> pub = new TestPublisher<>();\n+            pubs.add(pub);\n+            return pub;\n+        }))).subscribe(subscriber);\n+        subscriber.request(MAX_VALUE);\n+    }\n+\n+    @Test\n+    public void errorWithNoAddresses() throws Exception {\n+        TestPublisher<ServiceDiscovererEvent<String>> sdEvents = pubs.take();\n+        sdEvents = triggerRetry(sdEvents);\n+        verifyNoEventsReceived();\n+        sendUpAndVerifyReceive(\"addr1\", sdEvents);\n+    }\n+\n+    @Test\n+    public void newAddressPostRetry() throws Exception {\n+        TestPublisher<ServiceDiscovererEvent<String>> sdEvents = pubs.take();\n+\n+        final DefaultServiceDiscovererEvent<String> evt1 = sendUpAndVerifyReceive(\"addr1\", sdEvents);\n+\n+        sdEvents = triggerRetry(sdEvents);\n+\n+        verifyNoEventsReceived();\n+        final DefaultServiceDiscovererEvent<String> evt2 = new DefaultServiceDiscovererEvent<>(\"addr2\", true);\n+        sdEvents.onNext(evt2);\n+\n+        assertThat(\"Unexpected event received\", subscriber.takeItems(),\n+                containsInAnyOrder(flipAvailable(evt1), evt2));\n+    }\n+\n+    @Test\n+    public void overlapAddressPostRetry() throws Exception {\n+        TestPublisher<ServiceDiscovererEvent<String>> sdEvents = pubs.take();\n+\n+        final DefaultServiceDiscovererEvent<String> evt1 = sendUpAndVerifyReceive(\"addr1\", sdEvents);\n+        final DefaultServiceDiscovererEvent<String> evt2 = sendUpAndVerifyReceive(\"addr2\", sdEvents);\n+\n+        sdEvents = triggerRetry(sdEvents);\n+\n+        verifyNoEventsReceived();\n+\n+        sdEvents.onNext(evt1); // previously existing, should not be emitted\n+        verifyNoEventsReceived();\n+\n+        final DefaultServiceDiscovererEvent<String> evt3 = new DefaultServiceDiscovererEvent<>(\"addr3\", true);\n+        sdEvents.onNext(evt3); // threshold breach, should evict addr2\n+\n+        assertThat(\"Unexpected event received\", subscriber.takeItems(),\n+                containsInAnyOrder(flipAvailable(evt2), evt3));\n+    }\n+\n+    @Test\n+    public void errorWhileRetaining() throws Exception {\n+        TestPublisher<ServiceDiscovererEvent<String>> sdEvents = pubs.take();\n+\n+        final DefaultServiceDiscovererEvent<String> evt1 = sendUpAndVerifyReceive(\"addr1\", sdEvents);\n+        final DefaultServiceDiscovererEvent<String> evt2 = sendUpAndVerifyReceive(\"addr2\", sdEvents);\n+\n+        sdEvents = triggerRetry(sdEvents);\n+\n+        verifyNoEventsReceived();\n+\n+        sdEvents.onNext(evt1); // previously existing, should not be emitted\n+        verifyNoEventsReceived();\n+\n+        sdEvents = triggerRetry(sdEvents); // error while retaining\n+\n+        final DefaultServiceDiscovererEvent<String> evt3 = new DefaultServiceDiscovererEvent<>(\"addr3\", true);\n+        sdEvents.onNext(evt3); // threshold breach, should evict addr2\n+\n+        assertThat(\"Unexpected event received\", subscriber.takeItems(),\n+                containsInAnyOrder(flipAvailable(evt1), flipAvailable(evt2), evt3));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "253b274645a92923b2d8a2fe7aca54f220833b47"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNjY2NzI2OnYy", "diffSide": "RIGHT", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzoyMjo1NlrOG70xWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzoyMjo1NlrOG70xWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM4Mzc2OA==", "bodyText": "With max approach it will return 1 two times. Not a big deal. But if you don't like it, alternative could be (count % MAX_RETRIES) + 1.\nAlso, IIRC, the power of 2 value will be a bit more optimal for %. How about 8 or 16 instead of 10? Or just a mask of 0x0F?", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r465383768", "createdAt": "2020-08-04T23:22:56Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "diffHunk": "@@ -261,18 +269,23 @@ void errorSeen() {\n     }\n \n     private static final class IndefiniteRetryStrategy implements BiIntFunction<Throwable, Completable> {\n-        private static final int MAX_RETRIES = 10;\n         private final BiIntFunction<Throwable, Completable> delegate;\n+        private final int maxRetries;\n \n         IndefiniteRetryStrategy(final Executor executor, final Duration initialDelay) {\n-            delegate = retryWithExponentialBackoffAndJitter(MAX_RETRIES, __ -> true, initialDelay, executor);\n+            this(executor, initialDelay, 10);\n+        }\n+\n+        IndefiniteRetryStrategy(final Executor executor, final Duration initialDelay, final int maxRetries) {\n+            delegate = retryWithExponentialBackoffAndJitter(maxRetries, __ -> true, initialDelay, executor);\n+            this.maxRetries = maxRetries;\n         }\n \n         @Override\n         public Completable apply(final int count, final Throwable cause) {\n             // As we are retrying indefinitely (unless closed), cap the backoff on MAX_RETRIES retries to avoid\n             // impractical backoffs\n-            return delegate.apply(count % (MAX_RETRIES - 1), cause);\n+            return delegate.apply(max(1, count % (maxRetries)), cause);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0911d866722ebeb2ad7fc03ea74e244f2b71d29f"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzA4MDUxOnYy", "diffSide": "RIGHT", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzowOTo0OVrOG74ieQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzo1MDoyOFrOG8UTsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NTQ5Nw==", "bodyText": "Minor ask : Requires upper cap as well retainTillReceivePercentage should not be greater than 100", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r465445497", "createdAt": "2020-08-05T03:09:49Z", "author": {"login": "connect2gaurav"}, "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscoverer;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.partition.PartitionAttributes;\n+import io.servicetalk.client.api.partition.PartitionedServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.BiIntFunction;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.UnaryOperator;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.RetryStrategies.retryWithExponentialBackoffAndJitter;\n+import static java.lang.Math.ceil;\n+import static java.lang.Math.max;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default implementation for {@link ServiceDiscoveryRetryStrategy}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+ */\n+public final class DefaultServiceDiscoveryRetryStrategy<ResolvedAddress,\n+        E extends ServiceDiscovererEvent<ResolvedAddress>>\n+        implements ServiceDiscoveryRetryStrategy<ResolvedAddress, E> {\n+    private final int retainTillReceivePercentage;\n+    private final UnaryOperator<E> flipAvailability;\n+    private final BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+\n+    private DefaultServiceDiscoveryRetryStrategy(final int retainTillReceivePercentage,\n+                                                 final UnaryOperator<E> flipAvailability,\n+                                                 final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+        this.retainTillReceivePercentage = retainTillReceivePercentage;\n+        this.flipAvailability = requireNonNull(flipAvailability);\n+        this.retryStrategy = requireNonNull(retryStrategy);\n+    }\n+\n+    @Override\n+    public Publisher<? extends E> apply(final Publisher<? extends E> sdEvents) {\n+        return defer(() -> {\n+            EventsCache<ResolvedAddress, E> eventsCache =\n+                    new EventsCache<>(retainTillReceivePercentage, flipAvailability);\n+            return sdEvents.flatMapConcatIterable(eventsCache::consume)\n+                    .beforeOnError(__ -> eventsCache.errorSeen())\n+                    .retryWhen(retryStrategy);\n+        });\n+    }\n+\n+    /**\n+     * A builder to build instances of {@link DefaultServiceDiscoveryRetryStrategy}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution.\n+     * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+     */\n+    public static final class Builder<ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> {\n+        // There is no reason for the choice of 75%, it is arbitrary and can be configured by users.\n+        private int retainTillReceivePercentage = 75;\n+        private BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        private Builder(final BiIntFunction<Throwable, ? extends Completable> retryStrategy,\n+                        final UnaryOperator<E> flipAvailability) {\n+            this.retryStrategy = retryStrategy;\n+            this.flipAvailability = requireNonNull(flipAvailability);\n+        }\n+\n+        /**\n+         * A {@link Publisher} returned from {@link ServiceDiscoverer#discover(Object)} may fail transiently leaving the\n+         * consumer of these events with an option of either disposing the addresses that were provided before the\n+         * error or retain them till a retry succeeds. This option enables retention of addresses after an error is\n+         * observed till the total number of received addresses after an error is {@code retainTillReceivePercentage}\n+         * percent of the addresses that were available before the error was received.\n+         *\n+         * @param retainTillReceivePercentage A percentage of addresses that were received before an error that should\n+         * be received after a success, after which unreceived addresses are removed by sending appropriate\n+         * {@link ServiceDiscovererEvent}s. When set to {@code 0}, addresses are not retained.\n+         * @return {@code this}.\n+         */\n+        public Builder<ResolvedAddress, E> retainAddressesTillSuccess(final int retainTillReceivePercentage) {\n+            if (retainTillReceivePercentage < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0911d866722ebeb2ad7fc03ea74e244f2b71d29f"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwMDQ2Nw==", "bodyText": "Not adding an upper cap is intentional here as it enables folks to retain older addresses for a longish time.", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r465900467", "createdAt": "2020-08-05T17:50:28Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscoverer;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.partition.PartitionAttributes;\n+import io.servicetalk.client.api.partition.PartitionedServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.BiIntFunction;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.UnaryOperator;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.RetryStrategies.retryWithExponentialBackoffAndJitter;\n+import static java.lang.Math.ceil;\n+import static java.lang.Math.max;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default implementation for {@link ServiceDiscoveryRetryStrategy}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+ */\n+public final class DefaultServiceDiscoveryRetryStrategy<ResolvedAddress,\n+        E extends ServiceDiscovererEvent<ResolvedAddress>>\n+        implements ServiceDiscoveryRetryStrategy<ResolvedAddress, E> {\n+    private final int retainTillReceivePercentage;\n+    private final UnaryOperator<E> flipAvailability;\n+    private final BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+\n+    private DefaultServiceDiscoveryRetryStrategy(final int retainTillReceivePercentage,\n+                                                 final UnaryOperator<E> flipAvailability,\n+                                                 final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+        this.retainTillReceivePercentage = retainTillReceivePercentage;\n+        this.flipAvailability = requireNonNull(flipAvailability);\n+        this.retryStrategy = requireNonNull(retryStrategy);\n+    }\n+\n+    @Override\n+    public Publisher<? extends E> apply(final Publisher<? extends E> sdEvents) {\n+        return defer(() -> {\n+            EventsCache<ResolvedAddress, E> eventsCache =\n+                    new EventsCache<>(retainTillReceivePercentage, flipAvailability);\n+            return sdEvents.flatMapConcatIterable(eventsCache::consume)\n+                    .beforeOnError(__ -> eventsCache.errorSeen())\n+                    .retryWhen(retryStrategy);\n+        });\n+    }\n+\n+    /**\n+     * A builder to build instances of {@link DefaultServiceDiscoveryRetryStrategy}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution.\n+     * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+     */\n+    public static final class Builder<ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> {\n+        // There is no reason for the choice of 75%, it is arbitrary and can be configured by users.\n+        private int retainTillReceivePercentage = 75;\n+        private BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        private Builder(final BiIntFunction<Throwable, ? extends Completable> retryStrategy,\n+                        final UnaryOperator<E> flipAvailability) {\n+            this.retryStrategy = retryStrategy;\n+            this.flipAvailability = requireNonNull(flipAvailability);\n+        }\n+\n+        /**\n+         * A {@link Publisher} returned from {@link ServiceDiscoverer#discover(Object)} may fail transiently leaving the\n+         * consumer of these events with an option of either disposing the addresses that were provided before the\n+         * error or retain them till a retry succeeds. This option enables retention of addresses after an error is\n+         * observed till the total number of received addresses after an error is {@code retainTillReceivePercentage}\n+         * percent of the addresses that were available before the error was received.\n+         *\n+         * @param retainTillReceivePercentage A percentage of addresses that were received before an error that should\n+         * be received after a success, after which unreceived addresses are removed by sending appropriate\n+         * {@link ServiceDiscovererEvent}s. When set to {@code 0}, addresses are not retained.\n+         * @return {@code this}.\n+         */\n+        public Builder<ResolvedAddress, E> retainAddressesTillSuccess(final int retainTillReceivePercentage) {\n+            if (retainTillReceivePercentage < 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NTQ5Nw=="}, "originalCommit": {"oid": "0911d866722ebeb2ad7fc03ea74e244f2b71d29f"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzA4NTQzOnYy", "diffSide": "RIGHT", "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzoxMjoyOVrOG74lUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNzo1MDo1OFrOG8UU1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NjIyNg==", "bodyText": "System.out.println(\"Output for 0\t:\" +(int)Math.ceil(0/100d)); System.out.println(\"Output for 10\t:\" +(int)Math.ceil(10/100d)); System.out.println(\"Output for 75\t:\" +(int)Math.ceil(75/100d)); System.out.println(\"Output for 100\t:\" +(int)Math.ceil(100/100d));\nOutput for 0\t:0 Output for 10\t:1 Output for 75\t:1 Output for 100\t:1\nSeems like Percentage computation is bit off. Irrespective of percentage targetSize = 1 * activeAddresses.size()", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r465446226", "createdAt": "2020-08-05T03:12:29Z", "author": {"login": "connect2gaurav"}, "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscoverer;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.partition.PartitionAttributes;\n+import io.servicetalk.client.api.partition.PartitionedServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.BiIntFunction;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.UnaryOperator;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.RetryStrategies.retryWithExponentialBackoffAndJitter;\n+import static java.lang.Math.ceil;\n+import static java.lang.Math.max;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default implementation for {@link ServiceDiscoveryRetryStrategy}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+ */\n+public final class DefaultServiceDiscoveryRetryStrategy<ResolvedAddress,\n+        E extends ServiceDiscovererEvent<ResolvedAddress>>\n+        implements ServiceDiscoveryRetryStrategy<ResolvedAddress, E> {\n+    private final int retainTillReceivePercentage;\n+    private final UnaryOperator<E> flipAvailability;\n+    private final BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+\n+    private DefaultServiceDiscoveryRetryStrategy(final int retainTillReceivePercentage,\n+                                                 final UnaryOperator<E> flipAvailability,\n+                                                 final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+        this.retainTillReceivePercentage = retainTillReceivePercentage;\n+        this.flipAvailability = requireNonNull(flipAvailability);\n+        this.retryStrategy = requireNonNull(retryStrategy);\n+    }\n+\n+    @Override\n+    public Publisher<? extends E> apply(final Publisher<? extends E> sdEvents) {\n+        return defer(() -> {\n+            EventsCache<ResolvedAddress, E> eventsCache =\n+                    new EventsCache<>(retainTillReceivePercentage, flipAvailability);\n+            return sdEvents.flatMapConcatIterable(eventsCache::consume)\n+                    .beforeOnError(__ -> eventsCache.errorSeen())\n+                    .retryWhen(retryStrategy);\n+        });\n+    }\n+\n+    /**\n+     * A builder to build instances of {@link DefaultServiceDiscoveryRetryStrategy}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution.\n+     * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+     */\n+    public static final class Builder<ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> {\n+        // There is no reason for the choice of 75%, it is arbitrary and can be configured by users.\n+        private int retainTillReceivePercentage = 75;\n+        private BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        private Builder(final BiIntFunction<Throwable, ? extends Completable> retryStrategy,\n+                        final UnaryOperator<E> flipAvailability) {\n+            this.retryStrategy = retryStrategy;\n+            this.flipAvailability = requireNonNull(flipAvailability);\n+        }\n+\n+        /**\n+         * A {@link Publisher} returned from {@link ServiceDiscoverer#discover(Object)} may fail transiently leaving the\n+         * consumer of these events with an option of either disposing the addresses that were provided before the\n+         * error or retain them till a retry succeeds. This option enables retention of addresses after an error is\n+         * observed till the total number of received addresses after an error is {@code retainTillReceivePercentage}\n+         * percent of the addresses that were available before the error was received.\n+         *\n+         * @param retainTillReceivePercentage A percentage of addresses that were received before an error that should\n+         * be received after a success, after which unreceived addresses are removed by sending appropriate\n+         * {@link ServiceDiscovererEvent}s. When set to {@code 0}, addresses are not retained.\n+         * @return {@code this}.\n+         */\n+        public Builder<ResolvedAddress, E> retainAddressesTillSuccess(final int retainTillReceivePercentage) {\n+            if (retainTillReceivePercentage < 0) {\n+                throw new IllegalArgumentException(\"retainTillReceivePercentage: \" + retainTillReceivePercentage +\n+                        \" (expected >= 0)\");\n+            }\n+            this.retainTillReceivePercentage = retainTillReceivePercentage;\n+            return this;\n+        }\n+\n+        /**\n+         * Specifies a {@link BiFunction} which is applied as-is using {@link Publisher#retryWhen(BiIntFunction)}\n+         * on the {@link Publisher} passed to {@link DefaultServiceDiscoveryRetryStrategy#apply(Publisher)}.\n+         *\n+         * @param retryStrategy A {@link BiFunction} which is applied as-is using\n+         * {@link Publisher#retryWhen(BiIntFunction)} on the {@link Publisher} passed to\n+         * {@link DefaultServiceDiscoveryRetryStrategy#apply(Publisher)}.\n+         * @return {@code this}.\n+         */\n+        public Builder<ResolvedAddress, E> retryStrategy(\n+                final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+            this.retryStrategy = requireNonNull(retryStrategy);\n+            return this;\n+        }\n+\n+        /**\n+         * Creates a new {@link ServiceDiscoveryRetryStrategy}.\n+         *\n+         * @return A new {@link ServiceDiscoveryRetryStrategy}.\n+         */\n+        public ServiceDiscoveryRetryStrategy<ResolvedAddress, E> build() {\n+            return new DefaultServiceDiscoveryRetryStrategy<>(retainTillReceivePercentage, flipAvailability,\n+                    retryStrategy);\n+        }\n+\n+        /**\n+         * Creates a new builder that uses default retries.\n+         *\n+         * @param executor {@link Executor} to use for retry backoffs.\n+         * @param initialDelay {@link Duration} to use as initial delay for backoffs.\n+         * @param <ResolvedAddress> The type of address after resolution.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress, ServiceDiscovererEvent<ResolvedAddress>>\n+        withDefaults(final Executor executor, final Duration initialDelay) {\n+            return new Builder<>(new IndefiniteRetryStrategy(executor, initialDelay),\n+                    evt -> new DefaultServiceDiscovererEvent<>(evt.address(), !evt.isAvailable()));\n+        }\n+\n+        /**\n+         * Creates a new builder that uses default retries.\n+         *\n+         * @param executor {@link Executor} to use for retry backoffs.\n+         * @param initialDelay {@link Duration} to use as initial delay for backoffs.\n+         * @param <ResolvedAddress> The type of address after resolution.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress, PartitionedServiceDiscovererEvent<ResolvedAddress>>\n+        withDefaultsForPartitions(final Executor executor, final Duration initialDelay) {\n+            return new Builder<>(new IndefiniteRetryStrategy(executor, initialDelay),\n+                    evt -> new PartitionedServiceDiscovererEvent<ResolvedAddress>() {\n+                        @Override\n+                        public PartitionAttributes partitionAddress() {\n+                            return evt.partitionAddress();\n+                        }\n+\n+                        @Override\n+                        public ResolvedAddress address() {\n+                            return evt.address();\n+                        }\n+\n+                        @Override\n+                        public boolean isAvailable() {\n+                            return !evt.isAvailable();\n+                        }\n+                    });\n+        }\n+\n+        /**\n+         * Creates a new builder that uses default retries.\n+         *\n+         * @param executor {@link Executor} to use for retry backoffs.\n+         * @param initialDelay {@link Duration} to use as initial delay for backoffs.\n+         * @param flipAvailability {@link UnaryOperator} that returns a new {@link ServiceDiscovererEvent} that is the\n+         * same as the passed {@link ServiceDiscovererEvent} but with {@link ServiceDiscovererEvent#isAvailable()} value\n+         * flipped.\n+         * @param <ResolvedAddress> The type of address after resolution.\n+         * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> Builder<ResolvedAddress, E>\n+        withDefaults(final Executor executor, final Duration initialDelay, final UnaryOperator<E> flipAvailability) {\n+            return new Builder<>(new IndefiniteRetryStrategy(executor, initialDelay), flipAvailability);\n+        }\n+    }\n+\n+    private static final class EventsCache<R, E extends ServiceDiscovererEvent<R>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final Map NONE_RETAINED = emptyMap();\n+\n+        private Map<R, E> retainedAddresses = noneRetained();\n+        private int targetSize;\n+        private final Map<R, E> activeAddresses = new HashMap<>();\n+        private final int retainTillReceivePercentage;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        EventsCache(final int retainTillReceivePercentage, final UnaryOperator<E> flipAvailability) {\n+            this.retainTillReceivePercentage = retainTillReceivePercentage;\n+            this.flipAvailability = flipAvailability;\n+        }\n+\n+        void errorSeen() {\n+            if (retainedAddresses == NONE_RETAINED) {\n+                retainedAddresses = new HashMap<>(activeAddresses);\n+            } else {\n+                retainedAddresses.putAll(activeAddresses);\n+            }\n+            targetSize = (int) (ceil(retainTillReceivePercentage / 100d) * activeAddresses.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0911d866722ebeb2ad7fc03ea74e244f2b71d29f"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwMDc1Nw==", "bodyText": "Great catch!\nWrong placement of brackets \ud83d\ude22\nI will fix and add tests, thanks!", "url": "https://github.com/apple/servicetalk/pull/1115#discussion_r465900757", "createdAt": "2020-08-05T17:50:58Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-api/src/main/java/io/servicetalk/http/api/DefaultServiceDiscoveryRetryStrategy.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.api;\n+\n+import io.servicetalk.client.api.DefaultServiceDiscovererEvent;\n+import io.servicetalk.client.api.ServiceDiscoverer;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.client.api.partition.PartitionAttributes;\n+import io.servicetalk.client.api.partition.PartitionedServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.BiIntFunction;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Executor;\n+import io.servicetalk.concurrent.api.Publisher;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+import java.util.function.UnaryOperator;\n+\n+import static io.servicetalk.concurrent.api.Publisher.defer;\n+import static io.servicetalk.concurrent.api.RetryStrategies.retryWithExponentialBackoffAndJitter;\n+import static java.lang.Math.ceil;\n+import static java.lang.Math.max;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default implementation for {@link ServiceDiscoveryRetryStrategy}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+ */\n+public final class DefaultServiceDiscoveryRetryStrategy<ResolvedAddress,\n+        E extends ServiceDiscovererEvent<ResolvedAddress>>\n+        implements ServiceDiscoveryRetryStrategy<ResolvedAddress, E> {\n+    private final int retainTillReceivePercentage;\n+    private final UnaryOperator<E> flipAvailability;\n+    private final BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+\n+    private DefaultServiceDiscoveryRetryStrategy(final int retainTillReceivePercentage,\n+                                                 final UnaryOperator<E> flipAvailability,\n+                                                 final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+        this.retainTillReceivePercentage = retainTillReceivePercentage;\n+        this.flipAvailability = requireNonNull(flipAvailability);\n+        this.retryStrategy = requireNonNull(retryStrategy);\n+    }\n+\n+    @Override\n+    public Publisher<? extends E> apply(final Publisher<? extends E> sdEvents) {\n+        return defer(() -> {\n+            EventsCache<ResolvedAddress, E> eventsCache =\n+                    new EventsCache<>(retainTillReceivePercentage, flipAvailability);\n+            return sdEvents.flatMapConcatIterable(eventsCache::consume)\n+                    .beforeOnError(__ -> eventsCache.errorSeen())\n+                    .retryWhen(retryStrategy);\n+        });\n+    }\n+\n+    /**\n+     * A builder to build instances of {@link DefaultServiceDiscoveryRetryStrategy}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution.\n+     * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+     */\n+    public static final class Builder<ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> {\n+        // There is no reason for the choice of 75%, it is arbitrary and can be configured by users.\n+        private int retainTillReceivePercentage = 75;\n+        private BiIntFunction<Throwable, ? extends Completable> retryStrategy;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        private Builder(final BiIntFunction<Throwable, ? extends Completable> retryStrategy,\n+                        final UnaryOperator<E> flipAvailability) {\n+            this.retryStrategy = retryStrategy;\n+            this.flipAvailability = requireNonNull(flipAvailability);\n+        }\n+\n+        /**\n+         * A {@link Publisher} returned from {@link ServiceDiscoverer#discover(Object)} may fail transiently leaving the\n+         * consumer of these events with an option of either disposing the addresses that were provided before the\n+         * error or retain them till a retry succeeds. This option enables retention of addresses after an error is\n+         * observed till the total number of received addresses after an error is {@code retainTillReceivePercentage}\n+         * percent of the addresses that were available before the error was received.\n+         *\n+         * @param retainTillReceivePercentage A percentage of addresses that were received before an error that should\n+         * be received after a success, after which unreceived addresses are removed by sending appropriate\n+         * {@link ServiceDiscovererEvent}s. When set to {@code 0}, addresses are not retained.\n+         * @return {@code this}.\n+         */\n+        public Builder<ResolvedAddress, E> retainAddressesTillSuccess(final int retainTillReceivePercentage) {\n+            if (retainTillReceivePercentage < 0) {\n+                throw new IllegalArgumentException(\"retainTillReceivePercentage: \" + retainTillReceivePercentage +\n+                        \" (expected >= 0)\");\n+            }\n+            this.retainTillReceivePercentage = retainTillReceivePercentage;\n+            return this;\n+        }\n+\n+        /**\n+         * Specifies a {@link BiFunction} which is applied as-is using {@link Publisher#retryWhen(BiIntFunction)}\n+         * on the {@link Publisher} passed to {@link DefaultServiceDiscoveryRetryStrategy#apply(Publisher)}.\n+         *\n+         * @param retryStrategy A {@link BiFunction} which is applied as-is using\n+         * {@link Publisher#retryWhen(BiIntFunction)} on the {@link Publisher} passed to\n+         * {@link DefaultServiceDiscoveryRetryStrategy#apply(Publisher)}.\n+         * @return {@code this}.\n+         */\n+        public Builder<ResolvedAddress, E> retryStrategy(\n+                final BiIntFunction<Throwable, ? extends Completable> retryStrategy) {\n+            this.retryStrategy = requireNonNull(retryStrategy);\n+            return this;\n+        }\n+\n+        /**\n+         * Creates a new {@link ServiceDiscoveryRetryStrategy}.\n+         *\n+         * @return A new {@link ServiceDiscoveryRetryStrategy}.\n+         */\n+        public ServiceDiscoveryRetryStrategy<ResolvedAddress, E> build() {\n+            return new DefaultServiceDiscoveryRetryStrategy<>(retainTillReceivePercentage, flipAvailability,\n+                    retryStrategy);\n+        }\n+\n+        /**\n+         * Creates a new builder that uses default retries.\n+         *\n+         * @param executor {@link Executor} to use for retry backoffs.\n+         * @param initialDelay {@link Duration} to use as initial delay for backoffs.\n+         * @param <ResolvedAddress> The type of address after resolution.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress, ServiceDiscovererEvent<ResolvedAddress>>\n+        withDefaults(final Executor executor, final Duration initialDelay) {\n+            return new Builder<>(new IndefiniteRetryStrategy(executor, initialDelay),\n+                    evt -> new DefaultServiceDiscovererEvent<>(evt.address(), !evt.isAvailable()));\n+        }\n+\n+        /**\n+         * Creates a new builder that uses default retries.\n+         *\n+         * @param executor {@link Executor} to use for retry backoffs.\n+         * @param initialDelay {@link Duration} to use as initial delay for backoffs.\n+         * @param <ResolvedAddress> The type of address after resolution.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress, PartitionedServiceDiscovererEvent<ResolvedAddress>>\n+        withDefaultsForPartitions(final Executor executor, final Duration initialDelay) {\n+            return new Builder<>(new IndefiniteRetryStrategy(executor, initialDelay),\n+                    evt -> new PartitionedServiceDiscovererEvent<ResolvedAddress>() {\n+                        @Override\n+                        public PartitionAttributes partitionAddress() {\n+                            return evt.partitionAddress();\n+                        }\n+\n+                        @Override\n+                        public ResolvedAddress address() {\n+                            return evt.address();\n+                        }\n+\n+                        @Override\n+                        public boolean isAvailable() {\n+                            return !evt.isAvailable();\n+                        }\n+                    });\n+        }\n+\n+        /**\n+         * Creates a new builder that uses default retries.\n+         *\n+         * @param executor {@link Executor} to use for retry backoffs.\n+         * @param initialDelay {@link Duration} to use as initial delay for backoffs.\n+         * @param flipAvailability {@link UnaryOperator} that returns a new {@link ServiceDiscovererEvent} that is the\n+         * same as the passed {@link ServiceDiscovererEvent} but with {@link ServiceDiscovererEvent#isAvailable()} value\n+         * flipped.\n+         * @param <ResolvedAddress> The type of address after resolution.\n+         * @param <E> Type of {@link ServiceDiscovererEvent}s published from {@link ServiceDiscoverer#discover(Object)}.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress, E extends ServiceDiscovererEvent<ResolvedAddress>> Builder<ResolvedAddress, E>\n+        withDefaults(final Executor executor, final Duration initialDelay, final UnaryOperator<E> flipAvailability) {\n+            return new Builder<>(new IndefiniteRetryStrategy(executor, initialDelay), flipAvailability);\n+        }\n+    }\n+\n+    private static final class EventsCache<R, E extends ServiceDiscovererEvent<R>> {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final Map NONE_RETAINED = emptyMap();\n+\n+        private Map<R, E> retainedAddresses = noneRetained();\n+        private int targetSize;\n+        private final Map<R, E> activeAddresses = new HashMap<>();\n+        private final int retainTillReceivePercentage;\n+        private final UnaryOperator<E> flipAvailability;\n+\n+        EventsCache(final int retainTillReceivePercentage, final UnaryOperator<E> flipAvailability) {\n+            this.retainTillReceivePercentage = retainTillReceivePercentage;\n+            this.flipAvailability = flipAvailability;\n+        }\n+\n+        void errorSeen() {\n+            if (retainedAddresses == NONE_RETAINED) {\n+                retainedAddresses = new HashMap<>(activeAddresses);\n+            } else {\n+                retainedAddresses.putAll(activeAddresses);\n+            }\n+            targetSize = (int) (ceil(retainTillReceivePercentage / 100d) * activeAddresses.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0NjIyNg=="}, "originalCommit": {"oid": "0911d866722ebeb2ad7fc03ea74e244f2b71d29f"}, "originalPosition": 223}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2526, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}