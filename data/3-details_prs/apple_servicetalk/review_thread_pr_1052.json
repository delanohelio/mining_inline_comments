{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3NjcwNzg0", "number": 1052, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMzo1MDo1MlrOD8RoTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTo0NDo0NlrOD8icOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTI5OTk3OnYy", "diffSide": "RIGHT", "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMzo1MDo1MlrOGVHZrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMzo1MDo1MlrOGVHZrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NDU0MA==", "bodyText": "Consider using emptyList() to allow currentAddresses to be GCed.", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424794540", "createdAt": "2020-05-13T23:50:52Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -150,29 +150,26 @@ public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                         event);\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n                         activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n                             final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n-                                if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n-                                    }\n-                                }\n-                            }\n+                            final List<Host<ResolvedAddress, C>> refreshedAddresses;\n                             if (event.isAvailable()) {\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() + 1);\n+                                refreshedAddresses.addAll(currentAddresses);\n                                 refreshedAddresses.add(new Host<>(addr));\n-                                return refreshedAddresses;\n+                            } else if (currentAddresses.isEmpty()) {\n+                                refreshedAddresses = currentAddresses;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0060468acd5bf55e8f65e268b102d564d5b513c9"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTMwMzcwOnYy", "diffSide": "RIGHT", "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMzo1Mjo0MlrOGVHb3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMjo0Nzo1NlrOGVKNxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NTEwMg==", "bodyText": "ArrayList.addAll(anotherArrayList) implementation does copying two times internally:\n\nto convert anotherArrayList to array\nto copy that new array into its elementData\n\nAmount of allocated memory and copied elements remains the same.\nAlso, I won't expect this to be a perf issue, as usually new addresses does not appear frequently.", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424795102", "createdAt": "2020-05-13T23:52:42Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -150,29 +150,26 @@ public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                         event);\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n                         activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n                             final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n-                                if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n-                                    }\n-                                }\n-                            }\n+                            final List<Host<ResolvedAddress, C>> refreshedAddresses;\n                             if (event.isAvailable()) {\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() + 1);\n+                                refreshedAddresses.addAll(currentAddresses);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0060468acd5bf55e8f65e268b102d564d5b513c9"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0MDY0NA==", "bodyText": "Good observation that addAll does a toArray(). However this is an implementation detail of addAll which isn't strictly required. This approach avoids iteration for duplicate detection and an upfront copy and additional copy/shift for removal (at the expense of iterative additions instead of bulk copy operations). I'll add benchmarks for more insight: #1052 (comment)", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424840644", "createdAt": "2020-05-14T02:47:56Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -150,29 +150,26 @@ public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                         event);\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n                         activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n                             final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n-                                if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n-                                    }\n-                                }\n-                            }\n+                            final List<Host<ResolvedAddress, C>> refreshedAddresses;\n                             if (event.isAvailable()) {\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() + 1);\n+                                refreshedAddresses.addAll(currentAddresses);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NTEwMg=="}, "originalCommit": {"oid": "0060468acd5bf55e8f65e268b102d564d5b513c9"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTMwNzU5OnYy", "diffSide": "RIGHT", "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QyMzo1NDo0OVrOGVHeSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDowOTowNlrOGVLYLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NTcyMw==", "bodyText": "As we discussed in #1051 (comment), SD may emit duplicated events and it should be expected.", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424795723", "createdAt": "2020-05-13T23:54:49Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -150,29 +150,26 @@ public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                         event);\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n                         activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n                             final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n-                                if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n-                                    }\n-                                }\n-                            }\n+                            final List<Host<ResolvedAddress, C>> refreshedAddresses;\n                             if (event.isAvailable()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0060468acd5bf55e8f65e268b102d564d5b513c9"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0MzQwMQ==", "bodyText": "thx for pointing this out. I don't think we need todo duplicate detection in the LoadBalancer. the previous binarySearch approach was done for faster lookup and duplicate detection was a side effect.", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424843401", "createdAt": "2020-05-14T02:58:51Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -150,29 +150,26 @@ public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                         event);\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n                         activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n                             final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n-                                if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n-                                    }\n-                                }\n-                            }\n+                            final List<Host<ResolvedAddress, C>> refreshedAddresses;\n                             if (event.isAvailable()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NTcyMw=="}, "originalCommit": {"oid": "0060468acd5bf55e8f65e268b102d564d5b513c9"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1OTY5Mw==", "bodyText": "sgtm!", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424859693", "createdAt": "2020-05-14T04:09:06Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -150,29 +150,26 @@ public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                         event);\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n                         activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n                             final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n-                                if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n-                                    }\n-                                }\n-                            }\n+                            final List<Host<ResolvedAddress, C>> refreshedAddresses;\n                             if (event.isAvailable()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDc5NTcyMw=="}, "originalCommit": {"oid": "0060468acd5bf55e8f65e268b102d564d5b513c9"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTYxMjE5OnYy", "diffSide": "LEFT", "path": "servicetalk-loadbalancer/src/test/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMjo1ODo0OVrOGVKYgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMzowNjoyM1rOGVKffw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0MzM5NA==", "bodyText": "This test is still relevant, the assert can be changed.", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424843394", "createdAt": "2020-05-14T02:58:49Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-loadbalancer/src/test/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancerTest.java", "diffHunk": "@@ -242,15 +242,6 @@ public void unknownAddressIsRemoved() {\n         assertThat(lb.activeAddresses(), is(empty()));\n     }\n \n-    @Test\n-    public void addressIsAddedTwice() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "931875bc904c645e45c912bd7ba7874b60f9855c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0NTE4Mw==", "bodyText": "sounds good", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424845183", "createdAt": "2020-05-14T03:06:23Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-loadbalancer/src/test/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancerTest.java", "diffHunk": "@@ -242,15 +242,6 @@ public void unknownAddressIsRemoved() {\n         assertThat(lb.activeAddresses(), is(empty()));\n     }\n \n-    @Test\n-    public void addressIsAddedTwice() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0MzM5NA=="}, "originalCommit": {"oid": "931875bc904c645e45c912bd7ba7874b60f9855c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTYxNjM3OnYy", "diffSide": "LEFT", "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwMzowMToyOVrOGVKbBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNzozMTo1MFrOGVnAJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0NDAzOQ==", "bodyText": "An equivalent log may still be useful to detect descrepancies of events from SD or an issue with our matching.", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424844039", "createdAt": "2020-05-14T03:01:29Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -150,29 +150,26 @@ public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                         event);\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n                         activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n                             final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n-                                if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n-                                    }\n-                                }\n-                            }\n+                            final List<Host<ResolvedAddress, C>> refreshedAddresses;\n                             if (event.isAvailable()) {\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() + 1);\n+                                refreshedAddresses.addAll(currentAddresses);\n                                 refreshedAddresses.add(new Host<>(addr));\n-                                return refreshedAddresses;\n+                            } else if (currentAddresses.isEmpty()) {\n+                                refreshedAddresses = emptyList();\n                             } else {\n-                                LOGGER.debug(\"Address {} removed but it does not exist.\", addr);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "931875bc904c645e45c912bd7ba7874b60f9855c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1MTIzOA==", "bodyText": "I would prefer to avoid modifying control flow just for debug logs if possible (e.g. add boolean check it after loop). there is a debug statement before this operation for the event and after to prints all addresses which should be sufficient to detect the no-change scenario. I understand not having this log is dropping a targeted log statement for this condition, but this was the state for a while so trying to understand more context (e.g. too difficult to detect in practice, etc..).", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424851238", "createdAt": "2020-05-14T03:32:30Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -150,29 +150,26 @@ public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                         event);\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n                         activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n                             final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n-                                if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n-                                    }\n-                                }\n-                            }\n+                            final List<Host<ResolvedAddress, C>> refreshedAddresses;\n                             if (event.isAvailable()) {\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() + 1);\n+                                refreshedAddresses.addAll(currentAddresses);\n                                 refreshedAddresses.add(new Host<>(addr));\n-                                return refreshedAddresses;\n+                            } else if (currentAddresses.isEmpty()) {\n+                                refreshedAddresses = emptyList();\n                             } else {\n-                                LOGGER.debug(\"Address {} removed but it does not exist.\", addr);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0NDAzOQ=="}, "originalCommit": {"oid": "931875bc904c645e45c912bd7ba7874b60f9855c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA5MzQ0Mg==", "bodyText": "I changed the control flow so that we now only remove the first match ... so the control flow change would be lesser to add this log statement back. however we would need need to add another log statement if the oldHosts.isEmpty() to cover both cases ... still not sure the additional log(s) are necessary. wdyt?", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r425093442", "createdAt": "2020-05-14T12:21:49Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -150,29 +150,26 @@ public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                         event);\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n                         activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n                             final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n-                                if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n-                                    }\n-                                }\n-                            }\n+                            final List<Host<ResolvedAddress, C>> refreshedAddresses;\n                             if (event.isAvailable()) {\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() + 1);\n+                                refreshedAddresses.addAll(currentAddresses);\n                                 refreshedAddresses.add(new Host<>(addr));\n-                                return refreshedAddresses;\n+                            } else if (currentAddresses.isEmpty()) {\n+                                refreshedAddresses = emptyList();\n                             } else {\n-                                LOGGER.debug(\"Address {} removed but it does not exist.\", addr);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0NDAzOQ=="}, "originalCommit": {"oid": "931875bc904c645e45c912bd7ba7874b60f9855c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMxMjI5NQ==", "bodyText": "I didn't see that we already have logs at start and end of this method, so adding this log makes less sense. Disregard my comment here.", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r425312295", "createdAt": "2020-05-14T17:31:50Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -150,29 +150,26 @@ public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                         event);\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n                         activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n                             final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n-                                if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n-                                    }\n-                                }\n-                            }\n+                            final List<Host<ResolvedAddress, C>> refreshedAddresses;\n                             if (event.isAvailable()) {\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() + 1);\n+                                refreshedAddresses.addAll(currentAddresses);\n                                 refreshedAddresses.add(new Host<>(addr));\n-                                return refreshedAddresses;\n+                            } else if (currentAddresses.isEmpty()) {\n+                                refreshedAddresses = emptyList();\n                             } else {\n-                                LOGGER.debug(\"Address {} removed but it does not exist.\", addr);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg0NDAzOQ=="}, "originalCommit": {"oid": "931875bc904c645e45c912bd7ba7874b60f9855c"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NTcxMzcyOnYy", "diffSide": "RIGHT", "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNDowNjo1N1rOGVLV1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQwNTowNjo0NVrOGVMMsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1OTA5Mw==", "bodyText": "currentAddresses.size() - 1 may give a zero as the result. Consider rewriting in this way:\nif (event.isAvailable()) {\n    ...\n} else if (currentAddresses.size() <= 1) {\n    refreshedAddresses = emptyList();\n} else {\n    refreshedAddresses = new ArrayList<>(currentAddresses.size() - 1);\n    ...\n}", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424859093", "createdAt": "2020-05-14T04:06:57Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -150,29 +150,26 @@ public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                         event);\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n                         activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n                             final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n-                                if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n-                                    }\n-                                }\n-                            }\n+                            final List<Host<ResolvedAddress, C>> refreshedAddresses;\n                             if (event.isAvailable()) {\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() + 1);\n+                                refreshedAddresses.addAll(currentAddresses);\n                                 refreshedAddresses.add(new Host<>(addr));\n-                                return refreshedAddresses;\n+                            } else if (currentAddresses.isEmpty()) {\n+                                refreshedAddresses = emptyList();\n                             } else {\n-                                LOGGER.debug(\"Address {} removed but it does not exist.\", addr);\n-                                return currentAddresses;\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebeca0d822082ce444d4a54b3f88f7cdfb834c1c"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2MDA1Mg==", "bodyText": "hm, may be worth checking that addresses are equal when currentAddresses.size() == 1.", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424860052", "createdAt": "2020-05-14T04:10:37Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -150,29 +150,26 @@ public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                         event);\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n                         activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n                             final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n-                                if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n-                                    }\n-                                }\n-                            }\n+                            final List<Host<ResolvedAddress, C>> refreshedAddresses;\n                             if (event.isAvailable()) {\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() + 1);\n+                                refreshedAddresses.addAll(currentAddresses);\n                                 refreshedAddresses.add(new Host<>(addr));\n-                                return refreshedAddresses;\n+                            } else if (currentAddresses.isEmpty()) {\n+                                refreshedAddresses = emptyList();\n                             } else {\n-                                LOGGER.debug(\"Address {} removed but it does not exist.\", addr);\n-                                return currentAddresses;\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() - 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1OTA5Mw=="}, "originalCommit": {"oid": "ebeca0d822082ce444d4a54b3f88f7cdfb834c1c"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg2NTYwOQ==", "bodyText": "Not sure if we need to be too paranoid, but here is the version \ud83d\ude04\nfinal ResolvedAddress addr = requireNonNull(event.address());\nif (event.isAvailable()) {\n    if (currentAddresses.isEmpty()) {\n        return singletonList(new Host<>(addr));\n    }\n    final List<Host<ResolvedAddress, C>> refreshedAddresses =\n            new ArrayList<>(currentAddresses.size() + 1);\n    refreshedAddresses.addAll(currentAddresses);\n    refreshedAddresses.add(new Host<>(addr));\n    return refreshedAddresses;\n} else {\n    Host<ResolvedAddress, C> host;\n    switch (currentAddresses.size()) {\n        case 0:\n            return emptyList();\n        case 1:\n            host = (Host<ResolvedAddress, C>) currentAddresses.get(0);\n            return addr.equals(host.address) ? emptyList() : singletonList(host);\n        case 2:\n            host = (Host<ResolvedAddress, C>) currentAddresses.get(0);\n            if (addr.equals(host.address)) {\n                return singletonList(currentAddresses.get(1));\n            }\n            host = (Host<ResolvedAddress, C>) currentAddresses.get(1);\n            if (addr.equals(host.address)) {\n                return singletonList(currentAddresses.get(0));\n            }\n            return currentAddresses;\n        default:\n            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n                    new ArrayList<>(currentAddresses.size() - 1);\n            for (Host<ResolvedAddress, C> hostItem :\n                    (List<Host<ResolvedAddress, C>>) currentAddresses) {\n                if (hostItem.address.equals(addr)) {\n                    hostItem.markInactive();\n                } else {\n                    refreshedAddresses.add(hostItem);\n                }\n            }\n            return refreshedAddresses;\n    }\n}", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424865609", "createdAt": "2020-05-14T04:34:31Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -150,29 +150,26 @@ public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                         event);\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n                         activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n                             final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n-                                if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n-                                    }\n-                                }\n-                            }\n+                            final List<Host<ResolvedAddress, C>> refreshedAddresses;\n                             if (event.isAvailable()) {\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() + 1);\n+                                refreshedAddresses.addAll(currentAddresses);\n                                 refreshedAddresses.add(new Host<>(addr));\n-                                return refreshedAddresses;\n+                            } else if (currentAddresses.isEmpty()) {\n+                                refreshedAddresses = emptyList();\n                             } else {\n-                                LOGGER.debug(\"Address {} removed but it does not exist.\", addr);\n-                                return currentAddresses;\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() - 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1OTA5Mw=="}, "originalCommit": {"oid": "ebeca0d822082ce444d4a54b3f88f7cdfb834c1c"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg3MzEzOQ==", "bodyText": "this code would be a bit more complex in practice because we need to call markInactive when removing, and also for the removal of case 2 we need to check if both elements match bcz there maybe duplicates. I will take some of the suggestions (singleton list for adding when empty, return empty list if after removal the array is empty) but keep it simple as the list being empty isn't generally expected (e.g. we wouldn't be able to communicate with servers in that case).", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r424873139", "createdAt": "2020-05-14T05:06:45Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -150,29 +150,26 @@ public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                         event);\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n                         activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n                             final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n-                                if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n-                                    }\n-                                }\n-                            }\n+                            final List<Host<ResolvedAddress, C>> refreshedAddresses;\n                             if (event.isAvailable()) {\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() + 1);\n+                                refreshedAddresses.addAll(currentAddresses);\n                                 refreshedAddresses.add(new Host<>(addr));\n-                                return refreshedAddresses;\n+                            } else if (currentAddresses.isEmpty()) {\n+                                refreshedAddresses = emptyList();\n                             } else {\n-                                LOGGER.debug(\"Address {} removed but it does not exist.\", addr);\n-                                return currentAddresses;\n+                                refreshedAddresses = new ArrayList<>(currentAddresses.size() - 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg1OTA5Mw=="}, "originalCommit": {"oid": "ebeca0d822082ce444d4a54b3f88f7cdfb834c1c"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0ODA1NDM0OnYy", "diffSide": "RIGHT", "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTo0NDo0NlrOGVihqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjoxNDowNVrOGVj0XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIzODk1NA==", "bodyText": "We said that it's ok to have duplicated addresses from SD. Neither SD, nor RRLB removes duplicates. What is expected behavior when we receive inactive event for an address that appears multiple times in the list? Should we remove all entries or only the first one?", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r425238954", "createdAt": "2020-05-14T15:44:46Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -143,37 +144,43 @@ public void onSubscribe(final Subscription s) {\n                 discoveryCancellable.nextCancellable(s);\n             }\n \n-            @SuppressWarnings(\"unchecked\")\n             @Override\n             public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                 LOGGER.debug(\"Load balancer {}, received new ServiceDiscoverer event {}.\", RoundRobinLoadBalancer.this,\n                         event);\n+                @SuppressWarnings(\"unchecked\")\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n-                        activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n-                            final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n+                    activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, oldHosts -> {\n+                        final ResolvedAddress addr = requireNonNull(event.address());\n+                        @SuppressWarnings(\"unchecked\")\n+                        final List<Host<ResolvedAddress, C>> oldHostsTyped = (List<Host<ResolvedAddress, C>>) oldHosts;\n+                        if (event.isAvailable()) {\n+                            if (oldHostsTyped.isEmpty()) {\n+                                return singletonList(new Host<>(addr));\n+                            }\n+                            final List<Host<ResolvedAddress, C>> newHosts = new ArrayList<>(oldHostsTyped.size() + 1);\n+                            newHosts.addAll(oldHostsTyped);\n+                            newHosts.add(new Host<>(addr));\n+                            return newHosts;\n+                        } else if (oldHostsTyped.isEmpty()) {\n+                            return emptyList();\n+                        } else {\n+                            final List<Host<ResolvedAddress, C>> newHosts = new ArrayList<>(oldHostsTyped.size() - 1);\n+                            for (int i = 0; i < oldHostsTyped.size(); ++i) {\n+                                final Host<ResolvedAddress, C> host = oldHostsTyped.get(i);\n                                 if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n+                                    host.markInactive();\n+                                    for (int x = i + 1; x < oldHostsTyped.size(); ++x) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b520ad49d5a8183867864a097b0b0953c4e13920"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI2MDEyNQ==", "bodyText": "initially this PR was removing all items that matched, however I updated it last night to just the first match. for each available event there should be a corresponding unavailable event. if duplicates are used for weighting (e.g. duplicate entries make it more likely to select) then adjusting the weighting by removing an entry shouldn't remove all matching entries.", "url": "https://github.com/apple/servicetalk/pull/1052#discussion_r425260125", "createdAt": "2020-05-14T16:14:05Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -143,37 +144,43 @@ public void onSubscribe(final Subscription s) {\n                 discoveryCancellable.nextCancellable(s);\n             }\n \n-            @SuppressWarnings(\"unchecked\")\n             @Override\n             public void onNext(final ServiceDiscovererEvent<ResolvedAddress> event) {\n                 LOGGER.debug(\"Load balancer {}, received new ServiceDiscoverer event {}.\", RoundRobinLoadBalancer.this,\n                         event);\n+                @SuppressWarnings(\"unchecked\")\n                 final List<Host<ResolvedAddress, C>> activeAddresses =\n-                        activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, currentAddresses -> {\n-                            final List<Host<ResolvedAddress, C>> refreshedAddresses =\n-                                    new ArrayList<Host<ResolvedAddress, C>>(currentAddresses);\n-                            final ResolvedAddress addr = requireNonNull(event.address());\n-                            for (int i = 0; i < refreshedAddresses.size(); i++) {\n-                                Host<ResolvedAddress, C> host = refreshedAddresses.get(i);\n+                    activeHostsUpdater.updateAndGet(RoundRobinLoadBalancer.this, oldHosts -> {\n+                        final ResolvedAddress addr = requireNonNull(event.address());\n+                        @SuppressWarnings(\"unchecked\")\n+                        final List<Host<ResolvedAddress, C>> oldHostsTyped = (List<Host<ResolvedAddress, C>>) oldHosts;\n+                        if (event.isAvailable()) {\n+                            if (oldHostsTyped.isEmpty()) {\n+                                return singletonList(new Host<>(addr));\n+                            }\n+                            final List<Host<ResolvedAddress, C>> newHosts = new ArrayList<>(oldHostsTyped.size() + 1);\n+                            newHosts.addAll(oldHostsTyped);\n+                            newHosts.add(new Host<>(addr));\n+                            return newHosts;\n+                        } else if (oldHostsTyped.isEmpty()) {\n+                            return emptyList();\n+                        } else {\n+                            final List<Host<ResolvedAddress, C>> newHosts = new ArrayList<>(oldHostsTyped.size() - 1);\n+                            for (int i = 0; i < oldHostsTyped.size(); ++i) {\n+                                final Host<ResolvedAddress, C> host = oldHostsTyped.get(i);\n                                 if (host.address.equals(addr)) {\n-                                    if (event.isAvailable()) {\n-                                        LOGGER.debug(\"Address {} added but it already exists.\", addr);\n-                                        return currentAddresses;\n-                                    } else {\n-                                        refreshedAddresses.remove(i);\n-                                        host.markInactive();\n-                                        return refreshedAddresses;\n+                                    host.markInactive();\n+                                    for (int x = i + 1; x < oldHostsTyped.size(); ++x) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIzODk1NA=="}, "originalCommit": {"oid": "b520ad49d5a8183867864a097b0b0953c4e13920"}, "originalPosition": 52}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2752, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}