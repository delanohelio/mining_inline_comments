{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1NDM3MTIx", "number": 1026, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOToxMjo0M1rOD0ZIcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxOToxNzozM1rOD22sYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjY0MzA2OnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/CompletableProcessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOToxMjo0M1rOGJUPZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMzowMTo0OFrOGNAYyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyMTk4OA==", "bodyText": "Should we worry about multiple exceptions while we iterate all subscribers? Can we left a comment describing why we take only the first cause and ignore others?", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r412421988", "createdAt": "2020-04-21T19:12:43Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/CompletableProcessor.java", "diffHunk": "@@ -111,7 +90,20 @@ private void terminate(TerminalNotification terminalSignal) {\n     }\n \n     private void notifyListeners(TerminalNotification terminalSignal) {\n-        drainSingleConsumerQueueDelayThrow(subscribers, terminalSignal::terminate, drainingTheQueueUpdater, this);\n+        Throwable delayedCause = null;\n+        Subscriber subscriber;\n+        while ((subscriber = subscribers.poll()) != null) {\n+            try {\n+                terminalSignal.terminate(subscriber);\n+            } catch (Throwable cause) {\n+                if (delayedCause == null) {\n+                    delayedCause = cause;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4MTgwNA==", "bodyText": "Ok, I saw this discussion: #1011 (comment)\nCan you please leave a comment in all such places for future contributors to help them understand this decision?", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r412481804", "createdAt": "2020-04-21T20:49:57Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/CompletableProcessor.java", "diffHunk": "@@ -111,7 +90,20 @@ private void terminate(TerminalNotification terminalSignal) {\n     }\n \n     private void notifyListeners(TerminalNotification terminalSignal) {\n-        drainSingleConsumerQueueDelayThrow(subscribers, terminalSignal::terminate, drainingTheQueueUpdater, this);\n+        Throwable delayedCause = null;\n+        Subscriber subscriber;\n+        while ((subscriber = subscribers.poll()) != null) {\n+            try {\n+                terminalSignal.terminate(subscriber);\n+            } catch (Throwable cause) {\n+                if (delayedCause == null) {\n+                    delayedCause = cause;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyMTk4OA=="}, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI5MTAxOQ==", "bodyText": "I added a ThrowableUtils#catchUnexpected method to consolidate the usage and make it easier to change later if necessary (and added comments here).", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416291019", "createdAt": "2020-04-28T03:01:48Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/CompletableProcessor.java", "diffHunk": "@@ -111,7 +90,20 @@ private void terminate(TerminalNotification terminalSignal) {\n     }\n \n     private void notifyListeners(TerminalNotification terminalSignal) {\n-        drainSingleConsumerQueueDelayThrow(subscribers, terminalSignal::terminate, drainingTheQueueUpdater, this);\n+        Throwable delayedCause = null;\n+        Subscriber subscriber;\n+        while ((subscriber = subscribers.poll()) != null) {\n+            try {\n+                terminalSignal.terminate(subscriber);\n+            } catch (Throwable cause) {\n+                if (delayedCause == null) {\n+                    delayedCause = cause;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyMTk4OA=="}, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Nzc1ODkxOnYy", "diffSide": "LEFT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/CompletableProcessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjo0ODoxM1rOGMtRYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMzo0Nzo0OFrOGM8Yog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk3NzgyNA==", "bodyText": "Since we are simplifying this code, we can also remove the \"notify all subscribers in order\" semantics from here. I am pretty sure we do not need it.\nif (subscribers.offer(subscriber)) {\n    TerminalNotification terminalSignal = this.terminalSignal;\n    if (terminalSignal != null && subscribers.remove(subscriber)) {\n        terminalSignal.terminate(subscriber);\n    } else {", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r415977824", "createdAt": "2020-04-27T16:48:13Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/CompletableProcessor.java", "diffHunk": "@@ -67,20 +59,7 @@ protected void handleSubscribe(Subscriber subscriber) {\n                 delayedCancellable.delayedCancellable(() -> {\n                     // Cancel in this case will just cleanup references from the queue to ensure we don't prevent GC of\n                     // these references.\n-                    if (!drainingTheQueueUpdater.compareAndSet(this, CONCURRENT_IDLE, CONCURRENT_EMITTING)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIxMzMyNg==", "bodyText": "lets do this as a followup PR as you indicated it changes behavior/semantics and if we do relax constraints would be useful to have explicit PR/commit for release note notification.", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416213326", "createdAt": "2020-04-27T23:17:14Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/CompletableProcessor.java", "diffHunk": "@@ -67,20 +59,7 @@ protected void handleSubscribe(Subscriber subscriber) {\n                 delayedCancellable.delayedCancellable(() -> {\n                     // Cancel in this case will just cleanup references from the queue to ensure we don't prevent GC of\n                     // these references.\n-                    if (!drainingTheQueueUpdater.compareAndSet(this, CONCURRENT_IDLE, CONCURRENT_EMITTING)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk3NzgyNA=="}, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIyNTQ0Mg==", "bodyText": "#1033", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416225442", "createdAt": "2020-04-27T23:47:48Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/CompletableProcessor.java", "diffHunk": "@@ -67,20 +59,7 @@ protected void handleSubscribe(Subscriber subscriber) {\n                 delayedCancellable.delayedCancellable(() -> {\n                     // Cancel in this case will just cleanup references from the queue to ensure we don't prevent GC of\n                     // these references.\n-                    if (!drainingTheQueueUpdater.compareAndSet(this, CONCURRENT_IDLE, CONCURRENT_EMITTING)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk3NzgyNA=="}, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Nzc4NjcxOnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/CompositeException.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjo1Mzo0MlrOGMth1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjo1Mzo0MlrOGMth1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4MjAzOQ==", "bodyText": "perhaps a good time to rename this method to indicate that it throws? eg: finishAndThrow()", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r415982039", "createdAt": "2020-04-27T16:53:42Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/CompositeException.java", "diffHunk": "@@ -55,13 +48,30 @@ void add(Throwable toAdd) {\n         if (!suppressed.offer(toAdd)) {\n             addSuppressed(toAdd);\n         }\n+        // if addAllPendingSuppressed has already been called don't bother trying to synchronize/drain the queue\n+        // as it is assumed the exception will be thrown after that method is called.\n     }\n \n     /**\n      * Adds all {@link Throwable}s added using {@link #add(Throwable)} to this {@link CompositeException} using\n      * {@link #addSuppressed(Throwable)}.\n+     * <p>\n+     * It is assumed that {@link #add(Throwable)} won't be called after this method.\n      */\n     void addAllPendingSuppressed() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODI0NzY3OnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxODoyOTo0MFrOGMxuTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMzoyOTozN1rOGM79Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1MDc2Nw==", "bodyText": "rename to tryAcquireEmissionLock?", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416050767", "createdAt": "2020-04-27T18:29:40Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "diffHunk": "@@ -25,61 +23,52 @@\n  * Utilities which can be used for concurrency.\n  */\n public final class ConcurrentUtils {\n-    private static final int NOT_EXECUTING_EXCLUSIVE = 0;\n-    private static final int EXECUTING_EXCLUSIVE = 1;\n-    private static final int CONCURRENT_EXECUTE_EXCLUSIVE = 2;\n-\n-    public static final int CONCURRENT_IDLE = 0;\n-    public static final int CONCURRENT_EMITTING = 1;\n+    private static final int CONCURRENT_IDLE = 0;\n+    private static final int CONCURRENT_EMITTING = 1;\n+    private static final int CONCURRENT_PENDING = 2;\n \n     private ConcurrentUtils() {\n         // No instances.\n     }\n \n     /**\n-     * Drains the passed single-consumer {@link Queue} and ensures that it is empty before returning.\n-     * This accounts for any additions to the {@link Queue} while drain is in progress.\n-     * Multiple threads can call this method concurrently but only one thread will actively drain the {@link Queue}.\n-     *\n-     * @param queue {@link Queue} to drain.\n-     * @param forEach {@link Consumer} for each item that is drained.\n-     * @param drainActiveUpdater An {@link AtomicIntegerFieldUpdater} for an {@code int} that is used to guard against\n-     * concurrent drains.\n-     * @param flagOwner Holding instance for {@code drainActiveUpdater}.\n-     * @param <T> Type of items stored in the {@link Queue}.\n-     * @param <R> Type of the object holding the {@link int} referred by {@link AtomicIntegerFieldUpdater}.\n-     * @return Number of items drained from the queue.\n+     * Acquire a lock that is exclusively held with no re-entry, but attempts to acquire the lock while it is\n+     * held can be detected by {@link #releasePendingLock(AtomicIntegerFieldUpdater, Object)}.\n+     * @param lockUpdater The {@link AtomicIntegerFieldUpdater} used to control the lock state.\n+     * @param owner The owner of the lock object.\n+     * @param <T> The type of object that owns the lock.\n+     * @return {@code true} if the lock was acquired, {@code false} otherwise.\n      */\n-    public static <T, R> long drainSingleConsumerQueue(final Queue<T> queue, final Consumer<T> forEach,\n-                                                       final AtomicIntegerFieldUpdater<R> drainActiveUpdater,\n-                                                       final R flagOwner) {\n-        long drainedCount = 0;\n-        do {\n-            if (!drainActiveUpdater.compareAndSet(flagOwner, CONCURRENT_IDLE, CONCURRENT_EMITTING)) {\n-                break;\n-            }\n-            try {\n-                T t;\n-                while ((t = queue.poll()) != null) {\n-                    ++drainedCount;\n-                    forEach.accept(t);\n+    public static <T> boolean acquirePendingLock(AtomicIntegerFieldUpdater<T> lockUpdater, T owner) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIxODQwMg==", "bodyText": "i agree the existing name isn't ideal. I wanted to convey the lock state is 3 fold and there is a \"hand off\" if failure to acquire.\ndiscussed offline and we will go with tryAcquireLock and releaseLock", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416218402", "createdAt": "2020-04-27T23:29:37Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "diffHunk": "@@ -25,61 +23,52 @@\n  * Utilities which can be used for concurrency.\n  */\n public final class ConcurrentUtils {\n-    private static final int NOT_EXECUTING_EXCLUSIVE = 0;\n-    private static final int EXECUTING_EXCLUSIVE = 1;\n-    private static final int CONCURRENT_EXECUTE_EXCLUSIVE = 2;\n-\n-    public static final int CONCURRENT_IDLE = 0;\n-    public static final int CONCURRENT_EMITTING = 1;\n+    private static final int CONCURRENT_IDLE = 0;\n+    private static final int CONCURRENT_EMITTING = 1;\n+    private static final int CONCURRENT_PENDING = 2;\n \n     private ConcurrentUtils() {\n         // No instances.\n     }\n \n     /**\n-     * Drains the passed single-consumer {@link Queue} and ensures that it is empty before returning.\n-     * This accounts for any additions to the {@link Queue} while drain is in progress.\n-     * Multiple threads can call this method concurrently but only one thread will actively drain the {@link Queue}.\n-     *\n-     * @param queue {@link Queue} to drain.\n-     * @param forEach {@link Consumer} for each item that is drained.\n-     * @param drainActiveUpdater An {@link AtomicIntegerFieldUpdater} for an {@code int} that is used to guard against\n-     * concurrent drains.\n-     * @param flagOwner Holding instance for {@code drainActiveUpdater}.\n-     * @param <T> Type of items stored in the {@link Queue}.\n-     * @param <R> Type of the object holding the {@link int} referred by {@link AtomicIntegerFieldUpdater}.\n-     * @return Number of items drained from the queue.\n+     * Acquire a lock that is exclusively held with no re-entry, but attempts to acquire the lock while it is\n+     * held can be detected by {@link #releasePendingLock(AtomicIntegerFieldUpdater, Object)}.\n+     * @param lockUpdater The {@link AtomicIntegerFieldUpdater} used to control the lock state.\n+     * @param owner The owner of the lock object.\n+     * @param <T> The type of object that owns the lock.\n+     * @return {@code true} if the lock was acquired, {@code false} otherwise.\n      */\n-    public static <T, R> long drainSingleConsumerQueue(final Queue<T> queue, final Consumer<T> forEach,\n-                                                       final AtomicIntegerFieldUpdater<R> drainActiveUpdater,\n-                                                       final R flagOwner) {\n-        long drainedCount = 0;\n-        do {\n-            if (!drainActiveUpdater.compareAndSet(flagOwner, CONCURRENT_IDLE, CONCURRENT_EMITTING)) {\n-                break;\n-            }\n-            try {\n-                T t;\n-                while ((t = queue.poll()) != null) {\n-                    ++drainedCount;\n-                    forEach.accept(t);\n+    public static <T> boolean acquirePendingLock(AtomicIntegerFieldUpdater<T> lockUpdater, T owner) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1MDc2Nw=="}, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODI3Njc4OnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherConcatMapIterable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxODozNjoxMVrOGMx_RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMzozNDo0MVrOGM8FQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NTEwOA==", "bodyText": "This is pre-existing but looks like we will invoke the target onError twice if strategy is Propagate, terminalNotification is non-null (from onError() above) and currentIterator.hasNext() throws.", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416055108", "createdAt": "2020-04-27T18:36:11Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherConcatMapIterable.java", "diffHunk": "@@ -204,53 +194,32 @@ private void tryDrainIterator(Iterator<? extends U> currentIterator, Subscriptio\n                         terminalNotification.terminate(target);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIyMDQ4MQ==", "bodyText": "good catch .. I'll hard return our early", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416220481", "createdAt": "2020-04-27T23:34:41Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherConcatMapIterable.java", "diffHunk": "@@ -204,53 +194,32 @@ private void tryDrainIterator(Iterator<? extends U> currentIterator, Subscriptio\n                         terminalNotification.terminate(target);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1NTEwOA=="}, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODI5NTcxOnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherConcatMapIterable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxODo0MDozNlrOGMyKZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxODo0MDozNlrOGMyKZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1Nzk1Nw==", "bodyText": "Consider adding a comment that visibility is guaranteed by write/read of emitting lock", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416057957", "createdAt": "2020-04-27T18:40:36Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherConcatMapIterable.java", "diffHunk": "@@ -53,23 +53,25 @@\n     }\n \n     private static final class FlatMapIterableSubscriber<T, U> implements Subscriber<T>, Subscription {\n+        @SuppressWarnings(\"rawtypes\")\n         private static final AtomicLongFieldUpdater<FlatMapIterableSubscriber> requestNUpdater =\n                 AtomicLongFieldUpdater.newUpdater(FlatMapIterableSubscriber.class, \"requestN\");\n+        @SuppressWarnings(\"rawtypes\")\n         private static final AtomicIntegerFieldUpdater<FlatMapIterableSubscriber> emittingUpdater =\n                 AtomicIntegerFieldUpdater.newUpdater(FlatMapIterableSubscriber.class, \"emitting\");\n         private final Function<? super T, ? extends Iterable<? extends U>> mapper;\n         private final Subscriber<? super U> target;\n         @Nullable\n-        private volatile Subscription sourceSubscription;\n+        private Subscription sourceSubscription;\n         @Nullable\n-        private volatile TerminalNotification terminalNotification;\n+        private TerminalNotification terminalNotification;\n         /**\n          * We only ever request a single {@link Iterable} at a time, and wait to request another {@link Iterable} until\n          * {@link Iterator#hasNext()} returns {@code false}. This means we don't need to queue {@link Iterator}s, and\n          * was done because we don't know how many elements will be returned by each {@link Iterator} and so we are as\n          * conservative as we can be about memory consumption.\n          */\n-        private volatile Iterator<? extends U> currentIterator = emptyIterator();\n+        private Iterator<? extends U> currentIterator = emptyIterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODM1NjQwOnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherConcatMapIterable.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxODo1MzozOFrOGMytww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMzozODo0OVrOGM8LhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA2NzAxMQ==", "bodyText": "This may be a better in a separate PR but the control-flow here is still utterly confusing and there are cases we may throw from a finally block which is a debugging nightmare \ud83d\ude42. It will be good to revisit the control flow at some point.", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416067011", "createdAt": "2020-04-27T18:53:38Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherConcatMapIterable.java", "diffHunk": "@@ -204,53 +194,32 @@ private void tryDrainIterator(Iterator<? extends U> currentIterator, Subscriptio\n                         terminalNotification.terminate(target);\n                     }\n                 } finally {\n-                    requestN = requestNUpdater.accumulateAndGet(this, requestN - initialRequestN,\n+                    currRequestN = requestNUpdater.accumulateAndGet(this, currRequestN - initialRequestN,\n                             FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-                    if (requestN < 0) {\n+                    if (currRequestN < 0) {\n                         terminated = true;\n                         // We clear out the current iterator to allow for GC, and we don't want to deliver any more data\n                         // because it may be out of order or incomplete ... so simulate a terminated event.\n-                        doCancel(sourceSubscription);\n+                        doCancel();\n                     } else if (!terminated) {\n-                        final Iterator<? extends U> previousIterator;\n                         try {\n-                            if (terminalNotification == null && !hasNext && requestN > 0 &&\n+                            if (terminalNotification == null && !hasNext && currRequestN > 0 &&\n                                     currentIterator != EmptyIterator.instance()) {\n                                 // We only request 1 at a time, and therefore we don't have any outstanding demand, so\n                                 // we will not be getting an onNext call, so we write to the currentIterator variable\n                                 // here before we unlock emitting so visibility to other threads should be taken care of\n                                 // by the write to emitting below (and later read).\n-                                this.currentIterator = previousIterator = EmptyIterator.instance();\n+                                this.currentIterator = EmptyIterator.instance();\n                                 sourceSubscription.request(1);\n-                            } else {\n-                                previousIterator = currentIterator;\n                             }\n                         } finally {\n                             // The lock must be released after we interact with the subscription for thread safety\n                             // reasons.\n-                            emitting = CONCURRENT_IDLE;\n-                        }\n-\n-                        // We may have been cancelled while we were holding the lock, so we need to check if we have\n-                        // been cancelled after we release the lock.\n-                        requestN = this.requestN;\n-\n-                        // We may requested more data while we held the lock. If data was delivered in a re-entry\n-                        // fashion, or if data was delivered on another thread while we held the lock we may have to try\n-                        // to re-acquire the lock and drain the new Iterator.\n-                        currentIterator = this.currentIterator;\n-                        if (previousIterator != currentIterator) {\n-                            // We only want to interact with the iterator inside the lock, and we don't want to exit\n-                            // early if we have seen a terminal event in the mean time, so if there is demand we assume\n-                            // for now that hasNext is true, and we will find out if there is really data if we\n-                            // re-acquire the lock.\n-                            hasNext = requestN > 0;\n+                            releasedLock = releasePendingLock(emittingUpdater, this);\n                         }\n                     }\n                 }\n-            } while (!terminated &&\n-                    (requestN < 0 || (requestN > 0 && hasNext) ||\n-                    (!hasNext && (terminalNotification = this.terminalNotification) != null)));\n+            } while (!terminated && !releasedLock);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIyMTE2Mg==", "bodyText": "I wanted to minimize change in this PR to focus on the concurrent utilities. lets consider more general simplification as a followup PR.", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416221162", "createdAt": "2020-04-27T23:36:22Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherConcatMapIterable.java", "diffHunk": "@@ -204,53 +194,32 @@ private void tryDrainIterator(Iterator<? extends U> currentIterator, Subscriptio\n                         terminalNotification.terminate(target);\n                     }\n                 } finally {\n-                    requestN = requestNUpdater.accumulateAndGet(this, requestN - initialRequestN,\n+                    currRequestN = requestNUpdater.accumulateAndGet(this, currRequestN - initialRequestN,\n                             FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-                    if (requestN < 0) {\n+                    if (currRequestN < 0) {\n                         terminated = true;\n                         // We clear out the current iterator to allow for GC, and we don't want to deliver any more data\n                         // because it may be out of order or incomplete ... so simulate a terminated event.\n-                        doCancel(sourceSubscription);\n+                        doCancel();\n                     } else if (!terminated) {\n-                        final Iterator<? extends U> previousIterator;\n                         try {\n-                            if (terminalNotification == null && !hasNext && requestN > 0 &&\n+                            if (terminalNotification == null && !hasNext && currRequestN > 0 &&\n                                     currentIterator != EmptyIterator.instance()) {\n                                 // We only request 1 at a time, and therefore we don't have any outstanding demand, so\n                                 // we will not be getting an onNext call, so we write to the currentIterator variable\n                                 // here before we unlock emitting so visibility to other threads should be taken care of\n                                 // by the write to emitting below (and later read).\n-                                this.currentIterator = previousIterator = EmptyIterator.instance();\n+                                this.currentIterator = EmptyIterator.instance();\n                                 sourceSubscription.request(1);\n-                            } else {\n-                                previousIterator = currentIterator;\n                             }\n                         } finally {\n                             // The lock must be released after we interact with the subscription for thread safety\n                             // reasons.\n-                            emitting = CONCURRENT_IDLE;\n-                        }\n-\n-                        // We may have been cancelled while we were holding the lock, so we need to check if we have\n-                        // been cancelled after we release the lock.\n-                        requestN = this.requestN;\n-\n-                        // We may requested more data while we held the lock. If data was delivered in a re-entry\n-                        // fashion, or if data was delivered on another thread while we held the lock we may have to try\n-                        // to re-acquire the lock and drain the new Iterator.\n-                        currentIterator = this.currentIterator;\n-                        if (previousIterator != currentIterator) {\n-                            // We only want to interact with the iterator inside the lock, and we don't want to exit\n-                            // early if we have seen a terminal event in the mean time, so if there is demand we assume\n-                            // for now that hasNext is true, and we will find out if there is really data if we\n-                            // re-acquire the lock.\n-                            hasNext = requestN > 0;\n+                            releasedLock = releasePendingLock(emittingUpdater, this);\n                         }\n                     }\n                 }\n-            } while (!terminated &&\n-                    (requestN < 0 || (requestN > 0 && hasNext) ||\n-                    (!hasNext && (terminalNotification = this.terminalNotification) != null)));\n+            } while (!terminated && !releasedLock);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA2NzAxMQ=="}, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIyMjA4NQ==", "bodyText": "#1032", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416222085", "createdAt": "2020-04-27T23:38:49Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherConcatMapIterable.java", "diffHunk": "@@ -204,53 +194,32 @@ private void tryDrainIterator(Iterator<? extends U> currentIterator, Subscriptio\n                         terminalNotification.terminate(target);\n                     }\n                 } finally {\n-                    requestN = requestNUpdater.accumulateAndGet(this, requestN - initialRequestN,\n+                    currRequestN = requestNUpdater.accumulateAndGet(this, currRequestN - initialRequestN,\n                             FlowControlUtils::addWithOverflowProtectionIfNotNegative);\n-                    if (requestN < 0) {\n+                    if (currRequestN < 0) {\n                         terminated = true;\n                         // We clear out the current iterator to allow for GC, and we don't want to deliver any more data\n                         // because it may be out of order or incomplete ... so simulate a terminated event.\n-                        doCancel(sourceSubscription);\n+                        doCancel();\n                     } else if (!terminated) {\n-                        final Iterator<? extends U> previousIterator;\n                         try {\n-                            if (terminalNotification == null && !hasNext && requestN > 0 &&\n+                            if (terminalNotification == null && !hasNext && currRequestN > 0 &&\n                                     currentIterator != EmptyIterator.instance()) {\n                                 // We only request 1 at a time, and therefore we don't have any outstanding demand, so\n                                 // we will not be getting an onNext call, so we write to the currentIterator variable\n                                 // here before we unlock emitting so visibility to other threads should be taken care of\n                                 // by the write to emitting below (and later read).\n-                                this.currentIterator = previousIterator = EmptyIterator.instance();\n+                                this.currentIterator = EmptyIterator.instance();\n                                 sourceSubscription.request(1);\n-                            } else {\n-                                previousIterator = currentIterator;\n                             }\n                         } finally {\n                             // The lock must be released after we interact with the subscription for thread safety\n                             // reasons.\n-                            emitting = CONCURRENT_IDLE;\n-                        }\n-\n-                        // We may have been cancelled while we were holding the lock, so we need to check if we have\n-                        // been cancelled after we release the lock.\n-                        requestN = this.requestN;\n-\n-                        // We may requested more data while we held the lock. If data was delivered in a re-entry\n-                        // fashion, or if data was delivered on another thread while we held the lock we may have to try\n-                        // to re-acquire the lock and drain the new Iterator.\n-                        currentIterator = this.currentIterator;\n-                        if (previousIterator != currentIterator) {\n-                            // We only want to interact with the iterator inside the lock, and we don't want to exit\n-                            // early if we have seen a terminal event in the mean time, so if there is demand we assume\n-                            // for now that hasNext is true, and we will find out if there is really data if we\n-                            // re-acquire the lock.\n-                            hasNext = requestN > 0;\n+                            releasedLock = releasePendingLock(emittingUpdater, this);\n                         }\n                     }\n                 }\n-            } while (!terminated &&\n-                    (requestN < 0 || (requestN > 0 && hasNext) ||\n-                    (!hasNext && (terminalNotification = this.terminalNotification) != null)));\n+            } while (!terminated && !releasedLock);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA2NzAxMQ=="}, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODM2ODEyOnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherConcatMapIterable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxODo1NjoyMlrOGMy0yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxODo1NjoyMlrOGMy0yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA2ODgwOA==", "bodyText": "Use SubscriberUtils.safeOnError in this and other branches here.", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416068808", "createdAt": "2020-04-27T18:56:22Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherConcatMapIterable.java", "diffHunk": "@@ -160,27 +149,28 @@ private void doCancel(Subscription sourceSubscription) {\n             Throw\n         }\n \n-        private void tryDrainIterator(Iterator<? extends U> currentIterator, Subscription sourceSubscription,\n-                                      @Nullable TerminalNotification terminalNotification, long requestN,\n-                                      ErrorHandlingStrategyInDrain errorHandlingStrategyInDrain) {\n+        private void tryDrainIterator(ErrorHandlingStrategyInDrain errorHandlingStrategyInDrain) {\n+            assert sourceSubscription != null;\n             boolean hasNext = false;\n             boolean terminated = false;\n+            boolean releasedLock = false;\n             do {\n-                if (!emittingUpdater.compareAndSet(this, CONCURRENT_IDLE, CONCURRENT_EMITTING)) {\n+                if (!acquirePendingLock(emittingUpdater, this)) {\n                     break;\n                 }\n-                final long initialRequestN = requestN;\n+                long currRequestN = this.requestN;\n+                final long initialRequestN = currRequestN;\n                 try {\n                     try {\n-                        while ((hasNext = currentIterator.hasNext()) && requestN > 0) {\n-                            --requestN;\n+                        while ((hasNext = currentIterator.hasNext()) && currRequestN > 0) {\n+                            --currRequestN;\n                             target.onNext(currentIterator.next());\n                         }\n                     } catch (Throwable cause) {\n                         switch (errorHandlingStrategyInDrain) {\n                             case PropagateAndCancel:\n                                 terminated = true;\n-                                doCancel(sourceSubscription);\n+                                doCancel();\n                                 try {\n                                     target.onError(cause);\n                                 } catch (Throwable cause2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODM5OTE0OnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/QueueDynamicCompositeCancellable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxOTowMzoyOVrOGMzGxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMzo0NjozNVrOGM8XBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA3MzQxNQ==", "bodyText": "We just need to cancel toAdd if it wasn't cancelled by cancel() above, rite?\n        if (!cancellables.offer(toAdd)) {\n            toAdd.cancel();\n        } else if (isCancelled()) {\n            if (cancellables.remove(toAdd)) {\n                toAdd.cancel();\n            }\n            return false;\n        }\n        return true;", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416073415", "createdAt": "2020-04-27T19:03:29Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/QueueDynamicCompositeCancellable.java", "diffHunk": "@@ -16,50 +16,33 @@\n package io.servicetalk.concurrent.api;\n \n import io.servicetalk.concurrent.Cancellable;\n-import io.servicetalk.concurrent.internal.QueueFullException;\n \n import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.CONCURRENT_EMITTING;\n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.CONCURRENT_IDLE;\n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.drainSingleConsumerCollectionDelayThrow;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n \n final class QueueDynamicCompositeCancellable implements DynamicCompositeCancellable {\n     private static final AtomicIntegerFieldUpdater<QueueDynamicCompositeCancellable> cancelledUpdater =\n             AtomicIntegerFieldUpdater.newUpdater(QueueDynamicCompositeCancellable.class, \"cancelled\");\n     @SuppressWarnings(\"unused\")\n     private volatile int cancelled;\n \n-    private static final AtomicIntegerFieldUpdater<QueueDynamicCompositeCancellable> drainingUpdater =\n-            AtomicIntegerFieldUpdater.newUpdater(QueueDynamicCompositeCancellable.class, \"draining\");\n-    @SuppressWarnings(\"unused\")\n-    private volatile int draining;\n-\n-    // TODO(scott): consider using a MPSC queue from JCTools once remove is supported.\n-    // https://github.com/JCTools/JCTools/pull/193#issuecomment-329958251\n     private final Queue<Cancellable> cancellables = new ConcurrentLinkedQueue<>();\n \n     @Override\n     public void cancel() {\n-        if (cancelledUpdater.compareAndSet(this, CONCURRENT_IDLE, CONCURRENT_EMITTING)) {\n+        if (cancelledUpdater.compareAndSet(this, 0, 1)) {\n             cancelAll();\n         }\n     }\n \n     @Override\n     public boolean add(Cancellable toAdd) {\n-        if (isCancelled()) {\n-            toAdd.cancel();\n-            return false;\n-        }\n-\n         if (!cancellables.offer(toAdd)) {\n-            throw new QueueFullException(\"cancellables\");\n-        }\n-\n-        if (isCancelled()) {\n+            toAdd.cancel();\n+        } else if (isCancelled()) {\n             cancelAll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIyNTAyOQ==", "bodyText": "good question, lets handle this as a followup just to preserve ordering semantics in this PR and make the change more visible if/when it is made #1033", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416225029", "createdAt": "2020-04-27T23:46:35Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/QueueDynamicCompositeCancellable.java", "diffHunk": "@@ -16,50 +16,33 @@\n package io.servicetalk.concurrent.api;\n \n import io.servicetalk.concurrent.Cancellable;\n-import io.servicetalk.concurrent.internal.QueueFullException;\n \n import java.util.Queue;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.CONCURRENT_EMITTING;\n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.CONCURRENT_IDLE;\n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.drainSingleConsumerCollectionDelayThrow;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n \n final class QueueDynamicCompositeCancellable implements DynamicCompositeCancellable {\n     private static final AtomicIntegerFieldUpdater<QueueDynamicCompositeCancellable> cancelledUpdater =\n             AtomicIntegerFieldUpdater.newUpdater(QueueDynamicCompositeCancellable.class, \"cancelled\");\n     @SuppressWarnings(\"unused\")\n     private volatile int cancelled;\n \n-    private static final AtomicIntegerFieldUpdater<QueueDynamicCompositeCancellable> drainingUpdater =\n-            AtomicIntegerFieldUpdater.newUpdater(QueueDynamicCompositeCancellable.class, \"draining\");\n-    @SuppressWarnings(\"unused\")\n-    private volatile int draining;\n-\n-    // TODO(scott): consider using a MPSC queue from JCTools once remove is supported.\n-    // https://github.com/JCTools/JCTools/pull/193#issuecomment-329958251\n     private final Queue<Cancellable> cancellables = new ConcurrentLinkedQueue<>();\n \n     @Override\n     public void cancel() {\n-        if (cancelledUpdater.compareAndSet(this, CONCURRENT_IDLE, CONCURRENT_EMITTING)) {\n+        if (cancelledUpdater.compareAndSet(this, 0, 1)) {\n             cancelAll();\n         }\n     }\n \n     @Override\n     public boolean add(Cancellable toAdd) {\n-        if (isCancelled()) {\n-            toAdd.cancel();\n-            return false;\n-        }\n-\n         if (!cancellables.offer(toAdd)) {\n-            throw new QueueFullException(\"cancellables\");\n-        }\n-\n-        if (isCancelled()) {\n+            toAdd.cancel();\n+        } else if (isCancelled()) {\n             cancelAll();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA3MzQxNQ=="}, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODQ0NDI4OnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/SetDynamicCompositeCancellable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxOToxNDoxN1rOGMzhIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMDowMDo1N1rOGM8rpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA4MDE2Mg==", "bodyText": "Can we avoid calling cancelAll() here as I suggested above for the queue variant?\nLooks like we can concurrently invoke a Cancellable if cancelAll() is invoked concurrently.", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416080162", "createdAt": "2020-04-27T19:14:17Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/SetDynamicCompositeCancellable.java", "diffHunk": "@@ -17,75 +17,64 @@\n \n import io.servicetalk.concurrent.Cancellable;\n \n-import java.util.Map;\n+import java.util.Iterator;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.CONCURRENT_EMITTING;\n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.CONCURRENT_IDLE;\n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.drainSingleConsumerCollectionDelayThrow;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.util.Collections.newSetFromMap;\n \n /**\n  * A {@link Cancellable} that contains other {@link Cancellable}s.\n  * <p>\n  * {@link Cancellable#cancel()} is propagated to all active {@link Cancellable}s. Any new {@link Cancellable} added\n  * after that will be immediately cancelled.\n  */\n-final class MapDynamicCompositeCancellable implements DynamicCompositeCancellable {\n-\n-    private static final AtomicIntegerFieldUpdater<MapDynamicCompositeCancellable> cancelledUpdater =\n-            AtomicIntegerFieldUpdater.newUpdater(MapDynamicCompositeCancellable.class, \"cancelled\");\n+final class SetDynamicCompositeCancellable implements DynamicCompositeCancellable {\n+    private static final AtomicIntegerFieldUpdater<SetDynamicCompositeCancellable> cancelledUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(SetDynamicCompositeCancellable.class, \"cancelled\");\n     @SuppressWarnings(\"unused\")\n     private volatile int cancelled;\n \n-    private static final AtomicIntegerFieldUpdater<MapDynamicCompositeCancellable> drainingUpdater =\n-            AtomicIntegerFieldUpdater.newUpdater(MapDynamicCompositeCancellable.class, \"draining\");\n-    @SuppressWarnings(\"unused\")\n-    private volatile int draining;\n-\n-    private final ConcurrentMap<Cancellable, Cancellable> cancellables;\n+    private final Set<Cancellable> cancellables;\n \n     /**\n      * Create a new instance.\n      */\n-    MapDynamicCompositeCancellable() {\n+    SetDynamicCompositeCancellable() {\n         this(8);\n     }\n \n     /**\n      * Create a new instance.\n-     * @param initialSize The initial size of the internal {@link Map}.\n+     * @param initialSize The initial size of the internal {@link Set}.\n      */\n-    MapDynamicCompositeCancellable(int initialSize) {\n-        cancellables = new ConcurrentHashMap<>(initialSize);\n+    SetDynamicCompositeCancellable(int initialSize) {\n+        cancellables = newSetFromMap(new ConcurrentHashMap<>(initialSize));\n     }\n \n     @Override\n     public void cancel() {\n-        if (cancelledUpdater.compareAndSet(this, CONCURRENT_IDLE, CONCURRENT_EMITTING)) {\n+        if (cancelledUpdater.compareAndSet(this, 0, 1)) {\n             cancelAll();\n         }\n     }\n \n     @Override\n     public boolean add(Cancellable toAdd) {\n-        if (isCancelled()) {\n-            toAdd.cancel();\n+        if (!cancellables.add(toAdd)) {\n+            toAdd.cancel(); // out of memory, or user has implemented equals/hashCode so there is overlap.\n+        } else if (isCancelled()) {\n+            cancelAll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIzMDMxMQ==", "bodyText": "good call ... because of the Set interface we can't safely drain from multiple threads and process and item exactly once. This needs to use the tryAcquireLock method and I will fix.", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416230311", "createdAt": "2020-04-28T00:00:57Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/SetDynamicCompositeCancellable.java", "diffHunk": "@@ -17,75 +17,64 @@\n \n import io.servicetalk.concurrent.Cancellable;\n \n-import java.util.Map;\n+import java.util.Iterator;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.CONCURRENT_EMITTING;\n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.CONCURRENT_IDLE;\n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.drainSingleConsumerCollectionDelayThrow;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n+import static java.util.Collections.newSetFromMap;\n \n /**\n  * A {@link Cancellable} that contains other {@link Cancellable}s.\n  * <p>\n  * {@link Cancellable#cancel()} is propagated to all active {@link Cancellable}s. Any new {@link Cancellable} added\n  * after that will be immediately cancelled.\n  */\n-final class MapDynamicCompositeCancellable implements DynamicCompositeCancellable {\n-\n-    private static final AtomicIntegerFieldUpdater<MapDynamicCompositeCancellable> cancelledUpdater =\n-            AtomicIntegerFieldUpdater.newUpdater(MapDynamicCompositeCancellable.class, \"cancelled\");\n+final class SetDynamicCompositeCancellable implements DynamicCompositeCancellable {\n+    private static final AtomicIntegerFieldUpdater<SetDynamicCompositeCancellable> cancelledUpdater =\n+            AtomicIntegerFieldUpdater.newUpdater(SetDynamicCompositeCancellable.class, \"cancelled\");\n     @SuppressWarnings(\"unused\")\n     private volatile int cancelled;\n \n-    private static final AtomicIntegerFieldUpdater<MapDynamicCompositeCancellable> drainingUpdater =\n-            AtomicIntegerFieldUpdater.newUpdater(MapDynamicCompositeCancellable.class, \"draining\");\n-    @SuppressWarnings(\"unused\")\n-    private volatile int draining;\n-\n-    private final ConcurrentMap<Cancellable, Cancellable> cancellables;\n+    private final Set<Cancellable> cancellables;\n \n     /**\n      * Create a new instance.\n      */\n-    MapDynamicCompositeCancellable() {\n+    SetDynamicCompositeCancellable() {\n         this(8);\n     }\n \n     /**\n      * Create a new instance.\n-     * @param initialSize The initial size of the internal {@link Map}.\n+     * @param initialSize The initial size of the internal {@link Set}.\n      */\n-    MapDynamicCompositeCancellable(int initialSize) {\n-        cancellables = new ConcurrentHashMap<>(initialSize);\n+    SetDynamicCompositeCancellable(int initialSize) {\n+        cancellables = newSetFromMap(new ConcurrentHashMap<>(initialSize));\n     }\n \n     @Override\n     public void cancel() {\n-        if (cancelledUpdater.compareAndSet(this, CONCURRENT_IDLE, CONCURRENT_EMITTING)) {\n+        if (cancelledUpdater.compareAndSet(this, 0, 1)) {\n             cancelAll();\n         }\n     }\n \n     @Override\n     public boolean add(Cancellable toAdd) {\n-        if (isCancelled()) {\n-            toAdd.cancel();\n+        if (!cancellables.add(toAdd)) {\n+            toAdd.cancel(); // out of memory, or user has implemented equals/hashCode so there is overlap.\n+        } else if (isCancelled()) {\n+            cancelAll();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA4MDE2Mg=="}, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODQ1MTc1OnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxOToxNjowOVrOGMzlng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMDoxNzo0MlrOGM9D2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA4MTMxMA==", "bodyText": "Use acquire() and release methods from above here too?", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416081310", "createdAt": "2020-04-27T19:16:09Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "diffHunk": "@@ -89,13 +78,10 @@ private ConcurrentUtils() {\n      * @param <T> Type of items stored in the {@link Queue}.\n      * @param <R> Type of the object holding the {@link int} referred by {@link AtomicIntegerFieldUpdater}.\n      * @return Number of items drained from the queue.\n-     * @throws RuntimeException All {@link Throwable} thrown by {@code forEach} {@link Consumer} are added as suppressed\n-     * causes.\n      */\n-    public static <T, R> long drainSingleConsumerQueueDelayThrow(final Queue<T> queue, final Consumer<T> forEach,\n-                                                                 final AtomicIntegerFieldUpdater<R> drainActiveUpdater,\n-                                                                 final R flagOwner) {\n-        RuntimeException cause = null;\n+    public static <T, R> long drainSingleConsumerQueue(final Queue<T> queue, final Consumer<T> forEach,\n+                                                       final AtomicIntegerFieldUpdater<R> drainActiveUpdater,\n+                                                       final R flagOwner) {\n         long drainedCount = 0;\n         do {\n             if (!drainActiveUpdater.compareAndSet(flagOwner, CONCURRENT_IDLE, CONCURRENT_EMITTING)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIzNjUwNQ==", "bodyText": "This method is removed in #1014, so lets discuss on that PR and for now I'll avoid touching in this PR.", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416236505", "createdAt": "2020-04-28T00:17:42Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "diffHunk": "@@ -89,13 +78,10 @@ private ConcurrentUtils() {\n      * @param <T> Type of items stored in the {@link Queue}.\n      * @param <R> Type of the object holding the {@link int} referred by {@link AtomicIntegerFieldUpdater}.\n      * @return Number of items drained from the queue.\n-     * @throws RuntimeException All {@link Throwable} thrown by {@code forEach} {@link Consumer} are added as suppressed\n-     * causes.\n      */\n-    public static <T, R> long drainSingleConsumerQueueDelayThrow(final Queue<T> queue, final Consumer<T> forEach,\n-                                                                 final AtomicIntegerFieldUpdater<R> drainActiveUpdater,\n-                                                                 final R flagOwner) {\n-        RuntimeException cause = null;\n+    public static <T, R> long drainSingleConsumerQueue(final Queue<T> queue, final Consumer<T> forEach,\n+                                                       final AtomicIntegerFieldUpdater<R> drainActiveUpdater,\n+                                                       final R flagOwner) {\n         long drainedCount = 0;\n         do {\n             if (!drainActiveUpdater.compareAndSet(flagOwner, CONCURRENT_IDLE, CONCURRENT_EMITTING)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA4MTMxMA=="}, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODQ1NzkzOnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/SingleProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxOToxNzozM1rOGMzpDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMDoxODo0OFrOGM9Fcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA4MjE4OA==", "bodyText": "Same suggestion as CompletableProcessor to remove the \"invoke listeners in order\" semantics.", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416082188", "createdAt": "2020-04-27T19:17:33Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/SingleProcessor.java", "diffHunk": "@@ -22,28 +22,24 @@\n import io.servicetalk.concurrent.internal.TerminalNotification;\n \n import java.util.Queue;\n-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n import javax.annotation.Nullable;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.CONCURRENT_EMITTING;\n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.CONCURRENT_IDLE;\n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.drainSingleConsumerQueueDelayThrow;\n-import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedLinkedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n \n /**\n  * A {@link Single} which is also a {@link Subscriber}. State of this {@link Single} can be modified by using the\n  * {@link Subscriber} methods which is forwarded to all existing or subsequent {@link Subscriber}s.\n  * @param <T> The type of result of the {@link Single}.\n  */\n final class SingleProcessor<T> extends Single<T> implements Processor<T, T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjIzNjkxNQ==", "bodyText": "good point, lets discuss on #1033 and handle semantic change in a follow PR.", "url": "https://github.com/apple/servicetalk/pull/1026#discussion_r416236915", "createdAt": "2020-04-28T00:18:48Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/SingleProcessor.java", "diffHunk": "@@ -22,28 +22,24 @@\n import io.servicetalk.concurrent.internal.TerminalNotification;\n \n import java.util.Queue;\n-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n import javax.annotation.Nullable;\n \n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.CONCURRENT_EMITTING;\n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.CONCURRENT_IDLE;\n-import static io.servicetalk.concurrent.internal.ConcurrentUtils.drainSingleConsumerQueueDelayThrow;\n-import static io.servicetalk.utils.internal.PlatformDependent.newUnboundedLinkedMpscQueue;\n+import static io.servicetalk.utils.internal.PlatformDependent.throwException;\n \n /**\n  * A {@link Single} which is also a {@link Subscriber}. State of this {@link Single} can be modified by using the\n  * {@link Subscriber} methods which is forwarded to all existing or subsequent {@link Subscriber}s.\n  * @param <T> The type of result of the {@link Single}.\n  */\n final class SingleProcessor<T> extends Single<T> implements Processor<T, T> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA4MjE4OA=="}, "originalCommit": {"oid": "310fee0db4d1d65b9395344c8f8cd42076716ffe"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2706, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}