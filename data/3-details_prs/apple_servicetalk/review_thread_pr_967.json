{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg4MDA4NTI1", "number": 967, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwOTo1NzoxMFrODoQiuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODoyMDo0NVrODonvkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNTQwNjY1OnYy", "diffSide": "RIGHT", "path": "servicetalk-tcp-netty-internal/src/testFixtures/java/io/servicetalk/tcp/netty/internal/TcpClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwOTo1NzoxMFrOF2soJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMDoxMDozNFrOF3J4cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg5ODU5Ng==", "bodyText": "nit: is this really what happens ? It seems like it is not blocking and so not await.", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r392898596", "createdAt": "2020-03-16T09:57:10Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-tcp-netty-internal/src/testFixtures/java/io/servicetalk/tcp/netty/internal/TcpClient.java", "diffHunk": "@@ -82,13 +83,24 @@ public TcpClient(TcpClientConfig config) {\n      */\n     public NettyConnection<Buffer, Buffer> connectBlocking(ExecutionContext executionContext, SocketAddress address)\n             throws ExecutionException, InterruptedException {\n-        return TcpConnector.connect(null, address, config, false, executionContext)\n-                .flatMap(channel -> DefaultNettyConnection.<Buffer, Buffer>initChannel(channel,\n+        return connect(executionContext, address).toFuture().get();\n+    }\n+\n+    /**\n+     * Connect and await for the connection.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddf547d43170486fa7ef4ca4866ec92155f3328c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3NzkwNw==", "bodyText": "Yep .. copy-pasta, lemme fix", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393377907", "createdAt": "2020-03-17T00:10:34Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-tcp-netty-internal/src/testFixtures/java/io/servicetalk/tcp/netty/internal/TcpClient.java", "diffHunk": "@@ -82,13 +83,24 @@ public TcpClient(TcpClientConfig config) {\n      */\n     public NettyConnection<Buffer, Buffer> connectBlocking(ExecutionContext executionContext, SocketAddress address)\n             throws ExecutionException, InterruptedException {\n-        return TcpConnector.connect(null, address, config, false, executionContext)\n-                .flatMap(channel -> DefaultNettyConnection.<Buffer, Buffer>initChannel(channel,\n+        return connect(executionContext, address).toFuture().get();\n+    }\n+\n+    /**\n+     * Connect and await for the connection.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg5ODU5Ng=="}, "originalCommit": {"oid": "ddf547d43170486fa7ef4ca4866ec92155f3328c"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzODE5OTM2OnYy", "diffSide": "RIGHT", "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMjo0MTozMVrOF3IKgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMDowNzoxNlrOF3J1OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM0OTc2Mw==", "bodyText": "Consider verifying if connectFuture is already done before applying the listener, as we do in other places:\n\n  \n    \n      servicetalk/servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsServiceDiscoverer.java\n    \n    \n        Lines 370 to 376\n      in\n      e5f4c56\n    \n    \n    \n    \n\n        \n          \n           final Future<List<InetAddress>> addressFuture = resolver.resolveAll(inetHost); \n        \n\n        \n          \n           cancellableForQuery = () -> addressFuture.cancel(true); \n        \n\n        \n          \n           if (addressFuture.isDone()) { \n        \n\n        \n          \n               handleResolveDone0(addressFuture); \n        \n\n        \n          \n           } else { \n        \n\n        \n          \n               addressFuture.addListener((FutureListener<List<InetAddress>>) this::handleResolveDone0); \n        \n\n        \n          \n           }", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393349763", "createdAt": "2020-03-16T22:41:31Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "diffHunk": "@@ -68,67 +76,74 @@ private TcpConnector() {\n      * @param config The {@link ReadOnlyTcpClientConfig} to use while connecting.\n      * @param autoRead if {@code true} auto read will be enabled for new {@link Channel}s.\n      * @param executionContext The {@link ExecutionContext} to use for the returned {@link NettyConnection}.\n+     * @param connectionFactory {@link Function} to create a {@link NettyConnection} asynchronously.\n+     * @param <C> Type of the created connection.\n      * @return A {@link Single} that completes with a new {@link Channel} when connected.\n      */\n-    public static Single<Channel> connect(@Nullable SocketAddress localAddress, Object resolvedRemoteAddress,\n-                                          ReadOnlyTcpClientConfig config, boolean autoRead,\n-                                          ExecutionContext executionContext) {\n+    public static <C extends ListenableAsyncCloseable> Single<C> connect(\n+            final @Nullable SocketAddress localAddress, final Object resolvedRemoteAddress,\n+            final ReadOnlyTcpClientConfig config, final boolean autoRead, final ExecutionContext executionContext,\n+            final Function<Channel, Single<? extends C>> connectionFactory) {\n         requireNonNull(resolvedRemoteAddress);\n         requireNonNull(config);\n         requireNonNull(executionContext);\n-        return new SubscribableSingle<Channel>() {\n+        return new SubscribableSingle<C>() {\n             @Override\n-            protected void handleSubscribe(final Subscriber<? super Channel> subscriber) {\n-                connectFutureToListener(localAddress, resolvedRemoteAddress, subscriber,\n-                        connect0(localAddress, resolvedRemoteAddress, config, autoRead, executionContext, subscriber));\n+            protected void handleSubscribe(final Subscriber<? super C> subscriber) {\n+                ConnectHandler<C> connectHandler = new ConnectHandler<>(subscriber, connectionFactory);\n+                try {\n+                    Future<?> connectFuture = connect0(localAddress, resolvedRemoteAddress, config, autoRead,\n+                            executionContext, connectHandler);\n+                    connectHandler.connectFuture(connectFuture);\n+                    connectFuture.addListener(f -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddf547d43170486fa7ef4ca4866ec92155f3328c"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3NzA4MA==", "bodyText": "We do that when we are already on the eventloop and no ordering guarantees are required. In this case, adding a listener makes sure that the Single is completed on the eventloop.\n(This code was just refactored, so I would continue with the approach what was present before but if you feel we need to change this in general in all places, we can discuss/do that separately)", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393377080", "createdAt": "2020-03-17T00:07:16Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "diffHunk": "@@ -68,67 +76,74 @@ private TcpConnector() {\n      * @param config The {@link ReadOnlyTcpClientConfig} to use while connecting.\n      * @param autoRead if {@code true} auto read will be enabled for new {@link Channel}s.\n      * @param executionContext The {@link ExecutionContext} to use for the returned {@link NettyConnection}.\n+     * @param connectionFactory {@link Function} to create a {@link NettyConnection} asynchronously.\n+     * @param <C> Type of the created connection.\n      * @return A {@link Single} that completes with a new {@link Channel} when connected.\n      */\n-    public static Single<Channel> connect(@Nullable SocketAddress localAddress, Object resolvedRemoteAddress,\n-                                          ReadOnlyTcpClientConfig config, boolean autoRead,\n-                                          ExecutionContext executionContext) {\n+    public static <C extends ListenableAsyncCloseable> Single<C> connect(\n+            final @Nullable SocketAddress localAddress, final Object resolvedRemoteAddress,\n+            final ReadOnlyTcpClientConfig config, final boolean autoRead, final ExecutionContext executionContext,\n+            final Function<Channel, Single<? extends C>> connectionFactory) {\n         requireNonNull(resolvedRemoteAddress);\n         requireNonNull(config);\n         requireNonNull(executionContext);\n-        return new SubscribableSingle<Channel>() {\n+        return new SubscribableSingle<C>() {\n             @Override\n-            protected void handleSubscribe(final Subscriber<? super Channel> subscriber) {\n-                connectFutureToListener(localAddress, resolvedRemoteAddress, subscriber,\n-                        connect0(localAddress, resolvedRemoteAddress, config, autoRead, executionContext, subscriber));\n+            protected void handleSubscribe(final Subscriber<? super C> subscriber) {\n+                ConnectHandler<C> connectHandler = new ConnectHandler<>(subscriber, connectionFactory);\n+                try {\n+                    Future<?> connectFuture = connect0(localAddress, resolvedRemoteAddress, config, autoRead,\n+                            executionContext, connectHandler);\n+                    connectHandler.connectFuture(connectFuture);\n+                    connectFuture.addListener(f -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM0OTc2Mw=="}, "originalCommit": {"oid": "ddf547d43170486fa7ef4ca4866ec92155f3328c"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzODIxMjE5OnYy", "diffSide": "RIGHT", "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMjo0Nzo1N1rOF3ISnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMDowOTo0N1rOF3J3tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1MTgzNw==", "bodyText": "SingleSource.Subscriber defines a parameter for onSuccess as @Nullable. Instead of throwing from here, should we propagate onError instead?", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393351837", "createdAt": "2020-03-16T22:47:57Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "diffHunk": "@@ -209,4 +206,87 @@ private NoopNettyAddressResolverGroup() {\n             return NOOP_ADDRESS_RESOLVER;\n         }\n     }\n+\n+    private static final class ConnectHandler<C extends ListenableAsyncCloseable> implements Consumer<Channel> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(ConnectHandler.class);\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<ConnectHandler> terminatedUpdater =\n+                newUpdater(ConnectHandler.class, \"terminated\");\n+\n+        private final DelayedCancellable futureCancellable = new DelayedCancellable();\n+        private final DelayedCancellable flatMapCancellable = new DelayedCancellable();\n+        private final Subscriber<? super C> target;\n+        private final Function<Channel, Single<? extends C>> connectionFactory;\n+\n+        private volatile int terminated;\n+\n+        ConnectHandler(final Subscriber<? super C> target,\n+                       final Function<Channel, Single<? extends C>> connectionFactory) {\n+            this.target = target;\n+            this.connectionFactory = connectionFactory;\n+            target.onSubscribe(() -> {\n+                try {\n+                    futureCancellable.cancel();\n+                } finally {\n+                    flatMapCancellable.cancel();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public void accept(final Channel channel) {\n+            toSource(connectionFactory.apply(channel)\n+                    .subscribeShareContext())\n+                    .subscribe(new Subscriber<C>() {\n+                        @Override\n+                        public void onSubscribe(final Cancellable cancellable) {\n+                            flatMapCancellable.delayedCancellable(cancellable);\n+                        }\n+\n+                        @Override\n+                        public void onSuccess(final C connection) {\n+                            requireNonNull(connection);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddf547d43170486fa7ef4ca4866ec92155f3328c"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3NzcxNg==", "bodyText": "Good point, the null-check is only required for when we want to call close() so instead of disallowing null, lemme guard the close.", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393377716", "createdAt": "2020-03-17T00:09:47Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "diffHunk": "@@ -209,4 +206,87 @@ private NoopNettyAddressResolverGroup() {\n             return NOOP_ADDRESS_RESOLVER;\n         }\n     }\n+\n+    private static final class ConnectHandler<C extends ListenableAsyncCloseable> implements Consumer<Channel> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(ConnectHandler.class);\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<ConnectHandler> terminatedUpdater =\n+                newUpdater(ConnectHandler.class, \"terminated\");\n+\n+        private final DelayedCancellable futureCancellable = new DelayedCancellable();\n+        private final DelayedCancellable flatMapCancellable = new DelayedCancellable();\n+        private final Subscriber<? super C> target;\n+        private final Function<Channel, Single<? extends C>> connectionFactory;\n+\n+        private volatile int terminated;\n+\n+        ConnectHandler(final Subscriber<? super C> target,\n+                       final Function<Channel, Single<? extends C>> connectionFactory) {\n+            this.target = target;\n+            this.connectionFactory = connectionFactory;\n+            target.onSubscribe(() -> {\n+                try {\n+                    futureCancellable.cancel();\n+                } finally {\n+                    flatMapCancellable.cancel();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public void accept(final Channel channel) {\n+            toSource(connectionFactory.apply(channel)\n+                    .subscribeShareContext())\n+                    .subscribe(new Subscriber<C>() {\n+                        @Override\n+                        public void onSubscribe(final Cancellable cancellable) {\n+                            flatMapCancellable.delayedCancellable(cancellable);\n+                        }\n+\n+                        @Override\n+                        public void onSuccess(final C connection) {\n+                            requireNonNull(connection);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1MTgzNw=="}, "originalCommit": {"oid": "ddf547d43170486fa7ef4ca4866ec92155f3328c"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzODM5Mzk5OnYy", "diffSide": "RIGHT", "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMDoyMDozOFrOF3KBUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjowNToyM1rOF3jLrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4MDE3OA==", "bodyText": "Do we assume that downstream target Subscriber will handle null instead of a connection? I think it's easy to assume from the caller side that it's expected to receive non-null connection. Was suggesting to invoke target.onError instead of throwing from onSuccess.", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393380178", "createdAt": "2020-03-17T00:20:38Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "diffHunk": "@@ -244,15 +244,16 @@ public void onSubscribe(final Cancellable cancellable) {\n                         }\n \n                         @Override\n-                        public void onSuccess(final C connection) {\n-                            requireNonNull(connection);\n+                        public void onSuccess(@Nullable final C connection) {\n                             if (terminatedUpdater.compareAndSet(ConnectHandler.this, 0, 1)) {\n                                 target.onSuccess(connection);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1ae0305f9655f24e37383e5ab65e73601a3b06e"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc5MjQyOA==", "bodyText": "Do we assume that downstream target Subscriber will handle null instead of a connection?\n\n\nYes, in general in operators we pass-through what we get unless we use it.\n\n\nWas suggesting to invoke target.onError instead of throwing from onSuccess.\n\n\nI understood the suggestion but I am following the general pattern I mention above.", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393792428", "createdAt": "2020-03-17T16:05:23Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "diffHunk": "@@ -244,15 +244,16 @@ public void onSubscribe(final Cancellable cancellable) {\n                         }\n \n                         @Override\n-                        public void onSuccess(final C connection) {\n-                            requireNonNull(connection);\n+                        public void onSuccess(@Nullable final C connection) {\n                             if (terminatedUpdater.compareAndSet(ConnectHandler.this, 0, 1)) {\n                                 target.onSuccess(connection);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4MDE3OA=="}, "originalCommit": {"oid": "e1ae0305f9655f24e37383e5ab65e73601a3b06e"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTIwMjM0OnYy", "diffSide": "RIGHT", "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODoxODo1NlrOF3RxQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxNjowOTo1N1rOF3jZPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNzEzOQ==", "bodyText": "nit: This logging message will read a bit strange and may be confusing if connection == null.", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393507139", "createdAt": "2020-03-17T08:18:56Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "diffHunk": "@@ -209,4 +206,88 @@ private NoopNettyAddressResolverGroup() {\n             return NOOP_ADDRESS_RESOLVER;\n         }\n     }\n+\n+    private static final class ConnectHandler<C extends ListenableAsyncCloseable> implements Consumer<Channel> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(ConnectHandler.class);\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<ConnectHandler> terminatedUpdater =\n+                newUpdater(ConnectHandler.class, \"terminated\");\n+\n+        private final DelayedCancellable futureCancellable = new DelayedCancellable();\n+        private final DelayedCancellable flatMapCancellable = new DelayedCancellable();\n+        private final Subscriber<? super C> target;\n+        private final Function<Channel, Single<? extends C>> connectionFactory;\n+\n+        private volatile int terminated;\n+\n+        ConnectHandler(final Subscriber<? super C> target,\n+                       final Function<Channel, Single<? extends C>> connectionFactory) {\n+            this.target = target;\n+            this.connectionFactory = connectionFactory;\n+            target.onSubscribe(() -> {\n+                try {\n+                    futureCancellable.cancel();\n+                } finally {\n+                    flatMapCancellable.cancel();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public void accept(final Channel channel) {\n+            toSource(connectionFactory.apply(channel)\n+                    .subscribeShareContext())\n+                    .subscribe(new Subscriber<C>() {\n+                        @Override\n+                        public void onSubscribe(final Cancellable cancellable) {\n+                            flatMapCancellable.delayedCancellable(cancellable);\n+                        }\n+\n+                        @Override\n+                        public void onSuccess(@Nullable final C connection) {\n+                            if (terminatedUpdater.compareAndSet(ConnectHandler.this, 0, 1)) {\n+                                target.onSuccess(connection);\n+                            } else {\n+                                LOGGER.info(\"Connection {} created for a channel: {} but connect failed previously. \" +\n+                                                \"Closing connection\",\n+                                        connection, channel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1ae0305f9655f24e37383e5ab65e73601a3b06e"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc5NTkwMg==", "bodyText": "mmm ya but as we do not expect the connection to be null and I want to add a log if we are closing the connection, I think it is OK to not add more conditional to handle null. I will change the level to debug though as there isn't anything a user is expected to do here.", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393795902", "createdAt": "2020-03-17T16:09:57Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "diffHunk": "@@ -209,4 +206,88 @@ private NoopNettyAddressResolverGroup() {\n             return NOOP_ADDRESS_RESOLVER;\n         }\n     }\n+\n+    private static final class ConnectHandler<C extends ListenableAsyncCloseable> implements Consumer<Channel> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(ConnectHandler.class);\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<ConnectHandler> terminatedUpdater =\n+                newUpdater(ConnectHandler.class, \"terminated\");\n+\n+        private final DelayedCancellable futureCancellable = new DelayedCancellable();\n+        private final DelayedCancellable flatMapCancellable = new DelayedCancellable();\n+        private final Subscriber<? super C> target;\n+        private final Function<Channel, Single<? extends C>> connectionFactory;\n+\n+        private volatile int terminated;\n+\n+        ConnectHandler(final Subscriber<? super C> target,\n+                       final Function<Channel, Single<? extends C>> connectionFactory) {\n+            this.target = target;\n+            this.connectionFactory = connectionFactory;\n+            target.onSubscribe(() -> {\n+                try {\n+                    futureCancellable.cancel();\n+                } finally {\n+                    flatMapCancellable.cancel();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public void accept(final Channel channel) {\n+            toSource(connectionFactory.apply(channel)\n+                    .subscribeShareContext())\n+                    .subscribe(new Subscriber<C>() {\n+                        @Override\n+                        public void onSubscribe(final Cancellable cancellable) {\n+                            flatMapCancellable.delayedCancellable(cancellable);\n+                        }\n+\n+                        @Override\n+                        public void onSuccess(@Nullable final C connection) {\n+                            if (terminatedUpdater.compareAndSet(ConnectHandler.this, 0, 1)) {\n+                                target.onSuccess(connection);\n+                            } else {\n+                                LOGGER.info(\"Connection {} created for a channel: {} but connect failed previously. \" +\n+                                                \"Closing connection\",\n+                                        connection, channel);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNzEzOQ=="}, "originalCommit": {"oid": "e1ae0305f9655f24e37383e5ab65e73601a3b06e"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTIwNzg3OnYy", "diffSide": "RIGHT", "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODoyMDo0NlrOF3R0mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODoyMDo0NlrOF3R0mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUwNzk5NA==", "bodyText": "also nit.... All other log messages end with a ..", "url": "https://github.com/apple/servicetalk/pull/967#discussion_r393507994", "createdAt": "2020-03-17T08:20:46Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpConnector.java", "diffHunk": "@@ -209,4 +206,88 @@ private NoopNettyAddressResolverGroup() {\n             return NOOP_ADDRESS_RESOLVER;\n         }\n     }\n+\n+    private static final class ConnectHandler<C extends ListenableAsyncCloseable> implements Consumer<Channel> {\n+        private static final Logger LOGGER = LoggerFactory.getLogger(ConnectHandler.class);\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<ConnectHandler> terminatedUpdater =\n+                newUpdater(ConnectHandler.class, \"terminated\");\n+\n+        private final DelayedCancellable futureCancellable = new DelayedCancellable();\n+        private final DelayedCancellable flatMapCancellable = new DelayedCancellable();\n+        private final Subscriber<? super C> target;\n+        private final Function<Channel, Single<? extends C>> connectionFactory;\n+\n+        private volatile int terminated;\n+\n+        ConnectHandler(final Subscriber<? super C> target,\n+                       final Function<Channel, Single<? extends C>> connectionFactory) {\n+            this.target = target;\n+            this.connectionFactory = connectionFactory;\n+            target.onSubscribe(() -> {\n+                try {\n+                    futureCancellable.cancel();\n+                } finally {\n+                    flatMapCancellable.cancel();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        public void accept(final Channel channel) {\n+            toSource(connectionFactory.apply(channel)\n+                    .subscribeShareContext())\n+                    .subscribe(new Subscriber<C>() {\n+                        @Override\n+                        public void onSubscribe(final Cancellable cancellable) {\n+                            flatMapCancellable.delayedCancellable(cancellable);\n+                        }\n+\n+                        @Override\n+                        public void onSuccess(@Nullable final C connection) {\n+                            if (terminatedUpdater.compareAndSet(ConnectHandler.this, 0, 1)) {\n+                                target.onSuccess(connection);\n+                            } else {\n+                                LOGGER.info(\"Connection {} created for a channel: {} but connect failed previously. \" +\n+                                                \"Closing connection\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1ae0305f9655f24e37383e5ab65e73601a3b06e"}, "originalPosition": 230}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2891, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}