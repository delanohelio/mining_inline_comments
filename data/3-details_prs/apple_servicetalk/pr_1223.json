{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzNjEzNjAy", "number": 1223, "title": "DNS Client SRV robustness and A* record Publisher support", "bodyText": "Motivation:\nSRV resolution involves a two phase lookup. First a SRV query, which\nreturns a set of name/port pairs, and then for each pair a A* record\nresolution. If an A* record resolution fails it currently fails the\nouter SRV Publisher. We also do a one-time-lookup at the A* record level\nso we can't detect multiple A* records nor can we detect any changes at\nthe A* record level. When a failure at the SRV level occurs we don't\ncleanup the A* publisher query processing, which may accumulate queued\nitems over subsequent retry attempts.\nModifications:\n\nDefaultDnsClient SRV resolution should use flatMapMerge to process\nmultiple A* resolution streams in parallel, track changes, and deal with\ndynamic failures.\nDefaultDnsClient SRV resolution should not let A* resolution failures\npropagate to the SRV level, and instead should be retried as long as\nthere is a corresponding SRV entry.\nDefaultDnsClient SRV resolution should force innactive events upon\nfailure so that A* record publishers cleanup associated queues/timers.\nDefaultDnsClient SRV resolution should support a mode that allows\ndeduplication of <host, ip> pairs returned by different A* record\npublishers.\nDefaultDnsClient SRV resolution should disable Netty's CNAME cache\nbecause it may result in incorrect failures if CNAME TTLs are longer\nthan the SRV entries TTLs they map to.\nDefaultDnsClientTest and TestRecordStore have been reimplemented to\nallow for direct control in the unit test, rather than implicit\nremoval/addition in the background.\n\nResult:\nMore robust DNS SRV record resolution that can also continiously follow\neach corresponding A* record stream.", "createdAt": "2020-11-19T01:28:20Z", "url": "https://github.com/apple/servicetalk/pull/1223", "merged": true, "mergeCommit": {"oid": "2bed998829e654ec65b64145cd08488e2826640b"}, "closed": true, "closedAt": "2020-12-08T00:13:42Z", "author": {"login": "Scottmitch"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdd54zGABqjQwMTM3NDgzNTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdj-D3JgBqjQwODIxMjA0Mzc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9bd47defd5835f54983a5c51b0e577a04a9f1ef5", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/9bd47defd5835f54983a5c51b0e577a04a9f1ef5", "committedDate": "2020-11-19T02:53:18Z", "message": "avoid using ipv6 for test dns server if not supported by host"}, "afterCommit": {"oid": "15e300ab16c09c1569169a2c3ecc78d30a5efa9b", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/15e300ab16c09c1569169a2c3ecc78d30a5efa9b", "committedDate": "2020-11-19T03:07:24Z", "message": "DNS Client SRV robustness and A* record Publisher support\n\nMotivation:\nSRV resolution involves a two phase lookup. First a SRV query, which\nreturns a set of name/port pairs, and then for each pair a A* record\nresolution. If an A* record resolution fails it currently fails the\nouter SRV Publisher. We also do a one-time-lookup at the A* record level\nso we can't detect multiple A* records nor can we detect any changes at\nthe A* record level. When a failure at the SRV level occurs we don't\ncleanup the A* publisher query processing, which may accumulate queued\nitems over subsequent retry attempts.\n\nModifications:\n- DefaultDnsClient SRV resolution should use flatMapMerge to process\nmultiple A* resolution streams in parallel, track changes, and deal with\ndynamic failures.\n- DefaultDnsClient SRV resolution should not let A* resolution failures\npropagate to the SRV level, and instead should be retried as long as\nthere is a corresponding SRV entry.\n- DefaultDnsClient SRV resolution should force innactive events upon\nfailure so that A* record publishers cleanup associated queues/timers.\n- DefaultDnsClient SRV resolution should support a mode that allows\ndeduplication of <host, ip> pairs returned by different A* record\npublishers.\n- DefaultDnsClient SRV resolution should disable Netty's CNAME cache\nbecause it may result in incorrect failures if CNAME TTLs are longer\nthan the SRV entries TTLs they map to.\n- DefaultDnsClientTest and TestRecordStore have been reimplemented to\nallow for direct control in the unit test, rather than implicit\nremoval/addition in the background.\n\nResult:\nMore robust DNS SRV record resolution that can also continiously follow\neach corresponding A* record stream."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "14ebf5a25e56f93f18735dac9a3f9ef24a8bb198", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/14ebf5a25e56f93f18735dac9a3f9ef24a8bb198", "committedDate": "2020-11-19T03:32:33Z", "message": "resolve checkstyle"}, "afterCommit": {"oid": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee", "committedDate": "2020-11-20T01:48:57Z", "message": "DNS Client SRV robustness and A* record Publisher support\n\nMotivation:\nSRV resolution involves a two phase lookup. First a SRV query, which\nreturns a set of name/port pairs, and then for each pair a A* record\nresolution. If an A* record resolution fails it currently fails the\nouter SRV Publisher. We also do a one-time-lookup at the A* record level\nso we can't detect multiple A* records nor can we detect any changes at\nthe A* record level. When a failure at the SRV level occurs we don't\ncleanup the A* publisher query processing, which may accumulate queued\nitems over subsequent retry attempts.\n\nModifications:\n- DefaultDnsClient SRV resolution should use flatMapMerge to process\nmultiple A* resolution streams in parallel, track changes, and deal with\ndynamic failures.\n- DefaultDnsClient SRV resolution should not let A* resolution failures\npropagate to the SRV level, and instead should be retried as long as\nthere is a corresponding SRV entry.\n- DefaultDnsClient SRV resolution should force innactive events upon\nfailure so that A* record publishers cleanup associated queues/timers.\n- DefaultDnsClient SRV resolution should support a mode that allows\ndeduplication of <host, ip> pairs returned by different A* record\npublishers.\n- DefaultDnsClient SRV resolution should disable Netty's CNAME cache\nbecause it may result in incorrect failures if CNAME TTLs are longer\nthan the SRV entries TTLs they map to.\n- DefaultDnsClientTest and TestRecordStore have been reimplemented to\nallow for direct control in the unit test, rather than implicit\nremoval/addition in the background.\n\nResult:\nMore robust DNS SRV record resolution that can also continiously follow\neach corresponding A* record stream."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5NDg3Njk4", "url": "https://github.com/apple/servicetalk/pull/1223#pullrequestreview-539487698", "createdAt": "2020-11-26T17:43:41Z", "commit": {"oid": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNzo0Mzo0MlrOH6j5Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNzo0Mzo0MlrOH6j5Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE2NzUxNQ==", "bodyText": "nit: \"response payload\" irrelevant here.", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r531167515", "createdAt": "2020-11-26T17:43:42Z", "author": {"login": "tkountis"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/CancelImmediatelySubscriber.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.internal;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class CancelImmediatelySubscriber implements PublisherSource.Subscriber<Object> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CancelImmediatelySubscriber.class);\n+    public static final CancelImmediatelySubscriber INSTANCE = new CancelImmediatelySubscriber();\n+\n+    private CancelImmediatelySubscriber() {\n+        // Singleton\n+    }\n+\n+    @Override\n+    public void onSubscribe(final PublisherSource.Subscription s) {\n+        // Cancel immediately so that the connection can handle this as required.\n+        s.cancel();\n+    }\n+\n+    @Override\n+    public void onNext(final Object obj) {\n+        // Can not be here since we never request.\n+    }\n+\n+    @Override\n+    public void onError(final Throwable t) {\n+        LOGGER.debug(\"Ignoring error from response payload, since subscriber has already cancelled.\", t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0OTg1NzY3", "url": "https://github.com/apple/servicetalk/pull/1223#pullrequestreview-534985767", "createdAt": "2020-11-20T00:24:56Z", "commit": {"oid": "14ebf5a25e56f93f18735dac9a3f9ef24a8bb198"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwMDoyNDo1NlrOH23utQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzoyOTowNVrOH_l6Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI5ODIyOQ==", "bodyText": "Missed javadoc", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r527298229", "createdAt": "2020-11-20T00:24:56Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/CancelImmediatelySubscriber.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.internal;\n+\n+import io.servicetalk.concurrent.PublisherSource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class CancelImmediatelySubscriber implements PublisherSource.Subscriber<Object> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14ebf5a25e56f93f18735dac9a3f9ef24a8bb198"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MDMxMg==", "bodyText": "SrvAddressRemovedException, ClosedServiceDiscovererException, and SrvAggregateList should have serialVersionUID", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536350312", "createdAt": "2020-12-04T20:06:22Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -806,4 +912,12 @@ public int size() {\n             super(message);\n         }\n     }\n+\n+    private static final class SrvAddressRemovedException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee"}, "originalPosition": 604}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1MjAzMA==", "bodyText": "Consider adding a message", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536352030", "createdAt": "2020-12-04T20:09:44Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -776,6 +805,83 @@ private static ResolvedAddressTypes toNettyType(final DnsResolverAddressTypes dn\n         return hostname -> new ServiceTalkToNettyDnsServerAddressStream(provider.nameServerAddressStream(hostname));\n     }\n \n+    private static final class SrvInactiveCombinerOperator implements\n+                            PublisherOperator<Collection<ServiceDiscovererEvent<InetSocketAddress>>,\n+                                              Collection<ServiceDiscovererEvent<InetSocketAddress>>> {\n+        static final SrvInactiveCombinerOperator EMIT = new SrvInactiveCombinerOperator(true);\n+        static final SrvInactiveCombinerOperator NO_EMIT = new SrvInactiveCombinerOperator(false);\n+        private final boolean emitAggregatedEvents;\n+\n+        private SrvInactiveCombinerOperator(boolean emitAggregatedEvents) {\n+            this.emitAggregatedEvents = emitAggregatedEvents;\n+        }\n+\n+        @Override\n+        public Subscriber<? super Collection<ServiceDiscovererEvent<InetSocketAddress>>> apply(\n+                final Subscriber<? super Collection<ServiceDiscovererEvent<InetSocketAddress>>> subscriber) {\n+            return new Subscriber<Collection<ServiceDiscovererEvent<InetSocketAddress>>>() {\n+                @Nullable\n+                private List<ServiceDiscovererEvent<InetSocketAddress>> aggregatedEvents;\n+                @Nullable\n+                private Subscription subscription;\n+                @Override\n+                public void onSubscribe(final Subscription s) {\n+                    this.subscription = s;\n+                    subscriber.onSubscribe(s);\n+                }\n+\n+                @Override\n+                public void onNext(@Nullable final Collection<ServiceDiscovererEvent<InetSocketAddress>> evts) {\n+                    assert subscription != null;\n+                    if (aggregatedEvents != null) {\n+                        if (evts != null && emitAggregatedEvents) {\n+                            aggregatedEvents.addAll(evts);\n+                        }\n+                        subscription.request(1);\n+                    } else if (evts instanceof SrvAggregateList) {\n+                        aggregatedEvents = (List<ServiceDiscovererEvent<InetSocketAddress>>) evts;\n+                        subscription.request(1);\n+                    } else {\n+                        subscriber.onNext(evts);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(final Throwable t) {\n+                    try {\n+                        if (aggregatedEvents != null && emitAggregatedEvents) {\n+                            // requestN is OK. We previously didn't deliver the item which gave us inactiveEvents.\n+                            subscriber.onNext(aggregatedEvents);\n+                        }\n+                    } finally {\n+                        subscriber.onError(t);\n+                    }\n+                }\n+\n+                @Override\n+                public void onComplete() {\n+                    subscriber.onComplete();\n+                }\n+            };\n+        }\n+    }\n+\n+    private static final class SrvInactiveEvent<T, A> implements ServiceDiscovererEvent<T> {\n+        private final List<ServiceDiscovererEvent<A>> aggregatedEvents = new SrvAggregateList<>();\n+        @Override\n+        public T address() {\n+            throw new UnsupportedOperationException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee"}, "originalPosition": 584}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NDA4NA==", "bodyText": "Should we try-catch all invocations of Subscriber methods?", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536354084", "createdAt": "2020-12-04T20:13:48Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -776,6 +805,83 @@ private static ResolvedAddressTypes toNettyType(final DnsResolverAddressTypes dn\n         return hostname -> new ServiceTalkToNettyDnsServerAddressStream(provider.nameServerAddressStream(hostname));\n     }\n \n+    private static final class SrvInactiveCombinerOperator implements\n+                            PublisherOperator<Collection<ServiceDiscovererEvent<InetSocketAddress>>,\n+                                              Collection<ServiceDiscovererEvent<InetSocketAddress>>> {\n+        static final SrvInactiveCombinerOperator EMIT = new SrvInactiveCombinerOperator(true);\n+        static final SrvInactiveCombinerOperator NO_EMIT = new SrvInactiveCombinerOperator(false);\n+        private final boolean emitAggregatedEvents;\n+\n+        private SrvInactiveCombinerOperator(boolean emitAggregatedEvents) {\n+            this.emitAggregatedEvents = emitAggregatedEvents;\n+        }\n+\n+        @Override\n+        public Subscriber<? super Collection<ServiceDiscovererEvent<InetSocketAddress>>> apply(\n+                final Subscriber<? super Collection<ServiceDiscovererEvent<InetSocketAddress>>> subscriber) {\n+            return new Subscriber<Collection<ServiceDiscovererEvent<InetSocketAddress>>>() {\n+                @Nullable\n+                private List<ServiceDiscovererEvent<InetSocketAddress>> aggregatedEvents;\n+                @Nullable\n+                private Subscription subscription;\n+                @Override\n+                public void onSubscribe(final Subscription s) {\n+                    this.subscription = s;\n+                    subscriber.onSubscribe(s);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee"}, "originalPosition": 541}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NTMxMw==", "bodyText": "Is this expected path?", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536355313", "createdAt": "2020-12-04T20:16:20Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -776,6 +805,83 @@ private static ResolvedAddressTypes toNettyType(final DnsResolverAddressTypes dn\n         return hostname -> new ServiceTalkToNettyDnsServerAddressStream(provider.nameServerAddressStream(hostname));\n     }\n \n+    private static final class SrvInactiveCombinerOperator implements\n+                            PublisherOperator<Collection<ServiceDiscovererEvent<InetSocketAddress>>,\n+                                              Collection<ServiceDiscovererEvent<InetSocketAddress>>> {\n+        static final SrvInactiveCombinerOperator EMIT = new SrvInactiveCombinerOperator(true);\n+        static final SrvInactiveCombinerOperator NO_EMIT = new SrvInactiveCombinerOperator(false);\n+        private final boolean emitAggregatedEvents;\n+\n+        private SrvInactiveCombinerOperator(boolean emitAggregatedEvents) {\n+            this.emitAggregatedEvents = emitAggregatedEvents;\n+        }\n+\n+        @Override\n+        public Subscriber<? super Collection<ServiceDiscovererEvent<InetSocketAddress>>> apply(\n+                final Subscriber<? super Collection<ServiceDiscovererEvent<InetSocketAddress>>> subscriber) {\n+            return new Subscriber<Collection<ServiceDiscovererEvent<InetSocketAddress>>>() {\n+                @Nullable\n+                private List<ServiceDiscovererEvent<InetSocketAddress>> aggregatedEvents;\n+                @Nullable\n+                private Subscription subscription;\n+                @Override\n+                public void onSubscribe(final Subscription s) {\n+                    this.subscription = s;\n+                    subscriber.onSubscribe(s);\n+                }\n+\n+                @Override\n+                public void onNext(@Nullable final Collection<ServiceDiscovererEvent<InetSocketAddress>> evts) {\n+                    assert subscription != null;\n+                    if (aggregatedEvents != null) {\n+                        if (evts != null && emitAggregatedEvents) {\n+                            aggregatedEvents.addAll(evts);\n+                        }\n+                        subscription.request(1);\n+                    } else if (evts instanceof SrvAggregateList) {\n+                        aggregatedEvents = (List<ServiceDiscovererEvent<InetSocketAddress>>) evts;\n+                        subscription.request(1);\n+                    } else {\n+                        subscriber.onNext(evts);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee"}, "originalPosition": 556}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2MjE2NQ==", "bodyText": "srvEvent.address().toString() will include port number, but prevAPublisher.name won't. Consider making the msg consistent", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536362165", "createdAt": "2020-12-04T20:30:03Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -174,57 +206,63 @@ private DnsDiscoveryObserver newDiscoveryObserver(final String address) {\n     @Override\n     public Publisher<Collection<ServiceDiscovererEvent<InetAddress>>> dnsQuery(final String address) {\n         requireNonNull(address);\n-        return defer(() -> new ARecordPublisher(true, address, newDiscoveryObserver(address)));\n+        return defer(() -> {\n+            ARecordPublisher pub = new ARecordPublisher(address, newDiscoveryObserver(address));\n+            return inactiveEventsOnError ? recoverWithInactiveEvents(pub, false) : pub;\n+        });\n     }\n \n     @Override\n     public Publisher<Collection<ServiceDiscovererEvent<InetSocketAddress>>> dnsSrvQuery(final String serviceName) {\n         requireNonNull(serviceName);\n         return defer(() -> {\n-            // State per subscribe requires defer so each subscribe gets independent state.\n-            final Map<HostAndPort, ARecordPublisher> aRecordMap = new HashMap<>(8);\n-            final DnsDiscoveryObserver discoveryObserver = newDiscoveryObserver(serviceName);\n-            return new SrvRecordPublisher(serviceName, discoveryObserver).flatMapConcatIterable(identity())\n-                    .flatMapMergeSingle(srvEvent -> {\n+        // State per subscribe requires defer so each subscribe gets independent state.\n+        final Map<HostAndPort, ARecordPublisher> aRecordMap = new HashMap<>(8);\n+        final Map<InetSocketAddress, Integer> availableAddresses = srvFilterDuplicateEvents ?\n+                new HashMap<>(8) : emptyMap();\n+        final DnsDiscoveryObserver discoveryObserver = newDiscoveryObserver(serviceName);\n+        // We \"recover\" unconditionally to force inactive events to propagate to all mapped A* publishers to cancel\n+        // any pending scheduled tasks. SrvInactiveCombinerOperator is used to filter the aggregated collection of\n+        // inactive events if necessary.\n+        return recoverWithInactiveEvents(new SrvRecordPublisher(serviceName, discoveryObserver), true)\n+                .flatMapConcatIterable(identity())\n+                .flatMapMerge(srvEvent -> {\n                 assertInEventloop();\n                 if (srvEvent.isAvailable()) {\n-                    final ARecordPublisher aPublisher =\n-                            new ARecordPublisher(false, srvEvent.address().hostName(), discoveryObserver);\n-                    final ARecordPublisher prevAPublisher = aRecordMap.putIfAbsent(srvEvent.address(), aPublisher);\n-                    if (prevAPublisher != null) {\n-                        return failed(new IllegalStateException(\"Only 1 A* record per SRV record is supported. \" +\n-                                srvEvent.address() + \" corresponding to SRV name \" + serviceName +\n-                                \" had a pre-existing A* record:\" + prevAPublisher.name +\n-                                \" when new A* record arrived: \" + aPublisher.name));\n-                    }\n+                    return defer(() -> {\n+                        final ARecordPublisher aPublisher =\n+                                new ARecordPublisher(srvEvent.address().hostName(), discoveryObserver);\n+                        final ARecordPublisher prevAPublisher = aRecordMap.putIfAbsent(srvEvent.address(), aPublisher);\n+                        if (prevAPublisher != null) {\n+                            return newDuplicateSrv(serviceName, srvEvent.address().toString(), prevAPublisher.name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NzI0NA==", "bodyText": "For the purpose of A/AAAA record resolution the port number doesn't matter. Can we use only a hostname as a key?", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536367244", "createdAt": "2020-12-04T20:40:58Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -174,57 +206,63 @@ private DnsDiscoveryObserver newDiscoveryObserver(final String address) {\n     @Override\n     public Publisher<Collection<ServiceDiscovererEvent<InetAddress>>> dnsQuery(final String address) {\n         requireNonNull(address);\n-        return defer(() -> new ARecordPublisher(true, address, newDiscoveryObserver(address)));\n+        return defer(() -> {\n+            ARecordPublisher pub = new ARecordPublisher(address, newDiscoveryObserver(address));\n+            return inactiveEventsOnError ? recoverWithInactiveEvents(pub, false) : pub;\n+        });\n     }\n \n     @Override\n     public Publisher<Collection<ServiceDiscovererEvent<InetSocketAddress>>> dnsSrvQuery(final String serviceName) {\n         requireNonNull(serviceName);\n         return defer(() -> {\n-            // State per subscribe requires defer so each subscribe gets independent state.\n-            final Map<HostAndPort, ARecordPublisher> aRecordMap = new HashMap<>(8);\n-            final DnsDiscoveryObserver discoveryObserver = newDiscoveryObserver(serviceName);\n-            return new SrvRecordPublisher(serviceName, discoveryObserver).flatMapConcatIterable(identity())\n-                    .flatMapMergeSingle(srvEvent -> {\n+        // State per subscribe requires defer so each subscribe gets independent state.\n+        final Map<HostAndPort, ARecordPublisher> aRecordMap = new HashMap<>(8);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQwNzYyNA==", "bodyText": "For A/AAAA records we do not retry inside DNS SD, we apply DNS retries at the client level, as part of AutoRetryStrategy. Can we be consistent here?", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536407624", "createdAt": "2020-12-04T21:57:51Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/DefaultDnsClient.java", "diffHunk": "@@ -174,57 +206,63 @@ private DnsDiscoveryObserver newDiscoveryObserver(final String address) {\n     @Override\n     public Publisher<Collection<ServiceDiscovererEvent<InetAddress>>> dnsQuery(final String address) {\n         requireNonNull(address);\n-        return defer(() -> new ARecordPublisher(true, address, newDiscoveryObserver(address)));\n+        return defer(() -> {\n+            ARecordPublisher pub = new ARecordPublisher(address, newDiscoveryObserver(address));\n+            return inactiveEventsOnError ? recoverWithInactiveEvents(pub, false) : pub;\n+        });\n     }\n \n     @Override\n     public Publisher<Collection<ServiceDiscovererEvent<InetSocketAddress>>> dnsSrvQuery(final String serviceName) {\n         requireNonNull(serviceName);\n         return defer(() -> {\n-            // State per subscribe requires defer so each subscribe gets independent state.\n-            final Map<HostAndPort, ARecordPublisher> aRecordMap = new HashMap<>(8);\n-            final DnsDiscoveryObserver discoveryObserver = newDiscoveryObserver(serviceName);\n-            return new SrvRecordPublisher(serviceName, discoveryObserver).flatMapConcatIterable(identity())\n-                    .flatMapMergeSingle(srvEvent -> {\n+        // State per subscribe requires defer so each subscribe gets independent state.\n+        final Map<HostAndPort, ARecordPublisher> aRecordMap = new HashMap<>(8);\n+        final Map<InetSocketAddress, Integer> availableAddresses = srvFilterDuplicateEvents ?\n+                new HashMap<>(8) : emptyMap();\n+        final DnsDiscoveryObserver discoveryObserver = newDiscoveryObserver(serviceName);\n+        // We \"recover\" unconditionally to force inactive events to propagate to all mapped A* publishers to cancel\n+        // any pending scheduled tasks. SrvInactiveCombinerOperator is used to filter the aggregated collection of\n+        // inactive events if necessary.\n+        return recoverWithInactiveEvents(new SrvRecordPublisher(serviceName, discoveryObserver), true)\n+                .flatMapConcatIterable(identity())\n+                .flatMapMerge(srvEvent -> {\n                 assertInEventloop();\n                 if (srvEvent.isAvailable()) {\n-                    final ARecordPublisher aPublisher =\n-                            new ARecordPublisher(false, srvEvent.address().hostName(), discoveryObserver);\n-                    final ARecordPublisher prevAPublisher = aRecordMap.putIfAbsent(srvEvent.address(), aPublisher);\n-                    if (prevAPublisher != null) {\n-                        return failed(new IllegalStateException(\"Only 1 A* record per SRV record is supported. \" +\n-                                srvEvent.address() + \" corresponding to SRV name \" + serviceName +\n-                                \" had a pre-existing A* record:\" + prevAPublisher.name +\n-                                \" when new A* record arrived: \" + aPublisher.name));\n-                    }\n+                    return defer(() -> {\n+                        final ARecordPublisher aPublisher =\n+                                new ARecordPublisher(srvEvent.address().hostName(), discoveryObserver);\n+                        final ARecordPublisher prevAPublisher = aRecordMap.putIfAbsent(srvEvent.address(), aPublisher);\n+                        if (prevAPublisher != null) {\n+                            return newDuplicateSrv(serviceName, srvEvent.address().toString(), prevAPublisher.name);\n+                        }\n \n-                    return srvARecordPubToSingle(aPublisher, srvEvent, serviceName);\n+                        Publisher<? extends Collection<ServiceDiscovererEvent<InetAddress>>> returnPub =\n+                                recoverWithInactiveEvents(aPublisher, false);\n+                        return srvFilterDuplicateEvents ?\n+                                srvFilterDups(returnPub, availableAddresses, srvEvent.address().port()) :\n+                                returnPub.map(events -> mapEventList(events, inetAddress ->\n+                                        new InetSocketAddress(inetAddress, srvEvent.address().port())));\n+                    }).retryWhen((i, cause) -> {\n+                        assertInEventloop();\n+                        // If this error is because the SRV entry was detected as inactive, then propagate the error and\n+                        // don't retry. Otherwise this is a resolution exception (e.g. UnknownHostException), and retry.\n+                        return cause == SrvAddressRemovedException.DNS_SRV_ADDR_REMOVED ||\n+                                aRecordMap.remove(srvEvent.address()) == null ?\n+                                Completable.failed(cause) : srvHostNameRepeater.apply(i);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0MjE1OQ==", "bodyText": "Consider making it private", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536442159", "createdAt": "2020-12-04T23:25:01Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-dns-discovery-netty/src/main/java/io/servicetalk/dns/discovery/netty/SingletonDnsServerAddressStreamProvider.java", "diffHunk": "@@ -25,14 +27,52 @@\n \n     /**\n      * Create a new instance.\n-     * @param stream The singelton to return from {@link #nameServerAddressStream(String)}.\n+     * @param address The address to return from {@link #nameServerAddressStream(String)}.\n      */\n-    public SingletonDnsServerAddressStreamProvider(DnsServerAddressStream stream) {\n-        this.stream = requireNonNull(stream);\n+    public SingletonDnsServerAddressStreamProvider(InetSocketAddress address) {\n+        this.stream = new SingletonDnsServerAddresses(address);\n     }\n \n     @Override\n     public DnsServerAddressStream nameServerAddressStream(String hostname) {\n         return stream;\n     }\n+\n+    /**\n+     * A {@link DnsServerAddressStream} which always returns the same {@link InetSocketAddress}.\n+     */\n+    public static final class SingletonDnsServerAddresses implements DnsServerAddressStream {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0MjgyNQ==", "bodyText": "We should not override the copyright year", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536442825", "createdAt": "2020-12-04T23:27:03Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-dns-discovery-netty/src/test/java/io/servicetalk/dns/discovery/netty/DefaultDnsClientTest.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*\n- * Copyright \u00a9 2018 Apple Inc. and the ServiceTalk project authors\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ0MzQxMA==", "bodyText": "We should not override the copyright year", "url": "https://github.com/apple/servicetalk/pull/1223#discussion_r536443410", "createdAt": "2020-12-04T23:29:05Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-dns-discovery-netty/src/test/java/io/servicetalk/dns/discovery/netty/TestRecordStore.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*\n- * Copyright \u00a9 2019 Apple Inc. and the ServiceTalk project authors\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e31f2e4eb838aa9fa8fed393fff9ff056eae4ee"}, "originalPosition": 3}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "942a2f61b3630f51776f552397cd02e4019b8e16", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/942a2f61b3630f51776f552397cd02e4019b8e16", "committedDate": "2020-12-07T19:58:53Z", "message": "review comments"}, "afterCommit": {"oid": "ce50f2ae8cd6d73bdca7a21d6a07a9eb22213485", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/ce50f2ae8cd6d73bdca7a21d6a07a9eb22213485", "committedDate": "2020-12-07T20:27:32Z", "message": "rebase and update test utilities"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NTcyNzA0", "url": "https://github.com/apple/servicetalk/pull/1223#pullrequestreview-546572704", "createdAt": "2020-12-07T21:59:33Z", "commit": {"oid": "1d0fb7fdd07a4577dd10e8c33bd41d8cbea384e7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c03217d0eb3ffabeb4c0e71af797ae11d180b3c3", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/c03217d0eb3ffabeb4c0e71af797ae11d180b3c3", "committedDate": "2020-12-07T23:20:57Z", "message": "DNS Client SRV robustness and A* record Publisher support\n\nMotivation:\nSRV resolution involves a two phase lookup. First a SRV query, which\nreturns a set of name/port pairs, and then for each pair a A* record\nresolution. If an A* record resolution fails it currently fails the\nouter SRV Publisher. We also do a one-time-lookup at the A* record level\nso we can't detect multiple A* records nor can we detect any changes at\nthe A* record level. When a failure at the SRV level occurs we don't\ncleanup the A* publisher query processing, which may accumulate queued\nitems over subsequent retry attempts.\n\nModifications:\n- DefaultDnsClient SRV resolution should use flatMapMerge to process\nmultiple A* resolution streams in parallel, track changes, and deal with\ndynamic failures.\n- DefaultDnsClient SRV resolution should not let A* resolution failures\npropagate to the SRV level, and instead should be retried as long as\nthere is a corresponding SRV entry.\n- DefaultDnsClient SRV resolution should force innactive events upon\nfailure so that A* record publishers cleanup associated queues/timers.\n- DefaultDnsClient SRV resolution should support a mode that allows\ndeduplication of <host, ip> pairs returned by different A* record\npublishers.\n- DefaultDnsClient SRV resolution should disable Netty's CNAME cache\nbecause it may result in incorrect failures if CNAME TTLs are longer\nthan the SRV entries TTLs they map to.\n- DefaultDnsClientTest and TestRecordStore have been reimplemented to\nallow for direct control in the unit test, rather than implicit\nremoval/addition in the background.\n\nResult:\nMore robust DNS SRV record resolution that can also continiously follow\neach corresponding A* record stream."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3c065e9e26779108c8d4f23a832a8eb782c0832", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/f3c065e9e26779108c8d4f23a832a8eb782c0832", "committedDate": "2020-12-07T23:20:57Z", "message": "review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed62bd9e0d1d71e728f712e31f1d12dc89bd05a2", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/ed62bd9e0d1d71e728f712e31f1d12dc89bd05a2", "committedDate": "2020-12-07T23:22:46Z", "message": "rebase to main"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1d0fb7fdd07a4577dd10e8c33bd41d8cbea384e7", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/1d0fb7fdd07a4577dd10e8c33bd41d8cbea384e7", "committedDate": "2020-12-07T21:28:24Z", "message": "fix import order"}, "afterCommit": {"oid": "ed62bd9e0d1d71e728f712e31f1d12dc89bd05a2", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/ed62bd9e0d1d71e728f712e31f1d12dc89bd05a2", "committedDate": "2020-12-07T23:22:46Z", "message": "rebase to main"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3343, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}