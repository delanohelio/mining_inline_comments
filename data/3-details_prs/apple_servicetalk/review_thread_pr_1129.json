{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5ODUxNTg1", "number": 1129, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjo0OTo0OFrOEan45w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMzo1NDoyM1rOEavnxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MzUxOTc1OnYy", "diffSide": "RIGHT", "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/HttpsProxyTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjo0OTo0OFrOHEKzPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNjo0OTo0OFrOHEKzPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEzMzMxMA==", "bodyText": "Debugging leftover?", "url": "https://github.com/apple/servicetalk/pull/1129#discussion_r474133310", "createdAt": "2020-08-20T16:49:48Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-netty/src/test/java/io/servicetalk/http/netty/HttpsProxyTest.java", "diffHunk": "@@ -84,7 +83,11 @@ public void tearDown() throws Exception {\n \n     static void safeClose(@Nullable AutoCloseable closeable) {\n         if (closeable != null) {\n-            closeAndReThrowUnchecked(closeable);\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1d53b46509f53b4ba82b7bae07e604991fbb924"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2MzYzMTkxOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzoyMjoxNlrOHEL5mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMjoxNDozNFrOHEVFaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1MTMyMw==", "bodyText": "A negative of sending an event is that there is no acknowledgment of receipt which makes debugging harder.\nAn alternative is to follow what we do for DeferSslHandler => lookup the handler and register interest for receiving the observer. The negative is more public API (internal so arguably low) but gives a more determinsitic behavior.", "url": "https://github.com/apple/servicetalk/pull/1129#discussion_r474151323", "createdAt": "2020-08-20T17:22:16Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -672,7 +680,16 @@ public void channelInactive(ChannelHandlerContext ctx) {\n         }\n \n         private void doChannelActive(ChannelHandlerContext ctx) {\n+            if (active) {\n+                return;\n+            }\n+            active = true;\n+\n             if (waitForSslHandshake) {\n+                if (observer != null) {\n+                    // Notify ConnectionObserverHandler that we are ready to receive SecurityHandshakeObserver instance\n+                    ctx.pipeline().fireUserEventTriggered(WaitingForHandshakeCompletionEvent.INSTANCE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1d53b46509f53b4ba82b7bae07e604991fbb924"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMwMTgwMw==", "bodyText": "Good suggestion! Everything is pkg-private without public exposure \ud83c\udf89", "url": "https://github.com/apple/servicetalk/pull/1129#discussion_r474301803", "createdAt": "2020-08-20T22:14:34Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DefaultNettyConnection.java", "diffHunk": "@@ -672,7 +680,16 @@ public void channelInactive(ChannelHandlerContext ctx) {\n         }\n \n         private void doChannelActive(ChannelHandlerContext ctx) {\n+            if (active) {\n+                return;\n+            }\n+            active = true;\n+\n             if (waitForSslHandshake) {\n+                if (observer != null) {\n+                    // Notify ConnectionObserverHandler that we are ready to receive SecurityHandshakeObserver instance\n+                    ctx.pipeline().fireUserEventTriggered(WaitingForHandshakeCompletionEvent.INSTANCE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1MTMyMw=="}, "originalCommit": {"oid": "f1d53b46509f53b4ba82b7bae07e604991fbb924"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NDc4NjYwOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/NettyPipelineSslUtils.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMzo1NDoyM1rOHEW_2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwMjo1MzowOFrOHEZ2RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMzE0NA==", "bodyText": "Log at warn if shouldReport is true?", "url": "https://github.com/apple/servicetalk/pull/1129#discussion_r474333144", "createdAt": "2020-08-20T23:54:23Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/NettyPipelineSslUtils.java", "diffHunk": "@@ -54,28 +52,29 @@ public static boolean isSslEnabled(ChannelPipeline pipeline) {\n      * @param pipeline the {@link ChannelPipeline} which contains handler containing the {@link SSLSession}.\n      * @param sslEvent the event indicating a SSL/TLS handshake completed.\n      * @param failureConsumer invoked if a failure is encountered.\n+     * @param shouldReport {@code true} if the handshake status should be reported to {@link SecurityHandshakeObserver}.\n      * @return The {@link SSLSession} or {@code null} if none can be found.\n      */\n     @Nullable\n     public static SSLSession extractSslSessionAndReport(ChannelPipeline pipeline,\n                                                         SslHandshakeCompletionEvent sslEvent,\n-                                                        Consumer<Throwable> failureConsumer) {\n-        final Channel channel = pipeline.channel();\n-        final SecurityHandshakeObserver securityObserver = channel.attr(SECURITY_HANDSHAKE_OBSERVER).get();\n+                                                        Consumer<Throwable> failureConsumer,\n+                                                        boolean shouldReport) {\n+        final SecurityHandshakeObserver observer = shouldReport ? handshakeObserver(pipeline) : null;\n         if (sslEvent.isSuccess()) {\n             final SslHandler sslHandler = pipeline.get(SslHandler.class);\n             if (sslHandler != null) {\n                 final SSLSession session = sslHandler.engine().getSession();\n-                if (securityObserver != null) {\n-                    securityObserver.handshakeComplete(session);\n+                if (observer != null) {\n+                    observer.handshakeComplete(session);\n                 }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d2d15ea9d20e48b47c336ff99176ea0431eabf2"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM1OTY0Ng==", "bodyText": "The warn log is easy to miss. This is not expected to be caught by users, we should provide a guarantee that it never happens. I'm thinking about an assertion, but as we discussed offline we will avoid using null values. Therefore, shouldReport will go away in a follow-up.", "url": "https://github.com/apple/servicetalk/pull/1129#discussion_r474359646", "createdAt": "2020-08-21T01:35:48Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/NettyPipelineSslUtils.java", "diffHunk": "@@ -54,28 +52,29 @@ public static boolean isSslEnabled(ChannelPipeline pipeline) {\n      * @param pipeline the {@link ChannelPipeline} which contains handler containing the {@link SSLSession}.\n      * @param sslEvent the event indicating a SSL/TLS handshake completed.\n      * @param failureConsumer invoked if a failure is encountered.\n+     * @param shouldReport {@code true} if the handshake status should be reported to {@link SecurityHandshakeObserver}.\n      * @return The {@link SSLSession} or {@code null} if none can be found.\n      */\n     @Nullable\n     public static SSLSession extractSslSessionAndReport(ChannelPipeline pipeline,\n                                                         SslHandshakeCompletionEvent sslEvent,\n-                                                        Consumer<Throwable> failureConsumer) {\n-        final Channel channel = pipeline.channel();\n-        final SecurityHandshakeObserver securityObserver = channel.attr(SECURITY_HANDSHAKE_OBSERVER).get();\n+                                                        Consumer<Throwable> failureConsumer,\n+                                                        boolean shouldReport) {\n+        final SecurityHandshakeObserver observer = shouldReport ? handshakeObserver(pipeline) : null;\n         if (sslEvent.isSuccess()) {\n             final SslHandler sslHandler = pipeline.get(SslHandler.class);\n             if (sslHandler != null) {\n                 final SSLSession session = sslHandler.engine().getSession();\n-                if (securityObserver != null) {\n-                    securityObserver.handshakeComplete(session);\n+                if (observer != null) {\n+                    observer.handshakeComplete(session);\n                 }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMzE0NA=="}, "originalCommit": {"oid": "2d2d15ea9d20e48b47c336ff99176ea0431eabf2"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM3OTg0NQ==", "bodyText": "Ok what I meant was that if we expect the observer to be present but it is not; is there something we need to do to bubble it up to the user?\nYes good to guarantee but bugs will make it hard to debug. Perhaps a good item to think about when using NOOP observers.", "url": "https://github.com/apple/servicetalk/pull/1129#discussion_r474379845", "createdAt": "2020-08-21T02:53:08Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/NettyPipelineSslUtils.java", "diffHunk": "@@ -54,28 +52,29 @@ public static boolean isSslEnabled(ChannelPipeline pipeline) {\n      * @param pipeline the {@link ChannelPipeline} which contains handler containing the {@link SSLSession}.\n      * @param sslEvent the event indicating a SSL/TLS handshake completed.\n      * @param failureConsumer invoked if a failure is encountered.\n+     * @param shouldReport {@code true} if the handshake status should be reported to {@link SecurityHandshakeObserver}.\n      * @return The {@link SSLSession} or {@code null} if none can be found.\n      */\n     @Nullable\n     public static SSLSession extractSslSessionAndReport(ChannelPipeline pipeline,\n                                                         SslHandshakeCompletionEvent sslEvent,\n-                                                        Consumer<Throwable> failureConsumer) {\n-        final Channel channel = pipeline.channel();\n-        final SecurityHandshakeObserver securityObserver = channel.attr(SECURITY_HANDSHAKE_OBSERVER).get();\n+                                                        Consumer<Throwable> failureConsumer,\n+                                                        boolean shouldReport) {\n+        final SecurityHandshakeObserver observer = shouldReport ? handshakeObserver(pipeline) : null;\n         if (sslEvent.isSuccess()) {\n             final SslHandler sslHandler = pipeline.get(SslHandler.class);\n             if (sslHandler != null) {\n                 final SSLSession session = sslHandler.engine().getSession();\n-                if (securityObserver != null) {\n-                    securityObserver.handshakeComplete(session);\n+                if (observer != null) {\n+                    observer.handshakeComplete(session);\n                 }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMzE0NA=="}, "originalCommit": {"oid": "2d2d15ea9d20e48b47c336ff99176ea0431eabf2"}, "originalPosition": 43}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2547, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}