{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3ODQ5NzIz", "number": 994, "title": "Introduce `HttpLoadBalancerFactory`", "bodyText": "Motivation\nToday HttpClientBuilder takes two separate implementations of LoadBalancerFactory as well as Function as a protocol binder. As LoadBalancerFactory is protocol neutral, it does make sense to have the protocol binding separate but having two separate entities makes the generic ugly and it is hard to understand what the parameters stand for. Moreover the protocol binder is closely related to the load balancer anyways.\nModification\nIntroduce HttpLoadBalancerFactory that combines these two aspects and makes the usage easier.\nAdd a DefaultHttpLoadBalancerFactory to provide the default implementation using Round robin load balancer and in the future more load balancer implementations geared towards HTTP.\nResult\nEasier to understand interface for HTTP layer load balancing.", "createdAt": "2020-04-02T23:00:35Z", "url": "https://github.com/apple/servicetalk/pull/994", "merged": true, "mergeCommit": {"oid": "3e616be602e4baad65ae26a05affcca66c856792"}, "closed": true, "closedAt": "2020-04-03T23:43:55Z", "author": {"login": "NiteshKant"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcT0bnMAH2gAyMzk3ODQ5NzIzOjZjNzMyYmY4NDUxNGE3MjFjZjAwMzBkMWNlMGU4Zjc4OTkyMmE0NDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcUHp7bAH2gAyMzk3ODQ5NzIzOjZiOTRkNTI0ZDMzNzM2MWVhYmU3NWU3Y2Y4MjBlMzBjYTIxY2YwYmY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6c732bf84514a721cf0030d1ce0e8f789922a441", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/6c732bf84514a721cf0030d1ce0e8f789922a441", "committedDate": "2020-04-02T22:55:52Z", "message": "Introduce `HttpLoadBalancerFactory`\n\n__Motivation__\n\nToday `HttpClientBuilder` takes two separate implementations of `LoadBalancerFactory` as well as `Function` as a protocol binder. As `LoadBalancerFactory` is protocol neutral, it does make sense to have the protocol binding separate but having two separate entities makes the generic ugly and it is hard to understand what the parameters stand for.\n\n__Modification__\n\nIntroduce `HttpLoadBalancerFactory` that combines these two aspects and makes the usage easier.\nAdd a `DefaultHttpLoadBalancerFactory` to provide the default implementation using Round robin load balancer and in the future more load balancer implementations geared towards HTTP.\n\n__Result__\n\nEasier to understand interface for HTTP layer load balancing."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2b3a00745b0ff30aa527d3d3b5ec67dbe52a347", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/b2b3a00745b0ff30aa527d3d3b5ec67dbe52a347", "committedDate": "2020-04-03T00:11:18Z", "message": "Correctly implement exec strategy influencing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1", "committedDate": "2020-04-03T00:21:14Z", "message": "Making checkstyle happy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee43fa56b3916bbfb4f07b4bd74d52f51a2b3404", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/ee43fa56b3916bbfb4f07b4bd74d52f51a2b3404", "committedDate": "2020-04-03T00:47:22Z", "message": "Making checkstyle happy - take 2"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2ODcwNzA5", "url": "https://github.com/apple/servicetalk/pull/994#pullrequestreview-386870709", "createdAt": "2020-04-03T00:45:46Z", "commit": {"oid": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMDo0NTo0NlrOGABYlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMDo1MDowMVrOGABdIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NTg2Mw==", "bodyText": "consider killing the Config object and unrolling to just pass the fields directly from the builder:\nprivate final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory;\nprivate final HttpExecutionStrategyInfluencer strategyInfluencer;", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r402675863", "createdAt": "2020-04-03T00:45:46Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultHttpLoadBalancerFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.client.api.ConnectionFactory;\n+import io.servicetalk.client.api.LoadBalancer;\n+import io.servicetalk.client.api.LoadBalancerFactory;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.FilterableStreamingHttpConnection;\n+import io.servicetalk.http.api.FilterableStreamingHttpLoadBalancedConnection;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpExecutionStrategyInfluencer;\n+import io.servicetalk.http.api.HttpLoadBalancerFactory;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer.RoundRobinLoadBalancerFactory;\n+\n+import static io.servicetalk.http.api.HttpExecutionStrategyInfluencer.defaultStreamingInfluencer;\n+import static io.servicetalk.loadbalancer.RoundRobinLoadBalancer.newRoundRobinFactory;\n+\n+/**\n+ * Default implementation of {@link HttpLoadBalancerFactory}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ */\n+public final class DefaultHttpLoadBalancerFactory<ResolvedAddress>\n+        implements HttpLoadBalancerFactory<ResolvedAddress>, HttpExecutionStrategyInfluencer {\n+    private final Config<ResolvedAddress> config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NjE3Mw==", "bodyText": "nit: consider using // comments", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r402676173", "createdAt": "2020-04-03T00:46:53Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultHttpLoadBalancerFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.client.api.ConnectionFactory;\n+import io.servicetalk.client.api.LoadBalancer;\n+import io.servicetalk.client.api.LoadBalancerFactory;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.FilterableStreamingHttpConnection;\n+import io.servicetalk.http.api.FilterableStreamingHttpLoadBalancedConnection;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpExecutionStrategyInfluencer;\n+import io.servicetalk.http.api.HttpLoadBalancerFactory;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer.RoundRobinLoadBalancerFactory;\n+\n+import static io.servicetalk.http.api.HttpExecutionStrategyInfluencer.defaultStreamingInfluencer;\n+import static io.servicetalk.loadbalancer.RoundRobinLoadBalancer.newRoundRobinFactory;\n+\n+/**\n+ * Default implementation of {@link HttpLoadBalancerFactory}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ */\n+public final class DefaultHttpLoadBalancerFactory<ResolvedAddress>\n+        implements HttpLoadBalancerFactory<ResolvedAddress>, HttpExecutionStrategyInfluencer {\n+    private final Config<ResolvedAddress> config;\n+\n+    private DefaultHttpLoadBalancerFactory(final Config<ResolvedAddress> config) {\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public LoadBalancer<? extends FilterableStreamingHttpLoadBalancedConnection> newLoadBalancer(\n+            final Publisher<? extends ServiceDiscovererEvent<ResolvedAddress>> eventPublisher,\n+            final ConnectionFactory<ResolvedAddress, ? extends FilterableStreamingHttpLoadBalancedConnection> cf) {\n+        return config.rawFactory.newLoadBalancer(eventPublisher, cf);\n+    }\n+\n+    @Override\n+    public FilterableStreamingHttpLoadBalancedConnection toLoadBalancedConnection(\n+            final FilterableStreamingHttpConnection connection) {\n+        return new AbstractFilterableStreamingHttpLoadBalancedConnection(connection) {\n+            @Override\n+            public float score() {\n+                return 1;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n+        return config.strategyInfluencer.influenceStrategy(strategy);\n+    }\n+\n+    /**\n+     * A builder for creating instances of {@link DefaultHttpLoadBalancerFactory}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution for the {@link HttpLoadBalancerFactory} built by\n+     * this builder.\n+     */\n+    public static final class Builder<ResolvedAddress> {\n+        private final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory;\n+        private final HttpExecutionStrategyInfluencer strategyInfluencer;\n+\n+        private Builder(\n+                final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory,\n+                final HttpExecutionStrategyInfluencer strategyInfluencer) {\n+            this.rawFactory = rawFactory;\n+            this.strategyInfluencer = strategyInfluencer;\n+        }\n+\n+        /**\n+         * Builds a {@link DefaultHttpLoadBalancerFactory} using the properties configured on this builder.\n+         *\n+         * @return A {@link DefaultHttpLoadBalancerFactory}.\n+         */\n+        public DefaultHttpLoadBalancerFactory<ResolvedAddress> build() {\n+            return new DefaultHttpLoadBalancerFactory<>(new Config<>(rawFactory, strategyInfluencer));\n+        }\n+\n+        /**\n+         * Creates a new {@link Builder} instance using the default {@link LoadBalancer} implementation.\n+         *\n+         * @param <ResolvedAddress> The type of address after resolution for the {@link LoadBalancerFactory} built by\n+         * the returned builder.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress> fromDefaults() {\n+            return from(newRoundRobinFactory());\n+        }\n+\n+        /**\n+         * Creates a new {@link Builder} using the passed {@link LoadBalancerFactory}.\n+         *\n+         * @param rawFactory {@link LoadBalancerFactory} to use for creating a {@link HttpLoadBalancerFactory} from the\n+         * returned {@link Builder}.\n+         * @param <ResolvedAddress> The type of address after resolution for a {@link HttpLoadBalancerFactory} created\n+         * by the returned {@link Builder}.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress> from(\n+                final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory) {\n+            final HttpExecutionStrategyInfluencer strategyInfluencer;\n+            if (rawFactory instanceof HttpExecutionStrategyInfluencer) {\n+                strategyInfluencer = (HttpExecutionStrategyInfluencer) rawFactory;\n+            } else if(rawFactory instanceof RoundRobinLoadBalancerFactory) {\n+                strategyInfluencer = strategy -> strategy; // RoundRobinLoadBalancer is non-blocking.\n+            } else {\n+                /* user provided load balancer assumed to be blocking unless told otherwise */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NjM4OA==", "bodyText": "nit: consider clarifying, the only supported way to override the rawFactory to implement HttpExecutionStrategyInfluencer.", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r402676388", "createdAt": "2020-04-03T00:47:39Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultHttpLoadBalancerFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.client.api.ConnectionFactory;\n+import io.servicetalk.client.api.LoadBalancer;\n+import io.servicetalk.client.api.LoadBalancerFactory;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.FilterableStreamingHttpConnection;\n+import io.servicetalk.http.api.FilterableStreamingHttpLoadBalancedConnection;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpExecutionStrategyInfluencer;\n+import io.servicetalk.http.api.HttpLoadBalancerFactory;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer.RoundRobinLoadBalancerFactory;\n+\n+import static io.servicetalk.http.api.HttpExecutionStrategyInfluencer.defaultStreamingInfluencer;\n+import static io.servicetalk.loadbalancer.RoundRobinLoadBalancer.newRoundRobinFactory;\n+\n+/**\n+ * Default implementation of {@link HttpLoadBalancerFactory}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ */\n+public final class DefaultHttpLoadBalancerFactory<ResolvedAddress>\n+        implements HttpLoadBalancerFactory<ResolvedAddress>, HttpExecutionStrategyInfluencer {\n+    private final Config<ResolvedAddress> config;\n+\n+    private DefaultHttpLoadBalancerFactory(final Config<ResolvedAddress> config) {\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public LoadBalancer<? extends FilterableStreamingHttpLoadBalancedConnection> newLoadBalancer(\n+            final Publisher<? extends ServiceDiscovererEvent<ResolvedAddress>> eventPublisher,\n+            final ConnectionFactory<ResolvedAddress, ? extends FilterableStreamingHttpLoadBalancedConnection> cf) {\n+        return config.rawFactory.newLoadBalancer(eventPublisher, cf);\n+    }\n+\n+    @Override\n+    public FilterableStreamingHttpLoadBalancedConnection toLoadBalancedConnection(\n+            final FilterableStreamingHttpConnection connection) {\n+        return new AbstractFilterableStreamingHttpLoadBalancedConnection(connection) {\n+            @Override\n+            public float score() {\n+                return 1;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n+        return config.strategyInfluencer.influenceStrategy(strategy);\n+    }\n+\n+    /**\n+     * A builder for creating instances of {@link DefaultHttpLoadBalancerFactory}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution for the {@link HttpLoadBalancerFactory} built by\n+     * this builder.\n+     */\n+    public static final class Builder<ResolvedAddress> {\n+        private final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory;\n+        private final HttpExecutionStrategyInfluencer strategyInfluencer;\n+\n+        private Builder(\n+                final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory,\n+                final HttpExecutionStrategyInfluencer strategyInfluencer) {\n+            this.rawFactory = rawFactory;\n+            this.strategyInfluencer = strategyInfluencer;\n+        }\n+\n+        /**\n+         * Builds a {@link DefaultHttpLoadBalancerFactory} using the properties configured on this builder.\n+         *\n+         * @return A {@link DefaultHttpLoadBalancerFactory}.\n+         */\n+        public DefaultHttpLoadBalancerFactory<ResolvedAddress> build() {\n+            return new DefaultHttpLoadBalancerFactory<>(new Config<>(rawFactory, strategyInfluencer));\n+        }\n+\n+        /**\n+         * Creates a new {@link Builder} instance using the default {@link LoadBalancer} implementation.\n+         *\n+         * @param <ResolvedAddress> The type of address after resolution for the {@link LoadBalancerFactory} built by\n+         * the returned builder.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress> fromDefaults() {\n+            return from(newRoundRobinFactory());\n+        }\n+\n+        /**\n+         * Creates a new {@link Builder} using the passed {@link LoadBalancerFactory}.\n+         *\n+         * @param rawFactory {@link LoadBalancerFactory} to use for creating a {@link HttpLoadBalancerFactory} from the\n+         * returned {@link Builder}.\n+         * @param <ResolvedAddress> The type of address after resolution for a {@link HttpLoadBalancerFactory} created\n+         * by the returned {@link Builder}.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress> from(\n+                final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory) {\n+            final HttpExecutionStrategyInfluencer strategyInfluencer;\n+            if (rawFactory instanceof HttpExecutionStrategyInfluencer) {\n+                strategyInfluencer = (HttpExecutionStrategyInfluencer) rawFactory;\n+            } else if(rawFactory instanceof RoundRobinLoadBalancerFactory) {\n+                strategyInfluencer = strategy -> strategy; // RoundRobinLoadBalancer is non-blocking.\n+            } else {\n+                /* user provided load balancer assumed to be blocking unless told otherwise */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NjE3Mw=="}, "originalCommit": {"oid": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NzAyNg==", "bodyText": "can you clarify why this needs to be exposed as public type and have a static factory method to create a new one?", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r402677026", "createdAt": "2020-04-03T00:50:01Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-loadbalancer/src/main/java/io/servicetalk/loadbalancer/RoundRobinLoadBalancer.java", "diffHunk": "@@ -331,6 +329,25 @@ public Completable closeAsyncGracefully() {\n         return asyncCloseable.closeAsyncGracefully();\n     }\n \n+    /**\n+     * {@link LoadBalancerFactory} for {@link RoundRobinLoadBalancer}.\n+     *\n+     * @param <ResolvedAddress> The resolved address type.\n+     * @param <C> The type of connection.\n+     */\n+    public static final class RoundRobinLoadBalancerFactory<ResolvedAddress, C extends LoadBalancedConnection>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2ODY0ODYy", "url": "https://github.com/apple/servicetalk/pull/994#pullrequestreview-386864862", "createdAt": "2020-04-03T00:26:21Z", "commit": {"oid": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMDoyNjoyMVrOGABDXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwMDo1MzoyMVrOGABgkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MDQyOQ==", "bodyText": "This is a pkg-private abstract class that is used only in one place - DefaultHttpLoadBalancerFactory. Consider implementing it as a private static final class of DefaultHttpLoadBalancerFactory. Extend StreamingHttpConnectionFilter to avoid duplicating delegate logic.", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r402670429", "createdAt": "2020-04-03T00:26:21Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/AbstractFilterableStreamingHttpLoadBalancedConnection.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.http.api.FilterableStreamingHttpConnection;\n+import io.servicetalk.http.api.FilterableStreamingHttpLoadBalancedConnection;\n+import io.servicetalk.http.api.HttpConnectionContext;\n+import io.servicetalk.http.api.HttpEventKey;\n+import io.servicetalk.http.api.HttpExecutionContext;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpRequestMethod;\n+import io.servicetalk.http.api.StreamingHttpRequest;\n+import io.servicetalk.http.api.StreamingHttpResponse;\n+import io.servicetalk.http.api.StreamingHttpResponseFactory;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+abstract class AbstractFilterableStreamingHttpLoadBalancedConnection", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3Mjc0NA==", "bodyText": "Unused import statement", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r402672744", "createdAt": "2020-04-03T00:34:22Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultHttpLoadBalancerFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.client.api.ConnectionFactory;\n+import io.servicetalk.client.api.LoadBalancer;\n+import io.servicetalk.client.api.LoadBalancerFactory;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.FilterableStreamingHttpConnection;\n+import io.servicetalk.http.api.FilterableStreamingHttpLoadBalancedConnection;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpExecutionStrategyInfluencer;\n+import io.servicetalk.http.api.HttpLoadBalancerFactory;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MzU2Ng==", "bodyText": "Looking at #996, should it be Integer.MAX_VALUE?\nConcurrent PRs :) this returns float. Will keep this comment as a reminder to update.", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r402673566", "createdAt": "2020-04-03T00:37:39Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultHttpLoadBalancerFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.client.api.ConnectionFactory;\n+import io.servicetalk.client.api.LoadBalancer;\n+import io.servicetalk.client.api.LoadBalancerFactory;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.FilterableStreamingHttpConnection;\n+import io.servicetalk.http.api.FilterableStreamingHttpLoadBalancedConnection;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpExecutionStrategyInfluencer;\n+import io.servicetalk.http.api.HttpLoadBalancerFactory;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer.RoundRobinLoadBalancerFactory;\n+\n+import static io.servicetalk.http.api.HttpExecutionStrategyInfluencer.defaultStreamingInfluencer;\n+import static io.servicetalk.loadbalancer.RoundRobinLoadBalancer.newRoundRobinFactory;\n+\n+/**\n+ * Default implementation of {@link HttpLoadBalancerFactory}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ */\n+public final class DefaultHttpLoadBalancerFactory<ResolvedAddress>\n+        implements HttpLoadBalancerFactory<ResolvedAddress>, HttpExecutionStrategyInfluencer {\n+    private final Config<ResolvedAddress> config;\n+\n+    private DefaultHttpLoadBalancerFactory(final Config<ResolvedAddress> config) {\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public LoadBalancer<? extends FilterableStreamingHttpLoadBalancedConnection> newLoadBalancer(\n+            final Publisher<? extends ServiceDiscovererEvent<ResolvedAddress>> eventPublisher,\n+            final ConnectionFactory<ResolvedAddress, ? extends FilterableStreamingHttpLoadBalancedConnection> cf) {\n+        return config.rawFactory.newLoadBalancer(eventPublisher, cf);\n+    }\n+\n+    @Override\n+    public FilterableStreamingHttpLoadBalancedConnection toLoadBalancedConnection(\n+            final FilterableStreamingHttpConnection connection) {\n+        return new AbstractFilterableStreamingHttpLoadBalancedConnection(connection) {\n+            @Override\n+            public float score() {\n+                return 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NTAzOQ==", "bodyText": "The LB provided by users may be implemented in the same way as RoundRobinLoadBalancerFactory: it may not have a dependency on http-api. Therefore, it won't be able to implement HttpExecutionStrategyInfluencer. Consider providing a builder method that can take HttpExecutionStrategyInfluencer.", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r402675039", "createdAt": "2020-04-03T00:42:50Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultHttpLoadBalancerFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.client.api.ConnectionFactory;\n+import io.servicetalk.client.api.LoadBalancer;\n+import io.servicetalk.client.api.LoadBalancerFactory;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.FilterableStreamingHttpConnection;\n+import io.servicetalk.http.api.FilterableStreamingHttpLoadBalancedConnection;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpExecutionStrategyInfluencer;\n+import io.servicetalk.http.api.HttpLoadBalancerFactory;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer.RoundRobinLoadBalancerFactory;\n+\n+import static io.servicetalk.http.api.HttpExecutionStrategyInfluencer.defaultStreamingInfluencer;\n+import static io.servicetalk.loadbalancer.RoundRobinLoadBalancer.newRoundRobinFactory;\n+\n+/**\n+ * Default implementation of {@link HttpLoadBalancerFactory}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ */\n+public final class DefaultHttpLoadBalancerFactory<ResolvedAddress>\n+        implements HttpLoadBalancerFactory<ResolvedAddress>, HttpExecutionStrategyInfluencer {\n+    private final Config<ResolvedAddress> config;\n+\n+    private DefaultHttpLoadBalancerFactory(final Config<ResolvedAddress> config) {\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public LoadBalancer<? extends FilterableStreamingHttpLoadBalancedConnection> newLoadBalancer(\n+            final Publisher<? extends ServiceDiscovererEvent<ResolvedAddress>> eventPublisher,\n+            final ConnectionFactory<ResolvedAddress, ? extends FilterableStreamingHttpLoadBalancedConnection> cf) {\n+        return config.rawFactory.newLoadBalancer(eventPublisher, cf);\n+    }\n+\n+    @Override\n+    public FilterableStreamingHttpLoadBalancedConnection toLoadBalancedConnection(\n+            final FilterableStreamingHttpConnection connection) {\n+        return new AbstractFilterableStreamingHttpLoadBalancedConnection(connection) {\n+            @Override\n+            public float score() {\n+                return 1;\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n+        return config.strategyInfluencer.influenceStrategy(strategy);\n+    }\n+\n+    /**\n+     * A builder for creating instances of {@link DefaultHttpLoadBalancerFactory}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution for the {@link HttpLoadBalancerFactory} built by\n+     * this builder.\n+     */\n+    public static final class Builder<ResolvedAddress> {\n+        private final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory;\n+        private final HttpExecutionStrategyInfluencer strategyInfluencer;\n+\n+        private Builder(\n+                final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory,\n+                final HttpExecutionStrategyInfluencer strategyInfluencer) {\n+            this.rawFactory = rawFactory;\n+            this.strategyInfluencer = strategyInfluencer;\n+        }\n+\n+        /**\n+         * Builds a {@link DefaultHttpLoadBalancerFactory} using the properties configured on this builder.\n+         *\n+         * @return A {@link DefaultHttpLoadBalancerFactory}.\n+         */\n+        public DefaultHttpLoadBalancerFactory<ResolvedAddress> build() {\n+            return new DefaultHttpLoadBalancerFactory<>(new Config<>(rawFactory, strategyInfluencer));\n+        }\n+\n+        /**\n+         * Creates a new {@link Builder} instance using the default {@link LoadBalancer} implementation.\n+         *\n+         * @param <ResolvedAddress> The type of address after resolution for the {@link LoadBalancerFactory} built by\n+         * the returned builder.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress> fromDefaults() {\n+            return from(newRoundRobinFactory());\n+        }\n+\n+        /**\n+         * Creates a new {@link Builder} using the passed {@link LoadBalancerFactory}.\n+         *\n+         * @param rawFactory {@link LoadBalancerFactory} to use for creating a {@link HttpLoadBalancerFactory} from the\n+         * returned {@link Builder}.\n+         * @param <ResolvedAddress> The type of address after resolution for a {@link HttpLoadBalancerFactory} created\n+         * by the returned {@link Builder}.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress> from(\n+                final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory) {\n+            final HttpExecutionStrategyInfluencer strategyInfluencer;\n+            if (rawFactory instanceof HttpExecutionStrategyInfluencer) {\n+                strategyInfluencer = (HttpExecutionStrategyInfluencer) rawFactory;\n+            } else if(rawFactory instanceof RoundRobinLoadBalancerFactory) {\n+                strategyInfluencer = strategy -> strategy; // RoundRobinLoadBalancer is non-blocking.\n+            } else {\n+                /* user provided load balancer assumed to be blocking unless told otherwise */\n+                strategyInfluencer = defaultStreamingInfluencer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3NzkwNQ==", "bodyText": "Should we provide any way for users to configure this value? For example, consider adding a method for the builder that will take Function<FilterableStreamingHttpConnection, FilterableStreamingHttpLoadBalancedConnection>.", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r402677905", "createdAt": "2020-04-03T00:53:21Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultHttpLoadBalancerFactory.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.client.api.ConnectionFactory;\n+import io.servicetalk.client.api.LoadBalancer;\n+import io.servicetalk.client.api.LoadBalancerFactory;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.http.api.FilterableStreamingHttpConnection;\n+import io.servicetalk.http.api.FilterableStreamingHttpLoadBalancedConnection;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpExecutionStrategyInfluencer;\n+import io.servicetalk.http.api.HttpLoadBalancerFactory;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer.RoundRobinLoadBalancerFactory;\n+\n+import static io.servicetalk.http.api.HttpExecutionStrategyInfluencer.defaultStreamingInfluencer;\n+import static io.servicetalk.loadbalancer.RoundRobinLoadBalancer.newRoundRobinFactory;\n+\n+/**\n+ * Default implementation of {@link HttpLoadBalancerFactory}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ */\n+public final class DefaultHttpLoadBalancerFactory<ResolvedAddress>\n+        implements HttpLoadBalancerFactory<ResolvedAddress>, HttpExecutionStrategyInfluencer {\n+    private final Config<ResolvedAddress> config;\n+\n+    private DefaultHttpLoadBalancerFactory(final Config<ResolvedAddress> config) {\n+        this.config = config;\n+    }\n+\n+    @Override\n+    public LoadBalancer<? extends FilterableStreamingHttpLoadBalancedConnection> newLoadBalancer(\n+            final Publisher<? extends ServiceDiscovererEvent<ResolvedAddress>> eventPublisher,\n+            final ConnectionFactory<ResolvedAddress, ? extends FilterableStreamingHttpLoadBalancedConnection> cf) {\n+        return config.rawFactory.newLoadBalancer(eventPublisher, cf);\n+    }\n+\n+    @Override\n+    public FilterableStreamingHttpLoadBalancedConnection toLoadBalancedConnection(\n+            final FilterableStreamingHttpConnection connection) {\n+        return new AbstractFilterableStreamingHttpLoadBalancedConnection(connection) {\n+            @Override\n+            public float score() {\n+                return 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY3MzU2Ng=="}, "originalCommit": {"oid": "1fb6aa75a16a6bd9097ddf0dcb1bfd8f5d529ea1"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3MDI3ODY4", "url": "https://github.com/apple/servicetalk/pull/994#pullrequestreview-387027868", "createdAt": "2020-04-03T07:47:24Z", "commit": {"oid": "ee43fa56b3916bbfb4f07b4bd74d52f51a2b3404"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33dcb99c3fae038fec1498b8954eb02a6ac1e26c", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/33dcb99c3fae038fec1498b8954eb02a6ac1e26c", "committedDate": "2020-04-03T19:30:03Z", "message": "Merge remote-tracking branch 'upstream/master' into http-lb-factory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b31bd22b03dab8a861cec3f31c1d74fab62cb506", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/b31bd22b03dab8a861cec3f31c1d74fab62cb506", "committedDate": "2020-04-03T20:40:04Z", "message": "Review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "835e25a8180ababde87ae5661ff1a93c6e9fcc18", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/835e25a8180ababde87ae5661ff1a93c6e9fcc18", "committedDate": "2020-04-03T20:56:28Z", "message": "Merge remote-tracking branch 'upstream/master' into http-lb-factory"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NTc1MDkx", "url": "https://github.com/apple/servicetalk/pull/994#pullrequestreview-387575091", "createdAt": "2020-04-03T20:56:20Z", "commit": {"oid": "b31bd22b03dab8a861cec3f31c1d74fab62cb506"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QyMDo1NjoyMFrOGApVgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QyMDo1NjoyMFrOGApVgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzMzMDQzNQ==", "bodyText": "Consider extending StreamingHttpConnectionFilter to avoid duplicating delegate logic.", "url": "https://github.com/apple/servicetalk/pull/994#discussion_r403330435", "createdAt": "2020-04-03T20:56:20Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/DefaultHttpLoadBalancerFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.http.netty;\n+\n+import io.servicetalk.client.api.ConnectionFactory;\n+import io.servicetalk.client.api.LoadBalancer;\n+import io.servicetalk.client.api.LoadBalancerFactory;\n+import io.servicetalk.client.api.ServiceDiscovererEvent;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+import io.servicetalk.http.api.FilterableStreamingHttpConnection;\n+import io.servicetalk.http.api.FilterableStreamingHttpLoadBalancedConnection;\n+import io.servicetalk.http.api.HttpConnectionContext;\n+import io.servicetalk.http.api.HttpEventKey;\n+import io.servicetalk.http.api.HttpExecutionContext;\n+import io.servicetalk.http.api.HttpExecutionStrategy;\n+import io.servicetalk.http.api.HttpExecutionStrategyInfluencer;\n+import io.servicetalk.http.api.HttpLoadBalancerFactory;\n+import io.servicetalk.http.api.HttpRequestMethod;\n+import io.servicetalk.http.api.StreamingHttpRequest;\n+import io.servicetalk.http.api.StreamingHttpResponse;\n+import io.servicetalk.http.api.StreamingHttpResponseFactory;\n+import io.servicetalk.loadbalancer.RoundRobinLoadBalancer.RoundRobinLoadBalancerFactory;\n+\n+import static io.servicetalk.http.api.HttpExecutionStrategyInfluencer.defaultStreamingInfluencer;\n+import static io.servicetalk.loadbalancer.RoundRobinLoadBalancer.newRoundRobinFactory;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Default implementation of {@link HttpLoadBalancerFactory}.\n+ *\n+ * @param <ResolvedAddress> The type of address after resolution.\n+ */\n+public final class DefaultHttpLoadBalancerFactory<ResolvedAddress>\n+        implements HttpLoadBalancerFactory<ResolvedAddress>, HttpExecutionStrategyInfluencer {\n+    private final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory;\n+    private final HttpExecutionStrategyInfluencer strategyInfluencer;\n+\n+    DefaultHttpLoadBalancerFactory(\n+            final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory,\n+            final HttpExecutionStrategyInfluencer strategyInfluencer) {\n+        this.rawFactory = rawFactory;\n+        this.strategyInfluencer = strategyInfluencer;\n+    }\n+\n+    @Override\n+    public LoadBalancer<? extends FilterableStreamingHttpLoadBalancedConnection> newLoadBalancer(\n+            final Publisher<? extends ServiceDiscovererEvent<ResolvedAddress>> eventPublisher,\n+            final ConnectionFactory<ResolvedAddress, ? extends FilterableStreamingHttpLoadBalancedConnection> cf) {\n+        return rawFactory.newLoadBalancer(eventPublisher, cf);\n+    }\n+\n+    @Override\n+    public FilterableStreamingHttpLoadBalancedConnection toLoadBalancedConnection(\n+            final FilterableStreamingHttpConnection connection) {\n+        return new DefaultFilterableStreamingHttpLoadBalancedConnection(connection);\n+    }\n+\n+    @Override\n+    public HttpExecutionStrategy influenceStrategy(final HttpExecutionStrategy strategy) {\n+        return strategyInfluencer.influenceStrategy(strategy);\n+    }\n+\n+    /**\n+     * A builder for creating instances of {@link DefaultHttpLoadBalancerFactory}.\n+     *\n+     * @param <ResolvedAddress> The type of address after resolution for the {@link HttpLoadBalancerFactory} built by\n+     * this builder.\n+     */\n+    public static final class Builder<ResolvedAddress> {\n+        private final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory;\n+        private final HttpExecutionStrategyInfluencer strategyInfluencer;\n+\n+        private Builder(\n+                final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory,\n+                final HttpExecutionStrategyInfluencer strategyInfluencer) {\n+            this.rawFactory = rawFactory;\n+            this.strategyInfluencer = strategyInfluencer;\n+        }\n+\n+        /**\n+         * Builds a {@link DefaultHttpLoadBalancerFactory} using the properties configured on this builder.\n+         *\n+         * @return A {@link DefaultHttpLoadBalancerFactory}.\n+         */\n+        public DefaultHttpLoadBalancerFactory<ResolvedAddress> build() {\n+            return new DefaultHttpLoadBalancerFactory<>(rawFactory, strategyInfluencer);\n+        }\n+\n+        /**\n+         * Creates a new {@link Builder} instance using the default {@link LoadBalancer} implementation.\n+         *\n+         * @param <ResolvedAddress> The type of address after resolution for the {@link LoadBalancerFactory} built by\n+         * the returned builder.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress> fromDefaults() {\n+            return from(newRoundRobinFactory());\n+        }\n+\n+        /**\n+         * Creates a new {@link Builder} using the passed {@link LoadBalancerFactory}.\n+         *\n+         * @param rawFactory {@link LoadBalancerFactory} to use for creating a {@link HttpLoadBalancerFactory} from the\n+         * returned {@link Builder}.\n+         * @param <ResolvedAddress> The type of address after resolution for a {@link HttpLoadBalancerFactory} created\n+         * by the returned {@link Builder}.\n+         * @return A new {@link Builder}.\n+         */\n+        public static <ResolvedAddress> Builder<ResolvedAddress> from(\n+                final LoadBalancerFactory<ResolvedAddress, FilterableStreamingHttpLoadBalancedConnection> rawFactory) {\n+            final HttpExecutionStrategyInfluencer strategyInfluencer;\n+            if (rawFactory instanceof HttpExecutionStrategyInfluencer) {\n+                strategyInfluencer = (HttpExecutionStrategyInfluencer) rawFactory;\n+            } else if (rawFactory instanceof RoundRobinLoadBalancerFactory) {\n+                strategyInfluencer = strategy -> strategy; // RoundRobinLoadBalancer is non-blocking.\n+            } else {\n+                // user provided load balancer assumed to be blocking unless it implements\n+                // HttpExecutionStrategyInfluencer\n+                strategyInfluencer = defaultStreamingInfluencer();\n+            }\n+            return new Builder<>(rawFactory, strategyInfluencer);\n+        }\n+    }\n+\n+    private static final class DefaultFilterableStreamingHttpLoadBalancedConnection\n+            implements FilterableStreamingHttpLoadBalancedConnection {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b31bd22b03dab8a861cec3f31c1d74fab62cb506"}, "originalPosition": 141}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b94d524d337361eabe75e7cf820e30ca21cf0bf", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/6b94d524d337361eabe75e7cf820e30ca21cf0bf", "committedDate": "2020-04-03T21:19:42Z", "message": "Review comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3571, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}