{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4NDM5NjMy", "number": 1002, "title": "`ProxyConnectConnectionFactoryFilter` leaks connection in case of errors", "bodyText": "Motivation:\nIn case of any error or cancellation, ProxyConnectConnectionFactoryFilter\ndoes not close the connection to the proxy.\nModifications:\n\nAdd tests to verify different failure scenarios for\nProxyConnectConnectionFactoryFilter;\nClose connection when CONNECT request or SSL handshake failures;\nDo not drain the response payload body in case of error, because the\nconnection will be closed anyway;\n\nResult:\nProxyConnectConnectionFactoryFilter does not leak connections.", "createdAt": "2020-04-04T00:34:52Z", "url": "https://github.com/apple/servicetalk/pull/1002", "merged": true, "mergeCommit": {"oid": "ebb4931e8ab823ef006b5d389823be9cc1c062a9"}, "closed": true, "closedAt": "2020-04-09T01:16:55Z", "author": {"login": "idelpivnitskiy"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcUKbZ0gH2gAyMzk4NDM5NjMyOjhhOWNmMzczMTkyYmU5NDE5MDIzNjgwMGQ2MjUzNjljYzZhMjNmNWQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcVwTDogH2gAyMzk4NDM5NjMyOjEyY2JkNGMyOTk4YmM1NTkwZmZmMDM1OTFjOTE5NDU0ZTRhYzM5MDU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8a9cf373192be94190236800d625369cc6a23f5d", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/8a9cf373192be94190236800d625369cc6a23f5d", "committedDate": "2020-04-04T00:33:33Z", "message": "`ProxyConnectConnectionFactoryFilter` leaks connection in case of errors\n\nMotivation:\n\nIn case of any error or cancellation, `ProxyConnectConnectionFactoryFilter`\ndoes not close the connection to the proxy.\n\nModifications:\n\n- Add tests to verify different failure scenarios for\n`ProxyConnectConnectionFactoryFilter`;\n- Close connection when `CONNECT` request or SSL handshake failures or\nif a `Single` is cancelled;\n\nResult:\n\n`ProxyConnectConnectionFactoryFilter` does not leak connections."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3Nzg2NDU3", "url": "https://github.com/apple/servicetalk/pull/1002#pullrequestreview-387786457", "createdAt": "2020-04-05T06:43:56Z", "commit": {"oid": "8a9cf373192be94190236800d625369cc6a23f5d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQwNjo0Mzo1NlrOGA9TGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNVQwNjo0Mzo1NlrOGA9TGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY1NzQ5OQ==", "bodyText": "nit: looks like formatting is off...", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r403657499", "createdAt": "2020-04-05T06:43:56Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -100,28 +103,43 @@ public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt\n                         }\n                     });\n \n-                    DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n+                    final DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n                     if (deferSslHandler == null) {\n-                        return response.payloadBodyAndTrailers().ignoreElements().concat(failed(\n-                                new IllegalStateException(\"Failed to find a handler of type \" +\n-                                        DeferSslHandler.class + \" in channel pipeline.\")));\n+                        return failed(new IllegalStateException(\"Failed to find a handler of type \" +\n+                                DeferSslHandler.class + \" in channel pipeline.\"));\n                     }\n-\n                     deferSslHandler.ready();\n \n-                    // There is no need to apply offloading explicitly (despite completing `processor` on the\n-                    // EventLoop) because `payloadBody()` will be offloaded according to the strategy for the\n-                    // request.\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(fromSource(processor));\n-                } else {\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(\n-                            failed(new ProxyResponseException(\"Bad response from proxy CONNECT \" + connectAddress,\n-                                    response.status())));\n-                }\n-            }));\n+                    return fromSource(processor);\n+                    // Close recently created connection in case of any error or cancellation while it connects to proxy\n+                 }).whenFinally(new TerminalSignalConsumer<C>() {\n+                    @Override\n+                    public void onSuccess(@Nullable final C result) {\n+                        // noop\n+                    }\n+\n+                    @Override\n+                    public void onError(final Throwable ignore) {\n+                        closeConnection(c);\n+                    }\n+\n+                    @Override\n+                    public void cancel() {\n+                        closeConnection(c);\n+                    }\n+                 });\n+            } catch (Exception e) {\n+                closeConnection(c);\n+                return failed(e);\n+            }\n+            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9cf373192be94190236800d625369cc6a23f5d"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3Nzg2NDg1", "url": "https://github.com/apple/servicetalk/pull/1002#pullrequestreview-387786485", "createdAt": "2020-04-05T06:44:23Z", "commit": {"oid": "8a9cf373192be94190236800d625369cc6a23f5d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3OTQ1MDg2", "url": "https://github.com/apple/servicetalk/pull/1002#pullrequestreview-387945086", "createdAt": "2020-04-06T05:39:59Z", "commit": {"oid": "8a9cf373192be94190236800d625369cc6a23f5d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNTozOTo1OVrOGBIddw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQwNTo1NjowOVrOGBIuwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0MDM3NQ==", "bodyText": "Dangling subscribes are usually a bad idea. As this code is not composing the subscribe, if the returned Single from newConnection is cancelled, we will still keep consuming the response. Worse if the response does not complete, we will keep this subscribe around forever (and so the resources associated with the subscribe).\nWhat we were doing before, i.e. composing the response draining with the Single returned from this flatMap is the correct thing to do.", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r403840375", "createdAt": "2020-04-06T05:39:59Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -74,14 +70,21 @@ private ProxyFilter(final ConnectionFactory<ResolvedAddress, C> delegate) {\n \n         @Override\n         public Single<C> newConnection(final ResolvedAddress resolvedAddress) {\n-            return delegate().newConnection(resolvedAddress).flatMap(c ->\n+            return delegate().newConnection(resolvedAddress).flatMap(c -> {\n+            try {\n                 // We currently only have access to a StreamingHttpRequester, which means we are forced to provide an\n                 // HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the connection\n                 // filters we use the default strategy which should offload everything to be safe.\n-                c.request(defaultStrategy(),\n-                            reqRespFactory.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n+                return c.request(defaultStrategy(), c.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n                  .flatMap(response -> {\n-                if (SUCCESSFUL_2XX.contains(response.status())) {\n+                    // Drain response payload body asynchronously as we are not interested in it:\n+                    response.payloadBodyAndTrailers().ignoreElements().subscribe();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9cf373192be94190236800d625369cc6a23f5d"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0MTI3NQ==", "bodyText": "Same as above, we should not be doing dangling subscribes, instead compose connection closure with error response.\nCancel path will be an exception to this rule as cancels are not composable.", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r403841275", "createdAt": "2020-04-06T05:43:19Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -100,28 +103,43 @@ public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt\n                         }\n                     });\n \n-                    DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n+                    final DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n                     if (deferSslHandler == null) {\n-                        return response.payloadBodyAndTrailers().ignoreElements().concat(failed(\n-                                new IllegalStateException(\"Failed to find a handler of type \" +\n-                                        DeferSslHandler.class + \" in channel pipeline.\")));\n+                        return failed(new IllegalStateException(\"Failed to find a handler of type \" +\n+                                DeferSslHandler.class + \" in channel pipeline.\"));\n                     }\n-\n                     deferSslHandler.ready();\n \n-                    // There is no need to apply offloading explicitly (despite completing `processor` on the\n-                    // EventLoop) because `payloadBody()` will be offloaded according to the strategy for the\n-                    // request.\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(fromSource(processor));\n-                } else {\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(\n-                            failed(new ProxyResponseException(\"Bad response from proxy CONNECT \" + connectAddress,\n-                                    response.status())));\n-                }\n-            }));\n+                    return fromSource(processor);\n+                    // Close recently created connection in case of any error or cancellation while it connects to proxy\n+                 }).whenFinally(new TerminalSignalConsumer<C>() {\n+                    @Override\n+                    public void onSuccess(@Nullable final C result) {\n+                        // noop\n+                    }\n+\n+                    @Override\n+                    public void onError(final Throwable ignore) {\n+                        closeConnection(c);\n+                    }\n+\n+                    @Override\n+                    public void cancel() {\n+                        closeConnection(c);\n+                    }\n+                 });\n+            } catch (Exception e) {\n+                closeConnection(c);\n+                return failed(e);\n+            }\n+            });\n         }\n     }\n \n+    private static <C extends FilterableStreamingHttpConnection> void closeConnection(C connection) {\n+        connection.closeAsync().subscribe();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9cf373192be94190236800d625369cc6a23f5d"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0MjE3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (Exception e) {\n          \n          \n            \n                        } catch (Throwable t) {", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r403842172", "createdAt": "2020-04-06T05:46:47Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -100,28 +103,43 @@ public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt\n                         }\n                     });\n \n-                    DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n+                    final DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n                     if (deferSslHandler == null) {\n-                        return response.payloadBodyAndTrailers().ignoreElements().concat(failed(\n-                                new IllegalStateException(\"Failed to find a handler of type \" +\n-                                        DeferSslHandler.class + \" in channel pipeline.\")));\n+                        return failed(new IllegalStateException(\"Failed to find a handler of type \" +\n+                                DeferSslHandler.class + \" in channel pipeline.\"));\n                     }\n-\n                     deferSslHandler.ready();\n \n-                    // There is no need to apply offloading explicitly (despite completing `processor` on the\n-                    // EventLoop) because `payloadBody()` will be offloaded according to the strategy for the\n-                    // request.\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(fromSource(processor));\n-                } else {\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(\n-                            failed(new ProxyResponseException(\"Bad response from proxy CONNECT \" + connectAddress,\n-                                    response.status())));\n-                }\n-            }));\n+                    return fromSource(processor);\n+                    // Close recently created connection in case of any error or cancellation while it connects to proxy\n+                 }).whenFinally(new TerminalSignalConsumer<C>() {\n+                    @Override\n+                    public void onSuccess(@Nullable final C result) {\n+                        // noop\n+                    }\n+\n+                    @Override\n+                    public void onError(final Throwable ignore) {\n+                        closeConnection(c);\n+                    }\n+\n+                    @Override\n+                    public void cancel() {\n+                        closeConnection(c);\n+                    }\n+                 });\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9cf373192be94190236800d625369cc6a23f5d"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzg0NDgwMA==", "bodyText": "It seems cancel path may leak connection in general if the connection got emitted from here but the source got cancelled afterwards. eg: any operator added after this proxy filter may not send the connection further if it sees a cancel().", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r403844800", "createdAt": "2020-04-06T05:56:09Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -100,28 +103,43 @@ public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt\n                         }\n                     });\n \n-                    DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n+                    final DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n                     if (deferSslHandler == null) {\n-                        return response.payloadBodyAndTrailers().ignoreElements().concat(failed(\n-                                new IllegalStateException(\"Failed to find a handler of type \" +\n-                                        DeferSslHandler.class + \" in channel pipeline.\")));\n+                        return failed(new IllegalStateException(\"Failed to find a handler of type \" +\n+                                DeferSslHandler.class + \" in channel pipeline.\"));\n                     }\n-\n                     deferSslHandler.ready();\n \n-                    // There is no need to apply offloading explicitly (despite completing `processor` on the\n-                    // EventLoop) because `payloadBody()` will be offloaded according to the strategy for the\n-                    // request.\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(fromSource(processor));\n-                } else {\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(\n-                            failed(new ProxyResponseException(\"Bad response from proxy CONNECT \" + connectAddress,\n-                                    response.status())));\n-                }\n-            }));\n+                    return fromSource(processor);\n+                    // Close recently created connection in case of any error or cancellation while it connects to proxy\n+                 }).whenFinally(new TerminalSignalConsumer<C>() {\n+                    @Override\n+                    public void onSuccess(@Nullable final C result) {\n+                        // noop\n+                    }\n+\n+                    @Override\n+                    public void onError(final Throwable ignore) {\n+                        closeConnection(c);\n+                    }\n+\n+                    @Override\n+                    public void cancel() {\n+                        closeConnection(c);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9cf373192be94190236800d625369cc6a23f5d"}, "originalPosition": 118}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0cd7b8ff1c1f6c96fa18b9c2f2dd3098409b9cf", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/a0cd7b8ff1c1f6c96fa18b9c2f2dd3098409b9cf", "committedDate": "2020-04-07T04:40:20Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4Nzg3MTg5", "url": "https://github.com/apple/servicetalk/pull/1002#pullrequestreview-388787189", "createdAt": "2020-04-07T05:10:19Z", "commit": {"oid": "a0cd7b8ff1c1f6c96fa18b9c2f2dd3098409b9cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNToxMDoxOVrOGBzEsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNToxMDoxOVrOGBzEsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzODU0NA==", "bodyText": "we really do not know if the cancel has come due to the operation was canceled by the user or due to some operators sending a cancel for the previous source when they move on to the next source (eg: concat()).\n\nCan any operator cancel after success? IIUC they cancel the previous source only for non-success/non-complete cases.\nLMK if I need to revert whenFinally here to prevent closure on cancel after success.", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r404538544", "createdAt": "2020-04-07T05:10:19Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -74,51 +68,63 @@ private ProxyFilter(final ConnectionFactory<ResolvedAddress, C> delegate) {\n \n         @Override\n         public Single<C> newConnection(final ResolvedAddress resolvedAddress) {\n-            return delegate().newConnection(resolvedAddress).flatMap(c ->\n-                // We currently only have access to a StreamingHttpRequester, which means we are forced to provide an\n-                // HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the connection\n-                // filters we use the default strategy which should offload everything to be safe.\n-                c.request(defaultStrategy(),\n-                            reqRespFactory.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n-                 .flatMap(response -> {\n-                if (SUCCESSFUL_2XX.contains(response.status())) {\n-                    final Channel channel = ((NettyConnectionContext) c.connectionContext()).nettyChannel();\n-                    final SingleSource.Processor<C, C> processor = newSingleProcessor();\n+            return delegate().newConnection(resolvedAddress).flatMap(c -> {\n+                try {\n+                    // We currently only have access to a StreamingHttpRequester, which means we are forced to provide\n+                    // an HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the\n+                    // connection filters we use the default strategy which should offload everything to be safe.\n+                    return c.request(defaultStrategy(), c.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n+                            .flatMap(response -> handleConnectResponse(c, response))\n+                            // Close recently created connection in case of any error while it connects to the proxy\n+                            // or cancellation:\n+                            .recoverWith(t -> c.closeAsync().concat(failed(t)))\n+                            .whenCancel(() -> c.closeAsync().subscribe());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0cd7b8ff1c1f6c96fa18b9c2f2dd3098409b9cf"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4Nzg3ODk2", "url": "https://github.com/apple/servicetalk/pull/1002#pullrequestreview-388787896", "createdAt": "2020-04-07T05:12:33Z", "commit": {"oid": "a0cd7b8ff1c1f6c96fa18b9c2f2dd3098409b9cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNToxMjozM1rOGBzG5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNToxMjozM1rOGBzG5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzOTExMA==", "bodyText": "Moved this logic to the different method because nested try blocks make code indentation awful.", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r404539110", "createdAt": "2020-04-07T05:12:33Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -74,51 +68,63 @@ private ProxyFilter(final ConnectionFactory<ResolvedAddress, C> delegate) {\n \n         @Override\n         public Single<C> newConnection(final ResolvedAddress resolvedAddress) {\n-            return delegate().newConnection(resolvedAddress).flatMap(c ->\n-                // We currently only have access to a StreamingHttpRequester, which means we are forced to provide an\n-                // HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the connection\n-                // filters we use the default strategy which should offload everything to be safe.\n-                c.request(defaultStrategy(),\n-                            reqRespFactory.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n-                 .flatMap(response -> {\n-                if (SUCCESSFUL_2XX.contains(response.status())) {\n-                    final Channel channel = ((NettyConnectionContext) c.connectionContext()).nettyChannel();\n-                    final SingleSource.Processor<C, C> processor = newSingleProcessor();\n+            return delegate().newConnection(resolvedAddress).flatMap(c -> {\n+                try {\n+                    // We currently only have access to a StreamingHttpRequester, which means we are forced to provide\n+                    // an HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the\n+                    // connection filters we use the default strategy which should offload everything to be safe.\n+                    return c.request(defaultStrategy(), c.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n+                            .flatMap(response -> handleConnectResponse(c, response))\n+                            // Close recently created connection in case of any error while it connects to the proxy\n+                            // or cancellation:\n+                            .recoverWith(t -> c.closeAsync().concat(failed(t)))\n+                            .whenCancel(() -> c.closeAsync().subscribe());\n+                } catch (Throwable t) {\n+                    return c.closeAsync().concat(failed(t));\n+                }\n+            });\n+        }\n+    }\n \n-                    channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n-                        @Override\n-                        public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt) {\n-                            if (evt instanceof SslHandshakeCompletionEvent) {\n-                                SslHandshakeCompletionEvent event = (SslHandshakeCompletionEvent) evt;\n-                                if (event.isSuccess()) {\n-                                    processor.onSuccess(c);\n-                                } else {\n-                                    processor.onError(event.cause());\n-                                }\n-                            }\n-                            ctx.fireUserEventTriggered(evt);\n-                        }\n-                    });\n+    private Single<C> handleConnectResponse(final C connection, final StreamingHttpResponse response) {\n+        try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0cd7b8ff1c1f6c96fa18b9c2f2dd3098409b9cf"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NTQ5ODEy", "url": "https://github.com/apple/servicetalk/pull/1002#pullrequestreview-389549812", "createdAt": "2020-04-07T23:05:01Z", "commit": {"oid": "a0cd7b8ff1c1f6c96fa18b9c2f2dd3098409b9cf"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMzowNTowMVrOGCZRgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMzoxMjo1N1rOGCZb3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE2NDQxNw==", "bodyText": "whenCancel will unconditionally execute the callback when cancel is called regardless if the connection has been delivered downstream. If we have already delivered the connection we shouldn't later close it (regardless if someone cancels or not). In addition to this being the expected control flow, the RS spec has some rules which discuss cancel being a no-op after a terminal signal is delivered [1][2].\nafterFinally(SingleTerminalSignalConsumer<T> doFinally) happens to enforce \"only a single callback will be executed\" but may still result in invoking the onCancel() call back and also calling the downstream Subscriber#onSuccess(...) for the following reasons:\n\nSubscription can be invoked on a different thread\nData/terminal signals may still be delivered after cancel [3]\n\nSo afterFinally is an improvement over afterCancel, but still isn't ideal because we may deliver a closed object (and/or invoke closeAsync() concurrently).\n[1] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#1.6\n\nIf a Publisher signals either onError or onComplete on a Subscriber, that Subscriber\u2019s Subscription MUST be considered cancelled.\n\n[2] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#3.7\n\nAfter the Subscription is cancelled, additional Subscription.cancel() MUST be NOPs.\n\n[3] https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#2.8\n\nA Subscriber MUST be prepared to receive one or more onNext signals after having called Subscription.cancel() if there are still requested elements pending [see 3.12]. Subscription.cancel() does not guarantee to perform the underlying cleaning operations immediately.", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r405164417", "createdAt": "2020-04-07T23:05:01Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -74,51 +68,63 @@ private ProxyFilter(final ConnectionFactory<ResolvedAddress, C> delegate) {\n \n         @Override\n         public Single<C> newConnection(final ResolvedAddress resolvedAddress) {\n-            return delegate().newConnection(resolvedAddress).flatMap(c ->\n-                // We currently only have access to a StreamingHttpRequester, which means we are forced to provide an\n-                // HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the connection\n-                // filters we use the default strategy which should offload everything to be safe.\n-                c.request(defaultStrategy(),\n-                            reqRespFactory.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n-                 .flatMap(response -> {\n-                if (SUCCESSFUL_2XX.contains(response.status())) {\n-                    final Channel channel = ((NettyConnectionContext) c.connectionContext()).nettyChannel();\n-                    final SingleSource.Processor<C, C> processor = newSingleProcessor();\n+            return delegate().newConnection(resolvedAddress).flatMap(c -> {\n+                try {\n+                    // We currently only have access to a StreamingHttpRequester, which means we are forced to provide\n+                    // an HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the\n+                    // connection filters we use the default strategy which should offload everything to be safe.\n+                    return c.request(defaultStrategy(), c.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n+                            .flatMap(response -> handleConnectResponse(c, response))\n+                            // Close recently created connection in case of any error while it connects to the proxy\n+                            // or cancellation:\n+                            .recoverWith(t -> c.closeAsync().concat(failed(t)))\n+                            .whenCancel(() -> c.closeAsync().subscribe());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUzODU0NA=="}, "originalCommit": {"oid": "a0cd7b8ff1c1f6c96fa18b9c2f2dd3098409b9cf"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE2NzA3MQ==", "bodyText": "this could lead to unnecessary resource (CPU, memory, network, etc...) consumption if we continuously read data that we don't care about (potential DOS vector). Can you clarify why this is necessary when we are hard-closing the connection?", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r405167071", "createdAt": "2020-04-07T23:12:57Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -74,51 +68,63 @@ private ProxyFilter(final ConnectionFactory<ResolvedAddress, C> delegate) {\n \n         @Override\n         public Single<C> newConnection(final ResolvedAddress resolvedAddress) {\n-            return delegate().newConnection(resolvedAddress).flatMap(c ->\n-                // We currently only have access to a StreamingHttpRequester, which means we are forced to provide an\n-                // HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the connection\n-                // filters we use the default strategy which should offload everything to be safe.\n-                c.request(defaultStrategy(),\n-                            reqRespFactory.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n-                 .flatMap(response -> {\n-                if (SUCCESSFUL_2XX.contains(response.status())) {\n-                    final Channel channel = ((NettyConnectionContext) c.connectionContext()).nettyChannel();\n-                    final SingleSource.Processor<C, C> processor = newSingleProcessor();\n+            return delegate().newConnection(resolvedAddress).flatMap(c -> {\n+                try {\n+                    // We currently only have access to a StreamingHttpRequester, which means we are forced to provide\n+                    // an HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the\n+                    // connection filters we use the default strategy which should offload everything to be safe.\n+                    return c.request(defaultStrategy(), c.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n+                            .flatMap(response -> handleConnectResponse(c, response))\n+                            // Close recently created connection in case of any error while it connects to the proxy\n+                            // or cancellation:\n+                            .recoverWith(t -> c.closeAsync().concat(failed(t)))\n+                            .whenCancel(() -> c.closeAsync().subscribe());\n+                } catch (Throwable t) {\n+                    return c.closeAsync().concat(failed(t));\n+                }\n+            });\n+        }\n+    }\n \n-                    channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n-                        @Override\n-                        public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt) {\n-                            if (evt instanceof SslHandshakeCompletionEvent) {\n-                                SslHandshakeCompletionEvent event = (SslHandshakeCompletionEvent) evt;\n-                                if (event.isSuccess()) {\n-                                    processor.onSuccess(c);\n-                                } else {\n-                                    processor.onError(event.cause());\n-                                }\n-                            }\n-                            ctx.fireUserEventTriggered(evt);\n-                        }\n-                    });\n+    private Single<C> handleConnectResponse(final C connection, final StreamingHttpResponse response) {\n+        try {\n+            if (response.status().statusClass() != SUCCESSFUL_2XX) {\n+                return response.payloadBodyAndTrailers().ignoreElements().concat(failed(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0cd7b8ff1c1f6c96fa18b9c2f2dd3098409b9cf"}, "originalPosition": 91}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "685900e9234a7a2848425896b62e9ce90565f30a", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/685900e9234a7a2848425896b62e9ce90565f30a", "committedDate": "2020-04-07T23:37:17Z", "message": "Merge remote-tracking branch 'upstream/master' into proxy-close-connection"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2bf22f6b3dd9d9f8a82a7193fd159b4ca069d50", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/d2bf22f6b3dd9d9f8a82a7193fd159b4ca069d50", "committedDate": "2020-04-07T23:50:13Z", "message": "Use whenFinally to prevent handling cancel event after termination"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "083347de4ffd0e52bef4a5c573008827a67cc07e", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/083347de4ffd0e52bef4a5c573008827a67cc07e", "committedDate": "2020-04-07T23:50:37Z", "message": "Do not drain payload body in case of error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfd01174f02340fc92b0adb892e2d98e0e7d778f", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/cfd01174f02340fc92b0adb892e2d98e0e7d778f", "committedDate": "2020-04-08T00:07:53Z", "message": "Change whenFinally to afterFinally"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57e470b5307862d543c41e8274b3fc5ee634cfa7", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/57e470b5307862d543c41e8274b3fc5ee634cfa7", "committedDate": "2020-04-08T20:48:18Z", "message": "Remove close-on-cancel"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMzg1NTA2", "url": "https://github.com/apple/servicetalk/pull/1002#pullrequestreview-390385506", "createdAt": "2020-04-08T22:54:36Z", "commit": {"oid": "57e470b5307862d543c41e8274b3fc5ee634cfa7"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQyMjo1NDozNlrOGDDxUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQyMjo1NzoxNFrOGDD0-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2MDY5MA==", "bodyText": "This try-catch isn't required as it is called from the flatMap which has a recoverWith, so if anything does throw from here, flatMap will correctly terminate the control flow with the same error which will then be intercepted by recoverWith() closing the connection.", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r405860690", "createdAt": "2020-04-08T22:54:36Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -74,51 +68,59 @@ private ProxyFilter(final ConnectionFactory<ResolvedAddress, C> delegate) {\n \n         @Override\n         public Single<C> newConnection(final ResolvedAddress resolvedAddress) {\n-            return delegate().newConnection(resolvedAddress).flatMap(c ->\n-                // We currently only have access to a StreamingHttpRequester, which means we are forced to provide an\n-                // HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the connection\n-                // filters we use the default strategy which should offload everything to be safe.\n-                c.request(defaultStrategy(),\n-                            reqRespFactory.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n-                 .flatMap(response -> {\n-                if (SUCCESSFUL_2XX.contains(response.status())) {\n-                    final Channel channel = ((NettyConnectionContext) c.connectionContext()).nettyChannel();\n-                    final SingleSource.Processor<C, C> processor = newSingleProcessor();\n+            return delegate().newConnection(resolvedAddress).flatMap(c -> {\n+                try {\n+                    // We currently only have access to a StreamingHttpRequester, which means we are forced to provide\n+                    // an HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the\n+                    // connection filters we use the default strategy which should offload everything to be safe.\n+                    return c.request(defaultStrategy(), c.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n+                            .flatMap(response -> handleConnectResponse(c, response))\n+                            // Close recently created connection in case of any error while it connects to the proxy:\n+                            .recoverWith(t -> c.closeAsync().concat(failed(t)));\n+                } catch (Throwable t) {\n+                    return c.closeAsync().concat(failed(t));\n+                }\n+            });\n+        }\n+    }\n \n-                    channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n-                        @Override\n-                        public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt) {\n-                            if (evt instanceof SslHandshakeCompletionEvent) {\n-                                SslHandshakeCompletionEvent event = (SslHandshakeCompletionEvent) evt;\n-                                if (event.isSuccess()) {\n-                                    processor.onSuccess(c);\n-                                } else {\n-                                    processor.onError(event.cause());\n-                                }\n-                            }\n-                            ctx.fireUserEventTriggered(evt);\n-                        }\n-                    });\n+    private Single<C> handleConnectResponse(final C connection, final StreamingHttpResponse response) {\n+        try {\n+            if (response.status().statusClass() != SUCCESSFUL_2XX) {\n+                return failed(new ProxyResponseException(\"Non-successful response from proxy CONNECT \" +\n+                        connectAddress, response.status()));\n+            }\n \n-                    DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n-                    if (deferSslHandler == null) {\n-                        return response.payloadBodyAndTrailers().ignoreElements().concat(failed(\n-                                new IllegalStateException(\"Failed to find a handler of type \" +\n-                                        DeferSslHandler.class + \" in channel pipeline.\")));\n+            final Channel channel = ((NettyConnectionContext) connection.connectionContext()).nettyChannel();\n+            final SingleSource.Processor<C, C> processor = newSingleProcessor();\n+            channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n+                @Override\n+                public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt) {\n+                    if (evt instanceof SslHandshakeCompletionEvent) {\n+                        SslHandshakeCompletionEvent event = (SslHandshakeCompletionEvent) evt;\n+                        if (event.isSuccess()) {\n+                            processor.onSuccess(connection);\n+                        } else {\n+                            processor.onError(event.cause());\n+                        }\n                     }\n+                    ctx.fireUserEventTriggered(evt);\n+                }\n+            });\n \n-                    deferSslHandler.ready();\n+            final DeferSslHandler deferSslHandler = channel.pipeline().get(DeferSslHandler.class);\n+            if (deferSslHandler == null) {\n+                return failed(new IllegalStateException(\"Failed to find a handler of type \" +\n+                        DeferSslHandler.class + \" in channel pipeline.\"));\n+            }\n+            deferSslHandler.ready();\n \n-                    // There is no need to apply offloading explicitly (despite completing `processor` on the\n-                    // EventLoop) because `payloadBody()` will be offloaded according to the strategy for the\n-                    // request.\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(fromSource(processor));\n-                } else {\n-                    return response.payloadBodyAndTrailers().ignoreElements().concat(\n-                            failed(new ProxyResponseException(\"Bad response from proxy CONNECT \" + connectAddress,\n-                                    response.status())));\n-                }\n-            }));\n+            // There is no need to apply offloading explicitly (despite completing `processor` on the\n+            // EventLoop) because `payloadBody()` will be offloaded according to the strategy for the\n+            // request.\n+            return response.payloadBodyAndTrailers().ignoreElements().concat(fromSource(processor));\n+        } catch (Throwable t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57e470b5307862d543c41e8274b3fc5ee634cfa7"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2MTYyNg==", "bodyText": "I think we are being overly paranoid here about the calls to c.request() or c.connect() throwing. Any method returning an asynchronous source is not expected to throw. Having said that it is not a big deal so its ok as it is, I will leave it to you to take a call on this.", "url": "https://github.com/apple/servicetalk/pull/1002#discussion_r405861626", "createdAt": "2020-04-08T22:57:14Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/ProxyConnectConnectionFactoryFilter.java", "diffHunk": "@@ -74,51 +68,59 @@ private ProxyFilter(final ConnectionFactory<ResolvedAddress, C> delegate) {\n \n         @Override\n         public Single<C> newConnection(final ResolvedAddress resolvedAddress) {\n-            return delegate().newConnection(resolvedAddress).flatMap(c ->\n-                // We currently only have access to a StreamingHttpRequester, which means we are forced to provide an\n-                // HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the connection\n-                // filters we use the default strategy which should offload everything to be safe.\n-                c.request(defaultStrategy(),\n-                            reqRespFactory.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n-                 .flatMap(response -> {\n-                if (SUCCESSFUL_2XX.contains(response.status())) {\n-                    final Channel channel = ((NettyConnectionContext) c.connectionContext()).nettyChannel();\n-                    final SingleSource.Processor<C, C> processor = newSingleProcessor();\n+            return delegate().newConnection(resolvedAddress).flatMap(c -> {\n+                try {\n+                    // We currently only have access to a StreamingHttpRequester, which means we are forced to provide\n+                    // an HttpExecutionStrategy. Because we can't be sure if there is any blocking code in the\n+                    // connection filters we use the default strategy which should offload everything to be safe.\n+                    return c.request(defaultStrategy(), c.connect(connectAddress).addHeader(CONTENT_LENGTH, ZERO))\n+                            .flatMap(response -> handleConnectResponse(c, response))\n+                            // Close recently created connection in case of any error while it connects to the proxy:\n+                            .recoverWith(t -> c.closeAsync().concat(failed(t)));\n+                } catch (Throwable t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57e470b5307862d543c41e8274b3fc5ee634cfa7"}, "originalPosition": 65}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0144018d9bed65c5d358f725665005545255893e", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/0144018d9bed65c5d358f725665005545255893e", "committedDate": "2020-04-08T23:09:05Z", "message": "Remove unnecessary try-catch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12cbd4c2998bc5590fff03591c919454e4ac3905", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/12cbd4c2998bc5590fff03591c919454e4ac3905", "committedDate": "2020-04-08T23:14:45Z", "message": "Move handleConnectResponse inside ProxyFilter"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3589, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}