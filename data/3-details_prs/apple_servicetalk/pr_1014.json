{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzMzkzNjUz", "number": 1014, "title": "Publisher#flatMapMergeSingle potential queue drain visibility issue", "bodyText": "Motivation:\nPublisher#flatMapMergeSingle uses the\nConcurrentUtils#drainSingleConsumerQueue to drain the pending signal\nqueue. However this method relies upon the queue's isEmpty() method\nproviding visibility as to if an item has been inserted into the queue\nsince the last poll information. We should avoid leveraging the queue's\nvisibility guarantees (which may not hold) and instead leverage the\nconcurrency avoidance for single consumer drain to provide visibility.\nModifications:\n\nRemove ConcurrentUtils#drainSingleConsumerQueue\nIntroduce ConcurrentUtils#acquirePendingLock and releasePendingLock\nmethods that allow for notification if another thread attempted to\nacquire the lock while it was being held. If all threads that publish\nand event (e.g. insert into a queue) use this lock it can ensure no\nconcurrency and visibility.\n\nResult:\nNo dependency on queue visibility semantics for draining the signal\nqueue in Publisher#flatMapMergeSingle.", "createdAt": "2020-04-14T20:19:04Z", "url": "https://github.com/apple/servicetalk/pull/1014", "merged": true, "mergeCommit": {"oid": "d897beb5a3c3bda62384449e71bb2ad08f010036"}, "closed": true, "closedAt": "2020-05-04T22:45:21Z", "author": {"login": "Scottmitch"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcXpf-_gFqTM5MzI2OTc2MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABceE4PyAFqTQwNTI5MzE2Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMjY5NzYw", "url": "https://github.com/apple/servicetalk/pull/1014#pullrequestreview-393269760", "createdAt": "2020-04-14T20:27:12Z", "commit": {"oid": "e9dfa3d2b655dc4d7d1201fda62526237960d5c7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDoyNzoxMlrOGFfn4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDoyNzoxMlrOGFfn4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNDE3OQ==", "bodyText": "shouldn't we release in a finally block ?", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r408414179", "createdAt": "2020-04-14T20:27:12Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java", "diffHunk": "@@ -222,23 +223,31 @@ private void enqueueAndDrain(Object item) {\n             assert s != null;\n \n             if (!pending.offer(item)) {\n-                QueueFullException exception = new QueueFullException(\"pending\");\n-                if (item instanceof TerminalNotification) {\n-                    LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n-                    throw exception;\n-                } else {\n-                    onError0(exception, true, true);\n-                }\n+                enqueueAndDrainFail(item);\n             }\n             drainPending(s);\n         }\n \n         private void drainPending(Subscription subscription) {\n-            long drainedCount = drainSingleConsumerQueue(pending, this::sendToTarget, emittingUpdater, this);\n-            if (drainedCount != 0) {\n+            long drainCount = 0;\n+            for (;;) {\n+                if (!acquirePendingLock(emittingUpdater, this)) {\n+                    break;\n+                }\n+                Object t;\n+                while ((t = pending.poll()) != null) {\n+                    ++drainCount;\n+                    sendToTarget(t);\n+                }\n+                if (releasePendingLock(emittingUpdater, this)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9dfa3d2b655dc4d7d1201fda62526237960d5c7"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzNjIwNzI2", "url": "https://github.com/apple/servicetalk/pull/1014#pullrequestreview-393620726", "createdAt": "2020-04-15T09:48:02Z", "commit": {"oid": "8a525a8eae60877e0a37fa66f020c67588e0fbe7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTo0ODowMlrOGFyIgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTo0ODowMlrOGFyIgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxNzQ0MA==", "bodyText": "nit: should we use addSuppressed(...) when delayedCause != null", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r408717440", "createdAt": "2020-04-15T09:48:02Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java", "diffHunk": "@@ -222,29 +224,58 @@ private void enqueueAndDrain(Object item) {\n             assert s != null;\n \n             if (!pending.offer(item)) {\n-                QueueFullException exception = new QueueFullException(\"pending\");\n-                if (item instanceof TerminalNotification) {\n-                    LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n-                    throw exception;\n-                } else {\n-                    onError0(exception, true, true);\n-                }\n+                enqueueAndDrainFail(item);\n             }\n             drainPending(s);\n         }\n \n         private void drainPending(Subscription subscription) {\n-            long drainedCount = drainSingleConsumerQueue(pending, this::sendToTarget, emittingUpdater, this);\n-            if (drainedCount != 0) {\n+            long drainCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        ++drainCount;\n+                        try {\n+                            sendToTarget(t);\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a525a8eae60877e0a37fa66f020c67588e0fbe7"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1MzY4OTA0", "url": "https://github.com/apple/servicetalk/pull/1014#pullrequestreview-395368904", "createdAt": "2020-04-17T11:17:22Z", "commit": {"oid": "da043d3580ecb4737eef739b272693358f074539"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMToxNzoyMlrOGHKBmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMToxODoxOVrOGHKDLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE1NzQ2NQ==", "bodyText": "Just wondering why the others need to be public and this can be private ...", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r410157465", "createdAt": "2020-04-17T11:17:22Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "diffHunk": "@@ -31,47 +31,44 @@\n \n     public static final int CONCURRENT_IDLE = 0;\n     public static final int CONCURRENT_EMITTING = 1;\n+    private static final int CONCURRENT_PENDING = 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da043d3580ecb4737eef739b272693358f074539"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE1Nzg2OQ==", "bodyText": "nit: ...DrainFailed ?", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r410157869", "createdAt": "2020-04-17T11:18:19Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java", "diffHunk": "@@ -222,29 +231,62 @@ private void enqueueAndDrain(Object item) {\n             assert s != null;\n \n             if (!pending.offer(item)) {\n-                QueueFullException exception = new QueueFullException(\"pending\");\n-                if (item instanceof TerminalNotification) {\n-                    LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n-                    throw exception;\n-                } else {\n-                    onError0(exception, true, true);\n-                }\n+                enqueueAndDrainFail(item);\n             }\n             drainPending(s);\n         }\n \n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n         private void drainPending(Subscription subscription) {\n-            long drainedCount = drainSingleConsumerQueue(pending, this::sendToTarget, emittingUpdater, this);\n-            if (drainedCount != 0) {\n+            long drainCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        ++drainCount;\n+                        try {\n+                            sendToTarget(t);\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;\n+                            }\n+                        }\n+                    }\n+                } finally {\n+                    if (releasePendingLock(emittingUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (drainCount != 0) {\n                 // We ignore overflow here because once we get to this extreme, we won't be able to account for more\n                 // data anyways.\n-                sourceEmittedUpdater.addAndGet(this, drainedCount);\n+                sourceEmittedUpdater.addAndGet(this, drainCount);\n                 int actualSourceRequestN = calculateSourceRequested(requestedUpdater, sourceRequestedUpdater,\n                         sourceEmittedUpdater, source.maxConcurrency, this);\n                 if (actualSourceRequestN != 0) {\n                     subscription.request(actualSourceRequestN);\n                 }\n             }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da043d3580ecb4737eef739b272693358f074539"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MjU0NDAx", "url": "https://github.com/apple/servicetalk/pull/1014#pullrequestreview-397254401", "createdAt": "2020-04-21T11:53:15Z", "commit": {"oid": "a4eda8c2b2c26a2235f8c06c1b5784dc0ae6d251"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a4eda8c2b2c26a2235f8c06c1b5784dc0ae6d251", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/a4eda8c2b2c26a2235f8c06c1b5784dc0ae6d251", "committedDate": "2020-04-17T17:05:53Z", "message": "enqueueAndDrainFail -> enqueueAndDrainFailed"}, "afterCommit": {"oid": "b65d07d1426d1378179889947ab2d439ceb6d8b9", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/b65d07d1426d1378179889947ab2d439ceb6d8b9", "committedDate": "2020-04-27T22:59:07Z", "message": "Publisher#flatMapMergeSingle potential queue drain visibility issue\n\nMotivation:\nPublisher#flatMapMergeSingle uses the\nConcurrentUtils#drainSingleConsumerQueue to drain the pending signal\nqueue. However this method relies upon the queue's isEmpty() method\nproviding visibility as to if an item has been inserted into the queue\nsince the last poll information. We should avoid leveraging the queue's\nvisibility guarantees (which may not hold) and instead leverage the\nconcurrency avoidance for single consumer drain to provide visibility.\n\nModifications:\n- Remove ConcurrentUtils#drainSingleConsumerQueue\n- Introduce ConcurrentUtils#acquirePendingLock and releasePendingLock\nmethods that allow for notification if another thread attempted to\nacquire the lock while it was being held. If all threads that publish\nand event (e.g. insert into a queue) use this lock it can ensure no\nconcurrency and visibility.\n\nResult:\nNo dependency on queue visibility semantics for draining the signal\nqueue in Publisher#flatMapMergeSingle."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b65d07d1426d1378179889947ab2d439ceb6d8b9", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/b65d07d1426d1378179889947ab2d439ceb6d8b9", "committedDate": "2020-04-27T22:59:07Z", "message": "Publisher#flatMapMergeSingle potential queue drain visibility issue\n\nMotivation:\nPublisher#flatMapMergeSingle uses the\nConcurrentUtils#drainSingleConsumerQueue to drain the pending signal\nqueue. However this method relies upon the queue's isEmpty() method\nproviding visibility as to if an item has been inserted into the queue\nsince the last poll information. We should avoid leveraging the queue's\nvisibility guarantees (which may not hold) and instead leverage the\nconcurrency avoidance for single consumer drain to provide visibility.\n\nModifications:\n- Remove ConcurrentUtils#drainSingleConsumerQueue\n- Introduce ConcurrentUtils#acquirePendingLock and releasePendingLock\nmethods that allow for notification if another thread attempted to\nacquire the lock while it was being held. If all threads that publish\nand event (e.g. insert into a queue) use this lock it can ensure no\nconcurrency and visibility.\n\nResult:\nNo dependency on queue visibility semantics for draining the signal\nqueue in Publisher#flatMapMergeSingle."}, "afterCommit": {"oid": "3b79e1bfe466f985ba3a373126af2a413df0f66c", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/3b79e1bfe466f985ba3a373126af2a413df0f66c", "committedDate": "2020-04-28T04:01:28Z", "message": "Publisher#flatMapMergeSingle potential queue drain visibility issue\n\nMotivation:\nPublisher#flatMapMergeSingle uses the\nConcurrentUtils#drainSingleConsumerQueue to drain the pending signal\nqueue. However this method relies upon the queue's isEmpty() method\nproviding visibility as to if an item has been inserted into the queue\nsince the last poll information. We should avoid leveraging the queue's\nvisibility guarantees (which may not hold) and instead leverage the\nconcurrency avoidance for single consumer drain to provide visibility.\n\nModifications:\n- Remove ConcurrentUtils#drainSingleConsumerQueue\n- Introduce ConcurrentUtils#acquirePendingLock and releasePendingLock\nmethods that allow for notification if another thread attempted to\nacquire the lock while it was being held. If all threads that publish\nand event (e.g. insert into a queue) use this lock it can ensure no\nconcurrency and visibility.\n\nResult:\nNo dependency on queue visibility semantics for draining the signal\nqueue in Publisher#flatMapMergeSingle."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3b79e1bfe466f985ba3a373126af2a413df0f66c", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/3b79e1bfe466f985ba3a373126af2a413df0f66c", "committedDate": "2020-04-28T04:01:28Z", "message": "Publisher#flatMapMergeSingle potential queue drain visibility issue\n\nMotivation:\nPublisher#flatMapMergeSingle uses the\nConcurrentUtils#drainSingleConsumerQueue to drain the pending signal\nqueue. However this method relies upon the queue's isEmpty() method\nproviding visibility as to if an item has been inserted into the queue\nsince the last poll information. We should avoid leveraging the queue's\nvisibility guarantees (which may not hold) and instead leverage the\nconcurrency avoidance for single consumer drain to provide visibility.\n\nModifications:\n- Remove ConcurrentUtils#drainSingleConsumerQueue\n- Introduce ConcurrentUtils#acquirePendingLock and releasePendingLock\nmethods that allow for notification if another thread attempted to\nacquire the lock while it was being held. If all threads that publish\nand event (e.g. insert into a queue) use this lock it can ensure no\nconcurrency and visibility.\n\nResult:\nNo dependency on queue visibility semantics for draining the signal\nqueue in Publisher#flatMapMergeSingle."}, "afterCommit": {"oid": "cc5dd371da29fd90fd333d6604bd9a4bcd7bc0ff", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/cc5dd371da29fd90fd333d6604bd9a4bcd7bc0ff", "committedDate": "2020-04-28T04:02:23Z", "message": "Publisher#flatMapMergeSingle potential queue drain visibility issue\n\nMotivation:\nPublisher#flatMapMergeSingle uses the\nConcurrentUtils#drainSingleConsumerQueue to drain the pending signal\nqueue. However this method relies upon the queue's isEmpty() method\nproviding visibility as to if an item has been inserted into the queue\nsince the last poll information. We should avoid leveraging the queue's\nvisibility guarantees (which may not hold) and instead leverage the\nconcurrency avoidance for single consumer drain to provide visibility.\n\nModifications:\n- Remove ConcurrentUtils#drainSingleConsumerQueue\n- Introduce ConcurrentUtils#acquirePendingLock and releasePendingLock\nmethods that allow for notification if another thread attempted to\nacquire the lock while it was being held. If all threads that publish\nand event (e.g. insert into a queue) use this lock it can ensure no\nconcurrency and visibility.\n\nResult:\nNo dependency on queue visibility semantics for draining the signal\nqueue in Publisher#flatMapMergeSingle."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "550413afb290968388de8599cd729a248024a68b", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/550413afb290968388de8599cd729a248024a68b", "committedDate": "2020-05-01T01:16:52Z", "message": "Publisher#flatMapMergeSingle potential queue drain visibility issue\n\nMotivation:\nPublisher#flatMapMergeSingle uses the\nConcurrentUtils#drainSingleConsumerQueue to drain the pending signal\nqueue. However this method relies upon the queue's isEmpty() method\nproviding visibility as to if an item has been inserted into the queue\nsince the last poll information. We should avoid leveraging the queue's\nvisibility guarantees (which may not hold) and instead leverage the\nconcurrency avoidance for single consumer drain to provide visibility.\n\nModifications:\n- Remove ConcurrentUtils#drainSingleConsumerQueue\n- Introduce ConcurrentUtils#acquirePendingLock and releasePendingLock\nmethods that allow for notification if another thread attempted to\nacquire the lock while it was being held. If all threads that publish\nand event (e.g. insert into a queue) use this lock it can ensure no\nconcurrency and visibility.\n\nResult:\nNo dependency on queue visibility semantics for draining the signal\nqueue in Publisher#flatMapMergeSingle."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cc5dd371da29fd90fd333d6604bd9a4bcd7bc0ff", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/cc5dd371da29fd90fd333d6604bd9a4bcd7bc0ff", "committedDate": "2020-04-28T04:02:23Z", "message": "Publisher#flatMapMergeSingle potential queue drain visibility issue\n\nMotivation:\nPublisher#flatMapMergeSingle uses the\nConcurrentUtils#drainSingleConsumerQueue to drain the pending signal\nqueue. However this method relies upon the queue's isEmpty() method\nproviding visibility as to if an item has been inserted into the queue\nsince the last poll information. We should avoid leveraging the queue's\nvisibility guarantees (which may not hold) and instead leverage the\nconcurrency avoidance for single consumer drain to provide visibility.\n\nModifications:\n- Remove ConcurrentUtils#drainSingleConsumerQueue\n- Introduce ConcurrentUtils#acquirePendingLock and releasePendingLock\nmethods that allow for notification if another thread attempted to\nacquire the lock while it was being held. If all threads that publish\nand event (e.g. insert into a queue) use this lock it can ensure no\nconcurrency and visibility.\n\nResult:\nNo dependency on queue visibility semantics for draining the signal\nqueue in Publisher#flatMapMergeSingle."}, "afterCommit": {"oid": "550413afb290968388de8599cd729a248024a68b", "author": {"user": {"login": "Scottmitch", "name": "Scott Mitchell"}}, "url": "https://github.com/apple/servicetalk/commit/550413afb290968388de8599cd729a248024a68b", "committedDate": "2020-05-01T01:16:52Z", "message": "Publisher#flatMapMergeSingle potential queue drain visibility issue\n\nMotivation:\nPublisher#flatMapMergeSingle uses the\nConcurrentUtils#drainSingleConsumerQueue to drain the pending signal\nqueue. However this method relies upon the queue's isEmpty() method\nproviding visibility as to if an item has been inserted into the queue\nsince the last poll information. We should avoid leveraging the queue's\nvisibility guarantees (which may not hold) and instead leverage the\nconcurrency avoidance for single consumer drain to provide visibility.\n\nModifications:\n- Remove ConcurrentUtils#drainSingleConsumerQueue\n- Introduce ConcurrentUtils#acquirePendingLock and releasePendingLock\nmethods that allow for notification if another thread attempted to\nacquire the lock while it was being held. If all threads that publish\nand event (e.g. insert into a queue) use this lock it can ensure no\nconcurrency and visibility.\n\nResult:\nNo dependency on queue visibility semantics for draining the signal\nqueue in Publisher#flatMapMergeSingle."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MjkzMTYy", "url": "https://github.com/apple/servicetalk/pull/1014#pullrequestreview-405293162", "createdAt": "2020-05-04T19:44:52Z", "commit": {"oid": "550413afb290968388de8599cd729a248024a68b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3618, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}