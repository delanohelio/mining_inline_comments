{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2NzY1MjA4", "number": 942, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMjo0NTo0OVrODg4W2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMzo1MjozMFrODg5RdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1ODA0Mzc3OnYy", "diffSide": "RIGHT", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/AbstractH2DuplexHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMjo0NTo0OVrOFrVOww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjo1OTo0NVrOFsmJWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk4MDkzMQ==", "bodyText": "You can simplify control-flow as:\nfinal void readDataFrame(ChannelHandlerContext ctx, Http2DataFrame dataFrame) {\n    try {\n        if (dataFrame.content().isReadable()) {\n            // Copy to unpooled heap memory before passing to the user\n            Buffer data = allocator.newBuffer(dataFrame.content().readableBytes(), false);\n            ByteBuf nettyData = toByteBuf(data);\n            nettyData.writeBytes(dataFrame.content());\n            ctx.fireChannelRead(data);\n        }\n        if (dataFrame.isEndStream()) {\n            ctx.fireChannelRead(headersFactory.newEmptyTrailers());\n        }\n    } finally {\n        dataFrame.release();\n    }\n}", "url": "https://github.com/apple/servicetalk/pull/942#discussion_r380980931", "createdAt": "2020-02-18T22:45:49Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/AbstractH2DuplexHandler.java", "diffHunk": "@@ -85,14 +96,32 @@ final void writeTrailers(ChannelHandlerContext ctx, Object msg, ChannelPromise p\n     }\n \n     final void readDataFrame(ChannelHandlerContext ctx, Object msg) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da0faa625c24263258f639d896851beac833e859"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzMjIxNg==", "bodyText": "The intend here was to release the original ByteBuf asap, before firing channel read and future payload processing.", "url": "https://github.com/apple/servicetalk/pull/942#discussion_r382232216", "createdAt": "2020-02-20T20:11:56Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/AbstractH2DuplexHandler.java", "diffHunk": "@@ -85,14 +96,32 @@ final void writeTrailers(ChannelHandlerContext ctx, Object msg, ChannelPromise p\n     }\n \n     final void readDataFrame(ChannelHandlerContext ctx, Object msg) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk4MDkzMQ=="}, "originalCommit": {"oid": "da0faa625c24263258f639d896851beac833e859"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwNjY1MA==", "bodyText": "aah ok, makes sense.", "url": "https://github.com/apple/servicetalk/pull/942#discussion_r382306650", "createdAt": "2020-02-20T22:59:45Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/AbstractH2DuplexHandler.java", "diffHunk": "@@ -85,14 +96,32 @@ final void writeTrailers(ChannelHandlerContext ctx, Object msg, ChannelPromise p\n     }\n \n     final void readDataFrame(ChannelHandlerContext ctx, Object msg) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk4MDkzMQ=="}, "originalCommit": {"oid": "da0faa625c24263258f639d896851beac833e859"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1ODA0NTYzOnYy", "diffSide": "RIGHT", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/AbstractH2DuplexHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMjo0NjozNVrOFrVP9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMjo0NjozNVrOFrVP9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk4MTIzNg==", "bodyText": "This is not used.", "url": "https://github.com/apple/servicetalk/pull/942#discussion_r380981236", "createdAt": "2020-02-18T22:46:35Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/AbstractH2DuplexHandler.java", "diffHunk": "@@ -31,18 +32,28 @@\n import io.netty.handler.codec.http2.Http2DataFrame;\n import io.netty.handler.codec.http2.Http2Headers;\n import io.netty.handler.codec.http2.Http2ResetFrame;\n+import io.netty.util.ReferenceCountUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n \n import static io.netty.buffer.Unpooled.EMPTY_BUFFER;\n import static io.netty.handler.codec.http2.Http2Error.REFUSED_STREAM;\n-import static io.servicetalk.buffer.netty.BufferUtils.newBufferFrom;\n+import static io.servicetalk.buffer.netty.BufferUtils.toByteBuf;\n import static io.servicetalk.buffer.netty.BufferUtils.toByteBufNoThrow;\n import static io.servicetalk.http.netty.H2ToStH1Utils.h1HeadersToH2Headers;\n \n abstract class AbstractH2DuplexHandler extends ChannelDuplexHandler {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractH2DuplexHandler.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da0faa625c24263258f639d896851beac833e859"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1ODA2OTQyOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/ByteToMessageDecoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMjo1NDo0OFrOFrVd-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMjo1NDo0OFrOFrVd-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk4NDgyNA==", "bodyText": "nit: rename to cumulationAllocator to clarify intent.", "url": "https://github.com/apple/servicetalk/pull/942#discussion_r380984824", "createdAt": "2020-02-18T22:54:48Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/ByteToMessageDecoder.java", "diffHunk": "@@ -105,10 +105,19 @@\n      */\n     private byte decodeState = STATE_INIT;\n \n+    private final ByteBufAllocator alloc;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da0faa625c24263258f639d896851beac833e859"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1ODEwMDc0OnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CopyByteBufHandlerChannelInitializer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMzowNzoxMVrOFrVwtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjo0MToyMVrOFsls_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk4OTYyMA==", "bodyText": "We should also check for ByteBufHolder objects here, H2 frames may be buffer holders.", "url": "https://github.com/apple/servicetalk/pull/942#discussion_r380989620", "createdAt": "2020-02-18T23:07:11Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CopyByteBufHandlerChannelInitializer.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright \u00a9 2019-2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandler;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * Initializer to configure {@link ChannelInboundHandler} that will ensure no pooled {@link ByteBuf}s are passed to\n+ * the user and so no leaks are produced if the user does not call {@link ReferenceCountUtil#release(Object)}.\n+ */\n+public final class CopyByteBufHandlerChannelInitializer implements ChannelInitializer {\n+\n+    /**\n+     * {@link PooledByteBufAllocator} to use internally when we know memory won't be leaked.\n+     */\n+    public static final PooledByteBufAllocator POOLED_ALLOCATOR = PooledByteBufAllocator.DEFAULT;\n+\n+    private final CopyByteBufHandler copyHandler;\n+\n+    /**\n+     * Creates a new instance.\n+     *\n+     * @param alloc {@link ByteBufAllocator} to allocate unpooled memory.\n+     */\n+    public CopyByteBufHandlerChannelInitializer(final ByteBufAllocator alloc) {\n+        copyHandler = new CopyByteBufHandler(alloc);\n+    }\n+\n+    @Override\n+    public void init(final Channel channel) {\n+        channel.pipeline().addLast(copyHandler);\n+    }\n+\n+    /**\n+     * This handler has to be added to the {@link ChannelPipeline} when {@link PooledByteBufAllocator} is used for\n+     * reading data from the socket. The allocated {@link ByteBuf}s must be copied and released before handed over to\n+     * the user.\n+     */\n+    @Sharable\n+    private static final class CopyByteBufHandler extends SimpleChannelInboundHandler<ByteBuf> {\n+\n+        private final ByteBufAllocator alloc;\n+\n+        private CopyByteBufHandler(final ByteBufAllocator alloc) {\n+            if (alloc.isDirectBufferPooled()) {\n+                throw new IllegalArgumentException(\"ByteBufAllocator must be unpooled\");\n+            }\n+            this.alloc = alloc;\n+        }\n+\n+        @Override\n+        protected void channelRead0(final ChannelHandlerContext ctx, final ByteBuf buf) {\n+            // We must not release the incoming buf here because it will be released by SimpleChannelInboundHandler\n+            ctx.fireChannelRead(alloc.buffer(buf.readableBytes()).writeBytes(buf));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da0faa625c24263258f639d896851beac833e859"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzODI5Mw==", "bodyText": "This handler is not used for h2 because in h2 we copy only data-frames (see AbstractH2DuplexHandler) to unpooled memory. This is currently used only for h1 (and may be used for any other protocol that requires unpooled memory before decoding) and will be placed right after SslHandler. Therefore, only ByteBufs are expected here.", "url": "https://github.com/apple/servicetalk/pull/942#discussion_r382238293", "createdAt": "2020-02-20T20:25:04Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CopyByteBufHandlerChannelInitializer.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright \u00a9 2019-2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandler;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * Initializer to configure {@link ChannelInboundHandler} that will ensure no pooled {@link ByteBuf}s are passed to\n+ * the user and so no leaks are produced if the user does not call {@link ReferenceCountUtil#release(Object)}.\n+ */\n+public final class CopyByteBufHandlerChannelInitializer implements ChannelInitializer {\n+\n+    /**\n+     * {@link PooledByteBufAllocator} to use internally when we know memory won't be leaked.\n+     */\n+    public static final PooledByteBufAllocator POOLED_ALLOCATOR = PooledByteBufAllocator.DEFAULT;\n+\n+    private final CopyByteBufHandler copyHandler;\n+\n+    /**\n+     * Creates a new instance.\n+     *\n+     * @param alloc {@link ByteBufAllocator} to allocate unpooled memory.\n+     */\n+    public CopyByteBufHandlerChannelInitializer(final ByteBufAllocator alloc) {\n+        copyHandler = new CopyByteBufHandler(alloc);\n+    }\n+\n+    @Override\n+    public void init(final Channel channel) {\n+        channel.pipeline().addLast(copyHandler);\n+    }\n+\n+    /**\n+     * This handler has to be added to the {@link ChannelPipeline} when {@link PooledByteBufAllocator} is used for\n+     * reading data from the socket. The allocated {@link ByteBuf}s must be copied and released before handed over to\n+     * the user.\n+     */\n+    @Sharable\n+    private static final class CopyByteBufHandler extends SimpleChannelInboundHandler<ByteBuf> {\n+\n+        private final ByteBufAllocator alloc;\n+\n+        private CopyByteBufHandler(final ByteBufAllocator alloc) {\n+            if (alloc.isDirectBufferPooled()) {\n+                throw new IllegalArgumentException(\"ByteBufAllocator must be unpooled\");\n+            }\n+            this.alloc = alloc;\n+        }\n+\n+        @Override\n+        protected void channelRead0(final ChannelHandlerContext ctx, final ByteBuf buf) {\n+            // We must not release the incoming buf here because it will be released by SimpleChannelInboundHandler\n+            ctx.fireChannelRead(alloc.buffer(buf.readableBytes()).writeBytes(buf));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk4OTYyMA=="}, "originalCommit": {"oid": "da0faa625c24263258f639d896851beac833e859"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5OTM5MQ==", "bodyText": "Ok for the sake of completeness I think we should still check for BufferHolder objects and if they are not expected raise an error.", "url": "https://github.com/apple/servicetalk/pull/942#discussion_r382299391", "createdAt": "2020-02-20T22:41:21Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CopyByteBufHandlerChannelInitializer.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright \u00a9 2019-2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandler;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * Initializer to configure {@link ChannelInboundHandler} that will ensure no pooled {@link ByteBuf}s are passed to\n+ * the user and so no leaks are produced if the user does not call {@link ReferenceCountUtil#release(Object)}.\n+ */\n+public final class CopyByteBufHandlerChannelInitializer implements ChannelInitializer {\n+\n+    /**\n+     * {@link PooledByteBufAllocator} to use internally when we know memory won't be leaked.\n+     */\n+    public static final PooledByteBufAllocator POOLED_ALLOCATOR = PooledByteBufAllocator.DEFAULT;\n+\n+    private final CopyByteBufHandler copyHandler;\n+\n+    /**\n+     * Creates a new instance.\n+     *\n+     * @param alloc {@link ByteBufAllocator} to allocate unpooled memory.\n+     */\n+    public CopyByteBufHandlerChannelInitializer(final ByteBufAllocator alloc) {\n+        copyHandler = new CopyByteBufHandler(alloc);\n+    }\n+\n+    @Override\n+    public void init(final Channel channel) {\n+        channel.pipeline().addLast(copyHandler);\n+    }\n+\n+    /**\n+     * This handler has to be added to the {@link ChannelPipeline} when {@link PooledByteBufAllocator} is used for\n+     * reading data from the socket. The allocated {@link ByteBuf}s must be copied and released before handed over to\n+     * the user.\n+     */\n+    @Sharable\n+    private static final class CopyByteBufHandler extends SimpleChannelInboundHandler<ByteBuf> {\n+\n+        private final ByteBufAllocator alloc;\n+\n+        private CopyByteBufHandler(final ByteBufAllocator alloc) {\n+            if (alloc.isDirectBufferPooled()) {\n+                throw new IllegalArgumentException(\"ByteBufAllocator must be unpooled\");\n+            }\n+            this.alloc = alloc;\n+        }\n+\n+        @Override\n+        protected void channelRead0(final ChannelHandlerContext ctx, final ByteBuf buf) {\n+            // We must not release the incoming buf here because it will be released by SimpleChannelInboundHandler\n+            ctx.fireChannelRead(alloc.buffer(buf.readableBytes()).writeBytes(buf));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk4OTYyMA=="}, "originalCommit": {"oid": "da0faa625c24263258f639d896851beac833e859"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1ODEyOTM0OnYy", "diffSide": "RIGHT", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpClientChannelInitializer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMzoyMDo0OFrOFrWCCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMzoyMDo0OFrOFrWCCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5NDA1OA==", "bodyText": "Please add comment here (and in NettyHttpServer) to explain why we are copying buffers before the HTTP encoder/decoder.", "url": "https://github.com/apple/servicetalk/pull/942#discussion_r380994058", "createdAt": "2020-02-18T23:20:48Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/HttpClientChannelInitializer.java", "diffHunk": "@@ -29,26 +31,27 @@\n \n final class HttpClientChannelInitializer implements ChannelInitializer {\n \n-    private final H1ProtocolConfig config;\n-    private final CloseHandler closeHandler;\n+    private final ChannelInitializer delegate;\n \n     /**\n      * Creates a new instance.\n      * @param config {@link H1ProtocolConfig}\n      * @param closeHandler observes protocol state events\n      */\n-    HttpClientChannelInitializer(H1ProtocolConfig config, CloseHandler closeHandler) {\n-        this.config = config;\n-        this.closeHandler = closeHandler;\n+    HttpClientChannelInitializer(final ByteBufAllocator alloc, final H1ProtocolConfig config,\n+                                 final CloseHandler closeHandler) {\n+        this.delegate = new CopyByteBufHandlerChannelInitializer(alloc).andThen(channel -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da0faa625c24263258f639d896851beac833e859"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1ODEzNDI5OnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CopyByteBufHandlerChannelInitializer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMzoyMzoyNVrOFrWFMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMjo0MDozN1rOFslr4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5NDg2Ng==", "bodyText": "Should we be only doing the copy if the buffer is pooled?", "url": "https://github.com/apple/servicetalk/pull/942#discussion_r380994866", "createdAt": "2020-02-18T23:23:25Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CopyByteBufHandlerChannelInitializer.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright \u00a9 2019-2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandler;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * Initializer to configure {@link ChannelInboundHandler} that will ensure no pooled {@link ByteBuf}s are passed to\n+ * the user and so no leaks are produced if the user does not call {@link ReferenceCountUtil#release(Object)}.\n+ */\n+public final class CopyByteBufHandlerChannelInitializer implements ChannelInitializer {\n+\n+    /**\n+     * {@link PooledByteBufAllocator} to use internally when we know memory won't be leaked.\n+     */\n+    public static final PooledByteBufAllocator POOLED_ALLOCATOR = PooledByteBufAllocator.DEFAULT;\n+\n+    private final CopyByteBufHandler copyHandler;\n+\n+    /**\n+     * Creates a new instance.\n+     *\n+     * @param alloc {@link ByteBufAllocator} to allocate unpooled memory.\n+     */\n+    public CopyByteBufHandlerChannelInitializer(final ByteBufAllocator alloc) {\n+        copyHandler = new CopyByteBufHandler(alloc);\n+    }\n+\n+    @Override\n+    public void init(final Channel channel) {\n+        channel.pipeline().addLast(copyHandler);\n+    }\n+\n+    /**\n+     * This handler has to be added to the {@link ChannelPipeline} when {@link PooledByteBufAllocator} is used for\n+     * reading data from the socket. The allocated {@link ByteBuf}s must be copied and released before handed over to\n+     * the user.\n+     */\n+    @Sharable\n+    private static final class CopyByteBufHandler extends SimpleChannelInboundHandler<ByteBuf> {\n+\n+        private final ByteBufAllocator alloc;\n+\n+        private CopyByteBufHandler(final ByteBufAllocator alloc) {\n+            if (alloc.isDirectBufferPooled()) {\n+                throw new IllegalArgumentException(\"ByteBufAllocator must be unpooled\");\n+            }\n+            this.alloc = alloc;\n+        }\n+\n+        @Override\n+        protected void channelRead0(final ChannelHandlerContext ctx, final ByteBuf buf) {\n+            // We must not release the incoming buf here because it will be released by SimpleChannelInboundHandler\n+            ctx.fireChannelRead(alloc.buffer(buf.readableBytes()).writeBytes(buf));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a13417029e9b44d2eb5af299386cbcc52a564a5"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI3MDAzMA==", "bodyText": "Because we always expect pooled buffers at this point this check will be unnecessary. Let's consider it if the policy for buffer allocators will change later.", "url": "https://github.com/apple/servicetalk/pull/942#discussion_r382270030", "createdAt": "2020-02-20T21:34:14Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CopyByteBufHandlerChannelInitializer.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright \u00a9 2019-2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandler;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * Initializer to configure {@link ChannelInboundHandler} that will ensure no pooled {@link ByteBuf}s are passed to\n+ * the user and so no leaks are produced if the user does not call {@link ReferenceCountUtil#release(Object)}.\n+ */\n+public final class CopyByteBufHandlerChannelInitializer implements ChannelInitializer {\n+\n+    /**\n+     * {@link PooledByteBufAllocator} to use internally when we know memory won't be leaked.\n+     */\n+    public static final PooledByteBufAllocator POOLED_ALLOCATOR = PooledByteBufAllocator.DEFAULT;\n+\n+    private final CopyByteBufHandler copyHandler;\n+\n+    /**\n+     * Creates a new instance.\n+     *\n+     * @param alloc {@link ByteBufAllocator} to allocate unpooled memory.\n+     */\n+    public CopyByteBufHandlerChannelInitializer(final ByteBufAllocator alloc) {\n+        copyHandler = new CopyByteBufHandler(alloc);\n+    }\n+\n+    @Override\n+    public void init(final Channel channel) {\n+        channel.pipeline().addLast(copyHandler);\n+    }\n+\n+    /**\n+     * This handler has to be added to the {@link ChannelPipeline} when {@link PooledByteBufAllocator} is used for\n+     * reading data from the socket. The allocated {@link ByteBuf}s must be copied and released before handed over to\n+     * the user.\n+     */\n+    @Sharable\n+    private static final class CopyByteBufHandler extends SimpleChannelInboundHandler<ByteBuf> {\n+\n+        private final ByteBufAllocator alloc;\n+\n+        private CopyByteBufHandler(final ByteBufAllocator alloc) {\n+            if (alloc.isDirectBufferPooled()) {\n+                throw new IllegalArgumentException(\"ByteBufAllocator must be unpooled\");\n+            }\n+            this.alloc = alloc;\n+        }\n+\n+        @Override\n+        protected void channelRead0(final ChannelHandlerContext ctx, final ByteBuf buf) {\n+            // We must not release the incoming buf here because it will be released by SimpleChannelInboundHandler\n+            ctx.fireChannelRead(alloc.buffer(buf.readableBytes()).writeBytes(buf));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5NDg2Ng=="}, "originalCommit": {"oid": "1a13417029e9b44d2eb5af299386cbcc52a564a5"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5OTEwNw==", "bodyText": "It is better to reduce assumptions between unrelated components (Bootstrap classes using pooled allocator and this handler assuming pooled allocators). If you think it is not expected at least add an assert and a test that leverages the assert.", "url": "https://github.com/apple/servicetalk/pull/942#discussion_r382299107", "createdAt": "2020-02-20T22:40:37Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/CopyByteBufHandlerChannelInitializer.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright \u00a9 2019-2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.transport.netty.internal;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.PooledByteBufAllocator;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandler;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.util.ReferenceCountUtil;\n+\n+/**\n+ * Initializer to configure {@link ChannelInboundHandler} that will ensure no pooled {@link ByteBuf}s are passed to\n+ * the user and so no leaks are produced if the user does not call {@link ReferenceCountUtil#release(Object)}.\n+ */\n+public final class CopyByteBufHandlerChannelInitializer implements ChannelInitializer {\n+\n+    /**\n+     * {@link PooledByteBufAllocator} to use internally when we know memory won't be leaked.\n+     */\n+    public static final PooledByteBufAllocator POOLED_ALLOCATOR = PooledByteBufAllocator.DEFAULT;\n+\n+    private final CopyByteBufHandler copyHandler;\n+\n+    /**\n+     * Creates a new instance.\n+     *\n+     * @param alloc {@link ByteBufAllocator} to allocate unpooled memory.\n+     */\n+    public CopyByteBufHandlerChannelInitializer(final ByteBufAllocator alloc) {\n+        copyHandler = new CopyByteBufHandler(alloc);\n+    }\n+\n+    @Override\n+    public void init(final Channel channel) {\n+        channel.pipeline().addLast(copyHandler);\n+    }\n+\n+    /**\n+     * This handler has to be added to the {@link ChannelPipeline} when {@link PooledByteBufAllocator} is used for\n+     * reading data from the socket. The allocated {@link ByteBuf}s must be copied and released before handed over to\n+     * the user.\n+     */\n+    @Sharable\n+    private static final class CopyByteBufHandler extends SimpleChannelInboundHandler<ByteBuf> {\n+\n+        private final ByteBufAllocator alloc;\n+\n+        private CopyByteBufHandler(final ByteBufAllocator alloc) {\n+            if (alloc.isDirectBufferPooled()) {\n+                throw new IllegalArgumentException(\"ByteBufAllocator must be unpooled\");\n+            }\n+            this.alloc = alloc;\n+        }\n+\n+        @Override\n+        protected void channelRead0(final ChannelHandlerContext ctx, final ByteBuf buf) {\n+            // We must not release the incoming buf here because it will be released by SimpleChannelInboundHandler\n+            ctx.fireChannelRead(alloc.buffer(buf.readableBytes()).writeBytes(buf));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5NDg2Ng=="}, "originalCommit": {"oid": "1a13417029e9b44d2eb5af299386cbcc52a564a5"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1ODE1NDkwOnYy", "diffSide": "RIGHT", "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpServerBinder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMzozMzo1NlrOFrWRpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzowMjowOFrOFsmM7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5ODA1NQ==", "bodyText": "Although highly unlikely, we should also add a handler to the accept pipeline (inside bootstrap.handler()) to make sure we do not leak pooled buffers.", "url": "https://github.com/apple/servicetalk/pull/942#discussion_r380998055", "createdAt": "2020-02-18T23:33:56Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpServerBinder.java", "diffHunk": "@@ -165,7 +165,7 @@ private static void configure(ReadOnlyTcpServerConfig config, boolean autoRead,\n         bs.option(ChannelOption.SO_BACKLOG, config.backlog());\n \n         // Set the correct ByteBufAllocator based on our BufferAllocator to minimize memory copies.\n-        ByteBufAllocator byteBufAllocator = BufferUtils.getByteBufAllocator(bufferAllocator);\n+        ByteBufAllocator byteBufAllocator = POOLED_ALLOCATOR;\n         bs.option(ChannelOption.ALLOCATOR, byteBufAllocator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a13417029e9b44d2eb5af299386cbcc52a564a5"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI3ODE4OA==", "bodyText": "We currently have a check in NettyChannelPublisher:\n\n  \n    \n      servicetalk/servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/NettyChannelPublisher.java\n    \n    \n        Lines 79 to 89\n      in\n      3a67c9f\n    \n    \n    \n    \n\n        \n          \n                   if (data instanceof ReferenceCounted) { \n        \n\n        \n          \n                       /* \n        \n\n        \n          \n                        * We do not expect ref-counted objects here as ST does not support them and do not take care to clean them \n        \n\n        \n          \n                        * in error conditions. Hence we fail-fast when we see such objects. \n        \n\n        \n          \n                        */ \n        \n\n        \n          \n                       ReferenceCountUtil.release(data); \n        \n\n        \n          \n                       exceptionCaught(new IllegalArgumentException(\"Reference counted leaked netty's pipeline. Object: \" + \n        \n\n        \n          \n                               data.getClass().getSimpleName())); \n        \n\n        \n          \n                       channel.close(); \n        \n\n        \n          \n                       return; \n        \n\n        \n          \n                   } \n        \n    \n  \n\n\nThe only potential risk I see is that we wrap ByteBuf with Buffer interface or create HttpHeaders object with multiple ByteBuf slices inside.\n\nThis wrapping hides ReferenceCounted interface => check in NettyChannelPublisher won't see it.\nPresence of ReferenceCounted interface does not mean that the ByteBuf is pooled. Our unpooled buffers also implement ReferenceCounted, but override release() method to do nothing.\n\nWe can enhance HttpObjectDecoder to check each incoming ByteBuf in this way:\nif (buffer.alloc().isDirectBufferPooled()) {\n    throw new IllegalStateException(\"Unpooled ByteBuf was expected, but received the pooled one\");\n}\nBut not sure this is required because we always have CopyByteBufHandler before HttpObjectDecoder. I think we can keep it as is and rely on the check in NettyChannelPublisher and netty's leak detector.\nIf you think we need something else, where do you propose to add it? Because we behave differently for h2 and h1 and we wrap with our ST types after h1/h2 decoders, a simple handler after protocol decoders won't catch it.", "url": "https://github.com/apple/servicetalk/pull/942#discussion_r382278188", "createdAt": "2020-02-20T21:52:19Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpServerBinder.java", "diffHunk": "@@ -165,7 +165,7 @@ private static void configure(ReadOnlyTcpServerConfig config, boolean autoRead,\n         bs.option(ChannelOption.SO_BACKLOG, config.backlog());\n \n         // Set the correct ByteBufAllocator based on our BufferAllocator to minimize memory copies.\n-        ByteBufAllocator byteBufAllocator = BufferUtils.getByteBufAllocator(bufferAllocator);\n+        ByteBufAllocator byteBufAllocator = POOLED_ALLOCATOR;\n         bs.option(ChannelOption.ALLOCATOR, byteBufAllocator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5ODA1NQ=="}, "originalCommit": {"oid": "1a13417029e9b44d2eb5af299386cbcc52a564a5"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwNzU2Ng==", "bodyText": "I suggested change for the accept pipeline, I think you have described behavior for the child pipeline.", "url": "https://github.com/apple/servicetalk/pull/942#discussion_r382307566", "createdAt": "2020-02-20T23:02:08Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-tcp-netty-internal/src/main/java/io/servicetalk/tcp/netty/internal/TcpServerBinder.java", "diffHunk": "@@ -165,7 +165,7 @@ private static void configure(ReadOnlyTcpServerConfig config, boolean autoRead,\n         bs.option(ChannelOption.SO_BACKLOG, config.backlog());\n \n         // Set the correct ByteBufAllocator based on our BufferAllocator to minimize memory copies.\n-        ByteBufAllocator byteBufAllocator = BufferUtils.getByteBufAllocator(bufferAllocator);\n+        ByteBufAllocator byteBufAllocator = POOLED_ALLOCATOR;\n         bs.option(ChannelOption.ALLOCATOR, byteBufAllocator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5ODA1NQ=="}, "originalCommit": {"oid": "1a13417029e9b44d2eb5af299386cbcc52a564a5"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM1ODE5MzgxOnYy", "diffSide": "RIGHT", "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/StreamingConnectionFactory.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMzo1MjozMFrOFrWpuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMzowNDoxMFrOFsmPrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAwNDIxOQ==", "bodyText": "We should perhaps rename this class to H1StreamingConnectionFactory", "url": "https://github.com/apple/servicetalk/pull/942#discussion_r381004219", "createdAt": "2020-02-18T23:52:30Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/StreamingConnectionFactory.java", "diffHunk": "@@ -49,10 +50,12 @@ private StreamingConnectionFactory() {\n             final HttpExecutionContext executionContext, final ReadOnlyHttpClientConfig config,\n             final ChannelInitializer initializer) {\n         final CloseHandler closeHandler = forPipelinedRequestResponse(true, channel.config());\n+        assert config.h1Config() != null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a13417029e9b44d2eb5af299386cbcc52a564a5"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI3ODcwOQ==", "bodyText": "Let's do that in a follow-up to minimize scope of this PR.", "url": "https://github.com/apple/servicetalk/pull/942#discussion_r382278709", "createdAt": "2020-02-20T21:53:27Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/StreamingConnectionFactory.java", "diffHunk": "@@ -49,10 +50,12 @@ private StreamingConnectionFactory() {\n             final HttpExecutionContext executionContext, final ReadOnlyHttpClientConfig config,\n             final ChannelInitializer initializer) {\n         final CloseHandler closeHandler = forPipelinedRequestResponse(true, channel.config());\n+        assert config.h1Config() != null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAwNDIxOQ=="}, "originalCommit": {"oid": "1a13417029e9b44d2eb5af299386cbcc52a564a5"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwODI2OQ==", "bodyText": "Its a package private class and it is just a rename. It is easier to do it in-place as you added the assert to make sure it is used only for H1. It is up to you if you want to do it here or in a follow up, I just want to make sure this does not get lost in comments.", "url": "https://github.com/apple/servicetalk/pull/942#discussion_r382308269", "createdAt": "2020-02-20T23:04:10Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-http-netty/src/main/java/io/servicetalk/http/netty/StreamingConnectionFactory.java", "diffHunk": "@@ -49,10 +50,12 @@ private StreamingConnectionFactory() {\n             final HttpExecutionContext executionContext, final ReadOnlyHttpClientConfig config,\n             final ChannelInitializer initializer) {\n         final CloseHandler closeHandler = forPipelinedRequestResponse(true, channel.config());\n+        assert config.h1Config() != null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAwNDIxOQ=="}, "originalCommit": {"oid": "1a13417029e9b44d2eb5af299386cbcc52a564a5"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2860, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}