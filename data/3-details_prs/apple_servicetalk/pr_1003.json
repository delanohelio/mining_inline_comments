{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk5MTkxMzAy", "number": 1003, "title": "Add `ambWith` and `amb` methods for `Single` and `Completable`", "bodyText": "Motivation\namb is a useful operator for trying multiple sources and using the first result. Few cases that are common;\n\nUse as a windowing scheme (number of items or time as window boundarirs)\nBackup/hedge requests for clients.\n\nModification\nUse two flavors of these operators:\n\nStatic factory where an arbitrary number of sources can be ambiguated.\nOperator to ambiguate a source with other.\n\nResult\nMore operators, more fun!", "createdAt": "2020-04-05T18:10:06Z", "url": "https://github.com/apple/servicetalk/pull/1003", "merged": true, "mergeCommit": {"oid": "5b971c1083fec9e3fa2d9ed13053d10b0853a0cf"}, "closed": true, "closedAt": "2020-04-07T19:39:45Z", "author": {"login": "NiteshKant"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcUuFvKAH2gAyMzk5MTkxMzAyOmQ2ZWMwZGFkOTNkMWY3M2Y3OWQ3OWMyMjVhNTY1ZjMxNWI3YzQzODQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcVMTOUgFqTM4ODc4OTkxOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d6ec0dad93d1f73f79d79c225a565f315b7c4384", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/d6ec0dad93d1f73f79d79c225a565f315b7c4384", "committedDate": "2020-04-05T18:06:28Z", "message": "Add `ambWith` and `amb` methods for `Single` and `Completable`\n\n__Motivation__\n\n[`amb`](http://reactivex.io/documentation/operators/amb.html) is a useful operator for trying multiple sources and using the first result. Few cases that are common;\n- Use as a windowing scheme (number of items or time as window boundarirs)\n- Backup/hedge requests for clients.\n\n__Modification__\n\nUse two flavors of these operators:\n\n- Static factory where an arbitrary number of sources can be ambiguated.\n- Operator to ambiguate a source with other.\n\n__Result__\n\nMore operators, more fun!"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NTIyOTA1", "url": "https://github.com/apple/servicetalk/pull/1003#pullrequestreview-388522905", "createdAt": "2020-04-06T18:45:56Z", "commit": {"oid": "d6ec0dad93d1f73f79d79c225a565f315b7c4384"}, "state": "APPROVED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxODo0NTo1NlrOGBlL2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxOToxOTozNlrOGBmW6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMTAwMw==", "bodyText": "ambiguates -> this isn't a word. I think the amp operator name is meant to imply it \"ambiguously selects the source of data based upon the first one to produce data\" [1]. consider clarifying this language accordingly.\n[1] http://rxwiki.wikidot.com/enumerableex-amb", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404311003", "createdAt": "2020-04-06T18:45:56Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java", "diffHunk": "@@ -1213,6 +1216,29 @@ public final Completable subscribeShareContext() {\n         return new CompletableSubscribeShareContext(this);\n     }\n \n+    /**\n+     * Creates a new {@link Completable} that ambiguates the result of this {@link Completable} with the passed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6ec0dad93d1f73f79d79c225a565f315b7c4384"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMjMyNQ==", "bodyText": "not sure we need to get complex here but this would be like spawning n threads that each wait on the future, and complete a single future the main thread is waiting on.", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404312325", "createdAt": "2020-04-06T18:48:12Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java", "diffHunk": "@@ -1213,6 +1216,29 @@ public final Completable subscribeShareContext() {\n         return new CompletableSubscribeShareContext(this);\n     }\n \n+    /**\n+     * Creates a new {@link Completable} that ambiguates the result of this {@link Completable} with the passed\n+     * {@code other} {@link Completable} such that whichever of them terminates first (successfully or with an error),\n+     * the returned {@link Completable} will return that result.\n+     * <p>\n+     * From a sequential programming point of view this method is roughly equivalent to the following:\n+     * <pre>{@code\n+     *      for (Future<T> ft: futures) { // Provided Futures (analogous to the Completables here)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6ec0dad93d1f73f79d79c225a565f315b7c4384"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxODQ5Mg==", "bodyText": "DelayedCancellable semantics are to provide a Cancellable now when the real Cancellable isn't yet available and not necessarily to protect against concurrent access on cancel (which is an implementation detail). Do these two things necessarily go together, and if so do we want to clarify the javadocs on DelayedCancellable to more clearly state the \"will only cancel upstream once\" semantics?", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404318492", "createdAt": "2020-04-06T18:58:35Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AmbSingles.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.SingleSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class AmbSingles<T> extends Single<T> {\n+    private final Single<? extends T>[] singles;\n+\n+    @SafeVarargs\n+    AmbSingles(final Single<? extends T>... singles) {\n+        for (Single<? extends T> single : singles) {\n+            requireNonNull(single);\n+        }\n+        this.singles = singles;\n+    }\n+\n+    AmbSingles(final Iterable<Single<? extends T>> singles) {\n+        List<Single<? extends T>> allSingles = new ArrayList<>();\n+        for (Single<? extends T> single : singles) {\n+            allSingles.add(requireNonNull(single));\n+        }\n+        @SuppressWarnings({\"unchecked\", \"SuspiciousToArrayCall\"})\n+        Single<? extends T>[] singlesArr = (Single<? extends T>[]) allSingles.toArray(new Single[0]);\n+        this.singles = singlesArr;\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final Cancellable[] cancellables = new Cancellable[singles.length];\n+        final State<T> state = new State<>(subscriber);\n+        subscriber.onSubscribe(state);\n+        try {\n+            for (int i = 0; i < singles.length; i++) {\n+                AmbSubscriber<T> sub = new AmbSubscriber<>(state);\n+                cancellables[i] = sub;\n+                singles[i].subscribeInternal(sub);\n+            }\n+        } catch (Throwable t) {\n+            state.delayedCancellable(CompositeCancellable.create(cancellables));\n+            state.tryError(t);\n+            return;\n+        }\n+        state.delayedCancellable(CompositeCancellable.create(cancellables));\n+    }\n+\n+    static final class AmbSubscriber<T> extends DelayedCancellable implements Subscriber<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6ec0dad93d1f73f79d79c225a565f315b7c4384"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMyMTI5MQ==", "bodyText": "(pre-existing) since there is a static factory method for generation here, consider breaking apart into two separate classes to avoid unused state and duplicate conditionals.", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404321291", "createdAt": "2020-04-06T19:03:44Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/CompositeCancellable.java", "diffHunk": "@@ -59,13 +60,30 @@ private CompositeCancellable(Cancellable... others) {\n     public void cancel() {\n         if (cancelledUpdater.compareAndSet(this, 0, 1)) {\n             if (others == null) {\n-                //noinspection ConstantConditions\n-                first.cancel();\n-                //noinspection ConstantConditions\n-                second.cancel();\n+                try {\n+                    //noinspection ConstantConditions\n+                    first.cancel();\n+                } finally {\n+                    //noinspection ConstantConditions\n+                    second.cancel();\n+                }\n             } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6ec0dad93d1f73f79d79c225a565f315b7c4384"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMyMjA2Nw==", "bodyText": "put this in a finally block in case one of the cancel operations throw.", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404322067", "createdAt": "2020-04-06T19:05:06Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AmbSingles.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.SingleSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class AmbSingles<T> extends Single<T> {\n+    private final Single<? extends T>[] singles;\n+\n+    @SafeVarargs\n+    AmbSingles(final Single<? extends T>... singles) {\n+        for (Single<? extends T> single : singles) {\n+            requireNonNull(single);\n+        }\n+        this.singles = singles;\n+    }\n+\n+    AmbSingles(final Iterable<Single<? extends T>> singles) {\n+        List<Single<? extends T>> allSingles = new ArrayList<>();\n+        for (Single<? extends T> single : singles) {\n+            allSingles.add(requireNonNull(single));\n+        }\n+        @SuppressWarnings({\"unchecked\", \"SuspiciousToArrayCall\"})\n+        Single<? extends T>[] singlesArr = (Single<? extends T>[]) allSingles.toArray(new Single[0]);\n+        this.singles = singlesArr;\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final Cancellable[] cancellables = new Cancellable[singles.length];\n+        final State<T> state = new State<>(subscriber);\n+        subscriber.onSubscribe(state);\n+        try {\n+            for (int i = 0; i < singles.length; i++) {\n+                AmbSubscriber<T> sub = new AmbSubscriber<>(state);\n+                cancellables[i] = sub;\n+                singles[i].subscribeInternal(sub);\n+            }\n+        } catch (Throwable t) {\n+            state.delayedCancellable(CompositeCancellable.create(cancellables));\n+            state.tryError(t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6ec0dad93d1f73f79d79c225a565f315b7c4384"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMyMzM1Mw==", "bodyText": "nit: put on previous line", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404323353", "createdAt": "2020-04-06T19:07:19Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AmbSingles.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.SingleSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class AmbSingles<T> extends Single<T> {\n+    private final Single<? extends T>[] singles;\n+\n+    @SafeVarargs\n+    AmbSingles(final Single<? extends T>... singles) {\n+        for (Single<? extends T> single : singles) {\n+            requireNonNull(single);\n+        }\n+        this.singles = singles;\n+    }\n+\n+    AmbSingles(final Iterable<Single<? extends T>> singles) {\n+        List<Single<? extends T>> allSingles = new ArrayList<>();\n+        for (Single<? extends T> single : singles) {\n+            allSingles.add(requireNonNull(single));\n+        }\n+        @SuppressWarnings({\"unchecked\", \"SuspiciousToArrayCall\"})\n+        Single<? extends T>[] singlesArr = (Single<? extends T>[]) allSingles.toArray(new Single[0]);\n+        this.singles = singlesArr;\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final Cancellable[] cancellables = new Cancellable[singles.length];\n+        final State<T> state = new State<>(subscriber);\n+        subscriber.onSubscribe(state);\n+        try {\n+            for (int i = 0; i < singles.length; i++) {\n+                AmbSubscriber<T> sub = new AmbSubscriber<>(state);\n+                cancellables[i] = sub;\n+                singles[i].subscribeInternal(sub);\n+            }\n+        } catch (Throwable t) {\n+            state.delayedCancellable(CompositeCancellable.create(cancellables));\n+            state.tryError(t);\n+            return;\n+        }\n+        state.delayedCancellable(CompositeCancellable.create(cancellables));\n+    }\n+\n+    static final class AmbSubscriber<T> extends DelayedCancellable implements Subscriber<T> {\n+        private final State<T> state;\n+\n+        AmbSubscriber(final State<T> state) {\n+            this.state = state;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Cancellable cancellable) {\n+            delayedCancellable(cancellable);\n+        }\n+\n+        @Override\n+        public void onSuccess(@Nullable final T result) {\n+            state.trySuccess(result);\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.tryError(t);\n+        }\n+    }\n+\n+    static final class State<T> extends DelayedCancellable {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<State> doneUpdater =\n+                newUpdater(State.class, \"done\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6ec0dad93d1f73f79d79c225a565f315b7c4384"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMyNzM2Ng==", "bodyText": "consider including this inside the try catch to avoid letting the exception escape.", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404327366", "createdAt": "2020-04-06T19:14:22Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/SingleAmbWith.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.api.AmbSingles.AmbSubscriber;\n+import io.servicetalk.concurrent.api.AmbSingles.State;\n+import io.servicetalk.concurrent.internal.SignalOffloader;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+final class SingleAmbWith<T> extends AbstractNoHandleSubscribeSingle<T> {\n+    private final Single<T> original;\n+    private final Single<T> ambWith;\n+\n+    SingleAmbWith(final Executor executor, final Single<T> original, final Single<T> ambWith) {\n+        super(executor);\n+        this.original = requireNonNull(original);\n+        this.ambWith = requireNonNull(ambWith);\n+    }\n+\n+    @Override\n+    void handleSubscribe(final Subscriber<? super T> subscriber, final SignalOffloader signalOffloader,\n+                         final AsyncContextMap contextMap, final AsyncContextProvider contextProvider) {\n+        State<T> state = new State<>(subscriber);\n+        subscriber.onSubscribe(state);\n+        AmbSubscriber<T> originalSubscriber = new AmbSubscriber<>(state);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6ec0dad93d1f73f79d79c225a565f315b7c4384"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMyNzU2MQ==", "bodyText": "consider most/all of the allocation/invocations in try/catch to avoid letting exceptions escape. we also have more context here as to when onSubscribe is invoked to avoid letting the exception bubble up and invoking it multiple times.", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404327561", "createdAt": "2020-04-06T19:14:43Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AmbSingles.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.SingleSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class AmbSingles<T> extends Single<T> {\n+    private final Single<? extends T>[] singles;\n+\n+    @SafeVarargs\n+    AmbSingles(final Single<? extends T>... singles) {\n+        for (Single<? extends T> single : singles) {\n+            requireNonNull(single);\n+        }\n+        this.singles = singles;\n+    }\n+\n+    AmbSingles(final Iterable<Single<? extends T>> singles) {\n+        List<Single<? extends T>> allSingles = new ArrayList<>();\n+        for (Single<? extends T> single : singles) {\n+            allSingles.add(requireNonNull(single));\n+        }\n+        @SuppressWarnings({\"unchecked\", \"SuspiciousToArrayCall\"})\n+        Single<? extends T>[] singlesArr = (Single<? extends T>[]) allSingles.toArray(new Single[0]);\n+        this.singles = singlesArr;\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final Cancellable[] cancellables = new Cancellable[singles.length];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6ec0dad93d1f73f79d79c225a565f315b7c4384"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMzMDIxOQ==", "bodyText": "what about tests for the Completable variants?", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404330219", "createdAt": "2020-04-06T19:19:36Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-reactivestreams/src/test/java/io/servicetalk/concurrent/reactivestreams/tck/SingleAmbWithTckTest.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.reactivestreams.tck;\n+\n+import io.servicetalk.concurrent.api.Single;\n+\n+import org.testng.annotations.Test;\n+\n+import static io.servicetalk.concurrent.api.Single.never;\n+\n+@Test\n+public class SingleAmbWithTckTest extends AbstractSingleOperatorTckTest<Integer> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6ec0dad93d1f73f79d79c225a565f315b7c4384"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NjcwNTI5", "url": "https://github.com/apple/servicetalk/pull/1003#pullrequestreview-388670529", "createdAt": "2020-04-06T22:46:38Z", "commit": {"oid": "d6ec0dad93d1f73f79d79c225a565f315b7c4384"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMjo0NjozOFrOGBsqpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMjo1ODoyOFrOGBs7Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzMzU3Mg==", "bodyText": "Consider suppressing the original t: tt.addSuppressed(t);, like we do in BeforeFinally*.", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404433572", "createdAt": "2020-04-06T22:46:38Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/AmbSingles.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api;\n+\n+import io.servicetalk.concurrent.Cancellable;\n+import io.servicetalk.concurrent.SingleSource.Subscriber;\n+import io.servicetalk.concurrent.internal.DelayedCancellable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import javax.annotation.Nullable;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n+\n+final class AmbSingles<T> extends Single<T> {\n+    private final Single<? extends T>[] singles;\n+\n+    @SafeVarargs\n+    AmbSingles(final Single<? extends T>... singles) {\n+        for (Single<? extends T> single : singles) {\n+            requireNonNull(single);\n+        }\n+        this.singles = singles;\n+    }\n+\n+    AmbSingles(final Iterable<Single<? extends T>> singles) {\n+        List<Single<? extends T>> allSingles = new ArrayList<>();\n+        for (Single<? extends T> single : singles) {\n+            allSingles.add(requireNonNull(single));\n+        }\n+        @SuppressWarnings({\"unchecked\", \"SuspiciousToArrayCall\"})\n+        Single<? extends T>[] singlesArr = (Single<? extends T>[]) allSingles.toArray(new Single[0]);\n+        this.singles = singlesArr;\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final Subscriber<? super T> subscriber) {\n+        final Cancellable[] cancellables = new Cancellable[singles.length];\n+        final State<T> state = new State<>(subscriber);\n+        subscriber.onSubscribe(state);\n+        try {\n+            for (int i = 0; i < singles.length; i++) {\n+                AmbSubscriber<T> sub = new AmbSubscriber<>(state);\n+                cancellables[i] = sub;\n+                singles[i].subscribeInternal(sub);\n+            }\n+        } catch (Throwable t) {\n+            state.delayedCancellable(CompositeCancellable.create(cancellables));\n+            state.tryError(t);\n+            return;\n+        }\n+        state.delayedCancellable(CompositeCancellable.create(cancellables));\n+    }\n+\n+    static final class AmbSubscriber<T> extends DelayedCancellable implements Subscriber<T> {\n+        private final State<T> state;\n+\n+        AmbSubscriber(final State<T> state) {\n+            this.state = state;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Cancellable cancellable) {\n+            delayedCancellable(cancellable);\n+        }\n+\n+        @Override\n+        public void onSuccess(@Nullable final T result) {\n+            state.trySuccess(result);\n+        }\n+\n+        @Override\n+        public void onError(final Throwable t) {\n+            state.tryError(t);\n+        }\n+    }\n+\n+    static final class State<T> extends DelayedCancellable {\n+        @SuppressWarnings(\"rawtypes\")\n+        private static final AtomicIntegerFieldUpdater<State> doneUpdater =\n+                newUpdater(State.class, \"done\");\n+        private final Subscriber<? super T> target;\n+\n+        private volatile int done;\n+\n+        State(final Subscriber<? super T> target) {\n+            this.target = target;\n+        }\n+\n+        void trySuccess(@Nullable final T result) {\n+            if (doneUpdater.compareAndSet(this, 0, 1)) {\n+                // Cancel other as we got a result.\n+                try {\n+                    cancel();\n+                } catch (Throwable t) {\n+                    target.onError(t);\n+                    return;\n+                }\n+                target.onSuccess(result);\n+            }\n+        }\n+\n+        void tryError(final Throwable t) {\n+            if (doneUpdater.compareAndSet(this, 0, 1)) {\n+                // Cancel other as we got a result.\n+                try {\n+                    cancel();\n+                } catch (Throwable tt) {\n+                    target.onError(tt);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6ec0dad93d1f73f79d79c225a565f315b7c4384"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQzNzgyNg==", "bodyText": "This operator looks like the equivalent to CompletableFuture.anyOf(...).get(): https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html#anyOf-java.util.concurrent.CompletableFuture...-", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404437826", "createdAt": "2020-04-06T22:58:28Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java", "diffHunk": "@@ -1213,6 +1216,29 @@ public final Completable subscribeShareContext() {\n         return new CompletableSubscribeShareContext(this);\n     }\n \n+    /**\n+     * Creates a new {@link Completable} that ambiguates the result of this {@link Completable} with the passed\n+     * {@code other} {@link Completable} such that whichever of them terminates first (successfully or with an error),\n+     * the returned {@link Completable} will return that result.\n+     * <p>\n+     * From a sequential programming point of view this method is roughly equivalent to the following:\n+     * <pre>{@code\n+     *      for (Future<T> ft: futures) { // Provided Futures (analogous to the Completables here)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMjMyNQ=="}, "originalCommit": {"oid": "d6ec0dad93d1f73f79d79c225a565f315b7c4384"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "310a350ef0af1b48acd669be4a00860821c2559a", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/310a350ef0af1b48acd669be4a00860821c2559a", "committedDate": "2020-04-07T00:46:15Z", "message": "Review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4Nzg5OTE5", "url": "https://github.com/apple/servicetalk/pull/1003#pullrequestreview-388789919", "createdAt": "2020-04-07T05:18:21Z", "commit": {"oid": "310a350ef0af1b48acd669be4a00860821c2559a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNToxODoyMVrOGBzNFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNToxODoyMVrOGBzNFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU0MDY5NQ==", "bodyText": "Should we mention that this is an alias of amb operator and provide cross-links between amb and anyOf in @see tags?", "url": "https://github.com/apple/servicetalk/pull/1003#discussion_r404540695", "createdAt": "2020-04-07T05:18:21Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java", "diffHunk": "@@ -1643,6 +1667,94 @@ public static Completable mergeAllDelayError(int maxConcurrency, Completable...\n         return from(completables).flatMapCompletableDelayError(identity(), maxConcurrency);\n     }\n \n+    /**\n+     * Creates a new {@link Completable} that terminates with the result (either success or error) of whichever amongst\n+     * the passed {@code completables} that terminates first.\n+     * <p>\n+     * From a sequential programming point of view this method is roughly equivalent to the following:\n+     * <pre>{@code\n+     *      for (Future<T> ft: futures) { // Provided Futures (analogous to the Completables here)\n+     *          // This is an approximation, this operator will pick the first result from any of the futures.\n+     *          return ft.get();\n+     *      }\n+     * }</pre>\n+     *\n+     * @param completables {@link Completable}s the result of which are to be ambiguated.\n+     * @return A new {@link Completable} that terminates with the result (either success or error) of whichever amongst\n+     * the passed {@code completables} that terminates first.\n+     * @see <a href=\"http://reactivex.io/documentation/operators/amb.html\">ReactiveX amb operator.</a>\n+     */\n+    public static Completable amb(final Completable... completables) {\n+        return Single.amb(stream(spliterator(completables), false)\n+                .map(Completable::toSingle).collect(toList())).ignoreElement();\n+    }\n+\n+    /**\n+     * Creates a new {@link Completable} that terminates with the result (either success or error) of whichever amongst\n+     * the passed {@code completables} that terminates first.\n+     * <p>\n+     * From a sequential programming point of view this method is roughly equivalent to the following:\n+     * <pre>{@code\n+     *      for (Future<T> ft: futures) { // Provided Futures (analogous to the Completables here)\n+     *          // This is an approximation, this operator will pick the first result from any of the futures.\n+     *          return ft.get();\n+     *      }\n+     * }</pre>\n+     *\n+     * @param completables {@link Completable}s the result of which are to be ambiguated.\n+     * @return A new {@link Completable} that terminates with the result (either success or error) of whichever amongst\n+     * the passed {@code completables} that terminates first.\n+     * that result.\n+     * @see <a href=\"http://reactivex.io/documentation/operators/amb.html\">ReactiveX amb operator.</a>\n+     */\n+    public static Completable amb(final Iterable<Completable> completables) {\n+        return Single.amb(stream(completables.spliterator(), false)\n+                .map(Completable::toSingle).collect(toList())).ignoreElement();\n+    }\n+\n+    /**\n+     * Creates a new {@link Completable} that terminates with the result (either success or error) of whichever amongst\n+     * the passed {@code completables} that terminates first.\n+     * <p>\n+     * From a sequential programming point of view this method is roughly equivalent to the following:\n+     * <pre>{@code\n+     *      for (Future<T> ft: futures) { // Provided Futures (analogous to the Completables here)\n+     *          // This is an approximation, this operator will pick the first result from any of the futures.\n+     *          return ft.get();\n+     *      }\n+     * }</pre>\n+     *\n+     * @param completables {@link Completable}s the result of which are to be ambiguated.\n+     * @return A new {@link Completable} that terminates with the result (either success or error) of whichever amongst\n+     * the passed {@code completables} that terminates first.\n+     * @see <a href=\"http://reactivex.io/documentation/operators/amb.html\">ReactiveX amb operator.</a>\n+     */\n+    public static Completable anyOf(final Completable... completables) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "310a350ef0af1b48acd669be4a00860821c2559a"}, "originalPosition": 106}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3591, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}