{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUyNjY1ODg4", "number": 1099, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMDoyNToxN1rOEQW9LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMzo1OToyMlrOEQ1sGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NTg4NzgwOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DeferSslHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMDoyNToxN1rOG0eAtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMDoyNToxN1rOG0eAtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY3MDgzNg==", "bodyText": "nit: Rename observable to observeSsl", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r457670836", "createdAt": "2020-07-20T20:25:17Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DeferSslHandler.java", "diffHunk": "@@ -20,22 +20,29 @@\n import io.netty.channel.ChannelHandler;\n import io.netty.handler.ssl.SslHandler;\n \n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.reportSecurityHandshakeStarting;\n+\n /**\n  * A {@link ChannelHandler} that holds a place in a pipeline, allowing us to defer adding the {@link SslHandler}.\n  */\n-public class DeferSslHandler extends ChannelDuplexHandler {\n+public final class DeferSslHandler extends ChannelDuplexHandler {\n     private final Channel channel;\n     private final SslHandler handler;\n+    private final boolean observable;\n \n-    DeferSslHandler(final Channel channel, final SslHandler handler) {\n+    DeferSslHandler(final Channel channel, final SslHandler handler, final boolean observable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjY0ODI4OnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMTo0MzoyMlrOG0lDeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMTo0MzoyMlrOG0lDeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4NjIzMw==", "bodyText": "rename to handshakeStartNotified to indicate that this does not reflect handshake start state but the notification to the observer.", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r457786233", "createdAt": "2020-07-21T01:43:22Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -16,46 +16,93 @@\n package io.servicetalk.transport.netty.internal;\n \n import io.servicetalk.transport.api.ConnectionObserver;\n+import io.servicetalk.transport.api.ConnectionObserver.SecurityHandshakeObserver;\n import io.servicetalk.transport.api.TransportObserver;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufHolder;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPipeline;\n import io.netty.channel.ChannelPromise;\n+import io.netty.handler.ssl.SslHandshakeCompletionEvent;\n \n+import javax.net.ssl.SSLSession;\n+\n+import static io.servicetalk.transport.netty.internal.NettyPipelineSslUtils.extractSslSession;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionError;\n import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionObserver;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.securityHandshakeObserver;\n import static java.util.Objects.requireNonNull;\n \n /**\n  * A {@link ChannelInitializer} that registers a {@link ConnectionObserver} for all channels.\n  */\n public final class TransportObserverInitializer implements ChannelInitializer {\n \n+    /**\n+     * Tells which side is using secure connection.\n+     */\n+    public enum SecureSide {\n+        CLIENT,\n+        SERVER,\n+        NONE\n+    }\n+\n     private final TransportObserver transportObserver;\n+    private final SecureSide secureSide;\n \n     /**\n      * Creates a new instance.\n      *\n      * @param transportObserver {@link TransportObserver} to initialize for the channel\n+     * @param secureSide tells which side is using secure connection\n      */\n-    public TransportObserverInitializer(final TransportObserver transportObserver) {\n+    public TransportObserverInitializer(final TransportObserver transportObserver, final SecureSide secureSide) {\n         this.transportObserver = requireNonNull(transportObserver);\n+        this.secureSide = secureSide;\n     }\n \n     @Override\n     public void init(final Channel channel) {\n         final ConnectionObserver observer = requireNonNull(transportObserver.onNewConnection());\n         assignConnectionObserver(channel, observer);\n-        channel.pipeline().addLast(new TransportObserverChannelHandler(observer));\n+        final ChannelPipeline pipeline = channel.pipeline();\n+        pipeline.addLast(new TransportObserverHandler(observer, secureSide));\n     }\n \n-    private static final class TransportObserverChannelHandler extends ChannelDuplexHandler {\n+    private static final class TransportObserverHandler extends ChannelDuplexHandler {\n         private final ConnectionObserver observer;\n+        private final SecureSide secure;\n+        private boolean handshakeStarted;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjY0OTExOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMTo0Mzo0N1rOG0lD8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMTo0Mzo0N1rOG0lD8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4NjM1Mg==", "bodyText": "Set this before sending the callback to account for reentrancy?", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r457786352", "createdAt": "2020-07-21T01:43:47Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -16,46 +16,93 @@\n package io.servicetalk.transport.netty.internal;\n \n import io.servicetalk.transport.api.ConnectionObserver;\n+import io.servicetalk.transport.api.ConnectionObserver.SecurityHandshakeObserver;\n import io.servicetalk.transport.api.TransportObserver;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufHolder;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPipeline;\n import io.netty.channel.ChannelPromise;\n+import io.netty.handler.ssl.SslHandshakeCompletionEvent;\n \n+import javax.net.ssl.SSLSession;\n+\n+import static io.servicetalk.transport.netty.internal.NettyPipelineSslUtils.extractSslSession;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionError;\n import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionObserver;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.securityHandshakeObserver;\n import static java.util.Objects.requireNonNull;\n \n /**\n  * A {@link ChannelInitializer} that registers a {@link ConnectionObserver} for all channels.\n  */\n public final class TransportObserverInitializer implements ChannelInitializer {\n \n+    /**\n+     * Tells which side is using secure connection.\n+     */\n+    public enum SecureSide {\n+        CLIENT,\n+        SERVER,\n+        NONE\n+    }\n+\n     private final TransportObserver transportObserver;\n+    private final SecureSide secureSide;\n \n     /**\n      * Creates a new instance.\n      *\n      * @param transportObserver {@link TransportObserver} to initialize for the channel\n+     * @param secureSide tells which side is using secure connection\n      */\n-    public TransportObserverInitializer(final TransportObserver transportObserver) {\n+    public TransportObserverInitializer(final TransportObserver transportObserver, final SecureSide secureSide) {\n         this.transportObserver = requireNonNull(transportObserver);\n+        this.secureSide = secureSide;\n     }\n \n     @Override\n     public void init(final Channel channel) {\n         final ConnectionObserver observer = requireNonNull(transportObserver.onNewConnection());\n         assignConnectionObserver(channel, observer);\n-        channel.pipeline().addLast(new TransportObserverChannelHandler(observer));\n+        final ChannelPipeline pipeline = channel.pipeline();\n+        pipeline.addLast(new TransportObserverHandler(observer, secureSide));\n     }\n \n-    private static final class TransportObserverChannelHandler extends ChannelDuplexHandler {\n+    private static final class TransportObserverHandler extends ChannelDuplexHandler {\n         private final ConnectionObserver observer;\n+        private final SecureSide secure;\n+        private boolean handshakeStarted;\n \n-        TransportObserverChannelHandler(final ConnectionObserver observer) {\n+        TransportObserverHandler(final ConnectionObserver observer, final SecureSide secure) {\n             this.observer = observer;\n+            this.secure = secure;\n+        }\n+\n+        @Override\n+        public void handlerAdded(final ChannelHandlerContext ctx) {\n+            if (secure != SecureSide.NONE && ctx.channel().isActive()) {\n+                reportSecurityHandshakeStarting(ctx.channel());\n+            }\n+        }\n+\n+        @Override\n+        public void channelActive(final ChannelHandlerContext ctx) {\n+            if (secure == SecureSide.CLIENT) {\n+                reportSecurityHandshakeStarting(ctx.channel());\n+            }\n+            ctx.fireChannelActive();\n+        }\n+\n+        void reportSecurityHandshakeStarting(final Channel channel) {\n+            if (!handshakeStarted) {\n+                TransportObserverUtils.reportSecurityHandshakeStarting(channel);\n+                handshakeStarted = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjY1MTkzOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMTo0NToxNlrOG0lFmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxOTo1OTozOVrOG1HpjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4Njc3Ng==", "bodyText": "Why is the condition in handlerAdded and channelActive different?\nIf this is valid, then add a comment to explain the same.", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r457786776", "createdAt": "2020-07-21T01:45:16Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -16,46 +16,93 @@\n package io.servicetalk.transport.netty.internal;\n \n import io.servicetalk.transport.api.ConnectionObserver;\n+import io.servicetalk.transport.api.ConnectionObserver.SecurityHandshakeObserver;\n import io.servicetalk.transport.api.TransportObserver;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufHolder;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPipeline;\n import io.netty.channel.ChannelPromise;\n+import io.netty.handler.ssl.SslHandshakeCompletionEvent;\n \n+import javax.net.ssl.SSLSession;\n+\n+import static io.servicetalk.transport.netty.internal.NettyPipelineSslUtils.extractSslSession;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionError;\n import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionObserver;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.securityHandshakeObserver;\n import static java.util.Objects.requireNonNull;\n \n /**\n  * A {@link ChannelInitializer} that registers a {@link ConnectionObserver} for all channels.\n  */\n public final class TransportObserverInitializer implements ChannelInitializer {\n \n+    /**\n+     * Tells which side is using secure connection.\n+     */\n+    public enum SecureSide {\n+        CLIENT,\n+        SERVER,\n+        NONE\n+    }\n+\n     private final TransportObserver transportObserver;\n+    private final SecureSide secureSide;\n \n     /**\n      * Creates a new instance.\n      *\n      * @param transportObserver {@link TransportObserver} to initialize for the channel\n+     * @param secureSide tells which side is using secure connection\n      */\n-    public TransportObserverInitializer(final TransportObserver transportObserver) {\n+    public TransportObserverInitializer(final TransportObserver transportObserver, final SecureSide secureSide) {\n         this.transportObserver = requireNonNull(transportObserver);\n+        this.secureSide = secureSide;\n     }\n \n     @Override\n     public void init(final Channel channel) {\n         final ConnectionObserver observer = requireNonNull(transportObserver.onNewConnection());\n         assignConnectionObserver(channel, observer);\n-        channel.pipeline().addLast(new TransportObserverChannelHandler(observer));\n+        final ChannelPipeline pipeline = channel.pipeline();\n+        pipeline.addLast(new TransportObserverHandler(observer, secureSide));\n     }\n \n-    private static final class TransportObserverChannelHandler extends ChannelDuplexHandler {\n+    private static final class TransportObserverHandler extends ChannelDuplexHandler {\n         private final ConnectionObserver observer;\n+        private final SecureSide secure;\n+        private boolean handshakeStarted;\n \n-        TransportObserverChannelHandler(final ConnectionObserver observer) {\n+        TransportObserverHandler(final ConnectionObserver observer, final SecureSide secure) {\n             this.observer = observer;\n+            this.secure = secure;\n+        }\n+\n+        @Override\n+        public void handlerAdded(final ChannelHandlerContext ctx) {\n+            if (secure != SecureSide.NONE && ctx.channel().isActive()) {\n+                reportSecurityHandshakeStarting(ctx.channel());\n+            }\n+        }\n+\n+        @Override\n+        public void channelActive(final ChannelHandlerContext ctx) {\n+            if (secure == SecureSide.CLIENT) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM1MzAzNg==", "bodyText": "That was my overthinking :) Channel is already active when server adds a handler. Therefore, there is no need to expect channelActive on the server-side. But we can make conditions the same with no side-effects. Thanks!", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r458353036", "createdAt": "2020-07-21T19:59:39Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -16,46 +16,93 @@\n package io.servicetalk.transport.netty.internal;\n \n import io.servicetalk.transport.api.ConnectionObserver;\n+import io.servicetalk.transport.api.ConnectionObserver.SecurityHandshakeObserver;\n import io.servicetalk.transport.api.TransportObserver;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufHolder;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPipeline;\n import io.netty.channel.ChannelPromise;\n+import io.netty.handler.ssl.SslHandshakeCompletionEvent;\n \n+import javax.net.ssl.SSLSession;\n+\n+import static io.servicetalk.transport.netty.internal.NettyPipelineSslUtils.extractSslSession;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionError;\n import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionObserver;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.securityHandshakeObserver;\n import static java.util.Objects.requireNonNull;\n \n /**\n  * A {@link ChannelInitializer} that registers a {@link ConnectionObserver} for all channels.\n  */\n public final class TransportObserverInitializer implements ChannelInitializer {\n \n+    /**\n+     * Tells which side is using secure connection.\n+     */\n+    public enum SecureSide {\n+        CLIENT,\n+        SERVER,\n+        NONE\n+    }\n+\n     private final TransportObserver transportObserver;\n+    private final SecureSide secureSide;\n \n     /**\n      * Creates a new instance.\n      *\n      * @param transportObserver {@link TransportObserver} to initialize for the channel\n+     * @param secureSide tells which side is using secure connection\n      */\n-    public TransportObserverInitializer(final TransportObserver transportObserver) {\n+    public TransportObserverInitializer(final TransportObserver transportObserver, final SecureSide secureSide) {\n         this.transportObserver = requireNonNull(transportObserver);\n+        this.secureSide = secureSide;\n     }\n \n     @Override\n     public void init(final Channel channel) {\n         final ConnectionObserver observer = requireNonNull(transportObserver.onNewConnection());\n         assignConnectionObserver(channel, observer);\n-        channel.pipeline().addLast(new TransportObserverChannelHandler(observer));\n+        final ChannelPipeline pipeline = channel.pipeline();\n+        pipeline.addLast(new TransportObserverHandler(observer, secureSide));\n     }\n \n-    private static final class TransportObserverChannelHandler extends ChannelDuplexHandler {\n+    private static final class TransportObserverHandler extends ChannelDuplexHandler {\n         private final ConnectionObserver observer;\n+        private final SecureSide secure;\n+        private boolean handshakeStarted;\n \n-        TransportObserverChannelHandler(final ConnectionObserver observer) {\n+        TransportObserverHandler(final ConnectionObserver observer, final SecureSide secure) {\n             this.observer = observer;\n+            this.secure = secure;\n+        }\n+\n+        @Override\n+        public void handlerAdded(final ChannelHandlerContext ctx) {\n+            if (secure != SecureSide.NONE && ctx.channel().isActive()) {\n+                reportSecurityHandshakeStarting(ctx.channel());\n+            }\n+        }\n+\n+        @Override\n+        public void channelActive(final ChannelHandlerContext ctx) {\n+            if (secure == SecureSide.CLIENT) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4Njc3Ng=="}, "originalCommit": {"oid": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjY2NDAyOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMTo1MTo0MlrOG0lMzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMTo0OTo0NFrOG1LEBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4ODYyMg==", "bodyText": "We are already intercepting this event and extract SSL session in DefaultNettyConnection, can we do these callbacks there instead of adding another handler?", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r457788622", "createdAt": "2020-07-21T01:51:42Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -92,4 +139,32 @@ public void flush(final ChannelHandlerContext ctx) {\n             ctx.flush();\n         }\n     }\n+\n+    @Sharable\n+    static final class SecurityHandshakeObserverHandler extends ChannelDuplexHandler {\n+\n+        static final SecurityHandshakeObserverHandler INSTANCE = new SecurityHandshakeObserverHandler();\n+\n+        private SecurityHandshakeObserverHandler() {\n+            // Singleton\n+        }\n+\n+        @Override\n+        public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt) {\n+            if (evt instanceof SslHandshakeCompletionEvent) {\n+                final Channel channel = ctx.channel();\n+                final SecurityHandshakeObserver observer = securityHandshakeObserver(channel);\n+                assert observer != null;\n+                final SSLSession sslSession = extractSslSession(ctx.pipeline(), (SslHandshakeCompletionEvent) evt,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM1NTE0MQ==", "bodyText": "There is H2ParentConnectionContext that also performs a similar logic, but this class is from servicetalk-http-netty.\nThe goal to have SecurityHandshakeObserverHandler is to encapsulate everything related to transport observer in servicetalk-transport-netty-internal. For users who are interested in observability, it looks like small and acceptable overhead.", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r458355141", "createdAt": "2020-07-21T20:03:47Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -92,4 +139,32 @@ public void flush(final ChannelHandlerContext ctx) {\n             ctx.flush();\n         }\n     }\n+\n+    @Sharable\n+    static final class SecurityHandshakeObserverHandler extends ChannelDuplexHandler {\n+\n+        static final SecurityHandshakeObserverHandler INSTANCE = new SecurityHandshakeObserverHandler();\n+\n+        private SecurityHandshakeObserverHandler() {\n+            // Singleton\n+        }\n+\n+        @Override\n+        public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt) {\n+            if (evt instanceof SslHandshakeCompletionEvent) {\n+                final Channel channel = ctx.channel();\n+                final SecurityHandshakeObserver observer = securityHandshakeObserver(channel);\n+                assert observer != null;\n+                final SSLSession sslSession = extractSslSession(ctx.pipeline(), (SslHandshakeCompletionEvent) evt,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4ODYyMg=="}, "originalCommit": {"oid": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwODk2Nw==", "bodyText": "Moved this logic to NettyPipelineSslUtils.extractSslSession instead: e118cd1", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r458408967", "createdAt": "2020-07-21T21:49:44Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -92,4 +139,32 @@ public void flush(final ChannelHandlerContext ctx) {\n             ctx.flush();\n         }\n     }\n+\n+    @Sharable\n+    static final class SecurityHandshakeObserverHandler extends ChannelDuplexHandler {\n+\n+        static final SecurityHandshakeObserverHandler INSTANCE = new SecurityHandshakeObserverHandler();\n+\n+        private SecurityHandshakeObserverHandler() {\n+            // Singleton\n+        }\n+\n+        @Override\n+        public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt) {\n+            if (evt instanceof SslHandshakeCompletionEvent) {\n+                final Channel channel = ctx.channel();\n+                final SecurityHandshakeObserver observer = securityHandshakeObserver(channel);\n+                assert observer != null;\n+                final SSLSession sslSession = extractSslSession(ctx.pipeline(), (SslHandshakeCompletionEvent) evt,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4ODYyMg=="}, "originalCommit": {"oid": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjY3MjY0OnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMTo1NjowOVrOG0lR-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMTo1NjowOVrOG0lR-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4OTk0NQ==", "bodyText": "The name is confusing since TLS can not be on one side.\nI think this enum is overloaded to give two piece of information:\n\nWhether TLS is enabled.\nWhether this initializer is used by client/server.\n\nTo avoid confusion caused by this overload, I would suggest splitting this into two fields:\n\nboolean isSecure\nboolean forClient\n\nThis is similar to what we do for security config.", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r457789945", "createdAt": "2020-07-21T01:56:09Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -16,46 +16,93 @@\n package io.servicetalk.transport.netty.internal;\n \n import io.servicetalk.transport.api.ConnectionObserver;\n+import io.servicetalk.transport.api.ConnectionObserver.SecurityHandshakeObserver;\n import io.servicetalk.transport.api.TransportObserver;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufHolder;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPipeline;\n import io.netty.channel.ChannelPromise;\n+import io.netty.handler.ssl.SslHandshakeCompletionEvent;\n \n+import javax.net.ssl.SSLSession;\n+\n+import static io.servicetalk.transport.netty.internal.NettyPipelineSslUtils.extractSslSession;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionError;\n import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionObserver;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.securityHandshakeObserver;\n import static java.util.Objects.requireNonNull;\n \n /**\n  * A {@link ChannelInitializer} that registers a {@link ConnectionObserver} for all channels.\n  */\n public final class TransportObserverInitializer implements ChannelInitializer {\n \n+    /**\n+     * Tells which side is using secure connection.\n+     */\n+    public enum SecureSide {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDkyMzEzOnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/NettyPipelineSslUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMzo1OToyMlrOG1N71Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMzo1OToyMlrOG1N71Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ1NjAyMQ==", "bodyText": "Since extractSslSession sounds like a method with no side effects; I would suggest either renaming the method or create an overload which explicitly says that it emits observer events.", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r458456021", "createdAt": "2020-07-21T23:59:22Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/NettyPipelineSslUtils.java", "diffHunk": "@@ -55,17 +61,33 @@ public static boolean isSslEnabled(ChannelPipeline pipeline) {\n     public static SSLSession extractSslSession(ChannelPipeline pipeline,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "533d53f6b39ec010f3e6040f0af825cc605b7773"}, "originalPosition": 21}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2515, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}