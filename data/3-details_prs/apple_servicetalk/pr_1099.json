{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUyNjY1ODg4", "number": 1099, "title": "Security handshake observability", "bodyText": "Motivation:\nProvide visibility into security handshake events: when it's started and\nwhen it's complete or failed.\nModifications:\n\nAdd ConnectionObserver.SecurityHandshakeObserver;\nEnhance TransportObserverInitializer to capture when security\nhandshake starts;\nReport the result of SSL handshake from\nNettyPipelineSslUtils.extractSslSession;\nTest observability of successful security handshakes;\nTest observability of failed security handshakes;\n\nResult:\nUsers can observe when security handshake starts and completes.", "createdAt": "2020-07-19T17:06:17Z", "url": "https://github.com/apple/servicetalk/pull/1099", "merged": true, "mergeCommit": {"oid": "a140c0f75ac2164dc73f29cdff9cde5d45136cc6"}, "closed": true, "closedAt": "2020-07-22T01:26:24Z", "author": {"login": "idelpivnitskiy"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc14CWRgH2gAyNDUyNjY1ODg4OjA0MjgxY2IxYzRkZWIzOTQyYWIxNGFiYzUwZDIyZTY4N2I1NDRlMGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc3QS7EAH2gAyNDUyNjY1ODg4OmZiNGZmYTRlMjg0NTVkODg4MzUxYzhmNjU1MmFjYWJmZTllNDAxZWE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "04281cb1c4deb3942ab14abc50d22e687b544e0f", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/04281cb1c4deb3942ab14abc50d22e687b544e0f", "committedDate": "2020-07-17T18:21:19Z", "message": "Implement SecurityHandshakeObserver"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47153596b8e58a8ec776d0f7c4dc1dd061e8add5", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/47153596b8e58a8ec776d0f7c4dc1dd061e8add5", "committedDate": "2020-07-17T18:21:33Z", "message": "Test SecurityHandshakeObserver"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e56af97bc5465a1a4a309b33648e31218ba7c84d", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/e56af97bc5465a1a4a309b33648e31218ba7c84d", "committedDate": "2020-07-17T18:54:28Z", "message": "Test SecurityHandshakeObserver in a separate class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f70c7cece44149c9b5f1bec0c38c2b00c9c1321f", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/f70c7cece44149c9b5f1bec0c38c2b00c9c1321f", "committedDate": "2020-07-18T02:06:59Z", "message": "Add SecureTcpTransportObserverErrorsTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/e72b73f6cb65ed565f69b95ab73b117d0fb2f779", "committedDate": "2020-07-18T02:10:35Z", "message": "Fix checkstyle errors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxOTMzMDAz", "url": "https://github.com/apple/servicetalk/pull/1099#pullrequestreview-451933003", "createdAt": "2020-07-20T20:25:17Z", "commit": {"oid": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMDoyNToxN1rOG0eAtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMTo1NjowOVrOG0lR-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY3MDgzNg==", "bodyText": "nit: Rename observable to observeSsl", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r457670836", "createdAt": "2020-07-20T20:25:17Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/DeferSslHandler.java", "diffHunk": "@@ -20,22 +20,29 @@\n import io.netty.channel.ChannelHandler;\n import io.netty.handler.ssl.SslHandler;\n \n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.reportSecurityHandshakeStarting;\n+\n /**\n  * A {@link ChannelHandler} that holds a place in a pipeline, allowing us to defer adding the {@link SslHandler}.\n  */\n-public class DeferSslHandler extends ChannelDuplexHandler {\n+public final class DeferSslHandler extends ChannelDuplexHandler {\n     private final Channel channel;\n     private final SslHandler handler;\n+    private final boolean observable;\n \n-    DeferSslHandler(final Channel channel, final SslHandler handler) {\n+    DeferSslHandler(final Channel channel, final SslHandler handler, final boolean observable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4NjIzMw==", "bodyText": "rename to handshakeStartNotified to indicate that this does not reflect handshake start state but the notification to the observer.", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r457786233", "createdAt": "2020-07-21T01:43:22Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -16,46 +16,93 @@\n package io.servicetalk.transport.netty.internal;\n \n import io.servicetalk.transport.api.ConnectionObserver;\n+import io.servicetalk.transport.api.ConnectionObserver.SecurityHandshakeObserver;\n import io.servicetalk.transport.api.TransportObserver;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufHolder;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPipeline;\n import io.netty.channel.ChannelPromise;\n+import io.netty.handler.ssl.SslHandshakeCompletionEvent;\n \n+import javax.net.ssl.SSLSession;\n+\n+import static io.servicetalk.transport.netty.internal.NettyPipelineSslUtils.extractSslSession;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionError;\n import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionObserver;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.securityHandshakeObserver;\n import static java.util.Objects.requireNonNull;\n \n /**\n  * A {@link ChannelInitializer} that registers a {@link ConnectionObserver} for all channels.\n  */\n public final class TransportObserverInitializer implements ChannelInitializer {\n \n+    /**\n+     * Tells which side is using secure connection.\n+     */\n+    public enum SecureSide {\n+        CLIENT,\n+        SERVER,\n+        NONE\n+    }\n+\n     private final TransportObserver transportObserver;\n+    private final SecureSide secureSide;\n \n     /**\n      * Creates a new instance.\n      *\n      * @param transportObserver {@link TransportObserver} to initialize for the channel\n+     * @param secureSide tells which side is using secure connection\n      */\n-    public TransportObserverInitializer(final TransportObserver transportObserver) {\n+    public TransportObserverInitializer(final TransportObserver transportObserver, final SecureSide secureSide) {\n         this.transportObserver = requireNonNull(transportObserver);\n+        this.secureSide = secureSide;\n     }\n \n     @Override\n     public void init(final Channel channel) {\n         final ConnectionObserver observer = requireNonNull(transportObserver.onNewConnection());\n         assignConnectionObserver(channel, observer);\n-        channel.pipeline().addLast(new TransportObserverChannelHandler(observer));\n+        final ChannelPipeline pipeline = channel.pipeline();\n+        pipeline.addLast(new TransportObserverHandler(observer, secureSide));\n     }\n \n-    private static final class TransportObserverChannelHandler extends ChannelDuplexHandler {\n+    private static final class TransportObserverHandler extends ChannelDuplexHandler {\n         private final ConnectionObserver observer;\n+        private final SecureSide secure;\n+        private boolean handshakeStarted;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4NjM1Mg==", "bodyText": "Set this before sending the callback to account for reentrancy?", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r457786352", "createdAt": "2020-07-21T01:43:47Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -16,46 +16,93 @@\n package io.servicetalk.transport.netty.internal;\n \n import io.servicetalk.transport.api.ConnectionObserver;\n+import io.servicetalk.transport.api.ConnectionObserver.SecurityHandshakeObserver;\n import io.servicetalk.transport.api.TransportObserver;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufHolder;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPipeline;\n import io.netty.channel.ChannelPromise;\n+import io.netty.handler.ssl.SslHandshakeCompletionEvent;\n \n+import javax.net.ssl.SSLSession;\n+\n+import static io.servicetalk.transport.netty.internal.NettyPipelineSslUtils.extractSslSession;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionError;\n import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionObserver;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.securityHandshakeObserver;\n import static java.util.Objects.requireNonNull;\n \n /**\n  * A {@link ChannelInitializer} that registers a {@link ConnectionObserver} for all channels.\n  */\n public final class TransportObserverInitializer implements ChannelInitializer {\n \n+    /**\n+     * Tells which side is using secure connection.\n+     */\n+    public enum SecureSide {\n+        CLIENT,\n+        SERVER,\n+        NONE\n+    }\n+\n     private final TransportObserver transportObserver;\n+    private final SecureSide secureSide;\n \n     /**\n      * Creates a new instance.\n      *\n      * @param transportObserver {@link TransportObserver} to initialize for the channel\n+     * @param secureSide tells which side is using secure connection\n      */\n-    public TransportObserverInitializer(final TransportObserver transportObserver) {\n+    public TransportObserverInitializer(final TransportObserver transportObserver, final SecureSide secureSide) {\n         this.transportObserver = requireNonNull(transportObserver);\n+        this.secureSide = secureSide;\n     }\n \n     @Override\n     public void init(final Channel channel) {\n         final ConnectionObserver observer = requireNonNull(transportObserver.onNewConnection());\n         assignConnectionObserver(channel, observer);\n-        channel.pipeline().addLast(new TransportObserverChannelHandler(observer));\n+        final ChannelPipeline pipeline = channel.pipeline();\n+        pipeline.addLast(new TransportObserverHandler(observer, secureSide));\n     }\n \n-    private static final class TransportObserverChannelHandler extends ChannelDuplexHandler {\n+    private static final class TransportObserverHandler extends ChannelDuplexHandler {\n         private final ConnectionObserver observer;\n+        private final SecureSide secure;\n+        private boolean handshakeStarted;\n \n-        TransportObserverChannelHandler(final ConnectionObserver observer) {\n+        TransportObserverHandler(final ConnectionObserver observer, final SecureSide secure) {\n             this.observer = observer;\n+            this.secure = secure;\n+        }\n+\n+        @Override\n+        public void handlerAdded(final ChannelHandlerContext ctx) {\n+            if (secure != SecureSide.NONE && ctx.channel().isActive()) {\n+                reportSecurityHandshakeStarting(ctx.channel());\n+            }\n+        }\n+\n+        @Override\n+        public void channelActive(final ChannelHandlerContext ctx) {\n+            if (secure == SecureSide.CLIENT) {\n+                reportSecurityHandshakeStarting(ctx.channel());\n+            }\n+            ctx.fireChannelActive();\n+        }\n+\n+        void reportSecurityHandshakeStarting(final Channel channel) {\n+            if (!handshakeStarted) {\n+                TransportObserverUtils.reportSecurityHandshakeStarting(channel);\n+                handshakeStarted = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4Njc3Ng==", "bodyText": "Why is the condition in handlerAdded and channelActive different?\nIf this is valid, then add a comment to explain the same.", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r457786776", "createdAt": "2020-07-21T01:45:16Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -16,46 +16,93 @@\n package io.servicetalk.transport.netty.internal;\n \n import io.servicetalk.transport.api.ConnectionObserver;\n+import io.servicetalk.transport.api.ConnectionObserver.SecurityHandshakeObserver;\n import io.servicetalk.transport.api.TransportObserver;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufHolder;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPipeline;\n import io.netty.channel.ChannelPromise;\n+import io.netty.handler.ssl.SslHandshakeCompletionEvent;\n \n+import javax.net.ssl.SSLSession;\n+\n+import static io.servicetalk.transport.netty.internal.NettyPipelineSslUtils.extractSslSession;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionError;\n import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionObserver;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.securityHandshakeObserver;\n import static java.util.Objects.requireNonNull;\n \n /**\n  * A {@link ChannelInitializer} that registers a {@link ConnectionObserver} for all channels.\n  */\n public final class TransportObserverInitializer implements ChannelInitializer {\n \n+    /**\n+     * Tells which side is using secure connection.\n+     */\n+    public enum SecureSide {\n+        CLIENT,\n+        SERVER,\n+        NONE\n+    }\n+\n     private final TransportObserver transportObserver;\n+    private final SecureSide secureSide;\n \n     /**\n      * Creates a new instance.\n      *\n      * @param transportObserver {@link TransportObserver} to initialize for the channel\n+     * @param secureSide tells which side is using secure connection\n      */\n-    public TransportObserverInitializer(final TransportObserver transportObserver) {\n+    public TransportObserverInitializer(final TransportObserver transportObserver, final SecureSide secureSide) {\n         this.transportObserver = requireNonNull(transportObserver);\n+        this.secureSide = secureSide;\n     }\n \n     @Override\n     public void init(final Channel channel) {\n         final ConnectionObserver observer = requireNonNull(transportObserver.onNewConnection());\n         assignConnectionObserver(channel, observer);\n-        channel.pipeline().addLast(new TransportObserverChannelHandler(observer));\n+        final ChannelPipeline pipeline = channel.pipeline();\n+        pipeline.addLast(new TransportObserverHandler(observer, secureSide));\n     }\n \n-    private static final class TransportObserverChannelHandler extends ChannelDuplexHandler {\n+    private static final class TransportObserverHandler extends ChannelDuplexHandler {\n         private final ConnectionObserver observer;\n+        private final SecureSide secure;\n+        private boolean handshakeStarted;\n \n-        TransportObserverChannelHandler(final ConnectionObserver observer) {\n+        TransportObserverHandler(final ConnectionObserver observer, final SecureSide secure) {\n             this.observer = observer;\n+            this.secure = secure;\n+        }\n+\n+        @Override\n+        public void handlerAdded(final ChannelHandlerContext ctx) {\n+            if (secure != SecureSide.NONE && ctx.channel().isActive()) {\n+                reportSecurityHandshakeStarting(ctx.channel());\n+            }\n+        }\n+\n+        @Override\n+        public void channelActive(final ChannelHandlerContext ctx) {\n+            if (secure == SecureSide.CLIENT) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4ODYyMg==", "bodyText": "We are already intercepting this event and extract SSL session in DefaultNettyConnection, can we do these callbacks there instead of adding another handler?", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r457788622", "createdAt": "2020-07-21T01:51:42Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -92,4 +139,32 @@ public void flush(final ChannelHandlerContext ctx) {\n             ctx.flush();\n         }\n     }\n+\n+    @Sharable\n+    static final class SecurityHandshakeObserverHandler extends ChannelDuplexHandler {\n+\n+        static final SecurityHandshakeObserverHandler INSTANCE = new SecurityHandshakeObserverHandler();\n+\n+        private SecurityHandshakeObserverHandler() {\n+            // Singleton\n+        }\n+\n+        @Override\n+        public void userEventTriggered(final ChannelHandlerContext ctx, final Object evt) {\n+            if (evt instanceof SslHandshakeCompletionEvent) {\n+                final Channel channel = ctx.channel();\n+                final SecurityHandshakeObserver observer = securityHandshakeObserver(channel);\n+                assert observer != null;\n+                final SSLSession sslSession = extractSslSession(ctx.pipeline(), (SslHandshakeCompletionEvent) evt,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4OTk0NQ==", "bodyText": "The name is confusing since TLS can not be on one side.\nI think this enum is overloaded to give two piece of information:\n\nWhether TLS is enabled.\nWhether this initializer is used by client/server.\n\nTo avoid confusion caused by this overload, I would suggest splitting this into two fields:\n\nboolean isSecure\nboolean forClient\n\nThis is similar to what we do for security config.", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r457789945", "createdAt": "2020-07-21T01:56:09Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/TransportObserverInitializer.java", "diffHunk": "@@ -16,46 +16,93 @@\n package io.servicetalk.transport.netty.internal;\n \n import io.servicetalk.transport.api.ConnectionObserver;\n+import io.servicetalk.transport.api.ConnectionObserver.SecurityHandshakeObserver;\n import io.servicetalk.transport.api.TransportObserver;\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufHolder;\n import io.netty.channel.Channel;\n import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandler.Sharable;\n import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPipeline;\n import io.netty.channel.ChannelPromise;\n+import io.netty.handler.ssl.SslHandshakeCompletionEvent;\n \n+import javax.net.ssl.SSLSession;\n+\n+import static io.servicetalk.transport.netty.internal.NettyPipelineSslUtils.extractSslSession;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionError;\n import static io.servicetalk.transport.netty.internal.TransportObserverUtils.assignConnectionObserver;\n+import static io.servicetalk.transport.netty.internal.TransportObserverUtils.securityHandshakeObserver;\n import static java.util.Objects.requireNonNull;\n \n /**\n  * A {@link ChannelInitializer} that registers a {@link ConnectionObserver} for all channels.\n  */\n public final class TransportObserverInitializer implements ChannelInitializer {\n \n+    /**\n+     * Tells which side is using secure connection.\n+     */\n+    public enum SecureSide {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e72b73f6cb65ed565f69b95ab73b117d0fb2f779"}, "originalPosition": 33}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c0481484501cc689842d0902bf1a9895ae516a8", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/5c0481484501cc689842d0902bf1a9895ae516a8", "committedDate": "2020-07-21T18:40:03Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b3518173bf28915537ebe5f9117d0531fbfab40", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/8b3518173bf28915537ebe5f9117d0531fbfab40", "committedDate": "2020-07-21T19:56:28Z", "message": "Fix a test that fails on JDK8"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc619f8fbe25623f874ce9b3e73811a593ceeda0", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/cc619f8fbe25623f874ce9b3e73811a593ceeda0", "committedDate": "2020-07-21T20:21:17Z", "message": "Revert `final` from DeferSslHandler, otherwise we can not mock it"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e118cd1c3dbf862f5d4a4e8fe1467bffdfdeb7db", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/e118cd1c3dbf862f5d4a4e8fe1467bffdfdeb7db", "committedDate": "2020-07-21T21:43:00Z", "message": "Remove SecurityHandshakeObserverHandler and add observability hooks to NettyPipelineSslUtils.extractSslSession"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "533d53f6b39ec010f3e6040f0af825cc605b7773", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/533d53f6b39ec010f3e6040f0af825cc605b7773", "committedDate": "2020-07-21T21:48:09Z", "message": "Small fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyOTA3NTc4", "url": "https://github.com/apple/servicetalk/pull/1099#pullrequestreview-452907578", "createdAt": "2020-07-21T23:59:21Z", "commit": {"oid": "533d53f6b39ec010f3e6040f0af825cc605b7773"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMzo1OToyMlrOG1N71Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMzo1OToyMlrOG1N71Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ1NjAyMQ==", "bodyText": "Since extractSslSession sounds like a method with no side effects; I would suggest either renaming the method or create an overload which explicitly says that it emits observer events.", "url": "https://github.com/apple/servicetalk/pull/1099#discussion_r458456021", "createdAt": "2020-07-21T23:59:22Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/NettyPipelineSslUtils.java", "diffHunk": "@@ -55,17 +61,33 @@ public static boolean isSslEnabled(ChannelPipeline pipeline) {\n     public static SSLSession extractSslSession(ChannelPipeline pipeline,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "533d53f6b39ec010f3e6040f0af825cc605b7773"}, "originalPosition": 21}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb4ffa4e28455d888351c8f6552acabfe9e401ea", "author": {"user": {"login": "idelpivnitskiy", "name": "Idel Pivnitskiy"}}, "url": "https://github.com/apple/servicetalk/commit/fb4ffa4e28455d888351c8f6552acabfe9e401ea", "committedDate": "2020-07-22T01:11:04Z", "message": "Rename NettyPipelineSslUtils.extractSslSession"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3420, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}