{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzMzkzNjUz", "number": 1014, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDoyNzoxMlrODxz0_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMToxODoxOVrODy3O9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTU1OTY3OnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDoyNzoxMlrOGFfn4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMTowNDo1OFrOGFg3tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNDE3OQ==", "bodyText": "shouldn't we release in a finally block ?", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r408414179", "createdAt": "2020-04-14T20:27:12Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java", "diffHunk": "@@ -222,23 +223,31 @@ private void enqueueAndDrain(Object item) {\n             assert s != null;\n \n             if (!pending.offer(item)) {\n-                QueueFullException exception = new QueueFullException(\"pending\");\n-                if (item instanceof TerminalNotification) {\n-                    LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n-                    throw exception;\n-                } else {\n-                    onError0(exception, true, true);\n-                }\n+                enqueueAndDrainFail(item);\n             }\n             drainPending(s);\n         }\n \n         private void drainPending(Subscription subscription) {\n-            long drainedCount = drainSingleConsumerQueue(pending, this::sendToTarget, emittingUpdater, this);\n-            if (drainedCount != 0) {\n+            long drainCount = 0;\n+            for (;;) {\n+                if (!acquirePendingLock(emittingUpdater, this)) {\n+                    break;\n+                }\n+                Object t;\n+                while ((t = pending.poll()) != null) {\n+                    ++drainCount;\n+                    sendToTarget(t);\n+                }\n+                if (releasePendingLock(emittingUpdater, this)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9dfa3d2b655dc4d7d1201fda62526237960d5c7"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQzNDYxNA==", "bodyText": "good point ... let me make this more robust.", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r408434614", "createdAt": "2020-04-14T21:04:58Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java", "diffHunk": "@@ -222,23 +223,31 @@ private void enqueueAndDrain(Object item) {\n             assert s != null;\n \n             if (!pending.offer(item)) {\n-                QueueFullException exception = new QueueFullException(\"pending\");\n-                if (item instanceof TerminalNotification) {\n-                    LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n-                    throw exception;\n-                } else {\n-                    onError0(exception, true, true);\n-                }\n+                enqueueAndDrainFail(item);\n             }\n             drainPending(s);\n         }\n \n         private void drainPending(Subscription subscription) {\n-            long drainedCount = drainSingleConsumerQueue(pending, this::sendToTarget, emittingUpdater, this);\n-            if (drainedCount != 0) {\n+            long drainCount = 0;\n+            for (;;) {\n+                if (!acquirePendingLock(emittingUpdater, this)) {\n+                    break;\n+                }\n+                Object t;\n+                while ((t = pending.poll()) != null) {\n+                    ++drainCount;\n+                    sendToTarget(t);\n+                }\n+                if (releasePendingLock(emittingUpdater, this)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxNDE3OQ=="}, "originalCommit": {"oid": "e9dfa3d2b655dc4d7d1201fda62526237960d5c7"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNzUyMTY4OnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTo0ODowMlrOGFyIgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQyMjo0ODo1NVrOGGOTag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxNzQ0MA==", "bodyText": "nit: should we use addSuppressed(...) when delayedCause != null", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r408717440", "createdAt": "2020-04-15T09:48:02Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java", "diffHunk": "@@ -222,29 +224,58 @@ private void enqueueAndDrain(Object item) {\n             assert s != null;\n \n             if (!pending.offer(item)) {\n-                QueueFullException exception = new QueueFullException(\"pending\");\n-                if (item instanceof TerminalNotification) {\n-                    LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n-                    throw exception;\n-                } else {\n-                    onError0(exception, true, true);\n-                }\n+                enqueueAndDrainFail(item);\n             }\n             drainPending(s);\n         }\n \n         private void drainPending(Subscription subscription) {\n-            long drainedCount = drainSingleConsumerQueue(pending, this::sendToTarget, emittingUpdater, this);\n-            if (drainedCount != 0) {\n+            long drainCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        ++drainCount;\n+                        try {\n+                            sendToTarget(t);\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a525a8eae60877e0a37fa66f020c67588e0fbe7"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3ODk4Ng==", "bodyText": "lets discuss on #1011 (comment)", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r409178986", "createdAt": "2020-04-15T22:48:55Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java", "diffHunk": "@@ -222,29 +224,58 @@ private void enqueueAndDrain(Object item) {\n             assert s != null;\n \n             if (!pending.offer(item)) {\n-                QueueFullException exception = new QueueFullException(\"pending\");\n-                if (item instanceof TerminalNotification) {\n-                    LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n-                    throw exception;\n-                } else {\n-                    onError0(exception, true, true);\n-                }\n+                enqueueAndDrainFail(item);\n             }\n             drainPending(s);\n         }\n \n         private void drainPending(Subscription subscription) {\n-            long drainedCount = drainSingleConsumerQueue(pending, this::sendToTarget, emittingUpdater, this);\n-            if (drainedCount != 0) {\n+            long drainCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        ++drainCount;\n+                        try {\n+                            sendToTarget(t);\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxNzQ0MA=="}, "originalCommit": {"oid": "8a525a8eae60877e0a37fa66f020c67588e0fbe7"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjYwMDc1OnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMToxNzoyMlrOGHKBmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMTo1Mjo0MVrOGJBoqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE1NzQ2NQ==", "bodyText": "Just wondering why the others need to be public and this can be private ...", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r410157465", "createdAt": "2020-04-17T11:17:22Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "diffHunk": "@@ -31,47 +31,44 @@\n \n     public static final int CONCURRENT_IDLE = 0;\n     public static final int CONCURRENT_EMITTING = 1;\n+    private static final int CONCURRENT_PENDING = 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da043d3580ecb4737eef739b272693358f074539"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MDcyMQ==", "bodyText": "its a good question. I would like to investigate making them all private and instead expose lock methods, but didn't want to expand the scope of this PR: #1023", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r410350721", "createdAt": "2020-04-17T16:57:28Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "diffHunk": "@@ -31,47 +31,44 @@\n \n     public static final int CONCURRENT_IDLE = 0;\n     public static final int CONCURRENT_EMITTING = 1;\n+    private static final int CONCURRENT_PENDING = 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE1NzQ2NQ=="}, "originalCommit": {"oid": "da043d3580ecb4737eef739b272693358f074539"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjExNzE2MQ==", "bodyText": "sounds good...", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r412117161", "createdAt": "2020-04-21T11:52:41Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-internal/src/main/java/io/servicetalk/concurrent/internal/ConcurrentUtils.java", "diffHunk": "@@ -31,47 +31,44 @@\n \n     public static final int CONCURRENT_IDLE = 0;\n     public static final int CONCURRENT_EMITTING = 1;\n+    private static final int CONCURRENT_PENDING = 2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE1NzQ2NQ=="}, "originalCommit": {"oid": "da043d3580ecb4737eef739b272693358f074539"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0NjYwMzQwOnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMToxODoxOVrOGHKDLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxMToxODoxOVrOGHKDLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDE1Nzg2OQ==", "bodyText": "nit: ...DrainFailed ?", "url": "https://github.com/apple/servicetalk/pull/1014#discussion_r410157869", "createdAt": "2020-04-17T11:18:19Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/PublisherFlatMapSingle.java", "diffHunk": "@@ -222,29 +231,62 @@ private void enqueueAndDrain(Object item) {\n             assert s != null;\n \n             if (!pending.offer(item)) {\n-                QueueFullException exception = new QueueFullException(\"pending\");\n-                if (item instanceof TerminalNotification) {\n-                    LOGGER.error(\"Queue should be unbounded, but an offer failed!\", exception);\n-                    throw exception;\n-                } else {\n-                    onError0(exception, true, true);\n-                }\n+                enqueueAndDrainFail(item);\n             }\n             drainPending(s);\n         }\n \n+        @SuppressWarnings(\"ContinueOrBreakFromFinallyBlock\")\n         private void drainPending(Subscription subscription) {\n-            long drainedCount = drainSingleConsumerQueue(pending, this::sendToTarget, emittingUpdater, this);\n-            if (drainedCount != 0) {\n+            long drainCount = 0;\n+            Throwable delayedCause = null;\n+            while (acquirePendingLock(emittingUpdater, this)) {\n+                try {\n+                    Object t;\n+                    while ((t = pending.poll()) != null) {\n+                        ++drainCount;\n+                        try {\n+                            sendToTarget(t);\n+                        } catch (Throwable cause) {\n+                            if (delayedCause == null) {\n+                                delayedCause = cause;\n+                            }\n+                        }\n+                    }\n+                } finally {\n+                    if (releasePendingLock(emittingUpdater, this)) {\n+                        // break in finally isn't ideal but we catch Throwable above so we won't modify exception\n+                        // control flow. Also if we didn't catch Throwable and attempt to req-acquire the lock would be\n+                        // poisoned as the owner needs to re-acquire as long as release fails.\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (drainCount != 0) {\n                 // We ignore overflow here because once we get to this extreme, we won't be able to account for more\n                 // data anyways.\n-                sourceEmittedUpdater.addAndGet(this, drainedCount);\n+                sourceEmittedUpdater.addAndGet(this, drainCount);\n                 int actualSourceRequestN = calculateSourceRequested(requestedUpdater, sourceRequestedUpdater,\n                         sourceEmittedUpdater, source.maxConcurrency, this);\n                 if (actualSourceRequestN != 0) {\n                     subscription.request(actualSourceRequestN);\n                 }\n             }\n+\n+            if (delayedCause != null) {\n+                throwException(delayedCause);\n+            }\n+        }\n+\n+        private void enqueueAndDrainFail(Object item) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da043d3580ecb4737eef739b272693358f074539"}, "originalPosition": 105}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2687, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}