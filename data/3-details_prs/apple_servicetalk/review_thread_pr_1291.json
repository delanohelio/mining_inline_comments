{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyNTI0Mzg0", "number": 1291, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMTo1NzozNVrOFHZnXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMjozMzo0NlrOFHZ0Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzA0MDMwOnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMTo1NzozNVrOII310A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwNDo1MzowOVrOII45Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3NDQxNg==", "bodyText": "I thought about cases like this. Currently, we allow Completable.completed().merge() which doesn't make any sense. I think we should change all API that use varargs but require at least one element to merge(Completable first, Completable... others).  Then merge(Completable) will be not necessary or may be used to avoid extra allocation because merging with one is the most common case.", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546174416", "createdAt": "2020-12-19T01:57:35Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java", "diffHunk": "@@ -437,7 +461,7 @@ public final Completable concat(Completable next) {\n      * complete or terminates with an error when any one terminates with an error.\n      */\n     public final Completable merge(Completable... other) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "315029c1f6020692be9558025fadb10394f5b211"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE5MTcxOQ==", "bodyText": "I think it makes sense for merge(Completable) to exist either way as you said to avoid allocations when not necessary.", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546191719", "createdAt": "2020-12-19T04:53:09Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java", "diffHunk": "@@ -437,7 +461,7 @@ public final Completable concat(Completable next) {\n      * complete or terminates with an error when any one terminates with an error.\n      */\n     public final Completable merge(Completable... other) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3NDQxNg=="}, "originalCommit": {"oid": "315029c1f6020692be9558025fadb10394f5b211"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzA1MTcyOnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMjowOTowOFrOII37IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMjowOTowOFrOII37IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3NTc3Ng==", "bodyText": "If other is empty we can return this here and in mergeDelayError.", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546175776", "createdAt": "2020-12-19T02:09:08Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/Completable.java", "diffHunk": "@@ -437,7 +461,7 @@ public final Completable concat(Completable next) {\n      * complete or terminates with an error when any one terminates with an error.\n      */\n     public final Completable merge(Completable... other) {\n-        return new MergeCompletable(false, this, executor, other);\n+        return MergeCompletable.newInstance(false, this, executor, other);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "315029c1f6020692be9558025fadb10394f5b211"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzA1Nzg3OnYy", "diffSide": "LEFT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/MergeCompletable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMjoxNjoxNVrOII3-Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwNDo1NzoyN1rOII47DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3NjU1NA==", "bodyText": "Consider reverting this check until we fix API as described above.", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546176554", "createdAt": "2020-12-19T02:16:15Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/MergeCompletable.java", "diffHunk": "@@ -15,77 +15,54 @@\n  */\n package io.servicetalk.concurrent.api;\n \n-import javax.annotation.Nullable;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n \n import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n \n-/**\n- * A {@link Completable} implementation for merging {@link Completable}s.\n- */\n final class MergeCompletable extends AbstractMergeCompletableOperator {\n-\n-    @Nullable\n     private final Completable[] others;\n-    @Nullable\n-    private final Completable onlyOther;\n     private final boolean delayError;\n \n-    /**\n-     * New instance.\n-     * @param delayError {@code true} to wait until all {@code others} complete before propagating an error.\n-     *                   {@code false} to fail fast and propagate an error on the first\n-     *                   {@link Subscriber#onError(Throwable)} observed.\n-     * @param original {@link Completable} to merge with {@code others}.\n-     * @param others {@link Completable}s to merge with {@code original}.\n-     */\n-    MergeCompletable(boolean delayError, Completable original, Executor executor, Completable... others) {\n+    private MergeCompletable(boolean delayError, Completable original, Executor executor, Completable... others) {\n         super(original, executor);\n         this.delayError = delayError;\n-        switch (others.length) {\n-            case 0:\n-                throw new IllegalArgumentException(\"At least one Completable required to merge\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "315029c1f6020692be9558025fadb10394f5b211"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE5MjE0MA==", "bodyText": "I don't think we need to prevent the empty use case you described. There is nothing incorrect about passing an empty array or empty iterator, and I think we would want consistency between the two. If folks are passing empty collections they will just incur some overhead. If we have an API which prevents it that is fine, but until then lets just allow it consistently.", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546192140", "createdAt": "2020-12-19T04:57:27Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/MergeCompletable.java", "diffHunk": "@@ -15,77 +15,54 @@\n  */\n package io.servicetalk.concurrent.api;\n \n-import javax.annotation.Nullable;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n \n import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n \n-/**\n- * A {@link Completable} implementation for merging {@link Completable}s.\n- */\n final class MergeCompletable extends AbstractMergeCompletableOperator {\n-\n-    @Nullable\n     private final Completable[] others;\n-    @Nullable\n-    private final Completable onlyOther;\n     private final boolean delayError;\n \n-    /**\n-     * New instance.\n-     * @param delayError {@code true} to wait until all {@code others} complete before propagating an error.\n-     *                   {@code false} to fail fast and propagate an error on the first\n-     *                   {@link Subscriber#onError(Throwable)} observed.\n-     * @param original {@link Completable} to merge with {@code others}.\n-     * @param others {@link Completable}s to merge with {@code original}.\n-     */\n-    MergeCompletable(boolean delayError, Completable original, Executor executor, Completable... others) {\n+    private MergeCompletable(boolean delayError, Completable original, Executor executor, Completable... others) {\n         super(original, executor);\n         this.delayError = delayError;\n-        switch (others.length) {\n-            case 0:\n-                throw new IllegalArgumentException(\"At least one Completable required to merge\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3NjU1NA=="}, "originalCommit": {"oid": "315029c1f6020692be9558025fadb10394f5b211"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzA2MTk0OnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/MergeCompletable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMjoyMDo0NFrOII4AEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMjoyMDo0NFrOII4AEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3NzA0Mw==", "bodyText": "It's actually not a counter of remaining items, it's a counter of terminated items. Consider renaming to something like terminatedCount or doneCount.\nAlternatively, you can initialize remainingCount = expectedCount and decrement until 0. This way we will save a few bytes in this object by removing expectedCount.", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546177043", "createdAt": "2020-12-19T02:20:44Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/MergeCompletable.java", "diffHunk": "@@ -15,77 +15,54 @@\n  */\n package io.servicetalk.concurrent.api;\n \n-import javax.annotation.Nullable;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n \n import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;\n \n-/**\n- * A {@link Completable} implementation for merging {@link Completable}s.\n- */\n final class MergeCompletable extends AbstractMergeCompletableOperator {\n-\n-    @Nullable\n     private final Completable[] others;\n-    @Nullable\n-    private final Completable onlyOther;\n     private final boolean delayError;\n \n-    /**\n-     * New instance.\n-     * @param delayError {@code true} to wait until all {@code others} complete before propagating an error.\n-     *                   {@code false} to fail fast and propagate an error on the first\n-     *                   {@link Subscriber#onError(Throwable)} observed.\n-     * @param original {@link Completable} to merge with {@code others}.\n-     * @param others {@link Completable}s to merge with {@code original}.\n-     */\n-    MergeCompletable(boolean delayError, Completable original, Executor executor, Completable... others) {\n+    private MergeCompletable(boolean delayError, Completable original, Executor executor, Completable... others) {\n         super(original, executor);\n         this.delayError = delayError;\n-        switch (others.length) {\n-            case 0:\n-                throw new IllegalArgumentException(\"At least one Completable required to merge\");\n-            case 1:\n-                onlyOther = requireNonNull(others[0]);\n-                this.others = null;\n-                break;\n-            default:\n-                this.others = others;\n-                onlyOther = null;\n-        }\n+        this.others = requireNonNull(others);\n+    }\n+\n+    static AbstractMergeCompletableOperator newInstance(boolean delayError, Completable original, Executor executor,\n+                                                        Completable... others) {\n+        return others.length == 1 ?\n+                new MergeOneCompletable(delayError, original, executor, others[0]) :\n+                new MergeCompletable(delayError, original, executor, others);\n     }\n \n     @Override\n     public MergeSubscriber apply(final Subscriber subscriber) {\n-        assert onlyOther != null || others != null;\n-        return new FixedCountMergeSubscriber(subscriber, 1 + (onlyOther == null ? others.length : 1),\n-                delayError);\n+        return new FixedCountMergeSubscriber(subscriber, 1 + others.length, delayError);\n     }\n \n     @Override\n     void doMerge(final MergeSubscriber subscriber) {\n-        if (onlyOther == null) {\n-            assert others != null;\n-            for (Completable itr : others) {\n-                itr.subscribeInternal(subscriber);\n-            }\n-        } else {\n-            onlyOther.subscribeInternal(subscriber);\n+        for (Completable itr : others) {\n+            itr.subscribeInternal(subscriber);\n         }\n     }\n \n     static final class FixedCountMergeSubscriber extends MergeSubscriber {\n-        FixedCountMergeSubscriber(Subscriber subscriber, int completedCount, boolean delayError) {\n-            super(subscriber, completedCount, delayError);\n-        }\n+        private static final AtomicIntegerFieldUpdater<FixedCountMergeSubscriber> remainingCountUpdater =\n+                newUpdater(FixedCountMergeSubscriber.class, \"remainingCount\");\n+        private final int expectedCount;\n+        private volatile int remainingCount;\n \n-        @Override\n-        boolean onTerminate() {\n-            return completedCountUpdater.decrementAndGet(this) == 0;\n+        FixedCountMergeSubscriber(Subscriber subscriber, int expectedCount, boolean delayError) {\n+            super(subscriber, delayError);\n+            this.expectedCount = expectedCount;\n         }\n \n         @Override\n-        boolean isDone() {\n-            return completedCount == 0;\n+        boolean onTerminate() {\n+            return remainingCountUpdater.incrementAndGet(this) == expectedCount;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "315029c1f6020692be9558025fadb10394f5b211"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzA3MjM0OnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/IterableMergeCompletable.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMjozMjoyNVrOII4FEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQxODoxNToyMVrOISOLvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3ODMyMA==", "bodyText": "Why not to keep pre-existing check for Collection?", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546178320", "createdAt": "2020-12-19T02:32:25Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/IterableMergeCompletable.java", "diffHunk": "@@ -37,49 +35,37 @@\n \n     @Override\n     public MergeSubscriber apply(final Subscriber subscriber) {\n-        if (others instanceof Collection) {\n-            return new FixedCountMergeSubscriber(subscriber, 1 + ((Collection) others).size(), delayError);\n-        } else {\n-            return new DynamicCountSubscriber(subscriber, delayError);\n-        }\n+        return new DynamicCountSubscriber(subscriber, delayError);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "315029c1f6020692be9558025fadb10394f5b211"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE5MjMzMg==", "bodyText": "there is no longer a meaningful different between the two implementations, and some collections size() is costly and requires iteration.", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546192332", "createdAt": "2020-12-19T04:59:23Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/IterableMergeCompletable.java", "diffHunk": "@@ -37,49 +35,37 @@\n \n     @Override\n     public MergeSubscriber apply(final Subscriber subscriber) {\n-        if (others instanceof Collection) {\n-            return new FixedCountMergeSubscriber(subscriber, 1 + ((Collection) others).size(), delayError);\n-        } else {\n-            return new DynamicCountSubscriber(subscriber, delayError);\n-        }\n+        return new DynamicCountSubscriber(subscriber, delayError);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3ODMyMA=="}, "originalCommit": {"oid": "315029c1f6020692be9558025fadb10394f5b211"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE5NzEzNQ==", "bodyText": "Agreed, difference is negligible. Saying that, do we need 2 impls or can we always use dynamic one?", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546197135", "createdAt": "2020-12-19T05:56:36Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/IterableMergeCompletable.java", "diffHunk": "@@ -37,49 +35,37 @@\n \n     @Override\n     public MergeSubscriber apply(final Subscriber subscriber) {\n-        if (others instanceof Collection) {\n-            return new FixedCountMergeSubscriber(subscriber, 1 + ((Collection) others).size(), delayError);\n-        } else {\n-            return new DynamicCountSubscriber(subscriber, delayError);\n-        }\n+        return new DynamicCountSubscriber(subscriber, delayError);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3ODMyMA=="}, "originalCommit": {"oid": "315029c1f6020692be9558025fadb10394f5b211"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE5NzIxOQ==", "bodyText": "Sorry for back and forth. Existing code lgtm as well.", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546197219", "createdAt": "2020-12-19T05:57:18Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/IterableMergeCompletable.java", "diffHunk": "@@ -37,49 +35,37 @@\n \n     @Override\n     public MergeSubscriber apply(final Subscriber subscriber) {\n-        if (others instanceof Collection) {\n-            return new FixedCountMergeSubscriber(subscriber, 1 + ((Collection) others).size(), delayError);\n-        } else {\n-            return new DynamicCountSubscriber(subscriber, delayError);\n-        }\n+        return new DynamicCountSubscriber(subscriber, delayError);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3ODMyMA=="}, "originalCommit": {"oid": "315029c1f6020692be9558025fadb10394f5b211"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTk3NzY2Mw==", "bodyText": "np. thanks for review!", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r555977663", "createdAt": "2021-01-12T18:15:21Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/IterableMergeCompletable.java", "diffHunk": "@@ -37,49 +35,37 @@\n \n     @Override\n     public MergeSubscriber apply(final Subscriber subscriber) {\n-        if (others instanceof Collection) {\n-            return new FixedCountMergeSubscriber(subscriber, 1 + ((Collection) others).size(), delayError);\n-        } else {\n-            return new DynamicCountSubscriber(subscriber, delayError);\n-        }\n+        return new DynamicCountSubscriber(subscriber, delayError);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3ODMyMA=="}, "originalCommit": {"oid": "315029c1f6020692be9558025fadb10394f5b211"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzA3MzUwOnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/IterableMergeCompletable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwMjozMzo0NlrOII4Fmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwNTowNjo1N1rOII4-XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3ODQ1OQ==", "bodyText": "If you prefer to keep only DynamicCountSubscriber, consider adding a generic type for AbstractMergeCompletableOperator to avoid cast here.", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546178459", "createdAt": "2020-12-19T02:33:46Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/IterableMergeCompletable.java", "diffHunk": "@@ -37,49 +35,37 @@\n \n     @Override\n     public MergeSubscriber apply(final Subscriber subscriber) {\n-        if (others instanceof Collection) {\n-            return new FixedCountMergeSubscriber(subscriber, 1 + ((Collection) others).size(), delayError);\n-        } else {\n-            return new DynamicCountSubscriber(subscriber, delayError);\n-        }\n+        return new DynamicCountSubscriber(subscriber, delayError);\n     }\n \n     @Override\n     void doMerge(final MergeSubscriber subscriber) {\n-        if (subscriber instanceof DynamicCountSubscriber) {\n-            int count = 1;\n-            for (Completable itr : others) {\n-                ++count;\n-                itr.subscribeInternal(subscriber);\n-            }\n-            ((DynamicCountSubscriber) subscriber).setExpectedCount(count);\n-        } else {\n-            for (Completable itr : others) {\n-                itr.subscribeInternal(subscriber);\n-            }\n+        long count = 1;\n+        for (Completable itr : others) {\n+            ++count;\n+            itr.subscribeInternal(subscriber);\n         }\n+        ((DynamicCountSubscriber) subscriber).setExpectedCount(count);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "315029c1f6020692be9558025fadb10394f5b211"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE5Mjk4OA==", "bodyText": "I experimented with this but you can't have a generic sub-type with an inner class. I'll move the inner classes so I can avoid the cast.", "url": "https://github.com/apple/servicetalk/pull/1291#discussion_r546192988", "createdAt": "2020-12-19T05:06:57Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api/src/main/java/io/servicetalk/concurrent/api/IterableMergeCompletable.java", "diffHunk": "@@ -37,49 +35,37 @@\n \n     @Override\n     public MergeSubscriber apply(final Subscriber subscriber) {\n-        if (others instanceof Collection) {\n-            return new FixedCountMergeSubscriber(subscriber, 1 + ((Collection) others).size(), delayError);\n-        } else {\n-            return new DynamicCountSubscriber(subscriber, delayError);\n-        }\n+        return new DynamicCountSubscriber(subscriber, delayError);\n     }\n \n     @Override\n     void doMerge(final MergeSubscriber subscriber) {\n-        if (subscriber instanceof DynamicCountSubscriber) {\n-            int count = 1;\n-            for (Completable itr : others) {\n-                ++count;\n-                itr.subscribeInternal(subscriber);\n-            }\n-            ((DynamicCountSubscriber) subscriber).setExpectedCount(count);\n-        } else {\n-            for (Completable itr : others) {\n-                itr.subscribeInternal(subscriber);\n-            }\n+        long count = 1;\n+        for (Completable itr : others) {\n+            ++count;\n+            itr.subscribeInternal(subscriber);\n         }\n+        ((DynamicCountSubscriber) subscriber).setExpectedCount(count);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjE3ODQ1OQ=="}, "originalCommit": {"oid": "315029c1f6020692be9558025fadb10394f5b211"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2504, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}