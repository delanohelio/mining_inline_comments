{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyNDQ0MTM0", "number": 1290, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoxNDo0MlrOFHHypQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOTo1NToxN1rOFHU8UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMDEyMDA1OnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/Verifiers.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxMDoxNDo0MlrOIIc8dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOTo1ODowOFrOIIw-Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMzc0OQ==", "bodyText": "If I use the same stepVerifier for PublisherSource, java is confused when an async source implements both types Publisher and PublisherSource (example: TestPublisher). Which approach will you prefer: different factory names or force users to use a concrete type?", "url": "https://github.com/apple/servicetalk/pull/1290#discussion_r545733749", "createdAt": "2020-12-18T10:14:42Z", "author": {"login": "idelpivnitskiy"}, "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/Verifiers.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.SingleSource;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.api.test.TimeSources.nanoTimeNormalized;\n+\n+/**\n+ * Factory for the first steps that lead to {@link StepVerifier} test utility to verify each step in the lifecycle of\n+ * asynchronous sources {@link Publisher}, {@link Single}, and {@link Completable}.\n+ * <p>\n+ * The steps are typically from the perspective of a {@link Subscriber}'s lifecycle.\n+ */\n+public final class Verifiers {\n+    private Verifiers() {\n+    }\n+\n+    /**\n+     * Create a new {@link PublisherFirstStep}.\n+     *\n+     * @param source The {@link Publisher} to verify.\n+     * @param <T> The type of {@link Publisher}.\n+     * @return A {@link PublisherFirstStep} that can be used to verify {@code source}'s signal emission(s).\n+     */\n+    public static <T> PublisherFirstStep<T> stepVerifier(Publisher<T> source) {\n+        return stepVerifierForSource(toSource(source));\n+    }\n+\n+    /**\n+     * Create a new {@link PublisherFirstStep}.\n+     *\n+     * @param source The {@link PublisherSource} to verify.\n+     * @param <T> The type of {@link PublisherSource}.\n+     * @return A {@link PublisherFirstStep} that can be used to verify {@code source}'s signal emission(s).\n+     */\n+    public static <T> PublisherFirstStep<T> stepVerifierForSource(PublisherSource<T> source) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43e7bc6fe88991606348fd89a372e2f0ef924549"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA2MTgzMQ==", "bodyText": "I'm fine with different factory method name especially if it will come up in common cases and require additional casting/effort.\nfwiw ReactiveStreamsAdapters uses the same method name for both, but I guess this is less commonly used...", "url": "https://github.com/apple/servicetalk/pull/1290#discussion_r546061831", "createdAt": "2020-12-18T19:58:08Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api-test/src/main/java/io/servicetalk/concurrent/api/test/Verifiers.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright \u00a9 2020 Apple Inc. and the ServiceTalk project authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.servicetalk.concurrent.api.test;\n+\n+import io.servicetalk.concurrent.CompletableSource;\n+import io.servicetalk.concurrent.PublisherSource;\n+import io.servicetalk.concurrent.PublisherSource.Subscriber;\n+import io.servicetalk.concurrent.SingleSource;\n+import io.servicetalk.concurrent.api.Completable;\n+import io.servicetalk.concurrent.api.Publisher;\n+import io.servicetalk.concurrent.api.Single;\n+\n+import static io.servicetalk.concurrent.api.SourceAdapters.toSource;\n+import static io.servicetalk.concurrent.api.test.TimeSources.nanoTimeNormalized;\n+\n+/**\n+ * Factory for the first steps that lead to {@link StepVerifier} test utility to verify each step in the lifecycle of\n+ * asynchronous sources {@link Publisher}, {@link Single}, and {@link Completable}.\n+ * <p>\n+ * The steps are typically from the perspective of a {@link Subscriber}'s lifecycle.\n+ */\n+public final class Verifiers {\n+    private Verifiers() {\n+    }\n+\n+    /**\n+     * Create a new {@link PublisherFirstStep}.\n+     *\n+     * @param source The {@link Publisher} to verify.\n+     * @param <T> The type of {@link Publisher}.\n+     * @return A {@link PublisherFirstStep} that can be used to verify {@code source}'s signal emission(s).\n+     */\n+    public static <T> PublisherFirstStep<T> stepVerifier(Publisher<T> source) {\n+        return stepVerifierForSource(toSource(source));\n+    }\n+\n+    /**\n+     * Create a new {@link PublisherFirstStep}.\n+     *\n+     * @param source The {@link PublisherSource} to verify.\n+     * @param <T> The type of {@link PublisherSource}.\n+     * @return A {@link PublisherFirstStep} that can be used to verify {@code source}'s signal emission(s).\n+     */\n+    public static <T> PublisherFirstStep<T> stepVerifierForSource(PublisherSource<T> source) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTczMzc0OQ=="}, "originalCommit": {"oid": "43e7bc6fe88991606348fd89a372e2f0ef924549"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjI3MzQ3OnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/PublisherStepVerifierTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOTo1NDo1MlrOIIw4Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOTo1NDo1MlrOIIw4Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA2MDMxOQ==", "bodyText": "ah this is what you were asking for ... sorry I missed this and nice improvement \ud83d\udc4d", "url": "https://github.com/apple/servicetalk/pull/1290#discussion_r546060319", "createdAt": "2020-12-18T19:54:52Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/PublisherStepVerifierTest.java", "diffHunk": "@@ -729,19 +728,14 @@ private static void verifyException(Supplier<Duration> verifier, String failedTe\n     }\n \n     static void verifyException(Supplier<Duration> verifier, String classNamePrefix, String failedTestMethod) {\n-        try {\n-            verifier.get();\n-        } catch (StepAssertionError error) {\n-            StackTraceElement[] stackTraceElements = error.getStackTrace();\n-            assertThat(stackTraceElements.length, greaterThanOrEqualTo(1));\n-            assertThat(\"first stacktrace element expected <class: \" + classNamePrefix +\n-                    \"> actual: \" + stackTraceElements[0] + \" error: \" + error,\n-                    stackTraceElements[0].getClassName(), startsWith(classNamePrefix));\n-            StackTraceElement testMethodStackTrace = error.testMethodStackTrace();\n-            assertEquals(\"unexpected test method failure: \" + testMethodStackTrace, failedTestMethod,\n-                    testMethodStackTrace.getMethodName());\n-            return;\n-        }\n-        fail();\n+        StepAssertionError error = assertThrows(StepAssertionError.class, verifier::get);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43e7bc6fe88991606348fd89a372e2f0ef924549"}, "originalPosition": 635}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjI3NDczOnYy", "diffSide": "RIGHT", "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/PublisherStepVerifierTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOTo1NToxN1rOIIw42g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOTo1NToxN1rOIIw42g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA2MDUwNg==", "bodyText": "nit: consider putting more content on the previous line now that indentation has changed.", "url": "https://github.com/apple/servicetalk/pull/1290#discussion_r546060506", "createdAt": "2020-12-18T19:55:17Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-concurrent-api-test/src/test/java/io/servicetalk/concurrent/api/test/PublisherStepVerifierTest.java", "diffHunk": "@@ -729,19 +728,14 @@ private static void verifyException(Supplier<Duration> verifier, String failedTe\n     }\n \n     static void verifyException(Supplier<Duration> verifier, String classNamePrefix, String failedTestMethod) {\n-        try {\n-            verifier.get();\n-        } catch (StepAssertionError error) {\n-            StackTraceElement[] stackTraceElements = error.getStackTrace();\n-            assertThat(stackTraceElements.length, greaterThanOrEqualTo(1));\n-            assertThat(\"first stacktrace element expected <class: \" + classNamePrefix +\n-                    \"> actual: \" + stackTraceElements[0] + \" error: \" + error,\n-                    stackTraceElements[0].getClassName(), startsWith(classNamePrefix));\n-            StackTraceElement testMethodStackTrace = error.testMethodStackTrace();\n-            assertEquals(\"unexpected test method failure: \" + testMethodStackTrace, failedTestMethod,\n-                    testMethodStackTrace.getMethodName());\n-            return;\n-        }\n-        fail();\n+        StepAssertionError error = assertThrows(StepAssertionError.class, verifier::get);\n+        StackTraceElement[] stackTraceElements = error.getStackTrace();\n+        assertThat(stackTraceElements.length, greaterThanOrEqualTo(1));\n+        assertThat(\"first stacktrace element expected <class: \" + classNamePrefix +\n+                        \"> actual: \" + stackTraceElements[0] + \" error: \" + error,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43e7bc6fe88991606348fd89a372e2f0ef924549"}, "originalPosition": 639}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2502, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}