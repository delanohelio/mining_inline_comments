{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyNDg3Mzk4", "number": 976, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxODoyMFrODqf72A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxODoyMFrODqf72A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1ODkwMDA4OnYy", "diffSide": "RIGHT", "path": "servicetalk-transport-netty-internal/src/test/java/io/servicetalk/transport/netty/internal/NettyChannelPublisherTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxODoxODoyMFrOF6SOcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQwMjo0NjowM1rOF7KSmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2MDMzNw==", "bodyText": "Can you also add a test that does a channelRead() between cancel() and re-subscribe? That will re-initialize the pending queue.", "url": "https://github.com/apple/servicetalk/pull/976#discussion_r396660337", "createdAt": "2020-03-23T18:18:20Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/test/java/io/servicetalk/transport/netty/internal/NettyChannelPublisherTest.java", "diffHunk": "@@ -111,6 +113,27 @@ public void tearDown() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testCancelThenResubscribeDeliversErrorAndNotQueuedData() throws InterruptedException {\n+        TestCollectingPublisherSubscriber<Integer> subscriber1 = new TestCollectingPublisherSubscriber<>();\n+        TestCollectingPublisherSubscriber<Integer> subscriber2 = new TestCollectingPublisherSubscriber<>();\n+        toSource(publisher).subscribe(subscriber1);\n+        Subscription subscription1 = subscriber1.awaitSubscription();\n+        subscription1.request(1);\n+\n+        assertFalse(channel.writeInbound(1));\n+        Integer next = subscriber1.takeOnNext();\n+        assertThat(next, is(1));\n+        assertFalse(channel.writeInbound(2)); // this write should be queued, because there isn't any requestN demand.\n+\n+        subscription1.cancel(); // cancel of active subscription should clear the queue and fail future Subscribers.\n+\n+        toSource(publisher).subscribe(subscriber2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3cf0a1c97111b957f6c26634efda2fa96ed40b26"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjgyNDgxMw==", "bodyText": "The cancel operation does a shutdownInput so no more data should be delivered by Netty via channelRead. EmbeddedChannel throws ClosedChannelException if I try to deliver more data, and I will add a test for this.", "url": "https://github.com/apple/servicetalk/pull/976#discussion_r396824813", "createdAt": "2020-03-23T23:44:02Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/test/java/io/servicetalk/transport/netty/internal/NettyChannelPublisherTest.java", "diffHunk": "@@ -111,6 +113,27 @@ public void tearDown() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testCancelThenResubscribeDeliversErrorAndNotQueuedData() throws InterruptedException {\n+        TestCollectingPublisherSubscriber<Integer> subscriber1 = new TestCollectingPublisherSubscriber<>();\n+        TestCollectingPublisherSubscriber<Integer> subscriber2 = new TestCollectingPublisherSubscriber<>();\n+        toSource(publisher).subscribe(subscriber1);\n+        Subscription subscription1 = subscriber1.awaitSubscription();\n+        subscription1.request(1);\n+\n+        assertFalse(channel.writeInbound(1));\n+        Integer next = subscriber1.takeOnNext();\n+        assertThat(next, is(1));\n+        assertFalse(channel.writeInbound(2)); // this write should be queued, because there isn't any requestN demand.\n+\n+        subscription1.cancel(); // cancel of active subscription should clear the queue and fail future Subscribers.\n+\n+        toSource(publisher).subscribe(subscriber2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2MDMzNw=="}, "originalCommit": {"oid": "3cf0a1c97111b957f6c26634efda2fa96ed40b26"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNTY2MA==", "bodyText": "The case I was trying to get to was when data is enqueued in the channel when cancel() happens in which case Netty should deliver data first and then the shutdown. We do not have to go out of our way to verify the scenario but looks like having a handler that buffers data could do the trick?", "url": "https://github.com/apple/servicetalk/pull/976#discussion_r397525660", "createdAt": "2020-03-24T23:36:53Z", "author": {"login": "NiteshKant"}, "path": "servicetalk-transport-netty-internal/src/test/java/io/servicetalk/transport/netty/internal/NettyChannelPublisherTest.java", "diffHunk": "@@ -111,6 +113,27 @@ public void tearDown() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testCancelThenResubscribeDeliversErrorAndNotQueuedData() throws InterruptedException {\n+        TestCollectingPublisherSubscriber<Integer> subscriber1 = new TestCollectingPublisherSubscriber<>();\n+        TestCollectingPublisherSubscriber<Integer> subscriber2 = new TestCollectingPublisherSubscriber<>();\n+        toSource(publisher).subscribe(subscriber1);\n+        Subscription subscription1 = subscriber1.awaitSubscription();\n+        subscription1.request(1);\n+\n+        assertFalse(channel.writeInbound(1));\n+        Integer next = subscriber1.takeOnNext();\n+        assertThat(next, is(1));\n+        assertFalse(channel.writeInbound(2)); // this write should be queued, because there isn't any requestN demand.\n+\n+        subscription1.cancel(); // cancel of active subscription should clear the queue and fail future Subscribers.\n+\n+        toSource(publisher).subscribe(subscriber2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2MDMzNw=="}, "originalCommit": {"oid": "3cf0a1c97111b957f6c26634efda2fa96ed40b26"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU3ODkwNw==", "bodyText": "good call ... I was trying to get away with avoiding additional conditional in channelRead but it is helpful to avoid this case.", "url": "https://github.com/apple/servicetalk/pull/976#discussion_r397578907", "createdAt": "2020-03-25T02:46:03Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/test/java/io/servicetalk/transport/netty/internal/NettyChannelPublisherTest.java", "diffHunk": "@@ -111,6 +113,27 @@ public void tearDown() throws Exception {\n         }\n     }\n \n+    @Test\n+    public void testCancelThenResubscribeDeliversErrorAndNotQueuedData() throws InterruptedException {\n+        TestCollectingPublisherSubscriber<Integer> subscriber1 = new TestCollectingPublisherSubscriber<>();\n+        TestCollectingPublisherSubscriber<Integer> subscriber2 = new TestCollectingPublisherSubscriber<>();\n+        toSource(publisher).subscribe(subscriber1);\n+        Subscription subscription1 = subscriber1.awaitSubscription();\n+        subscription1.request(1);\n+\n+        assertFalse(channel.writeInbound(1));\n+        Integer next = subscriber1.takeOnNext();\n+        assertThat(next, is(1));\n+        assertFalse(channel.writeInbound(2)); // this write should be queued, because there isn't any requestN demand.\n+\n+        subscription1.cancel(); // cancel of active subscription should clear the queue and fail future Subscribers.\n+\n+        toSource(publisher).subscribe(subscriber2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY2MDMzNw=="}, "originalCommit": {"oid": "3cf0a1c97111b957f6c26634efda2fa96ed40b26"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2796, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}