{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwMzYzNDAx", "number": 1059, "title": "`WriteStreamSubscriber` retains listeners for the lifetime of the source", "bodyText": "Motivation\nWriteStreamSubscriber uses a single Promise for all writes done through it. As we add listeners to each write, the listeners get accumulated in the promise till the WriteStreamSubscriber terminates. For servers since we do a single write for the connection, these listeners are retained for the connection lifetime.\nModification\n\nManage listeners in AllWritesPromise as opposed to delegating them to DefaultWritePromise.\nListeners are managed over the specific write boundaries.\nEach time a write is complete, listeners added since last write are terminated and removed from the list.\n\nResult\nListeners are retained by WriteStreamSubscriber for the duration of each write.", "createdAt": "2020-05-19T21:01:28Z", "url": "https://github.com/apple/servicetalk/pull/1059", "merged": true, "mergeCommit": {"oid": "1a7498da15a40f1f4777618f2f4ce06c34a60d1a"}, "closed": true, "closedAt": "2020-05-21T01:21:50Z", "author": {"login": "NiteshKant"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABci85CtgH2gAyNDIwMzYzNDAxOjg0NTE3ZTVjMDE5M2ZjMTU5MTE2Y2E0MTM0ZmFmNDJmMWZkYmJhOWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcjSl4dAH2gAyNDIwMzYzNDAxOjFiOThlNjExN2RiOGY5ZjRiNzk1NzhiNmNlZGQ2ODgxMWE4MTEyODA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "84517e5c0193fc159116ca4134faf42f1fdbba9a", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/84517e5c0193fc159116ca4134faf42f1fdbba9a", "committedDate": "2020-05-19T23:16:07Z", "message": "`WriteStreamSubscriber` retains listeners for the lifetime of the source\n\n__Motivation__\n\n`WriteStreamSubscriber` uses a single `Promise` for all writes done through it. As we add listeners to each write, the listeners get accumulated in the promise till the `WriteStreamSubscriber` terminates. For servers since we do a single write for the connection, these listeners are retained for the connection lifetime.\n\n__Modification__\n\n- Manage listeners in `AllWritesPromise` as opposed to delegating them to `DefaultWritePromise`.\n- Listeners are managed over the specific write boundaries.\n- Each time a write is complete, listeners added since last write are terminated and removed from the list.\n\n__Result__\n\nListeners are retained by `WriteStreamSubscriber` for the duration of each write."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215", "committedDate": "2020-05-19T21:00:31Z", "message": "`WriteStreamSubscriber` retains listeners for the lifetime of the source\n\n__Motivation__\n\n`WriteStreamSubscriber` uses a single `Promise` for all writes done through it. As we add listeners to each write, the listeners get accumulated in the promise till the `WriteStreamSubscriber` terminates. For servers since we do a single write for the connection, these listeners are retained for the connection lifetime.\n\n__Modification__\n\n- Manage listeners in `AllWritesPromise` as opposed to delegating them to `DefaultWritePromise`.\n- Listeners are managed over the specific write boundaries.\n- Each time a write is complete, listeners added since last write are terminated and removed from the list.\n\n__Result__\n\nListeners are retained by `WriteStreamSubscriber` for the duration of each write."}, "afterCommit": {"oid": "84517e5c0193fc159116ca4134faf42f1fdbba9a", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/84517e5c0193fc159116ca4134faf42f1fdbba9a", "committedDate": "2020-05-19T23:16:07Z", "message": "`WriteStreamSubscriber` retains listeners for the lifetime of the source\n\n__Motivation__\n\n`WriteStreamSubscriber` uses a single `Promise` for all writes done through it. As we add listeners to each write, the listeners get accumulated in the promise till the `WriteStreamSubscriber` terminates. For servers since we do a single write for the connection, these listeners are retained for the connection lifetime.\n\n__Modification__\n\n- Manage listeners in `AllWritesPromise` as opposed to delegating them to `DefaultWritePromise`.\n- Listeners are managed over the specific write boundaries.\n- Each time a write is complete, listeners added since last write are terminated and removed from the list.\n\n__Result__\n\nListeners are retained by `WriteStreamSubscriber` for the duration of each write."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0ODcxNTQy", "url": "https://github.com/apple/servicetalk/pull/1059#pullrequestreview-414871542", "createdAt": "2020-05-19T22:37:04Z", "commit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMjozNzowNVrOGX1C2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMzo1Mzo1NlrOGX2ljQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYzOTUxMg==", "bodyText": "nit: isEmpty() and removeFirst() can be combined into a single call:\n            Object maybeListener;\n            while ((maybeListener = listenersOnWriteBoundaries.pollFirst()) != null) {\n                if (maybeListener != WRITE_BOUNDARY) {\n                    notifyListener(future, maybeListener);\n                }\n            }", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427639512", "createdAt": "2020-05-19T22:37:05Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -420,6 +482,38 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n             }\n         }\n \n+        private void notifyAllListeners(@Nullable Throwable cause) {\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MDA2OQ==", "bodyText": "did you consider random insertion or removal to be common (I'm assuming removeListener isn't frequently used)? if not consider ArrayDeque which has a lower constant memory overhead (LinkedList = 24 bytes per Node, ArrayDeque = backed by array).", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427640069", "createdAt": "2020-05-19T22:38:42Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -259,11 +265,61 @@ private void requestMoreIfRequired(@Nullable Subscription subscription) {\n         private byte state;\n         @Nullable\n         private Throwable failureCause;\n+        /**\n+         * This deque contains all added listeners within {@link #WRITE_BOUNDARY write boundaries}.\n+         * <pre>\n+         *     {@link #WRITE_BOUNDARY}, listener1, listener2, {@link #WRITE_BOUNDARY}, listener3 ...\n+         * </pre>\n+         * We assume that no listener for a write is added after that write is completed (a.k.a late listeners).\n+         */\n+        private final Deque<Object> listenersOnWriteBoundaries = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MjU4MA==", "bodyText": "is it necessary to leave WRITE_BOUNDARY at the head of the queue?  if not we could simplify draining to just stop when null or we hit a WRITE_BOUNDARY\n            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n            Object maybeListener = listenersOnWriteBoundaries.poll();\n            while (maybeListener != null && maybeListener != WRITE_BOUNDARY) {\n                notifyListener(future, maybeListener);\n                maybeListener = listenersOnWriteBoundaries.poll();\n            }\nthe order of the WRITE_BOUNDRY addition relative to channel#write would have to change, not sure if that is a problem? It maybe safer to delineate the boundaries on the leading edge if there are any async listeners added before completion, but given the restrictions on the boundaries I'm not sure if that would be reliable from a sequencing perspective?\n            channel.write(msg, this);\n            if (listenersOnWriteBoundaries.peekLast() != WRITE_BOUNDARY) {\n                listenersOnWriteBoundaries.addLast(WRITE_BOUNDARY);\n            }", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427642580", "createdAt": "2020-05-19T22:45:58Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -420,6 +482,38 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n             }\n         }\n \n+        private void notifyAllListeners(@Nullable Throwable cause) {\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty()) {\n+                Object mayBeListener = listenersOnWriteBoundaries.removeFirst();\n+                if (mayBeListener != WRITE_BOUNDARY) {\n+                    notifyListener(future, mayBeListener);\n+                }\n+            }\n+        }\n+\n+        private void notifyListenersTillNextWrite(@Nullable Throwable cause) {\n+            Object shdBeWriteBoundary = listenersOnWriteBoundaries.removeFirst();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MzcxMw==", "bodyText": "I see the we assume no late listener comment above but I'm wondering what the negative/costs would be of notifying listeners if they are late. Otherwise if this does happen we may not complete async control flow in some cases. We maybe able to delegate to super to manage notification, however not sure if this will bring up any notification ordering if folks add a listener in a re-entry fashion.", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427643713", "createdAt": "2020-05-19T22:49:30Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -259,11 +265,61 @@ private void requestMoreIfRequired(@Nullable Subscription subscription) {\n         private byte state;\n         @Nullable\n         private Throwable failureCause;\n+        /**\n+         * This deque contains all added listeners within {@link #WRITE_BOUNDARY write boundaries}.\n+         * <pre>\n+         *     {@link #WRITE_BOUNDARY}, listener1, listener2, {@link #WRITE_BOUNDARY}, listener3 ...\n+         * </pre>\n+         * We assume that no listener for a write is added after that write is completed (a.k.a late listeners).\n+         */\n+        private final Deque<Object> listenersOnWriteBoundaries = new LinkedList<>();\n \n         AllWritesPromise(final Channel channel) {\n             super(channel);\n         }\n \n+        @Override\n+        public ChannelPromise addListener(final GenericFutureListener<? extends Future<? super Void>> listener) {\n+            assert channel.eventLoop().inEventLoop();\n+            if (hasFlag(SUBSCRIBER_TERMINATED)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY2NDAzNA==", "bodyText": "nit: consider making this method static", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427664034", "createdAt": "2020-05-19T23:51:29Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -420,6 +480,39 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n             }\n         }\n \n+        private void notifyAllListeners(@Nullable Throwable cause) {\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty()) {\n+                Object mayBeListener = listenersOnWriteBoundaries.removeFirst();\n+                if (mayBeListener != WRITE_BOUNDARY) {\n+                    notifyListener(future, mayBeListener);\n+                }\n+            }\n+        }\n+\n+        private void notifyListenersTillNextWrite(@Nullable Throwable cause) {\n+            assert !listenersOnWriteBoundaries.isEmpty();\n+            Object shdBeWriteBoundary = listenersOnWriteBoundaries.removeFirst();\n+            if (shdBeWriteBoundary != WRITE_BOUNDARY) {\n+                return;\n+            }\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty() && listenersOnWriteBoundaries.peekFirst() != WRITE_BOUNDARY) {\n+                Object shdBeListener = listenersOnWriteBoundaries.removeFirst();\n+                notifyListener(future, shdBeListener);\n+            }\n+        }\n+\n+        @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+        private void notifyListener(final ChannelFuture future, final Object shdBeListener) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84517e5c0193fc159116ca4134faf42f1fdbba9a"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY2NDc4MQ==", "bodyText": "nit: consider simplifying code block to:\n            if (!hasFlag(SUBSCRIBER_TERMINATED)) {\n                listenersOnWriteBoundaries.addLast(listener);\n            }\n            return this;", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427664781", "createdAt": "2020-05-19T23:53:56Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -259,11 +265,61 @@ private void requestMoreIfRequired(@Nullable Subscription subscription) {\n         private byte state;\n         @Nullable\n         private Throwable failureCause;\n+        /**\n+         * This deque contains all added listeners within {@link #WRITE_BOUNDARY write boundaries}.\n+         * <pre>\n+         *     {@link #WRITE_BOUNDARY}, listener1, listener2, {@link #WRITE_BOUNDARY}, listener3 ...\n+         * </pre>\n+         * We assume that no listener for a write is added after that write is completed (a.k.a late listeners).\n+         */\n+        private final Deque<Object> listenersOnWriteBoundaries = new LinkedList<>();\n \n         AllWritesPromise(final Channel channel) {\n             super(channel);\n         }\n \n+        @Override\n+        public ChannelPromise addListener(final GenericFutureListener<? extends Future<? super Void>> listener) {\n+            assert channel.eventLoop().inEventLoop();\n+            if (hasFlag(SUBSCRIBER_TERMINATED)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MzcxMw=="}, "originalCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0OTg1Nzc3", "url": "https://github.com/apple/servicetalk/pull/1059#pullrequestreview-414985777", "createdAt": "2020-05-20T04:35:54Z", "commit": {"oid": "84517e5c0193fc159116ca4134faf42f1fdbba9a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwNDozNTo1NFrOGX68UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwNDozNTo1NFrOGX68UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczNjE0NQ==", "bodyText": "Consider making this a GenericFutureListener. This was can tighten up the generics for the queue.", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r427736145", "createdAt": "2020-05-20T04:35:54Z", "author": {"login": "normanmaurer"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -67,6 +72,7 @@\n  */\n final class WriteStreamSubscriber implements PublisherSource.Subscriber<Object>, ChannelOutboundListener, Cancellable {\n     private static final Logger LOGGER = LoggerFactory.getLogger(WriteStreamSubscriber.class);\n+    private static final Object WRITE_BOUNDARY = new Object();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84517e5c0193fc159116ca4134faf42f1fdbba9a"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2982c09dacb563b2562511a3eae9b90022e6db64", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/2982c09dacb563b2562511a3eae9b90022e6db64", "committedDate": "2020-05-20T18:33:34Z", "message": "Review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6cea4eb2599b9e55326573bfb559d71c0d75e7e5", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/6cea4eb2599b9e55326573bfb559d71c0d75e7e5", "committedDate": "2020-05-20T18:47:51Z", "message": "Moar review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1Nzg3MjQy", "url": "https://github.com/apple/servicetalk/pull/1059#pullrequestreview-415787242", "createdAt": "2020-05-20T23:41:48Z", "commit": {"oid": "6cea4eb2599b9e55326573bfb559d71c0d75e7e5"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMzo0MTo0OVrOGYhhGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMDoxNjowOVrOGYiHuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM2ODE1NA==", "bodyText": "removeFirst() -> pollFirst() (you have already verified there is an item in the queue, you can avoid the null check/exception from remove* method)", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r428368154", "createdAt": "2020-05-20T23:41:49Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -420,6 +481,26 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n             }\n         }\n \n+        private void notifyAllListeners(@Nullable Throwable cause) {\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            GenericFutureListener<?> mayBeListener;\n+            while ((mayBeListener = listenersOnWriteBoundaries.pollFirst()) != null) {\n+                if (mayBeListener != WRITE_BOUNDARY) {\n+                    notifyListener(eventLoop, future, mayBeListener);\n+                }\n+            }\n+        }\n+\n+        private void notifyListenersTillNextWrite(@Nullable Throwable cause) {\n+            Object shdBeWriteBoundary = listenersOnWriteBoundaries.pollFirst();\n+            assert shdBeWriteBoundary == WRITE_BOUNDARY;\n+\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty() && listenersOnWriteBoundaries.peekFirst() != WRITE_BOUNDARY) {\n+                notifyListener(eventLoop, future, listenersOnWriteBoundaries.removeFirst());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cea4eb2599b9e55326573bfb559d71c0d75e7e5"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3ODA0MA==", "bodyText": "good call on the re-entry! Here is a unit test for WriteStreamSubscriberFutureListenersTest to verify correctness here:\n    @Test\n    public void synchronousCompleteWrite() throws Exception {\n        Channel mockChannel = mock(Channel.class);\n        EventLoop mockEventLoop = mock(EventLoop.class);\n        when(mockEventLoop.inEventLoop()).thenReturn(true);\n        when(mockChannel.eventLoop()).thenReturn(mockEventLoop);\n        when(mockChannel.newSucceededFuture()).thenReturn(channel.newSucceededFuture());\n        doAnswer((Answer<Void>) invocation -> {\n            ReferenceCountUtil.release(invocation.getArgument(0));\n            ChannelFutureListener listener = mock(ChannelFutureListener.class);\n            listeners.add(listener);\n            ChannelPromise promise = invocation.getArgument(1);\n            promise.addListener(listener);\n            promise.setSuccess();\n            return null;\n        }).when(mockChannel).write(any(), any());\n        WriteDemandEstimator estimator = WriteDemandEstimators.newDefaultEstimator();\n        TestCompletableSubscriber completableSubscriber = new TestCompletableSubscriber();\n        WriteStreamSubscriber subscriber = new WriteStreamSubscriber(mockChannel, estimator, completableSubscriber,\n                UNSUPPORTED_PROTOCOL_CLOSE_HANDLER);\n        subscriber.onNext(1);\n        verifyListenerInvokedWithSuccess(listeners.take());\n        subscriber.onNext(2);\n        verifyListenerInvokedWithSuccess(listeners.take());\n    }", "url": "https://github.com/apple/servicetalk/pull/1059#discussion_r428378040", "createdAt": "2020-05-21T00:16:09Z", "author": {"login": "Scottmitch"}, "path": "servicetalk-transport-netty-internal/src/main/java/io/servicetalk/transport/netty/internal/WriteStreamSubscriber.java", "diffHunk": "@@ -420,6 +482,38 @@ private void terminateSubscriber(@Nullable Throwable cause) {\n             }\n         }\n \n+        private void notifyAllListeners(@Nullable Throwable cause) {\n+            final ChannelFuture future = cause == null ? channel.newSucceededFuture() : channel.newFailedFuture(cause);\n+            while (!listenersOnWriteBoundaries.isEmpty()) {\n+                Object mayBeListener = listenersOnWriteBoundaries.removeFirst();\n+                if (mayBeListener != WRITE_BOUNDARY) {\n+                    notifyListener(future, mayBeListener);\n+                }\n+            }\n+        }\n+\n+        private void notifyListenersTillNextWrite(@Nullable Throwable cause) {\n+            Object shdBeWriteBoundary = listenersOnWriteBoundaries.removeFirst();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY0MjU4MA=="}, "originalCommit": {"oid": "ad102cb68c3a23fe4c6fb9c93d272d5bc1eab215"}, "originalPosition": 130}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b98e6117db8f9f4b79578b6cedd68811a811280", "author": {"user": {"login": "NiteshKant", "name": "Nitesh Kant"}}, "url": "https://github.com/apple/servicetalk/commit/1b98e6117db8f9f4b79578b6cedd68811a811280", "committedDate": "2020-05-21T00:33:06Z", "message": "Review comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3702, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}