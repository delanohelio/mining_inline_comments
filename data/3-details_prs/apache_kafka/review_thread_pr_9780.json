{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ0MzA3MDAx", "number": 9780, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMjoyMTowMlrOFW5G0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMjo1NzozNVrOFW506g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5NTQ4NjI0OnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMjoyMTowMlrOIgJraA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQwNTo0MDo0NFrOIgSwFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU4MzkxMg==", "bodyText": "I think it's better to avoid a variadic argument here.\nParameters tend to get added with new features in such constructors. And if a new parameter is required that is also a list, then we'll have a mix of list args with a variadic in the end.\nSince we transform to list I'd suggest using this type here and pass the single argument with Collections.singletonList in the caller.", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570583912", "createdAt": "2021-02-04T22:21:02Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java", "diffHunk": "@@ -185,16 +188,33 @@\n \n     private final DistributedConfig config;\n \n+    /**\n+     * Create a herder that will form a Connect cluster with other {@link DistributedHerder} instances (in this or other JVMs)\n+     * that have the same group ID.\n+     *\n+     * @param config             the configuration for the worker; may not be null\n+     * @param time               the clock to use; may not be null\n+     * @param worker             the {@link Worker} instance to use; may not be null\n+     * @param kafkaClusterId     the identifier of the Kafka cluster to use for internal topics; may not be null\n+     * @param statusBackingStore the backing store for statuses; may not be null\n+     * @param configBackingStore the backing store for connector configurations; may not be null\n+     * @param restUrl            the URL of this herder's REST API; may not be null\n+     * @param connectorClientConfigOverridePolicy the policy specifying the client configuration properties that may be overridden\n+     *                                            in connector configurations; may not be null\n+     * @param uponShutdown       any {@link AutoCloseable} objects that should be closed when this herder is {@link #stop() stopped},\n+     *                           after all services and resources owned by this herder are stopped\n+     */\n     public DistributedHerder(DistributedConfig config,\n                              Time time,\n                              Worker worker,\n                              String kafkaClusterId,\n                              StatusBackingStore statusBackingStore,\n                              ConfigBackingStore configBackingStore,\n                              String restUrl,\n-                             ConnectorClientConfigOverridePolicy connectorClientConfigOverridePolicy) {\n+                             ConnectorClientConfigOverridePolicy connectorClientConfigOverridePolicy,\n+                             AutoCloseable... uponShutdown) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY0ODU1Ng==", "bodyText": "The reason I used a variadic array here was to avoid having to create a new connector when no AutoCloseable instances are supplied. If we use a List, then we can change the usage in Connect runtime and in MirrorMaker 2, but anywhere else will break without keeping the old signature. WDYT?", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570648556", "createdAt": "2021-02-05T00:56:58Z", "author": {"login": "rhauch"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java", "diffHunk": "@@ -185,16 +188,33 @@\n \n     private final DistributedConfig config;\n \n+    /**\n+     * Create a herder that will form a Connect cluster with other {@link DistributedHerder} instances (in this or other JVMs)\n+     * that have the same group ID.\n+     *\n+     * @param config             the configuration for the worker; may not be null\n+     * @param time               the clock to use; may not be null\n+     * @param worker             the {@link Worker} instance to use; may not be null\n+     * @param kafkaClusterId     the identifier of the Kafka cluster to use for internal topics; may not be null\n+     * @param statusBackingStore the backing store for statuses; may not be null\n+     * @param configBackingStore the backing store for connector configurations; may not be null\n+     * @param restUrl            the URL of this herder's REST API; may not be null\n+     * @param connectorClientConfigOverridePolicy the policy specifying the client configuration properties that may be overridden\n+     *                                            in connector configurations; may not be null\n+     * @param uponShutdown       any {@link AutoCloseable} objects that should be closed when this herder is {@link #stop() stopped},\n+     *                           after all services and resources owned by this herder are stopped\n+     */\n     public DistributedHerder(DistributedConfig config,\n                              Time time,\n                              Worker worker,\n                              String kafkaClusterId,\n                              StatusBackingStore statusBackingStore,\n                              ConfigBackingStore configBackingStore,\n                              String restUrl,\n-                             ConnectorClientConfigOverridePolicy connectorClientConfigOverridePolicy) {\n+                             ConnectorClientConfigOverridePolicy connectorClientConfigOverridePolicy,\n+                             AutoCloseable... uponShutdown) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU4MzkxMg=="}, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDczMjU2NQ==", "bodyText": "We can always keep a constructor with the old signature along with the new if we wanted not to break classes that use DistributedHerder. I'm fine with the change here as a short term workaround. I guess it saves us one constructor but we can use it only once.", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570732565", "createdAt": "2021-02-05T05:40:44Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java", "diffHunk": "@@ -185,16 +188,33 @@\n \n     private final DistributedConfig config;\n \n+    /**\n+     * Create a herder that will form a Connect cluster with other {@link DistributedHerder} instances (in this or other JVMs)\n+     * that have the same group ID.\n+     *\n+     * @param config             the configuration for the worker; may not be null\n+     * @param time               the clock to use; may not be null\n+     * @param worker             the {@link Worker} instance to use; may not be null\n+     * @param kafkaClusterId     the identifier of the Kafka cluster to use for internal topics; may not be null\n+     * @param statusBackingStore the backing store for statuses; may not be null\n+     * @param configBackingStore the backing store for connector configurations; may not be null\n+     * @param restUrl            the URL of this herder's REST API; may not be null\n+     * @param connectorClientConfigOverridePolicy the policy specifying the client configuration properties that may be overridden\n+     *                                            in connector configurations; may not be null\n+     * @param uponShutdown       any {@link AutoCloseable} objects that should be closed when this herder is {@link #stop() stopped},\n+     *                           after all services and resources owned by this herder are stopped\n+     */\n     public DistributedHerder(DistributedConfig config,\n                              Time time,\n                              Worker worker,\n                              String kafkaClusterId,\n                              StatusBackingStore statusBackingStore,\n                              ConfigBackingStore configBackingStore,\n                              String restUrl,\n-                             ConnectorClientConfigOverridePolicy connectorClientConfigOverridePolicy) {\n+                             ConnectorClientConfigOverridePolicy connectorClientConfigOverridePolicy,\n+                             AutoCloseable... uponShutdown) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU4MzkxMg=="}, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5NTQ4NzA0OnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMjoyMToxNlrOIgJr5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMjoyMToxNlrOIgJr5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU4NDAzNg==", "bodyText": "see comment above", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570584036", "createdAt": "2021-02-04T22:21:16Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java", "diffHunk": "@@ -209,7 +229,8 @@ public DistributedHerder(DistributedConfig config,\n                       String restUrl,\n                       ConnectMetrics metrics,\n                       Time time,\n-                      ConnectorClientConfigOverridePolicy connectorClientConfigOverridePolicy) {\n+                      ConnectorClientConfigOverridePolicy connectorClientConfigOverridePolicy,\n+                      AutoCloseable... uponShutdown) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5NTQ4NzYxOnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMjoyMToyOFrOIgJsRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMjoyMToyOFrOIgJsRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU4NDEzMw==", "bodyText": "nit: extra", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570584133", "createdAt": "2021-02-04T22:21:28Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java", "diffHunk": "@@ -676,6 +698,16 @@ public void halt() {\n         }\n     }\n \n+    @Override\n+    protected void stopServices() {\n+        try {\n+            super.stopServices();\n+        } finally {\n+            this.uponShutdown.stream().forEach(closeable -> Utils.closeQuietly(closeable, closeable != null ? closeable.toString() : \"<unknown>\"));\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5NTQ4OTIzOnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMjoyMjowM1rOIgJtZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMjoyMjowM1rOIgJtZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU4NDQyMQ==", "bodyText": "I'd guess stream().forEach can be simplified with forEach only", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570584421", "createdAt": "2021-02-04T22:22:03Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java", "diffHunk": "@@ -676,6 +698,16 @@ public void halt() {\n         }\n     }\n \n+    @Override\n+    protected void stopServices() {\n+        try {\n+            super.stopServices();\n+        } finally {\n+            this.uponShutdown.stream().forEach(closeable -> Utils.closeQuietly(closeable, closeable != null ? closeable.toString() : \"<unknown>\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5NTUyMzYxOnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/distributed/DistributedHerderTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMjozMjoxN1rOIgKBhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMjozMjoxN1rOIgKBhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU4OTU3Mg==", "bodyText": "see comment above. We'll avoid the array static init too. Tests here but still that's where array lists come handy", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570589572", "createdAt": "2021-02-04T22:32:17Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/distributed/DistributedHerderTest.java", "diffHunk": "@@ -207,14 +209,16 @@ public void setUp() throws Exception {\n         metrics = new MockConnectMetrics(time);\n         worker = PowerMock.createMock(Worker.class);\n         EasyMock.expect(worker.isSinkConnector(CONN1)).andStubReturn(Boolean.TRUE);\n+        AutoCloseable uponShutdown = () -> shutdownCalled.countDown();\n \n         // Default to the old protocol unless specified otherwise\n         connectProtocolVersion = CONNECT_PROTOCOL_V0;\n \n         herder = PowerMock.createPartialMock(DistributedHerder.class,\n                 new String[]{\"connectorTypeForClass\", \"updateDeletedConnectorStatus\", \"updateDeletedTaskStatus\", \"validateConnectorConfig\"},\n                 new DistributedConfig(HERDER_CONFIG), worker, WORKER_ID, KAFKA_CLUSTER_ID,\n-                statusBackingStore, configBackingStore, member, MEMBER_URL, metrics, time, noneConnectorClientConfigOverridePolicy);\n+                statusBackingStore, configBackingStore, member, MEMBER_URL, metrics, time, noneConnectorClientConfigOverridePolicy,\n+                new AutoCloseable[]{uponShutdown});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5NTUyNzAxOnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/util/SharedTopicAdminTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMjozMzoyNlrOIgKDpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMjozMzoyNlrOIgKDpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5MDExNw==", "bodyText": "should we call it EMPTY_CONFIG since it won't change?", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570590117", "createdAt": "2021-02-04T22:33:26Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/util/SharedTopicAdminTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.connect.util;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import org.apache.kafka.connect.errors.ConnectException;\n+import org.easymock.EasyMock;\n+import org.easymock.Mock;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.powermock.api.easymock.PowerMock;\n+import org.powermock.core.classloader.annotations.PowerMockIgnore;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest(KafkaBasedLog.class)\n+@PowerMockIgnore(\"javax.management.*\")\n+public class SharedTopicAdminTest {\n+\n+    private static final Map<String, Object> CONFIG = Collections.emptyMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5NTU0MDMxOnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/util/SharedTopicAdminTest.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMjozNzozMVrOIgKLfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOFQyMjoyNzoyMFrOIh52iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5MjEyNg==", "bodyText": "Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that?\nReplay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570592126", "createdAt": "2021-02-04T22:37:31Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/util/SharedTopicAdminTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.connect.util;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import org.apache.kafka.connect.errors.ConnectException;\n+import org.easymock.EasyMock;\n+import org.easymock.Mock;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.powermock.api.easymock.PowerMock;\n+import org.powermock.core.classloader.annotations.PowerMockIgnore;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest(KafkaBasedLog.class)\n+@PowerMockIgnore(\"javax.management.*\")\n+public class SharedTopicAdminTest {\n+\n+    private static final Map<String, Object> CONFIG = Collections.emptyMap();\n+\n+    @Mock private TopicAdmin mockTopicAdmin;\n+    private SharedTopicAdmin sharedAdmin;\n+    private int created = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY1NTAwOA==", "bodyText": "Really I'm just using that to be able to test that the new topicAdmin() method is returning the correct instance, even after repeated calls. It was an easy way to verify that the TopicAdmin matches what the factory function returned.", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570655008", "createdAt": "2021-02-05T01:16:26Z", "author": {"login": "rhauch"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/util/SharedTopicAdminTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.connect.util;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import org.apache.kafka.connect.errors.ConnectException;\n+import org.easymock.EasyMock;\n+import org.easymock.Mock;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.powermock.api.easymock.PowerMock;\n+import org.powermock.core.classloader.annotations.PowerMockIgnore;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest(KafkaBasedLog.class)\n+@PowerMockIgnore(\"javax.management.*\")\n+public class SharedTopicAdminTest {\n+\n+    private static final Map<String, Object> CONFIG = Collections.emptyMap();\n+\n+    @Mock private TopicAdmin mockTopicAdmin;\n+    private SharedTopicAdmin sharedAdmin;\n+    private int created = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5MjEyNg=="}, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDc0NzI1OA==", "bodyText": "I know. It's just that we already use a mocking framework and we could use something like:\nEasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();\nif we also defined factory to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570747258", "createdAt": "2021-02-05T06:28:21Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/util/SharedTopicAdminTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.connect.util;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import org.apache.kafka.connect.errors.ConnectException;\n+import org.easymock.EasyMock;\n+import org.easymock.Mock;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.powermock.api.easymock.PowerMock;\n+import org.powermock.core.classloader.annotations.PowerMockIgnore;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest(KafkaBasedLog.class)\n+@PowerMockIgnore(\"javax.management.*\")\n+public class SharedTopicAdminTest {\n+\n+    private static final Map<String, Object> CONFIG = Collections.emptyMap();\n+\n+    @Mock private TopicAdmin mockTopicAdmin;\n+    private SharedTopicAdmin sharedAdmin;\n+    private int created = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5MjEyNg=="}, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjI1NjM5Mg==", "bodyText": "I vaguely remember struggling with getting EasyMock to work properly when I originally created this PR, but I tried it again just to be sure.\nUnfortunately, the SharedTopicAdmin constructor takes a method reference, and apparently EasyMock provides no way to effectively mock the behavior of a method passed via a method reference. See this still-open EasyMock issue for details.\nSo, while I agree using mocks to verify the # of times the factor is invoked, because EasyMock can't really mock method references means we're stuck with the current code using the counter.", "url": "https://github.com/apache/kafka/pull/9780#discussion_r572256392", "createdAt": "2021-02-08T18:03:00Z", "author": {"login": "rhauch"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/util/SharedTopicAdminTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.connect.util;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import org.apache.kafka.connect.errors.ConnectException;\n+import org.easymock.EasyMock;\n+import org.easymock.Mock;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.powermock.api.easymock.PowerMock;\n+import org.powermock.core.classloader.annotations.PowerMockIgnore;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest(KafkaBasedLog.class)\n+@PowerMockIgnore(\"javax.management.*\")\n+public class SharedTopicAdminTest {\n+\n+    private static final Map<String, Object> CONFIG = Collections.emptyMap();\n+\n+    @Mock private TopicAdmin mockTopicAdmin;\n+    private SharedTopicAdmin sharedAdmin;\n+    private int created = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5MjEyNg=="}, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MjQyMTc3MQ==", "bodyText": "Okay, Mockito FTW! I've rewritten the SharedTopicAdminTest class to use Mockito instead of PowerMock and EasyMock, and was able to use mocks to assert the correct number of times an admin instance was created and closed.", "url": "https://github.com/apache/kafka/pull/9780#discussion_r572421771", "createdAt": "2021-02-08T22:27:20Z", "author": {"login": "rhauch"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/util/SharedTopicAdminTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.connect.util;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import org.apache.kafka.connect.errors.ConnectException;\n+import org.easymock.EasyMock;\n+import org.easymock.Mock;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.powermock.api.easymock.PowerMock;\n+import org.powermock.core.classloader.annotations.PowerMockIgnore;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest(KafkaBasedLog.class)\n+@PowerMockIgnore(\"javax.management.*\")\n+public class SharedTopicAdminTest {\n+\n+    private static final Map<String, Object> CONFIG = Collections.emptyMap();\n+\n+    @Mock private TopicAdmin mockTopicAdmin;\n+    private SharedTopicAdmin sharedAdmin;\n+    private int created = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5MjEyNg=="}, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5NTU2MzE5OnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/util/TopicAdminTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMjo0NDo1NVrOIgKZfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQwMTowOTo0NFrOIgN4dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5NTcxMA==", "bodyText": "curious, what is the array symbolizing here now?\nWe used to have 1 value. Is this ISR nodes? Do we even need to add or remove any?", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570595710", "createdAt": "2021-02-04T22:44:55Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/util/TopicAdminTest.java", "diffHunk": "@@ -457,17 +465,273 @@ public void verifyingGettingTopicCleanupPolicies() {\n         }\n     }\n \n+    @Test\n+    public void endOffsetsShouldFailWithNonRetriableWhenAuthorizationFailureOccurs() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        Long offset = null; // response should use error\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithClusterAuthorizationException(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            ConnectException e = assertThrows(ConnectException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"Not authorized to get the end offsets\"));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldFailWithNonRetriableWhenVersionUnsupportedErrorOccurs() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        Long offset = null; // response should use error\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithUnsupportedVersion(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            ConnectException e = assertThrows(ConnectException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"is unsupported on brokers\"));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldFailWithRetriableWhenTimeoutErrorOccurs() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        Long offset = null; // response should use error\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithTimeout(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            RetriableException e = assertThrows(RetriableException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"Timed out while waiting\"));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldFailWithNonRetriableWhenUnknownErrorOccurs() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        Long offset = null; // response should use error\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithUnknownError(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            ConnectException e = assertThrows(ConnectException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"Error while getting end offsets for topic\"));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldReturnEmptyMapWhenPartitionsSetIsNull() {\n+        String topicName = \"myTopic\";\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            Map<TopicPartition, Long> offsets = admin.endOffsets(Collections.emptySet());\n+            assertTrue(offsets.isEmpty());\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldReturnOffsetsForOnePartition() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        long offset = 1000L;\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResult(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            Map<TopicPartition, Long> offsets = admin.endOffsets(tps);\n+            assertEquals(1, offsets.size());\n+            assertEquals(Long.valueOf(offset), offsets.get(tp1));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldReturnOffsetsForMultiplePartitions() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        TopicPartition tp2 = new TopicPartition(topicName, 1);\n+        Set<TopicPartition> tps = new HashSet<>(Arrays.asList(tp1, tp2));\n+        long offset1 = 1001;\n+        long offset2 = 1002;\n+        Cluster cluster = createCluster(1, topicName, 2);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResult(tp1, offset1, tp2, offset2));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            Map<TopicPartition, Long> offsets = admin.endOffsets(tps);\n+            assertEquals(2, offsets.size());\n+            assertEquals(Long.valueOf(offset1), offsets.get(tp1));\n+            assertEquals(Long.valueOf(offset2), offsets.get(tp2));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldFailWhenAnyTopicPartitionHasError() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        long offset = 1000;\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithClusterAuthorizationException(tp1, null));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            ConnectException e = assertThrows(ConnectException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"Not authorized to get the end offsets\"));\n+        }\n+    }\n+\n     private Cluster createCluster(int numNodes) {\n+        return createCluster(numNodes, \"unused\", 0);\n+    }\n+\n+    private Cluster createCluster(int numNodes, String topicName, int partitions) {\n+        Node[] nodeArray = new Node[numNodes];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY1Mjc5MQ==", "bodyText": "Yes, these are just the ISRs for the one partition that we set up the cluster with.\nThe utility method did allow multiple nodes, but we don't really use that much in this class. I think this changed because we now have to define the PartitionInfo instances rather than an empty map. Not sure why that's now different, but supplying the empty infos definitely caused problems in these new tests.", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570652791", "createdAt": "2021-02-05T01:09:44Z", "author": {"login": "rhauch"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/util/TopicAdminTest.java", "diffHunk": "@@ -457,17 +465,273 @@ public void verifyingGettingTopicCleanupPolicies() {\n         }\n     }\n \n+    @Test\n+    public void endOffsetsShouldFailWithNonRetriableWhenAuthorizationFailureOccurs() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        Long offset = null; // response should use error\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithClusterAuthorizationException(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            ConnectException e = assertThrows(ConnectException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"Not authorized to get the end offsets\"));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldFailWithNonRetriableWhenVersionUnsupportedErrorOccurs() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        Long offset = null; // response should use error\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithUnsupportedVersion(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            ConnectException e = assertThrows(ConnectException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"is unsupported on brokers\"));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldFailWithRetriableWhenTimeoutErrorOccurs() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        Long offset = null; // response should use error\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithTimeout(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            RetriableException e = assertThrows(RetriableException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"Timed out while waiting\"));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldFailWithNonRetriableWhenUnknownErrorOccurs() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        Long offset = null; // response should use error\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithUnknownError(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            ConnectException e = assertThrows(ConnectException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"Error while getting end offsets for topic\"));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldReturnEmptyMapWhenPartitionsSetIsNull() {\n+        String topicName = \"myTopic\";\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            Map<TopicPartition, Long> offsets = admin.endOffsets(Collections.emptySet());\n+            assertTrue(offsets.isEmpty());\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldReturnOffsetsForOnePartition() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        long offset = 1000L;\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResult(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            Map<TopicPartition, Long> offsets = admin.endOffsets(tps);\n+            assertEquals(1, offsets.size());\n+            assertEquals(Long.valueOf(offset), offsets.get(tp1));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldReturnOffsetsForMultiplePartitions() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        TopicPartition tp2 = new TopicPartition(topicName, 1);\n+        Set<TopicPartition> tps = new HashSet<>(Arrays.asList(tp1, tp2));\n+        long offset1 = 1001;\n+        long offset2 = 1002;\n+        Cluster cluster = createCluster(1, topicName, 2);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResult(tp1, offset1, tp2, offset2));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            Map<TopicPartition, Long> offsets = admin.endOffsets(tps);\n+            assertEquals(2, offsets.size());\n+            assertEquals(Long.valueOf(offset1), offsets.get(tp1));\n+            assertEquals(Long.valueOf(offset2), offsets.get(tp2));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldFailWhenAnyTopicPartitionHasError() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        long offset = 1000;\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithClusterAuthorizationException(tp1, null));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            ConnectException e = assertThrows(ConnectException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"Not authorized to get the end offsets\"));\n+        }\n+    }\n+\n     private Cluster createCluster(int numNodes) {\n+        return createCluster(numNodes, \"unused\", 0);\n+    }\n+\n+    private Cluster createCluster(int numNodes, String topicName, int partitions) {\n+        Node[] nodeArray = new Node[numNodes];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5NTcxMA=="}, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5NTYwNDI2OnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/SharedTopicAdmin.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMjo1NzozNVrOIgKxxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQwNToyNzoyNlrOIgShyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDYwMTkyNg==", "bodyText": "It's not immediately obvious to me what's the advantage compared to a synchronized topicAdmin or even get.\nI see that the value can go back to null. But we already have the guard with the closed to atomically decide whether this is closed or not. Lmk if I'm missing something, but I feel the points of indirection might be a few more than they have to be here (we have no gains in locking, since we'll need to atomically updateAndGet in every get and the advantage vs synchronized should be negligible here).", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570601926", "createdAt": "2021-02-04T22:57:35Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/SharedTopicAdmin.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.connect.util;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.function.UnaryOperator;\n+\n+import org.apache.kafka.clients.admin.AdminClientConfig;\n+import org.apache.kafka.connect.errors.ConnectException;\n+\n+/**\n+ * A holder of a {@link TopicAdmin} object that is lazily and atomically created when needed by multiple callers.\n+ * As soon as one of the getters is called, all getters will return the same shared {@link TopicAdmin}\n+ * instance until this SharedAdmin is closed via {@link #close()} or {@link #close(Duration)}.\n+ *\n+ * <p>The owner of this object is responsible for ensuring that either {@link #close()} or {@link #close(Duration)}\n+ * is called when the {@link TopicAdmin} instance is no longer needed. Consequently, once this\n+ * {@link SharedTopicAdmin} instance has been closed, the {@link #get()} and {@link #topicAdmin()} methods,\n+ * nor any previously returned {@link TopicAdmin} instances may be used.\n+ *\n+ * <p>This class is thread-safe. It also appears as immutable to callers that obtain the {@link TopicAdmin} object,\n+ * until this object is closed, at which point it cannot be used anymore\n+ */\n+public class SharedTopicAdmin implements AutoCloseable, Supplier<TopicAdmin> {\n+\n+    // Visible for testing\n+    static final Duration DEFAULT_CLOSE_DURATION = Duration.ofMillis(Long.MAX_VALUE);\n+\n+    private final Map<String, Object> adminProps;\n+    private final AtomicReference<TopicAdmin> admin = new AtomicReference<>();\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final Function<Map<String, Object>, TopicAdmin> factory;\n+\n+    public SharedTopicAdmin(Map<String, Object> adminProps) {\n+        this(adminProps, TopicAdmin::new);\n+    }\n+\n+    // Visible for testing\n+    SharedTopicAdmin(Map<String, Object> adminProps, Function<Map<String, Object>, TopicAdmin> factory) {\n+        this.adminProps = Objects.requireNonNull(adminProps);\n+        this.factory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Get the shared {@link TopicAdmin} instance.\n+     *\n+     * @return the shared instance; never null\n+     * @throws ConnectException if this object has already been closed\n+     */\n+    @Override\n+    public TopicAdmin get() {\n+        return topicAdmin();\n+    }\n+\n+    /**\n+     * Get the shared {@link TopicAdmin} instance.\n+     *\n+     * @return the shared instance; never null\n+     * @throws ConnectException if this object has already been closed\n+     */\n+    public TopicAdmin topicAdmin() {\n+        return admin.updateAndGet(this::createAdmin);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY1NzAyOA==", "bodyText": "I'm not sure there is much advantage either way, considering these methods are not called frequently and synchronized would indeed work. I personally like the simplicity of using AtomicReference, which to me seemed natural and straightforward, avoided having to synchronize the entire methods, and needed no if-checks in this method.", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570657028", "createdAt": "2021-02-05T01:22:27Z", "author": {"login": "rhauch"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/SharedTopicAdmin.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.connect.util;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.function.UnaryOperator;\n+\n+import org.apache.kafka.clients.admin.AdminClientConfig;\n+import org.apache.kafka.connect.errors.ConnectException;\n+\n+/**\n+ * A holder of a {@link TopicAdmin} object that is lazily and atomically created when needed by multiple callers.\n+ * As soon as one of the getters is called, all getters will return the same shared {@link TopicAdmin}\n+ * instance until this SharedAdmin is closed via {@link #close()} or {@link #close(Duration)}.\n+ *\n+ * <p>The owner of this object is responsible for ensuring that either {@link #close()} or {@link #close(Duration)}\n+ * is called when the {@link TopicAdmin} instance is no longer needed. Consequently, once this\n+ * {@link SharedTopicAdmin} instance has been closed, the {@link #get()} and {@link #topicAdmin()} methods,\n+ * nor any previously returned {@link TopicAdmin} instances may be used.\n+ *\n+ * <p>This class is thread-safe. It also appears as immutable to callers that obtain the {@link TopicAdmin} object,\n+ * until this object is closed, at which point it cannot be used anymore\n+ */\n+public class SharedTopicAdmin implements AutoCloseable, Supplier<TopicAdmin> {\n+\n+    // Visible for testing\n+    static final Duration DEFAULT_CLOSE_DURATION = Duration.ofMillis(Long.MAX_VALUE);\n+\n+    private final Map<String, Object> adminProps;\n+    private final AtomicReference<TopicAdmin> admin = new AtomicReference<>();\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final Function<Map<String, Object>, TopicAdmin> factory;\n+\n+    public SharedTopicAdmin(Map<String, Object> adminProps) {\n+        this(adminProps, TopicAdmin::new);\n+    }\n+\n+    // Visible for testing\n+    SharedTopicAdmin(Map<String, Object> adminProps, Function<Map<String, Object>, TopicAdmin> factory) {\n+        this.adminProps = Objects.requireNonNull(adminProps);\n+        this.factory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Get the shared {@link TopicAdmin} instance.\n+     *\n+     * @return the shared instance; never null\n+     * @throws ConnectException if this object has already been closed\n+     */\n+    @Override\n+    public TopicAdmin get() {\n+        return topicAdmin();\n+    }\n+\n+    /**\n+     * Get the shared {@link TopicAdmin} instance.\n+     *\n+     * @return the shared instance; never null\n+     * @throws ConnectException if this object has already been closed\n+     */\n+    public TopicAdmin topicAdmin() {\n+        return admin.updateAndGet(this::createAdmin);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDYwMTkyNg=="}, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDcyODkwNg==", "bodyText": "I'm happy to leave it as an example of the pattern that demonstrates how to apply updateAndGet.\nI just didn't feel that the two or three levels of indirection were worth to write the singleton pattern differently.", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570728906", "createdAt": "2021-02-05T05:27:26Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/SharedTopicAdmin.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.connect.util;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.function.UnaryOperator;\n+\n+import org.apache.kafka.clients.admin.AdminClientConfig;\n+import org.apache.kafka.connect.errors.ConnectException;\n+\n+/**\n+ * A holder of a {@link TopicAdmin} object that is lazily and atomically created when needed by multiple callers.\n+ * As soon as one of the getters is called, all getters will return the same shared {@link TopicAdmin}\n+ * instance until this SharedAdmin is closed via {@link #close()} or {@link #close(Duration)}.\n+ *\n+ * <p>The owner of this object is responsible for ensuring that either {@link #close()} or {@link #close(Duration)}\n+ * is called when the {@link TopicAdmin} instance is no longer needed. Consequently, once this\n+ * {@link SharedTopicAdmin} instance has been closed, the {@link #get()} and {@link #topicAdmin()} methods,\n+ * nor any previously returned {@link TopicAdmin} instances may be used.\n+ *\n+ * <p>This class is thread-safe. It also appears as immutable to callers that obtain the {@link TopicAdmin} object,\n+ * until this object is closed, at which point it cannot be used anymore\n+ */\n+public class SharedTopicAdmin implements AutoCloseable, Supplier<TopicAdmin> {\n+\n+    // Visible for testing\n+    static final Duration DEFAULT_CLOSE_DURATION = Duration.ofMillis(Long.MAX_VALUE);\n+\n+    private final Map<String, Object> adminProps;\n+    private final AtomicReference<TopicAdmin> admin = new AtomicReference<>();\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final Function<Map<String, Object>, TopicAdmin> factory;\n+\n+    public SharedTopicAdmin(Map<String, Object> adminProps) {\n+        this(adminProps, TopicAdmin::new);\n+    }\n+\n+    // Visible for testing\n+    SharedTopicAdmin(Map<String, Object> adminProps, Function<Map<String, Object>, TopicAdmin> factory) {\n+        this.adminProps = Objects.requireNonNull(adminProps);\n+        this.factory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Get the shared {@link TopicAdmin} instance.\n+     *\n+     * @return the shared instance; never null\n+     * @throws ConnectException if this object has already been closed\n+     */\n+    @Override\n+    public TopicAdmin get() {\n+        return topicAdmin();\n+    }\n+\n+    /**\n+     * Get the shared {@link TopicAdmin} instance.\n+     *\n+     * @return the shared instance; never null\n+     * @throws ConnectException if this object has already been closed\n+     */\n+    public TopicAdmin topicAdmin() {\n+        return admin.updateAndGet(this::createAdmin);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDYwMTkyNg=="}, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 82}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3554, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}