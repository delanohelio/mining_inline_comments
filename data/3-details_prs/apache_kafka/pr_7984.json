{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0NTIwOTQ3", "number": 7984, "title": "KAFKA-9445: Allow adding changes to allow serving from a specific partition", "bodyText": "This is the implementation of KIP-562: https://cwiki.apache.org/confluence/display/KAFKA/KIP-562%3A+Allow+fetching+a+key+from+a+single+partition+rather+than+iterating+over+all+the+stores+on+an+instance\nCommitter Checklist (excluded from commit message)\n\n  Verify design and implementation\n  Verify test coverage and CI build status\n  Verify documentation (including upgrade notes)", "createdAt": "2020-01-19T10:39:14Z", "url": "https://github.com/apache/kafka/pull/7984", "merged": true, "mergeCommit": {"oid": "05b2361c0412be25877cb106e9847e9a8a4f622a"}, "closed": true, "closedAt": "2020-01-30T07:45:48Z", "author": {"login": "brary"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb71aGKAH2gAyMzY0NTIwOTQ3OmQxYmI2YzgyYTg0OTMzMmZhNTM4NzUwMDYxZGQxOTVjOTUzMzI4NWU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb_Vn8yAFqTM1MDYxNjc4OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d1bb6c82a849332fa538750061dd195c9533285e", "author": {"user": {"login": "brary", "name": "Navinder Pal Singh Brar"}}, "url": "https://github.com/apache/kafka/commit/d1bb6c82a849332fa538750061dd195c9533285e", "committedDate": "2020-01-19T10:29:56Z", "message": "adding changes to allow serving from a specific partition"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b741148d41df0f015d418f1b1671670c617a28a2", "author": {"user": {"login": "brary", "name": "Navinder Pal Singh Brar"}}, "url": "https://github.com/apache/kafka/commit/b741148d41df0f015d418f1b1671670c617a28a2", "committedDate": "2020-01-19T11:32:09Z", "message": "Updating the function usage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05d3145a73976a73b3ddc14663aa825edb4c6f87", "author": {"user": {"login": "brary", "name": "Navinder Pal Singh Brar"}}, "url": "https://github.com/apache/kafka/commit/05d3145a73976a73b3ddc14663aa825edb4c6f87", "committedDate": "2020-01-22T10:11:45Z", "message": "Addressing code review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0a4f537bcd8adcc81c7ac98f0c37c651c69a6ef", "author": {"user": {"login": "brary", "name": "Navinder Pal Singh Brar"}}, "url": "https://github.com/apache/kafka/commit/d0a4f537bcd8adcc81c7ac98f0c37c651c69a6ef", "committedDate": "2020-01-22T10:28:35Z", "message": "Minor bug fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd1a270fd7fd0a0400713737d9fe0bd82ab813e5", "author": {"user": {"login": "brary", "name": "Navinder Pal Singh Brar"}}, "url": "https://github.com/apache/kafka/commit/bd1a270fd7fd0a0400713737d9fe0bd82ab813e5", "committedDate": "2020-01-23T06:59:55Z", "message": "Accomodating new changes in the KIP"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3Nzc0NjU3", "url": "https://github.com/apache/kafka/pull/7984#pullrequestreview-347774657", "createdAt": "2020-01-24T06:53:36Z", "commit": {"oid": "bd1a270fd7fd0a0400713737d9fe0bd82ab813e5"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNjo1MzozNlrOFhVJ9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQwNjo1NjoyM1rOFhVMEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ5Mzk0Mw==", "bodyText": "can we do a null check way at the top when the StoreQueryParams is built and avoid this special casing here..", "url": "https://github.com/apache/kafka/pull/7984#discussion_r370493943", "createdAt": "2020-01-24T06:53:36Z", "author": {"login": "vinothchandar"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/StreamThreadStateStoreProvider.java", "diffHunk": "@@ -72,8 +82,23 @@ public StreamThreadStateStoreProvider(final StreamThread streamThread) {\n         } else {\n             throw new InvalidStateStoreException(\"Cannot get state store \" + storeName + \" because the stream thread is \" +\n                                                      state + \", not RUNNING\" +\n-                                                     (includeStaleStores ? \" or REBALANCING\" : \"\"));\n+                                                     (storeQueryParams.includeStaleStores() ? \" or REBALANCING\" : \"\"));\n         }\n     }\n \n+    private TaskId createKeyTaskId(final String storeName, final Integer partition) {\n+        if (partition == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd1a270fd7fd0a0400713737d9fe0bd82ab813e5"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDQ5NDQ4Mw==", "bodyText": "this looks right to me.. (I can't be sure unless I step through the code though :))", "url": "https://github.com/apache/kafka/pull/7984#discussion_r370494483", "createdAt": "2020-01-24T06:56:23Z", "author": {"login": "vinothchandar"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/StreamThreadStateStoreProvider.java", "diffHunk": "@@ -72,8 +82,23 @@ public StreamThreadStateStoreProvider(final StreamThread streamThread) {\n         } else {\n             throw new InvalidStateStoreException(\"Cannot get state store \" + storeName + \" because the stream thread is \" +\n                                                      state + \", not RUNNING\" +\n-                                                     (includeStaleStores ? \" or REBALANCING\" : \"\"));\n+                                                     (storeQueryParams.includeStaleStores() ? \" or REBALANCING\" : \"\"));\n         }\n     }\n \n+    private TaskId createKeyTaskId(final String storeName, final Integer partition) {\n+        if (partition == null) {\n+            return null;\n+        }\n+        final List<String> sourceTopics = internalTopologyBuilder.stateStoreNameToSourceTopics().get(storeName);\n+        final Set<String> sourceTopicsSet = sourceTopics.stream().collect(Collectors.toSet());\n+        final Map<Integer, InternalTopologyBuilder.TopicsInfo> topicGroups = internalTopologyBuilder.topicGroups();\n+        for (final Map.Entry<Integer, InternalTopologyBuilder.TopicsInfo> topicGroup : topicGroups.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd1a270fd7fd0a0400713737d9fe0bd82ab813e5"}, "originalPosition": 70}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "821e793df962f8ed1a68549cfacfe4c278f54488", "author": {"user": {"login": "brary", "name": "Navinder Pal Singh Brar"}}, "url": "https://github.com/apache/kafka/commit/821e793df962f8ed1a68549cfacfe4c278f54488", "committedDate": "2020-01-24T10:21:47Z", "message": "Addressing code review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d6667564718fb743e5186b79ed297e5767d033a", "author": {"user": {"login": "brary", "name": "Navinder Pal Singh Brar"}}, "url": "https://github.com/apache/kafka/commit/1d6667564718fb743e5186b79ed297e5767d033a", "committedDate": "2020-01-24T10:32:16Z", "message": "Fixing checkstyles"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c2f99dc6c1c42ac363cb45338742b8576a62dd6", "author": {"user": {"login": "brary", "name": "Navinder Pal Singh Brar"}}, "url": "https://github.com/apache/kafka/commit/5c2f99dc6c1c42ac363cb45338742b8576a62dd6", "committedDate": "2020-01-25T09:32:47Z", "message": "Adding intergration test for store query params:"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44", "author": {"user": {"login": "brary", "name": "Navinder Pal Singh Brar"}}, "url": "https://github.com/apache/kafka/commit/42ded2caf421de95ad307b7212bb8d93092e6c44", "committedDate": "2020-01-25T09:36:01Z", "message": "Removing dead code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNDg0OTYx", "url": "https://github.com/apache/kafka/pull/7984#pullrequestreview-350484961", "createdAt": "2020-01-29T22:59:57Z", "commit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "state": "COMMENTED", "comments": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMjo1OTo1N1rOFjafew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMzo1NTowN1rOFjbg8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY3ODUyMw==", "bodyText": "We should add a @deprecated annotation to the JavaDocs:\n@depreated since 2.5 release; use {@link #store(StoreQueryParams)} instead", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372678523", "createdAt": "2020-01-29T22:59:57Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -1176,31 +1176,32 @@ public void cleanUp() {\n      * @throws InvalidStateStoreException if Kafka Streams is (re-)initializing or a store with {@code storeName} and\n      * {@code queryableStoreType} doesn't exist\n      */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY3OTA2Mg==", "bodyText": "As we deprecate this method, I would remove the whole paragraph (that was added via KIP-535 and not necessary any longer)", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372679062", "createdAt": "2020-01-29T23:01:25Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -1166,8 +1166,8 @@ public void cleanUp() {\n      * The returned object can be used to query the {@link StateStore} instances.\n      *\n      * Only permits queries on active replicas of the store (no standbys or restoring replicas).\n-     * See {@link KafkaStreams#store(java.lang.String, org.apache.kafka.streams.state.QueryableStoreType, boolean)}\n-     * for the option to set {@code includeStaleStores} to true and trade off consistency in favor of availability.\n+     * See {@link KafkaStreams#store(StoreQueryParams)}\n+     * for the option to set {@code StoreQueryParams.withIncludeStaleStores()} and trade off consistency in favor of availability.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY3OTM3Ng==", "bodyText": "We should not explain how StoreQueryParams works -- this should to into StoreQueryParams JavaDocs -- we should just keep the first sentence of the paragraph.", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372679376", "createdAt": "2020-01-29T23:02:20Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -1176,31 +1176,32 @@ public void cleanUp() {\n      * @throws InvalidStateStoreException if Kafka Streams is (re-)initializing or a store with {@code storeName} and\n      * {@code queryableStoreType} doesn't exist\n      */\n+    @Deprecated\n     public <T> T store(final String storeName, final QueryableStoreType<T> queryableStoreType) {\n-        return store(storeName, queryableStoreType, false);\n+        return store(StoreQueryParams.fromNameAndType(storeName, queryableStoreType));\n     }\n \n     /**\n-     * Get a facade wrapping the local {@link StateStore} instances with the provided {@code storeName} if the Store's\n+     * Get a facade wrapping the local {@link StateStore} instances with the provided {@link StoreQueryParams}.\n+     * StoreQueryParams need required parameters to be set, which are {@code storeName} and if\n      * type is accepted by the provided {@link QueryableStoreType#accepts(StateStore) queryableStoreType}.\n+     * The optional parameters to the StoreQueryParams include {@code partition} and {@code staleStoresEnabled}.\n      * The returned object can be used to query the {@link StateStore} instances.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY3OTYwMQ==", "bodyText": "Same as above -- we should keep the parameter description brief, as this content belong into the JavaDocs of StoreQueryParams", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372679601", "createdAt": "2020-01-29T23:03:04Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -1176,31 +1176,32 @@ public void cleanUp() {\n      * @throws InvalidStateStoreException if Kafka Streams is (re-)initializing or a store with {@code storeName} and\n      * {@code queryableStoreType} doesn't exist\n      */\n+    @Deprecated\n     public <T> T store(final String storeName, final QueryableStoreType<T> queryableStoreType) {\n-        return store(storeName, queryableStoreType, false);\n+        return store(StoreQueryParams.fromNameAndType(storeName, queryableStoreType));\n     }\n \n     /**\n-     * Get a facade wrapping the local {@link StateStore} instances with the provided {@code storeName} if the Store's\n+     * Get a facade wrapping the local {@link StateStore} instances with the provided {@link StoreQueryParams}.\n+     * StoreQueryParams need required parameters to be set, which are {@code storeName} and if\n      * type is accepted by the provided {@link QueryableStoreType#accepts(StateStore) queryableStoreType}.\n+     * The optional parameters to the StoreQueryParams include {@code partition} and {@code staleStoresEnabled}.\n      * The returned object can be used to query the {@link StateStore} instances.\n      *\n-     * @param storeName           name of the store to find\n-     * @param queryableStoreType  accept only stores that are accepted by {@link QueryableStoreType#accepts(StateStore)}\n-     * @param includeStaleStores      If false, only permit queries on the active replica for a partition, and only if the\n-     *                            task for that partition is running. I.e., the state store is not a standby replica,\n-     *                            and it is not restoring from the changelog.\n-     *                            If true, allow queries on standbys and restoring replicas in addition to active ones.\n+     * @param storeQueryParams    If StoreQueryParams.fromNameAndType(storeName, queryableStoreType).withPartition(int partition) is used, it allow queries on the specific partition irrespective if it is a standby\n+     *                            or a restoring replicas in addition to active ones.\n+     *                            If StoreQueryParams.fromNameAndType(storeName, queryableStoreType).withIncludeStaleStores() is used, it allow queries on standbys and restoring replicas in addition to active ones for all the local partitions on the instance.\n+     *                            If StoreQueryParams.fromNameAndType(storeName, queryableStoreType).withIncludeStaleStores().withPartition(int partition), it allow queries on the specific partition irrespective if it is a standby\n+     *                            or a restoring replicas in addition to active ones..\n+     *                            By default, if just storeQueryParams is used, it returns all the local partitions for the store which are in running state.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY3OTcyMA==", "bodyText": "Nit. Line too long", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372679720", "createdAt": "2020-01-29T23:03:26Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting. The options would be whether a user would want to enable/disable stale stores* or whether it knows the list of partitions that it specifically wants to fetch. If this information is not provided the default behavior is to fetch the stores for all the partitions available on that instance* for that particular store name.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY3OTk1MQ==", "bodyText": "nit: {@link KeyQueryMetadata}", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372679951", "createdAt": "2020-01-29T23:04:06Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting. The options would be whether a user would want to enable/disable stale stores* or whether it knows the list of partitions that it specifically wants to fetch. If this information is not provided the default behavior is to fetch the stores for all the partitions available on that instance* for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the  KeyQueryMetadata.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4MDEzMw==", "bodyText": "nit: line too long.\nfinal not required -- a static method cannot be overwritten anyway", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372680133", "createdAt": "2020-01-29T23:04:41Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting. The options would be whether a user would want to enable/disable stale stores* or whether it knows the list of partitions that it specifically wants to fetch. If this information is not provided the default behavior is to fetch the stores for all the partitions available on that instance* for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the  KeyQueryMetadata.\n+ */\n+public class StoreQueryParams<T> {\n+\n+    private Integer partition;\n+    private boolean staleStores;\n+    private final String storeName;\n+    private final QueryableStoreType<T> queryableStoreType;\n+\n+    private StoreQueryParams(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        this.storeName = storeName;\n+        this.queryableStoreType = queryableStoreType;\n+    }\n+\n+    public static final <T> StoreQueryParams<T> fromNameAndType(final String storeName, final QueryableStoreType<T>  queryableStoreType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4MDkxMQ==", "bodyText": "Why new<T> ? I am not familiar with this syntax? Seems a simple new should be sufficient?", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372680911", "createdAt": "2020-01-29T23:07:16Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting. The options would be whether a user would want to enable/disable stale stores* or whether it knows the list of partitions that it specifically wants to fetch. If this information is not provided the default behavior is to fetch the stores for all the partitions available on that instance* for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the  KeyQueryMetadata.\n+ */\n+public class StoreQueryParams<T> {\n+\n+    private Integer partition;\n+    private boolean staleStores;\n+    private final String storeName;\n+    private final QueryableStoreType<T> queryableStoreType;\n+\n+    private StoreQueryParams(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        this.storeName = storeName;\n+        this.queryableStoreType = queryableStoreType;\n+    }\n+\n+    public static final <T> StoreQueryParams<T> fromNameAndType(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        return new<T> StoreQueryParams<T>(storeName, queryableStoreType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4MTIyMA==", "bodyText": "QueryableStoreProvider is a internal class and we should not mention it in the JavaDocs.\ntypo [q]eryable store", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372681220", "createdAt": "2020-01-29T23:08:15Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting. The options would be whether a user would want to enable/disable stale stores* or whether it knows the list of partitions that it specifically wants to fetch. If this information is not provided the default behavior is to fetch the stores for all the partitions available on that instance* for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the  KeyQueryMetadata.\n+ */\n+public class StoreQueryParams<T> {\n+\n+    private Integer partition;\n+    private boolean staleStores;\n+    private final String storeName;\n+    private final QueryableStoreType<T> queryableStoreType;\n+\n+    private StoreQueryParams(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        this.storeName = storeName;\n+        this.queryableStoreType = queryableStoreType;\n+    }\n+\n+    public static final <T> StoreQueryParams<T> fromNameAndType(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        return new<T> StoreQueryParams<T>(storeName, queryableStoreType);\n+    }\n+\n+    /**\n+     * Get the partition to be used to fetch list of Queryable store from QueryableStoreProvider.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4MTQ1Mw==", "bodyText": "function -> method ?\n{@code null}", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372681453", "createdAt": "2020-01-29T23:08:57Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting. The options would be whether a user would want to enable/disable stale stores* or whether it knows the list of partitions that it specifically wants to fetch. If this information is not provided the default behavior is to fetch the stores for all the partitions available on that instance* for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the  KeyQueryMetadata.\n+ */\n+public class StoreQueryParams<T> {\n+\n+    private Integer partition;\n+    private boolean staleStores;\n+    private final String storeName;\n+    private final QueryableStoreType<T> queryableStoreType;\n+\n+    private StoreQueryParams(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        this.storeName = storeName;\n+        this.queryableStoreType = queryableStoreType;\n+    }\n+\n+    public static final <T> StoreQueryParams<T> fromNameAndType(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        return new<T> StoreQueryParams<T>(storeName, queryableStoreType);\n+    }\n+\n+    /**\n+     * Get the partition to be used to fetch list of Queryable store from QueryableStoreProvider.\n+     * If the function returns null, it would mean that no specific partition has been requested so all the local partitions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4MTY4OQ==", "bodyText": "{@code true}", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372681689", "createdAt": "2020-01-29T23:09:43Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting. The options would be whether a user would want to enable/disable stale stores* or whether it knows the list of partitions that it specifically wants to fetch. If this information is not provided the default behavior is to fetch the stores for all the partitions available on that instance* for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the  KeyQueryMetadata.\n+ */\n+public class StoreQueryParams<T> {\n+\n+    private Integer partition;\n+    private boolean staleStores;\n+    private final String storeName;\n+    private final QueryableStoreType<T> queryableStoreType;\n+\n+    private StoreQueryParams(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        this.storeName = storeName;\n+        this.queryableStoreType = queryableStoreType;\n+    }\n+\n+    public static final <T> StoreQueryParams<T> fromNameAndType(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        return new<T> StoreQueryParams<T>(storeName, queryableStoreType);\n+    }\n+\n+    /**\n+     * Get the partition to be used to fetch list of Queryable store from QueryableStoreProvider.\n+     * If the function returns null, it would mean that no specific partition has been requested so all the local partitions\n+     * for the store will be returned.\n+     *\n+     * @return Integer partition\n+     */\n+    public Integer partition() {\n+        return partition;\n+    }\n+\n+    /**\n+     * Get the flag staleStores. If true, include standbys and recovering stores along with running stores.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4MTkxNg==", "bodyText": "We agree to make helper classes immutable -- hence, we should create a new object instead of returning this", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372681916", "createdAt": "2020-01-29T23:10:29Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting. The options would be whether a user would want to enable/disable stale stores* or whether it knows the list of partitions that it specifically wants to fetch. If this information is not provided the default behavior is to fetch the stores for all the partitions available on that instance* for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the  KeyQueryMetadata.\n+ */\n+public class StoreQueryParams<T> {\n+\n+    private Integer partition;\n+    private boolean staleStores;\n+    private final String storeName;\n+    private final QueryableStoreType<T> queryableStoreType;\n+\n+    private StoreQueryParams(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        this.storeName = storeName;\n+        this.queryableStoreType = queryableStoreType;\n+    }\n+\n+    public static final <T> StoreQueryParams<T> fromNameAndType(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        return new<T> StoreQueryParams<T>(storeName, queryableStoreType);\n+    }\n+\n+    /**\n+     * Get the partition to be used to fetch list of Queryable store from QueryableStoreProvider.\n+     * If the function returns null, it would mean that no specific partition has been requested so all the local partitions\n+     * for the store will be returned.\n+     *\n+     * @return Integer partition\n+     */\n+    public Integer partition() {\n+        return partition;\n+    }\n+\n+    /**\n+     * Get the flag staleStores. If true, include standbys and recovering stores along with running stores.\n+     *\n+     * @return boolean staleStores\n+     */\n+    public boolean staleStoresEnabled() {\n+        return staleStores;\n+    }\n+\n+    /**\n+     * Get the {@link StoreQueryParams} with stale(standby, restoring) stores added via fetching the stores.\n+     *\n+     * @param partition   The specific integer partition to be fetched from the stores list by using {@link StoreQueryParams}.\n+     *\n+     * @return String storeName\n+     */\n+    public StoreQueryParams<T> withPartition(final Integer partition) {\n+        this.partition = partition;\n+        return this;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4Mjg0MQ==", "bodyText": "The primary functionality of this method is to set the partition... I am confused by with stale(standby, restoring) stores added via fetching the stores -- what does this mean?\nMaybe just simplify to:\nSet a specific partition that should be queries exclusively.", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372682841", "createdAt": "2020-01-29T23:13:13Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting. The options would be whether a user would want to enable/disable stale stores* or whether it knows the list of partitions that it specifically wants to fetch. If this information is not provided the default behavior is to fetch the stores for all the partitions available on that instance* for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the  KeyQueryMetadata.\n+ */\n+public class StoreQueryParams<T> {\n+\n+    private Integer partition;\n+    private boolean staleStores;\n+    private final String storeName;\n+    private final QueryableStoreType<T> queryableStoreType;\n+\n+    private StoreQueryParams(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        this.storeName = storeName;\n+        this.queryableStoreType = queryableStoreType;\n+    }\n+\n+    public static final <T> StoreQueryParams<T> fromNameAndType(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        return new<T> StoreQueryParams<T>(storeName, queryableStoreType);\n+    }\n+\n+    /**\n+     * Get the partition to be used to fetch list of Queryable store from QueryableStoreProvider.\n+     * If the function returns null, it would mean that no specific partition has been requested so all the local partitions\n+     * for the store will be returned.\n+     *\n+     * @return Integer partition\n+     */\n+    public Integer partition() {\n+        return partition;\n+    }\n+\n+    /**\n+     * Get the flag staleStores. If true, include standbys and recovering stores along with running stores.\n+     *\n+     * @return boolean staleStores\n+     */\n+    public boolean staleStoresEnabled() {\n+        return staleStores;\n+    }\n+\n+    /**\n+     * Get the {@link StoreQueryParams} with stale(standby, restoring) stores added via fetching the stores.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4MzI4Ng==", "bodyText": "As above. Simplify to:\nEnable querying of stale state stores, i.e., allow to query active tasks during restore as well as standby tasks.", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372683286", "createdAt": "2020-01-29T23:14:43Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting. The options would be whether a user would want to enable/disable stale stores* or whether it knows the list of partitions that it specifically wants to fetch. If this information is not provided the default behavior is to fetch the stores for all the partitions available on that instance* for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the  KeyQueryMetadata.\n+ */\n+public class StoreQueryParams<T> {\n+\n+    private Integer partition;\n+    private boolean staleStores;\n+    private final String storeName;\n+    private final QueryableStoreType<T> queryableStoreType;\n+\n+    private StoreQueryParams(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        this.storeName = storeName;\n+        this.queryableStoreType = queryableStoreType;\n+    }\n+\n+    public static final <T> StoreQueryParams<T> fromNameAndType(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        return new<T> StoreQueryParams<T>(storeName, queryableStoreType);\n+    }\n+\n+    /**\n+     * Get the partition to be used to fetch list of Queryable store from QueryableStoreProvider.\n+     * If the function returns null, it would mean that no specific partition has been requested so all the local partitions\n+     * for the store will be returned.\n+     *\n+     * @return Integer partition\n+     */\n+    public Integer partition() {\n+        return partition;\n+    }\n+\n+    /**\n+     * Get the flag staleStores. If true, include standbys and recovering stores along with running stores.\n+     *\n+     * @return boolean staleStores\n+     */\n+    public boolean staleStoresEnabled() {\n+        return staleStores;\n+    }\n+\n+    /**\n+     * Get the {@link StoreQueryParams} with stale(standby, restoring) stores added via fetching the stores.\n+     *\n+     * @param partition   The specific integer partition to be fetched from the stores list by using {@link StoreQueryParams}.\n+     *\n+     * @return String storeName\n+     */\n+    public StoreQueryParams<T> withPartition(final Integer partition) {\n+        this.partition = partition;\n+        return this;\n+    }\n+\n+    /**\n+     * Get the {@link StoreQueryParams} with stale(standby, restoring) stores added via fetching the stores.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4Mzk1MA==", "bodyText": "-> storeName() (without get)", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372683950", "createdAt": "2020-01-29T23:16:56Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting. The options would be whether a user would want to enable/disable stale stores* or whether it knows the list of partitions that it specifically wants to fetch. If this information is not provided the default behavior is to fetch the stores for all the partitions available on that instance* for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the  KeyQueryMetadata.\n+ */\n+public class StoreQueryParams<T> {\n+\n+    private Integer partition;\n+    private boolean staleStores;\n+    private final String storeName;\n+    private final QueryableStoreType<T> queryableStoreType;\n+\n+    private StoreQueryParams(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        this.storeName = storeName;\n+        this.queryableStoreType = queryableStoreType;\n+    }\n+\n+    public static final <T> StoreQueryParams<T> fromNameAndType(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        return new<T> StoreQueryParams<T>(storeName, queryableStoreType);\n+    }\n+\n+    /**\n+     * Get the partition to be used to fetch list of Queryable store from QueryableStoreProvider.\n+     * If the function returns null, it would mean that no specific partition has been requested so all the local partitions\n+     * for the store will be returned.\n+     *\n+     * @return Integer partition\n+     */\n+    public Integer partition() {\n+        return partition;\n+    }\n+\n+    /**\n+     * Get the flag staleStores. If true, include standbys and recovering stores along with running stores.\n+     *\n+     * @return boolean staleStores\n+     */\n+    public boolean staleStoresEnabled() {\n+        return staleStores;\n+    }\n+\n+    /**\n+     * Get the {@link StoreQueryParams} with stale(standby, restoring) stores added via fetching the stores.\n+     *\n+     * @param partition   The specific integer partition to be fetched from the stores list by using {@link StoreQueryParams}.\n+     *\n+     * @return String storeName\n+     */\n+    public StoreQueryParams<T> withPartition(final Integer partition) {\n+        this.partition = partition;\n+        return this;\n+    }\n+\n+    /**\n+     * Get the {@link StoreQueryParams} with stale(standby, restoring) stores added via fetching the stores.\n+     *\n+     * @return String storeName\n+     */\n+    public StoreQueryParams<T> enableStaleStores() {\n+        this.staleStores = true;\n+        return this;\n+    }\n+\n+    /**\n+     * Get the store name for which key is queried by the user.\n+     *\n+     * @return String storeName\n+     */\n+    public String getStoreName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4NDAyOQ==", "bodyText": "queryableStoreType()", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372684029", "createdAt": "2020-01-29T23:17:11Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting. The options would be whether a user would want to enable/disable stale stores* or whether it knows the list of partitions that it specifically wants to fetch. If this information is not provided the default behavior is to fetch the stores for all the partitions available on that instance* for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the  KeyQueryMetadata.\n+ */\n+public class StoreQueryParams<T> {\n+\n+    private Integer partition;\n+    private boolean staleStores;\n+    private final String storeName;\n+    private final QueryableStoreType<T> queryableStoreType;\n+\n+    private StoreQueryParams(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        this.storeName = storeName;\n+        this.queryableStoreType = queryableStoreType;\n+    }\n+\n+    public static final <T> StoreQueryParams<T> fromNameAndType(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        return new<T> StoreQueryParams<T>(storeName, queryableStoreType);\n+    }\n+\n+    /**\n+     * Get the partition to be used to fetch list of Queryable store from QueryableStoreProvider.\n+     * If the function returns null, it would mean that no specific partition has been requested so all the local partitions\n+     * for the store will be returned.\n+     *\n+     * @return Integer partition\n+     */\n+    public Integer partition() {\n+        return partition;\n+    }\n+\n+    /**\n+     * Get the flag staleStores. If true, include standbys and recovering stores along with running stores.\n+     *\n+     * @return boolean staleStores\n+     */\n+    public boolean staleStoresEnabled() {\n+        return staleStores;\n+    }\n+\n+    /**\n+     * Get the {@link StoreQueryParams} with stale(standby, restoring) stores added via fetching the stores.\n+     *\n+     * @param partition   The specific integer partition to be fetched from the stores list by using {@link StoreQueryParams}.\n+     *\n+     * @return String storeName\n+     */\n+    public StoreQueryParams<T> withPartition(final Integer partition) {\n+        this.partition = partition;\n+        return this;\n+    }\n+\n+    /**\n+     * Get the {@link StoreQueryParams} with stale(standby, restoring) stores added via fetching the stores.\n+     *\n+     * @return String storeName\n+     */\n+    public StoreQueryParams<T> enableStaleStores() {\n+        this.staleStores = true;\n+        return this;\n+    }\n+\n+    /**\n+     * Get the store name for which key is queried by the user.\n+     *\n+     * @return String storeName\n+     */\n+    public String getStoreName() {\n+        return storeName;\n+    }\n+\n+    /**\n+     * Get the queryable store type for which key is queried by the user.\n+     *\n+     * @return QueryableStoreType queryableStoreType\n+     */\n+    public QueryableStoreType<T> getQueryableStoreType() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4NDQ4Nw==", "bodyText": "Nit: Can we move all getters after the setters?", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372684487", "createdAt": "2020-01-29T23:18:48Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting. The options would be whether a user would want to enable/disable stale stores* or whether it knows the list of partitions that it specifically wants to fetch. If this information is not provided the default behavior is to fetch the stores for all the partitions available on that instance* for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the  KeyQueryMetadata.\n+ */\n+public class StoreQueryParams<T> {\n+\n+    private Integer partition;\n+    private boolean staleStores;\n+    private final String storeName;\n+    private final QueryableStoreType<T> queryableStoreType;\n+\n+    private StoreQueryParams(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        this.storeName = storeName;\n+        this.queryableStoreType = queryableStoreType;\n+    }\n+\n+    public static final <T> StoreQueryParams<T> fromNameAndType(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        return new<T> StoreQueryParams<T>(storeName, queryableStoreType);\n+    }\n+\n+    /**\n+     * Get the partition to be used to fetch list of Queryable store from QueryableStoreProvider.\n+     * If the function returns null, it would mean that no specific partition has been requested so all the local partitions\n+     * for the store will be returned.\n+     *\n+     * @return Integer partition\n+     */\n+    public Integer partition() {\n+        return partition;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4NDkwNQ==", "bodyText": "nit: line too long", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372684905", "createdAt": "2020-01-29T23:20:10Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/StreamThreadStateStoreProvider.java", "diffHunk": "@@ -30,27 +32,35 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n public class StreamThreadStateStoreProvider {\n \n     private final StreamThread streamThread;\n+    private final InternalTopologyBuilder internalTopologyBuilder;\n \n-    public StreamThreadStateStoreProvider(final StreamThread streamThread) {\n+    public StreamThreadStateStoreProvider(final StreamThread streamThread, final InternalTopologyBuilder internalTopologyBuilder) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4NjE4NQ==", "bodyText": "If we only need the source topics names and topic groups, we should not pass in the full InternalTopologyBuilder into this class, but only the two pieces we need.", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372686185", "createdAt": "2020-01-29T23:24:06Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/StreamThreadStateStoreProvider.java", "diffHunk": "@@ -72,8 +82,23 @@ public StreamThreadStateStoreProvider(final StreamThread streamThread) {\n         } else {\n             throw new InvalidStateStoreException(\"Cannot get state store \" + storeName + \" because the stream thread is \" +\n                                                      state + \", not RUNNING\" +\n-                                                     (includeStaleStores ? \" or REBALANCING\" : \"\"));\n+                                                     (storeQueryParams.staleStoresEnabled() ? \" or REBALANCING\" : \"\"));\n         }\n     }\n \n+    private TaskId createKeyTaskId(final String storeName, final Integer partition) {\n+        if (partition == null) {\n+            return null;\n+        }\n+        final List<String> sourceTopics = internalTopologyBuilder.stateStoreNameToSourceTopics().get(storeName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4Njc4MA==", "bodyText": "As we are only interested in the source topic ber topicGroup, we should just pass a Map<Integer, Set<String>> into this class.", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372686780", "createdAt": "2020-01-29T23:26:00Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/StreamThreadStateStoreProvider.java", "diffHunk": "@@ -72,8 +82,23 @@ public StreamThreadStateStoreProvider(final StreamThread streamThread) {\n         } else {\n             throw new InvalidStateStoreException(\"Cannot get state store \" + storeName + \" because the stream thread is \" +\n                                                      state + \", not RUNNING\" +\n-                                                     (includeStaleStores ? \" or REBALANCING\" : \"\"));\n+                                                     (storeQueryParams.staleStoresEnabled() ? \" or REBALANCING\" : \"\"));\n         }\n     }\n \n+    private TaskId createKeyTaskId(final String storeName, final Integer partition) {\n+        if (partition == null) {\n+            return null;\n+        }\n+        final List<String> sourceTopics = internalTopologyBuilder.stateStoreNameToSourceTopics().get(storeName);\n+        final Set<String> sourceTopicsSet = sourceTopics.stream().collect(Collectors.toSet());\n+        final Map<Integer, InternalTopologyBuilder.TopicsInfo> topicGroups = internalTopologyBuilder.topicGroups();\n+        for (final Map.Entry<Integer, InternalTopologyBuilder.TopicsInfo> topicGroup : topicGroups.entrySet()) {\n+            if (topicGroup.getValue().sourceTopics.containsAll(sourceTopicsSet)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4NzE0OA==", "bodyText": "nit: missing whitespace -> isnot", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372687148", "createdAt": "2020-01-29T23:27:17Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/StreamThreadStateStoreProvider.java", "diffHunk": "@@ -72,8 +82,23 @@ public StreamThreadStateStoreProvider(final StreamThread streamThread) {\n         } else {\n             throw new InvalidStateStoreException(\"Cannot get state store \" + storeName + \" because the stream thread is \" +\n                                                      state + \", not RUNNING\" +\n-                                                     (includeStaleStores ? \" or REBALANCING\" : \"\"));\n+                                                     (storeQueryParams.staleStoresEnabled() ? \" or REBALANCING\" : \"\"));\n         }\n     }\n \n+    private TaskId createKeyTaskId(final String storeName, final Integer partition) {\n+        if (partition == null) {\n+            return null;\n+        }\n+        final List<String> sourceTopics = internalTopologyBuilder.stateStoreNameToSourceTopics().get(storeName);\n+        final Set<String> sourceTopicsSet = sourceTopics.stream().collect(Collectors.toSet());\n+        final Map<Integer, InternalTopologyBuilder.TopicsInfo> topicGroups = internalTopologyBuilder.topicGroups();\n+        for (final Map.Entry<Integer, InternalTopologyBuilder.TopicsInfo> topicGroup : topicGroups.entrySet()) {\n+            if (topicGroup.getValue().sourceTopics.containsAll(sourceTopicsSet)) {\n+                return new TaskId(topicGroup.getKey(), partition.intValue());\n+            }\n+        }\n+        throw new InvalidStateStoreException(\"Cannot get state store \" + storeName + \" because the requested partition \" + partition + \"is\" +\n+                                                \"not available on this instance\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4NzMzMA==", "bodyText": "\\cc @vitojeng -- seems this is a new case we should cover in KIP-216?", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372687330", "createdAt": "2020-01-29T23:27:48Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/StreamThreadStateStoreProvider.java", "diffHunk": "@@ -72,8 +82,23 @@ public StreamThreadStateStoreProvider(final StreamThread streamThread) {\n         } else {\n             throw new InvalidStateStoreException(\"Cannot get state store \" + storeName + \" because the stream thread is \" +\n                                                      state + \", not RUNNING\" +\n-                                                     (includeStaleStores ? \" or REBALANCING\" : \"\"));\n+                                                     (storeQueryParams.staleStoresEnabled() ? \" or REBALANCING\" : \"\"));\n         }\n     }\n \n+    private TaskId createKeyTaskId(final String storeName, final Integer partition) {\n+        if (partition == null) {\n+            return null;\n+        }\n+        final List<String> sourceTopics = internalTopologyBuilder.stateStoreNameToSourceTopics().get(storeName);\n+        final Set<String> sourceTopicsSet = sourceTopics.stream().collect(Collectors.toSet());\n+        final Map<Integer, InternalTopologyBuilder.TopicsInfo> topicGroups = internalTopologyBuilder.topicGroups();\n+        for (final Map.Entry<Integer, InternalTopologyBuilder.TopicsInfo> topicGroup : topicGroups.entrySet()) {\n+            if (topicGroup.getValue().sourceTopics.containsAll(sourceTopicsSet)) {\n+                return new TaskId(topicGroup.getKey(), partition.intValue());\n+            }\n+        }\n+        throw new InvalidStateStoreException(\"Cannot get state store \" + storeName + \" because the requested partition \" + partition + \"is\" +\n+                                                \"not available on this instance\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4NzE0OA=="}, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4ODEyNg==", "bodyText": "Why do we have this check inside the loop? Should we not check this condition once, and only execute the loop if the condition is false?\nOr maybe pass a Collections.singleton(keyTaskId) into the loop if keyTaskId != null ?", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372688126", "createdAt": "2020-01-29T23:30:18Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/StreamThreadStateStoreProvider.java", "diffHunk": "@@ -30,27 +32,35 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n public class StreamThreadStateStoreProvider {\n \n     private final StreamThread streamThread;\n+    private final InternalTopologyBuilder internalTopologyBuilder;\n \n-    public StreamThreadStateStoreProvider(final StreamThread streamThread) {\n+    public StreamThreadStateStoreProvider(final StreamThread streamThread, final InternalTopologyBuilder internalTopologyBuilder) {\n         this.streamThread = streamThread;\n+        this.internalTopologyBuilder = internalTopologyBuilder;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    public <T> List<T> stores(final String storeName,\n-                              final QueryableStoreType<T> queryableStoreType,\n-                              final boolean includeStaleStores) {\n+    public <T> List<T> stores(final StoreQueryParams storeQueryParams) {\n+        final String storeName = storeQueryParams.getStoreName();\n+        final QueryableStoreType<T> queryableStoreType = storeQueryParams.getQueryableStoreType();\n+        final TaskId keyTaskId = createKeyTaskId(storeName, storeQueryParams.partition());\n         if (streamThread.state() == StreamThread.State.DEAD) {\n             return Collections.emptyList();\n         }\n         final StreamThread.State state = streamThread.state();\n-        if (includeStaleStores ? state.isAlive() : state == StreamThread.State.RUNNING) {\n-            final Map<TaskId, ? extends Task> tasks = includeStaleStores ? streamThread.allTasks() : streamThread.activeTasks();\n+        if (storeQueryParams.staleStoresEnabled() ? state.isAlive() : state == StreamThread.State.RUNNING) {\n+            final Map<TaskId, ? extends Task> tasks = storeQueryParams.staleStoresEnabled() ? streamThread.allTasks() : streamThread.activeTasks();\n             final List<T> stores = new ArrayList<>();\n             for (final Task streamTask : tasks.values()) {\n+                if (keyTaskId != null && !keyTaskId.equals(streamTask.id())) {\n+                    continue;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4ODYzMg==", "bodyText": "Why is this a new test class? Why not add those tests to existing QueryableStateIntegrationTest ?", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372688632", "createdAt": "2020-01-29T23:32:10Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/StoreQueryIntegrationTest.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.integration;\n+\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyQueryMetadata;\n+import org.apache.kafka.streams.StoreQueryParams;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.errors.InvalidStateStoreException;\n+import org.apache.kafka.streams.integration.utils.EmbeddedKafkaCluster;\n+import org.apache.kafka.streams.integration.utils.IntegrationTestUtils;\n+import org.apache.kafka.streams.kstream.Consumed;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.processor.StateRestoreListener;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.apache.kafka.test.IntegrationTest;\n+import org.apache.kafka.test.TestUtils;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.apache.kafka.streams.integration.utils.IntegrationTestUtils.startApplicationAndWaitUntilRunning;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+\n+@Category({IntegrationTest.class})\n+public class StoreQueryIntegrationTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4OTMzOA==", "bodyText": "Why do we need this setter? Why can't we pass in StoreQueryParams in the constructor in the tests?", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372689338", "createdAt": "2020-01-29T23:34:38Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/WrappingStoreProvider.java", "diffHunk": "@@ -28,20 +29,25 @@\n public class WrappingStoreProvider implements StateStoreProvider {\n \n     private final List<StreamThreadStateStoreProvider> storeProviders;\n-    private final boolean includeStaleStores;\n+    private StoreQueryParams storeQueryParams;\n \n     WrappingStoreProvider(final List<StreamThreadStateStoreProvider> storeProviders,\n-                          final boolean includeStaleStores) {\n+                          final StoreQueryParams storeQueryParams) {\n         this.storeProviders = storeProviders;\n-        this.includeStaleStores = includeStaleStores;\n+        this.storeQueryParams = storeQueryParams;\n+    }\n+\n+    //visible for testing\n+    public void setStoreQueryParams(final StoreQueryParams storeQueryParams) {\n+        this.storeQueryParams = storeQueryParams;\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4OTcyNQ==", "bodyText": "nit: Why a line break? Rather unusual formatting", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372689725", "createdAt": "2020-01-29T23:35:57Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/StoreQueryIntegrationTest.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.integration;\n+\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyQueryMetadata;\n+import org.apache.kafka.streams.StoreQueryParams;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.errors.InvalidStateStoreException;\n+import org.apache.kafka.streams.integration.utils.EmbeddedKafkaCluster;\n+import org.apache.kafka.streams.integration.utils.IntegrationTestUtils;\n+import org.apache.kafka.streams.kstream.Consumed;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.processor.StateRestoreListener;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.apache.kafka.test.IntegrationTest;\n+import org.apache.kafka.test.TestUtils;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.apache.kafka.streams.integration.utils.IntegrationTestUtils.startApplicationAndWaitUntilRunning;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+\n+@Category({IntegrationTest.class})\n+public class StoreQueryIntegrationTest {\n+\n+    private static final int NUM_BROKERS = 1;\n+    private static int port = 0;\n+    private static final String INPUT_TOPIC_NAME = \"input-topic\";\n+    private static final String TABLE_NAME = \"source-table\";\n+\n+    @Rule\n+    public final EmbeddedKafkaCluster cluster = new EmbeddedKafkaCluster(NUM_BROKERS);\n+\n+    private final List<KafkaStreams> streamsToCleanup = new ArrayList<>();\n+    private final MockTime mockTime = cluster.time;\n+\n+    @Before\n+    public void before() throws InterruptedException {\n+        cluster.createTopic(INPUT_TOPIC_NAME, 2, 1);\n+    }\n+\n+    @After\n+    public void after() {\n+        for (final KafkaStreams kafkaStreams : streamsToCleanup) {\n+            kafkaStreams.close();\n+        }\n+    }\n+\n+    @Test\n+    public void shouldQueryAllActivePartitionStoresByDefault() throws Exception {\n+        final int batch1NumMessages = 100;\n+        final int key = 1;\n+        final Semaphore semaphore = new Semaphore(0);\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        builder\n+                .table(INPUT_TOPIC_NAME, Consumed.with(Serdes.Integer(), Serdes.Integer()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5MjczOA==", "bodyText": "I am not sure if I understand this test? If there are two instances, and a topic with 2 partitions, each instance is hosting one task. Hence, how does this test verify that all partitions are considered for querying?\n\nthere is only one partition\neven if there would be two partitions, how could this test verify if only one partition was queried or both?\n\nMaybe enabling stale querying helps to verify?\nSimilar question about the below test. Or do I miss something?", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372692738", "createdAt": "2020-01-29T23:46:36Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/StoreQueryIntegrationTest.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.integration;\n+\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyQueryMetadata;\n+import org.apache.kafka.streams.StoreQueryParams;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.errors.InvalidStateStoreException;\n+import org.apache.kafka.streams.integration.utils.EmbeddedKafkaCluster;\n+import org.apache.kafka.streams.integration.utils.IntegrationTestUtils;\n+import org.apache.kafka.streams.kstream.Consumed;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.processor.StateRestoreListener;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.apache.kafka.test.IntegrationTest;\n+import org.apache.kafka.test.TestUtils;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.apache.kafka.streams.integration.utils.IntegrationTestUtils.startApplicationAndWaitUntilRunning;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+\n+@Category({IntegrationTest.class})\n+public class StoreQueryIntegrationTest {\n+\n+    private static final int NUM_BROKERS = 1;\n+    private static int port = 0;\n+    private static final String INPUT_TOPIC_NAME = \"input-topic\";\n+    private static final String TABLE_NAME = \"source-table\";\n+\n+    @Rule\n+    public final EmbeddedKafkaCluster cluster = new EmbeddedKafkaCluster(NUM_BROKERS);\n+\n+    private final List<KafkaStreams> streamsToCleanup = new ArrayList<>();\n+    private final MockTime mockTime = cluster.time;\n+\n+    @Before\n+    public void before() throws InterruptedException {\n+        cluster.createTopic(INPUT_TOPIC_NAME, 2, 1);\n+    }\n+\n+    @After\n+    public void after() {\n+        for (final KafkaStreams kafkaStreams : streamsToCleanup) {\n+            kafkaStreams.close();\n+        }\n+    }\n+\n+    @Test\n+    public void shouldQueryAllActivePartitionStoresByDefault() throws Exception {\n+        final int batch1NumMessages = 100;\n+        final int key = 1;\n+        final Semaphore semaphore = new Semaphore(0);\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        builder\n+                .table(INPUT_TOPIC_NAME, Consumed.with(Serdes.Integer(), Serdes.Integer()),\n+                        Materialized.<Integer, Integer, KeyValueStore<Bytes, byte[]>>as(TABLE_NAME)\n+                                .withCachingDisabled())\n+                .toStream()\n+                .peek((k, v) -> semaphore.release());\n+\n+        final KafkaStreams kafkaStreams1 = createKafkaStreams(builder, streamsConfiguration());\n+        final KafkaStreams kafkaStreams2 = createKafkaStreams(builder, streamsConfiguration());\n+        final List<KafkaStreams> kafkaStreamsList = Arrays.asList(kafkaStreams1, kafkaStreams2);\n+\n+        startApplicationAndWaitUntilRunning(kafkaStreamsList, Duration.ofSeconds(60));\n+\n+        produceValueRange(key, 0, batch1NumMessages);\n+\n+        // Assert that all messages in the first batch were processed in a timely manner\n+        assertThat(semaphore.tryAcquire(batch1NumMessages, 60, TimeUnit.SECONDS), is(equalTo(true)));\n+        final KeyQueryMetadata keyQueryMetadata = kafkaStreams1.queryMetadataForKey(TABLE_NAME, key, (topic, somekey, value, numPartitions) -> 0);\n+\n+        final QueryableStoreType<ReadOnlyKeyValueStore<Integer, Integer>> queryableStoreType = QueryableStoreTypes.keyValueStore();\n+        final ReadOnlyKeyValueStore<Integer, Integer> store1 = kafkaStreams1\n+                .store(StoreQueryParams.fromNameAndType(TABLE_NAME, queryableStoreType));\n+\n+        final ReadOnlyKeyValueStore<Integer, Integer> store2 = kafkaStreams2\n+                .store(StoreQueryParams.fromNameAndType(TABLE_NAME, queryableStoreType));\n+\n+        final boolean kafkaStreams1IsActive;\n+        if ((keyQueryMetadata.getActiveHost().port() % 2) == 1) {\n+            kafkaStreams1IsActive = true;\n+        } else {\n+            kafkaStreams1IsActive = false;\n+        }\n+\n+        // Assert that only active is able to query for a key by default\n+        assertThat(kafkaStreams1IsActive ? store1.get(key) : store2.get(key), is(notNullValue()));\n+        assertThat(kafkaStreams1IsActive ? store2.get(key) : store1.get(key), is(nullValue()));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5MzEzMA==", "bodyText": "Why do we catch? We should be able to figure this out before we call store() base on the given KeyQueryMetadata.", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372693130", "createdAt": "2020-01-29T23:48:00Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/StoreQueryIntegrationTest.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.integration;\n+\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyQueryMetadata;\n+import org.apache.kafka.streams.StoreQueryParams;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.errors.InvalidStateStoreException;\n+import org.apache.kafka.streams.integration.utils.EmbeddedKafkaCluster;\n+import org.apache.kafka.streams.integration.utils.IntegrationTestUtils;\n+import org.apache.kafka.streams.kstream.Consumed;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.processor.StateRestoreListener;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.apache.kafka.test.IntegrationTest;\n+import org.apache.kafka.test.TestUtils;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.apache.kafka.streams.integration.utils.IntegrationTestUtils.startApplicationAndWaitUntilRunning;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+\n+@Category({IntegrationTest.class})\n+public class StoreQueryIntegrationTest {\n+\n+    private static final int NUM_BROKERS = 1;\n+    private static int port = 0;\n+    private static final String INPUT_TOPIC_NAME = \"input-topic\";\n+    private static final String TABLE_NAME = \"source-table\";\n+\n+    @Rule\n+    public final EmbeddedKafkaCluster cluster = new EmbeddedKafkaCluster(NUM_BROKERS);\n+\n+    private final List<KafkaStreams> streamsToCleanup = new ArrayList<>();\n+    private final MockTime mockTime = cluster.time;\n+\n+    @Before\n+    public void before() throws InterruptedException {\n+        cluster.createTopic(INPUT_TOPIC_NAME, 2, 1);\n+    }\n+\n+    @After\n+    public void after() {\n+        for (final KafkaStreams kafkaStreams : streamsToCleanup) {\n+            kafkaStreams.close();\n+        }\n+    }\n+\n+    @Test\n+    public void shouldQueryAllActivePartitionStoresByDefault() throws Exception {\n+        final int batch1NumMessages = 100;\n+        final int key = 1;\n+        final Semaphore semaphore = new Semaphore(0);\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        builder\n+                .table(INPUT_TOPIC_NAME, Consumed.with(Serdes.Integer(), Serdes.Integer()),\n+                        Materialized.<Integer, Integer, KeyValueStore<Bytes, byte[]>>as(TABLE_NAME)\n+                                .withCachingDisabled())\n+                .toStream()\n+                .peek((k, v) -> semaphore.release());\n+\n+        final KafkaStreams kafkaStreams1 = createKafkaStreams(builder, streamsConfiguration());\n+        final KafkaStreams kafkaStreams2 = createKafkaStreams(builder, streamsConfiguration());\n+        final List<KafkaStreams> kafkaStreamsList = Arrays.asList(kafkaStreams1, kafkaStreams2);\n+\n+        startApplicationAndWaitUntilRunning(kafkaStreamsList, Duration.ofSeconds(60));\n+\n+        produceValueRange(key, 0, batch1NumMessages);\n+\n+        // Assert that all messages in the first batch were processed in a timely manner\n+        assertThat(semaphore.tryAcquire(batch1NumMessages, 60, TimeUnit.SECONDS), is(equalTo(true)));\n+        final KeyQueryMetadata keyQueryMetadata = kafkaStreams1.queryMetadataForKey(TABLE_NAME, key, (topic, somekey, value, numPartitions) -> 0);\n+\n+        final QueryableStoreType<ReadOnlyKeyValueStore<Integer, Integer>> queryableStoreType = QueryableStoreTypes.keyValueStore();\n+        final ReadOnlyKeyValueStore<Integer, Integer> store1 = kafkaStreams1\n+                .store(StoreQueryParams.fromNameAndType(TABLE_NAME, queryableStoreType));\n+\n+        final ReadOnlyKeyValueStore<Integer, Integer> store2 = kafkaStreams2\n+                .store(StoreQueryParams.fromNameAndType(TABLE_NAME, queryableStoreType));\n+\n+        final boolean kafkaStreams1IsActive;\n+        if ((keyQueryMetadata.getActiveHost().port() % 2) == 1) {\n+            kafkaStreams1IsActive = true;\n+        } else {\n+            kafkaStreams1IsActive = false;\n+        }\n+\n+        // Assert that only active is able to query for a key by default\n+        assertThat(kafkaStreams1IsActive ? store1.get(key) : store2.get(key), is(notNullValue()));\n+        assertThat(kafkaStreams1IsActive ? store2.get(key) : store1.get(key), is(nullValue()));\n+    }\n+\n+    @Test\n+    public void shouldQuerySpecificActivePartitionStores() throws Exception {\n+        final int batch1NumMessages = 100;\n+        final int key = 1;\n+        final Semaphore semaphore = new Semaphore(0);\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        builder\n+                .table(INPUT_TOPIC_NAME, Consumed.with(Serdes.Integer(), Serdes.Integer()),\n+                        Materialized.<Integer, Integer, KeyValueStore<Bytes, byte[]>>as(TABLE_NAME)\n+                                .withCachingDisabled())\n+                .toStream()\n+                .peek((k, v) -> semaphore.release());\n+\n+        final KafkaStreams kafkaStreams1 = createKafkaStreams(builder, streamsConfiguration());\n+        final KafkaStreams kafkaStreams2 = createKafkaStreams(builder, streamsConfiguration());\n+        final List<KafkaStreams> kafkaStreamsList = Arrays.asList(kafkaStreams1, kafkaStreams2);\n+\n+        startApplicationAndWaitUntilRunning(kafkaStreamsList, Duration.ofSeconds(60));\n+\n+        produceValueRange(key, 0, batch1NumMessages);\n+\n+        // Assert that all messages in the first batch were processed in a timely manner\n+        assertThat(semaphore.tryAcquire(batch1NumMessages, 60, TimeUnit.SECONDS), is(equalTo(true)));\n+        final KeyQueryMetadata keyQueryMetadata = kafkaStreams1.queryMetadataForKey(TABLE_NAME, key, (topic, somekey, value, numPartitions) -> 0);\n+\n+        //key belongs to this partition\n+        final int keyPartition = keyQueryMetadata.getPartition();\n+\n+        //key doesn't belongs to this partition\n+        final int keyDontBelongPartition = (keyPartition == 0) ? 1 : 0;\n+        final QueryableStoreType<ReadOnlyKeyValueStore<Integer, Integer>> queryableStoreType = QueryableStoreTypes.keyValueStore();\n+        ReadOnlyKeyValueStore<Integer, Integer> store1 = null;\n+        ReadOnlyKeyValueStore<Integer, Integer> store2 = null;\n+        try {\n+            store1 = kafkaStreams1\n+                    .store(StoreQueryParams.fromNameAndType(TABLE_NAME, queryableStoreType).withPartition(keyPartition));\n+        } catch (final InvalidStateStoreException exception) {\n+        //Only one among kafkaStreams1 and kafkaStreams2 will contain the specific active store requested. The other will throw exception\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5NTI4Mg==", "bodyText": "Seem this test is subject to a race condition, because we don't know if the standby is up-to-date already (the used semaphore only tells us that the active one is up-to-date) and contains the key. I think we need to retry this in a loop with timeout?", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372695282", "createdAt": "2020-01-29T23:55:07Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/StoreQueryIntegrationTest.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.integration;\n+\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyQueryMetadata;\n+import org.apache.kafka.streams.StoreQueryParams;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.errors.InvalidStateStoreException;\n+import org.apache.kafka.streams.integration.utils.EmbeddedKafkaCluster;\n+import org.apache.kafka.streams.integration.utils.IntegrationTestUtils;\n+import org.apache.kafka.streams.kstream.Consumed;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.processor.StateRestoreListener;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.apache.kafka.test.IntegrationTest;\n+import org.apache.kafka.test.TestUtils;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.apache.kafka.streams.integration.utils.IntegrationTestUtils.startApplicationAndWaitUntilRunning;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+\n+@Category({IntegrationTest.class})\n+public class StoreQueryIntegrationTest {\n+\n+    private static final int NUM_BROKERS = 1;\n+    private static int port = 0;\n+    private static final String INPUT_TOPIC_NAME = \"input-topic\";\n+    private static final String TABLE_NAME = \"source-table\";\n+\n+    @Rule\n+    public final EmbeddedKafkaCluster cluster = new EmbeddedKafkaCluster(NUM_BROKERS);\n+\n+    private final List<KafkaStreams> streamsToCleanup = new ArrayList<>();\n+    private final MockTime mockTime = cluster.time;\n+\n+    @Before\n+    public void before() throws InterruptedException {\n+        cluster.createTopic(INPUT_TOPIC_NAME, 2, 1);\n+    }\n+\n+    @After\n+    public void after() {\n+        for (final KafkaStreams kafkaStreams : streamsToCleanup) {\n+            kafkaStreams.close();\n+        }\n+    }\n+\n+    @Test\n+    public void shouldQueryAllActivePartitionStoresByDefault() throws Exception {\n+        final int batch1NumMessages = 100;\n+        final int key = 1;\n+        final Semaphore semaphore = new Semaphore(0);\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        builder\n+                .table(INPUT_TOPIC_NAME, Consumed.with(Serdes.Integer(), Serdes.Integer()),\n+                        Materialized.<Integer, Integer, KeyValueStore<Bytes, byte[]>>as(TABLE_NAME)\n+                                .withCachingDisabled())\n+                .toStream()\n+                .peek((k, v) -> semaphore.release());\n+\n+        final KafkaStreams kafkaStreams1 = createKafkaStreams(builder, streamsConfiguration());\n+        final KafkaStreams kafkaStreams2 = createKafkaStreams(builder, streamsConfiguration());\n+        final List<KafkaStreams> kafkaStreamsList = Arrays.asList(kafkaStreams1, kafkaStreams2);\n+\n+        startApplicationAndWaitUntilRunning(kafkaStreamsList, Duration.ofSeconds(60));\n+\n+        produceValueRange(key, 0, batch1NumMessages);\n+\n+        // Assert that all messages in the first batch were processed in a timely manner\n+        assertThat(semaphore.tryAcquire(batch1NumMessages, 60, TimeUnit.SECONDS), is(equalTo(true)));\n+        final KeyQueryMetadata keyQueryMetadata = kafkaStreams1.queryMetadataForKey(TABLE_NAME, key, (topic, somekey, value, numPartitions) -> 0);\n+\n+        final QueryableStoreType<ReadOnlyKeyValueStore<Integer, Integer>> queryableStoreType = QueryableStoreTypes.keyValueStore();\n+        final ReadOnlyKeyValueStore<Integer, Integer> store1 = kafkaStreams1\n+                .store(StoreQueryParams.fromNameAndType(TABLE_NAME, queryableStoreType));\n+\n+        final ReadOnlyKeyValueStore<Integer, Integer> store2 = kafkaStreams2\n+                .store(StoreQueryParams.fromNameAndType(TABLE_NAME, queryableStoreType));\n+\n+        final boolean kafkaStreams1IsActive;\n+        if ((keyQueryMetadata.getActiveHost().port() % 2) == 1) {\n+            kafkaStreams1IsActive = true;\n+        } else {\n+            kafkaStreams1IsActive = false;\n+        }\n+\n+        // Assert that only active is able to query for a key by default\n+        assertThat(kafkaStreams1IsActive ? store1.get(key) : store2.get(key), is(notNullValue()));\n+        assertThat(kafkaStreams1IsActive ? store2.get(key) : store1.get(key), is(nullValue()));\n+    }\n+\n+    @Test\n+    public void shouldQuerySpecificActivePartitionStores() throws Exception {\n+        final int batch1NumMessages = 100;\n+        final int key = 1;\n+        final Semaphore semaphore = new Semaphore(0);\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        builder\n+                .table(INPUT_TOPIC_NAME, Consumed.with(Serdes.Integer(), Serdes.Integer()),\n+                        Materialized.<Integer, Integer, KeyValueStore<Bytes, byte[]>>as(TABLE_NAME)\n+                                .withCachingDisabled())\n+                .toStream()\n+                .peek((k, v) -> semaphore.release());\n+\n+        final KafkaStreams kafkaStreams1 = createKafkaStreams(builder, streamsConfiguration());\n+        final KafkaStreams kafkaStreams2 = createKafkaStreams(builder, streamsConfiguration());\n+        final List<KafkaStreams> kafkaStreamsList = Arrays.asList(kafkaStreams1, kafkaStreams2);\n+\n+        startApplicationAndWaitUntilRunning(kafkaStreamsList, Duration.ofSeconds(60));\n+\n+        produceValueRange(key, 0, batch1NumMessages);\n+\n+        // Assert that all messages in the first batch were processed in a timely manner\n+        assertThat(semaphore.tryAcquire(batch1NumMessages, 60, TimeUnit.SECONDS), is(equalTo(true)));\n+        final KeyQueryMetadata keyQueryMetadata = kafkaStreams1.queryMetadataForKey(TABLE_NAME, key, (topic, somekey, value, numPartitions) -> 0);\n+\n+        //key belongs to this partition\n+        final int keyPartition = keyQueryMetadata.getPartition();\n+\n+        //key doesn't belongs to this partition\n+        final int keyDontBelongPartition = (keyPartition == 0) ? 1 : 0;\n+        final QueryableStoreType<ReadOnlyKeyValueStore<Integer, Integer>> queryableStoreType = QueryableStoreTypes.keyValueStore();\n+        ReadOnlyKeyValueStore<Integer, Integer> store1 = null;\n+        ReadOnlyKeyValueStore<Integer, Integer> store2 = null;\n+        try {\n+            store1 = kafkaStreams1\n+                    .store(StoreQueryParams.fromNameAndType(TABLE_NAME, queryableStoreType).withPartition(keyPartition));\n+        } catch (final InvalidStateStoreException exception) {\n+        //Only one among kafkaStreams1 and kafkaStreams2 will contain the specific active store requested. The other will throw exception\n+        }\n+        try {\n+            store2 = kafkaStreams2\n+                    .store(StoreQueryParams.fromNameAndType(TABLE_NAME, queryableStoreType).withPartition(keyPartition));\n+        } catch (final InvalidStateStoreException exception) {\n+            //Only one among kafkaStreams1 and kafkaStreams2 will contain the specific active store requested. The other will throw exception\n+        }\n+        final boolean kafkaStreams1IsActive;\n+        if ((keyQueryMetadata.getActiveHost().port() % 2) == 1) {\n+            kafkaStreams1IsActive = true;\n+            assertThat(store1, is(notNullValue()));\n+            assertThat(store2, is(nullValue()));\n+        } else {\n+            kafkaStreams1IsActive = false;\n+            assertThat(store2, is(notNullValue()));\n+            assertThat(store1, is(nullValue()));\n+        }\n+\n+        // Assert that only active for a specific requested partition serves key if stale stores and not enabled\n+        assertThat(kafkaStreams1IsActive ? store1.get(key) : store2.get(key), is(notNullValue()));\n+\n+        ReadOnlyKeyValueStore<Integer, Integer> store3 = null;\n+        ReadOnlyKeyValueStore<Integer, Integer> store4 = null;\n+        try {\n+            store3 = kafkaStreams1\n+                    .store(StoreQueryParams.fromNameAndType(TABLE_NAME, queryableStoreType).withPartition(keyDontBelongPartition));\n+        } catch (final InvalidStateStoreException exception) {\n+            //Only one among kafkaStreams1 and kafkaStreams2 will contain the specific active store requested. The other will throw exception\n+        }\n+        try {\n+            store4 = kafkaStreams2\n+                    .store(StoreQueryParams.fromNameAndType(TABLE_NAME, queryableStoreType).withPartition(keyDontBelongPartition));\n+        } catch (final InvalidStateStoreException exception) {\n+            //Only one among kafkaStreams1 and kafkaStreams2 will contain the specific active store requested. The other will throw exception\n+        }\n+\n+        // Assert that key is not served when wrong specific partition is requested\n+        // If kafkaStreams1 is active for keyPartition, kafkaStreams2 would be active for keyDontBelongPartition\n+        // So, in that case, store3 would be null and the store4 would not return the value for key as wrong partition was requested\n+        assertThat(kafkaStreams1IsActive ? store4.get(key) : store3.get(key), is(nullValue()));\n+    }\n+\n+    @Test\n+    public void shouldQueryAllStalePartitionStores() throws Exception {\n+        final int batch1NumMessages = 100;\n+        final int key = 1;\n+        final Semaphore semaphore = new Semaphore(0);\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        builder\n+                .table(INPUT_TOPIC_NAME, Consumed.with(Serdes.Integer(), Serdes.Integer()),\n+                        Materialized.<Integer, Integer, KeyValueStore<Bytes, byte[]>>as(TABLE_NAME)\n+                                .withCachingDisabled())\n+                .toStream()\n+                .peek((k, v) -> semaphore.release());\n+\n+        final KafkaStreams kafkaStreams1 = createKafkaStreams(builder, streamsConfiguration());\n+        final KafkaStreams kafkaStreams2 = createKafkaStreams(builder, streamsConfiguration());\n+        final List<KafkaStreams> kafkaStreamsList = Arrays.asList(kafkaStreams1, kafkaStreams2);\n+\n+        startApplicationAndWaitUntilRunning(kafkaStreamsList, Duration.ofSeconds(60));\n+\n+        produceValueRange(key, 0, batch1NumMessages);\n+\n+        // Assert that all messages in the first batch were processed in a timely manner\n+        assertThat(semaphore.tryAcquire(batch1NumMessages, 60, TimeUnit.SECONDS), is(equalTo(true)));\n+\n+        final QueryableStoreType<ReadOnlyKeyValueStore<Integer, Integer>> queryableStoreType = QueryableStoreTypes.keyValueStore();\n+        final ReadOnlyKeyValueStore<Integer, Integer> store1 = kafkaStreams1\n+                .store(StoreQueryParams.fromNameAndType(TABLE_NAME, queryableStoreType).enableStaleStores());\n+\n+        final ReadOnlyKeyValueStore<Integer, Integer> store2 = kafkaStreams2\n+                .store(StoreQueryParams.fromNameAndType(TABLE_NAME, queryableStoreType).enableStaleStores());\n+\n+        // Assert that both active and standby are able to query for a key\n+        assertThat(store1.get(key), is(notNullValue()));\n+        assertThat(store2.get(key), is(notNullValue()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 256}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e219cbc0308a0a76ddd4f72755908030fe8d3ee4", "author": {"user": {"login": "brary", "name": "Navinder Pal Singh Brar"}}, "url": "https://github.com/apache/kafka/commit/e219cbc0308a0a76ddd4f72755908030fe8d3ee4", "committedDate": "2020-01-30T05:29:38Z", "message": "Addressing code review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87c5b9c6789e6f77819eecee0400c64d4220356f", "author": {"user": {"login": "brary", "name": "Navinder Pal Singh Brar"}}, "url": "https://github.com/apache/kafka/commit/87c5b9c6789e6f77819eecee0400c64d4220356f", "committedDate": "2020-01-30T05:36:45Z", "message": "Addressing code review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNjE2Nzg5", "url": "https://github.com/apache/kafka/pull/7984#pullrequestreview-350616789", "createdAt": "2020-01-30T07:12:36Z", "commit": {"oid": "87c5b9c6789e6f77819eecee0400c64d4220356f"}, "state": "APPROVED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwNzoxMjozNlrOFjhMBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQwNzo0MTozMVrOFjhs-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc4ODIzMA==", "bodyText": "Nit: I would remove this sentence. Should be part of the JavaDocs of StoreQueryParams.", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372788230", "createdAt": "2020-01-30T07:12:36Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -1160,47 +1160,29 @@ public void cleanUp() {\n         return streamsMetadataState.getKeyQueryMetadataForKey(storeName, key, partitioner);\n     }\n \n+\n     /**\n-     * Get a facade wrapping the local {@link StateStore} instances with the provided {@code storeName} if the Store's\n-     * type is accepted by the provided {@link QueryableStoreType#accepts(StateStore) queryableStoreType}.\n-     * The returned object can be used to query the {@link StateStore} instances.\n-     *\n-     * Only permits queries on active replicas of the store (no standbys or restoring replicas).\n-     * See {@link KafkaStreams#store(java.lang.String, org.apache.kafka.streams.state.QueryableStoreType, boolean)}\n-     * for the option to set {@code includeStaleStores} to true and trade off consistency in favor of availability.\n-     *\n-     * @param storeName           name of the store to find\n-     * @param queryableStoreType  accept only stores that are accepted by {@link QueryableStoreType#accepts(StateStore)}\n-     * @param <T>                 return type\n-     * @return A facade wrapping the local {@link StateStore} instances\n-     * @throws InvalidStateStoreException if Kafka Streams is (re-)initializing or a store with {@code storeName} and\n-     * {@code queryableStoreType} doesn't exist\n+     * @deprecated since 2.5 release; use {@link #store(StoreQueryParams)}  instead\n      */\n+    @Deprecated\n     public <T> T store(final String storeName, final QueryableStoreType<T> queryableStoreType) {\n-        return store(storeName, queryableStoreType, false);\n+        return store(StoreQueryParams.fromNameAndType(storeName, queryableStoreType));\n     }\n \n     /**\n-     * Get a facade wrapping the local {@link StateStore} instances with the provided {@code storeName} if the Store's\n+     * Get a facade wrapping the local {@link StateStore} instances with the provided {@link StoreQueryParams}.\n+     * StoreQueryParams need required parameters to be set, which are {@code storeName} and if\n      * type is accepted by the provided {@link QueryableStoreType#accepts(StateStore) queryableStoreType}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87c5b9c6789e6f77819eecee0400c64d4220356f"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc4OTM5OQ==", "bodyText": "nit: remove optional the object is used to set mandatory and optional parameters. Overall it reads a little bit complicated. Not sure atm how to improve it. Maybe @vinothchandar or @vvcephei have some ideas?", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372789399", "createdAt": "2020-01-30T07:16:52Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -1160,47 +1160,29 @@ public void cleanUp() {\n         return streamsMetadataState.getKeyQueryMetadataForKey(storeName, key, partitioner);\n     }\n \n+\n     /**\n-     * Get a facade wrapping the local {@link StateStore} instances with the provided {@code storeName} if the Store's\n-     * type is accepted by the provided {@link QueryableStoreType#accepts(StateStore) queryableStoreType}.\n-     * The returned object can be used to query the {@link StateStore} instances.\n-     *\n-     * Only permits queries on active replicas of the store (no standbys or restoring replicas).\n-     * See {@link KafkaStreams#store(java.lang.String, org.apache.kafka.streams.state.QueryableStoreType, boolean)}\n-     * for the option to set {@code includeStaleStores} to true and trade off consistency in favor of availability.\n-     *\n-     * @param storeName           name of the store to find\n-     * @param queryableStoreType  accept only stores that are accepted by {@link QueryableStoreType#accepts(StateStore)}\n-     * @param <T>                 return type\n-     * @return A facade wrapping the local {@link StateStore} instances\n-     * @throws InvalidStateStoreException if Kafka Streams is (re-)initializing or a store with {@code storeName} and\n-     * {@code queryableStoreType} doesn't exist\n+     * @deprecated since 2.5 release; use {@link #store(StoreQueryParams)}  instead\n      */\n+    @Deprecated\n     public <T> T store(final String storeName, final QueryableStoreType<T> queryableStoreType) {\n-        return store(storeName, queryableStoreType, false);\n+        return store(StoreQueryParams.fromNameAndType(storeName, queryableStoreType));\n     }\n \n     /**\n-     * Get a facade wrapping the local {@link StateStore} instances with the provided {@code storeName} if the Store's\n+     * Get a facade wrapping the local {@link StateStore} instances with the provided {@link StoreQueryParams}.\n+     * StoreQueryParams need required parameters to be set, which are {@code storeName} and if\n      * type is accepted by the provided {@link QueryableStoreType#accepts(StateStore) queryableStoreType}.\n      * The returned object can be used to query the {@link StateStore} instances.\n      *\n-     * @param storeName           name of the store to find\n-     * @param queryableStoreType  accept only stores that are accepted by {@link QueryableStoreType#accepts(StateStore)}\n-     * @param includeStaleStores      If false, only permit queries on the active replica for a partition, and only if the\n-     *                            task for that partition is running. I.e., the state store is not a standby replica,\n-     *                            and it is not restoring from the changelog.\n-     *                            If true, allow queries on standbys and restoring replicas in addition to active ones.\n-     * @param <T>                 return type\n+     * @param storeQueryParams   to set the optional parameters to fetch type of stores user wants to fetch when a key is queried", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87c5b9c6789e6f77819eecee0400c64d4220356f"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc4OTc3OQ==", "bodyText": "As an after though, I am wondering why we not call this class StoreQueryParameters -- using an abbreviation does not really make a good name IMHO?", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372789779", "createdAt": "2020-01-30T07:18:26Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting.\n+ * The options would be whether a user would want to enable/disable stale stores\n+ * or whether it knows the list of partitions that it specifically wants to fetch.\n+ * If this information is not provided the default behavior is to fetch the stores for all the partitions\n+ * available on that instance for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the {@link KeyQueryMetadata}.\n+ */\n+public class StoreQueryParams<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87c5b9c6789e6f77819eecee0400c64d4220356f"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc4OTk3Mw==", "bodyText": "it is -> they are (we user is a person :))", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372789973", "createdAt": "2020-01-30T07:19:06Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87c5b9c6789e6f77819eecee0400c64d4220356f"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5MTM4MQ==", "bodyText": "it knows -> they know\nit specifically wants -> they specifically want\n\"list of partitions\" -- a user can only specify a single partition (this make we wonder: the optimization we do, only applies to single key lookups? For range queries, a user should never limit the number of partitions? -- if yes, we should explain this detailed in the JavaDocs of withPartition(...) -- one exception might be, if the underlying data is range-partitioned and the user would know that the range that is queried is solely contained in a single partition)", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372791381", "createdAt": "2020-01-30T07:23:51Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting.\n+ * The options would be whether a user would want to enable/disable stale stores\n+ * or whether it knows the list of partitions that it specifically wants to fetch.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87c5b9c6789e6f77819eecee0400c64d4220356f"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5MjAwNw==", "bodyText": "this information is ambiguous -- unclear from the context to what it really refers -- maybe better: If no specific partition is specified the default behavior...)", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372792007", "createdAt": "2020-01-30T07:25:53Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting.\n+ * The options would be whether a user would want to enable/disable stale stores\n+ * or whether it knows the list of partitions that it specifically wants to fetch.\n+ * If this information is not provided the default behavior is to fetch the stores for all the partitions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87c5b9c6789e6f77819eecee0400c64d4220356f"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5MjEzMw==", "bodyText": "Unclear what this sentence mean? Maybe we should just remove it completely?", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372792133", "createdAt": "2020-01-30T07:26:18Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting.\n+ * The options would be whether a user would want to enable/disable stale stores\n+ * or whether it knows the list of partitions that it specifically wants to fetch.\n+ * If this information is not provided the default behavior is to fetch the stores for all the partitions\n+ * available on that instance for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the {@link KeyQueryMetadata}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87c5b9c6789e6f77819eecee0400c64d4220356f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5MjMzMg==", "bodyText": "This method does not return a String.\nMaybe\n@return StoreQueryParams a new {@code StoreQueryParams} instance configured with the specified partition", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372792332", "createdAt": "2020-01-30T07:27:00Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting.\n+ * The options would be whether a user would want to enable/disable stale stores\n+ * or whether it knows the list of partitions that it specifically wants to fetch.\n+ * If this information is not provided the default behavior is to fetch the stores for all the partitions\n+ * available on that instance for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the {@link KeyQueryMetadata}.\n+ */\n+public class StoreQueryParams<T> {\n+\n+    private Integer partition;\n+    private boolean staleStores;\n+    private final String storeName;\n+    private final QueryableStoreType<T> queryableStoreType;\n+\n+    private StoreQueryParams(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        this.storeName = storeName;\n+        this.queryableStoreType = queryableStoreType;\n+    }\n+\n+    public static <T> StoreQueryParams<T> fromNameAndType(final String storeName,\n+                                                          final QueryableStoreType<T>  queryableStoreType) {\n+        return new StoreQueryParams<T>(storeName, queryableStoreType);\n+    }\n+\n+    /**\n+     * Set a specific partition that should be queried exclusively.\n+     *\n+     * @param partition   The specific integer partition to be fetched from the stores list by using {@link StoreQueryParams}.\n+     *\n+     * @return String storeName", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87c5b9c6789e6f77819eecee0400c64d4220356f"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5Mjc2Ng==", "bodyText": "It might be simpler to add a private constructor that allows to specify all 4 parameters:\nreturn new StoreQueryParams<>(storeName, queryableStoreType, partition, staleStores);\n\nSimilar in other methods", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372792766", "createdAt": "2020-01-30T07:28:40Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting.\n+ * The options would be whether a user would want to enable/disable stale stores\n+ * or whether it knows the list of partitions that it specifically wants to fetch.\n+ * If this information is not provided the default behavior is to fetch the stores for all the partitions\n+ * available on that instance for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the {@link KeyQueryMetadata}.\n+ */\n+public class StoreQueryParams<T> {\n+\n+    private Integer partition;\n+    private boolean staleStores;\n+    private final String storeName;\n+    private final QueryableStoreType<T> queryableStoreType;\n+\n+    private StoreQueryParams(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        this.storeName = storeName;\n+        this.queryableStoreType = queryableStoreType;\n+    }\n+\n+    public static <T> StoreQueryParams<T> fromNameAndType(final String storeName,\n+                                                          final QueryableStoreType<T>  queryableStoreType) {\n+        return new StoreQueryParams<T>(storeName, queryableStoreType);\n+    }\n+\n+    /**\n+     * Set a specific partition that should be queried exclusively.\n+     *\n+     * @param partition   The specific integer partition to be fetched from the stores list by using {@link StoreQueryParams}.\n+     *\n+     * @return String storeName\n+     */\n+    public StoreQueryParams<T> withPartition(final Integer partition) {\n+        final StoreQueryParams<T> storeQueryParams = StoreQueryParams.fromNameAndType(this.storeName(), this.queryableStoreType());\n+        storeQueryParams.partition = partition;\n+        storeQueryParams.staleStores = this.staleStores;\n+        return storeQueryParams;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87c5b9c6789e6f77819eecee0400c64d4220356f"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5MzI4NQ==", "bodyText": "Technically, a user could implement a custom store and thus we don't really know if a key is used...\n-> Get the name of the state store that should be queried. ?", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372793285", "createdAt": "2020-01-30T07:30:45Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting.\n+ * The options would be whether a user would want to enable/disable stale stores\n+ * or whether it knows the list of partitions that it specifically wants to fetch.\n+ * If this information is not provided the default behavior is to fetch the stores for all the partitions\n+ * available on that instance for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the {@link KeyQueryMetadata}.\n+ */\n+public class StoreQueryParams<T> {\n+\n+    private Integer partition;\n+    private boolean staleStores;\n+    private final String storeName;\n+    private final QueryableStoreType<T> queryableStoreType;\n+\n+    private StoreQueryParams(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        this.storeName = storeName;\n+        this.queryableStoreType = queryableStoreType;\n+    }\n+\n+    public static <T> StoreQueryParams<T> fromNameAndType(final String storeName,\n+                                                          final QueryableStoreType<T>  queryableStoreType) {\n+        return new StoreQueryParams<T>(storeName, queryableStoreType);\n+    }\n+\n+    /**\n+     * Set a specific partition that should be queried exclusively.\n+     *\n+     * @param partition   The specific integer partition to be fetched from the stores list by using {@link StoreQueryParams}.\n+     *\n+     * @return String storeName\n+     */\n+    public StoreQueryParams<T> withPartition(final Integer partition) {\n+        final StoreQueryParams<T> storeQueryParams = StoreQueryParams.fromNameAndType(this.storeName(), this.queryableStoreType());\n+        storeQueryParams.partition = partition;\n+        storeQueryParams.staleStores = this.staleStores;\n+        return storeQueryParams;\n+    }\n+\n+    /**\n+     * Enable querying of stale state stores, i.e., allow to query active tasks during restore as well as standby tasks.\n+     *\n+     * @return String storeName\n+     */\n+    public StoreQueryParams<T> enableStaleStores() {\n+        final StoreQueryParams<T> storeQueryParams = StoreQueryParams.fromNameAndType(this.storeName(), this.queryableStoreType());\n+        storeQueryParams.partition = this.partition;\n+        storeQueryParams.staleStores = true;\n+        return storeQueryParams;\n+    }\n+\n+    /**\n+     * Get the store name for which key is queried by the user.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87c5b9c6789e6f77819eecee0400c64d4220356f"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5MzU2Mw==", "bodyText": "storeName -> state store name (we should use natural language if possible, and avoid variable names)", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372793563", "createdAt": "2020-01-30T07:31:40Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting.\n+ * The options would be whether a user would want to enable/disable stale stores\n+ * or whether it knows the list of partitions that it specifically wants to fetch.\n+ * If this information is not provided the default behavior is to fetch the stores for all the partitions\n+ * available on that instance for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the {@link KeyQueryMetadata}.\n+ */\n+public class StoreQueryParams<T> {\n+\n+    private Integer partition;\n+    private boolean staleStores;\n+    private final String storeName;\n+    private final QueryableStoreType<T> queryableStoreType;\n+\n+    private StoreQueryParams(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        this.storeName = storeName;\n+        this.queryableStoreType = queryableStoreType;\n+    }\n+\n+    public static <T> StoreQueryParams<T> fromNameAndType(final String storeName,\n+                                                          final QueryableStoreType<T>  queryableStoreType) {\n+        return new StoreQueryParams<T>(storeName, queryableStoreType);\n+    }\n+\n+    /**\n+     * Set a specific partition that should be queried exclusively.\n+     *\n+     * @param partition   The specific integer partition to be fetched from the stores list by using {@link StoreQueryParams}.\n+     *\n+     * @return String storeName\n+     */\n+    public StoreQueryParams<T> withPartition(final Integer partition) {\n+        final StoreQueryParams<T> storeQueryParams = StoreQueryParams.fromNameAndType(this.storeName(), this.queryableStoreType());\n+        storeQueryParams.partition = partition;\n+        storeQueryParams.staleStores = this.staleStores;\n+        return storeQueryParams;\n+    }\n+\n+    /**\n+     * Enable querying of stale state stores, i.e., allow to query active tasks during restore as well as standby tasks.\n+     *\n+     * @return String storeName\n+     */\n+    public StoreQueryParams<T> enableStaleStores() {\n+        final StoreQueryParams<T> storeQueryParams = StoreQueryParams.fromNameAndType(this.storeName(), this.queryableStoreType());\n+        storeQueryParams.partition = this.partition;\n+        storeQueryParams.staleStores = true;\n+        return storeQueryParams;\n+    }\n+\n+    /**\n+     * Get the store name for which key is queried by the user.\n+     *\n+     * @return String storeName", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87c5b9c6789e6f77819eecee0400c64d4220356f"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5MzY4MQ==", "bodyText": "as above to improve JavaDocs", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372793681", "createdAt": "2020-01-30T07:32:03Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting.\n+ * The options would be whether a user would want to enable/disable stale stores\n+ * or whether it knows the list of partitions that it specifically wants to fetch.\n+ * If this information is not provided the default behavior is to fetch the stores for all the partitions\n+ * available on that instance for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the {@link KeyQueryMetadata}.\n+ */\n+public class StoreQueryParams<T> {\n+\n+    private Integer partition;\n+    private boolean staleStores;\n+    private final String storeName;\n+    private final QueryableStoreType<T> queryableStoreType;\n+\n+    private StoreQueryParams(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        this.storeName = storeName;\n+        this.queryableStoreType = queryableStoreType;\n+    }\n+\n+    public static <T> StoreQueryParams<T> fromNameAndType(final String storeName,\n+                                                          final QueryableStoreType<T>  queryableStoreType) {\n+        return new StoreQueryParams<T>(storeName, queryableStoreType);\n+    }\n+\n+    /**\n+     * Set a specific partition that should be queried exclusively.\n+     *\n+     * @param partition   The specific integer partition to be fetched from the stores list by using {@link StoreQueryParams}.\n+     *\n+     * @return String storeName\n+     */\n+    public StoreQueryParams<T> withPartition(final Integer partition) {\n+        final StoreQueryParams<T> storeQueryParams = StoreQueryParams.fromNameAndType(this.storeName(), this.queryableStoreType());\n+        storeQueryParams.partition = partition;\n+        storeQueryParams.staleStores = this.staleStores;\n+        return storeQueryParams;\n+    }\n+\n+    /**\n+     * Enable querying of stale state stores, i.e., allow to query active tasks during restore as well as standby tasks.\n+     *\n+     * @return String storeName\n+     */\n+    public StoreQueryParams<T> enableStaleStores() {\n+        final StoreQueryParams<T> storeQueryParams = StoreQueryParams.fromNameAndType(this.storeName(), this.queryableStoreType());\n+        storeQueryParams.partition = this.partition;\n+        storeQueryParams.staleStores = true;\n+        return storeQueryParams;\n+    }\n+\n+    /**\n+     * Get the store name for which key is queried by the user.\n+     *\n+     * @return String storeName\n+     */\n+    public String storeName() {\n+        return storeName;\n+    }\n+\n+    /**\n+     * Get the queryable store type for which key is queried by the user.\n+     *\n+     * @return QueryableStoreType queryableStoreType\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87c5b9c6789e6f77819eecee0400c64d4220356f"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5MzkxOA==", "bodyText": "will be returned -> will be queried", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372793918", "createdAt": "2020-01-30T07:32:40Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting.\n+ * The options would be whether a user would want to enable/disable stale stores\n+ * or whether it knows the list of partitions that it specifically wants to fetch.\n+ * If this information is not provided the default behavior is to fetch the stores for all the partitions\n+ * available on that instance for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the {@link KeyQueryMetadata}.\n+ */\n+public class StoreQueryParams<T> {\n+\n+    private Integer partition;\n+    private boolean staleStores;\n+    private final String storeName;\n+    private final QueryableStoreType<T> queryableStoreType;\n+\n+    private StoreQueryParams(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        this.storeName = storeName;\n+        this.queryableStoreType = queryableStoreType;\n+    }\n+\n+    public static <T> StoreQueryParams<T> fromNameAndType(final String storeName,\n+                                                          final QueryableStoreType<T>  queryableStoreType) {\n+        return new StoreQueryParams<T>(storeName, queryableStoreType);\n+    }\n+\n+    /**\n+     * Set a specific partition that should be queried exclusively.\n+     *\n+     * @param partition   The specific integer partition to be fetched from the stores list by using {@link StoreQueryParams}.\n+     *\n+     * @return String storeName\n+     */\n+    public StoreQueryParams<T> withPartition(final Integer partition) {\n+        final StoreQueryParams<T> storeQueryParams = StoreQueryParams.fromNameAndType(this.storeName(), this.queryableStoreType());\n+        storeQueryParams.partition = partition;\n+        storeQueryParams.staleStores = this.staleStores;\n+        return storeQueryParams;\n+    }\n+\n+    /**\n+     * Enable querying of stale state stores, i.e., allow to query active tasks during restore as well as standby tasks.\n+     *\n+     * @return String storeName\n+     */\n+    public StoreQueryParams<T> enableStaleStores() {\n+        final StoreQueryParams<T> storeQueryParams = StoreQueryParams.fromNameAndType(this.storeName(), this.queryableStoreType());\n+        storeQueryParams.partition = this.partition;\n+        storeQueryParams.staleStores = true;\n+        return storeQueryParams;\n+    }\n+\n+    /**\n+     * Get the store name for which key is queried by the user.\n+     *\n+     * @return String storeName\n+     */\n+    public String storeName() {\n+        return storeName;\n+    }\n+\n+    /**\n+     * Get the queryable store type for which key is queried by the user.\n+     *\n+     * @return QueryableStoreType queryableStoreType\n+     */\n+    public QueryableStoreType<T> queryableStoreType() {\n+        return queryableStoreType;\n+    }\n+\n+    /**\n+     * Get the partition to be used to fetch list of stores.\n+     * If the method returns {@code null}, it would mean that no specific partition has been requested,\n+     * so all the local partitions for the store will be returned.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87c5b9c6789e6f77819eecee0400c64d4220356f"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5NDQ3MQ==", "bodyText": "to fetch list of stores -- that describe some internal implementation detail.\nBetter: Get the store partition that will be queried.", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372794471", "createdAt": "2020-01-30T07:34:13Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting.\n+ * The options would be whether a user would want to enable/disable stale stores\n+ * or whether it knows the list of partitions that it specifically wants to fetch.\n+ * If this information is not provided the default behavior is to fetch the stores for all the partitions\n+ * available on that instance for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the {@link KeyQueryMetadata}.\n+ */\n+public class StoreQueryParams<T> {\n+\n+    private Integer partition;\n+    private boolean staleStores;\n+    private final String storeName;\n+    private final QueryableStoreType<T> queryableStoreType;\n+\n+    private StoreQueryParams(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        this.storeName = storeName;\n+        this.queryableStoreType = queryableStoreType;\n+    }\n+\n+    public static <T> StoreQueryParams<T> fromNameAndType(final String storeName,\n+                                                          final QueryableStoreType<T>  queryableStoreType) {\n+        return new StoreQueryParams<T>(storeName, queryableStoreType);\n+    }\n+\n+    /**\n+     * Set a specific partition that should be queried exclusively.\n+     *\n+     * @param partition   The specific integer partition to be fetched from the stores list by using {@link StoreQueryParams}.\n+     *\n+     * @return String storeName\n+     */\n+    public StoreQueryParams<T> withPartition(final Integer partition) {\n+        final StoreQueryParams<T> storeQueryParams = StoreQueryParams.fromNameAndType(this.storeName(), this.queryableStoreType());\n+        storeQueryParams.partition = partition;\n+        storeQueryParams.staleStores = this.staleStores;\n+        return storeQueryParams;\n+    }\n+\n+    /**\n+     * Enable querying of stale state stores, i.e., allow to query active tasks during restore as well as standby tasks.\n+     *\n+     * @return String storeName\n+     */\n+    public StoreQueryParams<T> enableStaleStores() {\n+        final StoreQueryParams<T> storeQueryParams = StoreQueryParams.fromNameAndType(this.storeName(), this.queryableStoreType());\n+        storeQueryParams.partition = this.partition;\n+        storeQueryParams.staleStores = true;\n+        return storeQueryParams;\n+    }\n+\n+    /**\n+     * Get the store name for which key is queried by the user.\n+     *\n+     * @return String storeName\n+     */\n+    public String storeName() {\n+        return storeName;\n+    }\n+\n+    /**\n+     * Get the queryable store type for which key is queried by the user.\n+     *\n+     * @return QueryableStoreType queryableStoreType\n+     */\n+    public QueryableStoreType<T> queryableStoreType() {\n+        return queryableStoreType;\n+    }\n+\n+    /**\n+     * Get the partition to be used to fetch list of stores.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87c5b9c6789e6f77819eecee0400c64d4220356f"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5NDY4NQ==", "bodyText": "As above -- incorrect return type description", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372794685", "createdAt": "2020-01-30T07:34:59Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/StoreQueryParams.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams;\n+\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Represents all the query options that a user can provide to state what kind of stores it is expecting.\n+ * The options would be whether a user would want to enable/disable stale stores\n+ * or whether it knows the list of partitions that it specifically wants to fetch.\n+ * If this information is not provided the default behavior is to fetch the stores for all the partitions\n+ * available on that instance for that particular store name.\n+ * It contains a partition, which for a point queries can be populated from the {@link KeyQueryMetadata}.\n+ */\n+public class StoreQueryParams<T> {\n+\n+    private Integer partition;\n+    private boolean staleStores;\n+    private final String storeName;\n+    private final QueryableStoreType<T> queryableStoreType;\n+\n+    private StoreQueryParams(final String storeName, final QueryableStoreType<T>  queryableStoreType) {\n+        this.storeName = storeName;\n+        this.queryableStoreType = queryableStoreType;\n+    }\n+\n+    public static <T> StoreQueryParams<T> fromNameAndType(final String storeName,\n+                                                          final QueryableStoreType<T>  queryableStoreType) {\n+        return new StoreQueryParams<T>(storeName, queryableStoreType);\n+    }\n+\n+    /**\n+     * Set a specific partition that should be queried exclusively.\n+     *\n+     * @param partition   The specific integer partition to be fetched from the stores list by using {@link StoreQueryParams}.\n+     *\n+     * @return String storeName\n+     */\n+    public StoreQueryParams<T> withPartition(final Integer partition) {\n+        final StoreQueryParams<T> storeQueryParams = StoreQueryParams.fromNameAndType(this.storeName(), this.queryableStoreType());\n+        storeQueryParams.partition = partition;\n+        storeQueryParams.staleStores = this.staleStores;\n+        return storeQueryParams;\n+    }\n+\n+    /**\n+     * Enable querying of stale state stores, i.e., allow to query active tasks during restore as well as standby tasks.\n+     *\n+     * @return String storeName", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "87c5b9c6789e6f77819eecee0400c64d4220356f"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5NTcyMg==", "bodyText": "Seems you missed this commnet? If you disagree with my comment, can you elaborate why (maybe I am missing something)?", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372795722", "createdAt": "2020-01-30T07:38:24Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/StreamThreadStateStoreProvider.java", "diffHunk": "@@ -30,27 +32,35 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n public class StreamThreadStateStoreProvider {\n \n     private final StreamThread streamThread;\n+    private final InternalTopologyBuilder internalTopologyBuilder;\n \n-    public StreamThreadStateStoreProvider(final StreamThread streamThread) {\n+    public StreamThreadStateStoreProvider(final StreamThread streamThread, final InternalTopologyBuilder internalTopologyBuilder) {\n         this.streamThread = streamThread;\n+        this.internalTopologyBuilder = internalTopologyBuilder;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    public <T> List<T> stores(final String storeName,\n-                              final QueryableStoreType<T> queryableStoreType,\n-                              final boolean includeStaleStores) {\n+    public <T> List<T> stores(final StoreQueryParams storeQueryParams) {\n+        final String storeName = storeQueryParams.getStoreName();\n+        final QueryableStoreType<T> queryableStoreType = storeQueryParams.getQueryableStoreType();\n+        final TaskId keyTaskId = createKeyTaskId(storeName, storeQueryParams.partition());\n         if (streamThread.state() == StreamThread.State.DEAD) {\n             return Collections.emptyList();\n         }\n         final StreamThread.State state = streamThread.state();\n-        if (includeStaleStores ? state.isAlive() : state == StreamThread.State.RUNNING) {\n-            final Map<TaskId, ? extends Task> tasks = includeStaleStores ? streamThread.allTasks() : streamThread.activeTasks();\n+        if (storeQueryParams.staleStoresEnabled() ? state.isAlive() : state == StreamThread.State.RUNNING) {\n+            final Map<TaskId, ? extends Task> tasks = storeQueryParams.staleStoresEnabled() ? streamThread.allTasks() : streamThread.activeTasks();\n             final List<T> stores = new ArrayList<>();\n             for (final Task streamTask : tasks.values()) {\n+                if (keyTaskId != null && !keyTaskId.equals(streamTask.id())) {\n+                    continue;\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4ODEyNg=="}, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5NTkwNw==", "bodyText": "Thanks @guozhangwang -- as this is internal, we can still improve on it in a follow up.", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372795907", "createdAt": "2020-01-30T07:38:59Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/StreamThreadStateStoreProvider.java", "diffHunk": "@@ -72,8 +82,23 @@ public StreamThreadStateStoreProvider(final StreamThread streamThread) {\n         } else {\n             throw new InvalidStateStoreException(\"Cannot get state store \" + storeName + \" because the stream thread is \" +\n                                                      state + \", not RUNNING\" +\n-                                                     (includeStaleStores ? \" or REBALANCING\" : \"\"));\n+                                                     (storeQueryParams.staleStoresEnabled() ? \" or REBALANCING\" : \"\"));\n         }\n     }\n \n+    private TaskId createKeyTaskId(final String storeName, final Integer partition) {\n+        if (partition == null) {\n+            return null;\n+        }\n+        final List<String> sourceTopics = internalTopologyBuilder.stateStoreNameToSourceTopics().get(storeName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY4NjE4NQ=="}, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc5NjY2Ng==", "bodyText": "If you want to verify that only the active task returns data, the test name should indicate this.", "url": "https://github.com/apache/kafka/pull/7984#discussion_r372796666", "createdAt": "2020-01-30T07:41:31Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/StoreQueryIntegrationTest.java", "diffHunk": "@@ -0,0 +1,351 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.integration;\n+\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.clients.producer.ProducerConfig;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyQueryMetadata;\n+import org.apache.kafka.streams.StoreQueryParams;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.errors.InvalidStateStoreException;\n+import org.apache.kafka.streams.integration.utils.EmbeddedKafkaCluster;\n+import org.apache.kafka.streams.integration.utils.IntegrationTestUtils;\n+import org.apache.kafka.streams.kstream.Consumed;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.processor.StateRestoreListener;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+import org.apache.kafka.streams.state.QueryableStoreType;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.ReadOnlyKeyValueStore;\n+import org.apache.kafka.test.IntegrationTest;\n+import org.apache.kafka.test.TestUtils;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.apache.kafka.streams.integration.utils.IntegrationTestUtils.startApplicationAndWaitUntilRunning;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+\n+@Category({IntegrationTest.class})\n+public class StoreQueryIntegrationTest {\n+\n+    private static final int NUM_BROKERS = 1;\n+    private static int port = 0;\n+    private static final String INPUT_TOPIC_NAME = \"input-topic\";\n+    private static final String TABLE_NAME = \"source-table\";\n+\n+    @Rule\n+    public final EmbeddedKafkaCluster cluster = new EmbeddedKafkaCluster(NUM_BROKERS);\n+\n+    private final List<KafkaStreams> streamsToCleanup = new ArrayList<>();\n+    private final MockTime mockTime = cluster.time;\n+\n+    @Before\n+    public void before() throws InterruptedException {\n+        cluster.createTopic(INPUT_TOPIC_NAME, 2, 1);\n+    }\n+\n+    @After\n+    public void after() {\n+        for (final KafkaStreams kafkaStreams : streamsToCleanup) {\n+            kafkaStreams.close();\n+        }\n+    }\n+\n+    @Test\n+    public void shouldQueryAllActivePartitionStoresByDefault() throws Exception {\n+        final int batch1NumMessages = 100;\n+        final int key = 1;\n+        final Semaphore semaphore = new Semaphore(0);\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        builder\n+                .table(INPUT_TOPIC_NAME, Consumed.with(Serdes.Integer(), Serdes.Integer()),\n+                        Materialized.<Integer, Integer, KeyValueStore<Bytes, byte[]>>as(TABLE_NAME)\n+                                .withCachingDisabled())\n+                .toStream()\n+                .peek((k, v) -> semaphore.release());\n+\n+        final KafkaStreams kafkaStreams1 = createKafkaStreams(builder, streamsConfiguration());\n+        final KafkaStreams kafkaStreams2 = createKafkaStreams(builder, streamsConfiguration());\n+        final List<KafkaStreams> kafkaStreamsList = Arrays.asList(kafkaStreams1, kafkaStreams2);\n+\n+        startApplicationAndWaitUntilRunning(kafkaStreamsList, Duration.ofSeconds(60));\n+\n+        produceValueRange(key, 0, batch1NumMessages);\n+\n+        // Assert that all messages in the first batch were processed in a timely manner\n+        assertThat(semaphore.tryAcquire(batch1NumMessages, 60, TimeUnit.SECONDS), is(equalTo(true)));\n+        final KeyQueryMetadata keyQueryMetadata = kafkaStreams1.queryMetadataForKey(TABLE_NAME, key, (topic, somekey, value, numPartitions) -> 0);\n+\n+        final QueryableStoreType<ReadOnlyKeyValueStore<Integer, Integer>> queryableStoreType = QueryableStoreTypes.keyValueStore();\n+        final ReadOnlyKeyValueStore<Integer, Integer> store1 = kafkaStreams1\n+                .store(StoreQueryParams.fromNameAndType(TABLE_NAME, queryableStoreType));\n+\n+        final ReadOnlyKeyValueStore<Integer, Integer> store2 = kafkaStreams2\n+                .store(StoreQueryParams.fromNameAndType(TABLE_NAME, queryableStoreType));\n+\n+        final boolean kafkaStreams1IsActive;\n+        if ((keyQueryMetadata.getActiveHost().port() % 2) == 1) {\n+            kafkaStreams1IsActive = true;\n+        } else {\n+            kafkaStreams1IsActive = false;\n+        }\n+\n+        // Assert that only active is able to query for a key by default\n+        assertThat(kafkaStreams1IsActive ? store1.get(key) : store2.get(key), is(notNullValue()));\n+        assertThat(kafkaStreams1IsActive ? store2.get(key) : store1.get(key), is(nullValue()));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY5MjczOA=="}, "originalCommit": {"oid": "42ded2caf421de95ad307b7212bb8d93092e6c44"}, "originalPosition": 139}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2057, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}