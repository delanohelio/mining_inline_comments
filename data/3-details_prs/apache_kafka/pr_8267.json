{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2NDA3NzE2", "number": 8267, "title": "KAFKA-6647: Do note delete the lock file while holding the lock", "bodyText": "Inside StateDirectory#cleanRemovedTasks, skip deleting the lock file (and hence the parent directory) until releasing the lock. And after the lock is released only go ahead and delete the parent directory if manualUserCall == true. That is, this is triggered from KafkaStreams#cleanUp and users are responsible to make sure that Streams instance is not started and hence there are no other threads trying to grab that lock.\n\n\nAs a result, during scheduled cleanup the corresponding task.dir would not be empty but be left with only the lock file, so effectively we still achieve the goal of releasing disk spaces. For callers of listTaskDirectories like KIP-441 (cc @ableegoldman to take a look) I've introduced a new listNonEmptyTaskDirectories which excludes such dummy task.dirs with only the lock file left.\n\n\nAlso fixed KAFKA-8999 along the way to expose the exception while traversing the directory.\n\n\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-03-10T23:13:53Z", "url": "https://github.com/apache/kafka/pull/8267", "merged": true, "mergeCommit": {"oid": "605d55dc173156471fb05c40d715ab318ce74952"}, "closed": true, "closedAt": "2020-03-14T20:49:09Z", "author": {"login": "guozhangwang"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcMHVANgH2gAyMzg2NDA3NzE2OjBkM2FjZWI1NzAyYzBmMDdlYmFlODUyNGVjOTczYWJkODEyNjY5NWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcNrMqngH2gAyMzg2NDA3NzE2OmU3Njk1NjA5MGYxYjgwMTBlZmI1YjFiZTlkYzdhMjRhN2I5ODg0YTY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0d3aceb5702c0f07ebae8524ec973abd8126695a", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/0d3aceb5702c0f07ebae8524ec973abd8126695a", "committedDate": "2020-03-10T00:25:27Z", "message": "first try"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e0a5038991cc473f376c8d43c8a26c8a484b404", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/7e0a5038991cc473f376c8d43c8a26c8a484b404", "committedDate": "2020-03-10T00:26:23Z", "message": "pass in LOCK_FILE_NAME"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe259171a744f9fcc52c09e008621e03d0ee0558", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/fe259171a744f9fcc52c09e008621e03d0ee0558", "committedDate": "2020-03-10T01:15:39Z", "message": "refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22844d00ccdf50a003f4407d5ba167969c3014dd", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/22844d00ccdf50a003f4407d5ba167969c3014dd", "committedDate": "2020-03-10T03:15:43Z", "message": "final fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyMzgzNTM4", "url": "https://github.com/apache/kafka/pull/8267#pullrequestreview-372383538", "createdAt": "2020-03-10T23:15:04Z", "commit": {"oid": "22844d00ccdf50a003f4407d5ba167969c3014dd"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMzoxNTowNVrOF0kQPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMzoxNjoxNFrOF0kR-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2NDI1Mg==", "bodyText": "This is a minor code clean up.", "url": "https://github.com/apache/kafka/pull/8267#discussion_r390664252", "createdAt": "2020-03-10T23:15:05Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -294,61 +302,69 @@ private synchronized void cleanRemovedTasks(final long cleanupDelayMs,\n             final String dirName = taskDir.getName();\n             final TaskId id = TaskId.parse(dirName);\n             if (!locks.containsKey(id)) {\n+                Exception exception = null;\n                 try {\n                     if (lock(id)) {\n                         final long now = time.milliseconds();\n                         final long lastModifiedMs = taskDir.lastModified();\n-                        if (now > lastModifiedMs + cleanupDelayMs || manualUserCall) {\n-                            if (!manualUserCall) {\n-                                log.info(\n-                                    \"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n-                                    logPrefix(),\n-                                    dirName,\n-                                    id,\n-                                    now - lastModifiedMs,\n-                                    cleanupDelayMs);\n-                            } else {\n-                                log.info(\n-                                        \"{} Deleting state directory {} for task {} as user calling cleanup.\",\n-                                        logPrefix(),\n-                                        dirName,\n-                                        id);\n-                            }\n-                            Utils.delete(taskDir);\n+                        if (now > lastModifiedMs + cleanupDelayMs) {\n+                            log.info(\"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n+                                logPrefix(), dirName, id, now - lastModifiedMs, cleanupDelayMs);\n+\n+                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n+                        } else if (manualUserCall) {\n+                            log.info(\"{} Deleting state directory {} for task {} as user calling cleanup.\",\n+                                logPrefix(), dirName, id);\n+\n+                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n                         }\n                     }\n-                } catch (final OverlappingFileLockException e) {\n-                    // locked by another thread\n-                    if (manualUserCall) {\n-                        log.error(\"{} Failed to get the state directory lock.\", logPrefix(), e);\n-                        throw e;\n-                    }\n-                } catch (final IOException e) {\n-                    log.error(\"{} Failed to delete the state directory.\", logPrefix(), e);\n-                    if (manualUserCall) {\n-                        throw e;\n-                    }\n+                } catch (final OverlappingFileLockException | IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22844d00ccdf50a003f4407d5ba167969c3014dd"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2NDY5OQ==", "bodyText": "This is a bit tricky: for the root file, we only consider deleting it if there's no specified skipping sub-files; otherwise we never try to delete since it would doom with DirectoryNotEmpty.", "url": "https://github.com/apache/kafka/pull/8267#discussion_r390664699", "createdAt": "2020-03-10T23:16:14Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/common/utils/Utils.java", "diffHunk": "@@ -736,29 +736,56 @@ public static Properties mkProperties(final Map<String, String> properties) {\n     /**\n      * Recursively delete the given file/directory and any subfiles (if any exist)\n      *\n-     * @param file The root file at which to begin deleting\n+     * @param rootFile The root file at which to begin deleting\n      */\n-    public static void delete(final File file) throws IOException {\n-        if (file == null)\n+    public static void delete(final File rootFile) throws IOException {\n+        delete(rootFile, Collections.emptyList());\n+    }\n+\n+    /**\n+     * Recursively delete the subfiles (if any exist) of the passed in root file that are not included\n+     * in the list to keep\n+     *\n+     * @param rootFile The root file at which to begin deleting\n+     * @param filesToKeep The subfiles to keep (note that if a subfile is to be kept, so are all its parent\n+     *                    files in its pat)h; if empty we would also delete the root file\n+     */\n+    public static void delete(final File rootFile, final List<File> filesToKeep) throws IOException {\n+        if (rootFile == null)\n             return;\n-        Files.walkFileTree(file.toPath(), new SimpleFileVisitor<Path>() {\n+        Files.walkFileTree(rootFile.toPath(), new SimpleFileVisitor<Path>() {\n             @Override\n             public FileVisitResult visitFileFailed(Path path, IOException exc) throws IOException {\n                 // If the root path did not exist, ignore the error; otherwise throw it.\n-                if (exc instanceof NoSuchFileException && path.toFile().equals(file))\n+                if (exc instanceof NoSuchFileException && path.toFile().equals(rootFile))\n                     return FileVisitResult.TERMINATE;\n                 throw exc;\n             }\n \n             @Override\n             public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) throws IOException {\n-                Files.delete(path);\n+                if (!filesToKeep.contains(path.toFile())) {\n+                    Files.delete(path);\n+                }\n                 return FileVisitResult.CONTINUE;\n             }\n \n             @Override\n             public FileVisitResult postVisitDirectory(Path path, IOException exc) throws IOException {\n-                Files.delete(path);\n+                // KAFKA-8999: if there's an exception thrown previously already, we should throw it\n+                if (exc != null) {\n+                    throw exc;\n+                }\n+\n+                if (rootFile.toPath().equals(path)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22844d00ccdf50a003f4407d5ba167969c3014dd"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNDExMzkw", "url": "https://github.com/apache/kafka/pull/8267#pullrequestreview-372411390", "createdAt": "2020-03-11T00:42:48Z", "commit": {"oid": "22844d00ccdf50a003f4407d5ba167969c3014dd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMDo0Mjo0OFrOF0lxhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMDo0Mjo0OFrOF0lxhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY4OTE1OA==", "bodyText": "What do you think about renaming this, eg  something like isStateful, hasStatefulTopology`, etc?\nIt's really confusing to reason about in its usage, for example why createStateDirectory => #lock returns true.  You have to backtrack to where createStateDirectory is set to understand this. However, I think it's easy to reason about why isStateful => should create state directory.\nAlternatively, what if we have a stateless version of the StateDirectory class that just stubs things where appropriate. Then we could get rid of this altogether. WDYT?", "url": "https://github.com/apache/kafka/pull/8267#discussion_r390689158", "createdAt": "2020-03-11T00:42:48Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -50,11 +51,12 @@\n     static final String LOCK_FILE_NAME = \".lock\";\n     private static final Logger log = LoggerFactory.getLogger(StateDirectory.class);\n \n+    private final Time time;\n+    private final String appId;\n     private final File stateDir;\n     private final boolean createStateDirectory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22844d00ccdf50a003f4407d5ba167969c3014dd"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcyNDE0MDk2", "url": "https://github.com/apache/kafka/pull/8267#pullrequestreview-372414096", "createdAt": "2020-03-11T00:52:50Z", "commit": {"oid": "22844d00ccdf50a003f4407d5ba167969c3014dd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMDo1Mjo1MFrOF0l7Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMDo1Mjo1MFrOF0l7Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY5MTY1NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                File[] lisAllTaskDirectories() {\n          \n          \n            \n                File[] listAllTaskDirectories() {", "url": "https://github.com/apache/kafka/pull/8267#discussion_r390691655", "createdAt": "2020-03-11T00:52:50Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -294,61 +302,69 @@ private synchronized void cleanRemovedTasks(final long cleanupDelayMs,\n             final String dirName = taskDir.getName();\n             final TaskId id = TaskId.parse(dirName);\n             if (!locks.containsKey(id)) {\n+                Exception exception = null;\n                 try {\n                     if (lock(id)) {\n                         final long now = time.milliseconds();\n                         final long lastModifiedMs = taskDir.lastModified();\n-                        if (now > lastModifiedMs + cleanupDelayMs || manualUserCall) {\n-                            if (!manualUserCall) {\n-                                log.info(\n-                                    \"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n-                                    logPrefix(),\n-                                    dirName,\n-                                    id,\n-                                    now - lastModifiedMs,\n-                                    cleanupDelayMs);\n-                            } else {\n-                                log.info(\n-                                        \"{} Deleting state directory {} for task {} as user calling cleanup.\",\n-                                        logPrefix(),\n-                                        dirName,\n-                                        id);\n-                            }\n-                            Utils.delete(taskDir);\n+                        if (now > lastModifiedMs + cleanupDelayMs) {\n+                            log.info(\"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n+                                logPrefix(), dirName, id, now - lastModifiedMs, cleanupDelayMs);\n+\n+                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n+                        } else if (manualUserCall) {\n+                            log.info(\"{} Deleting state directory {} for task {} as user calling cleanup.\",\n+                                logPrefix(), dirName, id);\n+\n+                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n                         }\n                     }\n-                } catch (final OverlappingFileLockException e) {\n-                    // locked by another thread\n-                    if (manualUserCall) {\n-                        log.error(\"{} Failed to get the state directory lock.\", logPrefix(), e);\n-                        throw e;\n-                    }\n-                } catch (final IOException e) {\n-                    log.error(\"{} Failed to delete the state directory.\", logPrefix(), e);\n-                    if (manualUserCall) {\n-                        throw e;\n-                    }\n+                } catch (final OverlappingFileLockException | IOException e) {\n+                    exception = e;\n                 } finally {\n                     try {\n                         unlock(id);\n-                    } catch (final IOException e) {\n-                        log.error(\"{} Failed to release the state directory lock.\", logPrefix());\n+\n+                        // for manual user call, stream threads are not running so it is safe to delete\n+                        // the whole directory\n                         if (manualUserCall) {\n-                            throw e;\n+                            Utils.delete(taskDir);\n                         }\n+                    } catch (final IOException e) {\n+                        exception = e;\n                     }\n                 }\n+\n+                if (exception != null && manualUserCall) {\n+                    log.error(\"{} Failed to release the state directory lock.\", logPrefix());\n+                    throw exception;\n+                }\n             }\n         }\n     }\n \n+    /**\n+     * List all of the task directories that are non-empty\n+     * @return The list of all the non-empty local directories for stream tasks\n+     */\n+    File[] listNonEmptyTaskDirectories() {\n+        return !stateDir.exists() ? new File[0] :\n+            stateDir.listFiles(pathname -> {\n+                if (!pathname.isDirectory() || !PATH_NAME.matcher(pathname.getName()).matches()) {\n+                    return false;\n+                } else {\n+                    return !taskDirEmpty(pathname);\n+                }\n+            });\n+    }\n+\n     /**\n      * List all of the task directories\n      * @return The list of all the existing local directories for stream tasks\n      */\n-    File[] listTaskDirectories() {\n+    File[] lisAllTaskDirectories() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22844d00ccdf50a003f4407d5ba167969c3014dd"}, "originalPosition": 187}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83b7fbe6885123011ef90d2220e18b2150c6a9aa", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/83b7fbe6885123011ef90d2220e18b2150c6a9aa", "committedDate": "2020-03-12T23:07:25Z", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into K6647-do-not-delete-lock-filet"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9618b165e97b3f54d5cff0a43ab7d812212896d", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/e9618b165e97b3f54d5cff0a43ab7d812212896d", "committedDate": "2020-03-13T01:26:55Z", "message": "unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczOTcxOTgx", "url": "https://github.com/apache/kafka/pull/8267#pullrequestreview-373971981", "createdAt": "2020-03-12T23:57:25Z", "commit": {"oid": "22844d00ccdf50a003f4407d5ba167969c3014dd"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNDoxMTozMlrOF13IHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNDoxNjo0OFrOF13L-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjAyMjA0NA==", "bodyText": "Is the double negative intentional here?", "url": "https://github.com/apache/kafka/pull/8267#discussion_r392022044", "createdAt": "2020-03-13T04:11:32Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StateDirectoryTest.java", "diffHunk": "@@ -290,15 +307,21 @@ public void shouldNotRemoveNonTaskDirectoriesAndFiles() {\n     }\n \n     @Test\n-    public void shouldListAllTaskDirectories() {\n+    public void shouldNotListNonEmptyTaskDirectories() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9618b165e97b3f54d5cff0a43ab7d812212896d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjAyMzAzMw==", "bodyText": "This comment makes me wonder why we even bother with locking at all for manual calls. If we know there\u2019s no app running, why not just delete the whole state directory and not bother with locks?", "url": "https://github.com/apache/kafka/pull/8267#discussion_r392023033", "createdAt": "2020-03-13T04:16:48Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateDirectory.java", "diffHunk": "@@ -294,61 +302,69 @@ private synchronized void cleanRemovedTasks(final long cleanupDelayMs,\n             final String dirName = taskDir.getName();\n             final TaskId id = TaskId.parse(dirName);\n             if (!locks.containsKey(id)) {\n+                Exception exception = null;\n                 try {\n                     if (lock(id)) {\n                         final long now = time.milliseconds();\n                         final long lastModifiedMs = taskDir.lastModified();\n-                        if (now > lastModifiedMs + cleanupDelayMs || manualUserCall) {\n-                            if (!manualUserCall) {\n-                                log.info(\n-                                    \"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n-                                    logPrefix(),\n-                                    dirName,\n-                                    id,\n-                                    now - lastModifiedMs,\n-                                    cleanupDelayMs);\n-                            } else {\n-                                log.info(\n-                                        \"{} Deleting state directory {} for task {} as user calling cleanup.\",\n-                                        logPrefix(),\n-                                        dirName,\n-                                        id);\n-                            }\n-                            Utils.delete(taskDir);\n+                        if (now > lastModifiedMs + cleanupDelayMs) {\n+                            log.info(\"{} Deleting obsolete state directory {} for task {} as {}ms has elapsed (cleanup delay is {}ms).\",\n+                                logPrefix(), dirName, id, now - lastModifiedMs, cleanupDelayMs);\n+\n+                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n+                        } else if (manualUserCall) {\n+                            log.info(\"{} Deleting state directory {} for task {} as user calling cleanup.\",\n+                                logPrefix(), dirName, id);\n+\n+                            Utils.delete(taskDir, Collections.singletonList(new File(taskDir, LOCK_FILE_NAME)));\n                         }\n                     }\n-                } catch (final OverlappingFileLockException e) {\n-                    // locked by another thread\n-                    if (manualUserCall) {\n-                        log.error(\"{} Failed to get the state directory lock.\", logPrefix(), e);\n-                        throw e;\n-                    }\n-                } catch (final IOException e) {\n-                    log.error(\"{} Failed to delete the state directory.\", logPrefix(), e);\n-                    if (manualUserCall) {\n-                        throw e;\n-                    }\n+                } catch (final OverlappingFileLockException | IOException e) {\n+                    exception = e;\n                 } finally {\n                     try {\n                         unlock(id);\n-                    } catch (final IOException e) {\n-                        log.error(\"{} Failed to release the state directory lock.\", logPrefix());\n+\n+                        // for manual user call, stream threads are not running so it is safe to delete", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9618b165e97b3f54d5cff0a43ab7d812212896d"}, "originalPosition": 148}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b963e3afdc15491dcb7e69e8880324d3cb6cfa3b", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/b963e3afdc15491dcb7e69e8880324d3cb6cfa3b", "committedDate": "2020-03-13T16:32:01Z", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into K6647-do-not-delete-lock-file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e3146062c7acfbfd8aab05bc574016ad6a4a398", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/9e3146062c7acfbfd8aab05bc574016ad6a4a398", "committedDate": "2020-03-13T16:45:27Z", "message": "address github comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NTIxNzMw", "url": "https://github.com/apache/kafka/pull/8267#pullrequestreview-374521730", "createdAt": "2020-03-13T18:24:48Z", "commit": {"oid": "9e3146062c7acfbfd8aab05bc574016ad6a4a398"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0Njk2NjMz", "url": "https://github.com/apache/kafka/pull/8267#pullrequestreview-374696633", "createdAt": "2020-03-14T04:19:03Z", "commit": {"oid": "9e3146062c7acfbfd8aab05bc574016ad6a4a398"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e55dd4f1672ec1dd1e15d35b5de54afc8cb6f826", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/e55dd4f1672ec1dd1e15d35b5de54afc8cb6f826", "committedDate": "2020-03-14T20:14:16Z", "message": "resolve conflicts from trunk"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e76956090f1b8010efb5b1be9dc7a24a7b9884a6", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/e76956090f1b8010efb5b1be9dc7a24a7b9884a6", "committedDate": "2020-03-14T20:46:51Z", "message": "fix unit tests and renaming"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 215, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}