{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3MzA4MDU1", "number": 8405, "title": "KAFKA-9801: Still trigger rebalance when static member joins in CompletingRebalance phase", "bodyText": "Fix the direct cause of the observed issue on the client side: when heartbeat getting errors and resetting generation, we only need to set it to UNJOINED when it was not already in REBALANCING; otherwise, the join-group handler would throw the retriable UnjoinedGroupException to force the consumer to re-send join group unnecessarily.\n\n\nFix the root cause of the issue on the broker side: we should still trigger rebalance when static member joins in CompletingRebalance phase; otherwise the member.ids would be changed when the assignment is received from the leader, hence causing the new member.id's assignment to be empty.\n\n\nAdded log4j entries as a by-product of my investigation.\n\n\nTesting coverage still in progress.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-04-02T01:25:04Z", "url": "https://github.com/apache/kafka/pull/8405", "merged": true, "mergeCommit": {"oid": "146811ab2964860adc8139cd3518719b2a377612"}, "closed": true, "closedAt": "2020-04-07T22:29:16Z", "author": {"login": "guozhangwang"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTbSlpgH2gAyMzk3MzA4MDU1OmNmOGY3ODk4NjRjZDg2OGFiZTI0YTg3MmE2OGNmY2NlZDVjZGI4NzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcVXHXMgH2gAyMzk3MzA4MDU1OmM0NGYxNDhlNDhmMWJiZWQ0ZTU3MTc2ODBiMTdjMmIwYjVjNTMwNDQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "cf8f789864cd868abe24a872a68cfcced5cdb876", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/cf8f789864cd868abe24a872a68cfcced5cdb876", "committedDate": "2020-04-01T17:38:23Z", "message": "minor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3521bec5d6b524f4c3bf764cc938d51712707a63", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/3521bec5d6b524f4c3bf764cc938d51712707a63", "committedDate": "2020-04-01T17:39:55Z", "message": "Merge branch '2.5' of https://github.com/apache/kafka into KMinor-2.5-investigation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c034ca998f42d7154f02c602235a2dce38f580d", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/9c034ca998f42d7154f02c602235a2dce38f580d", "committedDate": "2020-04-01T17:52:37Z", "message": "fenced instance reason"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56555055ddc32fd4894b6274034a653c83f47510", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/56555055ddc32fd4894b6274034a653c83f47510", "committedDate": "2020-04-01T18:44:24Z", "message": "Merge branch '2.5' of https://github.com/apache/kafka into KMinor-2.5-investigation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8ad46ce14e667f5452a89d0e42f9a2d9d1c14d6", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/c8ad46ce14e667f5452a89d0e42f9a2d9d1c14d6", "committedDate": "2020-04-01T20:00:50Z", "message": "more log4j"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b87e4f6328698c5b3dace1e1fdbb02a40c8cc4e", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/4b87e4f6328698c5b3dace1e1fdbb02a40c8cc4e", "committedDate": "2020-04-02T01:20:14Z", "message": "the fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/03beb118dda94512cbe88f24682c2fcc21e7220a", "committedDate": "2020-04-02T01:21:27Z", "message": "remove commented code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MDczMTEw", "url": "https://github.com/apache/kafka/pull/8405#pullrequestreview-386073110", "createdAt": "2020-04-02T02:39:23Z", "commit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MDczOTkz", "url": "https://github.com/apache/kafka/pull/8405#pullrequestreview-386073993", "createdAt": "2020-04-02T02:42:40Z", "commit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwMjo0Mjo0MFrOF_ZYzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwMjo1OTowNlrOF_ZpJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyMDU1Ng==", "bodyText": "What's the reasoning for this move?", "url": "https://github.com/apache/kafka/pull/8405#discussion_r402020556", "createdAt": "2020-04-02T02:42:40Z", "author": {"login": "abbccdda"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -451,8 +451,9 @@ boolean joinGroupIfNeeded(final Timer timer) {\n                     return false;\n                 }\n             } else {\n-                resetJoinGroupFuture();\n                 final RuntimeException exception = future.exception();\n+                log.info(\"Join group failed with {}\", exception.toString());\n+                resetJoinGroupFuture();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyMTAyMw==", "bodyText": "Should be equivalent to state == MemberState.STABLE?", "url": "https://github.com/apache/kafka/pull/8405#discussion_r402021023", "createdAt": "2020-04-02T02:44:31Z", "author": {"login": "abbccdda"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -892,7 +893,11 @@ protected synchronized String memberId() {\n \n     private synchronized void resetGeneration() {\n         this.generation = Generation.NO_GENERATION;\n-        resetStateAndRejoin();\n+        rejoinNeeded = true;\n+\n+        // only reset the state to un-joined when it is not already in rebalancing\n+        if (state != MemberState.REBALANCING)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyMzcyOA==", "bodyText": "We should add a comment about why we would like to trigger rebalance in this case, for example \"The rejoining static member will replace the assigned member.id, which could be unknown to the current leader. To avoid having an unknown member assignment returned, we need to trigger another rebalance\".", "url": "https://github.com/apache/kafka/pull/8405#discussion_r402023728", "createdAt": "2020-04-02T02:55:19Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -1025,7 +991,51 @@ class GroupCoordinator(val brokerId: Int,\n     } else {\n       group.removePendingMember(memberId)\n     }\n-    maybePrepareRebalance(group, s\"Adding new member $memberId with group instanceid $groupInstanceId\")\n+    maybePrepareRebalance(group, s\"Adding new member $memberId with group instance id $groupInstanceId\")\n+  }\n+\n+  private def updateStaticMemberAndRebalance(group: GroupMetadata,\n+                                             newMemberId: String,\n+                                             groupInstanceId: Option[String],\n+                                             protocols: List[(String, Array[Byte])],\n+                                             responseCallback: JoinCallback): Unit = {\n+    val oldMemberId = group.getStaticMemberId(groupInstanceId)\n+    info(s\"Static member $groupInstanceId of group ${group.groupId} with unknown member id rejoins, assigning new member id $newMemberId, while \" +\n+      s\"old member id $oldMemberId will be removed.\")\n+\n+    val currentLeader = group.leaderOrNull\n+    val member = group.replaceGroupInstance(oldMemberId, newMemberId, groupInstanceId)\n+    // Heartbeat of old member id will expire without effect since the group no longer contains that member id.\n+    // New heartbeat shall be scheduled with new member id.\n+    completeAndScheduleNextHeartbeatExpiration(group, member)\n+\n+    val knownStaticMember = group.get(newMemberId)\n+    group.updateMember(knownStaticMember, protocols, responseCallback)\n+\n+    group.currentState match {\n+      case Stable =>\n+        info(s\"Static member joins during Stable stage will not trigger rebalance.\")\n+        group.maybeInvokeJoinCallback(member, JoinGroupResult(\n+          members = List.empty,\n+          memberId = newMemberId,\n+          generationId = group.generationId,\n+          protocolType = group.protocolType,\n+          protocolName = group.protocolName,\n+          // We want to avoid current leader performing trivial assignment while the group\n+          // is in stable sync stage, because the new assignment in leader's next sync call\n+          // won't be broadcast by a stable group. This could be guaranteed by\n+          // always returning the old leader id so that the current leader won't assume itself\n+          // as a leader based on the returned message, since the new member.id won't match\n+          // returned leader id, therefore no assignment will be performed.\n+          leaderId = currentLeader,\n+          error = Errors.NONE))\n+      case CompletingRebalance =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyNDc0Mg==", "bodyText": "Do we have a way to verify the group actually transits CompletingRebalance -> PrepareRebalance -> CompletingRebalance?", "url": "https://github.com/apache/kafka/pull/8405#discussion_r402024742", "createdAt": "2020-04-02T02:59:06Z", "author": {"login": "abbccdda"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -630,30 +630,31 @@ class GroupCoordinatorTest {\n       Some(protocolType),\n       expectedLeaderId = leaderJoinGroupResult.memberId)\n \n+    // Old follower sync callback will return fenced exception while broker replaces the member identity.\n     EasyMock.reset(replicaManager)\n     val oldFollowerSyncGroupFuture = sendSyncGroupFollower(groupId, oldFollowerJoinGroupResult.generationId,\n       oldFollowerJoinGroupResult.memberId, Some(protocolType), Some(protocolName), followerInstanceId)\n-\n-    // Duplicate follower joins group with unknown member id will trigger member.id replacement.\n     EasyMock.reset(replicaManager)\n     val duplicateFollowerJoinFuture =\n       sendJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols, groupInstanceId = followerInstanceId)\n     timer.advanceClock(1)\n-\n-    // Old follower sync callback will return fenced exception while broker replaces the member identity.\n     val oldFollowerSyncGroupResult = Await.result(oldFollowerSyncGroupFuture, Duration(1, TimeUnit.MILLISECONDS))\n     assertEquals(Errors.FENCED_INSTANCE_ID, oldFollowerSyncGroupResult.error)\n \n-    // Duplicate follower will get the same response as old follower.\n+    // Duplicate follower joins group with unknown member id will trigger member.id replacement,\n+    // and will also trigger a rebalance under CompletingRebalance state", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2OTI2MDU3", "url": "https://github.com/apache/kafka/pull/8405#pullrequestreview-386926057", "createdAt": "2020-04-03T04:14:24Z", "commit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNDoxNDoyNFrOGAEhWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwNToxNzo1M1rOGAFaFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyNzI1OA==", "bodyText": "A couple questions on this change:\n\nIf we are leaving the group through resetGenerationOnLeaveGroup, do we still want to continue the rebalance?\nWe use the the REBALANCING state to tell whether to return RebalanceInProgressException or CommitFailedException. If we reset the generation and leave the state in REBALANCING, wouldn't that mess up the check?\n\nMentioned this offline, but if the problem is misinterpreting responses from the wrong generation, I think it would be safer to detect them directly. We can add the generation information to HeartbeatResponseHandler for example. If the stored generation does not match the current generation when the response is received, we can ignore it.", "url": "https://github.com/apache/kafka/pull/8405#discussion_r402727258", "createdAt": "2020-04-03T04:14:24Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -892,7 +893,11 @@ protected synchronized String memberId() {\n \n     private synchronized void resetGeneration() {\n         this.generation = Generation.NO_GENERATION;\n-        resetStateAndRejoin();\n+        rejoinNeeded = true;\n+\n+        // only reset the state to un-joined when it is not already in rebalancing\n+        if (state != MemberState.REBALANCING)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczOTgyNA==", "bodyText": "Leaving comment here for lack of an alternative. Is it worth checking for the case of an empty assignment? Would the client have been able to recover from this problem by leaving the group and rejoining? I am not sure how much value trying to detect broker versions which are affected by this bug. At least perhaps we can provide a better error message than the BufferUnderflow.", "url": "https://github.com/apache/kafka/pull/8405#discussion_r402739824", "createdAt": "2020-04-03T05:09:41Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -892,7 +893,11 @@ protected synchronized String memberId() {\n \n     private synchronized void resetGeneration() {\n         this.generation = Generation.NO_GENERATION;\n-        resetStateAndRejoin();\n+        rejoinNeeded = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MDQ3NQ==", "bodyText": "The logic we have in doSyncGroup to fill in missing assignments seems dubious. Perhaps there's a compatibility argument to retain it, but it seems more likely to cause problems like the one here than to be useful.", "url": "https://github.com/apache/kafka/pull/8405#discussion_r402740475", "createdAt": "2020-04-03T05:12:28Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -1025,7 +991,51 @@ class GroupCoordinator(val brokerId: Int,\n     } else {\n       group.removePendingMember(memberId)\n     }\n-    maybePrepareRebalance(group, s\"Adding new member $memberId with group instanceid $groupInstanceId\")\n+    maybePrepareRebalance(group, s\"Adding new member $memberId with group instance id $groupInstanceId\")\n+  }\n+\n+  private def updateStaticMemberAndRebalance(group: GroupMetadata,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MTc4MA==", "bodyText": "How does this test case reproduce the problem? I thought we would need a sync group from the leader which included the old memberId?", "url": "https://github.com/apache/kafka/pull/8405#discussion_r402741780", "createdAt": "2020-04-03T05:17:53Z", "author": {"login": "hachikuji"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -630,30 +630,31 @@ class GroupCoordinatorTest {\n       Some(protocolType),\n       expectedLeaderId = leaderJoinGroupResult.memberId)\n \n+    // Old follower sync callback will return fenced exception while broker replaces the member identity.\n     EasyMock.reset(replicaManager)\n     val oldFollowerSyncGroupFuture = sendSyncGroupFollower(groupId, oldFollowerJoinGroupResult.generationId,\n       oldFollowerJoinGroupResult.memberId, Some(protocolType), Some(protocolName), followerInstanceId)\n-\n-    // Duplicate follower joins group with unknown member id will trigger member.id replacement.\n     EasyMock.reset(replicaManager)\n     val duplicateFollowerJoinFuture =\n       sendJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols, groupInstanceId = followerInstanceId)\n     timer.advanceClock(1)\n-\n-    // Old follower sync callback will return fenced exception while broker replaces the member identity.\n     val oldFollowerSyncGroupResult = Await.result(oldFollowerSyncGroupFuture, Duration(1, TimeUnit.MILLISECONDS))\n     assertEquals(Errors.FENCED_INSTANCE_ID, oldFollowerSyncGroupResult.error)\n \n-    // Duplicate follower will get the same response as old follower.\n+    // Duplicate follower joins group with unknown member id will trigger member.id replacement,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a6c43aea6a5997c3abf916762062ceddc6be640", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/7a6c43aea6a5997c3abf916762062ceddc6be640", "committedDate": "2020-04-03T20:59:04Z", "message": "github comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NDY3MTg3", "url": "https://github.com/apache/kafka/pull/8405#pullrequestreview-387467187", "createdAt": "2020-04-03T17:57:06Z", "commit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNzo1NzowNlrOGAhPJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxODoxNzo1NFrOGAiU-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE5NzczMw==", "bodyText": "We just need to check that when the group is already in CompletingRebalance, a duplicate member (could be follower or leader) sending a join group again (line 638) will still trigger a rebalance.", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403197733", "createdAt": "2020-04-03T17:57:06Z", "author": {"login": "guozhangwang"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -630,30 +630,31 @@ class GroupCoordinatorTest {\n       Some(protocolType),\n       expectedLeaderId = leaderJoinGroupResult.memberId)\n \n+    // Old follower sync callback will return fenced exception while broker replaces the member identity.\n     EasyMock.reset(replicaManager)\n     val oldFollowerSyncGroupFuture = sendSyncGroupFollower(groupId, oldFollowerJoinGroupResult.generationId,\n       oldFollowerJoinGroupResult.memberId, Some(protocolType), Some(protocolName), followerInstanceId)\n-\n-    // Duplicate follower joins group with unknown member id will trigger member.id replacement.\n     EasyMock.reset(replicaManager)\n     val duplicateFollowerJoinFuture =\n       sendJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols, groupInstanceId = followerInstanceId)\n     timer.advanceClock(1)\n-\n-    // Old follower sync callback will return fenced exception while broker replaces the member identity.\n     val oldFollowerSyncGroupResult = Await.result(oldFollowerSyncGroupFuture, Duration(1, TimeUnit.MILLISECONDS))\n     assertEquals(Errors.FENCED_INSTANCE_ID, oldFollowerSyncGroupResult.error)\n \n-    // Duplicate follower will get the same response as old follower.\n+    // Duplicate follower joins group with unknown member id will trigger member.id replacement,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MTc4MA=="}, "originalCommit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIwMDk1Ng==", "bodyText": "Good call. In line 623 the group is in CompletingRebalance, and then it transits to PrepareRebalance --- let me add the verification of the group state as well.", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403200956", "createdAt": "2020-04-03T18:00:42Z", "author": {"login": "guozhangwang"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -630,30 +630,31 @@ class GroupCoordinatorTest {\n       Some(protocolType),\n       expectedLeaderId = leaderJoinGroupResult.memberId)\n \n+    // Old follower sync callback will return fenced exception while broker replaces the member identity.\n     EasyMock.reset(replicaManager)\n     val oldFollowerSyncGroupFuture = sendSyncGroupFollower(groupId, oldFollowerJoinGroupResult.generationId,\n       oldFollowerJoinGroupResult.memberId, Some(protocolType), Some(protocolName), followerInstanceId)\n-\n-    // Duplicate follower joins group with unknown member id will trigger member.id replacement.\n     EasyMock.reset(replicaManager)\n     val duplicateFollowerJoinFuture =\n       sendJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols, groupInstanceId = followerInstanceId)\n     timer.advanceClock(1)\n-\n-    // Old follower sync callback will return fenced exception while broker replaces the member identity.\n     val oldFollowerSyncGroupResult = Await.result(oldFollowerSyncGroupFuture, Duration(1, TimeUnit.MILLISECONDS))\n     assertEquals(Errors.FENCED_INSTANCE_ID, oldFollowerSyncGroupResult.error)\n \n-    // Duplicate follower will get the same response as old follower.\n+    // Duplicate follower joins group with unknown member id will trigger member.id replacement,\n+    // and will also trigger a rebalance under CompletingRebalance state", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyNDc0Mg=="}, "originalCommit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIwNjY4OA==", "bodyText": "Yup I agree, let me file a JIRA for this.", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403206688", "createdAt": "2020-04-03T18:07:28Z", "author": {"login": "guozhangwang"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -1025,7 +991,51 @@ class GroupCoordinator(val brokerId: Int,\n     } else {\n       group.removePendingMember(memberId)\n     }\n-    maybePrepareRebalance(group, s\"Adding new member $memberId with group instanceid $groupInstanceId\")\n+    maybePrepareRebalance(group, s\"Adding new member $memberId with group instance id $groupInstanceId\")\n+  }\n+\n+  private def updateStaticMemberAndRebalance(group: GroupMetadata,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0MDQ3NQ=="}, "originalCommit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIwNzkwNQ==", "bodyText": "There are other states beside STABLE and REBALANCING", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403207905", "createdAt": "2020-04-03T18:08:55Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -892,7 +893,11 @@ protected synchronized String memberId() {\n \n     private synchronized void resetGeneration() {\n         this.generation = Generation.NO_GENERATION;\n-        resetStateAndRejoin();\n+        rejoinNeeded = true;\n+\n+        // only reset the state to un-joined when it is not already in rebalancing\n+        if (state != MemberState.REBALANCING)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyMTAyMw=="}, "originalCommit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxMTcyMw==", "bodyText": "Good call, I think the two code path should better not sharing the same callee anyways.\nI think it would not, since if the member is indeed be participating in a rebalance (i.e. it has already sent a join-group request) and a commit is being failed, then heartbeat failure should not change it to return CommitFailedException.\n\nAbout your general comment, I agree that it's better to let heartbeat request remember the generation when it was sent and compare against it even with this change in place. Let me just do that in this PR.", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403211723", "createdAt": "2020-04-03T18:13:26Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -892,7 +893,11 @@ protected synchronized String memberId() {\n \n     private synchronized void resetGeneration() {\n         this.generation = Generation.NO_GENERATION;\n-        resetStateAndRejoin();\n+        rejoinNeeded = true;\n+\n+        // only reset the state to un-joined when it is not already in rebalancing\n+        if (state != MemberState.REBALANCING)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyNzI1OA=="}, "originalCommit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxMzA5OQ==", "bodyText": "No specific reasoning, I just prefer to change the state after we log the message :)", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403213099", "createdAt": "2020-04-03T18:15:00Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -451,8 +451,9 @@ boolean joinGroupIfNeeded(final Timer timer) {\n                     return false;\n                 }\n             } else {\n-                resetJoinGroupFuture();\n                 final RuntimeException exception = future.exception();\n+                log.info(\"Join group failed with {}\", exception.toString());\n+                resetJoinGroupFuture();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjAyMDU1Ng=="}, "originalCommit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxNTYxMA==", "bodyText": "Yes that makes sense, let me improve on the error handling.\nRegarding recovering from it, that I've thought about and it was a bit tricky --- if broker is on older versions then even if the client handles empty assignment by re-sending a join-group request, it would still be treated as not-triggering a rebalance, then the same empty assignment would still be returned..", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403215610", "createdAt": "2020-04-03T18:17:54Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -892,7 +893,11 @@ protected synchronized String memberId() {\n \n     private synchronized void resetGeneration() {\n         this.generation = Generation.NO_GENERATION;\n-        resetStateAndRejoin();\n+        rejoinNeeded = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjczOTgyNA=="}, "originalCommit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NjQxODgy", "url": "https://github.com/apache/kafka/pull/8405#pullrequestreview-387641882", "createdAt": "2020-04-04T00:10:46Z", "commit": {"oid": "7a6c43aea6a5997c3abf916762062ceddc6be640"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwMDoxMDo0N1rOGAtFeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwMDoyMjo1NlrOGAtO1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM5MTg2NA==", "bodyText": "Seems like we'd want to do this for OffsetCommitResponseHandler and SyncGroupResponseHandler as well? I am thinking this will be a big enough change that we should pull it into a separate PR.", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403391864", "createdAt": "2020-04-04T00:10:47Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -1008,28 +1013,36 @@ public void handle(LeaveGroupResponse leaveResponse, RequestFuture<Void> future)\n \n     // visible for testing\n     synchronized RequestFuture<Void> sendHeartbeatRequest() {\n-        log.debug(\"Sending Heartbeat request to coordinator {}\", coordinator);\n+        log.debug(\"Sending Heartbeat request with generation {} and member id {} to coordinator {}\",\n+            generation.generationId, generation.memberId, coordinator);\n         HeartbeatRequest.Builder requestBuilder =\n                 new HeartbeatRequest.Builder(new HeartbeatRequestData()\n                         .setGroupId(rebalanceConfig.groupId)\n                         .setMemberId(this.generation.memberId)\n                         .setGroupInstanceId(this.rebalanceConfig.groupInstanceId.orElse(null))\n                         .setGenerationId(this.generation.generationId));\n         return client.send(coordinator, requestBuilder)\n-                .compose(new HeartbeatResponseHandler());\n+                .compose(new HeartbeatResponseHandler(generation));\n     }\n \n     private class HeartbeatResponseHandler extends CoordinatorResponseHandler<HeartbeatResponse, Void> {\n+        private final Generation sentGeneration;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a6c43aea6a5997c3abf916762062ceddc6be640"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM5MjcyNw==", "bodyText": "This is basically the same thing that we have below. I think we could move it into a generic function in CoordinatorResponseHandler so that it could be used by other handlers.", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403392727", "createdAt": "2020-04-04T00:15:02Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -1038,16 +1051,30 @@ public void handle(HeartbeatResponse heartbeatResponse, RequestFuture<Void> futu\n                 requestRejoin();\n                 future.raise(error);\n             } else if (error == Errors.ILLEGAL_GENERATION) {\n-                log.info(\"Attempt to heartbeat failed since generation {} is not current\", generation.generationId);\n-                resetGenerationOnResponseError(ApiKeys.HEARTBEAT, error);\n-                future.raise(error);\n+                if (sentGeneration.equals(currentGeneration)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a6c43aea6a5997c3abf916762062ceddc6be640"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM5NDI2Mg==", "bodyText": "Just a nit, but there could be one byte in the message. Maybe we can phrase this message something like \"there is insufficient bytes available to read version field (actual size: %d)...\"", "url": "https://github.com/apache/kafka/pull/8405#discussion_r403394262", "createdAt": "2020-04-04T00:22:56Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinator.java", "diffHunk": "@@ -346,6 +346,12 @@ protected void onJoinComplete(int generation,\n \n         Set<TopicPartition> ownedPartitions = new HashSet<>(subscriptions.assignedPartitions());\n \n+        // should at least encode the short version\n+        if (assignmentBuffer.remaining() < 2)\n+            throw new IllegalStateException(\"Coordinator returned assignment is empty, this is not expected; \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a6c43aea6a5997c3abf916762062ceddc6be640"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e03fd85c4f234a9746a021856f468af4d8a06d7c", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/e03fd85c4f234a9746a021856f468af4d8a06d7c", "committedDate": "2020-04-05T22:12:49Z", "message": "revert generation check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "351590a4f73be9f88ae685e1c6dcbd706b0ede54", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/351590a4f73be9f88ae685e1c6dcbd706b0ede54", "committedDate": "2020-04-05T22:18:48Z", "message": "github comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4362b2adefcfa8416acaf77201b3cefae891f27", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/c4362b2adefcfa8416acaf77201b3cefae891f27", "committedDate": "2020-04-05T22:30:31Z", "message": "minor fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NDM2MjE2", "url": "https://github.com/apache/kafka/pull/8405#pullrequestreview-388436216", "createdAt": "2020-04-06T16:50:12Z", "commit": {"oid": "c4362b2adefcfa8416acaf77201b3cefae891f27"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNjo1MDoxM1rOGBg3yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNjo1MDoxM1rOGBg3yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI0MDMzMQ==", "bodyText": "I looked at the flakiness of this test, and propose we just check for exact num.callback", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404240331", "createdAt": "2020-04-06T16:50:13Z", "author": {"login": "guozhangwang"}, "path": "core/src/test/scala/integration/kafka/api/PlaintextConsumerTest.scala", "diffHunk": "@@ -187,11 +187,15 @@ class PlaintextConsumerTest extends BaseConsumerTest {\n     assertEquals(1, listener.callsToAssigned)\n     assertEquals(0, listener.callsToRevoked)\n \n-    Thread.sleep(3500)\n+    // as long as we are part of max.poll no rebalance should be triggered", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c4362b2adefcfa8416acaf77201b3cefae891f27"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92d7f2eef2f37f4bc896eb565a0fefbdf0f88bb8", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/92d7f2eef2f37f4bc896eb565a0fefbdf0f88bb8", "committedDate": "2020-04-06T17:19:46Z", "message": "Merge branch '2.5' of https://github.com/apache/kafka into KMinor-2.5-investigation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7dcc8ffa6b1b6a7855486b30a731c89025f10450", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/7dcc8ffa6b1b6a7855486b30a731c89025f10450", "committedDate": "2020-04-06T17:27:01Z", "message": "remove debugging log"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NTc2MTI3", "url": "https://github.com/apache/kafka/pull/8405#pullrequestreview-388576127", "createdAt": "2020-04-06T20:04:30Z", "commit": {"oid": "7dcc8ffa6b1b6a7855486b30a731c89025f10450"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMDowNDozMFrOGBn2QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMDowNDozMFrOGBn2QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM1NDYyNQ==", "bodyText": "This seems not used", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404354625", "createdAt": "2020-04-06T20:04:30Z", "author": {"login": "abbccdda"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -1427,5 +1440,7 @@ final boolean hasValidMemberId() {\n         return generation != Generation.NO_GENERATION && generation.hasMemberId();\n     }\n \n-\n+    final void setNewGeneration(final Generation generation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dcc8ffa6b1b6a7855486b30a731c89025f10450"}, "originalPosition": 109}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NjE4NDI0", "url": "https://github.com/apache/kafka/pull/8405#pullrequestreview-388618424", "createdAt": "2020-04-06T21:08:24Z", "commit": {"oid": "7dcc8ffa6b1b6a7855486b30a731c89025f10450"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTowODoyNFrOGBp9LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMToyMjo1NFrOGBqaiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4OTE2NA==", "bodyText": "Do we need a reference to the future? A boolean would probably be good enough.", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404389164", "createdAt": "2020-04-06T21:08:24Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/Heartbeat.java", "diffHunk": "@@ -32,6 +32,7 @@\n     private final Timer pollTimer;\n \n     private volatile long lastHeartbeatSend = 0L;\n+    private RequestFuture<Void> heartbeatFuture = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dcc8ffa6b1b6a7855486b30a731c89025f10450"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5MzI0OA==", "bodyText": "nit: maybe hasInflight?", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404393248", "createdAt": "2020-04-06T21:16:30Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/Heartbeat.java", "diffHunk": "@@ -56,60 +57,66 @@ public void poll(long now) {\n         pollTimer.reset(maxPollIntervalMs);\n     }\n \n-    public void sentHeartbeat(long now) {\n+    boolean hasOngoing() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dcc8ffa6b1b6a7855486b30a731c89025f10450"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NDczNQ==", "bodyText": "How about unsubscribe? That is a case where we send LeaveGroup, but we do not intend to rejoin the group.", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404394735", "createdAt": "2020-04-06T21:19:14Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -892,7 +893,11 @@ protected synchronized String memberId() {\n \n     private synchronized void resetGeneration() {\n         this.generation = Generation.NO_GENERATION;\n-        resetStateAndRejoin();\n+        rejoinNeeded = true;\n+\n+        // only reset the state to un-joined when it is not already in rebalancing\n+        if (state != MemberState.REBALANCING)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcyNzI1OA=="}, "originalCommit": {"oid": "03beb118dda94512cbe88f24682c2fcc21e7220a"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NjY4MQ==", "bodyText": "Related to my comment in Heartbeat, but I think this reordering is problematic. It is possible that the heartbeat finishes before we reach this point because it is asynchronous. If we use a boolean in Heartbeat instead, then we can keep the original ordering.", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404396681", "createdAt": "2020-04-06T21:22:54Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinator.java", "diffHunk": "@@ -1317,6 +1328,8 @@ public void onFailure(RuntimeException e) {\n                                     }\n                                 }\n                             });\n+\n+                            heartbeat.sentHeartbeat(now, heartbeatFuture);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7dcc8ffa6b1b6a7855486b30a731c89025f10450"}, "originalPosition": 100}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e84dd88db8643020a2acbf338e2d2868ba91cbdc", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/e84dd88db8643020a2acbf338e2d2868ba91cbdc", "committedDate": "2020-04-06T21:58:12Z", "message": "more comments addressed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac640c43ddc39b54f1fd848f4580866ed074d667", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/ac640c43ddc39b54f1fd848f4580866ed074d667", "committedDate": "2020-04-06T23:30:20Z", "message": "more comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NzA4NzQw", "url": "https://github.com/apache/kafka/pull/8405#pullrequestreview-388708740", "createdAt": "2020-04-07T00:30:34Z", "commit": {"oid": "ac640c43ddc39b54f1fd848f4580866ed074d667"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDozMDozNFrOGBuwSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMDozNDo0NVrOGBu03g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2Nzc4NA==", "bodyText": "nit: we could replace this with TestUtils.waitForCondition?", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404467784", "createdAt": "2020-04-07T00:30:34Z", "author": {"login": "hachikuji"}, "path": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinatorTest.java", "diffHunk": "@@ -465,6 +465,54 @@ public void testSyncGroupRequestWithFencedInstanceIdException() {\n         assertThrows(FencedInstanceIdException.class, () -> coordinator.ensureActiveGroup());\n     }\n \n+    @Test\n+    public void testHeartbeatUnknownMemberResponseDuringRebalancing() throws InterruptedException {\n+        setupCoordinator();\n+        mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));\n+\n+        final int generation = 1;\n+\n+        mockClient.prepareResponse(joinGroupFollowerResponse(generation, memberId, JoinGroupRequest.UNKNOWN_MEMBER_ID, Errors.NONE));\n+        mockClient.prepareResponse(syncGroupResponse(Errors.NONE));\n+\n+        coordinator.ensureActiveGroup();\n+\n+        final AbstractCoordinator.Generation currGen = coordinator.generation();\n+\n+        // let the heartbeat request to send out a request\n+        mockTime.sleep(HEARTBEAT_INTERVAL_MS);\n+\n+        long startMs = System.currentTimeMillis();\n+        while (System.currentTimeMillis() - startMs < 1000 && !coordinator.heartbeat().hasInflight()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac640c43ddc39b54f1fd848f4580866ed074d667"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2ODgyOQ==", "bodyText": "Can we get rid of this sleep since we're blocking below anyway?", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404468829", "createdAt": "2020-04-07T00:34:14Z", "author": {"login": "hachikuji"}, "path": "core/src/test/scala/integration/kafka/api/PlaintextConsumerTest.scala", "diffHunk": "@@ -187,11 +187,15 @@ class PlaintextConsumerTest extends BaseConsumerTest {\n     assertEquals(1, listener.callsToAssigned)\n     assertEquals(0, listener.callsToRevoked)\n \n-    Thread.sleep(3500)\n+    // as long as we are part of max.poll no rebalance should be triggered\n+    Thread.sleep(500)\n+    assertEquals(1, listener.callsToAssigned)\n \n-    // we should fall out of the group and need to rebalance\n-    awaitRebalance(consumer, listener)\n-    assertEquals(2, listener.callsToAssigned)\n+    // after we extend longer than max.poll a rebalance should be triggered\n+    // NOTE we need to have a relatively much larger value than max.poll to let heartbeat expired for sure\n+    Thread.sleep(3000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac640c43ddc39b54f1fd848f4580866ed074d667"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ2ODk1OA==", "bodyText": "Can we replace this with waitUntilTrue as well?", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404468958", "createdAt": "2020-04-07T00:34:45Z", "author": {"login": "hachikuji"}, "path": "core/src/test/scala/integration/kafka/api/PlaintextConsumerTest.scala", "diffHunk": "@@ -187,11 +187,15 @@ class PlaintextConsumerTest extends BaseConsumerTest {\n     assertEquals(1, listener.callsToAssigned)\n     assertEquals(0, listener.callsToRevoked)\n \n-    Thread.sleep(3500)\n+    // as long as we are part of max.poll no rebalance should be triggered\n+    Thread.sleep(500)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac640c43ddc39b54f1fd848f4580866ed074d667"}, "originalPosition": 15}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "533e0803c106a462134573568ce3475c548df435", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/533e0803c106a462134573568ce3475c548df435", "committedDate": "2020-04-07T04:15:22Z", "message": "Merge branch '2.5' of https://github.com/apache/kafka into KMinor-2.5-investigation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "980151b260b0697eedc1062c6c2daa627110d3c0", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/980151b260b0697eedc1062c6c2daa627110d3c0", "committedDate": "2020-04-07T04:26:46Z", "message": "cleanup tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4ODA4Nzg2", "url": "https://github.com/apache/kafka/pull/8405#pullrequestreview-388808786", "createdAt": "2020-04-07T06:10:01Z", "commit": {"oid": "980151b260b0697eedc1062c6c2daa627110d3c0"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNjoxMDowMVrOGB0OEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNjoxMDowMVrOGB0OEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU1NzMzMQ==", "bodyText": "nit: alignment looks a little off", "url": "https://github.com/apache/kafka/pull/8405#discussion_r404557331", "createdAt": "2020-04-07T06:10:01Z", "author": {"login": "hachikuji"}, "path": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinatorTest.java", "diffHunk": "@@ -494,12 +492,12 @@ public void testHeartbeatUnknownMemberResponseDuringRebalancing() throws Interru\n \n         coordinator.requestRejoin();\n \n-        startMs = System.currentTimeMillis();\n-        while (System.currentTimeMillis() - startMs < 1000 && coordinator.heartbeat().hasInflight()) {\n-            Thread.sleep(10);\n-            // poll the client until the heartbeat response is received\n+        TestUtils.waitForCondition(() -> {\n             coordinator.ensureActiveGroup(new MockTime(1L).timer(100L));\n-        }\n+            return !coordinator.heartbeat().hasInflight();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "980151b260b0697eedc1062c6c2daa627110d3c0"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c44f148e48f1bbed4e5717680b17c2b0b5c53044", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/c44f148e48f1bbed4e5717680b17c2b0b5c53044", "committedDate": "2020-04-07T17:54:21Z", "message": "checkstyle"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 40, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}