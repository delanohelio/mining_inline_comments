{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwNjY2MDMy", "number": 9317, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwODo0NTo1M1rOEl-9NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwODo1Mzo0NVrOEl_JoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MjY0MjQ1OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/network/SocketServer.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwODo0NTo1M1rOHVwGPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwNTo1MTowNFrOHXKp-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU3MDE3NQ==", "bodyText": "It is a bit annoying that we have to lookup the ListenerConnectionQuota twice. Once in recordConnectionAndGetThrottleTimeMs and once here. I wonder if we could look it up once to record the rate and to record the throttle time.\nI am thinking about the following to be more concrete. We could add two methods in ListenerConnectionQuota: 1) record and 2) recordThrottleTime. They would encapsulate the logic to respectively record the rate (for the listener and the broker like we do now) and the throttle time. So here we could look up the ListenerConnectionQuota record and get the throttle time, and record the throttle time if > 0.\nThat could improve the readability a bit. I am not sure that it would make a difference from a performance point of view. WDYT?", "url": "https://github.com/apache/kafka/pull/9317#discussion_r492570175", "createdAt": "2020-09-22T08:45:53Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1292,6 +1292,12 @@ class ConnectionQuotas(config: KafkaConfig, time: Time, metrics: Metrics) extend\n     counts.synchronized {\n       val startThrottleTimeMs = time.milliseconds\n       val throttleTimeMs = math.max(recordConnectionAndGetThrottleTimeMs(listenerName, startThrottleTimeMs), 0)\n+      if (throttleTimeMs > 0) {\n+        // record throttle time due to hitting connection rate limit\n+        // connection could be throttled longer if the limit of the number of active connections is reached as well\n+        maxConnectionsPerListener.get(listenerName)\n+          .foreach(_.connectionRateThrottleSensor.record(throttleTimeMs.toDouble, startThrottleTimeMs))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA1Mzg4Mg==", "bodyText": "That code seemed readable to me, but perhaps looking up ListenerConnectionQuota is better. I made a change to lookup once, please take a look.", "url": "https://github.com/apache/kafka/pull/9317#discussion_r494053882", "createdAt": "2020-09-24T05:51:04Z", "author": {"login": "apovzner"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1292,6 +1292,12 @@ class ConnectionQuotas(config: KafkaConfig, time: Time, metrics: Metrics) extend\n     counts.synchronized {\n       val startThrottleTimeMs = time.milliseconds\n       val throttleTimeMs = math.max(recordConnectionAndGetThrottleTimeMs(listenerName, startThrottleTimeMs), 0)\n+      if (throttleTimeMs > 0) {\n+        // record throttle time due to hitting connection rate limit\n+        // connection could be throttled longer if the limit of the number of active connections is reached as well\n+        maxConnectionsPerListener.get(listenerName)\n+          .foreach(_.connectionRateThrottleSensor.record(throttleTimeMs.toDouble, startThrottleTimeMs))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU3MDE3NQ=="}, "originalCommit": null, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MjY0NTcxOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/network/SocketServer.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwODo0NjozOFrOHVwIHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMDoxNzowNFrOHW_YyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU3MDY1Mw==", "bodyText": "nit: Do we really need to provide the type here? It seems that we usually don't provide it in that file.", "url": "https://github.com/apache/kafka/pull/9317#discussion_r492570653", "createdAt": "2020-09-22T08:46:38Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1414,7 +1420,8 @@ class ConnectionQuotas(config: KafkaConfig, time: Time, metrics: Metrics) extend\n \n   class ListenerConnectionQuota(lock: Object, listener: ListenerName) extends ListenerReconfigurable {\n     @volatile private var _maxConnections = Int.MaxValue\n-    val connectionRateSensor = createConnectionRateQuotaSensor(Int.MaxValue, Some(listener.value))\n+    val connectionRateSensor: Sensor = createConnectionRateQuotaSensor(Int.MaxValue, Some(listener.value))\n+    val connectionRateThrottleSensor: Sensor = createConnectionRateThrottleSensor()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg2OTI1Ng==", "bodyText": "I added type because style check suggested (and also checked style guide) to annotate public members. However, I will change this to package scope, since we only need an outer class to access them. So, it was useful that you asked.", "url": "https://github.com/apache/kafka/pull/9317#discussion_r493869256", "createdAt": "2020-09-23T20:17:04Z", "author": {"login": "apovzner"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1414,7 +1420,8 @@ class ConnectionQuotas(config: KafkaConfig, time: Time, metrics: Metrics) extend\n \n   class ListenerConnectionQuota(lock: Object, listener: ListenerName) extends ListenerReconfigurable {\n     @volatile private var _maxConnections = Int.MaxValue\n-    val connectionRateSensor = createConnectionRateQuotaSensor(Int.MaxValue, Some(listener.value))\n+    val connectionRateSensor: Sensor = createConnectionRateQuotaSensor(Int.MaxValue, Some(listener.value))\n+    val connectionRateThrottleSensor: Sensor = createConnectionRateThrottleSensor()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU3MDY1Mw=="}, "originalCommit": null, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MjY3NDI0OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/network/SocketServer.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQwODo1Mzo0NVrOHVwZPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwNDo0MToyMlrOHXJenw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU3NTAzNg==", "bodyText": "nit: What about naming this close? It feels a bit more natural to call close when we don't need the object anymore and it would be more aligned with the close methods that we already have in this file. For instance, ConnectionQuotas#close which also cleanup the metrics.\nBTW, not related to this PR but it seems that we don't close the ListenerConnectionQuota when the ConnectionQuotas is closed. I suppose that we leave metrics around. Is it the case?", "url": "https://github.com/apache/kafka/pull/9317#discussion_r492575036", "createdAt": "2020-09-22T08:53:45Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1447,13 +1454,33 @@ class ConnectionQuotas(config: KafkaConfig, time: Time, metrics: Metrics) extend\n       }\n     }\n \n+    def removeSensors(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAzNDU5MQ==", "bodyText": "agreed, close will be consistent.\nAbout not closing ListenerConnectionQuota on ConnectionQuotas.close(): this is on broker shutdown path where KafkaServer calls metrics.close() on shutdown as well (and metrics are owned by KafkaServer), so I don't think we are leaking anything. But I think it's better to remove listener sensors on ConnectionQuotas.close() anyways, so I will make that change.", "url": "https://github.com/apache/kafka/pull/9317#discussion_r494034591", "createdAt": "2020-09-24T04:41:22Z", "author": {"login": "apovzner"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1447,13 +1454,33 @@ class ConnectionQuotas(config: KafkaConfig, time: Time, metrics: Metrics) extend\n       }\n     }\n \n+    def removeSensors(): Unit = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjU3NTAzNg=="}, "originalCommit": null, "originalPosition": 54}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1849, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}