{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUwNTc3MjU0", "number": 9032, "title": "KAFKA-10259: KIP-554 Broker-side SCRAM Config API", "bodyText": "I still need to add a test file core/src/test/scala/unit/kafka/admin/UserScramCredentialsCommandTest.scala, but aside from that I think it's close to done.", "createdAt": "2020-07-16T22:50:19Z", "url": "https://github.com/apache/kafka/pull/9032", "merged": true, "mergeCommit": {"oid": "e8524ccd8fca0caac79b844d87e98e9c055f76fb"}, "closed": true, "closedAt": "2020-09-04T20:05:02Z", "author": {"login": "rondagostino"}, "timelineItems": {"totalCount": 78, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3H6CtgBqjM1NzE4MzIzNzQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdE_0RngBqjM3MjEwNzE0Mjc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjIxODU1", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-461221855", "createdAt": "2020-08-04T22:33:19Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMjozMzoyMFrOG7zxbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMjozMzoyMFrOG7zxbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2NzQwNw==", "bodyText": "It would be good to document here that users that are specified but not  present will be silently omitted from the result", "url": "https://github.com/apache/kafka/pull/9032#discussion_r465367407", "createdAt": "2020-08-04T22:33:20Z", "author": {"login": "cmccabe"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/Admin.java", "diffHunk": "@@ -1214,6 +1215,60 @@ default AlterClientQuotasResult alterClientQuotas(Collection<ClientQuotaAlterati\n      */\n     AlterClientQuotasResult alterClientQuotas(Collection<ClientQuotaAlteration> entries, AlterClientQuotasOptions options);\n \n+    /**\n+     * <p>Describe all SASL/SCRAM credentials.\n+     *\n+     * <p>This is a convenience method for {@link #describeUserScramCredentials(List, DescribeUserScramCredentialsOptions)}\n+     *\n+     * @return The DescribeUserScramCredentialsResult.\n+     */\n+    default DescribeUserScramCredentialsResult describeUserScramCredentials() {\n+        return describeUserScramCredentials(null, new DescribeUserScramCredentialsOptions());\n+    }\n+\n+    /**\n+     * <p>Describe SASL/SCRAM credentials for the given users.\n+     *\n+     * <p>This is a convenience method for {@link #describeUserScramCredentials(List, DescribeUserScramCredentialsOptions)}\n+     *\n+     * @param users the users for which credentials are to be described; all users' credentials are described if null or empty\n+     * @return The DescribeUserScramCredentialsResult.\n+     */\n+    default DescribeUserScramCredentialsResult describeUserScramCredentials(List<String> users) {\n+        return describeUserScramCredentials(users, new DescribeUserScramCredentialsOptions());\n+    }\n+\n+    /**\n+     * <p>Describe SASL/SCRAM credentials.\n+     *\n+     * @param users the users for which credentials are to be described; all users' credentials are described if null or empty", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjI0Mzk3", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-461224397", "createdAt": "2020-08-04T22:39:49Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMjozOTo0OVrOG7z5zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMjozOTo0OVrOG7z5zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2OTU1MA==", "bodyText": "Hmm... for consistency with from(byte), shouldn't we return UNKNOWN if we don't know the name?", "url": "https://github.com/apache/kafka/pull/9032#discussion_r465369550", "createdAt": "2020-08-04T22:39:49Z", "author": {"login": "cmccabe"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/ScramMechanism.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.clients.admin;\n+\n+/**\n+ * Representation of a SASL/SCRAM Mechanism.\n+ *\n+ * @see <a href=\"https://cwiki.apache.org/confluence/display/KAFKA/KIP-554%3A+Add+Broker-side+SCRAM+Config+API\">KIP-554: Add Broker-side SCRAM Config API</a>\n+ */\n+public enum ScramMechanism {\n+    UNKNOWN((byte) 0),\n+    SCRAM_SHA_256((byte) 1),\n+    SCRAM_SHA_512((byte) 2);\n+\n+    /**\n+     *\n+     * @param b the byte representation\n+     * @return the instance corresponding to the given byte value, otherwise {@link #UNKNOWN}\n+     */\n+    public static ScramMechanism from(byte b) {\n+        for (ScramMechanism scramMechanism : ScramMechanism.values()) {\n+            if (scramMechanism.type == b) {\n+                return scramMechanism;\n+            }\n+        }\n+        return UNKNOWN;\n+    }\n+\n+    /**\n+     *\n+     * @param mechanismName the SASL SCRAM mechanism name\n+     * @return the corresponding SASL SCRAM mechanism enum\n+     * @see <a href=\"https://tools.ietf.org/html/rfc5802#section-4>\n+     *     Salted Challenge Response Authentication Mechanism (SCRAM) SASL and GSS-API Mechanisms, Section 4</a>\n+     */\n+    public static ScramMechanism fromMechanismName(String mechanismName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjI1NTkx", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-461225591", "createdAt": "2020-08-04T22:42:39Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMjo0MjozOVrOG7z92g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMjo0MjozOVrOG7z92g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3MDU4Ng==", "bodyText": "I'd really prefer some way to just get the value byte out of the ScramMechanism object, rather than relying on the ordering of enum entries.  If we are going to rely on the ordering, that would have to be prominently documented in the class (but let's not....)", "url": "https://github.com/apache/kafka/pull/9032#discussion_r465370586", "createdAt": "2020-08-04T22:42:39Z", "author": {"login": "cmccabe"}, "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -980,4 +984,137 @@ class AdminManager(val config: KafkaConfig,\n       entry.entity -> apiError\n     }.toMap\n   }\n+\n+  def describeUserScramCredentials(users: Seq[String]): DescribeUserScramCredentialsResponseData = {\n+    val retval = new DescribeUserScramCredentialsResponseData()\n+\n+    def addToResults(user: String, userConfig: Properties) = {\n+      val configKeys = userConfig.stringPropertyNames\n+      val hasScramCredential = !ScramMechanism.values().toList.filter(key => key != ScramMechanism.UNKNOWN && configKeys.contains(key.toMechanismName)).isEmpty\n+      if (hasScramCredential) {\n+        val userScramCredentials = new UserScramCredential().setName(user)\n+        ScramMechanism.values().foreach(mechanism => if (mechanism != ScramMechanism.UNKNOWN) {\n+          val propertyValue = userConfig.getProperty(mechanism.toMechanismName)\n+          if (propertyValue != null) {\n+            val iterations = ScramCredentialUtils.credentialFromString(propertyValue).iterations\n+            userScramCredentials.credentialInfos.add(new CredentialInfo().setMechanism(mechanism.ordinal.toByte).setIterations(iterations))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjI5NTY5", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-461229569", "createdAt": "2020-08-04T22:52:38Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMjo1MjozOFrOG70LjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMjo1MjozOFrOG70LjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3NDA5Mg==", "bodyText": "We should have a defined ApiException and Errors entry for errors like this.  We could maybe use InvalidConfigurationException / INVALID_CONFIG", "url": "https://github.com/apache/kafka/pull/9032#discussion_r465374092", "createdAt": "2020-08-04T22:52:38Z", "author": {"login": "cmccabe"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java", "diffHunk": "@@ -4071,6 +4081,168 @@ void handleFailure(Throwable throwable) {\n         return new AlterClientQuotasResult(Collections.unmodifiableMap(futures));\n     }\n \n+    @Override\n+    public DescribeUserScramCredentialsResult describeUserScramCredentials(List<String> users, DescribeUserScramCredentialsOptions options) {\n+        final KafkaFutureImpl<Map<String, UserScramCredentialsDescription>> future = new KafkaFutureImpl<>();\n+        final long now = time.milliseconds();\n+        Call call = new Call(\"describeUserScramCredentials\", calcDeadlineMs(now, options.timeoutMs()),\n+                new ControllerNodeProvider()) {\n+            @Override\n+            public DescribeUserScramCredentialsRequest.Builder createRequest(int timeoutMs) {\n+                return new DescribeUserScramCredentialsRequest.Builder(\n+                        new DescribeUserScramCredentialsRequestData().setUsers(users.stream().map(user ->\n+                                new DescribeUserScramCredentialsRequestData.UserName().setName(user)).collect(Collectors.toList())));\n+            }\n+\n+            @Override\n+            public void handleResponse(AbstractResponse abstractResponse) {\n+                DescribeUserScramCredentialsResponse response = (DescribeUserScramCredentialsResponse) abstractResponse;\n+                Errors error = Errors.forCode(response.data().error());\n+                switch (error) {\n+                    case NONE:\n+                        DescribeUserScramCredentialsResponseData data = response.data();\n+                        future.complete(data.userScramCredentials().stream().collect(Collectors.toMap(\n+                            DescribeUserScramCredentialsResponseData.UserScramCredential::name,\n+                            userScramCredential -> {\n+                                List<ScramCredentialInfo> scramCredentialInfos = userScramCredential.credentialInfos().stream().map(\n+                                    credentialInfo -> new ScramCredentialInfo(ScramMechanism.from(credentialInfo.mechanism()), credentialInfo.iterations()))\n+                                        .collect(Collectors.toList());\n+                                return new UserScramCredentialsDescription(userScramCredential.name(), scramCredentialInfos);\n+                            })));\n+                        break;\n+                    case NOT_CONTROLLER:\n+                        handleNotControllerError(error);\n+                        break;\n+                    default:\n+                        future.completeExceptionally(new ApiError(error, response.data().errorMessage()).exception());\n+                        break;\n+                }\n+            }\n+\n+            @Override\n+            void handleFailure(Throwable throwable) {\n+                future.completeExceptionally(throwable);\n+            }\n+        };\n+        runnable.call(call, now);\n+        return new DescribeUserScramCredentialsResult(future);\n+    }\n+\n+    @Override\n+    public AlterUserScramCredentialsResult alterUserScramCredentials(List<UserScramCredentialAlteration> alterations,\n+                                                                     AlterUserScramCredentialsOptions options) {\n+        final long now = time.milliseconds();\n+        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>();\n+        for (UserScramCredentialAlteration alteration: alterations) {\n+            futures.put(alteration.getUser(), new KafkaFutureImpl<>());\n+        }\n+        final Map<String, Exception> userIllegalAlterationExceptions = new HashMap<>();\n+        // We need to keep track of users with deletions of an unknown SCRAM mechanism\n+        alterations.stream().filter(a -> a instanceof UserScramCredentialDeletion).forEach(alteration -> {\n+            UserScramCredentialDeletion deletion = (UserScramCredentialDeletion) alteration;\n+            ScramMechanism mechanism = deletion.getMechanism();\n+            if (mechanism == null || mechanism == ScramMechanism.UNKNOWN) {\n+                userIllegalAlterationExceptions.put(deletion.getUser(), new IllegalArgumentException(\"Unknown SCRAM mechanism\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 117}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjMwMjk3", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-461230297", "createdAt": "2020-08-04T22:54:32Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMjo1NDozMlrOG70N-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMjo1NDozMlrOG70N-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3NDcxMw==", "bodyText": "We should have a defined ApiException subclass for this.  NoSuchAlgorithmException could probably be shoehorned into INVALID_CONFIG.  InvalidKeyException probably needs its own defined error code (which we should add to the KIP).\nThis may seem bureaucratic, but think about it this way: maybe we'll want to do this on the broker side eventually.  Then we need a way to serialize, which plain old java exceptions don't have.", "url": "https://github.com/apache/kafka/pull/9032#discussion_r465374713", "createdAt": "2020-08-04T22:54:32Z", "author": {"login": "cmccabe"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java", "diffHunk": "@@ -4071,6 +4081,168 @@ void handleFailure(Throwable throwable) {\n         return new AlterClientQuotasResult(Collections.unmodifiableMap(futures));\n     }\n \n+    @Override\n+    public DescribeUserScramCredentialsResult describeUserScramCredentials(List<String> users, DescribeUserScramCredentialsOptions options) {\n+        final KafkaFutureImpl<Map<String, UserScramCredentialsDescription>> future = new KafkaFutureImpl<>();\n+        final long now = time.milliseconds();\n+        Call call = new Call(\"describeUserScramCredentials\", calcDeadlineMs(now, options.timeoutMs()),\n+                new ControllerNodeProvider()) {\n+            @Override\n+            public DescribeUserScramCredentialsRequest.Builder createRequest(int timeoutMs) {\n+                return new DescribeUserScramCredentialsRequest.Builder(\n+                        new DescribeUserScramCredentialsRequestData().setUsers(users.stream().map(user ->\n+                                new DescribeUserScramCredentialsRequestData.UserName().setName(user)).collect(Collectors.toList())));\n+            }\n+\n+            @Override\n+            public void handleResponse(AbstractResponse abstractResponse) {\n+                DescribeUserScramCredentialsResponse response = (DescribeUserScramCredentialsResponse) abstractResponse;\n+                Errors error = Errors.forCode(response.data().error());\n+                switch (error) {\n+                    case NONE:\n+                        DescribeUserScramCredentialsResponseData data = response.data();\n+                        future.complete(data.userScramCredentials().stream().collect(Collectors.toMap(\n+                            DescribeUserScramCredentialsResponseData.UserScramCredential::name,\n+                            userScramCredential -> {\n+                                List<ScramCredentialInfo> scramCredentialInfos = userScramCredential.credentialInfos().stream().map(\n+                                    credentialInfo -> new ScramCredentialInfo(ScramMechanism.from(credentialInfo.mechanism()), credentialInfo.iterations()))\n+                                        .collect(Collectors.toList());\n+                                return new UserScramCredentialsDescription(userScramCredential.name(), scramCredentialInfos);\n+                            })));\n+                        break;\n+                    case NOT_CONTROLLER:\n+                        handleNotControllerError(error);\n+                        break;\n+                    default:\n+                        future.completeExceptionally(new ApiError(error, response.data().errorMessage()).exception());\n+                        break;\n+                }\n+            }\n+\n+            @Override\n+            void handleFailure(Throwable throwable) {\n+                future.completeExceptionally(throwable);\n+            }\n+        };\n+        runnable.call(call, now);\n+        return new DescribeUserScramCredentialsResult(future);\n+    }\n+\n+    @Override\n+    public AlterUserScramCredentialsResult alterUserScramCredentials(List<UserScramCredentialAlteration> alterations,\n+                                                                     AlterUserScramCredentialsOptions options) {\n+        final long now = time.milliseconds();\n+        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>();\n+        for (UserScramCredentialAlteration alteration: alterations) {\n+            futures.put(alteration.getUser(), new KafkaFutureImpl<>());\n+        }\n+        final Map<String, Exception> userIllegalAlterationExceptions = new HashMap<>();\n+        // We need to keep track of users with deletions of an unknown SCRAM mechanism\n+        alterations.stream().filter(a -> a instanceof UserScramCredentialDeletion).forEach(alteration -> {\n+            UserScramCredentialDeletion deletion = (UserScramCredentialDeletion) alteration;\n+            ScramMechanism mechanism = deletion.getMechanism();\n+            if (mechanism == null || mechanism == ScramMechanism.UNKNOWN) {\n+                userIllegalAlterationExceptions.put(deletion.getUser(), new IllegalArgumentException(\"Unknown SCRAM mechanism\"));\n+            }\n+        });\n+        // Creating an upsertion may throw InvalidKeyException or NoSuchAlgorithmException,\n+        // so keep track of which users are affected by such a failure and immediately fail all their alterations\n+        final Map<String, Map<ScramMechanism, AlterUserScramCredentialsRequestData.ScramCredentialUpsertion>> userInsertions = new HashMap<>();\n+        alterations.stream().filter(a -> a instanceof UserScramCredentialUpsertion)\n+                .filter(alteration -> !userIllegalAlterationExceptions.containsKey(alteration.getUser()))\n+                .forEach(alteration -> {\n+                    UserScramCredentialUpsertion upsertion = (UserScramCredentialUpsertion) alteration;\n+                    String user = upsertion.getUser();\n+                    try {\n+                        ScramMechanism mechanism = upsertion.getInfo().getMechanism();\n+                        if (mechanism == null || mechanism == ScramMechanism.UNKNOWN)\n+                            throw new IllegalArgumentException(\"Unknown SCRAM mechanism\");\n+                        userInsertions.putIfAbsent(user, new HashMap<>());\n+                        userInsertions.get(user).put(mechanism, getScramCredentialUpsertion(upsertion));\n+                    } catch (Exception e) {\n+                        // we might overwrite aa exception from a previous upsertion, but we don't really care\n+                        // since we just needs to mark this user as having at least one illegal alteration\n+                        // and make an exception instance available for completing the corresponding future exceptionally\n+                        userIllegalAlterationExceptions.put(user, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 138}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjMzODc0", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-461233874", "createdAt": "2020-08-04T23:03:29Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzowMzozMFrOG70ZtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzowMzozMFrOG70ZtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3NzcxNw==", "bodyText": "it would be good to split this off into its own function (after verifying that we weren't trying to do both SCRAM + quota)", "url": "https://github.com/apache/kafka/pull/9032#discussion_r465377717", "createdAt": "2020-08-04T23:03:30Z", "author": {"login": "cmccabe"}, "path": "core/src/main/scala/kafka/admin/ConfigCommand.scala", "diffHunk": "@@ -365,45 +368,90 @@ object ConfigCommand extends Config {\n         adminClient.incrementalAlterConfigs(Map(configResource -> alterLogLevelEntries).asJava, alterOptions).all().get(60, TimeUnit.SECONDS)\n \n       case ConfigType.User | ConfigType.Client =>\n-        val nonQuotaConfigsToAdd = configsToBeAdded.keys.filterNot(QuotaConfigs.isQuotaConfig)\n-        if (nonQuotaConfigsToAdd.nonEmpty)\n-          throw new IllegalArgumentException(s\"Only quota configs can be added for '$entityTypeHead' using --bootstrap-server. Unexpected config names: $nonQuotaConfigsToAdd\")\n-        val nonQuotaConfigsToDelete = configsToBeDeleted.filterNot(QuotaConfigs.isQuotaConfig)\n-        if (nonQuotaConfigsToDelete.nonEmpty)\n-          throw new IllegalArgumentException(s\"Only quota configs can be deleted for '$entityTypeHead' using --bootstrap-server. Unexpected config names: $nonQuotaConfigsToDelete\")\n-\n-\n-        val oldConfig = getClientQuotasConfig(adminClient, entityTypes, entityNames)\n-\n-        val invalidConfigs = configsToBeDeleted.filterNot(oldConfig.contains)\n-        if (invalidConfigs.nonEmpty)\n-          throw new InvalidConfigurationException(s\"Invalid config(s): ${invalidConfigs.mkString(\",\")}\")\n-\n-        val alterEntityTypes = entityTypes.map { entType =>\n-          entType match {\n-            case ConfigType.User => ClientQuotaEntity.USER\n-            case ConfigType.Client => ClientQuotaEntity.CLIENT_ID\n-            case _ => throw new IllegalArgumentException(s\"Unexpected entity type: ${entType}\")\n+        val hasQuotaConfigsToAdd = configsToBeAdded.keys.exists(QuotaConfigs.isQuotaConfig)\n+        val scramConfigsToAddMap = configsToBeAdded.filter(entry => ScramMechanism.isScram(entry._1))\n+        val unknownConfigsToAdd = configsToBeAdded.keys.filterNot(key => ScramMechanism.isScram(key) || QuotaConfigs.isQuotaConfig(key))\n+        val hasQuotaConfigsToDelete = configsToBeDeleted.exists(QuotaConfigs.isQuotaConfig)\n+        val scramConfigsToDelete = configsToBeDeleted.filter(ScramMechanism.isScram)\n+        val unknownConfigsToDelete = configsToBeDeleted.filterNot(key => ScramMechanism.isScram(key) || QuotaConfigs.isQuotaConfig(key))\n+        if (entityTypeHead == ConfigType.Client || entityTypes.size == 2) { // size==2 for case where users is specified first on the command line, before clients\n+          // either just a client or both a user and a client\n+          if (unknownConfigsToAdd.nonEmpty || scramConfigsToAddMap.nonEmpty)\n+            throw new IllegalArgumentException(s\"Only quota configs can be added for '${ConfigType.Client}' using --bootstrap-server. Unexpected config names: ${unknownConfigsToAdd ++ scramConfigsToAddMap.keys}\")\n+          if (unknownConfigsToDelete.nonEmpty || scramConfigsToDelete.nonEmpty)\n+            throw new IllegalArgumentException(s\"Only quota configs can be deleted for '${ConfigType.Client}' using --bootstrap-server. Unexpected config names: ${unknownConfigsToDelete ++ scramConfigsToDelete}\")\n+        } else { // ConfigType.User\n+          if (unknownConfigsToAdd.nonEmpty)\n+            throw new IllegalArgumentException(s\"Only quota and SCRAM credential configs can be added for '${ConfigType.User}' using --bootstrap-server. Unexpected config names: $unknownConfigsToAdd\")\n+          if (unknownConfigsToDelete.nonEmpty)\n+            throw new IllegalArgumentException(s\"Only quota and SCRAM credential configs can be deleted for '${ConfigType.User}' using --bootstrap-server. Unexpected config names: $unknownConfigsToDelete\")\n+          if (scramConfigsToAddMap.nonEmpty || scramConfigsToDelete.nonEmpty) {\n+            if (entityNames.exists(_.isEmpty)) // either --entity-type users --entity-default or --user-defaults\n+              throw new IllegalArgumentException(\"The use of --entity-default or --user-defaults is not allowed with User SCRAM Credentials using --bootstrap-server.\")\n+            if (hasQuotaConfigsToAdd || hasQuotaConfigsToDelete)\n+              throw new IllegalArgumentException(s\"Cannot alter both quota and SCRAM credential configs simultaneously for '${ConfigType.User}' using --bootstrap-server.\")\n           }\n         }\n-        val alterEntityNames = entityNames.map(en => if (en.nonEmpty) en else null)\n \n-        // Explicitly populate a HashMap to ensure nulls are recorded properly.\n-        val alterEntityMap = new java.util.HashMap[String, String]\n-        alterEntityTypes.zip(alterEntityNames).foreach { case (k, v) => alterEntityMap.put(k, v) }\n-        val entity = new ClientQuotaEntity(alterEntityMap)\n+        if (hasQuotaConfigsToAdd || hasQuotaConfigsToDelete) {\n+          // handle altering client/user quota configs", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 96}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjM0MzUy", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-461234352", "createdAt": "2020-08-04T23:04:48Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzowNDo0OFrOG70bSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzowNDo0OFrOG70bSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3ODEyMg==", "bodyText": "it would be good to split this off into its own function (after verifying that we weren't trying to do both SCRAM + quota) or multiple entity names", "url": "https://github.com/apache/kafka/pull/9032#discussion_r465378122", "createdAt": "2020-08-04T23:04:48Z", "author": {"login": "cmccabe"}, "path": "core/src/main/scala/kafka/admin/ConfigCommand.scala", "diffHunk": "@@ -365,45 +368,90 @@ object ConfigCommand extends Config {\n         adminClient.incrementalAlterConfigs(Map(configResource -> alterLogLevelEntries).asJava, alterOptions).all().get(60, TimeUnit.SECONDS)\n \n       case ConfigType.User | ConfigType.Client =>\n-        val nonQuotaConfigsToAdd = configsToBeAdded.keys.filterNot(QuotaConfigs.isQuotaConfig)\n-        if (nonQuotaConfigsToAdd.nonEmpty)\n-          throw new IllegalArgumentException(s\"Only quota configs can be added for '$entityTypeHead' using --bootstrap-server. Unexpected config names: $nonQuotaConfigsToAdd\")\n-        val nonQuotaConfigsToDelete = configsToBeDeleted.filterNot(QuotaConfigs.isQuotaConfig)\n-        if (nonQuotaConfigsToDelete.nonEmpty)\n-          throw new IllegalArgumentException(s\"Only quota configs can be deleted for '$entityTypeHead' using --bootstrap-server. Unexpected config names: $nonQuotaConfigsToDelete\")\n-\n-\n-        val oldConfig = getClientQuotasConfig(adminClient, entityTypes, entityNames)\n-\n-        val invalidConfigs = configsToBeDeleted.filterNot(oldConfig.contains)\n-        if (invalidConfigs.nonEmpty)\n-          throw new InvalidConfigurationException(s\"Invalid config(s): ${invalidConfigs.mkString(\",\")}\")\n-\n-        val alterEntityTypes = entityTypes.map { entType =>\n-          entType match {\n-            case ConfigType.User => ClientQuotaEntity.USER\n-            case ConfigType.Client => ClientQuotaEntity.CLIENT_ID\n-            case _ => throw new IllegalArgumentException(s\"Unexpected entity type: ${entType}\")\n+        val hasQuotaConfigsToAdd = configsToBeAdded.keys.exists(QuotaConfigs.isQuotaConfig)\n+        val scramConfigsToAddMap = configsToBeAdded.filter(entry => ScramMechanism.isScram(entry._1))\n+        val unknownConfigsToAdd = configsToBeAdded.keys.filterNot(key => ScramMechanism.isScram(key) || QuotaConfigs.isQuotaConfig(key))\n+        val hasQuotaConfigsToDelete = configsToBeDeleted.exists(QuotaConfigs.isQuotaConfig)\n+        val scramConfigsToDelete = configsToBeDeleted.filter(ScramMechanism.isScram)\n+        val unknownConfigsToDelete = configsToBeDeleted.filterNot(key => ScramMechanism.isScram(key) || QuotaConfigs.isQuotaConfig(key))\n+        if (entityTypeHead == ConfigType.Client || entityTypes.size == 2) { // size==2 for case where users is specified first on the command line, before clients\n+          // either just a client or both a user and a client\n+          if (unknownConfigsToAdd.nonEmpty || scramConfigsToAddMap.nonEmpty)\n+            throw new IllegalArgumentException(s\"Only quota configs can be added for '${ConfigType.Client}' using --bootstrap-server. Unexpected config names: ${unknownConfigsToAdd ++ scramConfigsToAddMap.keys}\")\n+          if (unknownConfigsToDelete.nonEmpty || scramConfigsToDelete.nonEmpty)\n+            throw new IllegalArgumentException(s\"Only quota configs can be deleted for '${ConfigType.Client}' using --bootstrap-server. Unexpected config names: ${unknownConfigsToDelete ++ scramConfigsToDelete}\")\n+        } else { // ConfigType.User\n+          if (unknownConfigsToAdd.nonEmpty)\n+            throw new IllegalArgumentException(s\"Only quota and SCRAM credential configs can be added for '${ConfigType.User}' using --bootstrap-server. Unexpected config names: $unknownConfigsToAdd\")\n+          if (unknownConfigsToDelete.nonEmpty)\n+            throw new IllegalArgumentException(s\"Only quota and SCRAM credential configs can be deleted for '${ConfigType.User}' using --bootstrap-server. Unexpected config names: $unknownConfigsToDelete\")\n+          if (scramConfigsToAddMap.nonEmpty || scramConfigsToDelete.nonEmpty) {\n+            if (entityNames.exists(_.isEmpty)) // either --entity-type users --entity-default or --user-defaults\n+              throw new IllegalArgumentException(\"The use of --entity-default or --user-defaults is not allowed with User SCRAM Credentials using --bootstrap-server.\")\n+            if (hasQuotaConfigsToAdd || hasQuotaConfigsToDelete)\n+              throw new IllegalArgumentException(s\"Cannot alter both quota and SCRAM credential configs simultaneously for '${ConfigType.User}' using --bootstrap-server.\")\n           }\n         }\n-        val alterEntityNames = entityNames.map(en => if (en.nonEmpty) en else null)\n \n-        // Explicitly populate a HashMap to ensure nulls are recorded properly.\n-        val alterEntityMap = new java.util.HashMap[String, String]\n-        alterEntityTypes.zip(alterEntityNames).foreach { case (k, v) => alterEntityMap.put(k, v) }\n-        val entity = new ClientQuotaEntity(alterEntityMap)\n+        if (hasQuotaConfigsToAdd || hasQuotaConfigsToDelete) {\n+          // handle altering client/user quota configs\n+          val oldConfig = getClientQuotasConfig(adminClient, entityTypes, entityNames)\n \n-        val alterOptions = new AlterClientQuotasOptions().validateOnly(false)\n-        val alterOps = (configsToBeAddedMap.map { case (key, value) =>\n-          val doubleValue = try value.toDouble catch {\n-            case _: NumberFormatException =>\n-              throw new IllegalArgumentException(s\"Cannot parse quota configuration value for ${key}: ${value}\")\n+          val invalidConfigs = configsToBeDeleted.filterNot(oldConfig.contains)\n+          if (invalidConfigs.nonEmpty)\n+            throw new InvalidConfigurationException(s\"Invalid config(s): ${invalidConfigs.mkString(\",\")}\")\n+\n+          val alterEntityTypes = entityTypes.map { entType =>\n+            entType match {\n+              case ConfigType.User => ClientQuotaEntity.USER\n+              case ConfigType.Client => ClientQuotaEntity.CLIENT_ID\n+              case _ => throw new IllegalArgumentException(s\"Unexpected entity type: ${entType}\")\n+            }\n+          }\n+          val alterEntityNames = entityNames.map(en => if (en.nonEmpty) en else null)\n+\n+          // Explicitly populate a HashMap to ensure nulls are recorded properly.\n+          val alterEntityMap = new java.util.HashMap[String, String]\n+          alterEntityTypes.zip(alterEntityNames).foreach { case (k, v) => alterEntityMap.put(k, v) }\n+          val entity = new ClientQuotaEntity(alterEntityMap)\n+\n+          val alterOptions = new AlterClientQuotasOptions().validateOnly(false)\n+          val alterOps = (configsToBeAddedMap.map { case (key, value) =>\n+            val doubleValue = try value.toDouble catch {\n+              case _: NumberFormatException =>\n+                throw new IllegalArgumentException(s\"Cannot parse quota configuration value for ${key}: ${value}\")\n+            }\n+            new ClientQuotaAlteration.Op(key, doubleValue)\n+          } ++ configsToBeDeleted.map(key => new ClientQuotaAlteration.Op(key, null))).asJavaCollection\n+\n+          adminClient.alterClientQuotas(Collections.singleton(new ClientQuotaAlteration(entity, alterOps)), alterOptions)\n+            .all().get(60, TimeUnit.SECONDS)\n+        } else {\n+          // handle altering user SCRAM credential configs", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 134}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMjUxMzMy", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-461251332", "createdAt": "2020-08-04T23:54:12Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzo1NDoxM1rOG71Wzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzo1NDoxM1rOG71Wzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5MzM1OA==", "bodyText": "It would be good to avoid confusing empty with null.  Why not use Option[Seq[String]]", "url": "https://github.com/apache/kafka/pull/9032#discussion_r465393358", "createdAt": "2020-08-04T23:54:13Z", "author": {"login": "cmccabe"}, "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -980,4 +984,137 @@ class AdminManager(val config: KafkaConfig,\n       entry.entity -> apiError\n     }.toMap\n   }\n+\n+  def describeUserScramCredentials(users: Seq[String]): DescribeUserScramCredentialsResponseData = {\n+    val retval = new DescribeUserScramCredentialsResponseData()\n+\n+    def addToResults(user: String, userConfig: Properties) = {\n+      val configKeys = userConfig.stringPropertyNames\n+      val hasScramCredential = !ScramMechanism.values().toList.filter(key => key != ScramMechanism.UNKNOWN && configKeys.contains(key.toMechanismName)).isEmpty\n+      if (hasScramCredential) {\n+        val userScramCredentials = new UserScramCredential().setName(user)\n+        ScramMechanism.values().foreach(mechanism => if (mechanism != ScramMechanism.UNKNOWN) {\n+          val propertyValue = userConfig.getProperty(mechanism.toMechanismName)\n+          if (propertyValue != null) {\n+            val iterations = ScramCredentialUtils.credentialFromString(propertyValue).iterations\n+            userScramCredentials.credentialInfos.add(new CredentialInfo().setMechanism(mechanism.ordinal.toByte).setIterations(iterations))\n+          }\n+        })\n+        retval.userScramCredentials.add(userScramCredentials)\n+      }\n+    }\n+\n+    if (users.isEmpty)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxODQyNDAx", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-461842401", "createdAt": "2020-08-05T16:44:32Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNjo0NDozMlrOG8R-XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxOTo0NDoxMlrOG8YCKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2MjIzNg==", "bodyText": "Does this need to be controller for Describe? It looks similar to DescribeAcls where we use LeastLoadedNode.", "url": "https://github.com/apache/kafka/pull/9032#discussion_r465862236", "createdAt": "2020-08-05T16:44:32Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java", "diffHunk": "@@ -4071,6 +4081,168 @@ void handleFailure(Throwable throwable) {\n         return new AlterClientQuotasResult(Collections.unmodifiableMap(futures));\n     }\n \n+    @Override\n+    public DescribeUserScramCredentialsResult describeUserScramCredentials(List<String> users, DescribeUserScramCredentialsOptions options) {\n+        final KafkaFutureImpl<Map<String, UserScramCredentialsDescription>> future = new KafkaFutureImpl<>();\n+        final long now = time.milliseconds();\n+        Call call = new Call(\"describeUserScramCredentials\", calcDeadlineMs(now, options.timeoutMs()),\n+                new ControllerNodeProvider()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0NzU3Mg==", "bodyText": "typo: iterations", "url": "https://github.com/apache/kafka/pull/9032#discussion_r465947572", "createdAt": "2020-08-05T19:16:54Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java", "diffHunk": "@@ -4071,6 +4081,168 @@ void handleFailure(Throwable throwable) {\n         return new AlterClientQuotasResult(Collections.unmodifiableMap(futures));\n     }\n \n+    @Override\n+    public DescribeUserScramCredentialsResult describeUserScramCredentials(List<String> users, DescribeUserScramCredentialsOptions options) {\n+        final KafkaFutureImpl<Map<String, UserScramCredentialsDescription>> future = new KafkaFutureImpl<>();\n+        final long now = time.milliseconds();\n+        Call call = new Call(\"describeUserScramCredentials\", calcDeadlineMs(now, options.timeoutMs()),\n+                new ControllerNodeProvider()) {\n+            @Override\n+            public DescribeUserScramCredentialsRequest.Builder createRequest(int timeoutMs) {\n+                return new DescribeUserScramCredentialsRequest.Builder(\n+                        new DescribeUserScramCredentialsRequestData().setUsers(users.stream().map(user ->\n+                                new DescribeUserScramCredentialsRequestData.UserName().setName(user)).collect(Collectors.toList())));\n+            }\n+\n+            @Override\n+            public void handleResponse(AbstractResponse abstractResponse) {\n+                DescribeUserScramCredentialsResponse response = (DescribeUserScramCredentialsResponse) abstractResponse;\n+                Errors error = Errors.forCode(response.data().error());\n+                switch (error) {\n+                    case NONE:\n+                        DescribeUserScramCredentialsResponseData data = response.data();\n+                        future.complete(data.userScramCredentials().stream().collect(Collectors.toMap(\n+                            DescribeUserScramCredentialsResponseData.UserScramCredential::name,\n+                            userScramCredential -> {\n+                                List<ScramCredentialInfo> scramCredentialInfos = userScramCredential.credentialInfos().stream().map(\n+                                    credentialInfo -> new ScramCredentialInfo(ScramMechanism.fromType(credentialInfo.mechanism()), credentialInfo.iterations()))\n+                                        .collect(Collectors.toList());\n+                                return new UserScramCredentialsDescription(userScramCredential.name(), scramCredentialInfos);\n+                            })));\n+                        break;\n+                    case NOT_CONTROLLER:\n+                        handleNotControllerError(error);\n+                        break;\n+                    default:\n+                        future.completeExceptionally(new ApiError(error, response.data().errorMessage()).exception());\n+                        break;\n+                }\n+            }\n+\n+            @Override\n+            void handleFailure(Throwable throwable) {\n+                future.completeExceptionally(throwable);\n+            }\n+        };\n+        runnable.call(call, now);\n+        return new DescribeUserScramCredentialsResult(future);\n+    }\n+\n+    @Override\n+    public AlterUserScramCredentialsResult alterUserScramCredentials(List<UserScramCredentialAlteration> alterations,\n+                                                                     AlterUserScramCredentialsOptions options) {\n+        final long now = time.milliseconds();\n+        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>();\n+        for (UserScramCredentialAlteration alteration: alterations) {\n+            futures.put(alteration.getUser(), new KafkaFutureImpl<>());\n+        }\n+        final Map<String, Exception> userIllegalAlterationExceptions = new HashMap<>();\n+        // We need to keep track of users with deletions of an unknown SCRAM mechanism\n+        alterations.stream().filter(a -> a instanceof UserScramCredentialDeletion).forEach(alteration -> {\n+            UserScramCredentialDeletion deletion = (UserScramCredentialDeletion) alteration;\n+            ScramMechanism mechanism = deletion.getMechanism();\n+            if (mechanism == null || mechanism == ScramMechanism.UNKNOWN) {\n+                userIllegalAlterationExceptions.put(deletion.getUser(), new InvalidRequestException(\"Unknown SCRAM mechanism\"));\n+            }\n+        });\n+        // Creating an upsertion may throw InvalidKeyException or NoSuchAlgorithmException,\n+        // so keep track of which users are affected by such a failure and immediately fail all their alterations\n+        final Map<String, Map<ScramMechanism, AlterUserScramCredentialsRequestData.ScramCredentialUpsertion>> userInsertions = new HashMap<>();\n+        alterations.stream().filter(a -> a instanceof UserScramCredentialUpsertion)\n+                .filter(alteration -> !userIllegalAlterationExceptions.containsKey(alteration.getUser()))\n+                .forEach(alteration -> {\n+                    UserScramCredentialUpsertion upsertion = (UserScramCredentialUpsertion) alteration;\n+                    String user = upsertion.getUser();\n+                    try {\n+                        ScramMechanism mechanism = upsertion.getInfo().getMechanism();\n+                        if (mechanism == null || mechanism == ScramMechanism.UNKNOWN)\n+                            throw new InvalidRequestException(\"Unknown SCRAM mechanism\");\n+                        userInsertions.putIfAbsent(user, new HashMap<>());\n+                        userInsertions.get(user).put(mechanism, getScramCredentialUpsertion(upsertion));\n+                    } catch (Exception e) {\n+                        // we might overwrite an exception from a previous upsertion, but we don't really care\n+                        // since we just need to mark this user as having at least one illegal alteration\n+                        // and make an exception instance available for completing the corresponding future exceptionally\n+                        userIllegalAlterationExceptions.put(user, e);\n+                    }\n+                });\n+        // fail any users immediately that have an illegal alteration as identified above\n+        userIllegalAlterationExceptions.entrySet().stream().forEach(entry -> {\n+            futures.get(entry.getKey()).completeExceptionally(entry.getValue());\n+        });\n+\n+        // submit alterations for users that do not have an illegal upsertion as identified above\n+        Call call = new Call(\"alterUserScramCredentials\", calcDeadlineMs(now, options.timeoutMs()),\n+                new ControllerNodeProvider()) {\n+            @Override\n+            public AlterUserScramCredentialsRequest.Builder createRequest(int timeoutMs) {\n+                return new AlterUserScramCredentialsRequest.Builder(\n+                        new AlterUserScramCredentialsRequestData().setUpsertions(alterations.stream()\n+                                .filter(a -> a instanceof UserScramCredentialUpsertion)\n+                                .filter(a -> !userIllegalAlterationExceptions.containsKey(a.getUser()))\n+                                .map(a -> userInsertions.get(a.getUser()).get(((UserScramCredentialUpsertion) a).getInfo().getMechanism()))\n+                                .collect(Collectors.toList()))\n+                        .setDeletions(alterations.stream()\n+                                .filter(a -> a instanceof UserScramCredentialDeletion)\n+                                .filter(a -> !userIllegalAlterationExceptions.containsKey(a.getUser()))\n+                                .map(d ->\n+                                getScramCredentialDeletion((UserScramCredentialDeletion) d)).collect(Collectors.toList())));\n+            }\n+\n+            @Override\n+            public void handleResponse(AbstractResponse abstractResponse) {\n+                AlterUserScramCredentialsResponse response = (AlterUserScramCredentialsResponse) abstractResponse;\n+                // Check for controller change\n+                for (Errors error : response.errorCounts().keySet()) {\n+                    if (error == Errors.NOT_CONTROLLER) {\n+                        handleNotControllerError(error);\n+                    }\n+                }\n+                response.data().results().forEach(result -> {\n+                    KafkaFutureImpl<Void> future = futures.get(result.user());\n+                    if (future == null) {\n+                        log.warn(\"Server response mentioned unknown user {}\", result.user());\n+                    } else {\n+                        Errors error = Errors.forCode(result.errorCode());\n+                        if (error != Errors.NONE) {\n+                            future.completeExceptionally(error.exception());\n+                        } else {\n+                            future.complete(null);\n+                        }\n+                    }\n+                });\n+                completeUnrealizedFutures(\n+                    futures.entrySet().stream(),\n+                    user -> \"The broker response did not contain a result for user \" + user);\n+            }\n+\n+            @Override\n+            void handleFailure(Throwable throwable) {\n+                completeAllExceptionally(futures.values(), throwable);\n+            }\n+        };\n+        runnable.call(call, now);\n+        return new AlterUserScramCredentialsResult(new HashMap<>(futures));\n+    }\n+\n+    private static AlterUserScramCredentialsRequestData.ScramCredentialUpsertion getScramCredentialUpsertion(UserScramCredentialUpsertion u) throws InvalidKeyException, NoSuchAlgorithmException {\n+        AlterUserScramCredentialsRequestData.ScramCredentialUpsertion retval = new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion();\n+        return retval.setName(u.getUser())\n+                .setMechanism(u.getInfo().getMechanism().getType())\n+                .setIterations(u.getInfo().getIterations())\n+                .setSalt(u.getSalt())\n+                .setSaltedPassword(getSaltedPasword(u.getInfo().getMechanism(), u.getPassword(), u.getSalt(), u.getInfo().getIterations()));\n+    }\n+\n+    private static AlterUserScramCredentialsRequestData.ScramCredentialDeletion getScramCredentialDeletion(UserScramCredentialDeletion d) {\n+        return new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(d.getUser()).setMechanism(d.getMechanism().getType());\n+    }\n+\n+    private static byte[] getSaltedPasword(ScramMechanism publicScramMechanism, byte[] password, byte[] salt, int interations) throws NoSuchAlgorithmException, InvalidKeyException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk1MjE2Ng==", "bodyText": "What do we do if the user is not a SCRAM user? Won't this throw an exception? Can we make sure that user without quota or SCRAM credential doesn't print any errors or exceptions?", "url": "https://github.com/apache/kafka/pull/9032#discussion_r465952166", "createdAt": "2020-08-05T19:25:53Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/admin/ConfigCommand.scala", "diffHunk": "@@ -508,7 +563,15 @@ object ConfigCommand extends Config {\n \n       val entityStr = (entitySubstr(ClientQuotaEntity.USER) ++ entitySubstr(ClientQuotaEntity.CLIENT_ID)).mkString(\", \")\n       val entriesStr = entries.asScala.map(e => s\"${e._1}=${e._2}\").mkString(\", \")\n-      println(s\"Configs for ${entityStr} are ${entriesStr}\")\n+      println(s\"Quota configs for ${entityStr} are ${entriesStr}\")\n+    }\n+    // we describe user SCRAM credentials only when we are not describing client information\n+    // and we are not given either --entity-default or --user-defaults\n+    if (!entityTypes.contains(ConfigType.Client) && !entityNames.contains(\"\")) {\n+      getUserScramCredentialConfigs(adminClient, entityNames).foreach { case (user, description) =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk1NDM3MA==", "bodyText": "should we catch exception?", "url": "https://github.com/apache/kafka/pull/9032#discussion_r465954370", "createdAt": "2020-08-05T19:30:11Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -980,4 +984,137 @@ class AdminManager(val config: KafkaConfig,\n       entry.entity -> apiError\n     }.toMap\n   }\n+\n+  def describeUserScramCredentials(users: Option[Seq[String]]): DescribeUserScramCredentialsResponseData = {\n+    val retval = new DescribeUserScramCredentialsResponseData()\n+\n+    def addToResults(user: String, userConfig: Properties) = {\n+      val configKeys = userConfig.stringPropertyNames\n+      val hasScramCredential = !ScramMechanism.values().toList.filter(key => key != ScramMechanism.UNKNOWN && configKeys.contains(key.getMechanismName)).isEmpty\n+      if (hasScramCredential) {\n+        val userScramCredentials = new UserScramCredential().setName(user)\n+        ScramMechanism.values().foreach(mechanism => if (mechanism != ScramMechanism.UNKNOWN) {\n+          val propertyValue = userConfig.getProperty(mechanism.getMechanismName)\n+          if (propertyValue != null) {\n+            val iterations = ScramCredentialUtils.credentialFromString(propertyValue).iterations\n+            userScramCredentials.credentialInfos.add(new CredentialInfo().setMechanism(mechanism.getType).setIterations(iterations))\n+          }\n+        })\n+        retval.userScramCredentials.add(userScramCredentials)\n+      }\n+    }\n+\n+    if (!users.isDefined || users.get.isEmpty)\n+      // describe all users\n+      adminZkClient.fetchAllEntityConfigs(ConfigType.User).foreach { case (user, properties) => addToResults(user, properties) }\n+    else {\n+      // describe specific users\n+      // https://stackoverflow.com/questions/24729544/how-to-find-duplicates-in-a-list\n+      val duplicatedUsers = users.get.groupBy(identity).collect { case (x, Seq(_, _, _*)) => x }\n+      if (duplicatedUsers.nonEmpty) {\n+        retval.setError(Errors.INVALID_REQUEST.code())\n+        retval.setErrorMessage(s\"Cannot describe SCRAM credentials for the same user twice in a single request: ${duplicatedUsers.mkString(\"[\", \", \", \"]\")}\")\n+      } else\n+        users.get.foreach { user => addToResults(user, adminZkClient.fetchEntityConfig(ConfigType.User, Sanitizer.sanitize(user))) }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk1NTEzMg==", "bodyText": "Can't we return an exception message that says exactly why, instead of x or y", "url": "https://github.com/apache/kafka/pull/9032#discussion_r465955132", "createdAt": "2020-08-05T19:31:39Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -980,4 +984,137 @@ class AdminManager(val config: KafkaConfig,\n       entry.entity -> apiError\n     }.toMap\n   }\n+\n+  def describeUserScramCredentials(users: Option[Seq[String]]): DescribeUserScramCredentialsResponseData = {\n+    val retval = new DescribeUserScramCredentialsResponseData()\n+\n+    def addToResults(user: String, userConfig: Properties) = {\n+      val configKeys = userConfig.stringPropertyNames\n+      val hasScramCredential = !ScramMechanism.values().toList.filter(key => key != ScramMechanism.UNKNOWN && configKeys.contains(key.getMechanismName)).isEmpty\n+      if (hasScramCredential) {\n+        val userScramCredentials = new UserScramCredential().setName(user)\n+        ScramMechanism.values().foreach(mechanism => if (mechanism != ScramMechanism.UNKNOWN) {\n+          val propertyValue = userConfig.getProperty(mechanism.getMechanismName)\n+          if (propertyValue != null) {\n+            val iterations = ScramCredentialUtils.credentialFromString(propertyValue).iterations\n+            userScramCredentials.credentialInfos.add(new CredentialInfo().setMechanism(mechanism.getType).setIterations(iterations))\n+          }\n+        })\n+        retval.userScramCredentials.add(userScramCredentials)\n+      }\n+    }\n+\n+    if (!users.isDefined || users.get.isEmpty)\n+      // describe all users\n+      adminZkClient.fetchAllEntityConfigs(ConfigType.User).foreach { case (user, properties) => addToResults(user, properties) }\n+    else {\n+      // describe specific users\n+      // https://stackoverflow.com/questions/24729544/how-to-find-duplicates-in-a-list\n+      val duplicatedUsers = users.get.groupBy(identity).collect { case (x, Seq(_, _, _*)) => x }\n+      if (duplicatedUsers.nonEmpty) {\n+        retval.setError(Errors.INVALID_REQUEST.code())\n+        retval.setErrorMessage(s\"Cannot describe SCRAM credentials for the same user twice in a single request: ${duplicatedUsers.mkString(\"[\", \", \", \"]\")}\")\n+      } else\n+        users.get.foreach { user => addToResults(user, adminZkClient.fetchEntityConfig(ConfigType.User, Sanitizer.sanitize(user))) }\n+    }\n+    retval\n+  }\n+\n+  def alterUserScramCredentials(upsertions: Seq[AlterUserScramCredentialsRequestData.ScramCredentialUpsertion],\n+                                deletions: Seq[AlterUserScramCredentialsRequestData.ScramCredentialDeletion]): AlterUserScramCredentialsResponseData = {\n+\n+    def scramMechanism(mechanism: Byte): ScramMechanism = {\n+      ScramMechanism.fromType(mechanism)\n+    }\n+\n+    def mechanismName(mechanism: Byte): String = {\n+      scramMechanism(mechanism).getMechanismName\n+    }\n+\n+    val retval = new AlterUserScramCredentialsResponseData()\n+\n+    // fail any user that is invalid due to an empty user name, an unknown SCRAM mechanism, or not enough iterations\n+    val invalidUsers = (\n+      upsertions.filter(upsertion => {\n+        if (upsertion.name.isEmpty)\n+          true\n+        else {\n+          val publicScramMechanism = scramMechanism(upsertion.mechanism)\n+          publicScramMechanism == ScramMechanism.UNKNOWN ||\n+            (upsertion.iterations != -1 &&\n+              InternalScramMechanism.forMechanismName(publicScramMechanism.getMechanismName).minIterations > upsertion.iterations)\n+        }\n+      }).map(_.name) ++ deletions.filter(deletions => deletions.name.isEmpty || scramMechanism(deletions.mechanism) == ScramMechanism.UNKNOWN).map(_.name))\n+      .toSet\n+    invalidUsers.foreach(user => retval.results.add(new AlterUserScramCredentialsResult().setUser(user)\n+      .setErrorCode(Errors.INVALID_REQUEST.code).setErrorMessage(\"Unknown SCRAM mechanism or too few iterations\")))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk1NzAwMA==", "bodyText": "Do we include this kind of comment in code?", "url": "https://github.com/apache/kafka/pull/9032#discussion_r465957000", "createdAt": "2020-08-05T19:35:21Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -980,4 +984,137 @@ class AdminManager(val config: KafkaConfig,\n       entry.entity -> apiError\n     }.toMap\n   }\n+\n+  def describeUserScramCredentials(users: Option[Seq[String]]): DescribeUserScramCredentialsResponseData = {\n+    val retval = new DescribeUserScramCredentialsResponseData()\n+\n+    def addToResults(user: String, userConfig: Properties) = {\n+      val configKeys = userConfig.stringPropertyNames\n+      val hasScramCredential = !ScramMechanism.values().toList.filter(key => key != ScramMechanism.UNKNOWN && configKeys.contains(key.getMechanismName)).isEmpty\n+      if (hasScramCredential) {\n+        val userScramCredentials = new UserScramCredential().setName(user)\n+        ScramMechanism.values().foreach(mechanism => if (mechanism != ScramMechanism.UNKNOWN) {\n+          val propertyValue = userConfig.getProperty(mechanism.getMechanismName)\n+          if (propertyValue != null) {\n+            val iterations = ScramCredentialUtils.credentialFromString(propertyValue).iterations\n+            userScramCredentials.credentialInfos.add(new CredentialInfo().setMechanism(mechanism.getType).setIterations(iterations))\n+          }\n+        })\n+        retval.userScramCredentials.add(userScramCredentials)\n+      }\n+    }\n+\n+    if (!users.isDefined || users.get.isEmpty)\n+      // describe all users\n+      adminZkClient.fetchAllEntityConfigs(ConfigType.User).foreach { case (user, properties) => addToResults(user, properties) }\n+    else {\n+      // describe specific users\n+      // https://stackoverflow.com/questions/24729544/how-to-find-duplicates-in-a-list\n+      val duplicatedUsers = users.get.groupBy(identity).collect { case (x, Seq(_, _, _*)) => x }\n+      if (duplicatedUsers.nonEmpty) {\n+        retval.setError(Errors.INVALID_REQUEST.code())\n+        retval.setErrorMessage(s\"Cannot describe SCRAM credentials for the same user twice in a single request: ${duplicatedUsers.mkString(\"[\", \", \", \"]\")}\")\n+      } else\n+        users.get.foreach { user => addToResults(user, adminZkClient.fetchEntityConfig(ConfigType.User, Sanitizer.sanitize(user))) }\n+    }\n+    retval\n+  }\n+\n+  def alterUserScramCredentials(upsertions: Seq[AlterUserScramCredentialsRequestData.ScramCredentialUpsertion],\n+                                deletions: Seq[AlterUserScramCredentialsRequestData.ScramCredentialDeletion]): AlterUserScramCredentialsResponseData = {\n+\n+    def scramMechanism(mechanism: Byte): ScramMechanism = {\n+      ScramMechanism.fromType(mechanism)\n+    }\n+\n+    def mechanismName(mechanism: Byte): String = {\n+      scramMechanism(mechanism).getMechanismName\n+    }\n+\n+    val retval = new AlterUserScramCredentialsResponseData()\n+\n+    // fail any user that is invalid due to an empty user name, an unknown SCRAM mechanism, or not enough iterations\n+    val invalidUsers = (\n+      upsertions.filter(upsertion => {\n+        if (upsertion.name.isEmpty)\n+          true\n+        else {\n+          val publicScramMechanism = scramMechanism(upsertion.mechanism)\n+          publicScramMechanism == ScramMechanism.UNKNOWN ||\n+            (upsertion.iterations != -1 &&\n+              InternalScramMechanism.forMechanismName(publicScramMechanism.getMechanismName).minIterations > upsertion.iterations)\n+        }\n+      }).map(_.name) ++ deletions.filter(deletions => deletions.name.isEmpty || scramMechanism(deletions.mechanism) == ScramMechanism.UNKNOWN).map(_.name))\n+      .toSet\n+    invalidUsers.foreach(user => retval.results.add(new AlterUserScramCredentialsResult().setUser(user)\n+      .setErrorCode(Errors.INVALID_REQUEST.code).setErrorMessage(\"Unknown SCRAM mechanism or too few iterations\")))\n+\n+    val initiallyValidUserMechanismPairs = (upsertions.filter(upsertion => !invalidUsers.contains(upsertion.name)).map(upsertion => (upsertion.name, upsertion.mechanism)) ++\n+      deletions.filter(deletion => !invalidUsers.contains(deletion.name)).map(deletion => (deletion.name, deletion.mechanism)))\n+\n+    // https://stackoverflow.com/questions/24729544/how-to-find-duplicates-in-a-list", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk1OTQwNw==", "bodyText": "Shouldn't we also limit the max value for iterations?", "url": "https://github.com/apache/kafka/pull/9032#discussion_r465959407", "createdAt": "2020-08-05T19:40:15Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -980,4 +984,137 @@ class AdminManager(val config: KafkaConfig,\n       entry.entity -> apiError\n     }.toMap\n   }\n+\n+  def describeUserScramCredentials(users: Option[Seq[String]]): DescribeUserScramCredentialsResponseData = {\n+    val retval = new DescribeUserScramCredentialsResponseData()\n+\n+    def addToResults(user: String, userConfig: Properties) = {\n+      val configKeys = userConfig.stringPropertyNames\n+      val hasScramCredential = !ScramMechanism.values().toList.filter(key => key != ScramMechanism.UNKNOWN && configKeys.contains(key.getMechanismName)).isEmpty\n+      if (hasScramCredential) {\n+        val userScramCredentials = new UserScramCredential().setName(user)\n+        ScramMechanism.values().foreach(mechanism => if (mechanism != ScramMechanism.UNKNOWN) {\n+          val propertyValue = userConfig.getProperty(mechanism.getMechanismName)\n+          if (propertyValue != null) {\n+            val iterations = ScramCredentialUtils.credentialFromString(propertyValue).iterations\n+            userScramCredentials.credentialInfos.add(new CredentialInfo().setMechanism(mechanism.getType).setIterations(iterations))\n+          }\n+        })\n+        retval.userScramCredentials.add(userScramCredentials)\n+      }\n+    }\n+\n+    if (!users.isDefined || users.get.isEmpty)\n+      // describe all users\n+      adminZkClient.fetchAllEntityConfigs(ConfigType.User).foreach { case (user, properties) => addToResults(user, properties) }\n+    else {\n+      // describe specific users\n+      // https://stackoverflow.com/questions/24729544/how-to-find-duplicates-in-a-list\n+      val duplicatedUsers = users.get.groupBy(identity).collect { case (x, Seq(_, _, _*)) => x }\n+      if (duplicatedUsers.nonEmpty) {\n+        retval.setError(Errors.INVALID_REQUEST.code())\n+        retval.setErrorMessage(s\"Cannot describe SCRAM credentials for the same user twice in a single request: ${duplicatedUsers.mkString(\"[\", \", \", \"]\")}\")\n+      } else\n+        users.get.foreach { user => addToResults(user, adminZkClient.fetchEntityConfig(ConfigType.User, Sanitizer.sanitize(user))) }\n+    }\n+    retval\n+  }\n+\n+  def alterUserScramCredentials(upsertions: Seq[AlterUserScramCredentialsRequestData.ScramCredentialUpsertion],\n+                                deletions: Seq[AlterUserScramCredentialsRequestData.ScramCredentialDeletion]): AlterUserScramCredentialsResponseData = {\n+\n+    def scramMechanism(mechanism: Byte): ScramMechanism = {\n+      ScramMechanism.fromType(mechanism)\n+    }\n+\n+    def mechanismName(mechanism: Byte): String = {\n+      scramMechanism(mechanism).getMechanismName\n+    }\n+\n+    val retval = new AlterUserScramCredentialsResponseData()\n+\n+    // fail any user that is invalid due to an empty user name, an unknown SCRAM mechanism, or not enough iterations\n+    val invalidUsers = (\n+      upsertions.filter(upsertion => {\n+        if (upsertion.name.isEmpty)\n+          true\n+        else {\n+          val publicScramMechanism = scramMechanism(upsertion.mechanism)\n+          publicScramMechanism == ScramMechanism.UNKNOWN ||\n+            (upsertion.iterations != -1 &&\n+              InternalScramMechanism.forMechanismName(publicScramMechanism.getMechanismName).minIterations > upsertion.iterations)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk1OTQxNQ==", "bodyText": "Shouldn't we also limit the max value for iterations?", "url": "https://github.com/apache/kafka/pull/9032#discussion_r465959415", "createdAt": "2020-08-05T19:40:15Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -980,4 +984,137 @@ class AdminManager(val config: KafkaConfig,\n       entry.entity -> apiError\n     }.toMap\n   }\n+\n+  def describeUserScramCredentials(users: Option[Seq[String]]): DescribeUserScramCredentialsResponseData = {\n+    val retval = new DescribeUserScramCredentialsResponseData()\n+\n+    def addToResults(user: String, userConfig: Properties) = {\n+      val configKeys = userConfig.stringPropertyNames\n+      val hasScramCredential = !ScramMechanism.values().toList.filter(key => key != ScramMechanism.UNKNOWN && configKeys.contains(key.getMechanismName)).isEmpty\n+      if (hasScramCredential) {\n+        val userScramCredentials = new UserScramCredential().setName(user)\n+        ScramMechanism.values().foreach(mechanism => if (mechanism != ScramMechanism.UNKNOWN) {\n+          val propertyValue = userConfig.getProperty(mechanism.getMechanismName)\n+          if (propertyValue != null) {\n+            val iterations = ScramCredentialUtils.credentialFromString(propertyValue).iterations\n+            userScramCredentials.credentialInfos.add(new CredentialInfo().setMechanism(mechanism.getType).setIterations(iterations))\n+          }\n+        })\n+        retval.userScramCredentials.add(userScramCredentials)\n+      }\n+    }\n+\n+    if (!users.isDefined || users.get.isEmpty)\n+      // describe all users\n+      adminZkClient.fetchAllEntityConfigs(ConfigType.User).foreach { case (user, properties) => addToResults(user, properties) }\n+    else {\n+      // describe specific users\n+      // https://stackoverflow.com/questions/24729544/how-to-find-duplicates-in-a-list\n+      val duplicatedUsers = users.get.groupBy(identity).collect { case (x, Seq(_, _, _*)) => x }\n+      if (duplicatedUsers.nonEmpty) {\n+        retval.setError(Errors.INVALID_REQUEST.code())\n+        retval.setErrorMessage(s\"Cannot describe SCRAM credentials for the same user twice in a single request: ${duplicatedUsers.mkString(\"[\", \", \", \"]\")}\")\n+      } else\n+        users.get.foreach { user => addToResults(user, adminZkClient.fetchEntityConfig(ConfigType.User, Sanitizer.sanitize(user))) }\n+    }\n+    retval\n+  }\n+\n+  def alterUserScramCredentials(upsertions: Seq[AlterUserScramCredentialsRequestData.ScramCredentialUpsertion],\n+                                deletions: Seq[AlterUserScramCredentialsRequestData.ScramCredentialDeletion]): AlterUserScramCredentialsResponseData = {\n+\n+    def scramMechanism(mechanism: Byte): ScramMechanism = {\n+      ScramMechanism.fromType(mechanism)\n+    }\n+\n+    def mechanismName(mechanism: Byte): String = {\n+      scramMechanism(mechanism).getMechanismName\n+    }\n+\n+    val retval = new AlterUserScramCredentialsResponseData()\n+\n+    // fail any user that is invalid due to an empty user name, an unknown SCRAM mechanism, or not enough iterations\n+    val invalidUsers = (\n+      upsertions.filter(upsertion => {\n+        if (upsertion.name.isEmpty)\n+          true\n+        else {\n+          val publicScramMechanism = scramMechanism(upsertion.mechanism)\n+          publicScramMechanism == ScramMechanism.UNKNOWN ||\n+            (upsertion.iterations != -1 &&\n+              InternalScramMechanism.forMechanismName(publicScramMechanism.getMechanismName).minIterations > upsertion.iterations)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk2MTUxNA==", "bodyText": "I think we should also not allow users who authenticated using delegation tokens to create or update users. We don't allow these users to create new tokens, it would be odd if they could create a new user or the password of the user of the token.", "url": "https://github.com/apache/kafka/pull/9032#discussion_r465961514", "createdAt": "2020-08-05T19:44:12Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -2973,6 +2975,40 @@ class KafkaApis(val requestChannel: RequestChannel,\n     }\n   }\n \n+  def handleDescribeUserScramCredentialsRequest(request: RequestChannel.Request): Unit = {\n+    val describeUserScramCredentialsRequest = request.body[DescribeUserScramCredentialsRequest]\n+\n+    if (!controller.isActive) {\n+      sendResponseMaybeThrottle(request, requestThrottleMs =>\n+        describeUserScramCredentialsRequest.getErrorResponse(requestThrottleMs, Errors.NOT_CONTROLLER.exception))\n+    } else if (authorize(request.context, DESCRIBE, CLUSTER, CLUSTER_NAME)) {\n+      val result = adminManager.describeUserScramCredentials(\n+        Option(describeUserScramCredentialsRequest.data.users.asScala.map(_.name).toList))\n+      sendResponseMaybeThrottle(request, requestThrottleMs =>\n+        new DescribeUserScramCredentialsResponse(result.setThrottleTimeMs(requestThrottleMs)))\n+    } else {\n+      sendResponseMaybeThrottle(request, requestThrottleMs =>\n+        describeUserScramCredentialsRequest.getErrorResponse(requestThrottleMs, Errors.CLUSTER_AUTHORIZATION_FAILED.exception))\n+    }\n+  }\n+\n+  def handleAlterUserScramCredentialsRequest(request: RequestChannel.Request): Unit = {\n+    val alterUserScramCredentialsRequest = request.body[AlterUserScramCredentialsRequest]\n+\n+    if (!controller.isActive) {\n+      sendResponseMaybeThrottle(request, requestThrottleMs =>\n+        alterUserScramCredentialsRequest.getErrorResponse(requestThrottleMs, Errors.NOT_CONTROLLER.exception))\n+    } else if (authorize(request.context, ALTER, CLUSTER, CLUSTER_NAME)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MTM1Mjc3", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-464135277", "createdAt": "2020-08-10T11:04:58Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxMTowNDo1OFrOG-KHJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNjoyOToyM1rOG-WSYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgzMDU2Ng==", "bodyText": "Should we throw an exception for users which don't exist to be consistent with other APIs?", "url": "https://github.com/apache/kafka/pull/9032#discussion_r467830566", "createdAt": "2020-08-10T11:04:58Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/Admin.java", "diffHunk": "@@ -1214,6 +1215,64 @@ default AlterClientQuotasResult alterClientQuotas(Collection<ClientQuotaAlterati\n      */\n     AlterClientQuotasResult alterClientQuotas(Collection<ClientQuotaAlteration> entries, AlterClientQuotasOptions options);\n \n+    /**\n+     * <p>Describe all SASL/SCRAM credentials.\n+     *\n+     * <p>This is a convenience method for {@link #describeUserScramCredentials(List, DescribeUserScramCredentialsOptions)}\n+     *\n+     * @return The DescribeUserScramCredentialsResult.\n+     */\n+    default DescribeUserScramCredentialsResult describeUserScramCredentials() {\n+        return describeUserScramCredentials(null, new DescribeUserScramCredentialsOptions());\n+    }\n+\n+    /**\n+     * <p>Describe SASL/SCRAM credentials for the given users.\n+     *\n+     * <p>This is a convenience method for {@link #describeUserScramCredentials(List, DescribeUserScramCredentialsOptions)}\n+     *\n+     * @param users the users for which credentials are to be described; all users' credentials are described if null\n+     *              or empty.  A user explicitly specified here that does not have a SCRAM credential will not appear\n+     *              in the results.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg0ODc4MQ==", "bodyText": "We don't use get prefix elsewhere, just mechanismName()?", "url": "https://github.com/apache/kafka/pull/9032#discussion_r467848781", "createdAt": "2020-08-10T11:45:29Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/ScramMechanism.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.clients.admin;\n+\n+/**\n+ * Representation of a SASL/SCRAM Mechanism.\n+ *\n+ * @see <a href=\"https://cwiki.apache.org/confluence/display/KAFKA/KIP-554%3A+Add+Broker-side+SCRAM+Config+API\">KIP-554: Add Broker-side SCRAM Config API</a>\n+ */\n+public enum ScramMechanism {\n+    UNKNOWN((byte) 0),\n+    SCRAM_SHA_256((byte) 1),\n+    SCRAM_SHA_512((byte) 2);\n+\n+    /**\n+     *\n+     * @param type the type indicator\n+     * @return the instance corresponding to the given type indicator, otherwise {@link #UNKNOWN}\n+     */\n+    public static ScramMechanism fromType(byte type) {\n+        for (ScramMechanism scramMechanism : ScramMechanism.values()) {\n+            if (scramMechanism.type == type) {\n+                return scramMechanism;\n+            }\n+        }\n+        return UNKNOWN;\n+    }\n+\n+    /**\n+     *\n+     * @param mechanismName the SASL SCRAM mechanism name\n+     * @return the corresponding SASL SCRAM mechanism enum, otherwise {@link #UNKNOWN}\n+     * @see <a href=\"https://tools.ietf.org/html/rfc5802#section-4>\n+     *     Salted Challenge Response Authentication Mechanism (SCRAM) SASL and GSS-API Mechanisms, Section 4</a>\n+     */\n+    public static ScramMechanism fromMechanismName(String mechanismName) {\n+        ScramMechanism retvalFoundMechanism = ScramMechanism.valueOf(mechanismName.replace('-', '_'));\n+        return retvalFoundMechanism != null ? retvalFoundMechanism : UNKNOWN;\n+    }\n+\n+    /**\n+     *\n+     * @return the corresponding SASL SCRAM mechanism name\n+     * @see <a href=\"https://tools.ietf.org/html/rfc5802#section-4>\n+     *     Salted Challenge Response Authentication Mechanism (SCRAM) SASL and GSS-API Mechanisms, Section 4</a>\n+     */\n+    public String getMechanismName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg0ODkzOA==", "bodyText": "As before, type()?", "url": "https://github.com/apache/kafka/pull/9032#discussion_r467848938", "createdAt": "2020-08-10T11:45:54Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/ScramMechanism.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.clients.admin;\n+\n+/**\n+ * Representation of a SASL/SCRAM Mechanism.\n+ *\n+ * @see <a href=\"https://cwiki.apache.org/confluence/display/KAFKA/KIP-554%3A+Add+Broker-side+SCRAM+Config+API\">KIP-554: Add Broker-side SCRAM Config API</a>\n+ */\n+public enum ScramMechanism {\n+    UNKNOWN((byte) 0),\n+    SCRAM_SHA_256((byte) 1),\n+    SCRAM_SHA_512((byte) 2);\n+\n+    /**\n+     *\n+     * @param type the type indicator\n+     * @return the instance corresponding to the given type indicator, otherwise {@link #UNKNOWN}\n+     */\n+    public static ScramMechanism fromType(byte type) {\n+        for (ScramMechanism scramMechanism : ScramMechanism.values()) {\n+            if (scramMechanism.type == type) {\n+                return scramMechanism;\n+            }\n+        }\n+        return UNKNOWN;\n+    }\n+\n+    /**\n+     *\n+     * @param mechanismName the SASL SCRAM mechanism name\n+     * @return the corresponding SASL SCRAM mechanism enum, otherwise {@link #UNKNOWN}\n+     * @see <a href=\"https://tools.ietf.org/html/rfc5802#section-4>\n+     *     Salted Challenge Response Authentication Mechanism (SCRAM) SASL and GSS-API Mechanisms, Section 4</a>\n+     */\n+    public static ScramMechanism fromMechanismName(String mechanismName) {\n+        ScramMechanism retvalFoundMechanism = ScramMechanism.valueOf(mechanismName.replace('-', '_'));\n+        return retvalFoundMechanism != null ? retvalFoundMechanism : UNKNOWN;\n+    }\n+\n+    /**\n+     *\n+     * @return the corresponding SASL SCRAM mechanism name\n+     * @see <a href=\"https://tools.ietf.org/html/rfc5802#section-4>\n+     *     Salted Challenge Response Authentication Mechanism (SCRAM) SASL and GSS-API Mechanisms, Section 4</a>\n+     */\n+    public String getMechanismName() {\n+        return this.mechanismName;\n+    }\n+\n+    /**\n+     *\n+     * @return the type indicator for this SASL SCRAM mechanism\n+     */\n+    public byte getType() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg1MDExNw==", "bodyText": "Remove get prefix", "url": "https://github.com/apache/kafka/pull/9032#discussion_r467850117", "createdAt": "2020-08-10T11:48:36Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/UserScramCredentialsDescription.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.clients.admin;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Representation of all SASL/SCRAM credentials associated with a user that can be retrieved.\n+ *\n+ * @see <a href=\"https://cwiki.apache.org/confluence/display/KAFKA/KIP-554%3A+Add+Broker-side+SCRAM+Config+API\">KIP-554: Add Broker-side SCRAM Config API</a>\n+ */\n+public class UserScramCredentialsDescription {\n+    private final String name;\n+    private final List<ScramCredentialInfo> infos;\n+\n+    /**\n+     *\n+     * @param name the required user name\n+     * @param infos the required SASL/SCRAM credential representations for the user\n+     */\n+    public UserScramCredentialsDescription(String name, List<ScramCredentialInfo> infos) {\n+        this.name = Objects.requireNonNull(name);\n+        this.infos = Collections.unmodifiableList(new ArrayList<>(Objects.requireNonNull(infos)));\n+    }\n+\n+    /**\n+     *\n+     * @return the user name\n+     */\n+    public String getName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg1MDM2Nw==", "bodyText": "credentialInfos()?", "url": "https://github.com/apache/kafka/pull/9032#discussion_r467850367", "createdAt": "2020-08-10T11:49:11Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/UserScramCredentialsDescription.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.clients.admin;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Representation of all SASL/SCRAM credentials associated with a user that can be retrieved.\n+ *\n+ * @see <a href=\"https://cwiki.apache.org/confluence/display/KAFKA/KIP-554%3A+Add+Broker-side+SCRAM+Config+API\">KIP-554: Add Broker-side SCRAM Config API</a>\n+ */\n+public class UserScramCredentialsDescription {\n+    private final String name;\n+    private final List<ScramCredentialInfo> infos;\n+\n+    /**\n+     *\n+     * @param name the required user name\n+     * @param infos the required SASL/SCRAM credential representations for the user\n+     */\n+    public UserScramCredentialsDescription(String name, List<ScramCredentialInfo> infos) {\n+        this.name = Objects.requireNonNull(name);\n+        this.infos = Collections.unmodifiableList(new ArrayList<>(Objects.requireNonNull(infos)));\n+    }\n+\n+    /**\n+     *\n+     * @return the user name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the unmodifiable list of SASL/SCRAM credential representations for the user\n+     */\n+    public List<ScramCredentialInfo> getInfos() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk4NDUyMA==", "bodyText": "Do we test for empty password?", "url": "https://github.com/apache/kafka/pull/9032#discussion_r467984520", "createdAt": "2020-08-10T15:27:44Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/server/AlterUserScramCredentialsRequestTest.scala", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+\n+import java.nio.charset.StandardCharsets\n+import java.util\n+import java.util.Properties\n+\n+import kafka.network.SocketServer\n+import kafka.security.authorizer.AclAuthorizer\n+import org.apache.kafka.clients.admin.ScramMechanism\n+import org.apache.kafka.common.acl.AclOperation\n+import org.apache.kafka.common.message.{AlterUserScramCredentialsRequestData, DescribeUserScramCredentialsRequestData}\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.requests.{AlterUserScramCredentialsRequest, AlterUserScramCredentialsResponse, DescribeUserScramCredentialsRequest, DescribeUserScramCredentialsResponse}\n+import org.apache.kafka.common.resource.ResourceType\n+import org.apache.kafka.common.security.auth.{AuthenticationContext, KafkaPrincipal, KafkaPrincipalBuilder}\n+import org.apache.kafka.server.authorizer.{Action, AuthorizableRequestContext, AuthorizationResult}\n+import org.junit.Assert._\n+import org.junit.{Before, Test}\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Test AlterUserScramCredentialsRequest/Response API for the cases where either no credentials are altered\n+ * or failure is expected due to lack of authorization, sending the request to a non-controller broker, or some other issue.\n+ * Also tests the Alter and Describe APIs for the case where credentials are successfully altered/described.\n+ */\n+class AlterUserScramCredentialsRequestTest extends BaseRequestTest {\n+  override def brokerPropertyOverrides(properties: Properties): Unit = {\n+    properties.put(KafkaConfig.ControlledShutdownEnableProp, \"false\")\n+    properties.put(KafkaConfig.AuthorizerClassNameProp, classOf[AlterCredentialsTest.TestAuthorizer].getName)\n+    properties.put(KafkaConfig.PrincipalBuilderClassProp, classOf[AlterCredentialsTest.TestPrincipalBuilder].getName)\n+  }\n+\n+  @Before\n+  override def setUp(): Unit = {\n+    AlterCredentialsTest.principal = KafkaPrincipal.ANONYMOUS // default is to be authorized\n+    super.setUp()\n+  }\n+\n+  @Test\n+  def testAlterNothing(): Unit = {\n+    val request = new AlterUserScramCredentialsRequest.Builder(\n+      new AlterUserScramCredentialsRequestData()\n+        .setDeletions(new util.ArrayList[AlterUserScramCredentialsRequestData.ScramCredentialDeletion])\n+        .setUpsertions(new util.ArrayList[AlterUserScramCredentialsRequestData.ScramCredentialUpsertion])).build()\n+    val response = sendAlterUserScramCredentialsRequest(request)\n+\n+    val results = response.data.results\n+    assertEquals(0, results.size)\n+  }\n+\n+  @Test\n+  def testAlterNothingNotAuthorized(): Unit = {\n+    AlterCredentialsTest.principal = AlterCredentialsTest.UnauthorizedPrincipal\n+\n+    val request = new AlterUserScramCredentialsRequest.Builder(\n+      new AlterUserScramCredentialsRequestData()\n+        .setDeletions(new util.ArrayList[AlterUserScramCredentialsRequestData.ScramCredentialDeletion])\n+        .setUpsertions(new util.ArrayList[AlterUserScramCredentialsRequestData.ScramCredentialUpsertion])).build()\n+    val response = sendAlterUserScramCredentialsRequest(request)\n+\n+    val results = response.data.results\n+    assertEquals(0, results.size)\n+  }\n+\n+  @Test\n+  def testAlterSomethingNotAuthorized(): Unit = {\n+    AlterCredentialsTest.principal = AlterCredentialsTest.UnauthorizedPrincipal\n+\n+    val request = new AlterUserScramCredentialsRequest.Builder(\n+      new AlterUserScramCredentialsRequestData()\n+        .setDeletions(util.Arrays.asList(new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(\"name1\").setMechanism(ScramMechanism.SCRAM_SHA_256.getType)))\n+        .setUpsertions(util.Arrays.asList(new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(\"name2\").setMechanism(ScramMechanism.SCRAM_SHA_512.getType)))).build()\n+    val response = sendAlterUserScramCredentialsRequest(request)\n+\n+    val results = response.data.results\n+    assertEquals(2, results.size)\n+    assertTrue(\"Expected not authorized\",\n+      results.get(0).errorCode == Errors.CLUSTER_AUTHORIZATION_FAILED.code && results.get(1).errorCode == Errors.CLUSTER_AUTHORIZATION_FAILED.code)\n+  }\n+\n+  @Test\n+  def testAlterSameThingTwice(): Unit = {\n+    val deletion1 = new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(\"name1\").setMechanism(ScramMechanism.SCRAM_SHA_256.getType)\n+    val deletion2 = new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(\"name2\").setMechanism(ScramMechanism.SCRAM_SHA_256.getType)\n+    val upsertion1 = new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(\"name1\").setMechanism(ScramMechanism.SCRAM_SHA_256.getType)\n+      .setIterations(-1).setSalt(\"salt\".getBytes).setSaltedPassword(\"saltedPassword\".getBytes)\n+    val upsertion2 = new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(\"name2\").setMechanism(ScramMechanism.SCRAM_SHA_256.getType)\n+      .setIterations(-1).setSalt(\"salt\".getBytes).setSaltedPassword(\"saltedPassword\".getBytes)\n+    val requests = List (\n+      new AlterUserScramCredentialsRequest.Builder(\n+        new AlterUserScramCredentialsRequestData()\n+          .setDeletions(util.Arrays.asList(deletion1, deletion1))\n+          .setUpsertions(util.Arrays.asList(upsertion2, upsertion2))).build(),\n+      new AlterUserScramCredentialsRequest.Builder(\n+        new AlterUserScramCredentialsRequestData()\n+          .setDeletions(util.Arrays.asList(deletion1, deletion2))\n+          .setUpsertions(util.Arrays.asList(upsertion1, upsertion2))).build(),\n+    )\n+    requests.foreach(request => {\n+      val response = sendAlterUserScramCredentialsRequest(request)\n+      val results = response.data.results\n+      assertEquals(2, results.size)\n+      assertTrue(\"Expected error when altering the same credential twice in a single request\",\n+        results.get(0).errorCode == Errors.INVALID_REQUEST.code && results.get(1).errorCode == Errors.INVALID_REQUEST.code)\n+    })\n+  }\n+\n+  @Test\n+  def testAlterEmptyUser(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk4NDg1Mg==", "bodyText": "assertEquals so we know what the error was if test fails? (mutliple places)", "url": "https://github.com/apache/kafka/pull/9032#discussion_r467984852", "createdAt": "2020-08-10T15:28:16Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/server/AlterUserScramCredentialsRequestTest.scala", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+\n+import java.nio.charset.StandardCharsets\n+import java.util\n+import java.util.Properties\n+\n+import kafka.network.SocketServer\n+import kafka.security.authorizer.AclAuthorizer\n+import org.apache.kafka.clients.admin.ScramMechanism\n+import org.apache.kafka.common.acl.AclOperation\n+import org.apache.kafka.common.message.{AlterUserScramCredentialsRequestData, DescribeUserScramCredentialsRequestData}\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.requests.{AlterUserScramCredentialsRequest, AlterUserScramCredentialsResponse, DescribeUserScramCredentialsRequest, DescribeUserScramCredentialsResponse}\n+import org.apache.kafka.common.resource.ResourceType\n+import org.apache.kafka.common.security.auth.{AuthenticationContext, KafkaPrincipal, KafkaPrincipalBuilder}\n+import org.apache.kafka.server.authorizer.{Action, AuthorizableRequestContext, AuthorizationResult}\n+import org.junit.Assert._\n+import org.junit.{Before, Test}\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Test AlterUserScramCredentialsRequest/Response API for the cases where either no credentials are altered\n+ * or failure is expected due to lack of authorization, sending the request to a non-controller broker, or some other issue.\n+ * Also tests the Alter and Describe APIs for the case where credentials are successfully altered/described.\n+ */\n+class AlterUserScramCredentialsRequestTest extends BaseRequestTest {\n+  override def brokerPropertyOverrides(properties: Properties): Unit = {\n+    properties.put(KafkaConfig.ControlledShutdownEnableProp, \"false\")\n+    properties.put(KafkaConfig.AuthorizerClassNameProp, classOf[AlterCredentialsTest.TestAuthorizer].getName)\n+    properties.put(KafkaConfig.PrincipalBuilderClassProp, classOf[AlterCredentialsTest.TestPrincipalBuilder].getName)\n+  }\n+\n+  @Before\n+  override def setUp(): Unit = {\n+    AlterCredentialsTest.principal = KafkaPrincipal.ANONYMOUS // default is to be authorized\n+    super.setUp()\n+  }\n+\n+  @Test\n+  def testAlterNothing(): Unit = {\n+    val request = new AlterUserScramCredentialsRequest.Builder(\n+      new AlterUserScramCredentialsRequestData()\n+        .setDeletions(new util.ArrayList[AlterUserScramCredentialsRequestData.ScramCredentialDeletion])\n+        .setUpsertions(new util.ArrayList[AlterUserScramCredentialsRequestData.ScramCredentialUpsertion])).build()\n+    val response = sendAlterUserScramCredentialsRequest(request)\n+\n+    val results = response.data.results\n+    assertEquals(0, results.size)\n+  }\n+\n+  @Test\n+  def testAlterNothingNotAuthorized(): Unit = {\n+    AlterCredentialsTest.principal = AlterCredentialsTest.UnauthorizedPrincipal\n+\n+    val request = new AlterUserScramCredentialsRequest.Builder(\n+      new AlterUserScramCredentialsRequestData()\n+        .setDeletions(new util.ArrayList[AlterUserScramCredentialsRequestData.ScramCredentialDeletion])\n+        .setUpsertions(new util.ArrayList[AlterUserScramCredentialsRequestData.ScramCredentialUpsertion])).build()\n+    val response = sendAlterUserScramCredentialsRequest(request)\n+\n+    val results = response.data.results\n+    assertEquals(0, results.size)\n+  }\n+\n+  @Test\n+  def testAlterSomethingNotAuthorized(): Unit = {\n+    AlterCredentialsTest.principal = AlterCredentialsTest.UnauthorizedPrincipal\n+\n+    val request = new AlterUserScramCredentialsRequest.Builder(\n+      new AlterUserScramCredentialsRequestData()\n+        .setDeletions(util.Arrays.asList(new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(\"name1\").setMechanism(ScramMechanism.SCRAM_SHA_256.getType)))\n+        .setUpsertions(util.Arrays.asList(new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(\"name2\").setMechanism(ScramMechanism.SCRAM_SHA_512.getType)))).build()\n+    val response = sendAlterUserScramCredentialsRequest(request)\n+\n+    val results = response.data.results\n+    assertEquals(2, results.size)\n+    assertTrue(\"Expected not authorized\",\n+      results.get(0).errorCode == Errors.CLUSTER_AUTHORIZATION_FAILED.code && results.get(1).errorCode == Errors.CLUSTER_AUTHORIZATION_FAILED.code)\n+  }\n+\n+  @Test\n+  def testAlterSameThingTwice(): Unit = {\n+    val deletion1 = new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(\"name1\").setMechanism(ScramMechanism.SCRAM_SHA_256.getType)\n+    val deletion2 = new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(\"name2\").setMechanism(ScramMechanism.SCRAM_SHA_256.getType)\n+    val upsertion1 = new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(\"name1\").setMechanism(ScramMechanism.SCRAM_SHA_256.getType)\n+      .setIterations(-1).setSalt(\"salt\".getBytes).setSaltedPassword(\"saltedPassword\".getBytes)\n+    val upsertion2 = new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(\"name2\").setMechanism(ScramMechanism.SCRAM_SHA_256.getType)\n+      .setIterations(-1).setSalt(\"salt\".getBytes).setSaltedPassword(\"saltedPassword\".getBytes)\n+    val requests = List (\n+      new AlterUserScramCredentialsRequest.Builder(\n+        new AlterUserScramCredentialsRequestData()\n+          .setDeletions(util.Arrays.asList(deletion1, deletion1))\n+          .setUpsertions(util.Arrays.asList(upsertion2, upsertion2))).build(),\n+      new AlterUserScramCredentialsRequest.Builder(\n+        new AlterUserScramCredentialsRequestData()\n+          .setDeletions(util.Arrays.asList(deletion1, deletion2))\n+          .setUpsertions(util.Arrays.asList(upsertion1, upsertion2))).build(),\n+    )\n+    requests.foreach(request => {\n+      val response = sendAlterUserScramCredentialsRequest(request)\n+      val results = response.data.results\n+      assertEquals(2, results.size)\n+      assertTrue(\"Expected error when altering the same credential twice in a single request\",\n+        results.get(0).errorCode == Errors.INVALID_REQUEST.code && results.get(1).errorCode == Errors.INVALID_REQUEST.code)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAxMDMwNw==", "bodyText": "or -1?", "url": "https://github.com/apache/kafka/pull/9032#discussion_r468010307", "createdAt": "2020-08-10T15:56:54Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/ScramCredentialInfo.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.clients.admin;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Mechanism and iterations for a SASL/SCRAM credential associated with a user.\n+ *\n+ * @see <a href=\"https://cwiki.apache.org/confluence/display/KAFKA/KIP-554%3A+Add+Broker-side+SCRAM+Config+API\">KIP-554: Add Broker-side SCRAM Config API</a>\n+ */\n+public class ScramCredentialInfo {\n+    private final ScramMechanism mechanism;\n+    private final int iterations;\n+\n+    /**\n+     *\n+     * @param mechanism the required mechanism\n+     * @param iterations the number of iterations used when creating the credential\n+     */\n+    public ScramCredentialInfo(ScramMechanism mechanism, int iterations) {\n+        this.mechanism = Objects.requireNonNull(mechanism);\n+        this.iterations = iterations;\n+    }\n+\n+    /**\n+     *\n+     * @return the mechanism\n+     */\n+    public ScramMechanism getMechanism() {\n+        return mechanism;\n+    }\n+\n+    /**\n+     *\n+     * @return the number of iterations used when creating the credential", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAzMDA0OQ==", "bodyText": "Iterations can be -1 here? Won't we end up sending a password without applying the salt properly?", "url": "https://github.com/apache/kafka/pull/9032#discussion_r468030049", "createdAt": "2020-08-10T16:29:23Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java", "diffHunk": "@@ -4071,6 +4081,168 @@ void handleFailure(Throwable throwable) {\n         return new AlterClientQuotasResult(Collections.unmodifiableMap(futures));\n     }\n \n+    @Override\n+    public DescribeUserScramCredentialsResult describeUserScramCredentials(List<String> users, DescribeUserScramCredentialsOptions options) {\n+        final KafkaFutureImpl<Map<String, UserScramCredentialsDescription>> future = new KafkaFutureImpl<>();\n+        final long now = time.milliseconds();\n+        Call call = new Call(\"describeUserScramCredentials\", calcDeadlineMs(now, options.timeoutMs()),\n+                new ControllerNodeProvider()) {\n+            @Override\n+            public DescribeUserScramCredentialsRequest.Builder createRequest(int timeoutMs) {\n+                return new DescribeUserScramCredentialsRequest.Builder(\n+                        new DescribeUserScramCredentialsRequestData().setUsers(users.stream().map(user ->\n+                                new DescribeUserScramCredentialsRequestData.UserName().setName(user)).collect(Collectors.toList())));\n+            }\n+\n+            @Override\n+            public void handleResponse(AbstractResponse abstractResponse) {\n+                DescribeUserScramCredentialsResponse response = (DescribeUserScramCredentialsResponse) abstractResponse;\n+                Errors error = Errors.forCode(response.data().error());\n+                switch (error) {\n+                    case NONE:\n+                        DescribeUserScramCredentialsResponseData data = response.data();\n+                        future.complete(data.userScramCredentials().stream().collect(Collectors.toMap(\n+                            DescribeUserScramCredentialsResponseData.UserScramCredential::name,\n+                            userScramCredential -> {\n+                                List<ScramCredentialInfo> scramCredentialInfos = userScramCredential.credentialInfos().stream().map(\n+                                    credentialInfo -> new ScramCredentialInfo(ScramMechanism.fromType(credentialInfo.mechanism()), credentialInfo.iterations()))\n+                                        .collect(Collectors.toList());\n+                                return new UserScramCredentialsDescription(userScramCredential.name(), scramCredentialInfos);\n+                            })));\n+                        break;\n+                    case NOT_CONTROLLER:\n+                        handleNotControllerError(error);\n+                        break;\n+                    default:\n+                        future.completeExceptionally(new ApiError(error, response.data().errorMessage()).exception());\n+                        break;\n+                }\n+            }\n+\n+            @Override\n+            void handleFailure(Throwable throwable) {\n+                future.completeExceptionally(throwable);\n+            }\n+        };\n+        runnable.call(call, now);\n+        return new DescribeUserScramCredentialsResult(future);\n+    }\n+\n+    @Override\n+    public AlterUserScramCredentialsResult alterUserScramCredentials(List<UserScramCredentialAlteration> alterations,\n+                                                                     AlterUserScramCredentialsOptions options) {\n+        final long now = time.milliseconds();\n+        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>();\n+        for (UserScramCredentialAlteration alteration: alterations) {\n+            futures.put(alteration.getUser(), new KafkaFutureImpl<>());\n+        }\n+        final Map<String, Exception> userIllegalAlterationExceptions = new HashMap<>();\n+        // We need to keep track of users with deletions of an unknown SCRAM mechanism\n+        alterations.stream().filter(a -> a instanceof UserScramCredentialDeletion).forEach(alteration -> {\n+            UserScramCredentialDeletion deletion = (UserScramCredentialDeletion) alteration;\n+            ScramMechanism mechanism = deletion.getMechanism();\n+            if (mechanism == null || mechanism == ScramMechanism.UNKNOWN) {\n+                userIllegalAlterationExceptions.put(deletion.getUser(), new InvalidRequestException(\"Unknown SCRAM mechanism\"));\n+            }\n+        });\n+        // Creating an upsertion may throw InvalidKeyException or NoSuchAlgorithmException,\n+        // so keep track of which users are affected by such a failure and immediately fail all their alterations\n+        final Map<String, Map<ScramMechanism, AlterUserScramCredentialsRequestData.ScramCredentialUpsertion>> userInsertions = new HashMap<>();\n+        alterations.stream().filter(a -> a instanceof UserScramCredentialUpsertion)\n+                .filter(alteration -> !userIllegalAlterationExceptions.containsKey(alteration.getUser()))\n+                .forEach(alteration -> {\n+                    UserScramCredentialUpsertion upsertion = (UserScramCredentialUpsertion) alteration;\n+                    String user = upsertion.getUser();\n+                    try {\n+                        ScramMechanism mechanism = upsertion.getInfo().getMechanism();\n+                        if (mechanism == null || mechanism == ScramMechanism.UNKNOWN)\n+                            throw new InvalidRequestException(\"Unknown SCRAM mechanism\");\n+                        userInsertions.putIfAbsent(user, new HashMap<>());\n+                        userInsertions.get(user).put(mechanism, getScramCredentialUpsertion(upsertion));\n+                    } catch (Exception e) {\n+                        // we might overwrite an exception from a previous upsertion, but we don't really care\n+                        // since we just need to mark this user as having at least one illegal alteration\n+                        // and make an exception instance available for completing the corresponding future exceptionally\n+                        userIllegalAlterationExceptions.put(user, e);\n+                    }\n+                });\n+        // fail any users immediately that have an illegal alteration as identified above\n+        userIllegalAlterationExceptions.entrySet().stream().forEach(entry -> {\n+            futures.get(entry.getKey()).completeExceptionally(entry.getValue());\n+        });\n+\n+        // submit alterations for users that do not have an illegal upsertion as identified above\n+        Call call = new Call(\"alterUserScramCredentials\", calcDeadlineMs(now, options.timeoutMs()),\n+                new ControllerNodeProvider()) {\n+            @Override\n+            public AlterUserScramCredentialsRequest.Builder createRequest(int timeoutMs) {\n+                return new AlterUserScramCredentialsRequest.Builder(\n+                        new AlterUserScramCredentialsRequestData().setUpsertions(alterations.stream()\n+                                .filter(a -> a instanceof UserScramCredentialUpsertion)\n+                                .filter(a -> !userIllegalAlterationExceptions.containsKey(a.getUser()))\n+                                .map(a -> userInsertions.get(a.getUser()).get(((UserScramCredentialUpsertion) a).getInfo().getMechanism()))\n+                                .collect(Collectors.toList()))\n+                        .setDeletions(alterations.stream()\n+                                .filter(a -> a instanceof UserScramCredentialDeletion)\n+                                .filter(a -> !userIllegalAlterationExceptions.containsKey(a.getUser()))\n+                                .map(d ->\n+                                getScramCredentialDeletion((UserScramCredentialDeletion) d)).collect(Collectors.toList())));\n+            }\n+\n+            @Override\n+            public void handleResponse(AbstractResponse abstractResponse) {\n+                AlterUserScramCredentialsResponse response = (AlterUserScramCredentialsResponse) abstractResponse;\n+                // Check for controller change\n+                for (Errors error : response.errorCounts().keySet()) {\n+                    if (error == Errors.NOT_CONTROLLER) {\n+                        handleNotControllerError(error);\n+                    }\n+                }\n+                response.data().results().forEach(result -> {\n+                    KafkaFutureImpl<Void> future = futures.get(result.user());\n+                    if (future == null) {\n+                        log.warn(\"Server response mentioned unknown user {}\", result.user());\n+                    } else {\n+                        Errors error = Errors.forCode(result.errorCode());\n+                        if (error != Errors.NONE) {\n+                            future.completeExceptionally(error.exception(result.errorMessage()));\n+                        } else {\n+                            future.complete(null);\n+                        }\n+                    }\n+                });\n+                completeUnrealizedFutures(\n+                    futures.entrySet().stream(),\n+                    user -> \"The broker response did not contain a result for user \" + user);\n+            }\n+\n+            @Override\n+            void handleFailure(Throwable throwable) {\n+                completeAllExceptionally(futures.values(), throwable);\n+            }\n+        };\n+        runnable.call(call, now);\n+        return new AlterUserScramCredentialsResult(new HashMap<>(futures));\n+    }\n+\n+    private static AlterUserScramCredentialsRequestData.ScramCredentialUpsertion getScramCredentialUpsertion(UserScramCredentialUpsertion u) throws InvalidKeyException, NoSuchAlgorithmException {\n+        AlterUserScramCredentialsRequestData.ScramCredentialUpsertion retval = new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion();\n+        return retval.setName(u.getUser())\n+                .setMechanism(u.getInfo().getMechanism().getType())\n+                .setIterations(u.getInfo().getIterations())\n+                .setSalt(u.getSalt())\n+                .setSaltedPassword(getSaltedPasword(u.getInfo().getMechanism(), u.getPassword(), u.getSalt(), u.getInfo().getIterations()));\n+    }\n+\n+    private static AlterUserScramCredentialsRequestData.ScramCredentialDeletion getScramCredentialDeletion(UserScramCredentialDeletion d) {\n+        return new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(d.getUser()).setMechanism(d.getMechanism().getType());\n+    }\n+\n+    private static byte[] getSaltedPasword(ScramMechanism publicScramMechanism, byte[] password, byte[] salt, int iterations) throws NoSuchAlgorithmException, InvalidKeyException {\n+        return new ScramFormatter(org.apache.kafka.common.security.scram.internals.ScramMechanism.forMechanismName(publicScramMechanism.getMechanismName()))\n+                .hi(password, salt, iterations);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 215}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NTM4NDkx", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-464538491", "createdAt": "2020-08-10T20:01:58Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMDowMTo1OFrOG-dj9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMjozNzowN1rOG-iHZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE0OTIzNg==", "bodyText": "Hmm, good question.  The KIP doesn't state what do do here.  @cmccabe thoughts?", "url": "https://github.com/apache/kafka/pull/9032#discussion_r468149236", "createdAt": "2020-08-10T20:01:58Z", "author": {"login": "rondagostino"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/Admin.java", "diffHunk": "@@ -1214,6 +1215,64 @@ default AlterClientQuotasResult alterClientQuotas(Collection<ClientQuotaAlterati\n      */\n     AlterClientQuotasResult alterClientQuotas(Collection<ClientQuotaAlteration> entries, AlterClientQuotasOptions options);\n \n+    /**\n+     * <p>Describe all SASL/SCRAM credentials.\n+     *\n+     * <p>This is a convenience method for {@link #describeUserScramCredentials(List, DescribeUserScramCredentialsOptions)}\n+     *\n+     * @return The DescribeUserScramCredentialsResult.\n+     */\n+    default DescribeUserScramCredentialsResult describeUserScramCredentials() {\n+        return describeUserScramCredentials(null, new DescribeUserScramCredentialsOptions());\n+    }\n+\n+    /**\n+     * <p>Describe SASL/SCRAM credentials for the given users.\n+     *\n+     * <p>This is a convenience method for {@link #describeUserScramCredentials(List, DescribeUserScramCredentialsOptions)}\n+     *\n+     * @param users the users for which credentials are to be described; all users' credentials are described if null\n+     *              or empty.  A user explicitly specified here that does not have a SCRAM credential will not appear\n+     *              in the results.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzgzMDU2Ng=="}, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1MjExMw==", "bodyText": "Yeah, I think there is a fundamental problem with allowing the value -1 for iterations.  The KIP says \"Note that if the number of iterations is set to -1, the server-side default will be used.\". But we are on the client at this point in the code, and there is no concept for \"server-side default\" for SCRAM iterations in Kafka.  And unfortunately since we are salting the password here, we need to know the number of iterations.  So I think we need to do either of the following:\n\nAdd an ability to define server-side default number of iterations per SASL/SCRAM mechanism in Kafka and allow clients to learn them.\nGet rid of -1 as a special value.\n\nIt's pretty clear to me that (2) is the way to go, but @rajinisivaram and @cmccabe please chime in.", "url": "https://github.com/apache/kafka/pull/9032#discussion_r468152113", "createdAt": "2020-08-10T20:07:51Z", "author": {"login": "rondagostino"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java", "diffHunk": "@@ -4071,6 +4081,168 @@ void handleFailure(Throwable throwable) {\n         return new AlterClientQuotasResult(Collections.unmodifiableMap(futures));\n     }\n \n+    @Override\n+    public DescribeUserScramCredentialsResult describeUserScramCredentials(List<String> users, DescribeUserScramCredentialsOptions options) {\n+        final KafkaFutureImpl<Map<String, UserScramCredentialsDescription>> future = new KafkaFutureImpl<>();\n+        final long now = time.milliseconds();\n+        Call call = new Call(\"describeUserScramCredentials\", calcDeadlineMs(now, options.timeoutMs()),\n+                new ControllerNodeProvider()) {\n+            @Override\n+            public DescribeUserScramCredentialsRequest.Builder createRequest(int timeoutMs) {\n+                return new DescribeUserScramCredentialsRequest.Builder(\n+                        new DescribeUserScramCredentialsRequestData().setUsers(users.stream().map(user ->\n+                                new DescribeUserScramCredentialsRequestData.UserName().setName(user)).collect(Collectors.toList())));\n+            }\n+\n+            @Override\n+            public void handleResponse(AbstractResponse abstractResponse) {\n+                DescribeUserScramCredentialsResponse response = (DescribeUserScramCredentialsResponse) abstractResponse;\n+                Errors error = Errors.forCode(response.data().error());\n+                switch (error) {\n+                    case NONE:\n+                        DescribeUserScramCredentialsResponseData data = response.data();\n+                        future.complete(data.userScramCredentials().stream().collect(Collectors.toMap(\n+                            DescribeUserScramCredentialsResponseData.UserScramCredential::name,\n+                            userScramCredential -> {\n+                                List<ScramCredentialInfo> scramCredentialInfos = userScramCredential.credentialInfos().stream().map(\n+                                    credentialInfo -> new ScramCredentialInfo(ScramMechanism.fromType(credentialInfo.mechanism()), credentialInfo.iterations()))\n+                                        .collect(Collectors.toList());\n+                                return new UserScramCredentialsDescription(userScramCredential.name(), scramCredentialInfos);\n+                            })));\n+                        break;\n+                    case NOT_CONTROLLER:\n+                        handleNotControllerError(error);\n+                        break;\n+                    default:\n+                        future.completeExceptionally(new ApiError(error, response.data().errorMessage()).exception());\n+                        break;\n+                }\n+            }\n+\n+            @Override\n+            void handleFailure(Throwable throwable) {\n+                future.completeExceptionally(throwable);\n+            }\n+        };\n+        runnable.call(call, now);\n+        return new DescribeUserScramCredentialsResult(future);\n+    }\n+\n+    @Override\n+    public AlterUserScramCredentialsResult alterUserScramCredentials(List<UserScramCredentialAlteration> alterations,\n+                                                                     AlterUserScramCredentialsOptions options) {\n+        final long now = time.milliseconds();\n+        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>();\n+        for (UserScramCredentialAlteration alteration: alterations) {\n+            futures.put(alteration.getUser(), new KafkaFutureImpl<>());\n+        }\n+        final Map<String, Exception> userIllegalAlterationExceptions = new HashMap<>();\n+        // We need to keep track of users with deletions of an unknown SCRAM mechanism\n+        alterations.stream().filter(a -> a instanceof UserScramCredentialDeletion).forEach(alteration -> {\n+            UserScramCredentialDeletion deletion = (UserScramCredentialDeletion) alteration;\n+            ScramMechanism mechanism = deletion.getMechanism();\n+            if (mechanism == null || mechanism == ScramMechanism.UNKNOWN) {\n+                userIllegalAlterationExceptions.put(deletion.getUser(), new InvalidRequestException(\"Unknown SCRAM mechanism\"));\n+            }\n+        });\n+        // Creating an upsertion may throw InvalidKeyException or NoSuchAlgorithmException,\n+        // so keep track of which users are affected by such a failure and immediately fail all their alterations\n+        final Map<String, Map<ScramMechanism, AlterUserScramCredentialsRequestData.ScramCredentialUpsertion>> userInsertions = new HashMap<>();\n+        alterations.stream().filter(a -> a instanceof UserScramCredentialUpsertion)\n+                .filter(alteration -> !userIllegalAlterationExceptions.containsKey(alteration.getUser()))\n+                .forEach(alteration -> {\n+                    UserScramCredentialUpsertion upsertion = (UserScramCredentialUpsertion) alteration;\n+                    String user = upsertion.getUser();\n+                    try {\n+                        ScramMechanism mechanism = upsertion.getInfo().getMechanism();\n+                        if (mechanism == null || mechanism == ScramMechanism.UNKNOWN)\n+                            throw new InvalidRequestException(\"Unknown SCRAM mechanism\");\n+                        userInsertions.putIfAbsent(user, new HashMap<>());\n+                        userInsertions.get(user).put(mechanism, getScramCredentialUpsertion(upsertion));\n+                    } catch (Exception e) {\n+                        // we might overwrite an exception from a previous upsertion, but we don't really care\n+                        // since we just need to mark this user as having at least one illegal alteration\n+                        // and make an exception instance available for completing the corresponding future exceptionally\n+                        userIllegalAlterationExceptions.put(user, e);\n+                    }\n+                });\n+        // fail any users immediately that have an illegal alteration as identified above\n+        userIllegalAlterationExceptions.entrySet().stream().forEach(entry -> {\n+            futures.get(entry.getKey()).completeExceptionally(entry.getValue());\n+        });\n+\n+        // submit alterations for users that do not have an illegal upsertion as identified above\n+        Call call = new Call(\"alterUserScramCredentials\", calcDeadlineMs(now, options.timeoutMs()),\n+                new ControllerNodeProvider()) {\n+            @Override\n+            public AlterUserScramCredentialsRequest.Builder createRequest(int timeoutMs) {\n+                return new AlterUserScramCredentialsRequest.Builder(\n+                        new AlterUserScramCredentialsRequestData().setUpsertions(alterations.stream()\n+                                .filter(a -> a instanceof UserScramCredentialUpsertion)\n+                                .filter(a -> !userIllegalAlterationExceptions.containsKey(a.getUser()))\n+                                .map(a -> userInsertions.get(a.getUser()).get(((UserScramCredentialUpsertion) a).getInfo().getMechanism()))\n+                                .collect(Collectors.toList()))\n+                        .setDeletions(alterations.stream()\n+                                .filter(a -> a instanceof UserScramCredentialDeletion)\n+                                .filter(a -> !userIllegalAlterationExceptions.containsKey(a.getUser()))\n+                                .map(d ->\n+                                getScramCredentialDeletion((UserScramCredentialDeletion) d)).collect(Collectors.toList())));\n+            }\n+\n+            @Override\n+            public void handleResponse(AbstractResponse abstractResponse) {\n+                AlterUserScramCredentialsResponse response = (AlterUserScramCredentialsResponse) abstractResponse;\n+                // Check for controller change\n+                for (Errors error : response.errorCounts().keySet()) {\n+                    if (error == Errors.NOT_CONTROLLER) {\n+                        handleNotControllerError(error);\n+                    }\n+                }\n+                response.data().results().forEach(result -> {\n+                    KafkaFutureImpl<Void> future = futures.get(result.user());\n+                    if (future == null) {\n+                        log.warn(\"Server response mentioned unknown user {}\", result.user());\n+                    } else {\n+                        Errors error = Errors.forCode(result.errorCode());\n+                        if (error != Errors.NONE) {\n+                            future.completeExceptionally(error.exception(result.errorMessage()));\n+                        } else {\n+                            future.complete(null);\n+                        }\n+                    }\n+                });\n+                completeUnrealizedFutures(\n+                    futures.entrySet().stream(),\n+                    user -> \"The broker response did not contain a result for user \" + user);\n+            }\n+\n+            @Override\n+            void handleFailure(Throwable throwable) {\n+                completeAllExceptionally(futures.values(), throwable);\n+            }\n+        };\n+        runnable.call(call, now);\n+        return new AlterUserScramCredentialsResult(new HashMap<>(futures));\n+    }\n+\n+    private static AlterUserScramCredentialsRequestData.ScramCredentialUpsertion getScramCredentialUpsertion(UserScramCredentialUpsertion u) throws InvalidKeyException, NoSuchAlgorithmException {\n+        AlterUserScramCredentialsRequestData.ScramCredentialUpsertion retval = new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion();\n+        return retval.setName(u.getUser())\n+                .setMechanism(u.getInfo().getMechanism().getType())\n+                .setIterations(u.getInfo().getIterations())\n+                .setSalt(u.getSalt())\n+                .setSaltedPassword(getSaltedPasword(u.getInfo().getMechanism(), u.getPassword(), u.getSalt(), u.getInfo().getIterations()));\n+    }\n+\n+    private static AlterUserScramCredentialsRequestData.ScramCredentialDeletion getScramCredentialDeletion(UserScramCredentialDeletion d) {\n+        return new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(d.getUser()).setMechanism(d.getMechanism().getType());\n+    }\n+\n+    private static byte[] getSaltedPasword(ScramMechanism publicScramMechanism, byte[] password, byte[] salt, int iterations) throws NoSuchAlgorithmException, InvalidKeyException {\n+        return new ScramFormatter(org.apache.kafka.common.security.scram.internals.ScramMechanism.forMechanismName(publicScramMechanism.getMechanismName()))\n+                .hi(password, salt, iterations);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAzMDA0OQ=="}, "originalCommit": null, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1MzIxMA==", "bodyText": "TBD.  No change needed if we are getting rid of -1 as a special value.", "url": "https://github.com/apache/kafka/pull/9032#discussion_r468153210", "createdAt": "2020-08-10T20:10:11Z", "author": {"login": "rondagostino"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/ScramCredentialInfo.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.clients.admin;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Mechanism and iterations for a SASL/SCRAM credential associated with a user.\n+ *\n+ * @see <a href=\"https://cwiki.apache.org/confluence/display/KAFKA/KIP-554%3A+Add+Broker-side+SCRAM+Config+API\">KIP-554: Add Broker-side SCRAM Config API</a>\n+ */\n+public class ScramCredentialInfo {\n+    private final ScramMechanism mechanism;\n+    private final int iterations;\n+\n+    /**\n+     *\n+     * @param mechanism the required mechanism\n+     * @param iterations the number of iterations used when creating the credential\n+     */\n+    public ScramCredentialInfo(ScramMechanism mechanism, int iterations) {\n+        this.mechanism = Objects.requireNonNull(mechanism);\n+        this.iterations = iterations;\n+    }\n+\n+    /**\n+     *\n+     * @return the mechanism\n+     */\n+    public ScramMechanism getMechanism() {\n+        return mechanism;\n+    }\n+\n+    /**\n+     *\n+     * @return the number of iterations used when creating the credential", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODAxMDMwNw=="}, "originalCommit": null, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3MDY1OA==", "bodyText": "I made the changes here and also removed all get prefixes on getters within ScramCredentialInfo and UserScramCredential{Alteration,Deletion,Upsertion,Description}", "url": "https://github.com/apache/kafka/pull/9032#discussion_r468170658", "createdAt": "2020-08-10T20:35:24Z", "author": {"login": "rondagostino"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/ScramMechanism.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.clients.admin;\n+\n+/**\n+ * Representation of a SASL/SCRAM Mechanism.\n+ *\n+ * @see <a href=\"https://cwiki.apache.org/confluence/display/KAFKA/KIP-554%3A+Add+Broker-side+SCRAM+Config+API\">KIP-554: Add Broker-side SCRAM Config API</a>\n+ */\n+public enum ScramMechanism {\n+    UNKNOWN((byte) 0),\n+    SCRAM_SHA_256((byte) 1),\n+    SCRAM_SHA_512((byte) 2);\n+\n+    /**\n+     *\n+     * @param type the type indicator\n+     * @return the instance corresponding to the given type indicator, otherwise {@link #UNKNOWN}\n+     */\n+    public static ScramMechanism fromType(byte type) {\n+        for (ScramMechanism scramMechanism : ScramMechanism.values()) {\n+            if (scramMechanism.type == type) {\n+                return scramMechanism;\n+            }\n+        }\n+        return UNKNOWN;\n+    }\n+\n+    /**\n+     *\n+     * @param mechanismName the SASL SCRAM mechanism name\n+     * @return the corresponding SASL SCRAM mechanism enum, otherwise {@link #UNKNOWN}\n+     * @see <a href=\"https://tools.ietf.org/html/rfc5802#section-4>\n+     *     Salted Challenge Response Authentication Mechanism (SCRAM) SASL and GSS-API Mechanisms, Section 4</a>\n+     */\n+    public static ScramMechanism fromMechanismName(String mechanismName) {\n+        ScramMechanism retvalFoundMechanism = ScramMechanism.valueOf(mechanismName.replace('-', '_'));\n+        return retvalFoundMechanism != null ? retvalFoundMechanism : UNKNOWN;\n+    }\n+\n+    /**\n+     *\n+     * @return the corresponding SASL SCRAM mechanism name\n+     * @see <a href=\"https://tools.ietf.org/html/rfc5802#section-4>\n+     *     Salted Challenge Response Authentication Mechanism (SCRAM) SASL and GSS-API Mechanisms, Section 4</a>\n+     */\n+    public String getMechanismName() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg0ODc4MQ=="}, "originalCommit": null, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyMzg0Ng==", "bodyText": "Added a test for it in UserScramCredentialsCommandTest.  We can't test for it here because we get a salted password here, and I don't think it is possible for that to be an empty string and allow a successful SASL/SCRAM authentication.", "url": "https://github.com/apache/kafka/pull/9032#discussion_r468223846", "createdAt": "2020-08-10T22:37:07Z", "author": {"login": "rondagostino"}, "path": "core/src/test/scala/unit/kafka/server/AlterUserScramCredentialsRequestTest.scala", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+\n+import java.nio.charset.StandardCharsets\n+import java.util\n+import java.util.Properties\n+\n+import kafka.network.SocketServer\n+import kafka.security.authorizer.AclAuthorizer\n+import org.apache.kafka.clients.admin.ScramMechanism\n+import org.apache.kafka.common.acl.AclOperation\n+import org.apache.kafka.common.message.{AlterUserScramCredentialsRequestData, DescribeUserScramCredentialsRequestData}\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.requests.{AlterUserScramCredentialsRequest, AlterUserScramCredentialsResponse, DescribeUserScramCredentialsRequest, DescribeUserScramCredentialsResponse}\n+import org.apache.kafka.common.resource.ResourceType\n+import org.apache.kafka.common.security.auth.{AuthenticationContext, KafkaPrincipal, KafkaPrincipalBuilder}\n+import org.apache.kafka.server.authorizer.{Action, AuthorizableRequestContext, AuthorizationResult}\n+import org.junit.Assert._\n+import org.junit.{Before, Test}\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Test AlterUserScramCredentialsRequest/Response API for the cases where either no credentials are altered\n+ * or failure is expected due to lack of authorization, sending the request to a non-controller broker, or some other issue.\n+ * Also tests the Alter and Describe APIs for the case where credentials are successfully altered/described.\n+ */\n+class AlterUserScramCredentialsRequestTest extends BaseRequestTest {\n+  override def brokerPropertyOverrides(properties: Properties): Unit = {\n+    properties.put(KafkaConfig.ControlledShutdownEnableProp, \"false\")\n+    properties.put(KafkaConfig.AuthorizerClassNameProp, classOf[AlterCredentialsTest.TestAuthorizer].getName)\n+    properties.put(KafkaConfig.PrincipalBuilderClassProp, classOf[AlterCredentialsTest.TestPrincipalBuilder].getName)\n+  }\n+\n+  @Before\n+  override def setUp(): Unit = {\n+    AlterCredentialsTest.principal = KafkaPrincipal.ANONYMOUS // default is to be authorized\n+    super.setUp()\n+  }\n+\n+  @Test\n+  def testAlterNothing(): Unit = {\n+    val request = new AlterUserScramCredentialsRequest.Builder(\n+      new AlterUserScramCredentialsRequestData()\n+        .setDeletions(new util.ArrayList[AlterUserScramCredentialsRequestData.ScramCredentialDeletion])\n+        .setUpsertions(new util.ArrayList[AlterUserScramCredentialsRequestData.ScramCredentialUpsertion])).build()\n+    val response = sendAlterUserScramCredentialsRequest(request)\n+\n+    val results = response.data.results\n+    assertEquals(0, results.size)\n+  }\n+\n+  @Test\n+  def testAlterNothingNotAuthorized(): Unit = {\n+    AlterCredentialsTest.principal = AlterCredentialsTest.UnauthorizedPrincipal\n+\n+    val request = new AlterUserScramCredentialsRequest.Builder(\n+      new AlterUserScramCredentialsRequestData()\n+        .setDeletions(new util.ArrayList[AlterUserScramCredentialsRequestData.ScramCredentialDeletion])\n+        .setUpsertions(new util.ArrayList[AlterUserScramCredentialsRequestData.ScramCredentialUpsertion])).build()\n+    val response = sendAlterUserScramCredentialsRequest(request)\n+\n+    val results = response.data.results\n+    assertEquals(0, results.size)\n+  }\n+\n+  @Test\n+  def testAlterSomethingNotAuthorized(): Unit = {\n+    AlterCredentialsTest.principal = AlterCredentialsTest.UnauthorizedPrincipal\n+\n+    val request = new AlterUserScramCredentialsRequest.Builder(\n+      new AlterUserScramCredentialsRequestData()\n+        .setDeletions(util.Arrays.asList(new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(\"name1\").setMechanism(ScramMechanism.SCRAM_SHA_256.getType)))\n+        .setUpsertions(util.Arrays.asList(new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(\"name2\").setMechanism(ScramMechanism.SCRAM_SHA_512.getType)))).build()\n+    val response = sendAlterUserScramCredentialsRequest(request)\n+\n+    val results = response.data.results\n+    assertEquals(2, results.size)\n+    assertTrue(\"Expected not authorized\",\n+      results.get(0).errorCode == Errors.CLUSTER_AUTHORIZATION_FAILED.code && results.get(1).errorCode == Errors.CLUSTER_AUTHORIZATION_FAILED.code)\n+  }\n+\n+  @Test\n+  def testAlterSameThingTwice(): Unit = {\n+    val deletion1 = new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(\"name1\").setMechanism(ScramMechanism.SCRAM_SHA_256.getType)\n+    val deletion2 = new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(\"name2\").setMechanism(ScramMechanism.SCRAM_SHA_256.getType)\n+    val upsertion1 = new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(\"name1\").setMechanism(ScramMechanism.SCRAM_SHA_256.getType)\n+      .setIterations(-1).setSalt(\"salt\".getBytes).setSaltedPassword(\"saltedPassword\".getBytes)\n+    val upsertion2 = new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(\"name2\").setMechanism(ScramMechanism.SCRAM_SHA_256.getType)\n+      .setIterations(-1).setSalt(\"salt\".getBytes).setSaltedPassword(\"saltedPassword\".getBytes)\n+    val requests = List (\n+      new AlterUserScramCredentialsRequest.Builder(\n+        new AlterUserScramCredentialsRequestData()\n+          .setDeletions(util.Arrays.asList(deletion1, deletion1))\n+          .setUpsertions(util.Arrays.asList(upsertion2, upsertion2))).build(),\n+      new AlterUserScramCredentialsRequest.Builder(\n+        new AlterUserScramCredentialsRequestData()\n+          .setDeletions(util.Arrays.asList(deletion1, deletion2))\n+          .setUpsertions(util.Arrays.asList(upsertion1, upsertion2))).build(),\n+    )\n+    requests.foreach(request => {\n+      val response = sendAlterUserScramCredentialsRequest(request)\n+      val results = response.data.results\n+      assertEquals(2, results.size)\n+      assertTrue(\"Expected error when altering the same credential twice in a single request\",\n+        results.get(0).errorCode == Errors.INVALID_REQUEST.code && results.get(1).errorCode == Errors.INVALID_REQUEST.code)\n+    })\n+  }\n+\n+  @Test\n+  def testAlterEmptyUser(): Unit = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk4NDUyMA=="}, "originalCommit": null, "originalPosition": 127}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NDM4NzU4", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-465438758", "createdAt": "2020-08-11T21:22:58Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMToyMjo1OFrOG_JuHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMToyMjo1OFrOG_JuHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg3MjczMw==", "bodyText": "If we're going to have a per-user error, then we need Map<String, KafkaFuture<...>>.  This will also be useful if we need to add more per-user errors in the future.", "url": "https://github.com/apache/kafka/pull/9032#discussion_r468872733", "createdAt": "2020-08-11T21:22:58Z", "author": {"login": "cmccabe"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/DescribeUserScramCredentialsResult.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.clients.admin;\n+\n+import org.apache.kafka.common.KafkaFuture;\n+import org.apache.kafka.common.annotation.InterfaceStability;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * The result of the {@link Admin#describeUserScramCredentials()} call.\n+ *\n+ * The API of this class is evolving, see {@link Admin} for details.\n+ */\n+@InterfaceStability.Evolving\n+public class DescribeUserScramCredentialsResult {\n+    private final KafkaFuture<Map<String, UserScramCredentialsDescription>> future;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NDQzMjA2", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-465443206", "createdAt": "2020-08-11T21:30:51Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTozMDo1MVrOG_J8aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTozMDo1MVrOG_J8aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg3NjM5NQ==", "bodyText": "How does this interact with JUnit running tests concurrently?  cc @ijuma @hachikuji", "url": "https://github.com/apache/kafka/pull/9032#discussion_r468876395", "createdAt": "2020-08-11T21:30:51Z", "author": {"login": "cmccabe"}, "path": "core/src/test/scala/unit/kafka/admin/UserScramCredentialsCommandTest.scala", "diffHunk": "@@ -0,0 +1,127 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.admin\n+\n+import java.io.{ByteArrayOutputStream, PrintStream}\n+import java.nio.charset.StandardCharsets\n+\n+import kafka.server.BaseRequestTest\n+import kafka.utils.Exit\n+import org.junit.Assert._\n+import org.junit.Test\n+\n+class UserScramCredentialsCommandTest extends BaseRequestTest {\n+  override def brokerCount = 1\n+  var exitStatus: Option[Int] = None\n+  var exitMessage: Option[String] = None\n+\n+  case class ConfigCommandResult(stdout: String, exitStatus: Option[Int] = None)\n+\n+  private def runConfigCommandViaBroker(args: Array[String]) : ConfigCommandResult = {\n+    val byteArrayOutputStream = new ByteArrayOutputStream()\n+    val utf8 = StandardCharsets.UTF_8.name\n+    val printStream = new PrintStream(byteArrayOutputStream, true, utf8)\n+    var exitStatus: Option[Int] = None\n+    Exit.setExitProcedure { (status, _) =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NDQ5OTA3", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-465449907", "createdAt": "2020-08-11T21:43:25Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTo0MzoyNVrOG_KRqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTo0MzoyNVrOG_KRqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg4MTgzMg==", "bodyText": "It's kind of a code smell to be mutating static data during a JUnit test.  There are ways to run JUnit tests in parallel (although I think our current setup only runs at the granularity of test classes, not test methods?)  At the very least we'd have to document that this is not thread-safe and that it will prevent us from parellelizing this test class in the future.\nRather than doing this, how about having two separate test authorizers, and choosing the one you want for each individual JUnit test method?\nIn order to fit this into our bass-akwards inheritance based test design ( :( ) you could check the name of the test in brokerPropertyOverrides using one of these methods: https://stackoverflow.com/questions/473401/get-name-of-currently-executing-test-in-junit-4", "url": "https://github.com/apache/kafka/pull/9032#discussion_r468881832", "createdAt": "2020-08-11T21:43:25Z", "author": {"login": "cmccabe"}, "path": "core/src/test/scala/unit/kafka/server/DescribeUserScramCredentialsRequestTest.scala", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import java.util\n+import java.util.Properties\n+\n+import kafka.network.SocketServer\n+import kafka.security.authorizer.AclAuthorizer\n+import org.apache.kafka.common.acl.AclOperation\n+import org.apache.kafka.common.message.DescribeUserScramCredentialsRequestData\n+import org.apache.kafka.common.message.DescribeUserScramCredentialsRequestData.UserName\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.requests.{DescribeUserScramCredentialsRequest, DescribeUserScramCredentialsResponse}\n+import org.apache.kafka.common.resource.ResourceType\n+import org.apache.kafka.common.security.auth.{AuthenticationContext, KafkaPrincipal, KafkaPrincipalBuilder}\n+import org.apache.kafka.server.authorizer.{Action, AuthorizableRequestContext, AuthorizationResult}\n+import org.junit.Assert._\n+import org.junit.{Before, Test}\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Test DescribeUserScramCredentialsRequest/Response API for the cases where no credentials exist\n+ * or failure is expected due to lack of authorization, sending the request to a non-controller broker, or some other issue.\n+ * Testing the API for the case where there are actually credentials to describe is performed elsewhere.\n+ */\n+class DescribeUserScramCredentialsRequestTest extends BaseRequestTest {\n+  override def brokerPropertyOverrides(properties: Properties): Unit = {\n+    properties.put(KafkaConfig.ControlledShutdownEnableProp, \"false\")\n+    properties.put(KafkaConfig.AuthorizerClassNameProp, classOf[DescribeCredentialsTest.TestAuthorizer].getName)\n+    properties.put(KafkaConfig.PrincipalBuilderClassProp, classOf[DescribeCredentialsTest.TestPrincipalBuilder].getName)\n+  }\n+\n+  @Before\n+  override def setUp(): Unit = {\n+    DescribeCredentialsTest.principal = KafkaPrincipal.ANONYMOUS // default is to be authorized\n+    super.setUp()\n+  }\n+\n+  @Test\n+  def testDescribeNothing(): Unit = {\n+    val request = new DescribeUserScramCredentialsRequest.Builder(\n+      new DescribeUserScramCredentialsRequestData()).build()\n+    val response = sendDescribeUserScramCredentialsRequest(request)\n+\n+    val error = response.data.error\n+    assertEquals(\"Expected no error when routed correctly\", Errors.NONE.code, error)\n+    assertEquals(\"Expected no credentials\", 0, response.data.userScramCredentials.size)\n+  }\n+\n+  @Test\n+  def testDescribeNotController(): Unit = {\n+    val request = new DescribeUserScramCredentialsRequest.Builder(\n+      new DescribeUserScramCredentialsRequestData()).build()\n+    val response = sendDescribeUserScramCredentialsRequest(request, notControllerSocketServer)\n+\n+    val error = response.data.error\n+    assertEquals(\"Expected controller error when routed incorrectly\", Errors.NOT_CONTROLLER.code, error)\n+  }\n+\n+  @Test\n+  def testDescribeNotAuthorized(): Unit = {\n+    DescribeCredentialsTest.principal = DescribeCredentialsTest.UnauthorizedPrincipal\n+\n+    val request = new DescribeUserScramCredentialsRequest.Builder(\n+      new DescribeUserScramCredentialsRequestData()).build()\n+    val response = sendDescribeUserScramCredentialsRequest(request)\n+\n+    val error = response.data.error\n+    assertEquals(\"Expected not authorized error\", Errors.CLUSTER_AUTHORIZATION_FAILED.code, error)\n+  }\n+\n+  @Test\n+  def testDescribeSameUserTwice(): Unit = {\n+    val user = new UserName().setName(\"user1\")\n+    val request = new DescribeUserScramCredentialsRequest.Builder(\n+      new DescribeUserScramCredentialsRequestData().setUsers(List(user, user).asJava)).build()\n+    val response = sendDescribeUserScramCredentialsRequest(request)\n+\n+    val error = response.data.error\n+    assertEquals(\"Expected invalid request error\", Errors.INVALID_REQUEST.code, error)\n+  }\n+\n+\n+  private def sendDescribeUserScramCredentialsRequest(request: DescribeUserScramCredentialsRequest, socketServer: SocketServer = controllerSocketServer): DescribeUserScramCredentialsResponse = {\n+    connectAndReceive[DescribeUserScramCredentialsResponse](request, destination = socketServer)\n+  }\n+}\n+\n+object DescribeCredentialsTest {\n+  val UnauthorizedPrincipal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"Unauthorized\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 106}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NDUwOTA2", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-465450906", "createdAt": "2020-08-11T21:45:17Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTo0NToxN1rOG_KU9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTo0NToxN1rOG_KU9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg4MjY3Ng==", "bodyText": "Same comment applies here as in the describe test: don't mutate static data.", "url": "https://github.com/apache/kafka/pull/9032#discussion_r468882676", "createdAt": "2020-08-11T21:45:17Z", "author": {"login": "cmccabe"}, "path": "core/src/test/scala/unit/kafka/server/AlterUserScramCredentialsRequestTest.scala", "diffHunk": "@@ -0,0 +1,396 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+\n+import java.nio.charset.StandardCharsets\n+import java.util\n+import java.util.Properties\n+\n+import kafka.network.SocketServer\n+import kafka.security.authorizer.AclAuthorizer\n+import org.apache.kafka.clients.admin.ScramMechanism\n+import org.apache.kafka.common.acl.AclOperation\n+import org.apache.kafka.common.message.{AlterUserScramCredentialsRequestData, DescribeUserScramCredentialsRequestData}\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.requests.{AlterUserScramCredentialsRequest, AlterUserScramCredentialsResponse, DescribeUserScramCredentialsRequest, DescribeUserScramCredentialsResponse}\n+import org.apache.kafka.common.resource.ResourceType\n+import org.apache.kafka.common.security.auth.{AuthenticationContext, KafkaPrincipal, KafkaPrincipalBuilder}\n+import org.apache.kafka.server.authorizer.{Action, AuthorizableRequestContext, AuthorizationResult}\n+import org.junit.Assert._\n+import org.junit.{Before, Test}\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Test AlterUserScramCredentialsRequest/Response API for the cases where either no credentials are altered\n+ * or failure is expected due to lack of authorization, sending the request to a non-controller broker, or some other issue.\n+ * Also tests the Alter and Describe APIs for the case where credentials are successfully altered/described.\n+ */\n+class AlterUserScramCredentialsRequestTest extends BaseRequestTest {\n+  override def brokerPropertyOverrides(properties: Properties): Unit = {\n+    properties.put(KafkaConfig.ControlledShutdownEnableProp, \"false\")\n+    properties.put(KafkaConfig.AuthorizerClassNameProp, classOf[AlterCredentialsTest.TestAuthorizer].getName)\n+    properties.put(KafkaConfig.PrincipalBuilderClassProp, classOf[AlterCredentialsTest.TestPrincipalBuilder].getName)\n+  }\n+\n+  @Before\n+  override def setUp(): Unit = {\n+    AlterCredentialsTest.principal = KafkaPrincipal.ANONYMOUS // default is to be authorized\n+    super.setUp()\n+  }\n+\n+  @Test\n+  def testAlterNothing(): Unit = {\n+    val request = new AlterUserScramCredentialsRequest.Builder(\n+      new AlterUserScramCredentialsRequestData()\n+        .setDeletions(new util.ArrayList[AlterUserScramCredentialsRequestData.ScramCredentialDeletion])\n+        .setUpsertions(new util.ArrayList[AlterUserScramCredentialsRequestData.ScramCredentialUpsertion])).build()\n+    val response = sendAlterUserScramCredentialsRequest(request)\n+\n+    val results = response.data.results\n+    assertEquals(0, results.size)\n+  }\n+\n+  @Test\n+  def testAlterNothingNotAuthorized(): Unit = {\n+    AlterCredentialsTest.principal = AlterCredentialsTest.UnauthorizedPrincipal\n+\n+    val request = new AlterUserScramCredentialsRequest.Builder(\n+      new AlterUserScramCredentialsRequestData()\n+        .setDeletions(new util.ArrayList[AlterUserScramCredentialsRequestData.ScramCredentialDeletion])\n+        .setUpsertions(new util.ArrayList[AlterUserScramCredentialsRequestData.ScramCredentialUpsertion])).build()\n+    val response = sendAlterUserScramCredentialsRequest(request)\n+\n+    val results = response.data.results\n+    assertEquals(0, results.size)\n+  }\n+\n+  @Test\n+  def testAlterSomethingNotAuthorized(): Unit = {\n+    AlterCredentialsTest.principal = AlterCredentialsTest.UnauthorizedPrincipal\n+\n+    val request = new AlterUserScramCredentialsRequest.Builder(\n+      new AlterUserScramCredentialsRequestData()\n+        .setDeletions(util.Arrays.asList(new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(\"name1\").setMechanism(ScramMechanism.SCRAM_SHA_256.`type`)))\n+        .setUpsertions(util.Arrays.asList(new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(\"name2\").setMechanism(ScramMechanism.SCRAM_SHA_512.`type`)))).build()\n+    val response = sendAlterUserScramCredentialsRequest(request)\n+\n+    val results = response.data.results\n+    assertEquals(2, results.size)\n+    val msg = \"Expected not authorized\"\n+    assertEquals(msg, Errors.CLUSTER_AUTHORIZATION_FAILED.code, results.get(0).errorCode)\n+    assertEquals(msg, Errors.CLUSTER_AUTHORIZATION_FAILED.code, results.get(1).errorCode)\n+  }\n+\n+  @Test\n+  def testAlterSameThingTwice(): Unit = {\n+    val deletion1 = new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(\"name1\").setMechanism(ScramMechanism.SCRAM_SHA_256.`type`)\n+    val deletion2 = new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(\"name2\").setMechanism(ScramMechanism.SCRAM_SHA_256.`type`)\n+    val upsertion1 = new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(\"name1\").setMechanism(ScramMechanism.SCRAM_SHA_256.`type`)\n+      .setIterations(4096).setSalt(\"salt\".getBytes).setSaltedPassword(\"saltedPassword\".getBytes)\n+    val upsertion2 = new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(\"name2\").setMechanism(ScramMechanism.SCRAM_SHA_256.`type`)\n+      .setIterations(4096).setSalt(\"salt\".getBytes).setSaltedPassword(\"saltedPassword\".getBytes)\n+    val requests = List (\n+      new AlterUserScramCredentialsRequest.Builder(\n+        new AlterUserScramCredentialsRequestData()\n+          .setDeletions(util.Arrays.asList(deletion1, deletion1))\n+          .setUpsertions(util.Arrays.asList(upsertion2, upsertion2))).build(),\n+      new AlterUserScramCredentialsRequest.Builder(\n+        new AlterUserScramCredentialsRequestData()\n+          .setDeletions(util.Arrays.asList(deletion1, deletion2))\n+          .setUpsertions(util.Arrays.asList(upsertion1, upsertion2))).build(),\n+    )\n+    requests.foreach(request => {\n+      val response = sendAlterUserScramCredentialsRequest(request)\n+      val results = response.data.results\n+      assertEquals(2, results.size)\n+      val msg = \"Expected error when altering the same credential twice in a single request\"\n+      assertEquals(msg, Errors.INVALID_REQUEST.code, results.get(0).errorCode)\n+      assertEquals(msg, Errors.INVALID_REQUEST.code, results.get(1).errorCode)\n+    })\n+  }\n+\n+  @Test\n+  def testAlterEmptyUser(): Unit = {\n+    val deletionEmpty = new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(\"\").setMechanism(ScramMechanism.SCRAM_SHA_256.`type`)\n+    val upsertionEmpty = new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(\"\").setMechanism(ScramMechanism.SCRAM_SHA_256.`type`)\n+      .setIterations(4096).setSalt(\"salt\".getBytes).setSaltedPassword(\"saltedPassword\".getBytes)\n+    val requests = List (\n+      new AlterUserScramCredentialsRequest.Builder(\n+        new AlterUserScramCredentialsRequestData()\n+          .setDeletions(util.Arrays.asList(deletionEmpty))\n+          .setUpsertions(new util.ArrayList[AlterUserScramCredentialsRequestData.ScramCredentialUpsertion])).build(),\n+      new AlterUserScramCredentialsRequest.Builder(\n+        new AlterUserScramCredentialsRequestData()\n+          .setDeletions(new util.ArrayList[AlterUserScramCredentialsRequestData.ScramCredentialDeletion])\n+          .setUpsertions(util.Arrays.asList(upsertionEmpty))).build(),\n+      new AlterUserScramCredentialsRequest.Builder(\n+        new AlterUserScramCredentialsRequestData()\n+          .setDeletions(util.Arrays.asList(deletionEmpty, deletionEmpty))\n+          .setUpsertions(util.Arrays.asList(upsertionEmpty))).build(),\n+    )\n+    requests.foreach(request => {\n+      val response = sendAlterUserScramCredentialsRequest(request)\n+      val results = response.data.results\n+      assertEquals(1, results.size)\n+      assertEquals(\"Expected error when altering an empty user\", Errors.INVALID_REQUEST.code, results.get(0).errorCode)\n+      assertEquals(\"\\\"\\\" is an illegal user name\", results.get(0).errorMessage)\n+    })\n+  }\n+\n+  private val user1 = \"user1\"\n+  private val user2 = \"user2\"\n+\n+  @Test\n+  def testAlterUnknownMechanism(): Unit = {\n+    val deletionUnknown1 = new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(user1).setMechanism(ScramMechanism.UNKNOWN.`type`)\n+    val deletionValid1 = new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(user1).setMechanism(ScramMechanism.SCRAM_SHA_256.`type`)\n+    val deletionUnknown2 = new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(user2).setMechanism(10.toByte)\n+    val user3 = \"user3\"\n+    val upsertionUnknown3 = new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(user3).setMechanism(ScramMechanism.UNKNOWN.`type`)\n+      .setIterations(8192).setSalt(\"salt\".getBytes).setSaltedPassword(\"saltedPassword\".getBytes)\n+    val upsertionValid3 = new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(user3).setMechanism(ScramMechanism.SCRAM_SHA_256.`type`)\n+      .setIterations(8192).setSalt(\"salt\".getBytes).setSaltedPassword(\"saltedPassword\".getBytes)\n+    val user4 = \"user4\"\n+    val upsertionUnknown4 = new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(user4).setMechanism(10.toByte)\n+      .setIterations(8192).setSalt(\"salt\".getBytes).setSaltedPassword(\"saltedPassword\".getBytes)\n+    val user5 = \"user5\"\n+    val upsertionUnknown5 = new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(user5).setMechanism(ScramMechanism.UNKNOWN.`type`)\n+      .setIterations(8192).setSalt(\"salt\".getBytes).setSaltedPassword(\"saltedPassword\".getBytes)\n+    val request = new AlterUserScramCredentialsRequest.Builder(\n+        new AlterUserScramCredentialsRequestData()\n+          .setDeletions(util.Arrays.asList(deletionUnknown1, deletionValid1, deletionUnknown2))\n+          .setUpsertions(util.Arrays.asList(upsertionUnknown3, upsertionValid3, upsertionUnknown4, upsertionUnknown5))).build()\n+    val response = sendAlterUserScramCredentialsRequest(request)\n+    val results = response.data.results\n+    assertEquals(5, results.size)\n+    assertEquals(\"Expected error when altering the credentials with unknown SCRAM mechanisms\",\n+      0, results.asScala.filterNot(_.errorCode == Errors.INVALID_REQUEST.code).size)\n+    results.asScala.foreach(result => assertEquals(\"Unknown SCRAM mechanism\", result.errorMessage))\n+  }\n+\n+  @Test\n+  def testAlterTooFewIterations(): Unit = {\n+    val upsertionTooFewIterations = new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(user1)\n+      .setMechanism(ScramMechanism.SCRAM_SHA_256.`type`).setIterations(1)\n+      .setSalt(\"salt\".getBytes).setSaltedPassword(\"saltedPassword\".getBytes)\n+    val request = new AlterUserScramCredentialsRequest.Builder(\n+      new AlterUserScramCredentialsRequestData()\n+        .setDeletions(util.Collections.emptyList())\n+        .setUpsertions(util.Arrays.asList(upsertionTooFewIterations))).build()\n+    val response = sendAlterUserScramCredentialsRequest(request)\n+    val results = response.data.results\n+    assertEquals(1, results.size)\n+    assertEquals(\"Expected error when altering the credentials with too few iterations\",\n+      0, results.asScala.filterNot(_.errorCode == Errors.INVALID_REQUEST.code).size)\n+    assertEquals(\"Too few iterations\", results.get(0).errorMessage)\n+  }\n+\n+  @Test\n+  def testAlterTooManyIterations(): Unit = {\n+    val upsertionTooFewIterations = new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(user1)\n+      .setMechanism(ScramMechanism.SCRAM_SHA_256.`type`).setIterations(Integer.MAX_VALUE)\n+      .setSalt(\"salt\".getBytes).setSaltedPassword(\"saltedPassword\".getBytes)\n+    val request = new AlterUserScramCredentialsRequest.Builder(\n+      new AlterUserScramCredentialsRequestData()\n+        .setDeletions(util.Collections.emptyList())\n+        .setUpsertions(util.Arrays.asList(upsertionTooFewIterations))).build()\n+    val response = sendAlterUserScramCredentialsRequest(request)\n+    val results = response.data.results\n+    assertEquals(1, results.size)\n+    assertEquals(\"Expected error when altering the credentials with too many iterations\",\n+      0, results.asScala.filterNot(_.errorCode == Errors.INVALID_REQUEST.code).size)\n+    assertEquals(\"Too many iterations\", results.get(0).errorMessage)\n+  }\n+\n+  @Test\n+  def testDeleteSomethingThatDoesNotExist(): Unit = {\n+    val request = new AlterUserScramCredentialsRequest.Builder(\n+      new AlterUserScramCredentialsRequestData()\n+        .setDeletions(util.Arrays.asList(new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(\"name1\").setMechanism(ScramMechanism.SCRAM_SHA_256.`type`)))\n+        .setUpsertions(new util.ArrayList[AlterUserScramCredentialsRequestData.ScramCredentialUpsertion])).build()\n+    val response = sendAlterUserScramCredentialsRequest(request)\n+\n+    val results = response.data.results\n+    assertEquals(1, results.size)\n+    assertEquals(\"Expected error when deleting a non-existing credential\", Errors.RESOURCE_NOT_FOUND.code, results.get(0).errorCode)\n+  }\n+\n+  @Test\n+  def testAlterNotController(): Unit = {\n+    val request = new AlterUserScramCredentialsRequest.Builder(\n+      new AlterUserScramCredentialsRequestData()\n+        .setDeletions(util.Arrays.asList(new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(\"name1\").setMechanism(ScramMechanism.SCRAM_SHA_256.`type`)))\n+        .setUpsertions(util.Arrays.asList(new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion().setName(\"name2\").setMechanism(ScramMechanism.SCRAM_SHA_512.`type`)))).build()\n+    val response = sendAlterUserScramCredentialsRequest(request, notControllerSocketServer)\n+\n+    val results = response.data.results\n+    assertEquals(2, results.size)\n+    val msg = \"Expected controller error when routed incorrectly\"\n+    assertEquals(msg, Errors.NOT_CONTROLLER.code, results.get(0).errorCode)\n+    assertEquals(msg, Errors.NOT_CONTROLLER.code, results.get(1).errorCode)\n+  }\n+\n+  @Test\n+  def testAlterAndDescribe(): Unit = {\n+    // create a bunch of credentials\n+    val request1 = new AlterUserScramCredentialsRequest.Builder(\n+      new AlterUserScramCredentialsRequestData()\n+        .setUpsertions(util.Arrays.asList(\n+          new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion()\n+            .setName(user1).setMechanism(ScramMechanism.SCRAM_SHA_256.`type`)\n+            .setIterations(4096)\n+            .setSalt(\"salt\".getBytes(StandardCharsets.UTF_8))\n+            .setSaltedPassword(\"saltedPassword\".getBytes(StandardCharsets.UTF_8)),\n+          new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion()\n+            .setName(user1).setMechanism(ScramMechanism.SCRAM_SHA_512.`type`)\n+            .setIterations(8192)\n+            .setSalt(\"salt\".getBytes(StandardCharsets.UTF_8))\n+            .setSaltedPassword(\"saltedPassword\".getBytes(StandardCharsets.UTF_8)),\n+          new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion()\n+            .setName(user2).setMechanism(ScramMechanism.SCRAM_SHA_512.`type`)\n+            .setIterations(8192)\n+            .setSalt(\"salt\".getBytes(StandardCharsets.UTF_8))\n+            .setSaltedPassword(\"saltedPassword\".getBytes(StandardCharsets.UTF_8)),\n+        ))).build()\n+    val response1 = sendAlterUserScramCredentialsRequest(request1)\n+    val results1 = response1.data.results\n+    assertEquals(2, results1.size)\n+    assertEquals(\"Expected no error when creating the credentials\",\n+      0, results1.asScala.filterNot(_.errorCode == Errors.NONE.code).size)\n+    assertTrue(results1.asScala.exists(_.user == user1))\n+    assertTrue(results1.asScala.exists(_.user == user2))\n+    // now describe them all\n+    val request2 = new DescribeUserScramCredentialsRequest.Builder(\n+      new DescribeUserScramCredentialsRequestData()).build()\n+    val response2 = sendDescribeUserScramCredentialsRequest(request2)\n+    assertEquals(\"Expected no error when describing the credentials\",\n+      Errors.NONE.code, response2.data.error)\n+    val results2 = response2.data.userScramCredentials\n+    assertEquals(2, results2.size)\n+    assertTrue(s\"Expected result to contain '$user1' with 2 credentials: $results2\",\n+      results2.asScala.exists(usc => usc.name == user1 && usc.credentialInfos.size == 2))\n+    assertTrue(s\"Expected result to contain '$user2' with 1 credential: $results2\",\n+      results2.asScala.exists(usc => usc.name == user2 && usc.credentialInfos.size == 1))\n+    assertTrue(s\"Expected result to contain '$user1' with SCRAM_SHA_256/4096 and SCRAM_SHA_512/8192 credentials: $results2\",\n+      results2.asScala.exists(usc => usc.name == user1 && usc.credentialInfos.asScala.exists(info =>\n+        info.mechanism == ScramMechanism.SCRAM_SHA_256.`type` && info.iterations == 4096)\n+        && usc.credentialInfos.asScala.exists(info =>\n+        info.mechanism == ScramMechanism.SCRAM_SHA_512.`type` && info.iterations == 8192)))\n+    assertTrue(s\"Expected result to contain '$user2' with SCRAM_SHA_512/8192 credential: $results2\",\n+      results2.asScala.exists(usc => usc.name == user2 && usc.credentialInfos.asScala.exists(info =>\n+        info.mechanism == ScramMechanism.SCRAM_SHA_512.`type` && info.iterations == 8192)))\n+    // now describe just one\n+    val request3 = new DescribeUserScramCredentialsRequest.Builder(\n+      new DescribeUserScramCredentialsRequestData().setUsers(util.Arrays.asList(\n+        new DescribeUserScramCredentialsRequestData.UserName().setName(user1)))).build()\n+    val response3 = sendDescribeUserScramCredentialsRequest(request3)\n+    assertEquals(\"Expected no error when describing the credentials\",Errors.NONE.code, response3.data.error)\n+    val results3 = response3.data.userScramCredentials\n+    assertEquals(1, results3.size)\n+    assertTrue(s\"Expected result to contain '$user1' with 2 credentials: $results3\",\n+      results3.asScala.exists(usc => usc.name == user1 && usc.credentialInfos.size == 2))\n+    assertTrue(s\"Expected result to contain '$user1' with SCRAM_SHA_256/4096 and SCRAM_SHA_512/8192 credentials: $results3\",\n+      results3.asScala.exists(usc => usc.name == user1 && usc.credentialInfos.asScala.exists(info =>\n+        info.mechanism == ScramMechanism.SCRAM_SHA_256.`type` && info.iterations == 4096)\n+        && usc.credentialInfos.asScala.exists(info =>\n+        info.mechanism == ScramMechanism.SCRAM_SHA_512.`type` && info.iterations == 8192)))\n+    // now delete a couple of credentials\n+    val request4 = new AlterUserScramCredentialsRequest.Builder(\n+      new AlterUserScramCredentialsRequestData()\n+        .setDeletions(util.Arrays.asList(\n+          new AlterUserScramCredentialsRequestData.ScramCredentialDeletion()\n+            .setName(user1).setMechanism(ScramMechanism.SCRAM_SHA_256.`type`),\n+          new AlterUserScramCredentialsRequestData.ScramCredentialDeletion()\n+            .setName(user2).setMechanism(ScramMechanism.SCRAM_SHA_512.`type`),\n+        ))).build()\n+    val response4 = sendAlterUserScramCredentialsRequest(request4)\n+    val results4 = response4.data.results\n+    assertEquals(2, results4.size)\n+    assertEquals(\"Expected no error when deleting the credentials\",\n+      0, results4.asScala.filterNot(_.errorCode == Errors.NONE.code).size)\n+    assertTrue(s\"Expected result to contain '$user1'\", results4.asScala.exists(_.user == user1))\n+    assertTrue(s\"Expected result to contain '$user2'\", results4.asScala.exists(_.user == user2))\n+    // now describe them all, which should just yield 1 credential\n+    val request5 = new DescribeUserScramCredentialsRequest.Builder(\n+      new DescribeUserScramCredentialsRequestData()).build()\n+    val response5 = sendDescribeUserScramCredentialsRequest(request5)\n+    assertEquals(\"Expected no error when describing the credentials\", Errors.NONE.code, response5.data.error)\n+    val results5 = response5.data.userScramCredentials\n+    assertEquals(1, results5.size)\n+    assertTrue(s\"Expected result to contain '$user1' with 1 credential: $results5\",\n+      results5.asScala.exists(usc => usc.name == user1 && usc.credentialInfos.size == 1))\n+    assertTrue(s\"Expected result to contain '$user1' with SCRAM_SHA_512/8192 credential: $results5\",\n+      results5.asScala.exists(usc => usc.name == user1 && usc.credentialInfos.asScala.exists(info =>\n+        info.mechanism == ScramMechanism.SCRAM_SHA_512.`type` && info.iterations == 8192)))\n+    // now delete the last one\n+    val request6 = new AlterUserScramCredentialsRequest.Builder(\n+      new AlterUserScramCredentialsRequestData()\n+        .setDeletions(util.Arrays.asList(\n+          new AlterUserScramCredentialsRequestData.ScramCredentialDeletion()\n+            .setName(user1).setMechanism(ScramMechanism.SCRAM_SHA_512.`type`),\n+        ))).build()\n+    val response6 = sendAlterUserScramCredentialsRequest(request6)\n+    val results6 = response6.data.results\n+    assertEquals(1, results6.size)\n+    assertEquals(\"Expected no error when deleting the credentials\",\n+      0, results4.asScala.filterNot(_.errorCode == Errors.NONE.code).size)\n+    assertTrue(s\"Expected result to contain '$user1'\", results6.asScala.exists(_.user == user1))\n+    // now describe them all, which should yield 0 credentials\n+    val request7 = new DescribeUserScramCredentialsRequest.Builder(\n+      new DescribeUserScramCredentialsRequestData()).build()\n+    val response7 = sendDescribeUserScramCredentialsRequest(request7)\n+    assertEquals(\"Expected no error when describing the credentials\",\n+      Errors.NONE.code, response7.data.error)\n+    val results7 = response7.data.userScramCredentials\n+    assertEquals(0, results7.size)\n+  }\n+\n+  private def sendAlterUserScramCredentialsRequest(request: AlterUserScramCredentialsRequest, socketServer: SocketServer = controllerSocketServer): AlterUserScramCredentialsResponse = {\n+    connectAndReceive[AlterUserScramCredentialsResponse](request, destination = socketServer)\n+  }\n+\n+  private def sendDescribeUserScramCredentialsRequest(request: DescribeUserScramCredentialsRequest, socketServer: SocketServer = controllerSocketServer): DescribeUserScramCredentialsResponse = {\n+    connectAndReceive[DescribeUserScramCredentialsResponse](request, destination = socketServer)\n+  }\n+}\n+\n+object AlterCredentialsTest {\n+  val UnauthorizedPrincipal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"Unauthorized\")\n+  // Principal used for all client connections. This is modified by tests which\n+  // check unauthorized code path\n+  var principal = KafkaPrincipal.ANONYMOUS", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 377}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NDUzMTA3", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-465453107", "createdAt": "2020-08-11T21:49:47Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTo0OTo0N1rOG_KcQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTo0OTo0N1rOG_KcQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg4NDU0NQ==", "bodyText": "We've always set serialVersionUID in exception classes, to appease the Java gods.\n    private static final long serialVersionUID = 1L;\n\nit's not really necessary since we don't plan on using Java's built-in serialization framework, but I think some tools complain if they don't see it.  And anyway, it's the pattern... for now.", "url": "https://github.com/apache/kafka/pull/9032#discussion_r468884545", "createdAt": "2020-08-11T21:49:47Z", "author": {"login": "cmccabe"}, "path": "clients/src/main/java/org/apache/kafka/common/errors/ResourceNotFoundException.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.errors;\n+\n+/**\n+ * Exception thrown due to a request for a resource that does not exist.\n+ */\n+public class ResourceNotFoundException extends ApiException {\n+    private final String resource;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NDU0NjIx", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-465454621", "createdAt": "2020-08-11T21:52:33Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTo1MjozM1rOG_KhIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTo1MjozM1rOG_KhIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg4NTc5NQ==", "bodyText": "I think we can avoid a trip through BigInteger with something like this:\n      SecureRandom random = new SecureRandom();\n      byte bytes[] = new byte[length];\n      random.nextBytes(bytes);", "url": "https://github.com/apache/kafka/pull/9032#discussion_r468885795", "createdAt": "2020-08-11T21:52:33Z", "author": {"login": "cmccabe"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/UserScramCredentialUpsertion.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.clients.admin;\n+\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.security.SecureRandom;\n+import java.util.Objects;\n+\n+/**\n+ * A request to update/insert a SASL/SCRAM credential for a user.\n+ *\n+ * @see <a href=\"https://cwiki.apache.org/confluence/display/KAFKA/KIP-554%3A+Add+Broker-side+SCRAM+Config+API\">KIP-554: Add Broker-side SCRAM Config API</a>\n+ */\n+public class UserScramCredentialUpsertion extends UserScramCredentialAlteration {\n+    private final ScramCredentialInfo info;\n+    private final byte[] salt;\n+    private final byte[] password;\n+\n+    /**\n+     * Constructor that generates a random salt\n+     *\n+     * @param user the user for which the credential is to be updated/inserted\n+     * @param credentialInfo the mechanism and iterations to be used\n+     * @param password the password\n+     */\n+    public UserScramCredentialUpsertion(String user, ScramCredentialInfo credentialInfo, String password) {\n+        this(user, credentialInfo, password.getBytes(StandardCharsets.UTF_8));\n+    }\n+\n+    /**\n+     * Constructor that generates a random salt\n+     *\n+     * @param user the user for which the credential is to be updated/inserted\n+     * @param credentialInfo the mechanism and iterations to be used\n+     * @param password the password\n+     */\n+    public UserScramCredentialUpsertion(String user, ScramCredentialInfo credentialInfo, byte[] password) {\n+        this(user, credentialInfo, password, generateRandomSalt());\n+    }\n+\n+    /**\n+     * Constructor that accepts an explicit salt\n+     *\n+     * @param user the user for which the credential is to be updated/inserted\n+     * @param credentialInfo the mechanism and iterations to be used\n+     * @param password the password\n+     * @param salt the salt to be used\n+     */\n+    public UserScramCredentialUpsertion(String user, ScramCredentialInfo credentialInfo, byte[] password, byte[] salt) {\n+        super(Objects.requireNonNull(user));\n+        this.info = Objects.requireNonNull(credentialInfo);\n+        this.password = Objects.requireNonNull(password);\n+        this.salt = Objects.requireNonNull(salt);\n+    }\n+\n+    /**\n+     *\n+     * @return the mechanism and iterations\n+     */\n+    public ScramCredentialInfo credentialInfo() {\n+        return info;\n+    }\n+\n+    /**\n+     *\n+     * @return the salt\n+     */\n+    public byte[] salt() {\n+        return salt;\n+    }\n+\n+    /**\n+     *\n+     * @return the password\n+     */\n+    public byte[] password() {\n+        return password;\n+    }\n+\n+    private static byte[] generateRandomSalt() {\n+        return new BigInteger(130, new SecureRandom()).toString(Character.MAX_RADIX).getBytes(StandardCharsets.UTF_8);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5ODM1NjQ5", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-469835649", "createdAt": "2020-08-18T21:14:16Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMToxNDoxNlrOHCm7JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMToxNDoxNlrOHCm7JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ5NjkzMg==", "bodyText": "It would be good to throw the exception here if there is one, so that it wasn't possible to ignore the problem", "url": "https://github.com/apache/kafka/pull/9032#discussion_r472496932", "createdAt": "2020-08-18T21:14:16Z", "author": {"login": "cmccabe"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/UserScramCredentialsDescription.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.clients.admin;\n+\n+import org.apache.kafka.common.errors.ApiException;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * Representation of all SASL/SCRAM credentials associated with a user that can be retrieved, or an exception indicating\n+ * why credentials could not be retrieved.\n+ *\n+ * @see <a href=\"https://cwiki.apache.org/confluence/display/KAFKA/KIP-554%3A+Add+Broker-side+SCRAM+Config+API\">KIP-554: Add Broker-side SCRAM Config API</a>\n+ */\n+public class UserScramCredentialsDescription {\n+    private final String name;\n+    private final Optional<ApiException> exception;\n+    private final List<ScramCredentialInfo> credentialInfos;\n+\n+    /**\n+     * Constructor for when SASL/SCRAM credentials associated with a user could not be retrieved\n+     *\n+     * @param name the required user name\n+     * @param exception the required exception indicating why the credentials for the user could not be retrieved\n+     */\n+    public UserScramCredentialsDescription(String name, ApiException exception) {\n+        this(name, Optional.of(Objects.requireNonNull(exception)), Collections.emptyList());\n+    }\n+\n+    /**\n+     * Constructor for when SASL/SCRAM credentials associated with a user are successfully retrieved\n+     *\n+     * @param name the required user name\n+     * @param credentialInfos the required SASL/SCRAM credential representations for the user\n+     */\n+    public UserScramCredentialsDescription(String name, List<ScramCredentialInfo> credentialInfos) {\n+        this(name, Optional.empty(), Objects.requireNonNull(credentialInfos));\n+    }\n+\n+    private UserScramCredentialsDescription(String name, Optional<ApiException> exception, List<ScramCredentialInfo> credentialInfos) {\n+        this.name = Objects.requireNonNull(name);\n+        this.exception = Objects.requireNonNull(exception);\n+        this.credentialInfos = Collections.unmodifiableList(new ArrayList<>(credentialInfos));\n+    }\n+\n+    /**\n+     *\n+     * @return the user name\n+     */\n+    public String name() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the exception, if any, that prevented the user's SASL/SCRAM credentials from being retrieved\n+     */\n+    public Optional<ApiException> exception() {\n+        return exception;\n+    }\n+\n+    /**\n+     *\n+     * @return the always non-null/unmodifiable list of SASL/SCRAM credential representations for the user\n+     * (empty if {@link #exception} defines an exception)\n+     */\n+    public List<ScramCredentialInfo> credentialInfos() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5ODM3ODAx", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-469837801", "createdAt": "2020-08-18T21:18:12Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMToxODoxMlrOHCnCeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMToxODoxMlrOHCnCeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ5ODgwOQ==", "bodyText": "I know it's not strictly necessary, but it would be nice to have a \"break\" after the default clause too", "url": "https://github.com/apache/kafka/pull/9032#discussion_r472498809", "createdAt": "2020-08-18T21:18:12Z", "author": {"login": "cmccabe"}, "path": "clients/src/test/java/org/apache/kafka/common/protocol/ProtoUtilsTest.java", "diffHunk": "@@ -26,11 +26,18 @@\n     public void testDelayedAllocationSchemaDetection() throws Exception {\n         //verifies that schemas known to retain a reference to the underlying byte buffer are correctly detected.\n         for (ApiKeys key : ApiKeys.values()) {\n-            if (key == ApiKeys.PRODUCE || key == ApiKeys.JOIN_GROUP || key == ApiKeys.SYNC_GROUP || key == ApiKeys.SASL_AUTHENTICATE\n-                || key == ApiKeys.EXPIRE_DELEGATION_TOKEN || key == ApiKeys.RENEW_DELEGATION_TOKEN) {\n-                assertTrue(key + \" should require delayed allocation\", key.requiresDelayedAllocation);\n-            } else {\n-                assertFalse(key + \" should not require delayed allocation\", key.requiresDelayedAllocation);\n+            switch (key) {\n+                case PRODUCE:\n+                case JOIN_GROUP:\n+                case SYNC_GROUP:\n+                case SASL_AUTHENTICATE:\n+                case EXPIRE_DELEGATION_TOKEN:\n+                case RENEW_DELEGATION_TOKEN:\n+                case ALTER_USER_SCRAM_CREDENTIALS:\n+                    assertTrue(key + \" should require delayed allocation\", key.requiresDelayedAllocation);\n+                    break;\n+                default:\n+                    assertFalse(key + \" should not require delayed allocation\", key.requiresDelayedAllocation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5ODQwNjQw", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-469840640", "createdAt": "2020-08-18T21:23:20Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMToyMzoyMFrOHCnLmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMToyMzoyMFrOHCnLmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUwMTE0Nw==", "bodyText": "sorry, this might be a silly question, but how are these constraints different when using --zookeeper?  should we test that as well", "url": "https://github.com/apache/kafka/pull/9032#discussion_r472501147", "createdAt": "2020-08-18T21:23:20Z", "author": {"login": "cmccabe"}, "path": "core/src/test/scala/unit/kafka/admin/ConfigCommandTest.scala", "diffHunk": "@@ -486,7 +486,9 @@ class ConfigCommandTest extends ZooKeeperTestHarness with Logging {\n   }\n \n   @Test\n-  def shouldNotAlterNonQuotaClientConfigUsingBootstrapServer(): Unit = {\n+  def shouldNotAlterNonQuotaNonScramUserOrClientConfigUsingBootstrapServer(): Unit = {\n+    // when using --bootstrap-server, it should be illegal to alter anything that is not a quota and not a SCRAM credential\n+    // for both user and client entities", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 7}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMTUzMjM5", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-472153239", "createdAt": "2020-08-21T05:28:19Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNToyODoxOVrOHEcEcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNToyODoxOVrOHEcEcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxNjI0Mw==", "bodyText": "Based on our offline discussion, I thought we were going to have three methods here:\nKafkaFuture<Map<String, UserScramCredentialsDescription>> all()\n\nReturns all the users that were listed, or throws an exception if there was an error describing any of them.\nKafkaFuture<List<String>> users();\n\nReturns the names of all the users that were described, whether the describing was successful or not.\nKafkaFuture<UserScramCredentialDescription> description(String userName);\n\nReturns a future describing userName, or RESOURCE_NOT_FOUND if the user was not listed or not found.", "url": "https://github.com/apache/kafka/pull/9032#discussion_r474416243", "createdAt": "2020-08-21T05:28:19Z", "author": {"login": "cmccabe"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/DescribeUserScramCredentialsResult.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.clients.admin;\n+\n+import org.apache.kafka.common.KafkaFuture;\n+import org.apache.kafka.common.annotation.InterfaceStability;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * The result of the {@link Admin#describeUserScramCredentials()} call.\n+ *\n+ * The API of this class is evolving, see {@link Admin} for details.\n+ */\n+@InterfaceStability.Evolving\n+public class DescribeUserScramCredentialsResult {\n+    private final KafkaFuture<List<UserScramCredentialsDescriptionResult>> future;\n+\n+    /**\n+     *\n+     * @param future the required future representing the result of the call\n+     */\n+    public DescribeUserScramCredentialsResult(KafkaFuture<List<UserScramCredentialsDescriptionResult>> future) {\n+        this.future = Objects.requireNonNull(future);\n+    }\n+\n+    /**\n+     *\n+     * @return the future representing the result of the call\n+     */\n+    public KafkaFuture<List<UserScramCredentialsDescriptionResult>> future() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyMTUzNzE2", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-472153716", "createdAt": "2020-08-21T05:29:57Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNToyOTo1OFrOHEcGKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNToyOTo1OFrOHEcGKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQxNjY4Mg==", "bodyText": "As I commented above, I think we should not have the exception here.", "url": "https://github.com/apache/kafka/pull/9032#discussion_r474416682", "createdAt": "2020-08-21T05:29:58Z", "author": {"login": "cmccabe"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/UserScramCredentialsDescription.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.clients.admin;\n+\n+import org.apache.kafka.common.errors.ApiException;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * Representation of all SASL/SCRAM credentials associated with a user that can be retrieved, or an exception indicating\n+ * why credentials could not be retrieved.\n+ *\n+ * @see <a href=\"https://cwiki.apache.org/confluence/display/KAFKA/KIP-554%3A+Add+Broker-side+SCRAM+Config+API\">KIP-554: Add Broker-side SCRAM Config API</a>\n+ */\n+public class UserScramCredentialsDescription {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNjA2OTYw", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-473606960", "createdAt": "2020-08-24T15:22:02Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNToyMjowMlrOHFqKhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNToyMjowMlrOHFqKhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY5NTc1MA==", "bodyText": "We don't need this extra future, right?  We can just use requestedUserFuture directly if we want to use that", "url": "https://github.com/apache/kafka/pull/9032#discussion_r475695750", "createdAt": "2020-08-24T15:22:02Z", "author": {"login": "cmccabe"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/DescribeUserScramCredentialsResult.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.clients.admin;\n+\n+import org.apache.kafka.common.KafkaFuture;\n+import org.apache.kafka.common.annotation.InterfaceStability;\n+import org.apache.kafka.common.errors.ResourceNotFoundException;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The result of the {@link Admin#describeUserScramCredentials()} call.\n+ *\n+ * The API of this class is evolving, see {@link Admin} for details.\n+ */\n+@InterfaceStability.Evolving\n+public class DescribeUserScramCredentialsResult {\n+    private final KafkaFuture<List<String>> usersFuture;\n+    private final Map<String, KafkaFuture<UserScramCredentialsDescription>> perUserFutures;\n+\n+    /**\n+     *\n+     * @param usersFuture the future indicating the users described by the call\n+     * @param perUserFutures the required map of user names to futures representing the results of describing each\n+     *                       user's SCRAM credentials.\n+     */\n+    public DescribeUserScramCredentialsResult(KafkaFuture<List<String>> usersFuture,\n+                                              Map<String, KafkaFuture<UserScramCredentialsDescription>> perUserFutures) {\n+        this.usersFuture = Objects.requireNonNull(usersFuture);\n+        this.perUserFutures = Objects.requireNonNull(perUserFutures);\n+    }\n+\n+    /**\n+     *\n+     * @return a future for the results of all requested (either explicitly or implicitly via describe-all) users.\n+     * The future will complete successfully only if the users future first completes successfully and then all the\n+     * futures for the user descriptions complete successfully.\n+     */\n+    public KafkaFuture<Map<String, UserScramCredentialsDescription>> all() {\n+        KafkaFuture<Void> succeedsOnlyIfUsersFutureSucceeds = KafkaFuture.allOf(users());\n+        return succeedsOnlyIfUsersFutureSucceeds.thenApply(void1 -> {\n+            KafkaFuture<Void> succeedsOnlyIfAllDescriptionsSucceed = KafkaFuture.allOf(perUserFutures.values().toArray(\n+                    new KafkaFuture[perUserFutures.size()]));\n+            KafkaFuture<Map<String, UserScramCredentialsDescription>> mapFuture = succeedsOnlyIfAllDescriptionsSucceed.thenApply(void2 ->\n+                perUserFutures.entrySet().stream().collect(Collectors.toMap(\n+                    e -> e.getKey(),\n+                    e -> valueFromFutureGuaranteedToSucceedAtThisPoint(e.getValue()))));\n+            /* At this point it is only the users future that is guaranteed to have succeeded.\n+             * We want to return the future to the map, but we have to return a map at this point.\n+             * We need to dereference the future while propagating any exception.\n+             */\n+            return valueFromFuturePropagatingExceptionsAsUnchecked(mapFuture);\n+        });\n+    }\n+\n+    /**\n+     *\n+     * @return a future indicating the distinct users that were requested (either explicitly or implicitly via\n+     * describe-all).  The future will not complete successfully if the user is not authorized to perform the describe\n+     * operation; otherwise, it will complete successfully as long as the list of users with credentials can be\n+     * successfully determined within some hard-coded timeout period.\n+     */\n+    public KafkaFuture<List<String>> users() {\n+        return usersFuture;\n+    }\n+\n+    /**\n+     *\n+     * @param userName the name of the user description being requested\n+     * @return a future indicating the description results for the given user. The future will complete exceptionally if\n+     * the future returned by {@link #users()} completes exceptionally.  If the given user does not exist in the list\n+     * of requested users then the future will complete exceptionally with\n+     * {@link org.apache.kafka.common.errors.ResourceNotFoundException}.\n+     */\n+    public KafkaFuture<UserScramCredentialsDescription> description(String userName) {\n+        KafkaFuture<Void> succeedsOnlyIfUsersFutureSucceeds = KafkaFuture.allOf(usersFuture);\n+        return succeedsOnlyIfUsersFutureSucceeds.thenApply(void1 -> {\n+            // it is possible that there is no future for this user (for example, the original describe request was for\n+            // users 1, 2, and 3 but this is looking for user 4), so explicitly take care of that case\n+            KafkaFuture<UserScramCredentialsDescription> requestedUserFuture = perUserFutures.get(userName);\n+            if (requestedUserFuture == null) {\n+                throw new ResourceNotFoundException(\"No such user: \" + userName);\n+            }\n+            KafkaFuture<Void> succeedsOnlyIfRequestedUserFutureSucceeds = KafkaFuture.allOf(requestedUserFuture);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 103}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNjA3OTU5", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-473607959", "createdAt": "2020-08-24T15:23:14Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNToyMzoxNVrOHFqNqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNToyMzoxNVrOHFqNqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY5NjU1NA==", "bodyText": "You should not be calling get() here.\nIn general it seems like what you really want is a single future behind the scenes that returns everything that you fetched from your single RPC.  Then you just need a few translation functions that pull out the part you need for each future that you're returning to the user.", "url": "https://github.com/apache/kafka/pull/9032#discussion_r475696554", "createdAt": "2020-08-24T15:23:15Z", "author": {"login": "cmccabe"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/DescribeUserScramCredentialsResult.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.clients.admin;\n+\n+import org.apache.kafka.common.KafkaFuture;\n+import org.apache.kafka.common.annotation.InterfaceStability;\n+import org.apache.kafka.common.errors.ResourceNotFoundException;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The result of the {@link Admin#describeUserScramCredentials()} call.\n+ *\n+ * The API of this class is evolving, see {@link Admin} for details.\n+ */\n+@InterfaceStability.Evolving\n+public class DescribeUserScramCredentialsResult {\n+    private final KafkaFuture<List<String>> usersFuture;\n+    private final Map<String, KafkaFuture<UserScramCredentialsDescription>> perUserFutures;\n+\n+    /**\n+     *\n+     * @param usersFuture the future indicating the users described by the call\n+     * @param perUserFutures the required map of user names to futures representing the results of describing each\n+     *                       user's SCRAM credentials.\n+     */\n+    public DescribeUserScramCredentialsResult(KafkaFuture<List<String>> usersFuture,\n+                                              Map<String, KafkaFuture<UserScramCredentialsDescription>> perUserFutures) {\n+        this.usersFuture = Objects.requireNonNull(usersFuture);\n+        this.perUserFutures = Objects.requireNonNull(perUserFutures);\n+    }\n+\n+    /**\n+     *\n+     * @return a future for the results of all requested (either explicitly or implicitly via describe-all) users.\n+     * The future will complete successfully only if the users future first completes successfully and then all the\n+     * futures for the user descriptions complete successfully.\n+     */\n+    public KafkaFuture<Map<String, UserScramCredentialsDescription>> all() {\n+        KafkaFuture<Void> succeedsOnlyIfUsersFutureSucceeds = KafkaFuture.allOf(users());\n+        return succeedsOnlyIfUsersFutureSucceeds.thenApply(void1 -> {\n+            KafkaFuture<Void> succeedsOnlyIfAllDescriptionsSucceed = KafkaFuture.allOf(perUserFutures.values().toArray(\n+                    new KafkaFuture[perUserFutures.size()]));\n+            KafkaFuture<Map<String, UserScramCredentialsDescription>> mapFuture = succeedsOnlyIfAllDescriptionsSucceed.thenApply(void2 ->\n+                perUserFutures.entrySet().stream().collect(Collectors.toMap(\n+                    e -> e.getKey(),\n+                    e -> valueFromFutureGuaranteedToSucceedAtThisPoint(e.getValue()))));\n+            /* At this point it is only the users future that is guaranteed to have succeeded.\n+             * We want to return the future to the map, but we have to return a map at this point.\n+             * We need to dereference the future while propagating any exception.\n+             */\n+            return valueFromFuturePropagatingExceptionsAsUnchecked(mapFuture);\n+        });\n+    }\n+\n+    /**\n+     *\n+     * @return a future indicating the distinct users that were requested (either explicitly or implicitly via\n+     * describe-all).  The future will not complete successfully if the user is not authorized to perform the describe\n+     * operation; otherwise, it will complete successfully as long as the list of users with credentials can be\n+     * successfully determined within some hard-coded timeout period.\n+     */\n+    public KafkaFuture<List<String>> users() {\n+        return usersFuture;\n+    }\n+\n+    /**\n+     *\n+     * @param userName the name of the user description being requested\n+     * @return a future indicating the description results for the given user. The future will complete exceptionally if\n+     * the future returned by {@link #users()} completes exceptionally.  If the given user does not exist in the list\n+     * of requested users then the future will complete exceptionally with\n+     * {@link org.apache.kafka.common.errors.ResourceNotFoundException}.\n+     */\n+    public KafkaFuture<UserScramCredentialsDescription> description(String userName) {\n+        KafkaFuture<Void> succeedsOnlyIfUsersFutureSucceeds = KafkaFuture.allOf(usersFuture);\n+        return succeedsOnlyIfUsersFutureSucceeds.thenApply(void1 -> {\n+            // it is possible that there is no future for this user (for example, the original describe request was for\n+            // users 1, 2, and 3 but this is looking for user 4), so explicitly take care of that case\n+            KafkaFuture<UserScramCredentialsDescription> requestedUserFuture = perUserFutures.get(userName);\n+            if (requestedUserFuture == null) {\n+                throw new ResourceNotFoundException(\"No such user: \" + userName);\n+            }\n+            KafkaFuture<Void> succeedsOnlyIfRequestedUserFutureSucceeds = KafkaFuture.allOf(requestedUserFuture);\n+            KafkaFuture<UserScramCredentialsDescription> descriptionFuture = succeedsOnlyIfRequestedUserFutureSucceeds.thenApply(void2 ->\n+                valueFromFutureGuaranteedToSucceedAtThisPoint(requestedUserFuture));\n+            /* At this point it is only the users future that is guaranteed to have succeeded.\n+             * We want to return the future to the description, but we have to return a description at this point.\n+             * We need to dereference the future while propagating any exception.\n+             */\n+            return valueFromFuturePropagatingExceptionsAsUnchecked(descriptionFuture);\n+        });\n+    }\n+\n+    private static <T> T valueFromFutureGuaranteedToSucceedAtThisPoint(KafkaFuture<T> future) {\n+        try {\n+            return future.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNjEwODgx", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-473610881", "createdAt": "2020-08-24T15:26:31Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNToyNjozMVrOHFqWfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNToyNjozMVrOHFqWfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY5ODgxMw==", "bodyText": "I think it would be better to make this \"a future indicating the users that were listed\" (rather than \"requested\").  It's maybe a bit of a subtle distinction but think about things like requesting the null user, or the empty string user.  It's awkward to put that here.  I think if we explicitly request a user but it doesn't exist, it should be omitted from here as well.  That gives us more flexibility in the future with the API.", "url": "https://github.com/apache/kafka/pull/9032#discussion_r475698813", "createdAt": "2020-08-24T15:26:31Z", "author": {"login": "cmccabe"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/DescribeUserScramCredentialsResult.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.clients.admin;\n+\n+import org.apache.kafka.common.KafkaFuture;\n+import org.apache.kafka.common.annotation.InterfaceStability;\n+import org.apache.kafka.common.errors.ResourceNotFoundException;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The result of the {@link Admin#describeUserScramCredentials()} call.\n+ *\n+ * The API of this class is evolving, see {@link Admin} for details.\n+ */\n+@InterfaceStability.Evolving\n+public class DescribeUserScramCredentialsResult {\n+    private final KafkaFuture<List<String>> usersFuture;\n+    private final Map<String, KafkaFuture<UserScramCredentialsDescription>> perUserFutures;\n+\n+    /**\n+     *\n+     * @param usersFuture the future indicating the users described by the call\n+     * @param perUserFutures the required map of user names to futures representing the results of describing each\n+     *                       user's SCRAM credentials.\n+     */\n+    public DescribeUserScramCredentialsResult(KafkaFuture<List<String>> usersFuture,\n+                                              Map<String, KafkaFuture<UserScramCredentialsDescription>> perUserFutures) {\n+        this.usersFuture = Objects.requireNonNull(usersFuture);\n+        this.perUserFutures = Objects.requireNonNull(perUserFutures);\n+    }\n+\n+    /**\n+     *\n+     * @return a future for the results of all requested (either explicitly or implicitly via describe-all) users.\n+     * The future will complete successfully only if the users future first completes successfully and then all the\n+     * futures for the user descriptions complete successfully.\n+     */\n+    public KafkaFuture<Map<String, UserScramCredentialsDescription>> all() {\n+        KafkaFuture<Void> succeedsOnlyIfUsersFutureSucceeds = KafkaFuture.allOf(users());\n+        return succeedsOnlyIfUsersFutureSucceeds.thenApply(void1 -> {\n+            KafkaFuture<Void> succeedsOnlyIfAllDescriptionsSucceed = KafkaFuture.allOf(perUserFutures.values().toArray(\n+                    new KafkaFuture[perUserFutures.size()]));\n+            KafkaFuture<Map<String, UserScramCredentialsDescription>> mapFuture = succeedsOnlyIfAllDescriptionsSucceed.thenApply(void2 ->\n+                perUserFutures.entrySet().stream().collect(Collectors.toMap(\n+                    e -> e.getKey(),\n+                    e -> valueFromFutureGuaranteedToSucceedAtThisPoint(e.getValue()))));\n+            /* At this point it is only the users future that is guaranteed to have succeeded.\n+             * We want to return the future to the map, but we have to return a map at this point.\n+             * We need to dereference the future while propagating any exception.\n+             */\n+            return valueFromFuturePropagatingExceptionsAsUnchecked(mapFuture);\n+        });\n+    }\n+\n+    /**\n+     *\n+     * @return a future indicating the distinct users that were requested (either explicitly or implicitly via", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MDE3OTUx", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-477017951", "createdAt": "2020-08-27T19:28:35Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOToyODozNVrOHIeP_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOToyODozNVrOHIeP_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY0NjI3MQ==", "bodyText": "I think we should just have a separate function for this, since there's no code shared between when creating_broker_user=True and when it is False.", "url": "https://github.com/apache/kafka/pull/9032#discussion_r478646271", "createdAt": "2020-08-27T19:28:35Z", "author": {"login": "cmccabe"}, "path": "tests/kafkatest/services/security/security_config.py", "diffHunk": "@@ -276,18 +287,19 @@ def setup_node(self, node):\n         if java_version(node) <= 11 and self.properties.get('tls.version') == 'TLSv1.3':\n             self.properties.update({'tls.version': 'TLSv1.2'})\n \n-    def setup_credentials(self, node, path, zk_connect, broker):\n-        if broker:\n-            self.maybe_create_scram_credentials(node, zk_connect, path, self.interbroker_sasl_mechanism,\n+    def setup_credentials(self, node, path, connect, creating_broker_user):", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MDE4Nzk3", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-477018797", "createdAt": "2020-08-27T19:29:57Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOToyOTo1OFrOHIeSpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOToyOTo1OFrOHIeSpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY0Njk1MA==", "bodyText": "As we discussed offline, I think eventually the admin client should log in as its own admin user, not as the broker.  But we can save that for a follow-on.", "url": "https://github.com/apache/kafka/pull/9032#discussion_r478646950", "createdAt": "2020-08-27T19:29:58Z", "author": {"login": "cmccabe"}, "path": "tests/kafkatest/services/security/security_config.py", "diffHunk": "@@ -350,6 +362,14 @@ def kafka_opts(self):\n         else:\n             return \"\"\n \n+    def export_kafka_opts_for_admin_client_as_broker(self):", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 75}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MDI1NTEy", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-477025512", "createdAt": "2020-08-27T19:40:21Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTo0MDoyMlrOHIenXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTo0MDoyMlrOHIenXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1MjI1NA==", "bodyText": "It's sort of weird that we're creating files on the fly with '<(echo '%s') rather than just using a file in /mnt/security.  This will result in some pretty long command lines, right?\nConsidering this is an existing pattern in kafka.py (but nowhere else?), let's file a follow-on JIRA to look into this and fix it.  Unless there's some really good reason why kafka.py is doing this, but I can't think of any.", "url": "https://github.com/apache/kafka/pull/9032#discussion_r478652254", "createdAt": "2020-08-27T19:40:22Z", "author": {"login": "cmccabe"}, "path": "tests/kafkatest/services/kafka/kafka.py", "diffHunk": "@@ -575,10 +577,21 @@ def set_unclean_leader_election(self, topic, value=True, node=None):\n         node.account.ssh(cmd)\n \n     def _connect_setting_kafka_configs(self, node):\n+        # Use this for everything related to kafka-configs except User SCRAM Credentials\n         if node.version.kafka_configs_command_uses_bootstrap_server():\n-            return \"--bootstrap-server %s \" % self.bootstrap_servers(self.security_protocol)\n+            return \"--bootstrap-server %s --command-config <(echo '%s')\" % (self.bootstrap_servers(self.security_protocol),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MDMwNTE5", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-477030519", "createdAt": "2020-08-27T19:47:58Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTo0Nzo1OFrOHIe3OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTo0Nzo1OFrOHIe3OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1NjMxMw==", "bodyText": "I don't think this is quite right.  It should be self >= V_2_7_0, right?  And we should add 2.7 to the version.py file.\nmaster branch is already identifying itself as 2.7 anyway.\n[cmccabe@zeratul kafka2]$ git grep 2.7.0 | tail -n 10\ndocs/upgrade.html:<h5><a id=\"upgrade_270_notable\" href=\"#upgrade_270_notable\">Notable changes in 2.7.0</a></h5>\ngradle.properties:version=2.7.0-SNAPSHOT\nkafka-merge-pr.py:DEFAULT_FIX_VERSION = os.environ.get(\"DEFAULT_FIX_VERSION\", \"2.7.0\")\nstreams/quickstart/java/pom.xml:        <version>2.7.0-SNAPSHOT</version>\nstreams/quickstart/java/src/main/resources/archetype-resources/pom.xml:        <kafka.version>2.7.0-SNAPSHOT</kafka.version>\nstreams/quickstart/pom.xml:    <version>2.7.0-SNAPSHOT</version>\nstreams/src/main/java/org/apache/kafka/streams/StreamsBuilder.java:     * @deprecated Since 2.7.0; use {@link #addGlobalStore(StoreBuilder, String, Consumed, ProcessorSupplier)} instead.\nstreams/streams-scala/src/main/scala/org/apache/kafka/streams/scala/StreamsBuilder.scala:    \"2.7.0\"\ntests/kafkatest/__init__.py:__version__ = '2.7.0.dev0'\ntests/kafkatest/version.py:DEV_VERSION = KafkaVersion(\"2.7.0-SNAPSHOT\")\n\nSimilarly supports_tls_to_zookeeper should be checking for 2.5 and later, not \"after 2.4\" (they should be the same, but what if someone messed up incrementing LATEST_2_4, etc....)  It's always better to be explicit about what version something appeared in than to say it happened \"after (but not including) some version X\"", "url": "https://github.com/apache/kafka/pull/9032#discussion_r478656313", "createdAt": "2020-08-27T19:47:58Z", "author": {"login": "cmccabe"}, "path": "tests/kafkatest/version.py", "diffHunk": "@@ -63,8 +63,13 @@ def reassign_partitions_command_supports_bootstrap_server(self):\n         return self >= V_2_5_0\n \n     def kafka_configs_command_uses_bootstrap_server(self):\n+        # everything except User SCRAM Credentials (KIP-554)\n         return self >= V_2_6_0\n \n+    def kafka_configs_command_uses_bootstrap_server_scram(self):\n+        # User SCRAM Credentials (KIP-554)\n+        return self > LATEST_2_6", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MDMxNjk0", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-477031694", "createdAt": "2020-08-27T19:49:53Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTo0OTo1M1rOHIe6-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxOTo0OTo1M1rOHIe6-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODY1NzI3NQ==", "bodyText": "Can we not have these be naked constants?  Maybe we could iterate over an enum or something?  If we add another mechanism, it would be nice not to have to manually edit this.", "url": "https://github.com/apache/kafka/pull/9032#discussion_r478657275", "createdAt": "2020-08-27T19:49:53Z", "author": {"login": "cmccabe"}, "path": "core/src/test/scala/unit/kafka/utils/JaasTestUtils.scala", "diffHunk": "@@ -169,6 +169,18 @@ object JaasTestUtils {\n     jaasFile\n   }\n \n+  // Returns a SASL/SCRAM configuration using credentials for the given user and password\n+  def scramClientLoginModule(mechanism: String, scramUser: String, scramPassword: String): String = {\n+    mechanism match {\n+      case \"SCRAM-SHA-256\" | \"SCRAM-SHA-512\" =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDM5NTcw", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-478039570", "createdAt": "2020-08-28T21:39:04Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMTozOTowNFrOHJVKUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMTozOTowNFrOHJVKUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU0NTkzNg==", "bodyText": "There's no reason to call allOf on a single future.  After all, allOf's function is convert multiple futures to a single one.  But if you already have a single future, this is not needed.\nYou could use dataFuture.thenApply, but that will not trigger if dataFuture is completed exceptionally.\nInstead, what you want here is something like the following:\ndataFuture.whenComplete( (data, exception) -> if (exception != null) { ... error ... }  else { ... handle data ... }", "url": "https://github.com/apache/kafka/pull/9032#discussion_r479545936", "createdAt": "2020-08-28T21:39:04Z", "author": {"login": "cmccabe"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/DescribeUserScramCredentialsResult.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.clients.admin;\n+\n+import org.apache.kafka.common.KafkaFuture;\n+import org.apache.kafka.common.annotation.InterfaceStability;\n+import org.apache.kafka.common.errors.ResourceNotFoundException;\n+import org.apache.kafka.common.message.DescribeUserScramCredentialsResponseData;\n+import org.apache.kafka.common.protocol.Errors;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The result of the {@link Admin#describeUserScramCredentials()} call.\n+ *\n+ * The API of this class is evolving, see {@link Admin} for details.\n+ */\n+@InterfaceStability.Evolving\n+public class DescribeUserScramCredentialsResult {\n+    private final KafkaFuture<DescribeUserScramCredentialsResponseData> dataFuture;\n+\n+    /**\n+     * Package-private constructor\n+     *\n+     * @param dataFuture the future indicating response data from the call\n+     */\n+    DescribeUserScramCredentialsResult(KafkaFuture<DescribeUserScramCredentialsResponseData> dataFuture) {\n+        this.dataFuture = Objects.requireNonNull(dataFuture);\n+    }\n+\n+    /**\n+     *\n+     * @return a future for the results of all described users with map keys (one per user) being consistent with the\n+     * contents of the list returned by {@link #users()}. The future will complete successfully only if all such user\n+     * descriptions complete successfully.\n+     */\n+    public KafkaFuture<Map<String, UserScramCredentialsDescription>> all() {\n+        return KafkaFuture.allOf(dataFuture).thenApply(v -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDQwMTgy", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-478040182", "createdAt": "2020-08-28T21:40:42Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMTo0MDo0MlrOHJVMiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMTo0MDo0MlrOHJVMiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU0NjUwNQ==", "bodyText": "The call to get() here isn't needed.  See the comment about about using KafkaFuture#whenComplete.  Chaining future results is a big part of the power of CompletableFuture (which KafkaFuture is a clone of... long story...)", "url": "https://github.com/apache/kafka/pull/9032#discussion_r479546505", "createdAt": "2020-08-28T21:40:42Z", "author": {"login": "cmccabe"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/DescribeUserScramCredentialsResult.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.clients.admin;\n+\n+import org.apache.kafka.common.KafkaFuture;\n+import org.apache.kafka.common.annotation.InterfaceStability;\n+import org.apache.kafka.common.errors.ResourceNotFoundException;\n+import org.apache.kafka.common.message.DescribeUserScramCredentialsResponseData;\n+import org.apache.kafka.common.protocol.Errors;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The result of the {@link Admin#describeUserScramCredentials()} call.\n+ *\n+ * The API of this class is evolving, see {@link Admin} for details.\n+ */\n+@InterfaceStability.Evolving\n+public class DescribeUserScramCredentialsResult {\n+    private final KafkaFuture<DescribeUserScramCredentialsResponseData> dataFuture;\n+\n+    /**\n+     * Package-private constructor\n+     *\n+     * @param dataFuture the future indicating response data from the call\n+     */\n+    DescribeUserScramCredentialsResult(KafkaFuture<DescribeUserScramCredentialsResponseData> dataFuture) {\n+        this.dataFuture = Objects.requireNonNull(dataFuture);\n+    }\n+\n+    /**\n+     *\n+     * @return a future for the results of all described users with map keys (one per user) being consistent with the\n+     * contents of the list returned by {@link #users()}. The future will complete successfully only if all such user\n+     * descriptions complete successfully.\n+     */\n+    public KafkaFuture<Map<String, UserScramCredentialsDescription>> all() {\n+        return KafkaFuture.allOf(dataFuture).thenApply(v -> {\n+            DescribeUserScramCredentialsResponseData data = valueFromFutureGuaranteedToSucceedAtThisPoint(dataFuture);\n+            /* Check to make sure every individual described user succeeded.  Note that a successfully described user\n+             * is one that appears with *either* a NONE error code or a RESOURCE_NOT_FOUND error code. The\n+             * RESOURCE_NOT_FOUND means the client explicitly requested a describe of that particular user but it could\n+             * not be described because it does not exist; such a user will not appear as a key in the returned map.\n+             */\n+            Optional<DescribeUserScramCredentialsResponseData.DescribeUserScramCredentialsResult> optionalFirstFailedDescribe =\n+                    data.results().stream().filter(result ->\n+                        result.errorCode() != Errors.NONE.code() && result.errorCode() != Errors.RESOURCE_NOT_FOUND.code()).findFirst();\n+            if (optionalFirstFailedDescribe.isPresent()) {\n+                throw Errors.forCode(optionalFirstFailedDescribe.get().errorCode()).exception(optionalFirstFailedDescribe.get().errorMessage());\n+            }\n+            Map<String, UserScramCredentialsDescription> retval = new HashMap<>();\n+            data.results().stream().forEach(userResult ->\n+                    retval.put(userResult.user(), new UserScramCredentialsDescription(userResult.user(),\n+                            getScramCredentialInfosFor(userResult))));\n+            return retval;\n+        });\n+    }\n+\n+    /**\n+     *\n+     * @return a future indicating the distinct users that meet the request criteria and that have at least one\n+     * credential.  The future will not complete successfully if the user is not authorized to perform the describe\n+     * operation; otherwise, it will complete successfully as long as the list of users with credentials can be\n+     * successfully determined within some hard-coded timeout period. Note that the returned list will not include users\n+     * that do not exist/have no credentials: a request to describe an explicit list of users, none of which existed/had\n+     * a credential, will result in a future that returns an empty list being returned here. A returned list will\n+     * include users that have a credential but that could not be described.\n+     */\n+    public KafkaFuture<List<String>> users() {\n+        return KafkaFuture.allOf(dataFuture).thenApply(v -> {\n+            DescribeUserScramCredentialsResponseData data = valueFromFutureGuaranteedToSucceedAtThisPoint(dataFuture);\n+            return data.results().stream()\n+                    .filter(result -> result.errorCode() != Errors.RESOURCE_NOT_FOUND.code())\n+                    .map(result -> result.user()).collect(Collectors.toList());\n+        });\n+    }\n+\n+    /**\n+     *\n+     * @param userName the name of the user description being requested\n+     * @return a future indicating the description results for the given user. The future will complete exceptionally if\n+     * the future returned by {@link #users()} completes exceptionally.  Note that if the given user does not exist in\n+     * the list of described users then the returned future will complete exceptionally with\n+     * {@link org.apache.kafka.common.errors.ResourceNotFoundException}.\n+     */\n+    public KafkaFuture<UserScramCredentialsDescription> description(String userName) {\n+        return KafkaFuture.allOf(dataFuture).thenApply(v -> {\n+            DescribeUserScramCredentialsResponseData data = valueFromFutureGuaranteedToSucceedAtThisPoint(dataFuture);\n+            // it is possible that there is no future for this user (for example, the original describe request was for\n+            // users 1, 2, and 3 but this is looking for user 4), so explicitly take care of that case\n+            Optional<DescribeUserScramCredentialsResponseData.DescribeUserScramCredentialsResult> optionalUserResult =\n+                    data.results().stream().filter(result -> result.user().equals(userName)).findFirst();\n+            if (!optionalUserResult.isPresent()) {\n+                throw new ResourceNotFoundException(\"No such user: \" + userName);\n+            }\n+            DescribeUserScramCredentialsResponseData.DescribeUserScramCredentialsResult userResult = optionalUserResult.get();\n+            if (userResult.errorCode() != Errors.NONE.code()) {\n+                // RESOURCE_NOT_FOUND is included here\n+                throw Errors.forCode(userResult.errorCode()).exception(userResult.errorMessage());\n+            }\n+            return new UserScramCredentialsDescription(userResult.user(), getScramCredentialInfosFor(userResult));\n+        });\n+    }\n+\n+    private static List<ScramCredentialInfo> getScramCredentialInfosFor(\n+            DescribeUserScramCredentialsResponseData.DescribeUserScramCredentialsResult userResult) {\n+        return userResult.credentialInfos().stream().map(c ->\n+                new ScramCredentialInfo(ScramMechanism.fromType(c.mechanism()), c.iterations()))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private static <T> T valueFromFutureGuaranteedToSucceedAtThisPoint(KafkaFuture<T> future) {\n+        try {\n+            return future.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 135}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDQyMDQ3", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-478042047", "createdAt": "2020-08-28T21:46:06Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMTo0NjowNlrOHJVS2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMTo0NjowNlrOHJVS2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU0ODEyMQ==", "bodyText": "This should go with the other java imports, which I guess are combined in this file", "url": "https://github.com/apache/kafka/pull/9032#discussion_r479548121", "createdAt": "2020-08-28T21:46:06Z", "author": {"login": "cmccabe"}, "path": "core/src/test/scala/unit/kafka/server/ClientQuotasRequestTest.scala", "diffHunk": "@@ -17,6 +17,8 @@\n \n package kafka.server\n \n+import java.util", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDQ1NDkw", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-478045490", "createdAt": "2020-08-28T21:55:43Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMTo1NTo0M1rOHJVeVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMTo1NTo0M1rOHJVeVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1MTA2MQ==", "bodyText": "is it useful to log the exception here at debug level?", "url": "https://github.com/apache/kafka/pull/9032#discussion_r479551061", "createdAt": "2020-08-28T21:55:43Z", "author": {"login": "cmccabe"}, "path": "core/src/test/scala/unit/kafka/admin/UserScramCredentialsCommandTest.scala", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.admin\n+\n+import java.io.{ByteArrayOutputStream, PrintStream}\n+import java.nio.charset.StandardCharsets\n+\n+import kafka.server.BaseRequestTest\n+import kafka.utils.Exit\n+import org.junit.Assert._\n+import org.junit.Test\n+\n+class UserScramCredentialsCommandTest extends BaseRequestTest {\n+  override def brokerCount = 1\n+  var exitStatus: Option[Int] = None\n+  var exitMessage: Option[String] = None\n+\n+  case class ConfigCommandResult(stdout: String, exitStatus: Option[Int] = None)\n+\n+  private def runConfigCommandViaBroker(args: Array[String]) : ConfigCommandResult = {\n+    val byteArrayOutputStream = new ByteArrayOutputStream()\n+    val utf8 = StandardCharsets.UTF_8.name\n+    val printStream = new PrintStream(byteArrayOutputStream, true, utf8)\n+    var exitStatus: Option[Int] = None\n+    Exit.setExitProcedure { (status, _) =>\n+      exitStatus = Some(status)\n+      throw new RuntimeException\n+    }\n+    try {\n+      Console.withOut(printStream) {\n+        ConfigCommand.main(Array(\"--bootstrap-server\", brokerList) ++ args)\n+      }\n+      ConfigCommandResult(byteArrayOutputStream.toString(utf8))\n+    } catch {\n+      case e: Exception => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDQ3NjE5", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-478047619", "createdAt": "2020-08-28T22:02:03Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjowMjowM1rOHJVlKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjowMjowM1rOHJVlKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1MjgxMA==", "bodyText": "Is it necessary to wait for the change to be applied on all brokers after completing the admin client call?", "url": "https://github.com/apache/kafka/pull/9032#discussion_r479552810", "createdAt": "2020-08-28T22:02:03Z", "author": {"login": "cmccabe"}, "path": "core/src/test/scala/integration/kafka/server/DynamicBrokerReconfigurationTest.scala", "diffHunk": "@@ -1047,8 +1047,8 @@ class DynamicBrokerReconfigurationTest extends ZooKeeperTestHarness with SaslSet\n \n   @Test\n   def testAddRemoveSaslListeners(): Unit = {\n-    createScramCredentials(zkConnect, JaasTestUtils.KafkaScramUser, JaasTestUtils.KafkaScramPassword)\n-    createScramCredentials(zkConnect, JaasTestUtils.KafkaScramAdmin, JaasTestUtils.KafkaScramAdminPassword)\n+    createScramCredentials(adminClients.head, JaasTestUtils.KafkaScramUser, JaasTestUtils.KafkaScramPassword)\n+    createScramCredentials(adminClients.head, JaasTestUtils.KafkaScramAdmin, JaasTestUtils.KafkaScramAdminPassword)\n     initializeKerberos()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDQ4NzU2", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-478048756", "createdAt": "2020-08-28T22:05:33Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjowNTozNFrOHJVpIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjowNTozNFrOHJVpIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1MzgyNw==", "bodyText": "So the reason for not using the SaslSertup#createScramCredentials method here is because we want the admin client itself to be authenticated with SCRAM?", "url": "https://github.com/apache/kafka/pull/9032#discussion_r479553827", "createdAt": "2020-08-28T22:05:34Z", "author": {"login": "cmccabe"}, "path": "core/src/test/scala/integration/kafka/api/SaslScramSslEndToEndAuthorizationTest.scala", "diffHunk": "@@ -42,7 +42,18 @@ class SaslScramSslEndToEndAuthorizationTest extends SaslEndToEndAuthorizationTes\n   override def setUp(): Unit = {\n     super.setUp()\n     // Create client credentials after starting brokers so that dynamic credential creation is also tested\n-    createScramCredentials(zkConnect, JaasTestUtils.KafkaScramUser, JaasTestUtils.KafkaScramPassword)\n-    createScramCredentials(zkConnect, JaasTestUtils.KafkaScramUser2, JaasTestUtils.KafkaScramPassword2)\n+    createScramCredentialWithScramAdminClient(JaasTestUtils.KafkaScramUser, JaasTestUtils.KafkaScramPassword)\n+    createScramCredentialWithScramAdminClient(JaasTestUtils.KafkaScramUser2, JaasTestUtils.KafkaScramPassword2)\n+  }\n+\n+  private def createScramCredentialWithScramAdminClient(user: String, password: String) = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDQ5MzY2", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-478049366", "createdAt": "2020-08-28T22:07:18Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjowNzoxOFrOHJVrFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjowNzoxOFrOHJVrFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1NDMyNA==", "bodyText": "It feels like we are accumulating a lot of these \"create an admin client, but with SCRAM\" functions.  Since all these tests ultimately subclass SaslSetup, can't we have a common function there?", "url": "https://github.com/apache/kafka/pull/9032#discussion_r479554324", "createdAt": "2020-08-28T22:07:18Z", "author": {"login": "cmccabe"}, "path": "core/src/test/scala/integration/kafka/api/SaslClientsWithInvalidCredentialsTest.scala", "diffHunk": "@@ -248,4 +250,25 @@ class SaslClientsWithInvalidCredentialsTest extends IntegrationTestHarness with\n     producerConfig.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, \"true\")\n     createProducer()\n   }\n+\n+  private def createScramAdminClient(user: String, password: String): Admin = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MDUwMDcy", "url": "https://github.com/apache/kafka/pull/9032#pullrequestreview-478050072", "createdAt": "2020-08-28T22:09:40Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjowOTo0MFrOHJVtXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjowOTo0MFrOHJVtXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1NDkxMQ==", "bodyText": "can we create a common function in SaslSetup for this?  Seems to be repeated in a lot of tests.", "url": "https://github.com/apache/kafka/pull/9032#discussion_r479554911", "createdAt": "2020-08-28T22:09:40Z", "author": {"login": "cmccabe"}, "path": "core/src/test/scala/integration/kafka/api/EndToEndAuthorizationTest.scala", "diffHunk": "@@ -545,6 +558,16 @@ abstract class EndToEndAuthorizationTest extends IntegrationTestHarness with Sas\n     }\n   }\n \n+  protected def createScramAdminClient(scramMechanism: String, user: String, password: String): Admin = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 68}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "a58406a55d8f3c420f71f3db3446cb73d647d03f", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/a58406a55d8f3c420f71f3db3446cb73d647d03f", "committedDate": "2020-09-02T17:53:35Z", "message": "KAFKA-10259: KIP-554 Broker-side SCRAM Config API"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "155f6db629197e9b482213df8cda920eeb101003", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/155f6db629197e9b482213df8cda920eeb101003", "committedDate": "2020-09-02T17:53:35Z", "message": "Test cases for no credentials and authz failures"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0928b3822f24c9a46e4c11de65255a6c36737e60", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/0928b3822f24c9a46e4c11de65255a6c36737e60", "committedDate": "2020-09-02T17:53:35Z", "message": "ConfigCommand illgal invocation tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acc5c67be09894888ea96466c1da1d1ffd5b1217", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/acc5c67be09894888ea96466c1da1d1ffd5b1217", "committedDate": "2020-09-02T17:53:36Z", "message": "add negative test for --entity-default"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86a3ded3989571c12eaf1102c89d705d40890fb8", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/86a3ded3989571c12eaf1102c89d705d40890fb8", "committedDate": "2020-09-02T17:53:36Z", "message": "Describe works, HMAC_SHA -> SCRAM_SHA"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e22108fc43feb2c6945520b046fdc15fdf2de52", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/7e22108fc43feb2c6945520b046fdc15fdf2de52", "committedDate": "2020-09-02T17:53:36Z", "message": "more negative tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e095693e43a95adf3833542d8d95314dd01cef5", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/8e095693e43a95adf3833542d8d95314dd01cef5", "committedDate": "2020-09-02T17:53:36Z", "message": "some AlterUserScramCredentials tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aebb9a3741b6390738579292a75284d041a1a877", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/aebb9a3741b6390738579292a75284d041a1a877", "committedDate": "2020-09-02T17:53:36Z", "message": "create/describe/delete/describe test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a57d6d5039a548362a6d63a1294dc3b5eb82c93d", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/a57d6d5039a548362a6d63a1294dc3b5eb82c93d", "committedDate": "2020-09-02T17:53:37Z", "message": "Respond to review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72a936122f2327135703d1f88ab4a16e272ac3c4", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/72a936122f2327135703d1f88ab4a16e272ac3c4", "committedDate": "2020-09-02T17:53:37Z", "message": "Respond to review, add UserScramCredentialsCommandTest.scala"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "264182307f207561d09785e104557957de8524e2", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/264182307f207561d09785e104557957de8524e2", "committedDate": "2020-09-02T17:53:37Z", "message": "Leverage admin client in tests to create SCRAM credentials"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46e19b7180eb92f3f7e0022ea87b86aadab3dda0", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/46e19b7180eb92f3f7e0022ea87b86aadab3dda0", "committedDate": "2020-09-02T17:53:37Z", "message": "Respond to review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "924817b68fbdb032265b8a3b6eef19942c7e367b", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/924817b68fbdb032265b8a3b6eef19942c7e367b", "committedDate": "2020-09-02T17:53:38Z", "message": "Use admin client in system tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a60eaba22e5a5bc9da5f02e5d2906e7cc77525ce", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/a60eaba22e5a5bc9da5f02e5d2906e7cc77525ce", "committedDate": "2020-09-02T17:53:38Z", "message": "Eliminate -1 as a valid iterations value"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c906470e5d046d98d80170924f9060ede0ef5f2a", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/c906470e5d046d98d80170924f9060ede0ef5f2a", "committedDate": "2020-09-02T17:53:38Z", "message": "Respond to review except for per-user errors on Describe"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "503cb89ef405bfad3eeec18322d2a170f197fd3b", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/503cb89ef405bfad3eeec18322d2a170f197fd3b", "committedDate": "2020-09-02T17:53:38Z", "message": "Add per-user errors to DescribeUserScramCredentialResponse"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af14cc5eceebc6dcd9beef4bd7b0ad444cfcf1a8", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/af14cc5eceebc6dcd9beef4bd7b0ad444cfcf1a8", "committedDate": "2020-09-02T17:53:38Z", "message": "throw exception, add break statement as per review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d48e9e0cb73461ddc6b5bb295e7d5adaa37a12b", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/2d48e9e0cb73461ddc6b5bb295e7d5adaa37a12b", "committedDate": "2020-09-02T17:53:39Z", "message": "Return two levels of Future in describe"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b718ad80258756977fa58316b18bcc5bea22db77", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/b718ad80258756977fa58316b18bcc5bea22db77", "committedDate": "2020-09-02T17:53:39Z", "message": "Eliminate UserScramCredentialsDescriptionResult"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "968564ee399c83d589a72dabfe85c3c36e95484e", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/968564ee399c83d589a72dabfe85c3c36e95484e", "committedDate": "2020-09-02T17:53:39Z", "message": "Eliminate unnecessary intermediate future as per review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b98a70ad4d8fd19d8ba4d7af2fa783207dc7298", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/0b98a70ad4d8fd19d8ba4d7af2fa783207dc7298", "committedDate": "2020-09-02T17:53:39Z", "message": "Provide 1 Future to DescribeUserScramCredentialsResult"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "555a4ba066e87fa5b391480b294c5706051a9f3e", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/555a4ba066e87fa5b391480b294c5706051a9f3e", "committedDate": "2020-09-02T17:53:39Z", "message": "Javadoc fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4ffca49424487794648a457155bb7b328cea4e7", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/c4ffca49424487794648a457155bb7b328cea4e7", "committedDate": "2020-09-02T17:53:40Z", "message": "users() returns described users"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d18cba0a799a239b9af75629abdaf2887423a19b", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/d18cba0a799a239b9af75629abdaf2887423a19b", "committedDate": "2020-09-02T17:53:40Z", "message": "Added DescribeUserScramCredentialsResultTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e8d35d035f77c45f62d6bbf432440127e3d8709", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/0e8d35d035f77c45f62d6bbf432440127e3d8709", "committedDate": "2020-09-02T17:53:40Z", "message": "Respond to review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cdbdfb30e8be656719ca355ec0cb844b1f229cce", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/cdbdfb30e8be656719ca355ec0cb844b1f229cce", "committedDate": "2020-09-02T17:53:40Z", "message": "comment fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfd50346e657283bff66d72deafb5408f6a9102c", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/dfd50346e657283bff66d72deafb5408f6a9102c", "committedDate": "2020-09-02T17:53:40Z", "message": "Create SaslSetup.createAdminClient() method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8829db5261c6ead337f7d5efee5937fffbb9973c", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/8829db5261c6ead337f7d5efee5937fffbb9973c", "committedDate": "2020-09-02T17:53:41Z", "message": "Allow creation of scram credentials with delegation token"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04a882b1794f90bbe002f460803cda9a2beebccc", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/04a882b1794f90bbe002f460803cda9a2beebccc", "committedDate": "2020-09-02T17:53:41Z", "message": "Fix core spotbugs error under JDK 8/Scala 2.12"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "04a882b1794f90bbe002f460803cda9a2beebccc", "author": {"user": {"login": "rondagostino", "name": "Ron Dagostino"}}, "url": "https://github.com/apache/kafka/commit/04a882b1794f90bbe002f460803cda9a2beebccc", "committedDate": "2020-09-02T17:53:41Z", "message": "Fix core spotbugs error under JDK 8/Scala 2.12"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1323, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}