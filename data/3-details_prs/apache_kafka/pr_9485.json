{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA4NzI1NTM2", "number": 9485, "title": "KAKFA-10619: Idempotent producer will get authorized once it has a WRITE access to at least one topic", "bodyText": "New stuff implemented:\n\nthe interface default\na) handle the prefixed and wildcard resources correctly\nb) assume allow.anyone is false. so no ACL entry means no access\nc) handle the existing ACL entries with wildcard principle, host, and operation correctly\nthe new interface override in AclAuthorizer and\na) handling the prefixed and wildcard resources correctly\nb) maintaining the existing behavior wrt allow.anyone value.\nc) handling the existing ACL entries with wildcard principle, host, and operation\nd) optimized on performance with new indexing on ACE besides on the existing ResourcePattern.\nInitProducerIdRequest and ProduceRequest will be authorized once the producer has a WRITE access to at least one topic.\nlots of tests with different scenarios, both for the interface default and the overridden methods.\n\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-10-23T05:23:25Z", "url": "https://github.com/apache/kafka/pull/9485", "merged": true, "mergeCommit": {"oid": "ae3a6ed990f91708686d27c6023bac050c422248"}, "closed": true, "closedAt": "2020-12-18T18:08:47Z", "author": {"login": "ctan888"}, "timelineItems": {"totalCount": 94, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdVPoT1gH2gAyNTA4NzI1NTM2OjJjMzA2NWYyZWFkMTU1YWI0ODhkZjM4ZTBhN2RkMjU0MTIwZjdmMzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdnYju7AH2gAyNTA4NzI1NTM2OmRkNjIwZjRjYzcwZDA5ZGVmOTMwNDkwNGU3ZmNmMDIwZmQxYzQwNmU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2c3065f2ead155ab488df38e0a7dd254120f7f30", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/2c3065f2ead155ab488df38e0a7dd254120f7f30", "committedDate": "2020-10-23T05:22:15Z", "message": "initial"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a91a5bc32f614b09c65cb416df4e23f73aa9dbe8", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/a91a5bc32f614b09c65cb416df4e23f73aa9dbe8", "committedDate": "2020-10-27T01:53:44Z", "message": "Added tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f85601011c482e32d103462734a4af358e2560b1", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/f85601011c482e32d103462734a4af358e2560b1", "committedDate": "2020-10-28T06:17:28Z", "message": "implement the interface default"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc9fa33dea8d5764a1bdb20d62d9e160ce9f64ae", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/dc9fa33dea8d5764a1bdb20d62d9e160ce9f64ae", "committedDate": "2020-10-28T08:45:19Z", "message": "handle wildcard ace"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bcfe3532800108b8f33822432a01b45e2ceaec33", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/bcfe3532800108b8f33822432a01b45e2ceaec33", "committedDate": "2020-10-28T17:34:36Z", "message": "Fix authorizeAny deny on cluster"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05da2bd3eb0d7bd37fccf977a5215513c6974b29", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/05da2bd3eb0d7bd37fccf977a5215513c6974b29", "committedDate": "2020-10-29T00:58:29Z", "message": "Add more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45dc8a212d6f71d22536c5d1e14f8a57d2b03014", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/45dc8a212d6f71d22536c5d1e14f8a57d2b03014", "committedDate": "2020-10-29T01:00:18Z", "message": "bug fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68dc6bf1713f62977f2b2cf0f47d50f1a720c00f", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/68dc6bf1713f62977f2b2cf0f47d50f1a720c00f", "committedDate": "2020-10-29T05:06:20Z", "message": "added tests for wildcard principle, host, and operation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a886be27f7cb7488e899fa1c54477c83aa0fdef1", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/a886be27f7cb7488e899fa1c54477c83aa0fdef1", "committedDate": "2020-11-03T01:18:55Z", "message": "Support Wildcard ACES by default"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "955c78d9331c0fa6ca752bc5f9e2b199b123ed2f", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/955c78d9331c0fa6ca752bc5f9e2b199b123ed2f", "committedDate": "2020-11-03T01:28:12Z", "message": "move the acl removal logic from @before to @after, in order to pass all the tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c9feff96744804c543ecec370e60c4bd07708b0", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/5c9feff96744804c543ecec370e60c4bd07708b0", "committedDate": "2020-11-03T20:40:38Z", "message": "Implement the new API for AuthorizerWrapper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec900c3ed2e66bdbe17679fe8451d0badc439e8c", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/ec900c3ed2e66bdbe17679fe8451d0badc439e8c", "committedDate": "2020-11-03T20:42:04Z", "message": "refactor the test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "163f6cf54dde86679dab18cc4e003f879585d590", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/163f6cf54dde86679dab18cc4e003f879585d590", "committedDate": "2020-11-03T23:46:28Z", "message": "remove a) cluster special handling b) empty prefix check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b99fdce1987c0248353fa053b2d00254cf5827f", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/7b99fdce1987c0248353fa053b2d00254cf5827f", "committedDate": "2020-11-04T00:30:39Z", "message": "optimize the interface default, checking literals in the default instead of calling authorize"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7f63fe1a2cfc122af5cd0d678ada4ed0fd0ff04", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/b7f63fe1a2cfc122af5cd0d678ada4ed0fd0ff04", "committedDate": "2020-11-04T20:09:02Z", "message": "rename the authorizeAny to authorizeByResourceType"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b28637e57c7c3779795cae48ffc851f7c7f99080", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/b28637e57c7c3779795cae48ffc851f7c7f99080", "committedDate": "2020-11-04T22:07:16Z", "message": "clean up AclAuthorizer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/594e35099c6af000503f99d1028375a3f2da0014", "committedDate": "2020-11-07T10:08:30Z", "message": "added integration tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzOTUwNDk5", "url": "https://github.com/apache/kafka/pull/9485#pullrequestreview-533950499", "createdAt": "2020-11-18T22:58:25Z", "commit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "state": "COMMENTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMjo1ODoyNlrOH2FwcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMDowNDozM1rOH2HROw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3OTQ3Mw==", "bodyText": "We should document what this default implementation does and why a custom implementation may want to override this default.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526479473", "createdAt": "2020-11-18T22:58:26Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +150,129 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3OTQ3OA==", "bodyText": "We should document what this default implementation does and why a custom implementation may want to override this default.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526479478", "createdAt": "2020-11-18T22:58:26Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +150,129 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4MTU3Mw==", "bodyText": "nit: indentation", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526481573", "createdAt": "2020-11-18T23:03:40Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +150,129 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        if (resourceType == ResourceType.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter resource type for authorizeByResourceType\");\n+        }\n+\n+        if (resourceType == ResourceType.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown resource type\");\n+        }\n+\n+        if (op == AclOperation.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter operation type for authorizeByResourceType\");\n+        }\n+\n+        if (op == AclOperation.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown operation type\");\n+        }\n+\n+        ResourcePatternFilter resourceTypeFilter = new ResourcePatternFilter(\n+            resourceType, null, PatternType.ANY);\n+        AclBindingFilter aclFilter = new AclBindingFilter(\n+            resourceTypeFilter, AccessControlEntryFilter.ANY);\n+\n+        Set<String> denyLiterals = new HashSet<>();\n+        Set<String> denyPrefixes = new HashSet<>();\n+        Set<String> allowLiterals = new HashSet<>();\n+        Set<String> allowPrefixes = new HashSet<>();\n+        boolean hasWildCardAllow = false;\n+\n+        for (AclBinding binding : acls(aclFilter)) {\n+            if (!binding.entry().host().equals(requestContext.clientAddress().getHostAddress())\n+                    && !binding.entry().host().equals(\"*\"))\n+                continue;\n+\n+            if (!binding.entry().principal().equals(requestContext.principal().toString())\n+                    && !binding.entry().principal().equals(\"User:*\"))\n+                continue;\n+\n+            if (binding.entry().operation() != op\n+                    && binding.entry().operation() != AclOperation.ALL)\n+                continue;\n+\n+            if (binding.entry().permissionType() == AclPermissionType.DENY) {\n+                switch (binding.pattern().patternType()) {\n+                    case LITERAL:\n+                        if (binding.pattern().name().equals(ResourcePattern.WILDCARD_RESOURCE))\n+                            return AuthorizationResult.DENIED;\n+                            denyLiterals.add(binding.pattern().name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4Mjg5OQ==", "bodyText": "This looks identical to the code block above for prefix, we could just run the same code in a loop that checks both allow literals and prefixes.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526482899", "createdAt": "2020-11-18T23:07:07Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +150,129 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        if (resourceType == ResourceType.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter resource type for authorizeByResourceType\");\n+        }\n+\n+        if (resourceType == ResourceType.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown resource type\");\n+        }\n+\n+        if (op == AclOperation.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter operation type for authorizeByResourceType\");\n+        }\n+\n+        if (op == AclOperation.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown operation type\");\n+        }\n+\n+        ResourcePatternFilter resourceTypeFilter = new ResourcePatternFilter(\n+            resourceType, null, PatternType.ANY);\n+        AclBindingFilter aclFilter = new AclBindingFilter(\n+            resourceTypeFilter, AccessControlEntryFilter.ANY);\n+\n+        Set<String> denyLiterals = new HashSet<>();\n+        Set<String> denyPrefixes = new HashSet<>();\n+        Set<String> allowLiterals = new HashSet<>();\n+        Set<String> allowPrefixes = new HashSet<>();\n+        boolean hasWildCardAllow = false;\n+\n+        for (AclBinding binding : acls(aclFilter)) {\n+            if (!binding.entry().host().equals(requestContext.clientAddress().getHostAddress())\n+                    && !binding.entry().host().equals(\"*\"))\n+                continue;\n+\n+            if (!binding.entry().principal().equals(requestContext.principal().toString())\n+                    && !binding.entry().principal().equals(\"User:*\"))\n+                continue;\n+\n+            if (binding.entry().operation() != op\n+                    && binding.entry().operation() != AclOperation.ALL)\n+                continue;\n+\n+            if (binding.entry().permissionType() == AclPermissionType.DENY) {\n+                switch (binding.pattern().patternType()) {\n+                    case LITERAL:\n+                        if (binding.pattern().name().equals(ResourcePattern.WILDCARD_RESOURCE))\n+                            return AuthorizationResult.DENIED;\n+                            denyLiterals.add(binding.pattern().name());\n+                        break;\n+                    case PREFIXED:\n+                        denyPrefixes.add(binding.pattern().name());\n+                        break;\n+                }\n+                continue;\n+            }\n+\n+            if (binding.entry().permissionType() != AclPermissionType.ALLOW)\n+                continue;\n+\n+            switch (binding.pattern().patternType()) {\n+                case LITERAL:\n+                    if (binding.pattern().name().equals(ResourcePattern.WILDCARD_RESOURCE)) {\n+                        hasWildCardAllow = true;\n+                        continue;\n+                    }\n+                    allowLiterals.add(binding.pattern().name());\n+                    break;\n+                case PREFIXED:\n+                    allowPrefixes.add(binding.pattern().name());\n+                    break;\n+            }\n+        }\n+\n+        if (hasWildCardAllow) {\n+            return AuthorizationResult.ALLOWED;\n+        }\n+\n+        for (String allowPrefix : allowPrefixes) {\n+            StringBuilder sb = new StringBuilder();\n+            boolean hasDominatedDeny = false;\n+            for (char ch : allowPrefix.toCharArray()) {\n+                sb.append(ch);\n+                if (denyPrefixes.contains(sb.toString())) {\n+                    hasDominatedDeny = true;\n+                    break;\n+                }\n+            }\n+            if (!hasDominatedDeny)\n+                return AuthorizationResult.ALLOWED;\n+        }\n+\n+        for (String allowLiteral : allowLiterals) {\n+            if (denyLiterals.contains(allowLiteral))\n+                continue;\n+            StringBuilder sb = new StringBuilder();\n+            boolean hasDominatedDeny = false;\n+            for (char ch : allowLiteral.toCharArray()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4MzQ3Ng==", "bodyText": "We should have exactly one call to logAuditMessage that says whether access was allowed or denied.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526483476", "createdAt": "2020-11-18T23:08:45Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -307,6 +312,111 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4NjAyOA==", "bodyText": "request.principal can be a custom extension of KafkaPrincipal, we cannot use toString for comparison", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526486028", "createdAt": "2020-11-18T23:15:24Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +150,129 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        if (resourceType == ResourceType.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter resource type for authorizeByResourceType\");\n+        }\n+\n+        if (resourceType == ResourceType.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown resource type\");\n+        }\n+\n+        if (op == AclOperation.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter operation type for authorizeByResourceType\");\n+        }\n+\n+        if (op == AclOperation.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown operation type\");\n+        }\n+\n+        ResourcePatternFilter resourceTypeFilter = new ResourcePatternFilter(\n+            resourceType, null, PatternType.ANY);\n+        AclBindingFilter aclFilter = new AclBindingFilter(\n+            resourceTypeFilter, AccessControlEntryFilter.ANY);\n+\n+        Set<String> denyLiterals = new HashSet<>();\n+        Set<String> denyPrefixes = new HashSet<>();\n+        Set<String> allowLiterals = new HashSet<>();\n+        Set<String> allowPrefixes = new HashSet<>();\n+        boolean hasWildCardAllow = false;\n+\n+        for (AclBinding binding : acls(aclFilter)) {\n+            if (!binding.entry().host().equals(requestContext.clientAddress().getHostAddress())\n+                    && !binding.entry().host().equals(\"*\"))\n+                continue;\n+\n+            if (!binding.entry().principal().equals(requestContext.principal().toString())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4NzE3Ng==", "bodyText": "Not sure it is worth making a whole copy of this structure for a method that is not used frequently. It will be good to add microbenchmarks to AclAuthorizerBenchmark to understand how the new method performs.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526487176", "createdAt": "2020-11-18T23:18:26Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -130,6 +130,11 @@ class AclAuthorizer extends Authorizer with Logging {\n \n   @volatile\n   private var aclCache = new scala.collection.immutable.TreeMap[ResourcePattern, VersionedAcls]()(new ResourceOrdering)\n+\n+  @volatile\n+  private var resourceCache = new scala.collection.immutable.HashMap[AccessControlEntry,\n+    scala.collection.mutable.HashSet[ResourcePattern]]()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4Nzc2MQ==", "bodyText": "Same as in the Authorizer default method, we cannot use request.principal().toString()", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526487761", "createdAt": "2020-11-18T23:19:56Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -307,6 +312,111 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType eq ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType eq ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op eq AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op eq AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")\n+\n+    val allowPatterns = matchingPatterns(\n+      requestContext.principal().toString,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4OTE1Mg==", "bodyText": "We should optimize for the case where there are no DENY acls. There is no point in finding all matching ALLOW entries in that case, we would just need to check for one ALLOW.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526489152", "createdAt": "2020-11-18T23:23:54Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -307,6 +312,111 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType eq ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType eq ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op eq AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op eq AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")\n+\n+    val allowPatterns = matchingPatterns(\n+      requestContext.principal().toString,\n+      requestContext.clientAddress().getHostAddress,\n+      op,\n+      resourceType,\n+      AclPermissionType.ALLOW\n+    )\n+\n+    val denyPatterns = matchingPatterns(\n+      requestContext.principal().toString,\n+      requestContext.clientAddress().getHostAddress,\n+      op,\n+      resourceType,\n+      AclPermissionType.DENY", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5NDAxNA==", "bodyText": "make this all the methods below private", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526494014", "createdAt": "2020-11-18T23:37:05Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +179,69 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType == ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType == ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op == AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op == AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound && !denyAllResource(requestContext, op, resourceType)) {\n+      AuthorizationResult.ALLOWED\n+    } else {\n+      super.authorizeByResourceType(requestContext, op, resourceType)\n+    }\n+  }\n+\n+  def denyAllResource(requestContext: AuthorizableRequestContext,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5NDI5OA==", "bodyText": "We coul just inline all the methods below instead of separate methods for host etc.?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526494298", "createdAt": "2020-11-18T23:37:54Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +179,69 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType == ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType == ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op == AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op == AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound && !denyAllResource(requestContext, op, resourceType)) {\n+      AuthorizationResult.ALLOWED\n+    } else {\n+      super.authorizeByResourceType(requestContext, op, resourceType)\n+    }\n+  }\n+\n+  def denyAllResource(requestContext: AuthorizableRequestContext,\n+                      op: AclOperation,\n+                      resourceType: ResourceType): Boolean = {\n+    val resourceTypeFilter = new ResourcePatternFilter(\n+      resourceType, null, PatternType.ANY)\n+    val accessControlEntry = new AccessControlEntryFilter(\n+      null, null, null, AclPermissionType.DENY)\n+    val aclFilter = new AclBindingFilter(resourceTypeFilter, accessControlEntry)\n+\n+    for (binding <- acls(aclFilter).asScala) {\n+      if (aceMatched(requestContext, op, binding) && canDenyAll(binding.pattern()))\n+        return true\n+    }\n+    false\n+  }\n+\n+  def aceMatched(requestContext: AuthorizableRequestContext,\n+                 op: AclOperation,\n+                 binding: AclBinding): Boolean = {\n+    (hostMatched(requestContext, binding) && principleMatched(requestContext, binding)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5NTkyOA==", "bodyText": "Hmm, Produce s authorized for topic anyway. Why would we use a very expensive authorizeByResourceType here?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526495928", "createdAt": "2020-11-18T23:42:06Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -517,7 +517,9 @@ class KafkaApis(val requestChannel: RequestChannel,\n       }\n       // Note that authorization to a transactionalId implies ProducerId authorization\n \n-    } else if (produceRequest.hasIdempotentRecords && !authorize(request.context, IDEMPOTENT_WRITE, CLUSTER, CLUSTER_NAME)) {\n+    } else if (produceRequest.hasIdempotentRecords\n+        && !authorize(request.context, IDEMPOTENT_WRITE, CLUSTER, CLUSTER_NAME)\n+        && !authorizeByResourceType(request.context, WRITE, TOPIC)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5NjIyNA==", "bodyText": "First authorize should use logIfAllowed=true, logIfDenied=false", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526496224", "createdAt": "2020-11-18T23:42:56Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -2034,7 +2036,8 @@ class KafkaApis(val requestChannel: RequestChannel,\n         sendErrorResponseMaybeThrottle(request, Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED.exception)\n         return\n       }\n-    } else if (!authorize(request.context, IDEMPOTENT_WRITE, CLUSTER, CLUSTER_NAME)) {\n+    } else if (!authorize(request.context, IDEMPOTENT_WRITE, CLUSTER, CLUSTER_NAME)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5Njk5OA==", "bodyText": "Durability?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526496998", "createdAt": "2020-11-18T23:44:48Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/integration/kafka/api/AuthorizerIntegrationTest.scala", "diffHunk": "@@ -1775,6 +1782,87 @@ class AuthorizerIntegrationTest extends BaseRequestTest {\n     assertFalse(\"Cluster id not returned\", response.clusterId.isEmpty)\n   }\n \n+  @Test\n+  def testAuthorizeAnyDurability(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5OTE1OQ==", "bodyText": "It may be better to put the mock tests into another test class. That wouldn't request ZooKeeper for example.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526499159", "createdAt": "2020-11-18T23:50:40Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -82,16 +86,17 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n   override def setUp(): Unit = {\n     super.setUp()\n \n+    val authorizers = Seq(aclAuthorizer, aclAuthorizer2, MockAuthorizer.authorizer)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ5OTUwNA==", "bodyText": "As before, references to Durability in authorizer tests are confusing.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526499504", "createdAt": "2020-11-18T23:51:38Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -988,6 +1000,369 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n     }\n   }\n \n+  @Test\n+  def testAuthorizeAnyDurability(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwMDY4OA==", "bodyText": "Are we going to add tests here?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526500688", "createdAt": "2020-11-18T23:54:50Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerInterfaceDefaultTest.java", "diffHunk": "@@ -0,0 +1,4 @@\n+package unit.kafka.security.authorizer;\n+\n+public class AuthorizerInterfaceDefaultTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwMjAwMA==", "bodyText": "We should run the microbenchmarks in AclAuthorizerBenchmark to make sure we don't add too much overhead here.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526502000", "createdAt": "2020-11-18T23:58:19Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -550,6 +660,31 @@ class AclAuthorizer extends Authorizer with Logging {\n   }\n \n   private def updateCache(resource: ResourcePattern, versionedAcls: VersionedAcls): Unit = {\n+    val currentAces: Set[AccessControlEntry] = aclCache.get(resource) match {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwMzk3NQ==", "bodyText": "Don't we reuse this in multiple tests? How do we guarantee that no state is preserved between tests?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526503975", "createdAt": "2020-11-19T00:03:44Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/MockAuthorizer.scala", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.{lang, util}\n+import java.util.concurrent.CompletionStage\n+\n+import org.apache.kafka.common.Endpoint\n+import org.apache.kafka.common.acl.{AclBinding, AclBindingFilter}\n+import org.apache.kafka.server.authorizer.{AclCreateResult, AclDeleteResult, Action, AuthorizableRequestContext, AuthorizationResult, Authorizer, AuthorizerServerInfo}\n+\n+object MockAuthorizer {\n+    val authorizer = new AclAuthorizer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwNDI0NA==", "bodyText": "We could mock this fully instead of using AclAuthorizer?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526504244", "createdAt": "2020-11-19T00:04:32Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/MockAuthorizer.scala", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.{lang, util}\n+import java.util.concurrent.CompletionStage\n+\n+import org.apache.kafka.common.Endpoint\n+import org.apache.kafka.common.acl.{AclBinding, AclBindingFilter}\n+import org.apache.kafka.server.authorizer.{AclCreateResult, AclDeleteResult, Action, AuthorizableRequestContext, AuthorizationResult, Authorizer, AuthorizerServerInfo}\n+\n+object MockAuthorizer {\n+    val authorizer = new AclAuthorizer\n+}\n+\n+/**\n+ * A mock authorizer for testing the interface default\n+ */\n+class MockAuthorizer extends Authorizer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwNDI1MQ==", "bodyText": "We could mock this fully instead of using AclAuthorizer?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r526504251", "createdAt": "2020-11-19T00:04:33Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/MockAuthorizer.scala", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.{lang, util}\n+import java.util.concurrent.CompletionStage\n+\n+import org.apache.kafka.common.Endpoint\n+import org.apache.kafka.common.acl.{AclBinding, AclBindingFilter}\n+import org.apache.kafka.server.authorizer.{AclCreateResult, AclDeleteResult, Action, AuthorizableRequestContext, AuthorizationResult, Authorizer, AuthorizerServerInfo}\n+\n+object MockAuthorizer {\n+    val authorizer = new AclAuthorizer\n+}\n+\n+/**\n+ * A mock authorizer for testing the interface default\n+ */\n+class MockAuthorizer extends Authorizer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 33}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89df4d7600cad4e3785d0d95624d0918efce1f44", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/89df4d7600cad4e3785d0d95624d0918efce1f44", "committedDate": "2020-11-23T21:27:51Z", "message": "convert session principle to Kafka principle in case that the subclass override the toString() method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "188536ad8df13fc327008e59c9787ad2230a7186", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/188536ad8df13fc327008e59c9787ad2230a7186", "committedDate": "2020-11-23T22:13:39Z", "message": "Deduplicate allow literal & prefix's prefix checking logic in interface default"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3906f978e62255ff266f081bf646a4b3c6b896ad", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/3906f978e62255ff266f081bf646a4b3c6b896ad", "committedDate": "2020-11-24T00:43:26Z", "message": "enhance performance"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "230ee36b9147a11d7ce299aa9fcbb590324faf68", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/230ee36b9147a11d7ce299aa9fcbb590324faf68", "committedDate": "2020-11-30T01:02:21Z", "message": "add the API to aclBenchmark"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "230ee36b9147a11d7ce299aa9fcbb590324faf68", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/230ee36b9147a11d7ce299aa9fcbb590324faf68", "committedDate": "2020-11-30T01:02:21Z", "message": "add the API to aclBenchmark"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "254af37df5e2d6ec462e7b70497ceb655edea596", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/254af37df5e2d6ec462e7b70497ceb655edea596", "committedDate": "2020-11-30T04:02:17Z", "message": "optimize the API performance, add the audit log"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0aa305d8c043075ef0bb7b41d2c37e0072284c5", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/b0aa305d8c043075ef0bb7b41d2c37e0072284c5", "committedDate": "2020-11-30T04:32:26Z", "message": "test changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4504b181bba4675fa8b8967e59860c6817c6e709", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/4504b181bba4675fa8b8967e59860c6817c6e709", "committedDate": "2020-11-30T04:46:11Z", "message": "resolve conflicts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb8acb6b0e6a62b3ea29ed22a112b7ee0b07a749", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/eb8acb6b0e6a62b3ea29ed22a112b7ee0b07a749", "committedDate": "2020-11-30T20:39:52Z", "message": "fix checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f9979f3681e1c6374cb693b17f8440d874169ef5", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/f9979f3681e1c6374cb693b17f8440d874169ef5", "committedDate": "2020-12-01T17:07:30Z", "message": "fix syntax err"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "f9979f3681e1c6374cb693b17f8440d874169ef5", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/f9979f3681e1c6374cb693b17f8440d874169ef5", "committedDate": "2020-12-01T17:07:30Z", "message": "fix syntax err"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMDE2OTI3", "url": "https://github.com/apache/kafka/pull/9485#pullrequestreview-542016927", "createdAt": "2020-12-01T15:29:01Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNToyOTowMVrOH8yYCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMToxNzozNFrOH9AHaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUwMTk2Mw==", "bodyText": "This looks odd, do we really need these to index into arrays?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533501963", "createdAt": "2020-12-01T15:29:01Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,125 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        if (resourceType == ResourceType.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter resource type for authorizeByResourceType\");\n+        }\n+\n+        if (resourceType == ResourceType.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown resource type\");\n+        }\n+\n+        if (op == AclOperation.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter operation type for authorizeByResourceType\");\n+        }\n+\n+        if (op == AclOperation.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown operation type\");\n+        }\n+\n+        ResourcePatternFilter resourceTypeFilter = new ResourcePatternFilter(\n+            resourceType, null, PatternType.ANY);\n+        AclBindingFilter aclFilter = new AclBindingFilter(\n+            resourceTypeFilter, AccessControlEntryFilter.ANY);\n+\n+        final int typeLiteral = 0;\n+        final int typePrefix = 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUwMjQxNw==", "bodyText": "Why do we create ArrayList(Arrays.asList)?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533502417", "createdAt": "2020-12-01T15:29:33Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,125 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        if (resourceType == ResourceType.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter resource type for authorizeByResourceType\");\n+        }\n+\n+        if (resourceType == ResourceType.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown resource type\");\n+        }\n+\n+        if (op == AclOperation.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter operation type for authorizeByResourceType\");\n+        }\n+\n+        if (op == AclOperation.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown operation type\");\n+        }\n+\n+        ResourcePatternFilter resourceTypeFilter = new ResourcePatternFilter(\n+            resourceType, null, PatternType.ANY);\n+        AclBindingFilter aclFilter = new AclBindingFilter(\n+            resourceTypeFilter, AccessControlEntryFilter.ANY);\n+\n+        final int typeLiteral = 0;\n+        final int typePrefix = 1;\n+\n+        List<Set<String>> deny = new ArrayList<>(\n+            Arrays.asList(new HashSet<>(), new HashSet<>()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUwMzExOQ==", "bodyText": "We could get host address and store in a variable outside the loop.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533503119", "createdAt": "2020-12-01T15:30:24Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,125 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        if (resourceType == ResourceType.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter resource type for authorizeByResourceType\");\n+        }\n+\n+        if (resourceType == ResourceType.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown resource type\");\n+        }\n+\n+        if (op == AclOperation.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter operation type for authorizeByResourceType\");\n+        }\n+\n+        if (op == AclOperation.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown operation type\");\n+        }\n+\n+        ResourcePatternFilter resourceTypeFilter = new ResourcePatternFilter(\n+            resourceType, null, PatternType.ANY);\n+        AclBindingFilter aclFilter = new AclBindingFilter(\n+            resourceTypeFilter, AccessControlEntryFilter.ANY);\n+\n+        final int typeLiteral = 0;\n+        final int typePrefix = 1;\n+\n+        List<Set<String>> deny = new ArrayList<>(\n+            Arrays.asList(new HashSet<>(), new HashSet<>()));\n+        List<Set<String>> allow = new ArrayList<>(\n+            Arrays.asList(new HashSet<>(), new HashSet<>()));\n+\n+        boolean hasWildCardAllow = false;\n+\n+        for (AclBinding binding : acls(aclFilter)) {\n+            if (!binding.entry().host().equals(requestContext.clientAddress().getHostAddress())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUwMzE2Ng==", "bodyText": "Why is this inside the for loop? We could just create one principal and use it inside the loop.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533503166", "createdAt": "2020-12-01T15:30:27Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,125 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        if (resourceType == ResourceType.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter resource type for authorizeByResourceType\");\n+        }\n+\n+        if (resourceType == ResourceType.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown resource type\");\n+        }\n+\n+        if (op == AclOperation.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter operation type for authorizeByResourceType\");\n+        }\n+\n+        if (op == AclOperation.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown operation type\");\n+        }\n+\n+        ResourcePatternFilter resourceTypeFilter = new ResourcePatternFilter(\n+            resourceType, null, PatternType.ANY);\n+        AclBindingFilter aclFilter = new AclBindingFilter(\n+            resourceTypeFilter, AccessControlEntryFilter.ANY);\n+\n+        final int typeLiteral = 0;\n+        final int typePrefix = 1;\n+\n+        List<Set<String>> deny = new ArrayList<>(\n+            Arrays.asList(new HashSet<>(), new HashSet<>()));\n+        List<Set<String>> allow = new ArrayList<>(\n+            Arrays.asList(new HashSet<>(), new HashSet<>()));\n+\n+        boolean hasWildCardAllow = false;\n+\n+        for (AclBinding binding : acls(aclFilter)) {\n+            if (!binding.entry().host().equals(requestContext.clientAddress().getHostAddress())\n+                    && !binding.entry().host().equals(\"*\"))\n+                continue;\n+\n+            KafkaPrincipal principal = new KafkaPrincipal(\n+                requestContext.principal().getPrincipalType(),\n+                requestContext.principal().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUwNTU2MQ==", "bodyText": "An EnumMap may be neater.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533505561", "createdAt": "2020-12-01T15:33:34Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,125 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        if (resourceType == ResourceType.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter resource type for authorizeByResourceType\");\n+        }\n+\n+        if (resourceType == ResourceType.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown resource type\");\n+        }\n+\n+        if (op == AclOperation.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter operation type for authorizeByResourceType\");\n+        }\n+\n+        if (op == AclOperation.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown operation type\");\n+        }\n+\n+        ResourcePatternFilter resourceTypeFilter = new ResourcePatternFilter(\n+            resourceType, null, PatternType.ANY);\n+        AclBindingFilter aclFilter = new AclBindingFilter(\n+            resourceTypeFilter, AccessControlEntryFilter.ANY);\n+\n+        final int typeLiteral = 0;\n+        final int typePrefix = 1;\n+\n+        List<Set<String>> deny = new ArrayList<>(\n+            Arrays.asList(new HashSet<>(), new HashSet<>()));\n+        List<Set<String>> allow = new ArrayList<>(\n+            Arrays.asList(new HashSet<>(), new HashSet<>()));\n+\n+        boolean hasWildCardAllow = false;\n+\n+        for (AclBinding binding : acls(aclFilter)) {\n+            if (!binding.entry().host().equals(requestContext.clientAddress().getHostAddress())\n+                    && !binding.entry().host().equals(\"*\"))\n+                continue;\n+\n+            KafkaPrincipal principal = new KafkaPrincipal(\n+                requestContext.principal().getPrincipalType(),\n+                requestContext.principal().getName());\n+\n+            if (!SecurityUtils.parseKafkaPrincipal(binding.entry().principal()).equals(principal)\n+                    && !binding.entry().principal().equals(\"User:*\"))\n+                continue;\n+\n+            if (binding.entry().operation() != op\n+                    && binding.entry().operation() != AclOperation.ALL)\n+                continue;\n+\n+            if (binding.entry().permissionType() == AclPermissionType.DENY) {\n+                switch (binding.pattern().patternType()) {\n+                    case LITERAL:\n+                        if (binding.pattern().name().equals(ResourcePattern.WILDCARD_RESOURCE))\n+                            return AuthorizationResult.DENIED;\n+                        deny.get(typeLiteral).add(binding.pattern().name());\n+                        break;\n+                    case PREFIXED:\n+                        deny.get(typePrefix).add(binding.pattern().name());\n+                        break;\n+                }\n+                continue;\n+            }\n+\n+            if (binding.entry().permissionType() != AclPermissionType.ALLOW)\n+                continue;\n+\n+            switch (binding.pattern().patternType()) {\n+                case LITERAL:\n+                    if (binding.pattern().name().equals(ResourcePattern.WILDCARD_RESOURCE)) {\n+                        hasWildCardAllow = true;\n+                        continue;\n+                    }\n+                    allow.get(typeLiteral).add(binding.pattern().name());\n+                    break;\n+                case PREFIXED:\n+                    allow.get(typePrefix).add(binding.pattern().name());\n+                    break;\n+            }\n+        }\n+\n+        if (hasWildCardAllow) {\n+            return AuthorizationResult.ALLOWED;\n+        }\n+\n+        for (int allowType : Arrays.asList(typePrefix, typeLiteral)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUxMDQ2Nw==", "bodyText": "We should probably move this common code to SecurityUtils and use it both here and in the default implementation.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533510467", "createdAt": "2020-12-01T15:39:45Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,122 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType eq ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType eq ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op eq AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op eq AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUxMDQ3Nw==", "bodyText": "We should probably move this common code to SecurityUtils and use it both here and in the default implementation.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533510477", "createdAt": "2020-12-01T15:39:46Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,122 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType eq ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType eq ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op eq AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op eq AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUxMzAyMQ==", "bodyText": "We have lost the resource type for auditing, we should include a resource pattern with empty name or something.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533513021", "createdAt": "2020-12-01T15:42:54Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,122 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType eq ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType eq ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op eq AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op eq AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName).toString\n+\n+    val denyPatterns = matchingPatterns(\n+      principal,\n+      requestContext.clientAddress().getHostAddress,\n+      op,\n+      resourceType,\n+      AclPermissionType.DENY\n+    )\n+\n+    if (denyAll(denyPatterns)) {\n+      logAuditMessage(requestContext, new Action(op, null,0, true, true), false, false)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU2NDkwOA==", "bodyText": "ok, I seem to have forgotten this. Why is this code different from the one in the default implementation?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533564908", "createdAt": "2020-12-01T16:49:59Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,122 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType eq ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType eq ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op eq AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op eq AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName).toString\n+\n+    val denyPatterns = matchingPatterns(\n+      principal,\n+      requestContext.clientAddress().getHostAddress,\n+      op,\n+      resourceType,\n+      AclPermissionType.DENY\n+    )\n+\n+    if (denyAll(denyPatterns)) {\n+      logAuditMessage(requestContext, new Action(op, null,0, true, true), false, false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, new Action(op, null, 0, true, true), true, false)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val allowPatterns = matchingPatterns(\n+      principal,\n+      requestContext.clientAddress().getHostAddress,\n+      op,\n+      resourceType,\n+      AclPermissionType.ALLOW\n+    )\n+\n+    if (allowAny(allowPatterns, denyPatterns)) {\n+      logAuditMessage(requestContext, new Action(op,null, 0, true, true), true, false)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, new Action(op, null, 0, true, true), false, false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingPatterns(principal: String, host: String, op: AclOperation,\n+                       resourceType: ResourceType,\n+                       permission: AclPermissionType): Set[ResourcePattern] = {\n+    var resources = Set[ResourcePattern]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipal.toString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val ace = new AccessControlEntry(p, h, o, permission)\n+          resourceCache.get(ace) match {\n+            case Some(r) => resources ++= r.filter(r => r.resourceType() == resourceType)\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    resources\n+  }\n+\n+  private def denyAll(denyResources: Set[ResourcePattern]): Boolean =\n+    denyResources.exists(rp => denyAll(rp))\n+\n+  private def denyAll(rp: ResourcePattern): Boolean =\n+    rp.patternType() == PatternType.LITERAL && rp.name() == ResourcePattern.WILDCARD_RESOURCE\n+\n+  private def allowAny(allowPatterns: Set[ResourcePattern], denyPatterns: Set[ResourcePattern]): Boolean =\n+    allowPatterns.exists(pattern => allow(pattern, denyPatterns))\n+\n+  private def allow(pattern: ResourcePattern, denyPatterns: Set[ResourcePattern]): Boolean = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU2NzMxMg==", "bodyText": "We should try to preserve the format for this for compatibility with scripts that parse these logs.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533567312", "createdAt": "2020-12-01T16:53:18Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -456,8 +576,12 @@ class AclAuthorizer extends Authorizer with Logging {\n       val apiKey = if (ApiKeys.hasId(requestContext.requestType)) ApiKeys.forId(requestContext.requestType).name else requestContext.requestType\n       val refCount = action.resourceReferenceCount\n \n-      s\"Principal = $principal is $authResult Operation = $operation \" +\n-        s\"from host = $host on resource = $resource for request = $apiKey with resourceRefCount = $refCount\"\n+      if (byResourceType)\n+        s\"Principal = $principal is $authResult Operation = $operation \" +\n+          s\"from host = $host on at least one resource of type $resourceType for request = $apiKey\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyMjEyNw==", "bodyText": "Do we have a benchmark for updates (not authorize)?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533622127", "createdAt": "2020-12-01T18:15:06Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -550,6 +660,31 @@ class AclAuthorizer extends Authorizer with Logging {\n   }\n \n   private def updateCache(resource: ResourcePattern, versionedAcls: VersionedAcls): Unit = {\n+    val currentAces: Set[AccessControlEntry] = aclCache.get(resource) match {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwMjAwMA=="}, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyMzcxNQ==", "bodyText": "if denyAllResource is true, we can just return DENIED?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533623715", "createdAt": "2020-12-01T18:17:41Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +179,73 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType == ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType == ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op == AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op == AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound && !denyAllResource(requestContext, op, resourceType)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9979f3681e1c6374cb693b17f8440d874169ef5"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYyNjQ2MA==", "bodyText": "Looks like a lot of duplicate code here. We should see how to share code for all this. Can we move the default implementation into SecurityUtils and share some of the matching implementation across the classes?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533626460", "createdAt": "2020-12-01T18:21:58Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +179,73 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType == ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType == ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op == AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op == AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound && !denyAllResource(requestContext, op, resourceType)) {\n+      AuthorizationResult.ALLOWED\n+    } else {\n+      super.authorizeByResourceType(requestContext, op, resourceType)\n+    }\n+  }\n+\n+  private def denyAllResource(requestContext: AuthorizableRequestContext,\n+                      op: AclOperation,\n+                      resourceType: ResourceType): Boolean = {\n+    val resourceTypeFilter = new ResourcePatternFilter(\n+      resourceType, null, PatternType.ANY)\n+    val accessControlEntry = new AccessControlEntryFilter(\n+      null, null, null, AclPermissionType.DENY)\n+    val aclFilter = new AclBindingFilter(resourceTypeFilter, accessControlEntry)\n+\n+    for (binding <- acls(aclFilter).asScala) {\n+      if (aceMatched(requestContext, op, binding) && canDenyAll(binding.pattern()))\n+        return true\n+    }\n+    false\n+  }\n+\n+  @inline\n+  private def aceMatched(requestContext: AuthorizableRequestContext,\n+                 op: AclOperation,\n+                 binding: AclBinding): Boolean = {\n+    (hostMatched(requestContext, binding) && principleMatched(requestContext, binding)\n+      && operationMatched(op, binding))\n+  }\n+\n+  @inline\n+  private def hostMatched(requestContext: AuthorizableRequestContext,\n+                  binding: AclBinding): Boolean =\n+    (binding.entry().host().equals(requestContext.clientAddress().getHostAddress)\n+      || binding.entry().host().equals(AclEntry.WildcardHost))\n+\n+  @inline\n+  private def principleMatched(requestContext: AuthorizableRequestContext,\n+                  binding: AclBinding): Boolean =\n+    (binding.entry().principal().equals(requestContext.principal().toString)\n+      || binding.entry().principal().equals(AclEntry.WildcardPrincipal.toString))\n+\n+  @inline\n+  private def operationMatched(op: AclOperation,\n+                       binding: AclBinding): Boolean =\n+    (binding.entry().operation() == op\n+      || binding.entry().operation() == AclOperation.ALL)\n+\n+  @inline\n+  private def canDenyAll(pattern: ResourcePattern): Boolean =\n+    pattern.patternType() == PatternType.LITERAL && pattern.name().equals(ResourcePattern.WILDCARD_RESOURCE)\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9979f3681e1c6374cb693b17f8440d874169ef5"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYzMDIxMg==", "bodyText": "Should this be && since we we only need one?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533630212", "createdAt": "2020-12-01T18:27:59Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -2109,7 +2104,8 @@ class KafkaApis(val requestChannel: RequestChannel,\n         sendErrorResponseMaybeThrottle(request, Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED.exception)\n         return\n       }\n-    } else if (!authorize(request.context, IDEMPOTENT_WRITE, CLUSTER, CLUSTER_NAME)) {\n+    } else if (!authorize(request.context, IDEMPOTENT_WRITE, CLUSTER, CLUSTER_NAME, true, false)\n+        || !authorizeByResourceType(request.context, AclOperation.WRITE, ResourceType.TOPIC)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9979f3681e1c6374cb693b17f8440d874169ef5"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY0NDU4OQ==", "bodyText": "I wasn't sure what the result shows (not that familiar with the output format, sorry) The useful comparisons would be:\n\nFor authorizeByResourceType, what is the performance advantage we get by using this duplicate cache versus just using aclCache.\nWhat is the impact on updates which hold a lock for maintaining two caches (without the PR vs with this PR)\nDoes this PR impact regular authorize() calls? I think the answer is no.\n\nIn any case, it seems unnecessary to maintain a second cache with all ACLs. We never use authorizeByResourceType for anything other than topics, so it seems a waste to store ACLs for other resource types here. We could just use super.authorizeByResourceType for other types.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533644589", "createdAt": "2020-12-01T18:51:24Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -130,6 +130,11 @@ class AclAuthorizer extends Authorizer with Logging {\n \n   @volatile\n   private var aclCache = new scala.collection.immutable.TreeMap[ResourcePattern, VersionedAcls]()(new ResourceOrdering)\n+\n+  @volatile\n+  private var resourceCache = new scala.collection.immutable.HashMap[AccessControlEntry,\n+    scala.collection.mutable.HashSet[ResourcePattern]]()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4NzE3Ng=="}, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyMDQyNQ==", "bodyText": "This should perhaps be called DelegatingAuthorizer rather than MockAuthorizer since it is not a mock and requires ZK.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533720425", "createdAt": "2020-12-01T21:04:39Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/MockAuthorizer.scala", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.{lang, util}\n+import java.util.concurrent.CompletionStage\n+\n+import org.apache.kafka.common.Endpoint\n+import org.apache.kafka.common.acl.{AclBinding, AclBindingFilter}\n+import org.apache.kafka.server.authorizer.{AclCreateResult, AclDeleteResult, Action, AuthorizableRequestContext, AuthorizationResult, Authorizer, AuthorizerServerInfo}\n+\n+object MockAuthorizer {\n+    val authorizer = new AclAuthorizer\n+}\n+\n+/**\n+ * A mock authorizer for testing the interface default\n+ */\n+class MockAuthorizer extends Authorizer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUwNDI0NA=="}, "originalCommit": {"oid": "594e35099c6af000503f99d1028375a3f2da0014"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyMDk3MQ==", "bodyText": "I am not sure why we would make this change. If we need the change because we have become slower, we need to understand why.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533720971", "createdAt": "2020-12-01T21:05:42Z", "author": {"login": "rajinisivaram"}, "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -69,33 +70,39 @@\n @BenchmarkMode(Mode.AverageTime)\n @OutputTimeUnit(TimeUnit.MILLISECONDS)\n public class AclAuthorizerBenchmark {\n-    @Param({\"10000\", \"50000\", \"200000\"})\n+    @Param({\"10000\", \"40000\", \"80000\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9979f3681e1c6374cb693b17f8440d874169ef5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyMjM0OQ==", "bodyText": "spelling: principal", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533722349", "createdAt": "2020-12-01T21:08:29Z", "author": {"login": "rajinisivaram"}, "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -115,45 +122,62 @@ private void setFieldValue(Object obj, String fieldName, Object value) throws Ex\n \n             Set<AclEntry> entries = aclEntries.computeIfAbsent(resource, k -> new HashSet<>());\n \n-            for (int aclId = 0; aclId < aclCount; aclId++) {\n-                AccessControlEntry ace = new AccessControlEntry(principal.toString() + aclId,\n-                    \"*\", AclOperation.READ, AclPermissionType.ALLOW);\n-                entries.add(new AclEntry(ace));\n+            for (int aclId = 0; aclId < aclCount / 2; aclId++) {\n+                String acePrinciple = principal.toString() + (aclId == 0 ? \"\" : aclId);\n+                AccessControlEntry allowAce = new AccessControlEntry(\n+                    acePrinciple,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9979f3681e1c6374cb693b17f8440d874169ef5"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyMzgzNg==", "bodyText": "We probably want to retain the old benchmark as-is and add a different one for authorizeByResourceType. We were testing a common pattern before, but now we seem to be testing a very unlikely scenario. While this may be useful for testing authorizeByResourceType, it is not what we want for regression testing the authorizer.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533723836", "createdAt": "2020-12-01T21:11:24Z", "author": {"login": "rajinisivaram"}, "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -115,45 +122,62 @@ private void setFieldValue(Object obj, String fieldName, Object value) throws Ex\n \n             Set<AclEntry> entries = aclEntries.computeIfAbsent(resource, k -> new HashSet<>());\n \n-            for (int aclId = 0; aclId < aclCount; aclId++) {\n-                AccessControlEntry ace = new AccessControlEntry(principal.toString() + aclId,\n-                    \"*\", AclOperation.READ, AclPermissionType.ALLOW);\n-                entries.add(new AclEntry(ace));\n+            for (int aclId = 0; aclId < aclCount / 2; aclId++) {\n+                String acePrinciple = principal.toString() + (aclId == 0 ? \"\" : aclId);\n+                AccessControlEntry allowAce = new AccessControlEntry(\n+                    acePrinciple,\n+                    \"*\", AclOperation.WRITE, AclPermissionType.ALLOW);\n+                AccessControlEntry denyAce = new AccessControlEntry(\n+                    acePrinciple,\n+                    \"*\", AclOperation.WRITE, AclPermissionType.DENY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9979f3681e1c6374cb693b17f8440d874169ef5"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyNDM3OQ==", "bodyText": "spelling: principal (multiple places)", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533724379", "createdAt": "2020-12-01T21:12:21Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +179,73 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    if (resourceType == ResourceType.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter resource type for authorizeByResourceType\")\n+\n+    if (resourceType == ResourceType.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown resource type\")\n+\n+    if (op == AclOperation.ANY)\n+      throw new IllegalArgumentException(\"Must specify a non-filter operation type for authorizeByResourceType\")\n+\n+    if (op == AclOperation.UNKNOWN)\n+      throw new IllegalArgumentException(\"Unknown operation type\")\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound && !denyAllResource(requestContext, op, resourceType)) {\n+      AuthorizationResult.ALLOWED\n+    } else {\n+      super.authorizeByResourceType(requestContext, op, resourceType)\n+    }\n+  }\n+\n+  private def denyAllResource(requestContext: AuthorizableRequestContext,\n+                      op: AclOperation,\n+                      resourceType: ResourceType): Boolean = {\n+    val resourceTypeFilter = new ResourcePatternFilter(\n+      resourceType, null, PatternType.ANY)\n+    val accessControlEntry = new AccessControlEntryFilter(\n+      null, null, null, AclPermissionType.DENY)\n+    val aclFilter = new AclBindingFilter(resourceTypeFilter, accessControlEntry)\n+\n+    for (binding <- acls(aclFilter).asScala) {\n+      if (aceMatched(requestContext, op, binding) && canDenyAll(binding.pattern()))\n+        return true\n+    }\n+    false\n+  }\n+\n+  @inline\n+  private def aceMatched(requestContext: AuthorizableRequestContext,\n+                 op: AclOperation,\n+                 binding: AclBinding): Boolean = {\n+    (hostMatched(requestContext, binding) && principleMatched(requestContext, binding)\n+      && operationMatched(op, binding))\n+  }\n+\n+  @inline\n+  private def hostMatched(requestContext: AuthorizableRequestContext,\n+                  binding: AclBinding): Boolean =\n+    (binding.entry().host().equals(requestContext.clientAddress().getHostAddress)\n+      || binding.entry().host().equals(AclEntry.WildcardHost))\n+\n+  @inline\n+  private def principleMatched(requestContext: AuthorizableRequestContext,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9979f3681e1c6374cb693b17f8440d874169ef5"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcyNzA4MQ==", "bodyText": "Can we move testing of interfaceDefaultAuthorizer.authorizer into another class? This is AclAuthorizerTest and testing of interfaceDefaultAuthorizer seems unrelated to this test.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r533727081", "createdAt": "2020-12-01T21:17:34Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -82,16 +86,17 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n   override def setUp(): Unit = {\n     super.setUp()\n \n+    val authorizers = Seq(aclAuthorizer, aclAuthorizer2, interfaceDefaultAuthorizer.authorizer)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9979f3681e1c6374cb693b17f8440d874169ef5"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a139ce744a279e4424188008ee5158186b0fcbe", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/1a139ce744a279e4424188008ee5158186b0fcbe", "committedDate": "2020-12-02T05:56:34Z", "message": "Use EnumMap for looping in interface default"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29ac8628089ddf1210072bbf52e01a41e123a718", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/29ac8628089ddf1210072bbf52e01a41e123a718", "committedDate": "2020-12-02T06:02:58Z", "message": "interface default NIT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6d2a39706998160ebe77a854b8bf64268eec68a", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/f6d2a39706998160ebe77a854b8bf64268eec68a", "committedDate": "2020-12-02T06:09:40Z", "message": "move checkArgs to SecurityUtils"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "f6d2a39706998160ebe77a854b8bf64268eec68a", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/f6d2a39706998160ebe77a854b8bf64268eec68a", "committedDate": "2020-12-02T06:09:40Z", "message": "move checkArgs to SecurityUtils"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ab95d3668b3de27a7f6f58fc171a1e2e8925f69", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/6ab95d3668b3de27a7f6f58fc171a1e2e8925f69", "committedDate": "2020-12-02T06:19:20Z", "message": "Change typo principle to principal"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cebbbd47a8e7d318e327e3a279072c718b535abd", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/cebbbd47a8e7d318e327e3a279072c718b535abd", "committedDate": "2020-12-02T20:04:41Z", "message": "preserve the audit log format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18c5c04ad4d8c98dc3cdaa6d15bf70b9991a6b88", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/18c5c04ad4d8c98dc3cdaa6d15bf70b9991a6b88", "committedDate": "2020-12-03T01:05:31Z", "message": "return directly if denyAll in AuthorizerWrapper"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "30899c45ac50b70625baa2e5f12f58cfe9d79404", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/30899c45ac50b70625baa2e5f12f58cfe9d79404", "committedDate": "2020-12-03T03:17:50Z", "message": "Optimize the AuthorizerWrapper"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "30899c45ac50b70625baa2e5f12f58cfe9d79404", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/30899c45ac50b70625baa2e5f12f58cfe9d79404", "committedDate": "2020-12-03T03:17:50Z", "message": "Optimize the AuthorizerWrapper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c550fd04a0c1912e669bf18d60dee27dd03e53c", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/6c550fd04a0c1912e669bf18d60dee27dd03e53c", "committedDate": "2020-12-03T09:11:14Z", "message": "seperate the interfac default tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dcdc415dce0bfe98754a887d635e4e4681df2c71", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/dcdc415dce0bfe98754a887d635e4e4681df2c71", "committedDate": "2020-12-04T03:24:29Z", "message": "Add resourceIndex to further optimize the perf"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5fa4ad07ff7c64687d33efdda39ad42cd1e90be2", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/5fa4ad07ff7c64687d33efdda39ad42cd1e90be2", "committedDate": "2020-12-04T02:20:12Z", "message": "Add resourceIndex to further optimize the perf"}, "afterCommit": {"oid": "dcdc415dce0bfe98754a887d635e4e4681df2c71", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/dcdc415dce0bfe98754a887d635e4e4681df2c71", "committedDate": "2020-12-04T03:24:29Z", "message": "Add resourceIndex to further optimize the perf"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7af4a7ff7ed2dddc06cf11ab7ff2d4b9fee5fb56", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/7af4a7ff7ed2dddc06cf11ab7ff2d4b9fee5fb56", "committedDate": "2020-12-04T18:46:31Z", "message": "add description in interface default, and rename the MockAuthorizer to DelegateAuthorizer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "331cd13887dd1238211c48c13ccc734d0a05483b", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/331cd13887dd1238211c48c13ccc734d0a05483b", "committedDate": "2020-12-04T19:17:53Z", "message": "fix checkstyle"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2b7caf081ecebee092e191fbf85c386968d445b2", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/2b7caf081ecebee092e191fbf85c386968d445b2", "committedDate": "2020-12-04T20:16:03Z", "message": "add benchmark for updateCache"}, "afterCommit": {"oid": "957f3b212f8471ef208490d7ed9e996f5b94eed5", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/957f3b212f8471ef208490d7ed9e996f5b94eed5", "committedDate": "2020-12-04T23:29:15Z", "message": "add benchmark for updateCache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c79a1a075ec008a640f71513adf29eddfd46f12", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/5c79a1a075ec008a640f71513adf29eddfd46f12", "committedDate": "2020-12-07T16:27:09Z", "message": "add benchmark for updateCache"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "957f3b212f8471ef208490d7ed9e996f5b94eed5", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/957f3b212f8471ef208490d7ed9e996f5b94eed5", "committedDate": "2020-12-04T23:29:15Z", "message": "add benchmark for updateCache"}, "afterCommit": {"oid": "5c79a1a075ec008a640f71513adf29eddfd46f12", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/5c79a1a075ec008a640f71513adf29eddfd46f12", "committedDate": "2020-12-07T16:27:09Z", "message": "add benchmark for updateCache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "031c2f41e6611df3d18ef9b709c7d98c91b93326", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/031c2f41e6611df3d18ef9b709c7d98c91b93326", "committedDate": "2020-12-07T16:45:43Z", "message": "fix Api issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a591ef42912d5ce59eb18ec45ed8b95901b72a88", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/a591ef42912d5ce59eb18ec45ed8b95901b72a88", "committedDate": "2020-12-08T09:39:19Z", "message": "add deny percentage to jmh-benchmark"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5e051e978ebdc1995220ce201d9003361e17b6a9", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/5e051e978ebdc1995220ce201d9003361e17b6a9", "committedDate": "2020-12-08T09:38:47Z", "message": "add deny percentage to jmh-benchmark"}, "afterCommit": {"oid": "a591ef42912d5ce59eb18ec45ed8b95901b72a88", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/a591ef42912d5ce59eb18ec45ed8b95901b72a88", "committedDate": "2020-12-08T09:39:19Z", "message": "add deny percentage to jmh-benchmark"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3MzY2MzYy", "url": "https://github.com/apache/kafka/pull/9485#pullrequestreview-547366362", "createdAt": "2020-12-08T15:49:07Z", "commit": {"oid": "a591ef42912d5ce59eb18ec45ed8b95901b72a88"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNTo0OTowOFrOIBkyPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNTo0OTowOFrOIBkyPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUyMjE3Mw==", "bodyText": "nit, unnecessary whitespace in i++.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r538522173", "createdAt": "2020-12-08T15:49:08Z", "author": {"login": "lbradstreet"}, "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -164,4 +206,28 @@ public void testAclsIterator() {\n     public void testAuthorizer() {\n         aclAuthorizer.authorize(context, actions);\n     }\n+\n+    @Benchmark\n+    public void testAuthorizeByResourceType() {\n+        aclAuthorizer.authorizeByResourceType(context, AclOperation.WRITE, ResourceType.TOPIC);\n+    }\n+\n+    @Benchmark\n+    public void testUpdateCache() {\n+        AclAuthorizer aclAuthorizer = new AclAuthorizer();\n+        scala.collection.mutable.Set<AclEntry> entries = new scala.collection.mutable.HashSet<>();\n+        for (int i = 0; i < resourceCount; i ++){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a591ef42912d5ce59eb18ec45ed8b95901b72a88"}, "originalPosition": 193}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3MzY4MDgy", "url": "https://github.com/apache/kafka/pull/9485#pullrequestreview-547368082", "createdAt": "2020-12-08T15:50:44Z", "commit": {"oid": "a591ef42912d5ce59eb18ec45ed8b95901b72a88"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNTo1MDo0NVrOIBk51Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNTo1MDo0NVrOIBk51Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUyNDExNw==", "bodyText": "I think it's useful to understand how the cache performs at smaller sizes as well as larger sizes. Is there a reason we went with a fixed size and fixed number of resources now?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r538524117", "createdAt": "2020-12-08T15:50:45Z", "author": {"login": "lbradstreet"}, "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -69,33 +73,44 @@\n @BenchmarkMode(Mode.AverageTime)\n @OutputTimeUnit(TimeUnit.MILLISECONDS)\n public class AclAuthorizerBenchmark {\n-    @Param({\"10000\", \"50000\", \"200000\"})\n+    @Param({\"200000\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a591ef42912d5ce59eb18ec45ed8b95901b72a88"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3MzcxNTUw", "url": "https://github.com/apache/kafka/pull/9485#pullrequestreview-547371550", "createdAt": "2020-12-08T15:54:15Z", "commit": {"oid": "a591ef42912d5ce59eb18ec45ed8b95901b72a88"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNTo1NDoxNVrOIBlJDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNTo1NDoxNVrOIBlJDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUyODAxNQ==", "bodyText": "It might be better for the purpose of this microbenchmark to setup the cache with the desired size ahead of the time and then measure the time to update the cache with one entry. Otherwise you risk measuring a lot of the setup costs rather than the cost of the typical usage.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r538528015", "createdAt": "2020-12-08T15:54:15Z", "author": {"login": "lbradstreet"}, "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -164,4 +206,28 @@ public void testAclsIterator() {\n     public void testAuthorizer() {\n         aclAuthorizer.authorize(context, actions);\n     }\n+\n+    @Benchmark\n+    public void testAuthorizeByResourceType() {\n+        aclAuthorizer.authorizeByResourceType(context, AclOperation.WRITE, ResourceType.TOPIC);\n+    }\n+\n+    @Benchmark\n+    public void testUpdateCache() {\n+        AclAuthorizer aclAuthorizer = new AclAuthorizer();\n+        scala.collection.mutable.Set<AclEntry> entries = new scala.collection.mutable.HashSet<>();\n+        for (int i = 0; i < resourceCount; i ++){\n+            scala.collection.immutable.Set<AclEntry> immutable = new scala.collection.immutable.HashSet<>();\n+            for (int j = 0; j < aclCount; j++) {\n+                entries.add(new AclEntry(new AccessControlEntry(\n+                    principal.toString(), \"127.0.0\" + j, AclOperation.WRITE, AclPermissionType.ALLOW)));\n+                immutable = entries.toSet();\n+            }\n+            aclAuthorizer.updateCache(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a591ef42912d5ce59eb18ec45ed8b95901b72a88"}, "originalPosition": 200}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3Mzk0MDY3", "url": "https://github.com/apache/kafka/pull/9485#pullrequestreview-547394067", "createdAt": "2020-12-08T16:16:33Z", "commit": {"oid": "a591ef42912d5ce59eb18ec45ed8b95901b72a88"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjoxNjozM1rOIBmt-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjoxNjozM1rOIBmt-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU1Mzg1MQ==", "bodyText": "If you take an async profile of this benchmark method you end up spending most of the time in building the entries and immutable set, and barely any time on AclAuthorizer#updateCache.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r538553851", "createdAt": "2020-12-08T16:16:33Z", "author": {"login": "lbradstreet"}, "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -164,4 +206,28 @@ public void testAclsIterator() {\n     public void testAuthorizer() {\n         aclAuthorizer.authorize(context, actions);\n     }\n+\n+    @Benchmark\n+    public void testAuthorizeByResourceType() {\n+        aclAuthorizer.authorizeByResourceType(context, AclOperation.WRITE, ResourceType.TOPIC);\n+    }\n+\n+    @Benchmark\n+    public void testUpdateCache() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a591ef42912d5ce59eb18ec45ed8b95901b72a88"}, "originalPosition": 190}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/40c0cad01590e137eac4ad1bb859f3d97b62a245", "committedDate": "2020-12-08T20:03:56Z", "message": "checkstyle & NIT"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4NTQ2MjA1", "url": "https://github.com/apache/kafka/pull/9485#pullrequestreview-548546205", "createdAt": "2020-12-09T19:42:16Z", "commit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "state": "COMMENTED", "comments": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOTo0MjoxN1rOICmOjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMDo1MjoxNFrOICo8WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5NDM4Mg==", "bodyText": "This package is part of the public API, but the class looks like it should be internal?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539594382", "createdAt": "2020-12-09T19:42:17Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/common/acl/ResourceIndex.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.acl;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5NTU4NA==", "bodyText": "Perhaps ResourceAclEntry or something along those lines would be better than ResourceIndex since this class has no notion of index.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539595584", "createdAt": "2020-12-09T19:44:19Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/common/acl/ResourceIndex.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.acl;\n+\n+import org.apache.kafka.common.resource.PatternType;\n+import org.apache.kafka.common.resource.ResourceType;\n+\n+import java.util.Objects;\n+\n+public class ResourceIndex {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5OTQzMA==", "bodyText": "Can we remove the TODO comments?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539599430", "createdAt": "2020-12-09T19:50:25Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,105 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwMjgwOQ==", "bodyText": "In the typical case, we have a large number of allowLiterals and allowPrefixes, no denyLiterals or denPrefixes. I think it would make sense to special case denyLiterals.isEmpty && denyPrefixes.isEmpty. In this case, we don't need to find all matching resources, we just need to check that there is at least one matching resource.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539602809", "createdAt": "2020-12-09T19:55:39Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,105 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName).toString\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+    val denyPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNDM2MA==", "bodyText": "Why can't this be a Set instead of List of Sets?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539604360", "createdAt": "2020-12-09T19:58:05Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,105 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName).toString\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+    val denyPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[mutable.HashSet[String]] = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNDg0NQ==", "bodyText": "AclEntry.WildcardPrincipalString", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539604845", "createdAt": "2020-12-09T19:58:51Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,105 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName).toString\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+    val denyPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[mutable.HashSet[String]] = {\n+    var matched = List[mutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipal.toString)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNzIyMw==", "bodyText": "This method can be in SecurityUtils and shared with the default authorizer?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539607223", "createdAt": "2020-12-09T20:02:33Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,105 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName).toString\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+    val denyPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[mutable.HashSet[String]] = {\n+    var matched = List[mutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipal.toString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val ace = new AccessControlEntry(p, h, o, permission)\n+          val resourceIndex = new ResourceIndex(ace, resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def denyAll(denyLiterals: List[mutable.HashSet[String]]): Boolean =\n+    denyLiterals.exists(r => r.contains(ResourcePattern.WILDCARD_RESOURCE))\n+\n+\n+  private def allowAny(allowLiterals: List[mutable.Set[String]], allowPrefixes: List[mutable.Set[String]],\n+                       denyLiterals: List[mutable.Set[String]], denyPrefixes: List[mutable.Set[String]]): Boolean = {\n+    (allowPrefixes.exists(prefixes =>\n+          prefixes.exists(prefix => allowPrefix(prefix, denyPrefixes)))\n+      || allowLiterals.exists(literals =>\n+            literals.exists(literal => allowLiteral(literal, denyLiterals, denyPrefixes))))\n+  }\n+\n+  private def allowLiteral(literalName: String,\n+                           denyLiterals: List[mutable.Set[String]], denyPrefixes: List[mutable.Set[String]]): Boolean = {\n+    literalName match{\n+      case ResourcePattern.WILDCARD_RESOURCE => true\n+      case _ => (denyLiterals.forall(denyLiterals => !denyLiterals.contains(literalName))\n+                    && !hasDominantPrefixedDeny(literalName, denyPrefixes))\n+    }\n+  }\n+\n+  private def allowPrefix(prefixName: String,\n+                          denyPrefixes: List[mutable.Set[String]]): Boolean = {\n+    !hasDominantPrefixedDeny(prefixName, denyPrefixes)\n+  }\n+\n+  private def hasDominantPrefixedDeny(resourceName: String, denyPrefixes: List[mutable.Set[String]]): Boolean = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNzU2Mw==", "bodyText": "private def?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539607563", "createdAt": "2020-12-09T20:03:07Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,105 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName).toString\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+    val denyPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[mutable.HashSet[String]] = {\n+    var matched = List[mutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipal.toString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val ace = new AccessControlEntry(p, h, o, permission)\n+          val resourceIndex = new ResourceIndex(ace, resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def denyAll(denyLiterals: List[mutable.HashSet[String]]): Boolean =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYxMjUzNg==", "bodyText": "We cannot do this here. AuthorizerWrapper is used to wrap any custom authorizer using the old Authorizer API. AllowEveryoneIfNoAclIsFoundProp is a custom config of SimpleAclAuthorizer and AclAuthorizer, we cannot use that with any custom authorizer. We should find a way to support the config for SimpleAclAuthorizer that doesn't impact other custom authorizers.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539612536", "createdAt": "2020-12-09T20:11:00Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -71,15 +73,19 @@ object AuthorizerWrapper {\n   }\n \n   def convertToResource(resourcePattern: ResourcePattern): Resource = {\n-    Resource(ResourceType.fromJava(resourcePattern.resourceType), resourcePattern.name, resourcePattern.patternType)\n+    Resource(ResourceTypeLegacy.fromJava(resourcePattern.resourceType), resourcePattern.name, resourcePattern.patternType)\n   }\n }\n \n @deprecated(\"Use kafka.security.authorizer.AclAuthorizer\", \"Since 2.5\")\n class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.Authorizer) extends Authorizer {\n \n+  var shouldAllowEveryoneIfNoAclIsFound = false\n+\n   override def configure(configs: util.Map[String, _]): Unit = {\n     baseAuthorizer.configure(configs)\n+    shouldAllowEveryoneIfNoAclIsFound = configs.asScala.get(\n+      AclAuthorizer.AllowEveryoneIfNoAclIsFoundProp).exists(_.toString.toBoolean)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYxNDcxOQ==", "bodyText": "Does this work with an ACL with wildcard host?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539614719", "createdAt": "2020-12-09T20:14:37Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +181,32 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    if (denyAllResource(requestContext, op, resourceType)) {\n+      AuthorizationResult.DENIED\n+    } else if (shouldAllowEveryoneIfNoAclIsFound) {\n+      AuthorizationResult.ALLOWED\n+    } else {\n+      super.authorizeByResourceType(requestContext, op, resourceType)\n+    }\n+  }\n+\n+  private def denyAllResource(requestContext: AuthorizableRequestContext,\n+                      op: AclOperation,\n+                      resourceType: ResourceType): Boolean = {\n+    val resourceTypeFilter = new ResourcePatternFilter(\n+      resourceType, null, PatternType.ANY)\n+    val principal = new KafkaPrincipal(requestContext.principal.getPrincipalType, requestContext.principal.getName)\n+    val accessControlEntry = new AccessControlEntryFilter(\n+      principal.toString, requestContext.clientAddress().getHostAddress, op, AclPermissionType.DENY)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYxNDczOQ==", "bodyText": "Does this work with an ACL with wildcard host?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539614739", "createdAt": "2020-12-09T20:14:38Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +181,32 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    if (denyAllResource(requestContext, op, resourceType)) {\n+      AuthorizationResult.DENIED\n+    } else if (shouldAllowEveryoneIfNoAclIsFound) {\n+      AuthorizationResult.ALLOWED\n+    } else {\n+      super.authorizeByResourceType(requestContext, op, resourceType)\n+    }\n+  }\n+\n+  private def denyAllResource(requestContext: AuthorizableRequestContext,\n+                      op: AclOperation,\n+                      resourceType: ResourceType): Boolean = {\n+    val resourceTypeFilter = new ResourcePatternFilter(\n+      resourceType, null, PatternType.ANY)\n+    val principal = new KafkaPrincipal(requestContext.principal.getPrincipalType, requestContext.principal.getName)\n+    val accessControlEntry = new AccessControlEntryFilter(\n+      principal.toString, requestContext.clientAddress().getHostAddress, op, AclPermissionType.DENY)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYxNTE4OQ==", "bodyText": "The main logic of this could potentially be moved to SecurityUtils since the default Authorizer implementation, AclAuthorizer and the wrapper all do this.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539615189", "createdAt": "2020-12-09T20:15:25Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +181,32 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    if (denyAllResource(requestContext, op, resourceType)) {\n+      AuthorizationResult.DENIED\n+    } else if (shouldAllowEveryoneIfNoAclIsFound) {\n+      AuthorizationResult.ALLOWED\n+    } else {\n+      super.authorizeByResourceType(requestContext, op, resourceType)\n+    }\n+  }\n+\n+  private def denyAllResource(requestContext: AuthorizableRequestContext,\n+                      op: AclOperation,\n+                      resourceType: ResourceType): Boolean = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzMDA4NA==", "bodyText": "Why do we need this in tearDown?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539630084", "createdAt": "2020-12-09T20:37:40Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -100,8 +106,15 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n \n   @After\n   override def tearDown(): Unit = {\n-    aclAuthorizer.close()\n-    aclAuthorizer2.close()\n+    val authorizers = Seq(aclAuthorizer, aclAuthorizer2)\n+    authorizers.foreach(a => {\n+      a.acls(AclBindingFilter.ANY).forEach(bd => {\n+        removeAcls(aclAuthorizer, Set(bd.entry), bd.pattern())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzMTQyNQ==", "bodyText": "a lot of these changes look unnecessary", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539631425", "createdAt": "2020-12-09T20:40:04Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -1040,19 +1117,24 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n       securityProtocol, ClientInformation.EMPTY, false)\n   }\n \n-  private def authorize(authorizer: AclAuthorizer, requestContext: RequestContext, operation: AclOperation, resource: ResourcePattern): Boolean = {\n+  private def authorize(authorizer: Authorizer, requestContext: RequestContext, operation: AclOperation, resource: ResourcePattern): Boolean = {\n     val action = new Action(operation, resource, 1, true, true)\n     authorizer.authorize(requestContext, List(action).asJava).asScala.head == AuthorizationResult.ALLOWED\n   }\n \n-  private def addAcls(authorizer: AclAuthorizer, aces: Set[AccessControlEntry], resourcePattern: ResourcePattern): Unit = {\n+  private def authorizeByResourceType(authorizer: Authorizer, requestContext: RequestContext, operation: AclOperation, resourceType: ResourceType) : Boolean = {\n+    authorizer.authorizeByResourceType(requestContext, operation, resourceType) == AuthorizationResult.ALLOWED\n+  }\n+\n+  private def addAcls(authorizer: Authorizer, aces: Set[AccessControlEntry], resourcePattern: ResourcePattern): Unit = {\n     val bindings = aces.map { ace => new AclBinding(resourcePattern, ace) }\n     authorizer.createAcls(requestContext, bindings.toList.asJava).asScala\n       .map(_.toCompletableFuture.get)\n       .foreach { result => result.exception.ifPresent { e => throw e } }\n+    aclAdded += Tuple3(authorizer, aces, resourcePattern)\n   }\n \n-  private def removeAcls(authorizer: AclAuthorizer, aces: Set[AccessControlEntry], resourcePattern: ResourcePattern): Boolean = {\n+  private def removeAcls(authorizer: Authorizer, aces: Set[AccessControlEntry], resourcePattern: ResourcePattern): Boolean = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzMjQyNg==", "bodyText": "looks like this hasn't been reverted?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539632426", "createdAt": "2020-12-09T20:41:50Z", "author": {"login": "rajinisivaram"}, "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -69,33 +73,44 @@\n @BenchmarkMode(Mode.AverageTime)\n @OutputTimeUnit(TimeUnit.MILLISECONDS)\n public class AclAuthorizerBenchmark {\n-    @Param({\"10000\", \"50000\", \"200000\"})\n+    @Param({\"200000\"})", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUyNDExNw=="}, "originalCommit": {"oid": "a591ef42912d5ce59eb18ec45ed8b95901b72a88"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzMjY1Mw==", "bodyText": "revert?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539632653", "createdAt": "2020-12-09T20:42:14Z", "author": {"login": "rajinisivaram"}, "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -69,33 +73,44 @@\n @BenchmarkMode(Mode.AverageTime)\n @OutputTimeUnit(TimeUnit.MILLISECONDS)\n public class AclAuthorizerBenchmark {\n-    @Param({\"10000\", \"50000\", \"200000\"})\n+    @Param({\"200000\"})\n     private int resourceCount;\n     //no. of. rules per resource\n-    @Param({\"10\", \"50\"})\n+    @Param({\"50\"})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzNDc4OQ==", "bodyText": "why? This no longer reflects the comment above. Can we revert?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539634789", "createdAt": "2020-12-09T20:45:38Z", "author": {"login": "rajinisivaram"}, "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -69,33 +73,44 @@\n @BenchmarkMode(Mode.AverageTime)\n @OutputTimeUnit(TimeUnit.MILLISECONDS)\n public class AclAuthorizerBenchmark {\n-    @Param({\"10000\", \"50000\", \"200000\"})\n+    @Param({\"200000\"})\n     private int resourceCount;\n     //no. of. rules per resource\n-    @Param({\"10\", \"50\"})\n+    @Param({\"50\"})\n     private int aclCount;\n \n+    @Param({\"0\", \"20\", \"50\", \"90\", \"99\", \"99.9\", \"99.99\", \"100\"})\n+    private double denyPercentage;\n+\n     private final int hostPreCount = 1000;\n     private final String resourceNamePrefix = \"foo-bar35_resource-\";\n+    private final String resourceName = resourceNamePrefix + 95;\n \n     private final AclAuthorizer aclAuthorizer = new AclAuthorizer();\n     private final KafkaPrincipal principal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"test-user\");\n     private List<Action> actions = new ArrayList<>();\n     private RequestContext context;\n \n+    private TreeMap<ResourcePattern, VersionedAcls> aclCache = new TreeMap<>(new AclAuthorizer.ResourceOrdering());\n+    private scala.collection.mutable.HashMap<ResourceIndex, scala.collection.mutable.HashSet<String>> resourceCache =\n+        new scala.collection.mutable.HashMap<>();\n+    Random rand = new Random(System.currentTimeMillis());\n+    double eps = 1e-9;\n+\n     @Setup(Level.Trial)\n     public void setup() throws Exception {\n-        setFieldValue(aclAuthorizer, AclAuthorizer.class.getDeclaredField(\"aclCache\").getName(),\n-            prepareAclCache());\n+        prepareAclCache();\n+        setFieldValue(aclAuthorizer, AclAuthorizer.class.getDeclaredField(\"aclCache\").getName(), aclCache);\n+        setFieldValue(aclAuthorizer, AclAuthorizer.class.getDeclaredField(\"resourceCache\").getName(), resourceCache);\n         // By adding `-95` to the resource name prefix, we cause the `TreeMap.from/to` call to return\n         // most map entries. In such cases, we rely on the filtering based on `String.startsWith`\n         // to return the matching ACLs. Using a more efficient data structure (e.g. a prefix\n         // tree) should improve performance significantly).\n         actions = Collections.singletonList(new Action(AclOperation.WRITE,\n-            new ResourcePattern(ResourceType.TOPIC, resourceNamePrefix + 95, PatternType.LITERAL),\n+            new ResourcePattern(ResourceType.TOPIC, resourceName, PatternType.LITERAL),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzNTQyNg==", "bodyText": "We should revert changes to existing benchmark because it hard to tell why these changes were made and what impact it has on the original benchmark.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539635426", "createdAt": "2020-12-09T20:46:42Z", "author": {"login": "rajinisivaram"}, "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -105,49 +120,76 @@ private void setFieldValue(Object obj, String fieldName, Object value) throws Ex\n         field.set(obj, value);\n     }\n \n-    private TreeMap<ResourcePattern, VersionedAcls> prepareAclCache() {\n+    private void prepareAclCache() throws UnknownHostException {\n         Map<ResourcePattern, Set<AclEntry>> aclEntries = new HashMap<>();\n         for (int resourceId = 0; resourceId < resourceCount; resourceId++) {\n             ResourcePattern resource = new ResourcePattern(\n                 (resourceId % 10 == 0) ? ResourceType.GROUP : ResourceType.TOPIC,\n-                resourceNamePrefix + resourceId,\n+                resourceName(resourceNamePrefix),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzODg3Mg==", "bodyText": "It makes sense to merge the benchmarks to trunk. Let's make sure it measures just updateCache.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r539638872", "createdAt": "2020-12-09T20:52:14Z", "author": {"login": "rajinisivaram"}, "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -164,4 +206,28 @@ public void testAclsIterator() {\n     public void testAuthorizer() {\n         aclAuthorizer.authorize(context, actions);\n     }\n+\n+    @Benchmark\n+    public void testAuthorizeByResourceType() {\n+        aclAuthorizer.authorizeByResourceType(context, AclOperation.WRITE, ResourceType.TOPIC);\n+    }\n+\n+    @Benchmark\n+    public void testUpdateCache() {\n+        AclAuthorizer aclAuthorizer = new AclAuthorizer();\n+        scala.collection.mutable.Set<AclEntry> entries = new scala.collection.mutable.HashSet<>();\n+        for (int i = 0; i < resourceCount; i ++){\n+            scala.collection.immutable.Set<AclEntry> immutable = new scala.collection.immutable.HashSet<>();\n+            for (int j = 0; j < aclCount; j++) {\n+                entries.add(new AclEntry(new AccessControlEntry(\n+                    principal.toString(), \"127.0.0\" + j, AclOperation.WRITE, AclPermissionType.ALLOW)));\n+                immutable = entries.toSet();\n+            }\n+            aclAuthorizer.updateCache(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUyODAxNQ=="}, "originalCommit": {"oid": "a591ef42912d5ce59eb18ec45ed8b95901b72a88"}, "originalPosition": 200}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2fd4babe2c27ee0723fa1cd720ca35d2bbefe57b", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/2fd4babe2c27ee0723fa1cd720ca35d2bbefe57b", "committedDate": "2020-12-09T23:52:34Z", "message": "NIT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1dc143fc78a3b9927189751255346ef0b6cafd90", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/1dc143fc78a3b9927189751255346ef0b6cafd90", "committedDate": "2020-12-10T00:24:56Z", "message": "handle the special case where no deny resources exists, improve the performance"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e139df0ba64cb86507d9ec742214054791a45fe", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/1e139df0ba64cb86507d9ec742214054791a45fe", "committedDate": "2020-12-10T18:57:09Z", "message": "improve the allowEveryoneIfNoAclFound checking logic"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2ed79a0a7788f8841475badfd1c26adf0eb3435c", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/2ed79a0a7788f8841475badfd1c26adf0eb3435c", "committedDate": "2020-12-10T18:49:22Z", "message": "improve the allowEveryoneIfNoAclFound checking logic"}, "afterCommit": {"oid": "1e139df0ba64cb86507d9ec742214054791a45fe", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/1e139df0ba64cb86507d9ec742214054791a45fe", "committedDate": "2020-12-10T18:57:09Z", "message": "improve the allowEveryoneIfNoAclFound checking logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67b3163bbf6562bdad1ba054b813a454f9be2363", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/67b3163bbf6562bdad1ba054b813a454f9be2363", "committedDate": "2020-12-10T21:20:49Z", "message": "rename authorizeAny to authorizeByResourcetype in tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8263bd319f63d39808f90129db55427b98385dd4", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/8263bd319f63d39808f90129db55427b98385dd4", "committedDate": "2020-12-11T03:05:23Z", "message": "Fix the issue that the wildcard host and principle didn't work in AuthorizerWrapper"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "83d1f8840933a28934f261ca6affc820a8ececd5", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/83d1f8840933a28934f261ca6affc820a8ececd5", "committedDate": "2020-12-11T03:02:15Z", "message": "Fix the issue that the wildcard host and principle didn't work in AuthorizerWrapper"}, "afterCommit": {"oid": "8263bd319f63d39808f90129db55427b98385dd4", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/8263bd319f63d39808f90129db55427b98385dd4", "committedDate": "2020-12-11T03:05:23Z", "message": "Fix the issue that the wildcard host and principle didn't work in AuthorizerWrapper"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "13ffb06d820b23f8a9661f0a10772434ad0b329a", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/13ffb06d820b23f8a9661f0a10772434ad0b329a", "committedDate": "2020-12-11T19:46:43Z", "message": "Revert benchmark changes"}, "afterCommit": {"oid": "b90763947d4d7d6a3f42e12a7a440a7a212a73de", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/b90763947d4d7d6a3f42e12a7a440a7a212a73de", "committedDate": "2020-12-11T19:51:51Z", "message": "Revert benchmark changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b90763947d4d7d6a3f42e12a7a440a7a212a73de", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/b90763947d4d7d6a3f42e12a7a440a7a212a73de", "committedDate": "2020-12-11T19:51:51Z", "message": "Revert benchmark changes"}, "afterCommit": {"oid": "dea46b04516382285dc42f088f3f896b7c10cc64", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/dea46b04516382285dc42f088f3f896b7c10cc64", "committedDate": "2020-12-12T06:29:25Z", "message": "Revert benchmark changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6536cea788210860a764f3f0a6901244e8d974fe", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/6536cea788210860a764f3f0a6901244e8d974fe", "committedDate": "2020-12-12T20:01:42Z", "message": "Revert benchmark changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dea46b04516382285dc42f088f3f896b7c10cc64", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/dea46b04516382285dc42f088f3f896b7c10cc64", "committedDate": "2020-12-12T06:29:25Z", "message": "Revert benchmark changes"}, "afterCommit": {"oid": "6536cea788210860a764f3f0a6901244e8d974fe", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/6536cea788210860a764f3f0a6901244e8d974fe", "committedDate": "2020-12-12T20:01:42Z", "message": "Revert benchmark changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f9b79a810c4da3030fe262d4bfdc97df4945e8c", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/4f9b79a810c4da3030fe262d4bfdc97df4945e8c", "committedDate": "2020-12-12T21:01:46Z", "message": "revert unnecessary test re-writes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1cd55bc4f433fc40755772623c16fb0c06cdd95b", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/1cd55bc4f433fc40755772623c16fb0c06cdd95b", "committedDate": "2020-12-12T20:46:47Z", "message": "revert unnecessary test re-writes"}, "afterCommit": {"oid": "4f9b79a810c4da3030fe262d4bfdc97df4945e8c", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/4f9b79a810c4da3030fe262d4bfdc97df4945e8c", "committedDate": "2020-12-12T21:01:46Z", "message": "revert unnecessary test re-writes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd48b22aff2802c191fd555fa894a5d1081f68ca", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/dd48b22aff2802c191fd555fa894a5d1081f68ca", "committedDate": "2020-12-14T04:40:18Z", "message": "fix checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxODk1MzQ5", "url": "https://github.com/apache/kafka/pull/9485#pullrequestreview-551895349", "createdAt": "2020-12-14T21:10:15Z", "commit": {"oid": "dd48b22aff2802c191fd555fa894a5d1081f68ca"}, "state": "COMMENTED", "comments": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMToxMDoxNlrOIFpTbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMzowMDozNVrOIFwWmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc5MDUxMA==", "bodyText": "We have to move the class outside of the public package, so putting it alongside AclAuthorizer makes sense.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542790510", "createdAt": "2020-12-14T21:10:16Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/common/acl/ResourceIndex.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.acl;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5NDM4Mg=="}, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgzMDA5OA==", "bodyText": "Since this is the javadoc of a public API, we should move the details on how the default implementation works outside of the javadoc. We can move this list of comments inside the method.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542830098", "createdAt": "2020-12-14T21:47:04Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +151,126 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * 1. Filter out all the resource pattern corresponding to the requestContext, AclOperation,\n+     *    and ResourceType\n+     * 2. If wildcard deny exists, return deny directly\n+     * 3. For any literal allowed resource, if there's no dominant literal denied resource, and\n+     *    no dominant prefixed denied resource, return allow\n+     * 4. For any prefixed allowed resource, if there's no dominant denied resource, return allow\n+     * 5. For any other cases, return deny", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd48b22aff2802c191fd555fa894a5d1081f68ca"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg1MTU1MQ==", "bodyText": "We don't currently have anything in the default implementation to support super.users right? Unlike allow.everyone.if.no.acl.found which is not particularly suitable for production use, super.users is a commonly used config that is likely to be in use in a lot of deployments. The simplest fix may be to authorize() with a hard-coded name and return ALLOWED if authorize() returns ALLOWED before any of the logic below is executed.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542851551", "createdAt": "2020-12-14T22:07:06Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +151,126 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * 1. Filter out all the resource pattern corresponding to the requestContext, AclOperation,\n+     *    and ResourceType\n+     * 2. If wildcard deny exists, return deny directly\n+     * 3. For any literal allowed resource, if there's no dominant literal denied resource, and\n+     *    no dominant prefixed denied resource, return allow\n+     * 4. For any prefixed allowed resource, if there's no dominant denied resource, return allow\n+     * 5. For any other cases, return deny\n+     *\n+     * It is important to override this interface default in implementations because\n+     * 1. The interface default iterates all AclBindings multiple times, without any indexing,\n+     *    which is a CPU intense work.\n+     * 2. The interface default rebuild several sets of strings, which is a memory intense work.\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd48b22aff2802c191fd555fa894a5d1081f68ca"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg1NDYyOQ==", "bodyText": "This needs to be an immutable map or a ConcurrentHashMap since we read this without lock.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542854629", "createdAt": "2020-12-14T22:09:57Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -130,6 +130,10 @@ class AclAuthorizer extends Authorizer with Logging {\n \n   @volatile\n   private var aclCache = new scala.collection.immutable.TreeMap[ResourcePattern, VersionedAcls]()(new ResourceOrdering)\n+\n+  private val resourceCache = new scala.collection.mutable.HashMap[ResourceIndex,\n+    scala.collection.mutable.HashSet[String]]()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd48b22aff2802c191fd555fa894a5d1081f68ca"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg1NTMxNg==", "bodyText": "We need to check if the principal is a super.user and return ALLOWED for super users before executing any of the logic below.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542855316", "createdAt": "2020-12-14T22:10:36Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,131 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName).toString", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd48b22aff2802c191fd555fa894a5d1081f68ca"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg2MDk2OQ==", "bodyText": "ok, makes sense", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542860969", "createdAt": "2020-12-14T22:16:10Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,105 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName).toString\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+    val denyPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[mutable.HashSet[String]] = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNDM2MA=="}, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg2MTgzOQ==", "bodyText": "ok, let's leave as is.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542861839", "createdAt": "2020-12-14T22:16:57Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +308,105 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  // TODO: 1. Discuss how to log audit message\n+  // TODO: 2. Discuss if we need a trie to optimize\uff08mainly for the O(n^2) loop but I think\n+  //  in most of the cases it would be O(1) because denyDominatePrefixAllow should be rare\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName).toString\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+    val denyPrefixes = matchingResources(\n+      principal, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[mutable.HashSet[String]] = {\n+    var matched = List[mutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipal.toString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val ace = new AccessControlEntry(p, h, o, permission)\n+          val resourceIndex = new ResourceIndex(ace, resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def denyAll(denyLiterals: List[mutable.HashSet[String]]): Boolean =\n+    denyLiterals.exists(r => r.contains(ResourcePattern.WILDCARD_RESOURCE))\n+\n+\n+  private def allowAny(allowLiterals: List[mutable.Set[String]], allowPrefixes: List[mutable.Set[String]],\n+                       denyLiterals: List[mutable.Set[String]], denyPrefixes: List[mutable.Set[String]]): Boolean = {\n+    (allowPrefixes.exists(prefixes =>\n+          prefixes.exists(prefix => allowPrefix(prefix, denyPrefixes)))\n+      || allowLiterals.exists(literals =>\n+            literals.exists(literal => allowLiteral(literal, denyLiterals, denyPrefixes))))\n+  }\n+\n+  private def allowLiteral(literalName: String,\n+                           denyLiterals: List[mutable.Set[String]], denyPrefixes: List[mutable.Set[String]]): Boolean = {\n+    literalName match{\n+      case ResourcePattern.WILDCARD_RESOURCE => true\n+      case _ => (denyLiterals.forall(denyLiterals => !denyLiterals.contains(literalName))\n+                    && !hasDominantPrefixedDeny(literalName, denyPrefixes))\n+    }\n+  }\n+\n+  private def allowPrefix(prefixName: String,\n+                          denyPrefixes: List[mutable.Set[String]]): Boolean = {\n+    !hasDominantPrefixedDeny(prefixName, denyPrefixes)\n+  }\n+\n+  private def hasDominantPrefixedDeny(resourceName: String, denyPrefixes: List[mutable.Set[String]]): Boolean = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYwNzIyMw=="}, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3MTU3OQ==", "bodyText": "This is too hacky. And it breaks if ANONYMOUS has all access (e.g. because inter-broker listener alone uses PLAINTEXT). We could check baseAuthorizer.isInstanceOf[SimpleAclAuthorizer] perhaps. It is not perfect since it would break if there was a custom authorizer that extended SimpleAclAuthorizer, but doesn't support AllowEveryoneIfNoAclIsFoundProp and the prop was set to true. But that seems like an unlikely scenario.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542871579", "createdAt": "2020-12-14T22:26:24Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -71,15 +74,22 @@ object AuthorizerWrapper {\n   }\n \n   def convertToResource(resourcePattern: ResourcePattern): Resource = {\n-    Resource(ResourceType.fromJava(resourcePattern.resourceType), resourcePattern.name, resourcePattern.patternType)\n+    Resource(ResourceTypeLegacy.fromJava(resourcePattern.resourceType), resourcePattern.name, resourcePattern.patternType)\n   }\n }\n \n @deprecated(\"Use kafka.security.authorizer.AclAuthorizer\", \"Since 2.5\")\n class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.Authorizer) extends Authorizer {\n \n+  var shouldAllowEveryoneIfNoAclIsFound = false\n+\n   override def configure(configs: util.Map[String, _]): Unit = {\n     baseAuthorizer.configure(configs)\n+    shouldAllowEveryoneIfNoAclIsFound = (configs.asScala.get(\n+        AclAuthorizer.AllowEveryoneIfNoAclIsFoundProp).exists(_.toString.toBoolean)\n+      && baseAuthorizer.authorize(\n+        new Session(KafkaPrincipal.ANONYMOUS, InetAddress.getByName(\"1.2.3.4\")),\n+        Read, new Resource(Topic, \"hi\", PatternType.LITERAL)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd48b22aff2802c191fd555fa894a5d1081f68ca"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3OTE0Mw==", "bodyText": "This sequence doesn't work with super.users. We probably should do something like:\nif (super.authorizeByResourceType(requestContext, op, resourceType) == AuthorizationResult.ALLOWED)\n  AuthorizationResult.ALLOWED\nelse if (denyAllResource(requestContext, op, resourceType) || !shouldAllowEveryoneIfNoAclIsFound)\n  AuthorizationResult.DENIED\nelse\n  AuthorizationResult.ALLOWED", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542879143", "createdAt": "2020-12-14T22:33:41Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +185,39 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    if (denyAllResource(requestContext, op, resourceType)) {\n+      AuthorizationResult.DENIED\n+    } else if (shouldAllowEveryoneIfNoAclIsFound) {\n+      AuthorizationResult.ALLOWED\n+    } else {\n+      super.authorizeByResourceType(requestContext, op, resourceType)\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd48b22aff2802c191fd555fa894a5d1081f68ca"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4MTc3MA==", "bodyText": "We could have done principal.toString() once in the caller rather than convert everytime.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542881770", "createdAt": "2020-12-14T22:36:27Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AuthorizerWrapper.scala", "diffHunk": "@@ -175,4 +185,39 @@ class AuthorizerWrapper(private[kafka] val baseAuthorizer: kafka.security.auth.A\n   override def close(): Unit = {\n     baseAuthorizer.close()\n   }\n+\n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    if (denyAllResource(requestContext, op, resourceType)) {\n+      AuthorizationResult.DENIED\n+    } else if (shouldAllowEveryoneIfNoAclIsFound) {\n+      AuthorizationResult.ALLOWED\n+    } else {\n+      super.authorizeByResourceType(requestContext, op, resourceType)\n+    }\n+  }\n+\n+  private def denyAllResource(requestContext: AuthorizableRequestContext,\n+                              op: AclOperation,\n+                              resourceType: ResourceType): Boolean = {\n+    val resourceTypeFilter = new ResourcePatternFilter(\n+      resourceType, Resource.WildCardResource, PatternType.LITERAL)\n+    val principal = new KafkaPrincipal(requestContext.principal.getPrincipalType, requestContext.principal.getName)\n+    val host = requestContext.clientAddress().getHostAddress\n+    val accessControlEntry = new AccessControlEntryFilter(null, null, op, AclPermissionType.DENY)\n+    val aclFilter = new AclBindingFilter(resourceTypeFilter, accessControlEntry)\n+\n+    acls(aclFilter).asScala.exists(b => principalHostMatch(b.entry(), principal, host))\n+  }\n+\n+  private def principalHostMatch(ace: AccessControlEntry,\n+                                 principal: KafkaPrincipal,\n+                                 host: String): Boolean = {\n+    ((ace.host() == AclEntry.WildcardHost || ace.host() == host)\n+      && (ace.principal() == AclEntry.WildcardPrincipalString || ace.principal() == principal.toString))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd48b22aff2802c191fd555fa894a5d1081f68ca"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4NDUxNw==", "bodyText": "ZK is reinstantiated for every test.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542884517", "createdAt": "2020-12-14T22:39:08Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -100,8 +106,15 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n \n   @After\n   override def tearDown(): Unit = {\n-    aclAuthorizer.close()\n-    aclAuthorizer2.close()\n+    val authorizers = Seq(aclAuthorizer, aclAuthorizer2)\n+    authorizers.foreach(a => {\n+      a.acls(AclBindingFilter.ANY).forEach(bd => {\n+        removeAcls(aclAuthorizer, Set(bd.entry), bd.pattern())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzMDA4NA=="}, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4NzQwOQ==", "bodyText": "As in the other class, we don't need this in tearDown", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542887409", "createdAt": "2020-12-14T22:41:58Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerInterfaceDefaultTest.scala", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.net.InetAddress\n+\n+import kafka.server.KafkaConfig\n+import kafka.utils.TestUtils\n+import kafka.zk.ZooKeeperTestHarness\n+import kafka.zookeeper.ZooKeeperClient\n+import org.apache.kafka.common.acl._\n+import org.apache.kafka.common.network.{ClientInformation, ListenerName}\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.requests.{RequestContext, RequestHeader}\n+import org.apache.kafka.common.resource.{ResourcePattern, ResourceType}\n+import org.apache.kafka.common.security.auth.{KafkaPrincipal, SecurityProtocol}\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.authorizer._\n+import org.junit.{After, Before, Test}\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.jdk.CollectionConverters._\n+\n+class AuthorizerInterfaceDefaultTest extends ZooKeeperTestHarness {\n+\n+  private val interfaceDefaultAuthorizer = new DelegateAuthorizer\n+  private val superUsers = \"User:superuser1; User:superuser2\"\n+  private val username = \"alice\"\n+  private val principal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, username)\n+  private val requestContext = newRequestContext(principal, InetAddress.getByName(\"192.168.0.1\"))\n+  private var config: KafkaConfig = _\n+  private var zooKeeperClient: ZooKeeperClient = _\n+  private val aclAdded: ArrayBuffer[(Authorizer, Set[AccessControlEntry], ResourcePattern)] = ArrayBuffer()\n+  private val authorizerTestFactory = new AuthorizerTestFactory(\n+    newRequestContext, addAcls, authorizeByResourceType, removeAcls)\n+\n+  class CustomPrincipal(principalType: String, name: String) extends KafkaPrincipal(principalType, name) {\n+    override def equals(o: scala.Any): Boolean = false\n+  }\n+\n+  @Before\n+  override def setUp(): Unit = {\n+    super.setUp()\n+\n+    val authorizers = Seq(interfaceDefaultAuthorizer.authorizer)\n+\n+    // Increase maxUpdateRetries to avoid transient failures\n+    authorizers.foreach(a => a.maxUpdateRetries = Int.MaxValue)\n+\n+    val props = TestUtils.createBrokerConfig(0, zkConnect)\n+    props.put(AclAuthorizer.SuperUsersProp, superUsers)\n+\n+    config = KafkaConfig.fromProps(props)\n+    authorizers.foreach(a => a.configure(config.originals))\n+\n+    zooKeeperClient = new ZooKeeperClient(zkConnect, zkSessionTimeout, zkConnectionTimeout, zkMaxInFlightRequests,\n+      Time.SYSTEM, \"kafka.test\", \"AclAuthorizerTest\")\n+  }\n+\n+  @After\n+  override def tearDown(): Unit = {\n+    val authorizers = Seq(interfaceDefaultAuthorizer)\n+    authorizers.foreach(a => {\n+      a.acls(AclBindingFilter.ANY).forEach(bd => {\n+        removeAcls(interfaceDefaultAuthorizer, Set(bd.entry), bd.pattern())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd48b22aff2802c191fd555fa894a5d1081f68ca"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4ODYxNA==", "bodyText": "We should add tests for super users.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542888614", "createdAt": "2020-12-14T22:43:13Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerInterfaceDefaultTest.scala", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.net.InetAddress\n+\n+import kafka.server.KafkaConfig\n+import kafka.utils.TestUtils\n+import kafka.zk.ZooKeeperTestHarness\n+import kafka.zookeeper.ZooKeeperClient\n+import org.apache.kafka.common.acl._\n+import org.apache.kafka.common.network.{ClientInformation, ListenerName}\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.requests.{RequestContext, RequestHeader}\n+import org.apache.kafka.common.resource.{ResourcePattern, ResourceType}\n+import org.apache.kafka.common.security.auth.{KafkaPrincipal, SecurityProtocol}\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.authorizer._\n+import org.junit.{After, Before, Test}\n+\n+import scala.collection.mutable.ArrayBuffer\n+import scala.jdk.CollectionConverters._\n+\n+class AuthorizerInterfaceDefaultTest extends ZooKeeperTestHarness {\n+\n+  private val interfaceDefaultAuthorizer = new DelegateAuthorizer\n+  private val superUsers = \"User:superuser1; User:superuser2\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd48b22aff2802c191fd555fa894a5d1081f68ca"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5MDQ2NQ==", "bodyText": "why are we storing these?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542890465", "createdAt": "2020-12-14T22:45:10Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -74,6 +75,10 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n   private var config: KafkaConfig = _\n   private var zooKeeperClient: ZooKeeperClient = _\n \n+  private val aclAdded: ArrayBuffer[(Authorizer, Set[AccessControlEntry], ResourcePattern)] = ArrayBuffer()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd48b22aff2802c191fd555fa894a5d1081f68ca"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5Mjk0Mg==", "bodyText": "Why?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542892942", "createdAt": "2020-12-14T22:47:34Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -1040,19 +1116,24 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n       securityProtocol, ClientInformation.EMPTY, false)\n   }\n \n-  private def authorize(authorizer: AclAuthorizer, requestContext: RequestContext, operation: AclOperation, resource: ResourcePattern): Boolean = {\n+  private def authorize(authorizer: Authorizer, requestContext: RequestContext, operation: AclOperation, resource: ResourcePattern): Boolean = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd48b22aff2802c191fd555fa894a5d1081f68ca"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5MzM5Mw==", "bodyText": "why was this changed from AclAuthorizer to Authorizer?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542893393", "createdAt": "2020-12-14T22:48:00Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -1040,19 +1116,24 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n       securityProtocol, ClientInformation.EMPTY, false)\n   }\n \n-  private def authorize(authorizer: AclAuthorizer, requestContext: RequestContext, operation: AclOperation, resource: ResourcePattern): Boolean = {\n+  private def authorize(authorizer: Authorizer, requestContext: RequestContext, operation: AclOperation, resource: ResourcePattern): Boolean = {\n     val action = new Action(operation, resource, 1, true, true)\n     authorizer.authorize(requestContext, List(action).asJava).asScala.head == AuthorizationResult.ALLOWED\n   }\n \n-  private def addAcls(authorizer: AclAuthorizer, aces: Set[AccessControlEntry], resourcePattern: ResourcePattern): Unit = {\n+  private def authorizeByResourceType(authorizer: Authorizer, requestContext: RequestContext, operation: AclOperation, resourceType: ResourceType) : Boolean = {\n+    authorizer.authorizeByResourceType(requestContext, operation, resourceType) == AuthorizationResult.ALLOWED\n+  }\n+\n+  private def addAcls(authorizer: Authorizer, aces: Set[AccessControlEntry], resourcePattern: ResourcePattern): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd48b22aff2802c191fd555fa894a5d1081f68ca"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5MzY2NQ==", "bodyText": "why are we storing this?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542893665", "createdAt": "2020-12-14T22:48:15Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -1040,19 +1116,24 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n       securityProtocol, ClientInformation.EMPTY, false)\n   }\n \n-  private def authorize(authorizer: AclAuthorizer, requestContext: RequestContext, operation: AclOperation, resource: ResourcePattern): Boolean = {\n+  private def authorize(authorizer: Authorizer, requestContext: RequestContext, operation: AclOperation, resource: ResourcePattern): Boolean = {\n     val action = new Action(operation, resource, 1, true, true)\n     authorizer.authorize(requestContext, List(action).asJava).asScala.head == AuthorizationResult.ALLOWED\n   }\n \n-  private def addAcls(authorizer: AclAuthorizer, aces: Set[AccessControlEntry], resourcePattern: ResourcePattern): Unit = {\n+  private def authorizeByResourceType(authorizer: Authorizer, requestContext: RequestContext, operation: AclOperation, resourceType: ResourceType) : Boolean = {\n+    authorizer.authorizeByResourceType(requestContext, operation, resourceType) == AuthorizationResult.ALLOWED\n+  }\n+\n+  private def addAcls(authorizer: Authorizer, aces: Set[AccessControlEntry], resourcePattern: ResourcePattern): Unit = {\n     val bindings = aces.map { ace => new AclBinding(resourcePattern, ace) }\n     authorizer.createAcls(requestContext, bindings.toList.asJava).asScala\n       .map(_.toCompletableFuture.get)\n       .foreach { result => result.exception.ifPresent { e => throw e } }\n+    aclAdded += Tuple3(authorizer, aces, resourcePattern)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd48b22aff2802c191fd555fa894a5d1081f68ca"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjkwMDIxMw==", "bodyText": "It would be better to move this inside AuthorizerInterfaceDefaultTest since it is specific to that test.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542900213", "createdAt": "2020-12-14T22:54:40Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/DelegateAuthorizer.scala", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.{lang, util}\n+import java.util.concurrent.CompletionStage\n+\n+import org.apache.kafka.common.Endpoint\n+import org.apache.kafka.common.acl.{AclBinding, AclBindingFilter}\n+import org.apache.kafka.server.authorizer.{AclCreateResult, AclDeleteResult, Action, AuthorizableRequestContext, AuthorizationResult, Authorizer, AuthorizerServerInfo}\n+\n+/**\n+ * For testing the interface default\n+ */\n+class DelegateAuthorizer extends Authorizer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd48b22aff2802c191fd555fa894a5d1081f68ca"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjkwNjAwOA==", "bodyText": "For Map, you would say key rather than index. But this is not a resource or resourceName - it has no resource name, it is not a filter, but it includes AccessControlEntry. Maybe just ResourceTypeKey is sufficient, but you could also include something to indicate it includes the AccessControlEntry if you want. Either way, putting it along with AclAuthorizer would make naming less critical.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r542906008", "createdAt": "2020-12-14T23:00:35Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/common/acl/ResourceIndex.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.acl;\n+\n+import org.apache.kafka.common.resource.PatternType;\n+import org.apache.kafka.common.resource.ResourceType;\n+\n+import java.util.Objects;\n+\n+public class ResourceIndex {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5NTU4NA=="}, "originalCommit": {"oid": "40c0cad01590e137eac4ad1bb859f3d97b62a245"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25e0bfcc97f956ceb4254ab8c457fe5d8d250e82", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/25e0bfcc97f956ceb4254ab8c457fe5d8d250e82", "committedDate": "2020-12-15T06:28:49Z", "message": "move the step by step comments into the method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1217394c0c3767ac11df958c02a681c8cbc8382b", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/1217394c0c3767ac11df958c02a681c8cbc8382b", "committedDate": "2020-12-15T06:59:47Z", "message": "change the no acl found logic in AuthorizerWrapper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfe7dbbd0d3b495041dc89c51cb8f5b8d3258710", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/cfe7dbbd0d3b495041dc89c51cb8f5b8d3258710", "committedDate": "2020-12-15T07:18:44Z", "message": "optimize principle.toString"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "16576f85a858648cfc4ff882b554ddc65922021c", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/16576f85a858648cfc4ff882b554ddc65922021c", "committedDate": "2020-12-15T07:12:47Z", "message": "optimize principle.toString"}, "afterCommit": {"oid": "cfe7dbbd0d3b495041dc89c51cb8f5b8d3258710", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/cfe7dbbd0d3b495041dc89c51cb8f5b8d3258710", "committedDate": "2020-12-15T07:18:44Z", "message": "optimize principle.toString"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "825a8ba77ad1766f998a71a9a15f21e73daad84a", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/825a8ba77ad1766f998a71a9a15f21e73daad84a", "committedDate": "2020-12-15T07:37:25Z", "message": "remove the removeAcl related logic since ZK will re-instantiate before every test case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "184944c78ec1a0f3061dabba9b1c638a4f86d99a", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/184944c78ec1a0f3061dabba9b1c638a4f86d99a", "committedDate": "2020-12-15T07:43:49Z", "message": "rename the ZK client metricType name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e31f157eaac1213445dd284fd2209a29f4fa18fd", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/e31f157eaac1213445dd284fd2209a29f4fa18fd", "committedDate": "2020-12-15T07:53:26Z", "message": "move the DelegateAuthorizer into AuthorizerInterfaceDefaultTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dae1a788b70ebc03eab265b1027a4b43ad8e773b", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/dae1a788b70ebc03eab265b1027a4b43ad8e773b", "committedDate": "2020-12-15T22:48:27Z", "message": "added super user case and tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7fe92c6436432760adf9465c3f0bcf3c91104b10", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/7fe92c6436432760adf9465c3f0bcf3c91104b10", "committedDate": "2020-12-16T01:40:44Z", "message": "Maket ResourceIndex an Inner class of AclAuthorizer, and decouple the jmh benchmark with it"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62c44ade550a90671ff41bfb847e2bc28adc7baa", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/62c44ade550a90671ff41bfb847e2bc28adc7baa", "committedDate": "2020-12-16T01:50:47Z", "message": "change the mutable map to volatile immutable map for thread safety"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b22ecd69c0001046d62e6236e768422cbf1df0a0", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/b22ecd69c0001046d62e6236e768422cbf1df0a0", "committedDate": "2020-12-16T04:36:34Z", "message": "NIT"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzNTk2NTc0", "url": "https://github.com/apache/kafka/pull/9485#pullrequestreview-553596574", "createdAt": "2020-12-16T11:29:10Z", "commit": {"oid": "b22ecd69c0001046d62e6236e768422cbf1df0a0"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMToyOToxMVrOIHAvlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxMjowNzozN1rOIHCJ7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyMzEyNw==", "bodyText": "Use op rather than READ since that fits with why we are allowing access. We also need a test that verifies that permission to READ everything doesn't imply authorizeByResourceType for WRITE.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544223127", "createdAt": "2020-12-16T11:29:11Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,134 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * It is important to override this interface default in implementations because\n+     * 1. The interface default iterates all AclBindings multiple times, without any indexing,\n+     *    which is a CPU intense work.\n+     * 2. The interface default rebuild several sets of strings, which is a memory intense work.\n+     * 3. The interface default cannot perform the audit logging properly\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType);\n+\n+        if (authorize(requestContext, Collections.singletonList(new Action(\n+                AclOperation.READ,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b22ecd69c0001046d62e6236e768422cbf1df0a0"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyMzYzMA==", "bodyText": "Use logIfAllowed=true since we are granting access in that case.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544223630", "createdAt": "2020-12-16T11:29:58Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,134 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * It is important to override this interface default in implementations because\n+     * 1. The interface default iterates all AclBindings multiple times, without any indexing,\n+     *    which is a CPU intense work.\n+     * 2. The interface default rebuild several sets of strings, which is a memory intense work.\n+     * 3. The interface default cannot perform the audit logging properly\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType);\n+\n+        if (authorize(requestContext, Collections.singletonList(new Action(\n+                AclOperation.READ,\n+                new ResourcePattern(resourceType, \"hardcode\", PatternType.LITERAL),\n+                0, false, false)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b22ecd69c0001046d62e6236e768422cbf1df0a0"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIyOTY3Mw==", "bodyText": "Can we used named arguments for the booleans: authorized = false - we should update all usages of logAuditMessage below.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544229673", "createdAt": "2020-12-16T11:40:14Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +310,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, false)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b22ecd69c0001046d62e6236e768422cbf1df0a0"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzMjU1OA==", "bodyText": "We should make this a case class. We can then remove all the methods (equals, hashCode and toString) since we get those for free.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544232558", "createdAt": "2020-12-16T11:44:53Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -582,4 +749,21 @@ class AclAuthorizer extends Authorizer with Logging {\n       processAclChangeNotification(resource)\n     }\n   }\n+\n+  private class ResourceTypeKey(val ace: AccessControlEntry,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b22ecd69c0001046d62e6236e768422cbf1df0a0"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzOTc0Mg==", "bodyText": "not a custom principal, just a principal.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544239742", "createdAt": "2020-12-16T11:56:47Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerTestFactory.scala", "diffHunk": "@@ -0,0 +1,321 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.security.authorizer\n+\n+import java.net.InetAddress\n+import java.util.UUID\n+\n+import kafka.security.authorizer.AclEntry.{WildcardHost, WildcardPrincipalString}\n+import org.apache.kafka.common.acl.AclOperation.{ALL, READ, WRITE}\n+import org.apache.kafka.common.acl.AclPermissionType.{ALLOW, DENY}\n+import org.apache.kafka.common.acl.{AccessControlEntry, AclOperation}\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.requests.RequestContext\n+import org.apache.kafka.common.resource.PatternType.{LITERAL, PREFIXED}\n+import org.apache.kafka.common.resource.ResourcePattern.WILDCARD_RESOURCE\n+import org.apache.kafka.common.resource.ResourceType.{CLUSTER, GROUP, TOPIC, TRANSACTIONAL_ID}\n+import org.apache.kafka.common.resource.{ResourcePattern, ResourceType}\n+import org.apache.kafka.common.security.auth.KafkaPrincipal\n+import org.apache.kafka.server.authorizer.Authorizer\n+import org.junit.Assert.{assertFalse, assertTrue}\n+\n+class AuthorizerTestFactory(val newRequestContext3: (KafkaPrincipal, InetAddress, ApiKeys) => RequestContext,\n+                            val addAcls: (Authorizer, Set[AccessControlEntry], ResourcePattern) => Unit,\n+                            val authorizeByResourceType: (Authorizer, RequestContext, AclOperation, ResourceType) => Boolean,\n+                            val removeAcls: (Authorizer, Set[AccessControlEntry], ResourcePattern) => Unit) {\n+  def newRequestContext(kafkaPrincipal: KafkaPrincipal, inetAddress: InetAddress): RequestContext =\n+    newRequestContext3(kafkaPrincipal, inetAddress, ApiKeys.PRODUCE)\n+\n+  def testAuthorizeByResourceTypeMultipleAddAndRemove(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val denyRead = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val allowRead = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val u1h1Context = newRequestContext(user1, host1)\n+\n+    for (_ <- 1 to 10) {\n+      assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+        authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+      addAcls(authorizer, Set(allowRead), resource1)\n+      assertTrue(\"User1 from host1 now should have READ access to at least one topic\",\n+        authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+      for (_ <- 1 to 10) {\n+        addAcls(authorizer, Set(denyRead), resource1)\n+        assertFalse(\"User1 from host1 now should not have READ access to any topic\",\n+          authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+        removeAcls(authorizer, Set(denyRead), resource1)\n+        addAcls(authorizer, Set(allowRead), resource1)\n+        assertTrue(\"User1 from host1 now should have READ access to at least one topic\",\n+          authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+      }\n+\n+      removeAcls(authorizer, Set(allowRead), resource1)\n+      assertFalse(\"User1 from host1 now should not have READ access to any topic\",\n+        authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    }\n+  }\n+\n+   def testAuthorizeByResourceTypeIsolationUnrelatedDenyWontDominateAllow(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val user2 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user2\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val host2 = InetAddress.getByName(\"192.168.1.2\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val resource2 = new ResourcePattern(TOPIC, \"sb2\" + UUID.randomUUID(), LITERAL)\n+    val resource3 = new ResourcePattern(GROUP, \"s\", PREFIXED)\n+\n+    val acl1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val acl2 = new AccessControlEntry(user2.toString, host1.getHostAddress, READ, DENY)\n+    val acl3 = new AccessControlEntry(user1.toString, host2.getHostAddress, WRITE, DENY)\n+    val acl4 = new AccessControlEntry(user1.toString, host2.getHostAddress, READ, DENY)\n+    val acl5 = new AccessControlEntry(user1.toString, host2.getHostAddress, READ, DENY)\n+    val acl6 = new AccessControlEntry(user2.toString, host2.getHostAddress, READ, DENY)\n+    val acl7 = new AccessControlEntry(user1.toString, host2.getHostAddress, READ, ALLOW)\n+\n+    addAcls(authorizer, Set(acl1, acl2, acl3, acl6, acl7), resource1)\n+    addAcls(authorizer, Set(acl4), resource2)\n+    addAcls(authorizer, Set(acl5), resource3)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val u1h2Context = newRequestContext(user1, host2)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    assertFalse(\"User1 from host2 should not have READ access to any consumer group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+    assertFalse(\"User1 from host2 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TRANSACTIONAL_ID))\n+    assertFalse(\"User1 from host2 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.CLUSTER))\n+    assertTrue(\"User1 from host2 should have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+  }\n+\n+   def testAuthorizeByResourceTypeDenyTakesPrecedence(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val acl1 = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, ALLOW)\n+    val acl2 = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, DENY)\n+\n+    addAcls(authorizer, Set(acl1), resource1)\n+    assertTrue(\"User1 from host1 should have WRITE access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(acl2), resource1)\n+    assertFalse(\"User1 from host1 should not have WRITE access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.TOPIC))\n+  }\n+\n+  def testAuthorizeByResourceTypePrefixedResourceDenyDominate(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val a = new ResourcePattern(GROUP, \"a\", PREFIXED)\n+    val ab = new ResourcePattern(GROUP, \"ab\", PREFIXED)\n+    val abc = new ResourcePattern(GROUP, \"abc\", PREFIXED)\n+    val abcd = new ResourcePattern(GROUP, \"abcd\", PREFIXED)\n+    val abcde = new ResourcePattern(GROUP, \"abcde\", PREFIXED)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val allowAce = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val denyAce = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+\n+    addAcls(authorizer, Set(allowAce), abcde)\n+    assertTrue(\"User1 from host1 should have READ access to at least one group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(denyAce), abcd)\n+    assertFalse(\"User1 from host1 now should not have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), abc)\n+    assertTrue(\"User1 from host1 now should have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(denyAce), a)\n+    assertFalse(\"User1 from host1 now should not have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), ab)\n+    assertFalse(\"User1 from host1 still should not have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+  }\n+\n+  def testAuthorizeByResourceTypeWildcardResourceDenyDominate(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val wildcard = new ResourcePattern(GROUP, ResourcePattern.WILDCARD_RESOURCE, LITERAL)\n+    val prefixed = new ResourcePattern(GROUP, \"hello\", PREFIXED)\n+    val literal = new ResourcePattern(GROUP, \"aloha\", LITERAL)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val allowAce = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, ALLOW)\n+    val denyAce = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, DENY)\n+\n+    addAcls(authorizer, Set(allowAce), prefixed)\n+    assertTrue(\"User1 from host1 should have WRITE access to at least one group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(denyAce), wildcard)\n+    assertFalse(\"User1 from host1 now should not have WRITE access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), wildcard)\n+    assertFalse(\"User1 from host1 still should not have WRITE access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), literal)\n+    assertFalse(\"User1 from host1 still should not have WRITE access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+  }\n+\n+  def testAuthorizeByResourceTypeWithAllOperationAce(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val denyAll = new AccessControlEntry(user1.toString, host1.getHostAddress, ALL, DENY)\n+    val allowAll = new AccessControlEntry(user1.toString, host1.getHostAddress, ALL, ALLOW)\n+    val denyWrite = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, DENY)\n+    val u1h1Context = newRequestContext(user1, host1)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyWrite, allowAll), resource1)\n+    assertTrue(\"User1 from host1 now should have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAll), resource1)\n+    assertFalse(\"User1 from host1 now should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+  }\n+\n+  def testAuthorizeByResourceTypeWithAllHostAce(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val host2 = InetAddress.getByName(\"192.168.1.2\")\n+    val allHost = AclEntry.WildcardHost\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val resource2 = new ResourcePattern(TOPIC, \"sb2\" + UUID.randomUUID(), LITERAL)\n+    val allowHost1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val denyHost1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val denyAllHost = new AccessControlEntry(user1.toString, allHost, READ, DENY)\n+    val allowAllHost = new AccessControlEntry(user1.toString, allHost, READ, ALLOW)\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val u1h2Context = newRequestContext(user1, host2)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowHost1), resource1)\n+    assertTrue(\"User1 from host1 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllHost), resource1)\n+    assertFalse(\"User1 from host1 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyHost1), resource2)\n+    assertFalse(\"User1 from host1 still should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    assertFalse(\"User1 from host2 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowAllHost), resource2)\n+    assertTrue(\"User1 from host2 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllHost), resource2)\n+    assertFalse(\"User1 from host2 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+  }\n+\n+\n+  def testAuthorizeByResourceTypeWithAllPrincipalAce(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val user2 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user2\")\n+    val allUser = AclEntry.WildcardPrincipalString\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val resource2 = new ResourcePattern(TOPIC, \"sb2\" + UUID.randomUUID(), LITERAL)\n+    val allowUser1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val denyUser1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val denyAllUser = new AccessControlEntry(allUser, host1.getHostAddress, READ, DENY)\n+    val allowAllUser = new AccessControlEntry(allUser, host1.getHostAddress, READ, ALLOW)\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val u2h1Context = newRequestContext(user2, host1)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowUser1), resource1)\n+    assertTrue(\"User1 from host1 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllUser), resource1)\n+    assertFalse(\"User1 from host1 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyUser1), resource2)\n+    assertFalse(\"User1 from host1 still should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    assertFalse(\"User2 from host1 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u2h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowAllUser), resource2)\n+    assertTrue(\"User2 from host1 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u2h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllUser), resource2)\n+    assertFalse(\"User2 from host1 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u2h1Context, READ, ResourceType.TOPIC))\n+  }\n+\n+  def testAuthorzeByResourceTypeSuperUserHasAccess(authorizer: Authorizer, superUserName: String): Unit = {\n+    val denyAllAce = new AccessControlEntry(WildcardPrincipalString, WildcardHost, AclOperation.ALL, DENY)\n+    val superUser1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, superUserName)\n+    val host1 = InetAddress.getByName(\"192.0.4.4\")\n+    val allTopicsResource = new ResourcePattern(TOPIC, WILDCARD_RESOURCE, LITERAL)\n+    val clusterResource = new ResourcePattern(CLUSTER, WILDCARD_RESOURCE, LITERAL)\n+    val groupResource = new ResourcePattern(GROUP, WILDCARD_RESOURCE, LITERAL)\n+    val transactionIdResource = new ResourcePattern(TRANSACTIONAL_ID, WILDCARD_RESOURCE, LITERAL)\n+\n+    addAcls(authorizer, Set(denyAllAce), allTopicsResource)\n+    addAcls(authorizer, Set(denyAllAce), clusterResource)\n+    addAcls(authorizer, Set(denyAllAce), groupResource)\n+    addAcls(authorizer, Set(denyAllAce), transactionIdResource)\n+\n+    val superUserContext = newRequestContext(superUser1, host1)\n+\n+    assertTrue(\"superuser with custom principal always has access, no matter what acls.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b22ecd69c0001046d62e6236e768422cbf1df0a0"}, "originalPosition": 311}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDIzOTc0OQ==", "bodyText": "not a custom principal, just a principal.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544239749", "createdAt": "2020-12-16T11:56:48Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerTestFactory.scala", "diffHunk": "@@ -0,0 +1,321 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.security.authorizer\n+\n+import java.net.InetAddress\n+import java.util.UUID\n+\n+import kafka.security.authorizer.AclEntry.{WildcardHost, WildcardPrincipalString}\n+import org.apache.kafka.common.acl.AclOperation.{ALL, READ, WRITE}\n+import org.apache.kafka.common.acl.AclPermissionType.{ALLOW, DENY}\n+import org.apache.kafka.common.acl.{AccessControlEntry, AclOperation}\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.requests.RequestContext\n+import org.apache.kafka.common.resource.PatternType.{LITERAL, PREFIXED}\n+import org.apache.kafka.common.resource.ResourcePattern.WILDCARD_RESOURCE\n+import org.apache.kafka.common.resource.ResourceType.{CLUSTER, GROUP, TOPIC, TRANSACTIONAL_ID}\n+import org.apache.kafka.common.resource.{ResourcePattern, ResourceType}\n+import org.apache.kafka.common.security.auth.KafkaPrincipal\n+import org.apache.kafka.server.authorizer.Authorizer\n+import org.junit.Assert.{assertFalse, assertTrue}\n+\n+class AuthorizerTestFactory(val newRequestContext3: (KafkaPrincipal, InetAddress, ApiKeys) => RequestContext,\n+                            val addAcls: (Authorizer, Set[AccessControlEntry], ResourcePattern) => Unit,\n+                            val authorizeByResourceType: (Authorizer, RequestContext, AclOperation, ResourceType) => Boolean,\n+                            val removeAcls: (Authorizer, Set[AccessControlEntry], ResourcePattern) => Unit) {\n+  def newRequestContext(kafkaPrincipal: KafkaPrincipal, inetAddress: InetAddress): RequestContext =\n+    newRequestContext3(kafkaPrincipal, inetAddress, ApiKeys.PRODUCE)\n+\n+  def testAuthorizeByResourceTypeMultipleAddAndRemove(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val denyRead = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val allowRead = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val u1h1Context = newRequestContext(user1, host1)\n+\n+    for (_ <- 1 to 10) {\n+      assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+        authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+      addAcls(authorizer, Set(allowRead), resource1)\n+      assertTrue(\"User1 from host1 now should have READ access to at least one topic\",\n+        authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+      for (_ <- 1 to 10) {\n+        addAcls(authorizer, Set(denyRead), resource1)\n+        assertFalse(\"User1 from host1 now should not have READ access to any topic\",\n+          authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+        removeAcls(authorizer, Set(denyRead), resource1)\n+        addAcls(authorizer, Set(allowRead), resource1)\n+        assertTrue(\"User1 from host1 now should have READ access to at least one topic\",\n+          authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+      }\n+\n+      removeAcls(authorizer, Set(allowRead), resource1)\n+      assertFalse(\"User1 from host1 now should not have READ access to any topic\",\n+        authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    }\n+  }\n+\n+   def testAuthorizeByResourceTypeIsolationUnrelatedDenyWontDominateAllow(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val user2 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user2\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val host2 = InetAddress.getByName(\"192.168.1.2\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val resource2 = new ResourcePattern(TOPIC, \"sb2\" + UUID.randomUUID(), LITERAL)\n+    val resource3 = new ResourcePattern(GROUP, \"s\", PREFIXED)\n+\n+    val acl1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val acl2 = new AccessControlEntry(user2.toString, host1.getHostAddress, READ, DENY)\n+    val acl3 = new AccessControlEntry(user1.toString, host2.getHostAddress, WRITE, DENY)\n+    val acl4 = new AccessControlEntry(user1.toString, host2.getHostAddress, READ, DENY)\n+    val acl5 = new AccessControlEntry(user1.toString, host2.getHostAddress, READ, DENY)\n+    val acl6 = new AccessControlEntry(user2.toString, host2.getHostAddress, READ, DENY)\n+    val acl7 = new AccessControlEntry(user1.toString, host2.getHostAddress, READ, ALLOW)\n+\n+    addAcls(authorizer, Set(acl1, acl2, acl3, acl6, acl7), resource1)\n+    addAcls(authorizer, Set(acl4), resource2)\n+    addAcls(authorizer, Set(acl5), resource3)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val u1h2Context = newRequestContext(user1, host2)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    assertFalse(\"User1 from host2 should not have READ access to any consumer group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+    assertFalse(\"User1 from host2 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TRANSACTIONAL_ID))\n+    assertFalse(\"User1 from host2 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.CLUSTER))\n+    assertTrue(\"User1 from host2 should have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+  }\n+\n+   def testAuthorizeByResourceTypeDenyTakesPrecedence(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val acl1 = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, ALLOW)\n+    val acl2 = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, DENY)\n+\n+    addAcls(authorizer, Set(acl1), resource1)\n+    assertTrue(\"User1 from host1 should have WRITE access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(acl2), resource1)\n+    assertFalse(\"User1 from host1 should not have WRITE access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.TOPIC))\n+  }\n+\n+  def testAuthorizeByResourceTypePrefixedResourceDenyDominate(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val a = new ResourcePattern(GROUP, \"a\", PREFIXED)\n+    val ab = new ResourcePattern(GROUP, \"ab\", PREFIXED)\n+    val abc = new ResourcePattern(GROUP, \"abc\", PREFIXED)\n+    val abcd = new ResourcePattern(GROUP, \"abcd\", PREFIXED)\n+    val abcde = new ResourcePattern(GROUP, \"abcde\", PREFIXED)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val allowAce = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val denyAce = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+\n+    addAcls(authorizer, Set(allowAce), abcde)\n+    assertTrue(\"User1 from host1 should have READ access to at least one group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(denyAce), abcd)\n+    assertFalse(\"User1 from host1 now should not have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), abc)\n+    assertTrue(\"User1 from host1 now should have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(denyAce), a)\n+    assertFalse(\"User1 from host1 now should not have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), ab)\n+    assertFalse(\"User1 from host1 still should not have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+  }\n+\n+  def testAuthorizeByResourceTypeWildcardResourceDenyDominate(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val wildcard = new ResourcePattern(GROUP, ResourcePattern.WILDCARD_RESOURCE, LITERAL)\n+    val prefixed = new ResourcePattern(GROUP, \"hello\", PREFIXED)\n+    val literal = new ResourcePattern(GROUP, \"aloha\", LITERAL)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val allowAce = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, ALLOW)\n+    val denyAce = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, DENY)\n+\n+    addAcls(authorizer, Set(allowAce), prefixed)\n+    assertTrue(\"User1 from host1 should have WRITE access to at least one group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(denyAce), wildcard)\n+    assertFalse(\"User1 from host1 now should not have WRITE access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), wildcard)\n+    assertFalse(\"User1 from host1 still should not have WRITE access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), literal)\n+    assertFalse(\"User1 from host1 still should not have WRITE access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+  }\n+\n+  def testAuthorizeByResourceTypeWithAllOperationAce(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val denyAll = new AccessControlEntry(user1.toString, host1.getHostAddress, ALL, DENY)\n+    val allowAll = new AccessControlEntry(user1.toString, host1.getHostAddress, ALL, ALLOW)\n+    val denyWrite = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, DENY)\n+    val u1h1Context = newRequestContext(user1, host1)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyWrite, allowAll), resource1)\n+    assertTrue(\"User1 from host1 now should have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAll), resource1)\n+    assertFalse(\"User1 from host1 now should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+  }\n+\n+  def testAuthorizeByResourceTypeWithAllHostAce(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val host2 = InetAddress.getByName(\"192.168.1.2\")\n+    val allHost = AclEntry.WildcardHost\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val resource2 = new ResourcePattern(TOPIC, \"sb2\" + UUID.randomUUID(), LITERAL)\n+    val allowHost1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val denyHost1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val denyAllHost = new AccessControlEntry(user1.toString, allHost, READ, DENY)\n+    val allowAllHost = new AccessControlEntry(user1.toString, allHost, READ, ALLOW)\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val u1h2Context = newRequestContext(user1, host2)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowHost1), resource1)\n+    assertTrue(\"User1 from host1 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllHost), resource1)\n+    assertFalse(\"User1 from host1 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyHost1), resource2)\n+    assertFalse(\"User1 from host1 still should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    assertFalse(\"User1 from host2 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowAllHost), resource2)\n+    assertTrue(\"User1 from host2 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllHost), resource2)\n+    assertFalse(\"User1 from host2 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+  }\n+\n+\n+  def testAuthorizeByResourceTypeWithAllPrincipalAce(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val user2 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user2\")\n+    val allUser = AclEntry.WildcardPrincipalString\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val resource2 = new ResourcePattern(TOPIC, \"sb2\" + UUID.randomUUID(), LITERAL)\n+    val allowUser1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val denyUser1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val denyAllUser = new AccessControlEntry(allUser, host1.getHostAddress, READ, DENY)\n+    val allowAllUser = new AccessControlEntry(allUser, host1.getHostAddress, READ, ALLOW)\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val u2h1Context = newRequestContext(user2, host1)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowUser1), resource1)\n+    assertTrue(\"User1 from host1 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllUser), resource1)\n+    assertFalse(\"User1 from host1 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyUser1), resource2)\n+    assertFalse(\"User1 from host1 still should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    assertFalse(\"User2 from host1 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u2h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowAllUser), resource2)\n+    assertTrue(\"User2 from host1 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u2h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllUser), resource2)\n+    assertFalse(\"User2 from host1 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u2h1Context, READ, ResourceType.TOPIC))\n+  }\n+\n+  def testAuthorzeByResourceTypeSuperUserHasAccess(authorizer: Authorizer, superUserName: String): Unit = {\n+    val denyAllAce = new AccessControlEntry(WildcardPrincipalString, WildcardHost, AclOperation.ALL, DENY)\n+    val superUser1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, superUserName)\n+    val host1 = InetAddress.getByName(\"192.0.4.4\")\n+    val allTopicsResource = new ResourcePattern(TOPIC, WILDCARD_RESOURCE, LITERAL)\n+    val clusterResource = new ResourcePattern(CLUSTER, WILDCARD_RESOURCE, LITERAL)\n+    val groupResource = new ResourcePattern(GROUP, WILDCARD_RESOURCE, LITERAL)\n+    val transactionIdResource = new ResourcePattern(TRANSACTIONAL_ID, WILDCARD_RESOURCE, LITERAL)\n+\n+    addAcls(authorizer, Set(denyAllAce), allTopicsResource)\n+    addAcls(authorizer, Set(denyAllAce), clusterResource)\n+    addAcls(authorizer, Set(denyAllAce), groupResource)\n+    addAcls(authorizer, Set(denyAllAce), transactionIdResource)\n+\n+    val superUserContext = newRequestContext(superUser1, host1)\n+\n+    assertTrue(\"superuser with custom principal always has access, no matter what acls.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b22ecd69c0001046d62e6236e768422cbf1df0a0"}, "originalPosition": 311}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI0MDE1Ng==", "bodyText": "All these tests are using READ which happens to work for the default implementation since we used READ there.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544240156", "createdAt": "2020-12-16T11:57:27Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerTestFactory.scala", "diffHunk": "@@ -0,0 +1,321 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.security.authorizer\n+\n+import java.net.InetAddress\n+import java.util.UUID\n+\n+import kafka.security.authorizer.AclEntry.{WildcardHost, WildcardPrincipalString}\n+import org.apache.kafka.common.acl.AclOperation.{ALL, READ, WRITE}\n+import org.apache.kafka.common.acl.AclPermissionType.{ALLOW, DENY}\n+import org.apache.kafka.common.acl.{AccessControlEntry, AclOperation}\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.requests.RequestContext\n+import org.apache.kafka.common.resource.PatternType.{LITERAL, PREFIXED}\n+import org.apache.kafka.common.resource.ResourcePattern.WILDCARD_RESOURCE\n+import org.apache.kafka.common.resource.ResourceType.{CLUSTER, GROUP, TOPIC, TRANSACTIONAL_ID}\n+import org.apache.kafka.common.resource.{ResourcePattern, ResourceType}\n+import org.apache.kafka.common.security.auth.KafkaPrincipal\n+import org.apache.kafka.server.authorizer.Authorizer\n+import org.junit.Assert.{assertFalse, assertTrue}\n+\n+class AuthorizerTestFactory(val newRequestContext3: (KafkaPrincipal, InetAddress, ApiKeys) => RequestContext,\n+                            val addAcls: (Authorizer, Set[AccessControlEntry], ResourcePattern) => Unit,\n+                            val authorizeByResourceType: (Authorizer, RequestContext, AclOperation, ResourceType) => Boolean,\n+                            val removeAcls: (Authorizer, Set[AccessControlEntry], ResourcePattern) => Unit) {\n+  def newRequestContext(kafkaPrincipal: KafkaPrincipal, inetAddress: InetAddress): RequestContext =\n+    newRequestContext3(kafkaPrincipal, inetAddress, ApiKeys.PRODUCE)\n+\n+  def testAuthorizeByResourceTypeMultipleAddAndRemove(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val denyRead = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val allowRead = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val u1h1Context = newRequestContext(user1, host1)\n+\n+    for (_ <- 1 to 10) {\n+      assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+        authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+      addAcls(authorizer, Set(allowRead), resource1)\n+      assertTrue(\"User1 from host1 now should have READ access to at least one topic\",\n+        authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+      for (_ <- 1 to 10) {\n+        addAcls(authorizer, Set(denyRead), resource1)\n+        assertFalse(\"User1 from host1 now should not have READ access to any topic\",\n+          authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+        removeAcls(authorizer, Set(denyRead), resource1)\n+        addAcls(authorizer, Set(allowRead), resource1)\n+        assertTrue(\"User1 from host1 now should have READ access to at least one topic\",\n+          authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+      }\n+\n+      removeAcls(authorizer, Set(allowRead), resource1)\n+      assertFalse(\"User1 from host1 now should not have READ access to any topic\",\n+        authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    }\n+  }\n+\n+   def testAuthorizeByResourceTypeIsolationUnrelatedDenyWontDominateAllow(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val user2 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user2\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val host2 = InetAddress.getByName(\"192.168.1.2\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val resource2 = new ResourcePattern(TOPIC, \"sb2\" + UUID.randomUUID(), LITERAL)\n+    val resource3 = new ResourcePattern(GROUP, \"s\", PREFIXED)\n+\n+    val acl1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val acl2 = new AccessControlEntry(user2.toString, host1.getHostAddress, READ, DENY)\n+    val acl3 = new AccessControlEntry(user1.toString, host2.getHostAddress, WRITE, DENY)\n+    val acl4 = new AccessControlEntry(user1.toString, host2.getHostAddress, READ, DENY)\n+    val acl5 = new AccessControlEntry(user1.toString, host2.getHostAddress, READ, DENY)\n+    val acl6 = new AccessControlEntry(user2.toString, host2.getHostAddress, READ, DENY)\n+    val acl7 = new AccessControlEntry(user1.toString, host2.getHostAddress, READ, ALLOW)\n+\n+    addAcls(authorizer, Set(acl1, acl2, acl3, acl6, acl7), resource1)\n+    addAcls(authorizer, Set(acl4), resource2)\n+    addAcls(authorizer, Set(acl5), resource3)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val u1h2Context = newRequestContext(user1, host2)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    assertFalse(\"User1 from host2 should not have READ access to any consumer group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+    assertFalse(\"User1 from host2 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TRANSACTIONAL_ID))\n+    assertFalse(\"User1 from host2 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.CLUSTER))\n+    assertTrue(\"User1 from host2 should have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+  }\n+\n+   def testAuthorizeByResourceTypeDenyTakesPrecedence(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val acl1 = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, ALLOW)\n+    val acl2 = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, DENY)\n+\n+    addAcls(authorizer, Set(acl1), resource1)\n+    assertTrue(\"User1 from host1 should have WRITE access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(acl2), resource1)\n+    assertFalse(\"User1 from host1 should not have WRITE access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.TOPIC))\n+  }\n+\n+  def testAuthorizeByResourceTypePrefixedResourceDenyDominate(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val a = new ResourcePattern(GROUP, \"a\", PREFIXED)\n+    val ab = new ResourcePattern(GROUP, \"ab\", PREFIXED)\n+    val abc = new ResourcePattern(GROUP, \"abc\", PREFIXED)\n+    val abcd = new ResourcePattern(GROUP, \"abcd\", PREFIXED)\n+    val abcde = new ResourcePattern(GROUP, \"abcde\", PREFIXED)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val allowAce = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val denyAce = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+\n+    addAcls(authorizer, Set(allowAce), abcde)\n+    assertTrue(\"User1 from host1 should have READ access to at least one group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(denyAce), abcd)\n+    assertFalse(\"User1 from host1 now should not have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), abc)\n+    assertTrue(\"User1 from host1 now should have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(denyAce), a)\n+    assertFalse(\"User1 from host1 now should not have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), ab)\n+    assertFalse(\"User1 from host1 still should not have READ access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.GROUP))\n+  }\n+\n+  def testAuthorizeByResourceTypeWildcardResourceDenyDominate(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val wildcard = new ResourcePattern(GROUP, ResourcePattern.WILDCARD_RESOURCE, LITERAL)\n+    val prefixed = new ResourcePattern(GROUP, \"hello\", PREFIXED)\n+    val literal = new ResourcePattern(GROUP, \"aloha\", LITERAL)\n+\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val allowAce = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, ALLOW)\n+    val denyAce = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, DENY)\n+\n+    addAcls(authorizer, Set(allowAce), prefixed)\n+    assertTrue(\"User1 from host1 should have WRITE access to at least one group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(denyAce), wildcard)\n+    assertFalse(\"User1 from host1 now should not have WRITE access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), wildcard)\n+    assertFalse(\"User1 from host1 still should not have WRITE access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+\n+    addAcls(authorizer, Set(allowAce), literal)\n+    assertFalse(\"User1 from host1 still should not have WRITE access to any group\",\n+      authorizeByResourceType(authorizer, u1h1Context, WRITE, ResourceType.GROUP))\n+  }\n+\n+  def testAuthorizeByResourceTypeWithAllOperationAce(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val denyAll = new AccessControlEntry(user1.toString, host1.getHostAddress, ALL, DENY)\n+    val allowAll = new AccessControlEntry(user1.toString, host1.getHostAddress, ALL, ALLOW)\n+    val denyWrite = new AccessControlEntry(user1.toString, host1.getHostAddress, WRITE, DENY)\n+    val u1h1Context = newRequestContext(user1, host1)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyWrite, allowAll), resource1)\n+    assertTrue(\"User1 from host1 now should have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAll), resource1)\n+    assertFalse(\"User1 from host1 now should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+  }\n+\n+  def testAuthorizeByResourceTypeWithAllHostAce(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val host2 = InetAddress.getByName(\"192.168.1.2\")\n+    val allHost = AclEntry.WildcardHost\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val resource2 = new ResourcePattern(TOPIC, \"sb2\" + UUID.randomUUID(), LITERAL)\n+    val allowHost1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val denyHost1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val denyAllHost = new AccessControlEntry(user1.toString, allHost, READ, DENY)\n+    val allowAllHost = new AccessControlEntry(user1.toString, allHost, READ, ALLOW)\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val u1h2Context = newRequestContext(user1, host2)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowHost1), resource1)\n+    assertTrue(\"User1 from host1 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllHost), resource1)\n+    assertFalse(\"User1 from host1 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyHost1), resource2)\n+    assertFalse(\"User1 from host1 still should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    assertFalse(\"User1 from host2 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowAllHost), resource2)\n+    assertTrue(\"User1 from host2 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllHost), resource2)\n+    assertFalse(\"User1 from host2 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h2Context, READ, ResourceType.TOPIC))\n+  }\n+\n+\n+  def testAuthorizeByResourceTypeWithAllPrincipalAce(authorizer: Authorizer): Unit = {\n+    val user1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user1\")\n+    val user2 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"user2\")\n+    val allUser = AclEntry.WildcardPrincipalString\n+    val host1 = InetAddress.getByName(\"192.168.1.1\")\n+    val resource1 = new ResourcePattern(TOPIC, \"sb1\" + UUID.randomUUID(), LITERAL)\n+    val resource2 = new ResourcePattern(TOPIC, \"sb2\" + UUID.randomUUID(), LITERAL)\n+    val allowUser1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, ALLOW)\n+    val denyUser1 = new AccessControlEntry(user1.toString, host1.getHostAddress, READ, DENY)\n+    val denyAllUser = new AccessControlEntry(allUser, host1.getHostAddress, READ, DENY)\n+    val allowAllUser = new AccessControlEntry(allUser, host1.getHostAddress, READ, ALLOW)\n+    val u1h1Context = newRequestContext(user1, host1)\n+    val u2h1Context = newRequestContext(user2, host1)\n+\n+    assertFalse(\"User1 from host1 should not have READ access to any topic when no ACL exists\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowUser1), resource1)\n+    assertTrue(\"User1 from host1 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllUser), resource1)\n+    assertFalse(\"User1 from host1 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyUser1), resource2)\n+    assertFalse(\"User1 from host1 still should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u1h1Context, READ, ResourceType.TOPIC))\n+    assertFalse(\"User2 from host1 should not have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u2h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(allowAllUser), resource2)\n+    assertTrue(\"User2 from host1 should now have READ access to at least one topic\",\n+      authorizeByResourceType(authorizer, u2h1Context, READ, ResourceType.TOPIC))\n+\n+    addAcls(authorizer, Set(denyAllUser), resource2)\n+    assertFalse(\"User2 from host1 now shouldn't have READ access to any topic\",\n+      authorizeByResourceType(authorizer, u2h1Context, READ, ResourceType.TOPIC))\n+  }\n+\n+  def testAuthorzeByResourceTypeSuperUserHasAccess(authorizer: Authorizer, superUserName: String): Unit = {\n+    val denyAllAce = new AccessControlEntry(WildcardPrincipalString, WildcardHost, AclOperation.ALL, DENY)\n+    val superUser1 = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, superUserName)\n+    val host1 = InetAddress.getByName(\"192.0.4.4\")\n+    val allTopicsResource = new ResourcePattern(TOPIC, WILDCARD_RESOURCE, LITERAL)\n+    val clusterResource = new ResourcePattern(CLUSTER, WILDCARD_RESOURCE, LITERAL)\n+    val groupResource = new ResourcePattern(GROUP, WILDCARD_RESOURCE, LITERAL)\n+    val transactionIdResource = new ResourcePattern(TRANSACTIONAL_ID, WILDCARD_RESOURCE, LITERAL)\n+\n+    addAcls(authorizer, Set(denyAllAce), allTopicsResource)\n+    addAcls(authorizer, Set(denyAllAce), clusterResource)\n+    addAcls(authorizer, Set(denyAllAce), groupResource)\n+    addAcls(authorizer, Set(denyAllAce), transactionIdResource)\n+\n+    val superUserContext = newRequestContext(superUser1, host1)\n+\n+    assertTrue(\"superuser with custom principal always has access, no matter what acls.\",\n+      authorizeByResourceType(authorizer, superUserContext, READ, ResourceType.TOPIC))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b22ecd69c0001046d62e6236e768422cbf1df0a0"}, "originalPosition": 312}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI0NDgxMw==", "bodyText": "Can we check how much work it would be to convert authorizerTestFactory into an  abstract BaseAuthorizerTest class that the three xxxAuthorizerTest classes extend? Having to repeat these tests in all three places makes it too easy to miss one in the future.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544244813", "createdAt": "2020-12-16T12:05:14Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerWrapperTest.scala", "diffHunk": "@@ -0,0 +1,211 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.net.InetAddress\n+import java.util.UUID\n+\n+import kafka.security.auth.SimpleAclAuthorizer\n+import kafka.server.KafkaConfig\n+import kafka.utils.TestUtils\n+import kafka.zk.ZooKeeperTestHarness\n+import kafka.zookeeper.ZooKeeperClient\n+import org.apache.kafka.common.acl.AclOperation._\n+import org.apache.kafka.common.acl._\n+import org.apache.kafka.common.network.{ClientInformation, ListenerName}\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.requests.{RequestContext, RequestHeader}\n+import org.apache.kafka.common.resource.PatternType.LITERAL\n+import org.apache.kafka.common.resource.ResourceType._\n+import org.apache.kafka.common.resource.{ResourcePattern, ResourceType}\n+import org.apache.kafka.common.security.auth.{KafkaPrincipal, SecurityProtocol}\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.authorizer._\n+import org.junit.Assert._\n+import org.junit.{After, Before, Test}\n+\n+import scala.annotation.nowarn\n+import scala.collection.mutable.ArrayBuffer\n+import scala.jdk.CollectionConverters._\n+\n+class AuthorizerWrapperTest extends ZooKeeperTestHarness {\n+  @nowarn(\"cat=deprecation\")\n+  private val wrappedSimpleAuthorizer = new AuthorizerWrapper(new SimpleAclAuthorizer)\n+  @nowarn(\"cat=deprecation\")\n+  private val wrappedSimpleAuthorizerAllowEveryone = new AuthorizerWrapper(new SimpleAclAuthorizer)\n+  private var resource: ResourcePattern = _\n+  private val superUsers = \"User:superuser1; User:superuser2\"\n+  private val username = \"alice\"\n+  private val principal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, username)\n+  private val requestContext = newRequestContext(principal, InetAddress.getByName(\"192.168.0.1\"))\n+  private var config: KafkaConfig = _\n+  private var zooKeeperClient: ZooKeeperClient = _\n+\n+  private val aclAdded: ArrayBuffer[(Authorizer, Set[AccessControlEntry], ResourcePattern)] = ArrayBuffer()\n+  private val authorizerTestFactory = new AuthorizerTestFactory(\n+    newRequestContext, addAcls, authorizeByResourceType, removeAcls)\n+\n+  class CustomPrincipal(principalType: String, name: String) extends KafkaPrincipal(principalType, name) {\n+    override def equals(o: scala.Any): Boolean = false\n+  }\n+\n+  @Before\n+  @nowarn(\"cat=deprecation\")\n+  override def setUp(): Unit = {\n+    super.setUp()\n+\n+    val props = TestUtils.createBrokerConfig(0, zkConnect)\n+\n+    props.put(AclAuthorizer.SuperUsersProp, superUsers)\n+    config = KafkaConfig.fromProps(props)\n+    wrappedSimpleAuthorizer.configure(config.originals)\n+\n+    props.put(SimpleAclAuthorizer.AllowEveryoneIfNoAclIsFoundProp, \"true\")\n+    config = KafkaConfig.fromProps(props)\n+    wrappedSimpleAuthorizerAllowEveryone.configure(config.originals)\n+\n+    resource = new ResourcePattern(TOPIC, \"foo-\" + UUID.randomUUID(), LITERAL)\n+    zooKeeperClient = new ZooKeeperClient(zkConnect, zkSessionTimeout, zkConnectionTimeout, zkMaxInFlightRequests,\n+      Time.SYSTEM, \"kafka.test\", \"AuthorizerWrapperTest\")\n+  }\n+\n+  @After\n+  override def tearDown(): Unit = {\n+    val authorizers = Seq(wrappedSimpleAuthorizer, wrappedSimpleAuthorizerAllowEveryone)\n+    authorizers.foreach(a => {\n+      a.close()\n+    })\n+    zooKeeperClient.close()\n+    super.tearDown()\n+  }\n+\n+  @Test\n+  def testAuthorizeByResourceTypeMultipleAddAndRemove(): Unit = {\n+    authorizerTestFactory.testAuthorizeByResourceTypeMultipleAddAndRemove(wrappedSimpleAuthorizer)\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b22ecd69c0001046d62e6236e768422cbf1df0a0"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI0NjI1Mg==", "bodyText": "nit: principle => principal", "url": "https://github.com/apache/kafka/pull/9485#discussion_r544246252", "createdAt": "2020-12-16T12:07:37Z", "author": {"login": "rajinisivaram"}, "path": "jmh-benchmarks/src/main/java/org/apache/kafka/jmh/acl/AclAuthorizerBenchmark.java", "diffHunk": "@@ -116,38 +122,88 @@ private void setFieldValue(Object obj, String fieldName, Object value) throws Ex\n             Set<AclEntry> entries = aclEntries.computeIfAbsent(resource, k -> new HashSet<>());\n \n             for (int aclId = 0; aclId < aclCount; aclId++) {\n-                AccessControlEntry ace = new AccessControlEntry(principal.toString() + aclId,\n-                    \"*\", AclOperation.READ, AclPermissionType.ALLOW);\n-                entries.add(new AclEntry(ace));\n+                // The principle in the request context we are using", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b22ecd69c0001046d62e6236e768422cbf1df0a0"}, "originalPosition": 84}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec80dc4e55758d83835f3ecde381a988d6dd4779", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/ec80dc4e55758d83835f3ecde381a988d6dd4779", "committedDate": "2020-12-16T18:57:33Z", "message": "NIT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5e3d18f57ab22df20133f9841905af384d9b641", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/e5e3d18f57ab22df20133f9841905af384d9b641", "committedDate": "2020-12-16T23:18:46Z", "message": "Make a base authorizer class for code sharing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/092fec70a9547ec07cba999e77be1c0cf79fa275", "committedDate": "2020-12-16T23:54:20Z", "message": "condense methods and class members for sharing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0Nzk4NTg4", "url": "https://github.com/apache/kafka/pull/9485#pullrequestreview-554798588", "createdAt": "2020-12-17T16:56:46Z", "commit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "state": "COMMENTED", "comments": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNjo1Njo0NlrOIH_M3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMToyNjoyOVrOIIJaqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI0NjQyOA==", "bodyText": "resourceIndex => resourceTypeKey and omit new.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545246428", "createdAt": "2020-12-17T16:56:46Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def hasMatchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                           resourceType: ResourceType, patternType: PatternType): Boolean = {\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI0NzM5Nw==", "bodyText": "Couldn't we just check:resourceCache.contains(resourceKey) ?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545247397", "createdAt": "2020-12-17T16:58:03Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def hasMatchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                           resourceType: ResourceType, patternType: PatternType): Boolean = {\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI2MTEyOA==", "bodyText": "resourceIndex => resourceTypeKey, Also we can omit new for ResourceTypeKey since it is a case class.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545261128", "createdAt": "2020-12-17T17:17:49Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI2NDc5NQ==", "bodyText": "private def", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545264795", "createdAt": "2020-12-17T17:23:02Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def hasMatchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI2NDg5OA==", "bodyText": "private def", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545264898", "createdAt": "2020-12-17T17:23:10Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI2NzczNw==", "bodyText": "We can use map instead of match:\naclCache.get(resource).map(_.acls.map(_.ace)).getOrElse(Set.empty)", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545267737", "createdAt": "2020-12-17T17:27:13Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -547,7 +683,37 @@ class AclAuthorizer extends Authorizer with Logging {\n     zkClient.getVersionedAclsForResource(resource)\n   }\n \n-  private def updateCache(resource: ResourcePattern, versionedAcls: VersionedAcls): Unit = {\n+  // Visible for benchmark\n+  def updateCache(resource: ResourcePattern, versionedAcls: VersionedAcls): Unit = {\n+    val currentAces: Set[AccessControlEntry] = aclCache.get(resource) match {\n+      case Some(versionedAcls) => versionedAcls.acls.map(aclEntry => aclEntry.ace)\n+      case None => Set.empty", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI3MDIyMg==", "bodyText": "resourceIndex => resourceTypeKey, Omit new", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545270222", "createdAt": "2020-12-17T17:30:45Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -547,7 +683,37 @@ class AclAuthorizer extends Authorizer with Logging {\n     zkClient.getVersionedAclsForResource(resource)\n   }\n \n-  private def updateCache(resource: ResourcePattern, versionedAcls: VersionedAcls): Unit = {\n+  // Visible for benchmark\n+  def updateCache(resource: ResourcePattern, versionedAcls: VersionedAcls): Unit = {\n+    val currentAces: Set[AccessControlEntry] = aclCache.get(resource) match {\n+      case Some(versionedAcls) => versionedAcls.acls.map(aclEntry => aclEntry.ace)\n+      case None => Set.empty\n+    }\n+    val newAces: Set[AccessControlEntry] = versionedAcls.acls.map(aclEntry => aclEntry.ace)\n+    val acesToAdd = newAces.diff(currentAces)\n+    val acesToRemove = currentAces.diff(newAces)\n+\n+    acesToAdd.foreach(ace => {\n+      val resourceIndex = new ResourceTypeKey(ace, resource.resourceType(), resource.patternType())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI3MDI5Mg==", "bodyText": "resourceIndex => resourceTypeKey, Omit new", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545270292", "createdAt": "2020-12-17T17:30:53Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -547,7 +683,37 @@ class AclAuthorizer extends Authorizer with Logging {\n     zkClient.getVersionedAclsForResource(resource)\n   }\n \n-  private def updateCache(resource: ResourcePattern, versionedAcls: VersionedAcls): Unit = {\n+  // Visible for benchmark\n+  def updateCache(resource: ResourcePattern, versionedAcls: VersionedAcls): Unit = {\n+    val currentAces: Set[AccessControlEntry] = aclCache.get(resource) match {\n+      case Some(versionedAcls) => versionedAcls.acls.map(aclEntry => aclEntry.ace)\n+      case None => Set.empty\n+    }\n+    val newAces: Set[AccessControlEntry] = versionedAcls.acls.map(aclEntry => aclEntry.ace)\n+    val acesToAdd = newAces.diff(currentAces)\n+    val acesToRemove = currentAces.diff(newAces)\n+\n+    acesToAdd.foreach(ace => {\n+      val resourceIndex = new ResourceTypeKey(ace, resource.resourceType(), resource.patternType())\n+      resourceCache.get(resourceIndex) match {\n+        case Some(resources) => resourceCache += (resourceIndex -> (resources + resource.name()))\n+        case None => resourceCache += (resourceIndex -> immutable.HashSet(resource.name()))\n+      }\n+    })\n+    acesToRemove.foreach(ace => {\n+      val resourceIndex = new ResourceTypeKey(ace, resource.resourceType(), resource.patternType())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI3MzU2MQ==", "bodyText": "canDenyAll => denyAll since can doesn't fit with deny", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545273561", "createdAt": "2020-12-17T17:35:05Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/common/utils/SecurityUtils.java", "diffHunk": "@@ -146,4 +148,32 @@ else if (capitalizeNext) {\n         }\n         return builder.toString();\n     }\n+\n+    public static void authorizeByResourceTypeCheckArgs(AclOperation op,\n+                                                        ResourceType type) {\n+        if (type == ResourceType.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter resource type for authorizeByResourceType\");\n+        }\n+\n+        if (type == ResourceType.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown resource type\");\n+        }\n+\n+        if (op == AclOperation.ANY) {\n+            throw new IllegalArgumentException(\n+                \"Must specify a non-filter operation type for authorizeByResourceType\");\n+        }\n+\n+        if (op == AclOperation.UNKNOWN) {\n+            throw new IllegalArgumentException(\n+                \"Unknown operation type\");\n+        }\n+    }\n+\n+    public static boolean canDenyAll(ResourcePattern pattern) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI4MDY1NA==", "bodyText": "Suggestions to improve this (feel free to ignore/update):\nCustom authorizer implementations should consider overriding this default implementation because:\n1) The default implementation iterates all AclBindings multiple times, without any caching for resource types. More efficient implementations may be added in custom authorizers that directly access cached entries.\n2) The default implementation cannot integrate with any audit logging included in the authorizer implementation.\n3) The default implementation does not support any custom authorizer configs or other access rules apart from ACLs.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545280654", "createdAt": "2020-12-17T17:45:19Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,133 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * It is important to override this interface default in implementations because", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI4MjM3NA==", "bodyText": "Add a comment to say that we check for one hard-coded name to ensure that super users are granted access regardless of DENY acls.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545282374", "createdAt": "2020-12-17T17:47:45Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,133 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * It is important to override this interface default in implementations because\n+     * 1. The interface default iterates all AclBindings multiple times, without any indexing,\n+     *    which is a CPU intense work.\n+     * 2. The interface default rebuild several sets of strings, which is a memory intense work.\n+     * 3. The interface default cannot perform the audit logging properly\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType);\n+\n+        if (authorize(requestContext, Collections.singletonList(new Action(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI4NzQxOQ==", "bodyText": "Can we make this comment two lines instead of 4 since each sentence seems short enough to fit into a line?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545287419", "createdAt": "2020-12-17T17:55:22Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/server/authorizer/Authorizer.java", "diffHunk": "@@ -139,4 +152,133 @@\n      * @return Iterator for ACL bindings, which may be populated lazily.\n      */\n     Iterable<AclBinding> acls(AclBindingFilter filter);\n+\n+    /**\n+     * Check if the caller is authorized to perform the\u00a0given ACL operation on at least one\n+     * resource of the given type.\n+     *\n+     * It is important to override this interface default in implementations because\n+     * 1. The interface default iterates all AclBindings multiple times, without any indexing,\n+     *    which is a CPU intense work.\n+     * 2. The interface default rebuild several sets of strings, which is a memory intense work.\n+     * 3. The interface default cannot perform the audit logging properly\n+     *\n+     * @param requestContext Request context including request resourceType, security protocol, and listener name\n+     * @param op             The ACL operation to check\n+     * @param resourceType   The resource type to check\n+     * @return               Return {@link AuthorizationResult#ALLOWED} if the caller is authorized to perform the\n+     *                      \u00a0given ACL operation on at least one resource of the given type.\n+     *                       Return {@link AuthorizationResult#DENIED} otherwise.\n+     */\n+    default AuthorizationResult authorizeByResourceType(AuthorizableRequestContext requestContext, AclOperation op, ResourceType resourceType) {\n+        SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType);\n+\n+        if (authorize(requestContext, Collections.singletonList(new Action(\n+                op, new ResourcePattern(resourceType, \"hardcode\", PatternType.LITERAL),\n+                0, true, false)))\n+                .get(0) == AuthorizationResult.ALLOWED) {\n+            return AuthorizationResult.ALLOWED;\n+        }\n+\n+        // Filter out all the resource pattern corresponding to the RequestContext,\n+        // AclOperation, and ResourceType\n+        ResourcePatternFilter resourceTypeFilter = new ResourcePatternFilter(\n+            resourceType, null, PatternType.ANY);\n+        AclBindingFilter aclFilter = new AclBindingFilter(\n+            resourceTypeFilter, AccessControlEntryFilter.ANY);\n+\n+        EnumMap<PatternType, Set<String>> denyPatterns =\n+            new EnumMap<PatternType, Set<String>>(PatternType.class) {{\n+                put(PatternType.LITERAL, new HashSet<>());\n+                put(PatternType.PREFIXED, new HashSet<>());\n+            }};\n+        EnumMap<PatternType, Set<String>> allowPatterns =\n+            new EnumMap<PatternType, Set<String>>(PatternType.class) {{\n+                put(PatternType.LITERAL, new HashSet<>());\n+                put(PatternType.PREFIXED, new HashSet<>());\n+            }};\n+\n+        boolean hasWildCardAllow = false;\n+\n+        KafkaPrincipal principal = new KafkaPrincipal(\n+            requestContext.principal().getPrincipalType(),\n+            requestContext.principal().getName());\n+        String hostAddr = requestContext.clientAddress().getHostAddress();\n+\n+        for (AclBinding binding : acls(aclFilter)) {\n+            if (!binding.entry().host().equals(hostAddr) && !binding.entry().host().equals(\"*\"))\n+                continue;\n+\n+            if (!SecurityUtils.parseKafkaPrincipal(binding.entry().principal()).equals(principal)\n+                    && !binding.entry().principal().equals(\"User:*\"))\n+                continue;\n+\n+            if (binding.entry().operation() != op\n+                    && binding.entry().operation() != AclOperation.ALL)\n+                continue;\n+\n+            if (binding.entry().permissionType() == AclPermissionType.DENY) {\n+                switch (binding.pattern().patternType()) {\n+                    case LITERAL:\n+                        // If wildcard deny exists, return deny directly\n+                        if (binding.pattern().name().equals(ResourcePattern.WILDCARD_RESOURCE))\n+                            return AuthorizationResult.DENIED;\n+                        denyPatterns.get(PatternType.LITERAL).add(binding.pattern().name());\n+                        break;\n+                    case PREFIXED:\n+                        denyPatterns.get(PatternType.PREFIXED).add(binding.pattern().name());\n+                        break;\n+                    default:\n+                }\n+                continue;\n+            }\n+\n+            if (binding.entry().permissionType() != AclPermissionType.ALLOW)\n+                continue;\n+\n+            switch (binding.pattern().patternType()) {\n+                case LITERAL:\n+                    if (binding.pattern().name().equals(ResourcePattern.WILDCARD_RESOURCE)) {\n+                        hasWildCardAllow = true;\n+                        continue;\n+                    }\n+                    allowPatterns.get(PatternType.LITERAL).add(binding.pattern().name());\n+                    break;\n+                case PREFIXED:\n+                    allowPatterns.get(PatternType.PREFIXED).add(binding.pattern().name());\n+                    break;\n+                default:\n+            }\n+        }\n+\n+        if (hasWildCardAllow) {\n+            return AuthorizationResult.ALLOWED;\n+        }\n+\n+        // For any literal allowed, if there's no dominant literal\n+        // and prefix denied, return allow.\n+        // For any prefix allowed, if there's no dominant prefix\n+        // denied, return allow.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMyNTkwOQ==", "bodyText": "PatternType.UNKNOWN looks odd in audit logs, ANY may be better.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545325909", "createdAt": "2020-12-17T18:53:16Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2MzkzMw==", "bodyText": "The nested for loop can be replaced with:\nfor (p <- Set(principal, AclEntry.WildcardPrincipalString); h <- Set(host, AclEntry.WildcardHost); o <- Set(op, AclOperation.ALL))", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545363933", "createdAt": "2020-12-17T19:55:50Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2NTg1NQ==", "bodyText": "We can make this a val by using an ArrayBuffer instead of List that we keep recreating", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545365855", "createdAt": "2020-12-17T19:58:45Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2NjEwMQ==", "bodyText": "As before, we can use a single for loop instead of nested loop", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545366101", "createdAt": "2020-12-17T19:59:08Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def hasMatchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                           resourceType: ResourceType, patternType: PatternType): Boolean = {\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2NzQ5Nw==", "bodyText": "Can use denyLiterals.exists(_.contains(ResourcePattern.WILDCARD_RESOURCE))", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545367497", "createdAt": "2020-12-17T20:01:27Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def hasMatchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                           resourceType: ResourceType, patternType: PatternType): Boolean = {\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(_) => return true\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    false\n+  }\n+\n+  private def denyAll(denyLiterals: List[immutable.HashSet[String]]): Boolean =\n+    denyLiterals.exists(r => r.contains(ResourcePattern.WILDCARD_RESOURCE))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2ODA0NQ==", "bodyText": "Can use allowPrefixes.exists(_.exists, similarly for allowLiterals.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545368045", "createdAt": "2020-12-17T20:02:13Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def hasMatchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                           resourceType: ResourceType, patternType: PatternType): Boolean = {\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(_) => return true\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    false\n+  }\n+\n+  private def denyAll(denyLiterals: List[immutable.HashSet[String]]): Boolean =\n+    denyLiterals.exists(r => r.contains(ResourcePattern.WILDCARD_RESOURCE))\n+\n+\n+  private def allowAny(allowLiterals: List[immutable.Set[String]], allowPrefixes: List[immutable.Set[String]],\n+                       denyLiterals: List[immutable.Set[String]], denyPrefixes: List[immutable.Set[String]]): Boolean = {\n+    (allowPrefixes.exists(prefixes =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2ODE5OA==", "bodyText": "nit: space before {", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545368198", "createdAt": "2020-12-17T20:02:31Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def hasMatchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                           resourceType: ResourceType, patternType: PatternType): Boolean = {\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(_) => return true\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    false\n+  }\n+\n+  private def denyAll(denyLiterals: List[immutable.HashSet[String]]): Boolean =\n+    denyLiterals.exists(r => r.contains(ResourcePattern.WILDCARD_RESOURCE))\n+\n+\n+  private def allowAny(allowLiterals: List[immutable.Set[String]], allowPrefixes: List[immutable.Set[String]],\n+                       denyLiterals: List[immutable.Set[String]], denyPrefixes: List[immutable.Set[String]]): Boolean = {\n+    (allowPrefixes.exists(prefixes =>\n+          prefixes.exists(prefix => allowPrefix(prefix, denyPrefixes)))\n+      || allowLiterals.exists(literals =>\n+            literals.exists(literal => allowLiteral(literal, denyLiterals, denyPrefixes))))\n+  }\n+\n+  private def allowLiteral(literalName: String, denyLiterals: List[immutable.Set[String]],\n+                           denyPrefixes: List[immutable.Set[String]]): Boolean = {\n+    literalName match{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM2OTU3MQ==", "bodyText": "Can be !denyLiterals.exists(_.contains(literalName))?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545369571", "createdAt": "2020-12-17T20:04:55Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(resources) => matched = matched :+ resources\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    matched\n+  }\n+\n+  def hasMatchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                           resourceType: ResourceType, patternType: PatternType): Boolean = {\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {\n+            case Some(_) => return true\n+            case None =>\n+          }\n+        }\n+      }\n+    }\n+    false\n+  }\n+\n+  private def denyAll(denyLiterals: List[immutable.HashSet[String]]): Boolean =\n+    denyLiterals.exists(r => r.contains(ResourcePattern.WILDCARD_RESOURCE))\n+\n+\n+  private def allowAny(allowLiterals: List[immutable.Set[String]], allowPrefixes: List[immutable.Set[String]],\n+                       denyLiterals: List[immutable.Set[String]], denyPrefixes: List[immutable.Set[String]]): Boolean = {\n+    (allowPrefixes.exists(prefixes =>\n+          prefixes.exists(prefix => allowPrefix(prefix, denyPrefixes)))\n+      || allowLiterals.exists(literals =>\n+            literals.exists(literal => allowLiteral(literal, denyLiterals, denyPrefixes))))\n+  }\n+\n+  private def allowLiteral(literalName: String, denyLiterals: List[immutable.Set[String]],\n+                           denyPrefixes: List[immutable.Set[String]]): Boolean = {\n+    literalName match{\n+      case ResourcePattern.WILDCARD_RESOURCE => true\n+      case _ => (denyLiterals.forall(denyLiterals => !denyLiterals.contains(literalName))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5OTEwMQ==", "bodyText": "We should use the same pattern as the usage of aclCache where we get a aclCacheSnapshot at the start of the method and then use the same snapshot throughout the method rather than use a changing value of resourceCache within the loop.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545399101", "createdAt": "2020-12-17T20:57:59Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -304,6 +309,137 @@ class AclAuthorizer extends Authorizer with Logging {\n     if (zkClient != null) zkClient.close()\n   }\n \n+  override def authorizeByResourceType(requestContext: AuthorizableRequestContext,\n+                                       op: AclOperation,\n+                                       resourceType: ResourceType): AuthorizationResult = {\n+    SecurityUtils.authorizeByResourceTypeCheckArgs(op, resourceType)\n+\n+    val principal = new KafkaPrincipal(\n+      requestContext.principal().getPrincipalType,\n+      requestContext.principal().getName)\n+\n+    if (isSuperUser(principal))\n+      return AuthorizationResult.ALLOWED\n+\n+    val principalStr = principal.toString\n+\n+    val host = requestContext.clientAddress().getHostAddress\n+    val action = new Action(op, new ResourcePattern(resourceType, \"NONE\", PatternType.UNKNOWN), 0, true, true)\n+\n+    val denyLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.LITERAL)\n+\n+    if (denyAll(denyLiterals)) {\n+      logAuditMessage(requestContext, action, authorized = false)\n+      return AuthorizationResult.DENIED\n+    }\n+\n+    if (shouldAllowEveryoneIfNoAclIsFound) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    val denyPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.DENY, resourceType, PatternType.PREFIXED)\n+\n+    if (denyLiterals.isEmpty && denyPrefixes.isEmpty) {\n+      if (hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+          || hasMatchingResources(principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)) {\n+        logAuditMessage(requestContext, action, authorized = true)\n+        return AuthorizationResult.ALLOWED\n+      } else {\n+        logAuditMessage(requestContext, action, authorized = false)\n+        return AuthorizationResult.DENIED\n+      }\n+    }\n+\n+    val allowLiterals = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.LITERAL)\n+    val allowPrefixes = matchingResources(\n+      principalStr, host, op, AclPermissionType.ALLOW, resourceType, PatternType.PREFIXED)\n+\n+    if (allowAny(allowLiterals, allowPrefixes, denyLiterals, denyPrefixes)) {\n+      logAuditMessage(requestContext, action, authorized = true)\n+      return AuthorizationResult.ALLOWED\n+    }\n+\n+    logAuditMessage(requestContext, action, authorized = false)\n+    AuthorizationResult.DENIED\n+  }\n+\n+  def matchingResources(principal: String, host: String, op: AclOperation, permission: AclPermissionType,\n+                        resourceType: ResourceType, patternType: PatternType): List[immutable.HashSet[String]] = {\n+    var matched = List[immutable.HashSet[String]]()\n+    for (p <- Set(principal, AclEntry.WildcardPrincipalString)) {\n+      for (h <- Set(host, AclEntry.WildcardHost)) {\n+        for (o <- Set(op, AclOperation.ALL)) {\n+          val resourceIndex = new ResourceTypeKey(\n+            new AccessControlEntry(p, h, o, permission), resourceType, patternType)\n+          resourceCache.get(resourceIndex) match {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxMDMyMg==", "bodyText": "Could just close interfaceDefaultAuthorizer instead of creating an authorizers collection?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545410322", "createdAt": "2020-12-17T21:19:25Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerInterfaceDefaultTest.scala", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.util.concurrent.CompletionStage\n+import java.{lang, util}\n+\n+import kafka.server.KafkaConfig\n+import kafka.utils.TestUtils\n+import kafka.zk.ZooKeeperTestHarness\n+import kafka.zookeeper.ZooKeeperClient\n+import org.apache.kafka.common.Endpoint\n+import org.apache.kafka.common.acl._\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.authorizer._\n+import org.junit.{After, Before}\n+\n+class AuthorizerInterfaceDefaultTest extends ZooKeeperTestHarness with BaseAuthorizerTest {\n+\n+  private val interfaceDefaultAuthorizer = new DelegateAuthorizer\n+\n+  override def authorizer: Authorizer = interfaceDefaultAuthorizer\n+\n+  @Before\n+  override def setUp(): Unit = {\n+    super.setUp()\n+\n+    val authorizers = Seq(interfaceDefaultAuthorizer.authorizer)\n+\n+    // Increase maxUpdateRetries to avoid transient failures\n+    authorizers.foreach(a => a.maxUpdateRetries = Int.MaxValue)\n+\n+    val props = TestUtils.createBrokerConfig(0, zkConnect)\n+    props.put(AclAuthorizer.SuperUsersProp, superUsers)\n+\n+    config = KafkaConfig.fromProps(props)\n+    authorizers.foreach(a => a.configure(config.originals))\n+\n+    zooKeeperClient = new ZooKeeperClient(zkConnect, zkSessionTimeout, zkConnectionTimeout, zkMaxInFlightRequests,\n+      Time.SYSTEM, \"kafka.test\", \"AuthorizerInterfaceDefaultTest\")\n+  }\n+\n+  @After\n+  override def tearDown(): Unit = {\n+    val authorizers = Seq(interfaceDefaultAuthorizer)\n+    authorizers.foreach(a => {\n+      a.close()\n+    })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxMTM2MQ==", "bodyText": "The authorizer parameter is not used. Can't we just move this into the test method testAuthorizeByResourceTypeNoAclFoundOverride above?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545411361", "createdAt": "2020-12-17T21:21:34Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -988,6 +980,30 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n     }\n   }\n \n+  @Test\n+  def testAuthorizeByResourceTypeNoAclFoundOverride(): Unit = {\n+    testAuthorizeByResourceTypeNoAclFoundOverride(aclAuthorizer)\n+  }\n+\n+  private def testAuthorizeByResourceTypeNoAclFoundOverride(authorizer: Authorizer): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxMTgyOQ==", "bodyText": "can't this be aclAuthorizer?", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545411829", "createdAt": "2020-12-17T21:22:24Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AclAuthorizerTest.scala", "diffHunk": "@@ -988,6 +980,30 @@ class AclAuthorizerTest extends ZooKeeperTestHarness {\n     }\n   }\n \n+  @Test\n+  def testAuthorizeByResourceTypeNoAclFoundOverride(): Unit = {\n+    testAuthorizeByResourceTypeNoAclFoundOverride(aclAuthorizer)\n+  }\n+\n+  private def testAuthorizeByResourceTypeNoAclFoundOverride(authorizer: Authorizer): Unit = {\n+    val props = TestUtils.createBrokerConfig(1, zkConnect)\n+    props.put(AclAuthorizer.AllowEveryoneIfNoAclIsFoundProp, \"true\")\n+\n+    val cfg = KafkaConfig.fromProps(props)\n+    val testAuthorizer = new AclAuthorizer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxMjYzOQ==", "bodyText": "There is only one authorizer, we could just use it directly instead of creating a Seq", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545412639", "createdAt": "2020-12-17T21:24:09Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerInterfaceDefaultTest.scala", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.util.concurrent.CompletionStage\n+import java.{lang, util}\n+\n+import kafka.server.KafkaConfig\n+import kafka.utils.TestUtils\n+import kafka.zk.ZooKeeperTestHarness\n+import kafka.zookeeper.ZooKeeperClient\n+import org.apache.kafka.common.Endpoint\n+import org.apache.kafka.common.acl._\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.authorizer._\n+import org.junit.{After, Before}\n+\n+class AuthorizerInterfaceDefaultTest extends ZooKeeperTestHarness with BaseAuthorizerTest {\n+\n+  private val interfaceDefaultAuthorizer = new DelegateAuthorizer\n+\n+  override def authorizer: Authorizer = interfaceDefaultAuthorizer\n+\n+  @Before\n+  override def setUp(): Unit = {\n+    super.setUp()\n+\n+    val authorizers = Seq(interfaceDefaultAuthorizer.authorizer)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxMzgwMA==", "bodyText": "Looks like there is opportunity to move some of this stuff into BaseAuthorizerTest, but we can do that in a follow-up later.", "url": "https://github.com/apache/kafka/pull/9485#discussion_r545413800", "createdAt": "2020-12-17T21:26:29Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/security/authorizer/AuthorizerInterfaceDefaultTest.scala", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.security.authorizer\n+\n+import java.util.concurrent.CompletionStage\n+import java.{lang, util}\n+\n+import kafka.server.KafkaConfig\n+import kafka.utils.TestUtils\n+import kafka.zk.ZooKeeperTestHarness\n+import kafka.zookeeper.ZooKeeperClient\n+import org.apache.kafka.common.Endpoint\n+import org.apache.kafka.common.acl._\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.authorizer._\n+import org.junit.{After, Before}\n+\n+class AuthorizerInterfaceDefaultTest extends ZooKeeperTestHarness with BaseAuthorizerTest {\n+\n+  private val interfaceDefaultAuthorizer = new DelegateAuthorizer\n+\n+  override def authorizer: Authorizer = interfaceDefaultAuthorizer\n+\n+  @Before\n+  override def setUp(): Unit = {\n+    super.setUp()\n+\n+    val authorizers = Seq(interfaceDefaultAuthorizer.authorizer)\n+\n+    // Increase maxUpdateRetries to avoid transient failures\n+    authorizers.foreach(a => a.maxUpdateRetries = Int.MaxValue)\n+\n+    val props = TestUtils.createBrokerConfig(0, zkConnect)\n+    props.put(AclAuthorizer.SuperUsersProp, superUsers)\n+\n+    config = KafkaConfig.fromProps(props)\n+    authorizers.foreach(a => a.configure(config.originals))\n+\n+    zooKeeperClient = new ZooKeeperClient(zkConnect, zkSessionTimeout, zkConnectionTimeout, zkMaxInFlightRequests,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "092fec70a9547ec07cba999e77be1c0cf79fa275"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6a766b228034a442e3a6e8b71ecee78eefdbfd3", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/b6a766b228034a442e3a6e8b71ecee78eefdbfd3", "committedDate": "2020-12-18T02:15:31Z", "message": "Another NIT"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9407b1697d976fc6cff90703573a64f7a3c9f348", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/9407b1697d976fc6cff90703573a64f7a3c9f348", "committedDate": "2020-12-18T05:31:12Z", "message": "address the missing comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2fa768a62e7a343af200e10e54a1bc890a76ca46", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/2fa768a62e7a343af200e10e54a1bc890a76ca46", "committedDate": "2020-12-18T05:30:24Z", "message": "address the missing comments"}, "afterCommit": {"oid": "9407b1697d976fc6cff90703573a64f7a3c9f348", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/9407b1697d976fc6cff90703573a64f7a3c9f348", "committedDate": "2020-12-18T05:31:12Z", "message": "address the missing comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85231ec69bdf59be7853424dbe3c946addc8ec2b", "author": {"user": {"login": "rajinisivaram", "name": "Rajini Sivaram"}}, "url": "https://github.com/apache/kafka/commit/85231ec69bdf59be7853424dbe3c946addc8ec2b", "committedDate": "2020-12-18T10:03:59Z", "message": "A few minor updates"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MzU2NTIw", "url": "https://github.com/apache/kafka/pull/9485#pullrequestreview-555356520", "createdAt": "2020-12-18T10:08:01Z", "commit": {"oid": "9407b1697d976fc6cff90703573a64f7a3c9f348"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd620f4cc70d09def9304904e7fcf020fd1c406e", "author": {"user": {"login": "rajinisivaram", "name": "Rajini Sivaram"}}, "url": "https://github.com/apache/kafka/commit/dd620f4cc70d09def9304904e7fcf020fd1c406e", "committedDate": "2020-12-18T13:57:02Z", "message": "Fix Scala 2.12 build"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2854, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}