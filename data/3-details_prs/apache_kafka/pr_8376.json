{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0OTU0NjM3", "number": 8376, "title": "KAFKA-9724 Newer clients not always sending fetch request to older brokers", "bodyText": "We had a similar case previously with KAFKA-8422 (#6806) where we would skip the validation step if the broker was on a version older than 2.3.\nThis PR makes a similar change on the prepareFetchRequest side. If the broker is older than 2.3, we will skip the transition to AWAITING_VALIDATION but also we will clear that state if it had been set by a call to seekUnvalidated.\nThis PR adds a check for an appropriate version of OFFSETS_FOR_LEADER_EPOCH before entering the validation state in the consumer. If the broker does not support version 3+ of this API, we skip validation.\nAlso cleaned up the logic behind updating last-seen leader epochs. Now, if the leader epoch is null, we will not update it unless we are processing a metadata response. This prevents the client from learning about an epoch before it knows anything about the leader.", "createdAt": "2020-03-27T20:25:25Z", "url": "https://github.com/apache/kafka/pull/8376", "merged": true, "mergeCommit": {"oid": "1672a75e1f04ce3b7cd4fa202942a8887cf811e1"}, "closed": true, "closedAt": "2020-05-27T20:37:23Z", "author": {"login": "mumrah"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcR2ICjgH2gAyMzk0OTU0NjM3OmM3YmE4ZDU3ZjRmNTFmOWVhZGZlODBhMjUzY2Y0YWUwNDhkYjFhOGQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABclF2UQAH2gAyMzk0OTU0NjM3OjM3YmIzYTViYjgyZjIwNmY2ZGY5ZTQ2ZjI2N2YyMTQzODEzYzg5ODA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c7ba8d57f4f51f9eadfe80a253cf4ae048db1a8d", "author": {"user": {"login": "mumrah", "name": "David Arthur"}}, "url": "https://github.com/apache/kafka/commit/c7ba8d57f4f51f9eadfe80a253cf4ae048db1a8d", "committedDate": "2020-03-27T19:46:27Z", "message": "AWAITING_VALIDATION state causing clients to skip sending fetches to older broker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a461ec53379fd32dbb7142e7791bcdb51c53262", "author": {"user": {"login": "mumrah", "name": "David Arthur"}}, "url": "https://github.com/apache/kafka/commit/4a461ec53379fd32dbb7142e7791bcdb51c53262", "committedDate": "2020-04-07T03:20:30Z", "message": "Don't overwrite a partition's last seen epoch if it wasn't set already"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "349d7e42bc6dcf7dc7bb193cb427a6ff19f8be66", "author": {"user": {"login": "mumrah", "name": "David Arthur"}}, "url": "https://github.com/apache/kafka/commit/349d7e42bc6dcf7dc7bb193cb427a6ff19f8be66", "committedDate": "2020-04-07T15:36:00Z", "message": "Actually implement the new logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8433abb86a448f0f365e0aa985a047d7af366ab0", "author": {"user": {"login": "mumrah", "name": "David Arthur"}}, "url": "https://github.com/apache/kafka/commit/8433abb86a448f0f365e0aa985a047d7af366ab0", "committedDate": "2020-04-07T15:36:17Z", "message": "Add some tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MzQ4MDY0", "url": "https://github.com/apache/kafka/pull/8376#pullrequestreview-389348064", "createdAt": "2020-04-07T17:43:11Z", "commit": {"oid": "4a461ec53379fd32dbb7142e7791bcdb51c53262"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzo0MzoxMlrOGCO9tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxNzo1MDowNlrOGCPOkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5NTUxMA==", "bodyText": "This seems unused?", "url": "https://github.com/apache/kafka/pull/8376#discussion_r404995510", "createdAt": "2020-04-07T17:43:12Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/Metadata.java", "diffHunk": "@@ -178,11 +179,13 @@ public synchronized boolean updateLastSeenEpochIfNewer(TopicPartition topicParti\n      * @param topicPartition       topic+partition to update the epoch for\n      * @param epoch                the new epoch\n      * @param epochTest            a predicate to determine if the old epoch should be replaced\n+     * @param overwriteNullEpoch   if we should allow overwriting a missing epoch\n      * @return true if the epoch was updated, false otherwise\n      */\n     private synchronized boolean updateLastSeenEpoch(TopicPartition topicPartition,\n                                                      int epoch,\n-                                                     Predicate<Integer> epochTest) {\n+                                                     Predicate<Integer> epochTest,\n+                                                     boolean overwriteNullEpoch) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a461ec53379fd32dbb7142e7791bcdb51c53262"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk5OTgyNg==", "bodyText": "I think we can simplify this a little bit. The common case is that we will have an active connection and api version information available. If we are not connected, could we just go through maybeValidatePositionForCurrentLeader. as before?", "url": "https://github.com/apache/kafka/pull/8376#discussion_r404999826", "createdAt": "2020-04-07T17:50:06Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/Fetcher.java", "diffHunk": "@@ -1096,9 +1096,26 @@ Node selectReadReplica(TopicPartition partition, Node leaderReplica, long curren\n     private Map<Node, FetchSessionHandler.FetchRequestData> prepareFetchRequests() {\n         Map<Node, FetchSessionHandler.Builder> fetchable = new LinkedHashMap<>();\n \n-        // Ensure the position has an up-to-date leader\n-        subscriptions.assignedPartitions().forEach(\n-            tp -> subscriptions.maybeValidatePositionForCurrentLeader(tp, metadata.currentLeader(tp)));\n+        // Ensure the position has an up-to-date leader, if the leader is set and it's ApiVersion is new enough\n+        subscriptions.assignedPartitions().forEach(tp -> {\n+            Metadata.LeaderAndEpoch leaderAndEpoch = metadata.currentLeader(tp);\n+            final boolean offsetForEpochAvailable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a461ec53379fd32dbb7142e7791bcdb51c53262"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "567dc2d0261820205061a47c26e1ee0892ebac88", "author": {"user": {"login": "mumrah", "name": "David Arthur"}}, "url": "https://github.com/apache/kafka/commit/567dc2d0261820205061a47c26e1ee0892ebac88", "committedDate": "2020-04-07T18:29:31Z", "message": "Simply logic for completing validation in prepareFetchRequests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48605dc90f953f89def1c055272e4696dfbd4779", "author": {"user": {"login": "mumrah", "name": "David Arthur"}}, "url": "https://github.com/apache/kafka/commit/48605dc90f953f89def1c055272e4696dfbd4779", "committedDate": "2020-04-07T19:30:47Z", "message": "Feedback from PR"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NDk2NjI3", "url": "https://github.com/apache/kafka/pull/8376#pullrequestreview-389496627", "createdAt": "2020-04-07T21:16:24Z", "commit": {"oid": "48605dc90f953f89def1c055272e4696dfbd4779"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMToxNjoyNFrOGCWcjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMToxNjoyNFrOGCWcjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExODA5Mw==", "bodyText": "I removed this since at this point the two callers have different needs for updating the epoch and adding a flag felt pretty kludgy", "url": "https://github.com/apache/kafka/pull/8376#discussion_r405118093", "createdAt": "2020-04-07T21:16:24Z", "author": {"login": "mumrah"}, "path": "clients/src/main/java/org/apache/kafka/clients/Metadata.java", "diffHunk": "@@ -172,29 +189,6 @@ public synchronized boolean updateLastSeenEpochIfNewer(TopicPartition topicParti\n         return Optional.ofNullable(lastSeenLeaderEpochs.get(topicPartition));\n     }\n \n-    /**\n-     * Conditionally update the leader epoch for a partition\n-     *\n-     * @param topicPartition       topic+partition to update the epoch for\n-     * @param epoch                the new epoch\n-     * @param epochTest            a predicate to determine if the old epoch should be replaced\n-     * @return true if the epoch was updated, false otherwise\n-     */\n-    private synchronized boolean updateLastSeenEpoch(TopicPartition topicPartition,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48605dc90f953f89def1c055272e4696dfbd4779"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NDk3ODYz", "url": "https://github.com/apache/kafka/pull/8376#pullrequestreview-389497863", "createdAt": "2020-04-07T21:18:30Z", "commit": {"oid": "48605dc90f953f89def1c055272e4696dfbd4779"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMToxODozMFrOGCWgfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMToxODozMFrOGCWgfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExOTEwMg==", "bodyText": "After removing the updateLastSeenEpoch private method, there wasn't much point in this test. The epoch update is covered better in other tests anyways", "url": "https://github.com/apache/kafka/pull/8376#discussion_r405119102", "createdAt": "2020-04-07T21:18:30Z", "author": {"login": "mumrah"}, "path": "clients/src/test/java/org/apache/kafka/clients/MetadataTest.java", "diffHunk": "@@ -378,26 +382,6 @@ public void testRejectOldMetadata() {\n         }\n     }\n \n-    @Test\n-    public void testMaybeRequestUpdate() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48605dc90f953f89def1c055272e4696dfbd4779"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce38b74de19dfa90e529d5b841c0e573a2958b34", "author": {"user": {"login": "mumrah", "name": "David Arthur"}}, "url": "https://github.com/apache/kafka/commit/ce38b74de19dfa90e529d5b841c0e573a2958b34", "committedDate": "2020-04-08T15:49:20Z", "message": "checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45c20d8a53ef02b40b953d14c7f6f03e72c7fa05", "author": {"user": {"login": "mumrah", "name": "David Arthur"}}, "url": "https://github.com/apache/kafka/commit/45c20d8a53ef02b40b953d14c7f6f03e72c7fa05", "committedDate": "2020-04-08T15:49:37Z", "message": "Merge remote-tracking branch 'apache-github/trunk' into KAFKA-9724"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMTg0NjEx", "url": "https://github.com/apache/kafka/pull/8376#pullrequestreview-390184611", "createdAt": "2020-04-08T17:30:33Z", "commit": {"oid": "45c20d8a53ef02b40b953d14c7f6f03e72c7fa05"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNzozMDozM1rOGC5mbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNzo0NzowMFrOGC6LYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY5NDA2MA==", "bodyText": "It might be useful to mention here that this method is reserved for cases where the leader epoch is derived from some external source (such as committed offsets or fetched records). Maybe also document the returned value.", "url": "https://github.com/apache/kafka/pull/8376#discussion_r405694060", "createdAt": "2020-04-08T17:30:33Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/Metadata.java", "diffHunk": "@@ -156,14 +155,31 @@ public synchronized int requestUpdateForNewTopics() {\n     }\n \n     /**\n-     * Request an update for the partition metadata iff the given leader epoch is newer than the last seen leader epoch\n+     * Request an update for the partition metadata iff we encounter a leader epoch that is newer than the last seen leader epoch", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45c20d8a53ef02b40b953d14c7f6f03e72c7fa05"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY5NTQyMw==", "bodyText": "nit: add partition to this message?", "url": "https://github.com/apache/kafka/pull/8376#discussion_r405695423", "createdAt": "2020-04-08T17:32:58Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/Metadata.java", "diffHunk": "@@ -156,14 +155,31 @@ public synchronized int requestUpdateForNewTopics() {\n     }\n \n     /**\n-     * Request an update for the partition metadata iff the given leader epoch is newer than the last seen leader epoch\n+     * Request an update for the partition metadata iff we encounter a leader epoch that is newer than the last seen leader epoch\n      */\n     public synchronized boolean updateLastSeenEpochIfNewer(TopicPartition topicPartition, int leaderEpoch) {\n         Objects.requireNonNull(topicPartition, \"TopicPartition cannot be null\");\n         if (leaderEpoch < 0)\n             throw new IllegalArgumentException(\"Invalid leader epoch \" + leaderEpoch + \" (must be non-negative)\");\n \n-        boolean updated = updateLastSeenEpoch(topicPartition, leaderEpoch, oldEpoch -> leaderEpoch > oldEpoch);\n+        Integer oldEpoch = lastSeenLeaderEpochs.get(topicPartition);\n+        log.trace(\"Determining if we should replace existing epoch {} with new epoch {}\", oldEpoch, leaderEpoch);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45c20d8a53ef02b40b953d14c7f6f03e72c7fa05"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY5NTk4NQ==", "bodyText": "nit: could we collapse this with else if", "url": "https://github.com/apache/kafka/pull/8376#discussion_r405695985", "createdAt": "2020-04-08T17:33:56Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/Metadata.java", "diffHunk": "@@ -156,14 +155,31 @@ public synchronized int requestUpdateForNewTopics() {\n     }\n \n     /**\n-     * Request an update for the partition metadata iff the given leader epoch is newer than the last seen leader epoch\n+     * Request an update for the partition metadata iff we encounter a leader epoch that is newer than the last seen leader epoch\n      */\n     public synchronized boolean updateLastSeenEpochIfNewer(TopicPartition topicPartition, int leaderEpoch) {\n         Objects.requireNonNull(topicPartition, \"TopicPartition cannot be null\");\n         if (leaderEpoch < 0)\n             throw new IllegalArgumentException(\"Invalid leader epoch \" + leaderEpoch + \" (must be non-negative)\");\n \n-        boolean updated = updateLastSeenEpoch(topicPartition, leaderEpoch, oldEpoch -> leaderEpoch > oldEpoch);\n+        Integer oldEpoch = lastSeenLeaderEpochs.get(topicPartition);\n+        log.trace(\"Determining if we should replace existing epoch {} with new epoch {}\", oldEpoch, leaderEpoch);\n+\n+        final boolean updated;\n+        if (oldEpoch == null) {\n+            log.debug(\"Not replacing null epoch with new epoch {} for partition {}\", leaderEpoch, topicPartition);\n+            updated = false;\n+        } else {\n+            if (leaderEpoch > oldEpoch) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45c20d8a53ef02b40b953d14c7f6f03e72c7fa05"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwMDk4Nw==", "bodyText": "Would it make sense to push this check into maybeValidatePositionForCurrentLeader by passing through ApiVersions?  Otherwise, some of the checks here are redundant.", "url": "https://github.com/apache/kafka/pull/8376#discussion_r405700987", "createdAt": "2020-04-08T17:42:29Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/Fetcher.java", "diffHunk": "@@ -1098,8 +1098,20 @@ Node selectReadReplica(TopicPartition partition, Node leaderReplica, long curren\n         Map<Node, FetchSessionHandler.Builder> fetchable = new LinkedHashMap<>();\n \n         // Ensure the position has an up-to-date leader\n-        subscriptions.assignedPartitions().forEach(\n-            tp -> subscriptions.maybeValidatePositionForCurrentLeader(tp, metadata.currentLeader(tp)));\n+        subscriptions.assignedPartitions().forEach(tp -> {\n+            Metadata.LeaderAndEpoch leaderAndEpoch = metadata.currentLeader(tp);\n+            if (leaderAndEpoch.leader.isPresent()) {\n+                NodeApiVersions nodeApiVersions = apiVersions.get(leaderAndEpoch.leader.get().idString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45c20d8a53ef02b40b953d14c7f6f03e72c7fa05"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcwMzUyMQ==", "bodyText": "Why would removal of a private method make this test less relevant? Which test case already covers this?", "url": "https://github.com/apache/kafka/pull/8376#discussion_r405703521", "createdAt": "2020-04-08T17:47:00Z", "author": {"login": "hachikuji"}, "path": "clients/src/test/java/org/apache/kafka/clients/MetadataTest.java", "diffHunk": "@@ -378,26 +382,6 @@ public void testRejectOldMetadata() {\n         }\n     }\n \n-    @Test\n-    public void testMaybeRequestUpdate() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExOTEwMg=="}, "originalCommit": {"oid": "48605dc90f953f89def1c055272e4696dfbd4779"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8d4a8c5e76d9788a6669a1095103ac0f0fdfe17", "author": {"user": {"login": "mumrah", "name": "David Arthur"}}, "url": "https://github.com/apache/kafka/commit/c8d4a8c5e76d9788a6669a1095103ac0f0fdfe17", "committedDate": "2020-04-08T19:46:34Z", "message": "Add unit test for epoch updates in MetadataTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a1d6e699d3c01f8312151b637fa1d4a6dd1a6a7", "author": {"user": {"login": "mumrah", "name": "David Arthur"}}, "url": "https://github.com/apache/kafka/commit/7a1d6e699d3c01f8312151b637fa1d4a6dd1a6a7", "committedDate": "2020-05-18T15:32:52Z", "message": "Merge remote-tracking branch 'apache-github/trunk' into KAFKA-9724"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e05d8ad9e0ab0c1c7372c4f353fa41fdbafd1724", "author": {"user": {"login": "mumrah", "name": "David Arthur"}}, "url": "https://github.com/apache/kafka/commit/e05d8ad9e0ab0c1c7372c4f353fa41fdbafd1724", "committedDate": "2020-05-18T15:50:13Z", "message": "Update javadoc for updateLastSeenEpochIfNewer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa87a4bd9d37323dc1eafd83f7d23308ceaa14c7", "author": {"user": {"login": "mumrah", "name": "David Arthur"}}, "url": "https://github.com/apache/kafka/commit/aa87a4bd9d37323dc1eafd83f7d23308ceaa14c7", "committedDate": "2020-05-22T15:43:46Z", "message": "Push logic into maybeValidatePositionForCurrentLeader"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MDEyMjA1", "url": "https://github.com/apache/kafka/pull/8376#pullrequestreview-417012205", "createdAt": "2020-05-22T15:46:30Z", "commit": {"oid": "aa87a4bd9d37323dc1eafd83f7d23308ceaa14c7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTo0NjozMFrOGZb0gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTo0NjozMFrOGZb0gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMyMzM5NQ==", "bodyText": "I wonder, do we really need this call here? If the leader is not present the epoch shouldn't be present either -- right? If that's the case, then the call to maybeValidatePosition will short circuit\n        private boolean maybeValidatePosition(Metadata.LeaderAndEpoch currentLeaderAndEpoch) {\n            if (this.fetchState.equals(FetchStates.AWAIT_RESET)) {\n                return false;\n            }\n\n            if (!currentLeaderAndEpoch.leader.isPresent() && !currentLeaderAndEpoch.epoch.isPresent()) {\n                return false;\n            }\n\n            if (position != null && !position.currentLeader.equals(currentLeaderAndEpoch)) {\n                FetchPosition newPosition = new FetchPosition(position.offset, position.offsetEpoch, currentLeaderAndEpoch);\n                validatePosition(newPosition);\n                preferredReadReplica = null;\n            }\n            return this.fetchState.equals(FetchStates.AWAIT_VALIDATION);\n        }", "url": "https://github.com/apache/kafka/pull/8376#discussion_r429323395", "createdAt": "2020-05-22T15:46:30Z", "author": {"login": "mumrah"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/SubscriptionState.java", "diffHunk": "@@ -422,8 +427,29 @@ public synchronized void position(TopicPartition tp, FetchPosition position) {\n         assignedState(tp).position(position);\n     }\n \n-    public synchronized boolean maybeValidatePositionForCurrentLeader(TopicPartition tp, Metadata.LeaderAndEpoch leaderAndEpoch) {\n-        return assignedState(tp).maybeValidatePosition(leaderAndEpoch);\n+    /**\n+     * Enter the offset validation state if the leader for this partition is known to support a usable version of the\n+     * OffsetsForLeaderEpoch API. If the leader node does not support the API, simply complete the offset validation.\n+     *\n+     * @param apiVersions\n+     * @param tp\n+     * @param leaderAndEpoch\n+     * @return true if we enter the offset validation state\n+     */\n+    public synchronized boolean maybeValidatePositionForCurrentLeader(ApiVersions apiVersions, TopicPartition tp,\n+                                                                      Metadata.LeaderAndEpoch leaderAndEpoch) {\n+        if (leaderAndEpoch.leader.isPresent()) {\n+            NodeApiVersions nodeApiVersions = apiVersions.get(leaderAndEpoch.leader.get().idString());\n+            if (nodeApiVersions == null || hasUsableOffsetForLeaderEpochVersion(nodeApiVersions)) {\n+                return assignedState(tp).maybeValidatePosition(leaderAndEpoch);\n+            } else {\n+                // If the broker does not support a newer version of OffsetsForLeaderEpoch, we skip validation\n+                completeValidation(tp);\n+                return false;\n+            }\n+        } else {\n+            return assignedState(tp).maybeValidatePosition(leaderAndEpoch);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa87a4bd9d37323dc1eafd83f7d23308ceaa14c7"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MTcwNjE2", "url": "https://github.com/apache/kafka/pull/8376#pullrequestreview-417170616", "createdAt": "2020-05-22T20:36:41Z", "commit": {"oid": "aa87a4bd9d37323dc1eafd83f7d23308ceaa14c7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37bb3a5bb82f206f6df9e46f267f2143813c8980", "author": {"user": {"login": "mumrah", "name": "David Arthur"}}, "url": "https://github.com/apache/kafka/commit/37bb3a5bb82f206f6df9e46f267f2143813c8980", "committedDate": "2020-05-26T14:50:08Z", "message": "Checkstyle"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1725, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}