{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0Njk5MTc3", "number": 9139, "title": "KAFKA-9929: Support backward iterator on SessionStore", "bodyText": "Depends on #9138\nMore detailed description of your change,\nif necessary. The PR title and PR message become\nthe squashed commit message, so use a separate\ncomment to ping reviewers.\nSummary of testing strategy (including rationale)\nfor the feature or bug fix. Unit and/or integration\ntests are expected for any behaviour change and\nsystem tests should be considered for larger changes.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-08-07T16:24:09Z", "url": "https://github.com/apache/kafka/pull/9139", "merged": true, "mergeCommit": {"oid": "d0e6943bdd048aa6e0a4dbbdad3c8da460db16dc"}, "closed": true, "closedAt": "2020-10-08T13:08:25Z", "author": {"login": "jeqo"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc91zHoABqjM2NDI4NzkzODg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQZuFNgH2gAyNDY0Njk5MTc3OjE0ZmNlNTIxMzQ2YjI5MDQwN2M5NzFlNDJiZDY4NGY1NWI1MTI3ODU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyNTcyMjIx", "url": "https://github.com/apache/kafka/pull/9139#pullrequestreview-502572221", "createdAt": "2020-10-06T04:18:53Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwNDoxODo1M1rOHc1Yzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwNDozMTowOVrOHc1jug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk5Njg3OQ==", "bodyText": "Can you fix the keyFrom == keyTo to use .equals on the side (down on line 370)", "url": "https://github.com/apache/kafka/pull/9139#discussion_r499996879", "createdAt": "2020-10-06T04:18:53Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingSessionStore.java", "diffHunk": "@@ -359,7 +431,11 @@ private void getNextSegmentIterator() {\n             setCacheKeyRange(currentSegmentBeginTime(), currentSegmentLastTime());\n \n             current.close();\n-            current = context.cache().range(cacheName, cacheKeyFrom, cacheKeyTo);\n+            if (forward) {\n+                current = context.cache().range(cacheName, cacheKeyFrom, cacheKeyTo);\n+            } else {\n+                current = context.cache().reverseRange(cacheName, cacheKeyFrom, cacheKeyTo);\n+            }\n         }\n \n         private void setCacheKeyRange(final long lowerRangeEndTime, final long upperRangeEndTime) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk5ODcyMg==", "bodyText": "I think we're going to need some additional changes in this class similar to what we had in CachingWindowStore. Definitely at least in getNextSegmentIterator(). Let's make sure to have some cross-segment test coverage here as well, especially because the iteration logic of session store range queries is the hardest to wrap your head around out of all the stores (at least, it is for me)", "url": "https://github.com/apache/kafka/pull/9139#discussion_r499998722", "createdAt": "2020-10-06T04:27:12Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingSessionStore.java", "diffHunk": "@@ -359,7 +431,11 @@ private void getNextSegmentIterator() {\n             setCacheKeyRange(currentSegmentBeginTime(), currentSegmentLastTime());\n \n             current.close();\n-            current = context.cache().range(cacheName, cacheKeyFrom, cacheKeyTo);\n+            if (forward) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk5OTMzMw==", "bodyText": "If/else needs brackets", "url": "https://github.com/apache/kafka/pull/9139#discussion_r499999333", "createdAt": "2020-10-06T04:29:42Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/InMemorySessionStore.java", "diffHunk": "@@ -382,9 +478,20 @@ private boolean setInnerIterators() {\n                 currentKey = nextKeyEntry.getKey();\n \n                 if (latestSessionStartTime == Long.MAX_VALUE) {\n-                    recordIterator = nextKeyEntry.getValue().entrySet().iterator();\n+                    final Set<Entry<Long, byte[]>> entries;\n+                    if (forward) entries = nextKeyEntry.getValue().descendingMap().entrySet();\n+                    else entries = nextKeyEntry.getValue().entrySet();\n+                    recordIterator = entries.iterator();\n                 } else {\n-                    recordIterator = nextKeyEntry.getValue().headMap(latestSessionStartTime, true).entrySet().iterator();\n+                    final Set<Entry<Long, byte[]>> entries;\n+                    if (forward) entries = nextKeyEntry.getValue()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk5OTY3NA==", "bodyText": "missing newline", "url": "https://github.com/apache/kafka/pull/9139#discussion_r499999674", "createdAt": "2020-10-06T04:31:09Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/InMemorySessionStore.java", "diffHunk": "@@ -201,7 +247,26 @@ public void remove(final Windowed<Bytes> sessionKey) {\n \n         removeExpiredSegments();\n \n-        return registerNewIterator(key, key, Long.MAX_VALUE, endTimeMap.entrySet().iterator());\n+        return registerNewIterator(\n+            key,\n+            key,\n+            Long.MAX_VALUE, endTimeMap.entrySet().iterator(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 93}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNDM1NTgy", "url": "https://github.com/apache/kafka/pull/9139#pullrequestreview-503435582", "createdAt": "2020-10-06T23:50:49Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMzo1MDo0OVrOHddxgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMzo1MDo0OVrOHddxgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY1ODU2MA==", "bodyText": "Ok I think that for the reverse case, this should be initialized to cacheFunction.segmentId(maxObservedTimestamp) and lastSegmentId should be initialized to this (segmentId(earliestSessionEndTime)).", "url": "https://github.com/apache/kafka/pull/9139#discussion_r500658560", "createdAt": "2020-10-06T23:50:49Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingSessionStore.java", "diffHunk": "@@ -270,25 +335,32 @@ public void close() {\n \n         private CacheIteratorWrapper(final Bytes key,\n                                      final long earliestSessionEndTime,\n-                                     final long latestSessionStartTime) {\n-            this(key, key, earliestSessionEndTime, latestSessionStartTime);\n+                                     final long latestSessionStartTime,\n+                                     final boolean forward) {\n+            this(key, key, earliestSessionEndTime, latestSessionStartTime, forward);\n         }\n \n         private CacheIteratorWrapper(final Bytes keyFrom,\n                                      final Bytes keyTo,\n                                      final long earliestSessionEndTime,\n-                                     final long latestSessionStartTime) {\n+                                     final long latestSessionStartTime,\n+                                     final boolean forward) {\n             this.keyFrom = keyFrom;\n             this.keyTo = keyTo;\n             this.latestSessionStartTime = latestSessionStartTime;\n             this.lastSegmentId = cacheFunction.segmentId(maxObservedTimestamp);\n             this.segmentInterval = cacheFunction.getSegmentInterval();\n+            this.forward = forward;\n \n             this.currentSegmentId = cacheFunction.segmentId(earliestSessionEndTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 182}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNDQyNDI2", "url": "https://github.com/apache/kafka/pull/9139#pullrequestreview-503442426", "createdAt": "2020-10-07T00:11:32Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDoxMTozMlrOHdeJrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDoxODo0MVrOHdeRvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2NDc1MQ==", "bodyText": "We're losing the ordering check by comparing this as a set, let's use a list (or whatever) to verify the actual order", "url": "https://github.com/apache/kafka/pull/9139#discussion_r500664751", "createdAt": "2020-10-07T00:11:32Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CachingSessionStoreTest.java", "diffHunk": "@@ -301,6 +366,29 @@ public void shouldFetchRangeCorrectlyAcrossSegments() {\n         assertEquals(mkSet(a1, a2, a3, aa1, aa3), keys);\n     }\n \n+    @Test\n+    public void shouldBackwardFetchRangeCorrectlyAcrossSegments() {\n+        final Windowed<Bytes> a1 = new Windowed<>(keyA, new SessionWindow(SEGMENT_INTERVAL * 0, SEGMENT_INTERVAL * 0));\n+        final Windowed<Bytes> aa1 = new Windowed<>(keyAA, new SessionWindow(SEGMENT_INTERVAL * 0, SEGMENT_INTERVAL * 0));\n+        final Windowed<Bytes> a2 = new Windowed<>(keyA, new SessionWindow(SEGMENT_INTERVAL * 1, SEGMENT_INTERVAL * 1));\n+        final Windowed<Bytes> a3 = new Windowed<>(keyA, new SessionWindow(SEGMENT_INTERVAL * 2, SEGMENT_INTERVAL * 2));\n+        final Windowed<Bytes> aa3 = new Windowed<>(keyAA, new SessionWindow(SEGMENT_INTERVAL * 2, SEGMENT_INTERVAL * 2));\n+        cachingStore.put(a1, \"1\".getBytes());\n+        cachingStore.put(aa1, \"1\".getBytes());\n+        cachingStore.put(a2, \"2\".getBytes());\n+        cachingStore.put(a3, \"3\".getBytes());\n+        cachingStore.put(aa3, \"3\".getBytes());\n+\n+        final KeyValueIterator<Windowed<Bytes>, byte[]> rangeResults =\n+            cachingStore.backwardFindSessions(keyA, keyAA, 0, SEGMENT_INTERVAL * 2);\n+        final Set<Windowed<Bytes>> keys = new HashSet<>();\n+        while (rangeResults.hasNext()) {\n+            keys.add(rangeResults.next().key);\n+        }\n+        rangeResults.close();\n+        assertEquals(mkSet(a1, a2, a3, aa1, aa3), keys);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2NDkyNw==", "bodyText": "Can we add a few more records that span multiple segments that don't get flushed as well?", "url": "https://github.com/apache/kafka/pull/9139#discussion_r500664927", "createdAt": "2020-10-07T00:12:05Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CachingSessionStoreTest.java", "diffHunk": "@@ -278,6 +326,23 @@ public void shouldFetchCorrectlyAcrossSegments() {\n         assertFalse(results.hasNext());\n     }\n \n+    @Test\n+    public void shouldBackwardFetchCorrectlyAcrossSegments() {\n+        final Windowed<Bytes> a1 = new Windowed<>(keyA, new SessionWindow(SEGMENT_INTERVAL * 0, SEGMENT_INTERVAL * 0));\n+        final Windowed<Bytes> a2 = new Windowed<>(keyA, new SessionWindow(SEGMENT_INTERVAL * 1, SEGMENT_INTERVAL * 1));\n+        final Windowed<Bytes> a3 = new Windowed<>(keyA, new SessionWindow(SEGMENT_INTERVAL * 2, SEGMENT_INTERVAL * 2));\n+        cachingStore.put(a1, \"1\".getBytes());\n+        cachingStore.put(a2, \"2\".getBytes());\n+        cachingStore.flush();\n+        cachingStore.put(a3, \"3\".getBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2NTUwNg==", "bodyText": "Technically \"InvalidRangeException\" was just the name of the exception that could get thrown, there is no \"InvalidBackwardRangeException\" that I know of \ud83d\ude1b  But I think the meaning is clear enough lol", "url": "https://github.com/apache/kafka/pull/9139#discussion_r500665506", "createdAt": "2020-10-07T00:14:08Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CachingSessionStoreTest.java", "diffHunk": "@@ -456,68 +562,88 @@ public void shouldClearNamespaceCacheOnClose() {\n         assertEquals(0, cache.size());\n     }\n \n-    @Test(expected = InvalidStateStoreException.class)\n+    @Test\n     public void shouldThrowIfTryingToFetchFromClosedCachingStore() {\n         cachingStore.close();\n-        cachingStore.fetch(keyA);\n+        assertThrows(InvalidStateStoreException.class, () -> cachingStore.fetch(keyA));\n     }\n \n-    @Test(expected = InvalidStateStoreException.class)\n+    @Test\n     public void shouldThrowIfTryingToFindMergeSessionFromClosedCachingStore() {\n         cachingStore.close();\n-        cachingStore.findSessions(keyA, 0, Long.MAX_VALUE);\n+        assertThrows(InvalidStateStoreException.class, () -> cachingStore.findSessions(keyA, 0, Long.MAX_VALUE));\n     }\n \n-    @Test(expected = InvalidStateStoreException.class)\n+    @Test\n     public void shouldThrowIfTryingToRemoveFromClosedCachingStore() {\n         cachingStore.close();\n-        cachingStore.remove(new Windowed<>(keyA, new SessionWindow(0, 0)));\n+        assertThrows(InvalidStateStoreException.class, () -> cachingStore.remove(new Windowed<>(keyA, new SessionWindow(0, 0))));\n     }\n \n-    @Test(expected = InvalidStateStoreException.class)\n+    @Test\n     public void shouldThrowIfTryingToPutIntoClosedCachingStore() {\n         cachingStore.close();\n-        cachingStore.put(new Windowed<>(keyA, new SessionWindow(0, 0)), \"1\".getBytes());\n+        assertThrows(InvalidStateStoreException.class, () -> cachingStore.put(new Windowed<>(keyA, new SessionWindow(0, 0)), \"1\".getBytes()));\n     }\n \n-    @Test(expected = NullPointerException.class)\n+    @Test\n     public void shouldThrowNullPointerExceptionOnFindSessionsNullKey() {\n-        cachingStore.findSessions(null, 1L, 2L);\n+        assertThrows(NullPointerException.class, () -> cachingStore.findSessions(null, 1L, 2L));\n     }\n \n-    @Test(expected = NullPointerException.class)\n+    @Test\n     public void shouldThrowNullPointerExceptionOnFindSessionsNullFromKey() {\n-        cachingStore.findSessions(null, keyA, 1L, 2L);\n+        assertThrows(NullPointerException.class, () -> cachingStore.findSessions(null, keyA, 1L, 2L));\n     }\n \n-    @Test(expected = NullPointerException.class)\n+    @Test\n     public void shouldThrowNullPointerExceptionOnFindSessionsNullToKey() {\n-        cachingStore.findSessions(keyA, null, 1L, 2L);\n+        assertThrows(NullPointerException.class, () -> cachingStore.findSessions(keyA, null, 1L, 2L));\n     }\n \n-    @Test(expected = NullPointerException.class)\n+    @Test\n     public void shouldThrowNullPointerExceptionOnFetchNullFromKey() {\n-        cachingStore.fetch(null, keyA);\n+        assertThrows(NullPointerException.class, () -> cachingStore.fetch(null, keyA));\n     }\n \n-    @Test(expected = NullPointerException.class)\n+    @Test\n     public void shouldThrowNullPointerExceptionOnFetchNullToKey() {\n-        cachingStore.fetch(keyA, null);\n+        assertThrows(NullPointerException.class, () -> cachingStore.fetch(keyA, null));\n     }\n \n-    @Test(expected = NullPointerException.class)\n+    @Test\n     public void shouldThrowNullPointerExceptionOnFetchNullKey() {\n-        cachingStore.fetch(null);\n+        assertThrows(NullPointerException.class, () -> cachingStore.fetch(null));\n     }\n \n-    @Test(expected = NullPointerException.class)\n+    @Test\n     public void shouldThrowNullPointerExceptionOnRemoveNullKey() {\n-        cachingStore.remove(null);\n+        assertThrows(NullPointerException.class, () -> cachingStore.remove(null));\n     }\n \n-    @Test(expected = NullPointerException.class)\n+    @Test\n     public void shouldThrowNullPointerExceptionOnPutNullKey() {\n-        cachingStore.put(null, \"1\".getBytes());\n+        assertThrows(NullPointerException.class, () -> cachingStore.put(null, \"1\".getBytes()));\n+    }\n+\n+    @Test\n+    public void shouldNotThrowInvalidBackwardRangeExceptionWithNegativeFromKey() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2NjgxMw==", "bodyText": "I guess it probably doesn't matter since we presumably aren't using these backward methods of the ReadOnlySessionStoreStub, but it seems like it might result in some tricky NPEs to debug if ever someone does try to use it in a test. If you don't feel like implementing it I think it's fine to just throw UnsupportedOperationException and say that you'll have to implement this to use it.\nOr just copy the code from the forward direction and flip it \ud83e\udd37\u200d\u2640\ufe0f  Same goes for all the methods in here that return null", "url": "https://github.com/apache/kafka/pull/9139#discussion_r500666813", "createdAt": "2020-10-07T00:18:41Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/test/ReadOnlySessionStoreStub.java", "diffHunk": "@@ -82,11 +118,15 @@ public boolean hasNext() {\n                 public KeyValue<Windowed<K>, V> next() {\n                     return it.next();\n                 }\n-\n             }\n         );\n     }\n \n+    @Override\n+    public KeyValueIterator<Windowed<K>, V> backwardFetch(K from, K to) {\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 79}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d4327cbadb408c8134e5ac09592d41719f772e5", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/9d4327cbadb408c8134e5ac09592d41719f772e5", "committedDate": "2020-10-07T08:21:08Z", "message": "key/value reverse operation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6761c71e41040883634c8b664cdac9b3250a778c", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/6761c71e41040883634c8b664cdac9b3250a778c", "committedDate": "2020-10-07T08:21:08Z", "message": "window backward operations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "000c7b79009d24f61a97e562d8cdf5fb2bbef637", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/000c7b79009d24f61a97e562d8cdf5fb2bbef637", "committedDate": "2020-10-07T08:21:09Z", "message": "session backward operations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1811b577b027506d6249e1d71690bc82107ef2bf", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/1811b577b027506d6249e1d71690bc82107ef2bf", "committedDate": "2020-10-07T08:21:09Z", "message": "improve time range comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c26756dac79c2e5f1574c8057aeef3e163c71ea", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/8c26756dac79c2e5f1574c8057aeef3e163c71ea", "committedDate": "2020-10-07T08:21:09Z", "message": "fix bytes range validator not needed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0d160bc3ebf65a02fd995ea59e191a8db90b171", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/e0d160bc3ebf65a02fd995ea59e191a8db90b171", "committedDate": "2020-10-07T08:21:09Z", "message": "fix cache iterator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae7e3edcc426a98d61572686c4f884085f49e80c", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/ae7e3edcc426a98d61572686c4f884085f49e80c", "committedDate": "2020-10-07T08:21:10Z", "message": "fix session store to support backward queries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64a95c01658f1281e6e7b8986b9678dcbf456ffc", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/64a95c01658f1281e6e7b8986b9678dcbf456ffc", "committedDate": "2020-10-07T08:21:10Z", "message": "improve format based on feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a875cf1237a75eed6ccf3e00321768623aa8af11", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/a875cf1237a75eed6ccf3e00321768623aa8af11", "committedDate": "2020-10-07T08:21:10Z", "message": "test caching store across segments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "a875cf1237a75eed6ccf3e00321768623aa8af11", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/a875cf1237a75eed6ccf3e00321768623aa8af11", "committedDate": "2020-10-07T08:21:10Z", "message": "test caching store across segments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76bb9a27fd7a5e58bcfb74c8eca70c295f573d20", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/76bb9a27fd7a5e58bcfb74c8eca70c295f573d20", "committedDate": "2020-10-07T09:40:10Z", "message": "improve testing names and scenarios"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e49f258ad78bb75f23481f030d5e7be1db12ce00", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/e49f258ad78bb75f23481f030d5e7be1db12ce00", "committedDate": "2020-10-07T22:00:02Z", "message": "expand caching store tests per backing store"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MzMwNDQ1", "url": "https://github.com/apache/kafka/pull/9139#pullrequestreview-504330445", "createdAt": "2020-10-07T23:14:32Z", "commit": {"oid": "e49f258ad78bb75f23481f030d5e7be1db12ce00"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MDA3MjM2", "url": "https://github.com/apache/kafka/pull/9139#pullrequestreview-504007236", "createdAt": "2020-10-07T15:30:41Z", "commit": {"oid": "76bb9a27fd7a5e58bcfb74c8eca70c295f573d20"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNTozMDo0MlrOHd5MCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMjo0MzoyNlrOHeIEIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEwNzcyMg==", "bodyText": "It won't matter to users whether this method was moved from another interface or not. They just need to know why they're getting the exception. I.e., we just need to tell them that the store implementation they selected didn't implement the method.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new UnsupportedOperationException(\"Moved from SessionStore\");\n          \n          \n            \n                    throw new UnsupportedOperationException(\"This API is not supported by this implementation of ReadOnlySessionStore.\");\n          \n      \n    \n    \n  \n\nWe should say the exact same thing in all default implementations. Right now, they're a bit inconsistent.", "url": "https://github.com/apache/kafka/pull/9139#discussion_r501107722", "createdAt": "2020-10-07T15:30:42Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/ReadOnlySessionStore.java", "diffHunk": "@@ -24,35 +24,156 @@\n  * Implementations should be thread-safe as concurrent reads and writes\n  * are expected.\n  *\n- * @param <K> the key type\n+ * @param <K>   the key type\n  * @param <AGG> the aggregated value type\n  */\n public interface ReadOnlySessionStore<K, AGG> {\n+\n     /**\n-     * Retrieve all aggregated sessions for the provided key.\n+     * Fetch any sessions with the matching key and the sessions end is &ge; earliestSessionEndTime and the sessions\n+     * start is &le; latestSessionStartTime iterating from earliest to latest.\n+     * <p>\n      * This iterator must be closed after use.\n      *\n+     * @param key                    the key to return sessions for\n+     * @param earliestSessionEndTime the end timestamp of the earliest session to search for, where iteration starts.\n+     * @param latestSessionStartTime the end timestamp of the latest session to search for, where iteration ends.\n+     * @return iterator of sessions with the matching key and aggregated values, from earliest to latest session time.\n+     * @throws NullPointerException If null is used for key.\n+     */\n+    default KeyValueIterator<Windowed<K>, AGG> findSessions(final K key,\n+                                                            final long earliestSessionEndTime,\n+                                                            final long latestSessionStartTime) {\n+        throw new UnsupportedOperationException(\"Moved from SessionStore\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76bb9a27fd7a5e58bcfb74c8eca70c295f573d20"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEwOTY2Ng==", "bodyText": "There are a lot of unnecessary whitespace changes in this PR. You don't need to back them all out right now, but in the future, please clean up the diff before submitting a PR. These extra changes make it harder to review.", "url": "https://github.com/apache/kafka/pull/9139#discussion_r501109666", "createdAt": "2020-10-07T15:33:29Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingSessionStore.java", "diffHunk": "@@ -150,22 +149,44 @@ public void remove(final Windowed<Bytes> sessionKey) {\n         validateStoreOpen();\n \n         final PeekingKeyValueIterator<Bytes, LRUCacheEntry> cacheIterator = wrapped().persistent() ?\n-            new CacheIteratorWrapper(key, earliestSessionEndTime, latestSessionStartTime) :\n+            new CacheIteratorWrapper(key, earliestSessionEndTime, latestSessionStartTime, true) :\n             context.cache().range(cacheName,\n-                        cacheFunction.cacheKey(keySchema.lowerRangeFixedSize(key, earliestSessionEndTime)),\n-                        cacheFunction.cacheKey(keySchema.upperRangeFixedSize(key, latestSessionStartTime))\n+                cacheFunction.cacheKey(keySchema.lowerRangeFixedSize(key, earliestSessionEndTime)),\n+                cacheFunction.cacheKey(keySchema.upperRangeFixedSize(key, latestSessionStartTime))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76bb9a27fd7a5e58bcfb74c8eca70c295f573d20"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM1MTQ1Nw==", "bodyText": "The code style discourages inline conditionals. It's more maintainable to always use blocks.", "url": "https://github.com/apache/kafka/pull/9139#discussion_r501351457", "createdAt": "2020-10-07T22:43:26Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/InMemorySessionStore.java", "diffHunk": "@@ -382,9 +479,23 @@ private boolean setInnerIterators() {\n                 currentKey = nextKeyEntry.getKey();\n \n                 if (latestSessionStartTime == Long.MAX_VALUE) {\n-                    recordIterator = nextKeyEntry.getValue().entrySet().iterator();\n+                    final Set<Entry<Long, byte[]>> entries;\n+                    if (forward) entries = nextKeyEntry.getValue().descendingMap().entrySet();\n+                    else entries = nextKeyEntry.getValue().entrySet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e49f258ad78bb75f23481f030d5e7be1db12ce00"}, "originalPosition": 214}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8562422783d83ad5d334155d1bcc6c56cea47d2", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/b8562422783d83ad5d334155d1bcc6c56cea47d2", "committedDate": "2020-10-08T03:36:49Z", "message": "fix formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19324130d62a482b001c0e85b8fe51a0160d10fd", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/19324130d62a482b001c0e85b8fe51a0160d10fd", "committedDate": "2020-10-08T03:41:58Z", "message": "fix formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70484e4a1ffc29f5effc822d1aea54c24730b603", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/70484e4a1ffc29f5effc822d1aea54c24730b603", "committedDate": "2020-10-08T04:12:56Z", "message": "Merge branch 'trunk' into backward-sessionstore"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14fce521346b290407c971e42bd684f55b512785", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/14fce521346b290407c971e42bd684f55b512785", "committedDate": "2020-10-08T04:17:59Z", "message": "fix conflict with trunk"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1088, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}