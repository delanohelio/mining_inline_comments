{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1NDMwMzk1", "number": 8509, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTowNjoxMFrOD0pfOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjoyNDoxNlrOD1HPfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTMyMjgwOnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTowNjoxMVrOGJrw0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMToxNTowMVrOGKMJdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwNzM3Nw==", "bodyText": "This and the two above should use testStopReplicaRequest instead of testUpdateMetadataRequest.", "url": "https://github.com/apache/kafka/pull/8509#discussion_r412807377", "createdAt": "2020-04-22T09:06:11Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -1553,6 +1552,179 @@ class KafkaApisTest {\n     assertEquals(Errors.INVALID_REQUEST, response.error)\n   }\n \n+  @Test\n+  def testUpdateMetadataRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testUpdateMetadataRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val updateMetadataRequest = createBasicMetadataRequest(\"topicA\", 1, brokerEpochInRequest)\n+    val request = buildRequest(updateMetadataRequest)\n+\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.maybeUpdateMetadataCache(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      Seq()\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleUpdateMetadataRequest(request)\n+    val updateMetadataResponse = readResponse(ApiKeys.UPDATE_METADATA, updateMetadataRequest, capturedResponse)\n+      .asInstanceOf[UpdateMetadataResponse]\n+    assertEquals(expectedError, updateMetadataResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testLeaderAndIsrRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val controllerId = 2\n+    val controllerEpoch = 6\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+    val partitionStates = Seq(\n+      new LeaderAndIsrRequestData.LeaderAndIsrPartitionState()\n+        .setTopicName(\"topicW\")\n+        .setPartitionIndex(1)\n+        .setControllerEpoch(1)\n+        .setLeader(0)\n+        .setLeaderEpoch(1)\n+        .setIsr(asList(0, 1))\n+        .setZkVersion(2)\n+        .setReplicas(asList(0, 1, 2))\n+        .setIsNew(false)\n+    ).asJava\n+    val leaderAndIsrRequest = new LeaderAndIsrRequest.Builder(\n+      ApiKeys.LEADER_AND_ISR.latestVersion,\n+      controllerId,\n+      controllerEpoch,\n+      brokerEpochInRequest,\n+      partitionStates,\n+      asList(new Node(0, \"host0\", 9090), new Node(1, \"host1\", 9091))\n+    ).build()\n+    val request = buildRequest(leaderAndIsrRequest)\n+    val response = new LeaderAndIsrResponse(new LeaderAndIsrResponseData()\n+      .setErrorCode(Errors.NONE.code)\n+      .setPartitionErrors(asList()))\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.becomeLeaderOrFollower(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject(),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      response\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleLeaderAndIsrRequest(request)\n+    val leaderAndIsrResponse = readResponse(ApiKeys.LEADER_AND_ISR, leaderAndIsrRequest, capturedResponse)\n+      .asInstanceOf[LeaderAndIsrResponse]\n+    assertEquals(expectedError, leaderAndIsrResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8604ede27d47a3a4bd016d70d7a1c7438445a00"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzNzk3Mg==", "bodyText": "thanks for catching this and others below!", "url": "https://github.com/apache/kafka/pull/8509#discussion_r413337972", "createdAt": "2020-04-22T21:15:01Z", "author": {"login": "apovzner"}, "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -1553,6 +1552,179 @@ class KafkaApisTest {\n     assertEquals(Errors.INVALID_REQUEST, response.error)\n   }\n \n+  @Test\n+  def testUpdateMetadataRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testUpdateMetadataRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val updateMetadataRequest = createBasicMetadataRequest(\"topicA\", 1, brokerEpochInRequest)\n+    val request = buildRequest(updateMetadataRequest)\n+\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.maybeUpdateMetadataCache(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      Seq()\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleUpdateMetadataRequest(request)\n+    val updateMetadataResponse = readResponse(ApiKeys.UPDATE_METADATA, updateMetadataRequest, capturedResponse)\n+      .asInstanceOf[UpdateMetadataResponse]\n+    assertEquals(expectedError, updateMetadataResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testLeaderAndIsrRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val controllerId = 2\n+    val controllerEpoch = 6\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+    val partitionStates = Seq(\n+      new LeaderAndIsrRequestData.LeaderAndIsrPartitionState()\n+        .setTopicName(\"topicW\")\n+        .setPartitionIndex(1)\n+        .setControllerEpoch(1)\n+        .setLeader(0)\n+        .setLeaderEpoch(1)\n+        .setIsr(asList(0, 1))\n+        .setZkVersion(2)\n+        .setReplicas(asList(0, 1, 2))\n+        .setIsNew(false)\n+    ).asJava\n+    val leaderAndIsrRequest = new LeaderAndIsrRequest.Builder(\n+      ApiKeys.LEADER_AND_ISR.latestVersion,\n+      controllerId,\n+      controllerEpoch,\n+      brokerEpochInRequest,\n+      partitionStates,\n+      asList(new Node(0, \"host0\", 9090), new Node(1, \"host1\", 9091))\n+    ).build()\n+    val request = buildRequest(leaderAndIsrRequest)\n+    val response = new LeaderAndIsrResponse(new LeaderAndIsrResponseData()\n+      .setErrorCode(Errors.NONE.code)\n+      .setPartitionErrors(asList()))\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.becomeLeaderOrFollower(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject(),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      response\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleLeaderAndIsrRequest(request)\n+    val leaderAndIsrResponse = readResponse(ApiKeys.LEADER_AND_ISR, leaderAndIsrRequest, capturedResponse)\n+      .asInstanceOf[LeaderAndIsrResponse]\n+    assertEquals(expectedError, leaderAndIsrResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwNzM3Nw=="}, "originalCommit": {"oid": "d8604ede27d47a3a4bd016d70d7a1c7438445a00"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTMzMzUyOnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTowODozM1rOGJr3Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTowODozM1rOGJr3Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwOTAxOQ==", "bodyText": "brokerEpoch is not necessary, I suppose.", "url": "https://github.com/apache/kafka/pull/8509#discussion_r412809019", "createdAt": "2020-04-22T09:08:33Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -1553,6 +1552,179 @@ class KafkaApisTest {\n     assertEquals(Errors.INVALID_REQUEST, response.error)\n   }\n \n+  @Test\n+  def testUpdateMetadataRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testUpdateMetadataRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val updateMetadataRequest = createBasicMetadataRequest(\"topicA\", 1, brokerEpochInRequest)\n+    val request = buildRequest(updateMetadataRequest)\n+\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.maybeUpdateMetadataCache(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      Seq()\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleUpdateMetadataRequest(request)\n+    val updateMetadataResponse = readResponse(ApiKeys.UPDATE_METADATA, updateMetadataRequest, capturedResponse)\n+      .asInstanceOf[UpdateMetadataResponse]\n+    assertEquals(expectedError, updateMetadataResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testLeaderAndIsrRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val controllerId = 2\n+    val controllerEpoch = 6\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+    val partitionStates = Seq(\n+      new LeaderAndIsrRequestData.LeaderAndIsrPartitionState()\n+        .setTopicName(\"topicW\")\n+        .setPartitionIndex(1)\n+        .setControllerEpoch(1)\n+        .setLeader(0)\n+        .setLeaderEpoch(1)\n+        .setIsr(asList(0, 1))\n+        .setZkVersion(2)\n+        .setReplicas(asList(0, 1, 2))\n+        .setIsNew(false)\n+    ).asJava\n+    val leaderAndIsrRequest = new LeaderAndIsrRequest.Builder(\n+      ApiKeys.LEADER_AND_ISR.latestVersion,\n+      controllerId,\n+      controllerEpoch,\n+      brokerEpochInRequest,\n+      partitionStates,\n+      asList(new Node(0, \"host0\", 9090), new Node(1, \"host1\", 9091))\n+    ).build()\n+    val request = buildRequest(leaderAndIsrRequest)\n+    val response = new LeaderAndIsrResponse(new LeaderAndIsrResponseData()\n+      .setErrorCode(Errors.NONE.code)\n+      .setPartitionErrors(asList()))\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.becomeLeaderOrFollower(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject(),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      response\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleLeaderAndIsrRequest(request)\n+    val leaderAndIsrResponse = readResponse(ApiKeys.LEADER_AND_ISR, leaderAndIsrRequest, capturedResponse)\n+      .asInstanceOf[LeaderAndIsrResponse]\n+    assertEquals(expectedError, leaderAndIsrResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testStopReplicaRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val controllerId = 0\n+    val controllerEpoch = 5\n+    val brokerEpoch = 230498320L", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8604ede27d47a3a4bd016d70d7a1c7438445a00"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NTMzNjQ1OnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTowOTowOVrOGJr48A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTowOTowOVrOGJr48A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwOTQ1Ng==", "bodyText": "This should rely on brokerEpochInRequest.", "url": "https://github.com/apache/kafka/pull/8509#discussion_r412809456", "createdAt": "2020-04-22T09:09:09Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -1553,6 +1552,179 @@ class KafkaApisTest {\n     assertEquals(Errors.INVALID_REQUEST, response.error)\n   }\n \n+  @Test\n+  def testUpdateMetadataRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testUpdateMetadataRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val updateMetadataRequest = createBasicMetadataRequest(\"topicA\", 1, brokerEpochInRequest)\n+    val request = buildRequest(updateMetadataRequest)\n+\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.maybeUpdateMetadataCache(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      Seq()\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleUpdateMetadataRequest(request)\n+    val updateMetadataResponse = readResponse(ApiKeys.UPDATE_METADATA, updateMetadataRequest, capturedResponse)\n+      .asInstanceOf[UpdateMetadataResponse]\n+    assertEquals(expectedError, updateMetadataResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testLeaderAndIsrRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val controllerId = 2\n+    val controllerEpoch = 6\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+    val partitionStates = Seq(\n+      new LeaderAndIsrRequestData.LeaderAndIsrPartitionState()\n+        .setTopicName(\"topicW\")\n+        .setPartitionIndex(1)\n+        .setControllerEpoch(1)\n+        .setLeader(0)\n+        .setLeaderEpoch(1)\n+        .setIsr(asList(0, 1))\n+        .setZkVersion(2)\n+        .setReplicas(asList(0, 1, 2))\n+        .setIsNew(false)\n+    ).asJava\n+    val leaderAndIsrRequest = new LeaderAndIsrRequest.Builder(\n+      ApiKeys.LEADER_AND_ISR.latestVersion,\n+      controllerId,\n+      controllerEpoch,\n+      brokerEpochInRequest,\n+      partitionStates,\n+      asList(new Node(0, \"host0\", 9090), new Node(1, \"host1\", 9091))\n+    ).build()\n+    val request = buildRequest(leaderAndIsrRequest)\n+    val response = new LeaderAndIsrResponse(new LeaderAndIsrResponseData()\n+      .setErrorCode(Errors.NONE.code)\n+      .setPartitionErrors(asList()))\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.becomeLeaderOrFollower(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject(),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      response\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleLeaderAndIsrRequest(request)\n+    val leaderAndIsrResponse = readResponse(ApiKeys.LEADER_AND_ISR, leaderAndIsrRequest, capturedResponse)\n+      .asInstanceOf[LeaderAndIsrResponse]\n+    assertEquals(expectedError, leaderAndIsrResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testStopReplicaRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val controllerId = 0\n+    val controllerEpoch = 5\n+    val brokerEpoch = 230498320L\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+    val fooPartition = new TopicPartition(\"foo\", 0)\n+    val topicStates = Seq(\n+      new StopReplicaTopicState()\n+        .setTopicName(fooPartition.topic())\n+        .setPartitionStates(Seq(new StopReplicaPartitionState()\n+          .setPartitionIndex(fooPartition.partition())\n+          .setLeaderEpoch(1)\n+          .setDeletePartition(false)).asJava)\n+    ).asJava\n+    val stopReplicaRequest = new StopReplicaRequest.Builder(\n+      ApiKeys.STOP_REPLICA.latestVersion,\n+      controllerId,\n+      controllerEpoch,\n+      brokerEpochInRequest,\n+      false,\n+      topicStates\n+    ).build()\n+    val request = buildRequest(stopReplicaRequest)\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.stopReplicas(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.eq(controllerId),\n+      EasyMock.eq(controllerEpoch),\n+      EasyMock.eq(brokerEpoch + 1),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8604ede27d47a3a4bd016d70d7a1c7438445a00"}, "originalPosition": 214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2NzE2NjI4OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNTozNzozMFrOGJ9E3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNTozNzozMFrOGJ9E3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5MTAzNw==", "bodyText": "Short comment here may be helpful about the case where the controller sees the epoch bump first.", "url": "https://github.com/apache/kafka/pull/8509#discussion_r413091037", "createdAt": "2020-04-22T15:37:30Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -3084,12 +3084,7 @@ class KafkaApis(val requestChannel: RequestChannel,\n     // Broker epoch in LeaderAndIsr/UpdateMetadata/StopReplica request is unknown\n     // if the controller hasn't been upgraded to use KIP-380\n     if (brokerEpochInRequest == AbstractControlRequest.UNKNOWN_BROKER_EPOCH) false\n-    else {\n-      val curBrokerEpoch = controller.brokerEpoch\n-      if (brokerEpochInRequest < curBrokerEpoch) true\n-      else if (brokerEpochInRequest == curBrokerEpoch) false\n-      else throw new IllegalStateException(s\"Epoch $brokerEpochInRequest larger than current broker epoch $curBrokerEpoch\")\n-    }\n+    else brokerEpochInRequest < controller.brokerEpoch", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8604ede27d47a3a4bd016d70d7a1c7438445a00"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MDE5Nzc1OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjoyNDoxNlrOGKYjOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjoyNDoxNlrOGKYjOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0MTE3Nw==", "bodyText": "nit: Alignment of the comment looks a bit weird. I would align it with the if/else.", "url": "https://github.com/apache/kafka/pull/8509#discussion_r413541177", "createdAt": "2020-04-23T06:24:16Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -3084,12 +3084,9 @@ class KafkaApis(val requestChannel: RequestChannel,\n     // Broker epoch in LeaderAndIsr/UpdateMetadata/StopReplica request is unknown\n     // if the controller hasn't been upgraded to use KIP-380\n     if (brokerEpochInRequest == AbstractControlRequest.UNKNOWN_BROKER_EPOCH) false\n-    else {\n-      val curBrokerEpoch = controller.brokerEpoch\n-      if (brokerEpochInRequest < curBrokerEpoch) true\n-      else if (brokerEpochInRequest == curBrokerEpoch) false\n-      else throw new IllegalStateException(s\"Epoch $brokerEpochInRequest larger than current broker epoch $curBrokerEpoch\")\n-    }\n+      // brokerEpochInRequest > controller.brokerEpoch is possible in rare scenarios where the controller gets notified\n+      // about the new broker epoch and sends a control request with this epoch before the broker learns about it", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "062c787a6a34246ac25026ebb6d3cfeec3515d20"}, "originalPosition": 11}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3035, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}