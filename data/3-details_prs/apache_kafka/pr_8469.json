{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyMjcyNjc0", "number": 8469, "title": "[KAFKA-9826] Handle an unaligned first dirty offset during log cleaning.", "bodyText": "What\nIn KAFKA-9826, a log whose first dirty offset was past the start of the active segment and past the last cleaned point resulted in an endless cycle of picking the segment to clean and discarding it. Though this didn't interfere with cleaning other log segments, it kept the log cleaner thread continuously busy (potentially wasting CPU and impacting other running threads) and filled the logs with lots of extraneous messages.\nThis was determined to be because the active segment was getting mistakenly picked for cleaning, and because the logSegments code handles (start == end) cases only for (start, end) on a segment boundary: the intent is to return a null list, but if they're not on a segment boundary, the routine returns that segment.\nThis fix has two parts:\n\nIt changes logSegments to handle start==end by returning an empty List always.\nIt changes the definition of calculateCleanableBytes to not consider anything past the UncleanableOffset; previously, it would potentially shift the UncleanableOffset to match the firstDirtyOffset even if the firstDirtyOffset was past the firstUncleanableOffset. This has no real effect now in the context of the fix for (1) but it makes the code read more like the model that the code is attempting to follow.\n\nThese changes require modifications to a few test cases that handled this particular test case; they were introduced in the context of KAFKA-8764. Those situations are now handled elsewhere in code, but the tests themselves allowed a DirtyOffset in the active segment, and expected an active segment to be selected for cleaning.\nAn additional unit test for the logSegments call is added.\nSummary of testing strategy (including rationale)\nfor the feature or bug fix. Unit and/or integration\ntests are expected for any behaviour change and\nsystem tests should be considered for larger changes.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-04-12T01:44:51Z", "url": "https://github.com/apache/kafka/pull/8469", "merged": true, "mergeCommit": {"oid": "b8c292c36187d3feda8ae0ce22d58604115b8507"}, "closed": true, "closedAt": "2020-04-15T05:27:51Z", "author": {"login": "steverod"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcVHGgYAH2gAyNDAyMjcyNjc0OjdhNDFhNDU5OWIyNDIyMmFiNDZkMDhjMWVmYjc5ZjM2MjM1ZmI5YTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcXtDIGgFqTM5MzM4NDAzNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7a41a4599b24222ab46d08c1efb79f36235fb9a2", "author": {"user": {"login": "steverod", "name": "Steve Rodrigues"}}, "url": "https://github.com/apache/kafka/commit/7a41a4599b24222ab46d08c1efb79f36235fb9a2", "committedDate": "2020-04-06T23:14:56Z", "message": "KAFKA-9826: LogSegments(A, A) can return a non-empty list if A isn't a segment base offset.\n\nEnsure that logSegments(A, A) returns an empty list in this case.\nAdd a test case for the logSegments call.\n\nAdjust some log cleaner tests because when the first dirty offset is in the active\nsegment, no segment is filthy."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9c1dc6495a6d5cbcc38cdb05b5cb8d86c48852f", "author": {"user": {"login": "steverod", "name": "Steve Rodrigues"}}, "url": "https://github.com/apache/kafka/commit/c9c1dc6495a6d5cbcc38cdb05b5cb8d86c48852f", "committedDate": "2020-04-06T23:59:16Z", "message": "KAFKA-9826: Don't consider dirty bytes past the uncleanable point as cleanable.\n\nIn LogToClean::calculateCleanableBytes the cleanableBytes calculation would adjust the endpoint\nto the firstDirtyOffset even if it was past the first uncleanable offset. Instead,\nlimit the dirty bytes calculation to not go past the first uncleanable offset."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNTI4ODY3", "url": "https://github.com/apache/kafka/pull/8469#pullrequestreview-392528867", "createdAt": "2020-04-14T00:38:44Z", "commit": {"oid": "c9c1dc6495a6d5cbcc38cdb05b5cb8d86c48852f"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDozODo0NVrOGE6C8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDozOToxNVrOGE6Dlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5ODUxNA==", "bodyText": "While you are here, it's probably better to consistently throw IllegalArgumentException if from > to. Currently, we only throw IllegalArgumentException if we get into this path.", "url": "https://github.com/apache/kafka/pull/8469#discussion_r407798514", "createdAt": "2020-04-14T00:38:45Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -2132,17 +2132,23 @@ class Log(@volatile private var _dir: File,\n \n   /**\n    * Get all segments beginning with the segment that includes \"from\" and ending with the segment\n-   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset)\n+   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset).\n+   *\n    */\n   def logSegments(from: Long, to: Long): Iterable[LogSegment] = {\n-    lock synchronized {\n-      val view = Option(segments.floorKey(from)).map { floor =>\n-        if (to < floor)\n-          throw new IllegalArgumentException(s\"Invalid log segment range: requested segments in $topicPartition \" +\n-            s\"from offset $from mapping to segment with base offset $floor, which is greater than limit offset $to\")\n-        segments.subMap(floor, to)\n-      }.getOrElse(segments.headMap(to))\n-      view.values.asScala\n+    if (from == to) {\n+      // Handle non-segment-aligned empty sets\n+      List.empty[LogSegment]\n+    } else {\n+      lock synchronized {\n+        val view = Option(segments.floorKey(from)).map { floor =>\n+          if (to < floor)\n+            throw new IllegalArgumentException(s\"Invalid log segment range: requested segments in $topicPartition \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9c1dc6495a6d5cbcc38cdb05b5cb8d86c48852f"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5ODY3OQ==", "bodyText": "Do we need to add a new line?", "url": "https://github.com/apache/kafka/pull/8469#discussion_r407798679", "createdAt": "2020-04-14T00:39:15Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -2132,17 +2132,23 @@ class Log(@volatile private var _dir: File,\n \n   /**\n    * Get all segments beginning with the segment that includes \"from\" and ending with the segment\n-   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset)\n+   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset).\n+   *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9c1dc6495a6d5cbcc38cdb05b5cb8d86c48852f"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b4d9456028c544c9a2e899f4d2ac10e2cc2b7d8c", "author": {"user": {"login": "steverod", "name": "Steve Rodrigues"}}, "url": "https://github.com/apache/kafka/commit/b4d9456028c544c9a2e899f4d2ac10e2cc2b7d8c", "committedDate": "2020-04-14T02:44:27Z", "message": "Review feedback: Add a check for from < to (not just floor < to)."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNTg0OTk5", "url": "https://github.com/apache/kafka/pull/8469#pullrequestreview-392584999", "createdAt": "2020-04-14T03:48:26Z", "commit": {"oid": "b4d9456028c544c9a2e899f4d2ac10e2cc2b7d8c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMzo0ODoyN1rOGE9K7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMzo0ODoyN1rOGE9K7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0OTcwOQ==", "bodyText": "Do we still need this given the test in line 2141?", "url": "https://github.com/apache/kafka/pull/8469#discussion_r407849709", "createdAt": "2020-04-14T03:48:27Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -2132,17 +2132,25 @@ class Log(@volatile private var _dir: File,\n \n   /**\n    * Get all segments beginning with the segment that includes \"from\" and ending with the segment\n-   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset)\n+   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset).\n    */\n   def logSegments(from: Long, to: Long): Iterable[LogSegment] = {\n-    lock synchronized {\n-      val view = Option(segments.floorKey(from)).map { floor =>\n-        if (to < floor)\n-          throw new IllegalArgumentException(s\"Invalid log segment range: requested segments in $topicPartition \" +\n-            s\"from offset $from mapping to segment with base offset $floor, which is greater than limit offset $to\")\n-        segments.subMap(floor, to)\n-      }.getOrElse(segments.headMap(to))\n-      view.values.asScala\n+    if (from == to) {\n+      // Handle non-segment-aligned empty sets\n+      List.empty[LogSegment]\n+    } else if (to < from) {\n+      throw new IllegalArgumentException(s\"Invalid log segment range: requested segments in $topicPartition \" +\n+        s\"from offset $from which is greater than limit offset $to\")\n+    } else {\n+      lock synchronized {\n+        val view = Option(segments.floorKey(from)).map { floor =>\n+          if (to < floor)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4d9456028c544c9a2e899f4d2ac10e2cc2b7d8c"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac53a2a21dd631c0c65c686b7dbc7cb24a559c95", "author": {"user": {"login": "steverod", "name": "Steve Rodrigues"}}, "url": "https://github.com/apache/kafka/commit/ac53a2a21dd631c0c65c686b7dbc7cb24a559c95", "committedDate": "2020-04-14T20:24:36Z", "message": "Remove extraneous check. Since we already validate from < to, floor(from) < to always."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzg0MDM1", "url": "https://github.com/apache/kafka/pull/8469#pullrequestreview-393384035", "createdAt": "2020-04-15T00:35:29Z", "commit": {"oid": "ac53a2a21dd631c0c65c686b7dbc7cb24a559c95"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1477, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}