{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1MTY1MzM3", "number": 8755, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNTozNjoxOVrOEA8KOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwODo1Njo0OFrOEBp-QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDIxMTE1OnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNTozNjoxOVrOGch3Ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNTo0MjozOFrOGciGmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2ODE0Ng==", "bodyText": "I think we should assert that the \"predicate\" and \"negate\" config were the implicit ones and not the ones defined by HasDuplicateConfigTransformation. I guess we could do this by having HasDuplicateConfigTransformation's configs use different types (\"negate is BOOLEAN in both) and then asserting the expected types.", "url": "https://github.com/apache/kafka/pull/8755#discussion_r432568146", "createdAt": "2020-05-29T15:36:19Z", "author": {"login": "tombentley"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "diffHunk": "@@ -434,5 +436,56 @@ public void configure(Map<String, ?> configs) {\n         }\n     }\n \n+    @Test\n+    public void testConfigDefOverrideByInitialConfigDef() {\n+        String alias = \"hdt\";\n+        String prefix = ConnectorConfig.TRANSFORMS_CONFIG + \".\" + alias + \".\";\n+        Map<String, String> props = new HashMap<>();\n+        props.put(ConnectorConfig.TRANSFORMS_CONFIG, alias);\n+        props.put(prefix + \"type\", HasDuplicateConfigTransformation.class.getName());\n+        ConfigDef def = ConnectorConfig.enrich(MOCK_PLUGINS,\n+                new ConfigDef(),\n+                props,\n+                false);\n+        Arrays.asList(PredicatedTransformation.PREDICATE_CONFIG,\n+                PredicatedTransformation.NEGATE_CONFIG,\n+                HasDuplicateConfigTransformation.MUST_EXIST_KEY)\n+                .forEach(key -> {\n+                    Assert.assertNotNull(def.configKeys().get(prefix + key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU3MjA1OA==", "bodyText": "will roger that", "url": "https://github.com/apache/kafka/pull/8755#discussion_r432572058", "createdAt": "2020-05-29T15:42:38Z", "author": {"login": "chia7712"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "diffHunk": "@@ -434,5 +436,56 @@ public void configure(Map<String, ?> configs) {\n         }\n     }\n \n+    @Test\n+    public void testConfigDefOverrideByInitialConfigDef() {\n+        String alias = \"hdt\";\n+        String prefix = ConnectorConfig.TRANSFORMS_CONFIG + \".\" + alias + \".\";\n+        Map<String, String> props = new HashMap<>();\n+        props.put(ConnectorConfig.TRANSFORMS_CONFIG, alias);\n+        props.put(prefix + \"type\", HasDuplicateConfigTransformation.class.getName());\n+        ConfigDef def = ConnectorConfig.enrich(MOCK_PLUGINS,\n+                new ConfigDef(),\n+                props,\n+                false);\n+        Arrays.asList(PredicatedTransformation.PREDICATE_CONFIG,\n+                PredicatedTransformation.NEGATE_CONFIG,\n+                HasDuplicateConfigTransformation.MUST_EXIST_KEY)\n+                .forEach(key -> {\n+                    Assert.assertNotNull(def.configKeys().get(prefix + key));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjU2ODE0Ng=="}, "originalCommit": null, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDQzMTE3OnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNjozODoxOVrOGckEmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNjozODoxOVrOGckEmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYwNDMxNQ==", "bodyText": "There are already static imports for some Assert methods, so no reason not to make assertNull and assertNotNull static imports too.\nAnd I don't think the asList()/forEach() are really providing much benefit here. It would be clearer if you factored out a method:\n        assertNotNull(def.configKeys().get(prefix + HasDuplicateConfigTransformation.MUST_EXIST_KEY));\n        assertNull(def.configKeys().get(HasDuplicateConfigTransformation.MUST_EXIST_KEY));\n        assertImplicitConfigDef(def, prefix, PredicatedTransformation.PREDICATE_CONFIG, ConfigDef.Type.STRING);\n        assertImplicitConfigDef(def, prefix, PredicatedTransformation.NEGATE_CONFIG, ConfigDef.Type.BOOLEAN);\n    }\n\n    private void assertImplicitConfigDef(ConfigDef def, String prefix, String keyName, ConfigDef.Type expectedType) {\n        assertNull(def.configKeys().get(keyName));\n        ConfigDef.ConfigKey configKey = def.configKeys().get(prefix + keyName);\n        assertNotNull(\"Implicit '\" + prefix + keyName + \"' config must be present\", configKey);\n        assertEquals(\"Implicit '\" + prefix + keyName + \"' config should be a \" + expectedType,\n                expectedType, configKey.type);\n    }", "url": "https://github.com/apache/kafka/pull/8755#discussion_r432604315", "createdAt": "2020-05-29T16:38:19Z", "author": {"login": "tombentley"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "diffHunk": "@@ -434,5 +436,63 @@ public void configure(Map<String, ?> configs) {\n         }\n     }\n \n+    @Test\n+    public void testConfigDefOverrideByInitialConfigDef() {\n+        String alias = \"hdt\";\n+        String prefix = ConnectorConfig.TRANSFORMS_CONFIG + \".\" + alias + \".\";\n+        Map<String, String> props = new HashMap<>();\n+        props.put(ConnectorConfig.TRANSFORMS_CONFIG, alias);\n+        props.put(prefix + \"type\", HasDuplicateConfigTransformation.class.getName());\n+        ConfigDef def = ConnectorConfig.enrich(MOCK_PLUGINS,\n+                new ConfigDef(),\n+                props,\n+                false);\n+\n+        Arrays.asList(PredicatedTransformation.PREDICATE_CONFIG,\n+                PredicatedTransformation.NEGATE_CONFIG,\n+                HasDuplicateConfigTransformation.MUST_EXIST_KEY)\n+                .forEach(key -> {\n+                    Assert.assertNotNull(def.configKeys().get(prefix + key));\n+                    Assert.assertNull(def.configKeys().get(key));\n+                });\n+\n+        Arrays.asList(PredicatedTransformation.PREDICATE_CONFIG,\n+                PredicatedTransformation.NEGATE_CONFIG)\n+                .forEach(key -> Assert.assertNotEquals(\n+                        HasDuplicateConfigTransformation.CONFIG_DEF.configKeys().get(key).type,\n+                        def.configKeys().get(prefix + key).type));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTcyMzExOnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwNDoyNjowOFrOGcwkjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQwNDoyNjowOFrOGcwkjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgwOTEwMA==", "bodyText": "@tombentley Thanks for your reviews! I have addressed ur comment.", "url": "https://github.com/apache/kafka/pull/8755#discussion_r432809100", "createdAt": "2020-05-30T04:26:08Z", "author": {"login": "chia7712"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "diffHunk": "@@ -434,5 +436,59 @@ public void configure(Map<String, ?> configs) {\n         }\n     }\n \n+    @Test\n+    public void testConfigDefOverrideByInitialConfigDef() {\n+        String alias = \"hdt\";\n+        String prefix = ConnectorConfig.TRANSFORMS_CONFIG + \".\" + alias + \".\";\n+        Map<String, String> props = new HashMap<>();\n+        props.put(ConnectorConfig.TRANSFORMS_CONFIG, alias);\n+        props.put(prefix + \"type\", HasDuplicateConfigTransformation.class.getName());\n+        ConfigDef def = ConnectorConfig.enrich(MOCK_PLUGINS,\n+                new ConfigDef(),\n+                props,\n+                false);\n+        assertConfigDef(def, prefix, HasDuplicateConfigTransformation.MUST_EXIST_KEY, ConfigDef.Type.BOOLEAN);\n+        assertConfigDef(def, prefix, PredicatedTransformation.PREDICATE_CONFIG, ConfigDef.Type.STRING);\n+        assertConfigDef(def, prefix, PredicatedTransformation.NEGATE_CONFIG, ConfigDef.Type.BOOLEAN);\n+    }\n+\n+    private static void assertConfigDef(ConfigDef def, String prefix, String keyName, ConfigDef.Type expectedType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDUzODIzOnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzoxODowOFrOGddE6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzoxODowOFrOGddE6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUzODI4MA==", "bodyText": "nit: extra blank line", "url": "https://github.com/apache/kafka/pull/8755#discussion_r433538280", "createdAt": "2020-06-01T23:18:08Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "diffHunk": "@@ -434,5 +436,59 @@ public void configure(Map<String, ?> configs) {\n         }\n     }\n \n+    @Test\n+    public void testConfigDefOverrideByInitialConfigDef() {\n+        String alias = \"hdt\";\n+        String prefix = ConnectorConfig.TRANSFORMS_CONFIG + \".\" + alias + \".\";\n+        Map<String, String> props = new HashMap<>();\n+        props.put(ConnectorConfig.TRANSFORMS_CONFIG, alias);\n+        props.put(prefix + \"type\", HasDuplicateConfigTransformation.class.getName());\n+        ConfigDef def = ConnectorConfig.enrich(MOCK_PLUGINS,\n+                new ConfigDef(),\n+                props,\n+                false);\n+        assertConfigDef(def, prefix, HasDuplicateConfigTransformation.MUST_EXIST_KEY, ConfigDef.Type.BOOLEAN);\n+        assertConfigDef(def, prefix, PredicatedTransformation.PREDICATE_CONFIG, ConfigDef.Type.STRING);\n+        assertConfigDef(def, prefix, PredicatedTransformation.NEGATE_CONFIG, ConfigDef.Type.BOOLEAN);\n+    }\n+\n+    private static void assertConfigDef(ConfigDef def, String prefix, String keyName, ConfigDef.Type expectedType) {\n+        assertNull(def.configKeys().get(keyName));\n+        ConfigDef.ConfigKey configKey = def.configKeys().get(prefix + keyName);\n+        assertNotNull(prefix + keyName + \"' config must be present\", configKey);\n+        assertEquals(prefix + keyName + \"' config should be a \" + expectedType, expectedType, configKey.type);\n+    }\n+\n+    public static class HasDuplicateConfigTransformation<R extends ConnectRecord<R>> implements Transformation<R> {\n+        private static final String MUST_EXIST_KEY = \"must.exist.key\";\n+        private static final ConfigDef CONFIG_DEF = new ConfigDef()\n+                // this configDef is duplicate. It should be removed automatically so as to avoid duplicate config error.\n+                .define(PredicatedTransformation.PREDICATE_CONFIG, ConfigDef.Type.INT, 100, ConfigDef.Importance.MEDIUM,\n+                        \"fake\")\n+                // this configDef is duplicate. It should be removed automatically so as to avoid duplicate config error.\n+                .define(PredicatedTransformation.NEGATE_CONFIG, ConfigDef.Type.INT, 123, ConfigDef.Importance.MEDIUM,\n+                        \"fake\")\n+                // this configDef should appear if above duplicate configDef is removed without any error\n+                .define(MUST_EXIST_KEY, ConfigDef.Type.BOOLEAN, true, ConfigDef.Importance.MEDIUM,\n+                        \"this key must exist\");\n+        @Override\n+        public R apply(R record) {\n+            return record;\n+        }\n+\n+        @Override\n+        public ConfigDef config() {\n+            return CONFIG_DEF;\n+        }\n+\n+        @Override\n+        public void close() {\n+        }\n+\n+        @Override\n+        public void configure(Map<String, ?> configs) {\n+        }\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDUzODQ5OnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzoxODoyMVrOGddFFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzoxODoyMVrOGddFFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUzODMyNg==", "bodyText": "nit: blank line missing here", "url": "https://github.com/apache/kafka/pull/8755#discussion_r433538326", "createdAt": "2020-06-01T23:18:21Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "diffHunk": "@@ -434,5 +436,59 @@ public void configure(Map<String, ?> configs) {\n         }\n     }\n \n+    @Test\n+    public void testConfigDefOverrideByInitialConfigDef() {\n+        String alias = \"hdt\";\n+        String prefix = ConnectorConfig.TRANSFORMS_CONFIG + \".\" + alias + \".\";\n+        Map<String, String> props = new HashMap<>();\n+        props.put(ConnectorConfig.TRANSFORMS_CONFIG, alias);\n+        props.put(prefix + \"type\", HasDuplicateConfigTransformation.class.getName());\n+        ConfigDef def = ConnectorConfig.enrich(MOCK_PLUGINS,\n+                new ConfigDef(),\n+                props,\n+                false);\n+        assertConfigDef(def, prefix, HasDuplicateConfigTransformation.MUST_EXIST_KEY, ConfigDef.Type.BOOLEAN);\n+        assertConfigDef(def, prefix, PredicatedTransformation.PREDICATE_CONFIG, ConfigDef.Type.STRING);\n+        assertConfigDef(def, prefix, PredicatedTransformation.NEGATE_CONFIG, ConfigDef.Type.BOOLEAN);\n+    }\n+\n+    private static void assertConfigDef(ConfigDef def, String prefix, String keyName, ConfigDef.Type expectedType) {\n+        assertNull(def.configKeys().get(keyName));\n+        ConfigDef.ConfigKey configKey = def.configKeys().get(prefix + keyName);\n+        assertNotNull(prefix + keyName + \"' config must be present\", configKey);\n+        assertEquals(prefix + keyName + \"' config should be a \" + expectedType, expectedType, configKey.type);\n+    }\n+\n+    public static class HasDuplicateConfigTransformation<R extends ConnectRecord<R>> implements Transformation<R> {\n+        private static final String MUST_EXIST_KEY = \"must.exist.key\";\n+        private static final ConfigDef CONFIG_DEF = new ConfigDef()\n+                // this configDef is duplicate. It should be removed automatically so as to avoid duplicate config error.\n+                .define(PredicatedTransformation.PREDICATE_CONFIG, ConfigDef.Type.INT, 100, ConfigDef.Importance.MEDIUM,\n+                        \"fake\")\n+                // this configDef is duplicate. It should be removed automatically so as to avoid duplicate config error.\n+                .define(PredicatedTransformation.NEGATE_CONFIG, ConfigDef.Type.INT, 123, ConfigDef.Importance.MEDIUM,\n+                        \"fake\")\n+                // this configDef should appear if above duplicate configDef is removed without any error\n+                .define(MUST_EXIST_KEY, ConfigDef.Type.BOOLEAN, true, ConfigDef.Importance.MEDIUM,\n+                        \"this key must exist\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDUzOTE5OnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzoxODo1MlrOGddFlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzoxODo1MlrOGddFlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUzODQ1Mw==", "bodyText": "nit: I'm sure these fit in a line shorter than the one below", "url": "https://github.com/apache/kafka/pull/8755#discussion_r433538453", "createdAt": "2020-06-01T23:18:52Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "diffHunk": "@@ -434,5 +436,59 @@ public void configure(Map<String, ?> configs) {\n         }\n     }\n \n+    @Test\n+    public void testConfigDefOverrideByInitialConfigDef() {\n+        String alias = \"hdt\";\n+        String prefix = ConnectorConfig.TRANSFORMS_CONFIG + \".\" + alias + \".\";\n+        Map<String, String> props = new HashMap<>();\n+        props.put(ConnectorConfig.TRANSFORMS_CONFIG, alias);\n+        props.put(prefix + \"type\", HasDuplicateConfigTransformation.class.getName());\n+        ConfigDef def = ConnectorConfig.enrich(MOCK_PLUGINS,\n+                new ConfigDef(),\n+                props,\n+                false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDU1NjkzOnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzoyODo1MFrOGddQhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzoyODo1MFrOGddQhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0MTI1Mw==", "bodyText": "this method won't work with empty prefix but that's not obvious just by reading its name.", "url": "https://github.com/apache/kafka/pull/8755#discussion_r433541253", "createdAt": "2020-06-01T23:28:50Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "diffHunk": "@@ -434,5 +436,59 @@ public void configure(Map<String, ?> configs) {\n         }\n     }\n \n+    @Test\n+    public void testConfigDefOverrideByInitialConfigDef() {\n+        String alias = \"hdt\";\n+        String prefix = ConnectorConfig.TRANSFORMS_CONFIG + \".\" + alias + \".\";\n+        Map<String, String> props = new HashMap<>();\n+        props.put(ConnectorConfig.TRANSFORMS_CONFIG, alias);\n+        props.put(prefix + \"type\", HasDuplicateConfigTransformation.class.getName());\n+        ConfigDef def = ConnectorConfig.enrich(MOCK_PLUGINS,\n+                new ConfigDef(),\n+                props,\n+                false);\n+        assertConfigDef(def, prefix, HasDuplicateConfigTransformation.MUST_EXIST_KEY, ConfigDef.Type.BOOLEAN);\n+        assertConfigDef(def, prefix, PredicatedTransformation.PREDICATE_CONFIG, ConfigDef.Type.STRING);\n+        assertConfigDef(def, prefix, PredicatedTransformation.NEGATE_CONFIG, ConfigDef.Type.BOOLEAN);\n+    }\n+\n+    private static void assertConfigDef(ConfigDef def, String prefix, String keyName, ConfigDef.Type expectedType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDU4MTU3OnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzo0MzowOFrOGddf0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzo0MzowOFrOGddf0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0NTE2OQ==", "bodyText": "let's add ConfigDef.NO_DEFAULT_VALUE in one of them", "url": "https://github.com/apache/kafka/pull/8755#discussion_r433545169", "createdAt": "2020-06-01T23:43:08Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "diffHunk": "@@ -434,5 +436,59 @@ public void configure(Map<String, ?> configs) {\n         }\n     }\n \n+    @Test\n+    public void testConfigDefOverrideByInitialConfigDef() {\n+        String alias = \"hdt\";\n+        String prefix = ConnectorConfig.TRANSFORMS_CONFIG + \".\" + alias + \".\";\n+        Map<String, String> props = new HashMap<>();\n+        props.put(ConnectorConfig.TRANSFORMS_CONFIG, alias);\n+        props.put(prefix + \"type\", HasDuplicateConfigTransformation.class.getName());\n+        ConfigDef def = ConnectorConfig.enrich(MOCK_PLUGINS,\n+                new ConfigDef(),\n+                props,\n+                false);\n+        assertConfigDef(def, prefix, HasDuplicateConfigTransformation.MUST_EXIST_KEY, ConfigDef.Type.BOOLEAN);\n+        assertConfigDef(def, prefix, PredicatedTransformation.PREDICATE_CONFIG, ConfigDef.Type.STRING);\n+        assertConfigDef(def, prefix, PredicatedTransformation.NEGATE_CONFIG, ConfigDef.Type.BOOLEAN);\n+    }\n+\n+    private static void assertConfigDef(ConfigDef def, String prefix, String keyName, ConfigDef.Type expectedType) {\n+        assertNull(def.configKeys().get(keyName));\n+        ConfigDef.ConfigKey configKey = def.configKeys().get(prefix + keyName);\n+        assertNotNull(prefix + keyName + \"' config must be present\", configKey);\n+        assertEquals(prefix + keyName + \"' config should be a \" + expectedType, expectedType, configKey.type);\n+    }\n+\n+    public static class HasDuplicateConfigTransformation<R extends ConnectRecord<R>> implements Transformation<R> {\n+        private static final String MUST_EXIST_KEY = \"must.exist.key\";\n+        private static final ConfigDef CONFIG_DEF = new ConfigDef()\n+                // this configDef is duplicate. It should be removed automatically so as to avoid duplicate config error.\n+                .define(PredicatedTransformation.PREDICATE_CONFIG, ConfigDef.Type.INT, 100, ConfigDef.Importance.MEDIUM,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDU4MTk1OnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzo0MzoyMVrOGddgFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzo0MzoyMVrOGddgFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0NTIzNg==", "bodyText": "nit: fits in one line", "url": "https://github.com/apache/kafka/pull/8755#discussion_r433545236", "createdAt": "2020-06-01T23:43:21Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "diffHunk": "@@ -434,5 +436,59 @@ public void configure(Map<String, ?> configs) {\n         }\n     }\n \n+    @Test\n+    public void testConfigDefOverrideByInitialConfigDef() {\n+        String alias = \"hdt\";\n+        String prefix = ConnectorConfig.TRANSFORMS_CONFIG + \".\" + alias + \".\";\n+        Map<String, String> props = new HashMap<>();\n+        props.put(ConnectorConfig.TRANSFORMS_CONFIG, alias);\n+        props.put(prefix + \"type\", HasDuplicateConfigTransformation.class.getName());\n+        ConfigDef def = ConnectorConfig.enrich(MOCK_PLUGINS,\n+                new ConfigDef(),\n+                props,\n+                false);\n+        assertConfigDef(def, prefix, HasDuplicateConfigTransformation.MUST_EXIST_KEY, ConfigDef.Type.BOOLEAN);\n+        assertConfigDef(def, prefix, PredicatedTransformation.PREDICATE_CONFIG, ConfigDef.Type.STRING);\n+        assertConfigDef(def, prefix, PredicatedTransformation.NEGATE_CONFIG, ConfigDef.Type.BOOLEAN);\n+    }\n+\n+    private static void assertConfigDef(ConfigDef def, String prefix, String keyName, ConfigDef.Type expectedType) {\n+        assertNull(def.configKeys().get(keyName));\n+        ConfigDef.ConfigKey configKey = def.configKeys().get(prefix + keyName);\n+        assertNotNull(prefix + keyName + \"' config must be present\", configKey);\n+        assertEquals(prefix + keyName + \"' config should be a \" + expectedType, expectedType, configKey.type);\n+    }\n+\n+    public static class HasDuplicateConfigTransformation<R extends ConnectRecord<R>> implements Transformation<R> {\n+        private static final String MUST_EXIST_KEY = \"must.exist.key\";\n+        private static final ConfigDef CONFIG_DEF = new ConfigDef()\n+                // this configDef is duplicate. It should be removed automatically so as to avoid duplicate config error.\n+                .define(PredicatedTransformation.PREDICATE_CONFIG, ConfigDef.Type.INT, 100, ConfigDef.Importance.MEDIUM,\n+                        \"fake\")\n+                // this configDef is duplicate. It should be removed automatically so as to avoid duplicate config error.\n+                .define(PredicatedTransformation.NEGATE_CONFIG, ConfigDef.Type.INT, 123, ConfigDef.Importance.MEDIUM,\n+                        \"fake\")\n+                // this configDef should appear if above duplicate configDef is removed without any error\n+                .define(MUST_EXIST_KEY, ConfigDef.Type.BOOLEAN, true, ConfigDef.Importance.MEDIUM,\n+                        \"this key must exist\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMDU4MjAwOnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzo0MzoyM1rOGddgGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQyMzo0MzoyM1rOGddgGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0NTI0Mw==", "bodyText": "nit: fits in one line", "url": "https://github.com/apache/kafka/pull/8755#discussion_r433545243", "createdAt": "2020-06-01T23:43:23Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "diffHunk": "@@ -434,5 +436,59 @@ public void configure(Map<String, ?> configs) {\n         }\n     }\n \n+    @Test\n+    public void testConfigDefOverrideByInitialConfigDef() {\n+        String alias = \"hdt\";\n+        String prefix = ConnectorConfig.TRANSFORMS_CONFIG + \".\" + alias + \".\";\n+        Map<String, String> props = new HashMap<>();\n+        props.put(ConnectorConfig.TRANSFORMS_CONFIG, alias);\n+        props.put(prefix + \"type\", HasDuplicateConfigTransformation.class.getName());\n+        ConfigDef def = ConnectorConfig.enrich(MOCK_PLUGINS,\n+                new ConfigDef(),\n+                props,\n+                false);\n+        assertConfigDef(def, prefix, HasDuplicateConfigTransformation.MUST_EXIST_KEY, ConfigDef.Type.BOOLEAN);\n+        assertConfigDef(def, prefix, PredicatedTransformation.PREDICATE_CONFIG, ConfigDef.Type.STRING);\n+        assertConfigDef(def, prefix, PredicatedTransformation.NEGATE_CONFIG, ConfigDef.Type.BOOLEAN);\n+    }\n+\n+    private static void assertConfigDef(ConfigDef def, String prefix, String keyName, ConfigDef.Type expectedType) {\n+        assertNull(def.configKeys().get(keyName));\n+        ConfigDef.ConfigKey configKey = def.configKeys().get(prefix + keyName);\n+        assertNotNull(prefix + keyName + \"' config must be present\", configKey);\n+        assertEquals(prefix + keyName + \"' config should be a \" + expectedType, expectedType, configKey.type);\n+    }\n+\n+    public static class HasDuplicateConfigTransformation<R extends ConnectRecord<R>> implements Transformation<R> {\n+        private static final String MUST_EXIST_KEY = \"must.exist.key\";\n+        private static final ConfigDef CONFIG_DEF = new ConfigDef()\n+                // this configDef is duplicate. It should be removed automatically so as to avoid duplicate config error.\n+                .define(PredicatedTransformation.PREDICATE_CONFIG, ConfigDef.Type.INT, 100, ConfigDef.Importance.MEDIUM,\n+                        \"fake\")\n+                // this configDef is duplicate. It should be removed automatically so as to avoid duplicate config error.\n+                .define(PredicatedTransformation.NEGATE_CONFIG, ConfigDef.Type.INT, 123, ConfigDef.Importance.MEDIUM,\n+                        \"fake\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMTcxNzEyOnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwODo1Njo0OFrOGdobiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwODo1Njo0OFrOGdobiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyNDI5Ng==", "bodyText": "@kkonstantine Please take a look at this new name", "url": "https://github.com/apache/kafka/pull/8755#discussion_r433724296", "createdAt": "2020-06-02T08:56:48Z", "author": {"login": "chia7712"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/ConnectorConfigTest.java", "diffHunk": "@@ -434,5 +436,52 @@ public void configure(Map<String, ?> configs) {\n         }\n     }\n \n+    @Test\n+    public void testEnrichedConfigDef() {\n+        String alias = \"hdt\";\n+        String prefix = ConnectorConfig.TRANSFORMS_CONFIG + \".\" + alias + \".\";\n+        Map<String, String> props = new HashMap<>();\n+        props.put(ConnectorConfig.TRANSFORMS_CONFIG, alias);\n+        props.put(prefix + \"type\", HasDuplicateConfigTransformation.class.getName());\n+        ConfigDef def = ConnectorConfig.enrich(MOCK_PLUGINS, new ConfigDef(), props, false);\n+        assertEnrichedConfigDef(def, prefix, HasDuplicateConfigTransformation.MUST_EXIST_KEY, ConfigDef.Type.BOOLEAN);\n+        assertEnrichedConfigDef(def, prefix, PredicatedTransformation.PREDICATE_CONFIG, ConfigDef.Type.STRING);\n+        assertEnrichedConfigDef(def, prefix, PredicatedTransformation.NEGATE_CONFIG, ConfigDef.Type.BOOLEAN);\n+    }\n+\n+    private static void assertEnrichedConfigDef(ConfigDef def, String prefix, String keyName, ConfigDef.Type expectedType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2462, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}