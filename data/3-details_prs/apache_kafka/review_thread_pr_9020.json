{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4OTM5NjE0", "number": 9020, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNjowNTo1NFrOEPMu9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTowMDo1MVrOEnTrxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzcyNzI3OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/WrappingStoreProvider.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNjowNTo1NFrOGyx-Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QwMToxMDo1N1rOHb-wmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMDcyNg==", "bodyText": "Is this really a different condition than the one on L65? It seems like the failure is still probably that the store \"migrated\" instead of \"doesn't exist\", right?", "url": "https://github.com/apache/kafka/pull/9020#discussion_r455900726", "createdAt": "2020-07-16T16:05:54Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/WrappingStoreProvider.java", "diffHunk": "@@ -46,11 +46,22 @@ public void setStoreQueryParameters(final StoreQueryParameters storeQueryParamet\n     public <T> List<T> stores(final String storeName,\n                               final QueryableStoreType<T> queryableStoreType) {\n         final List<T> allStores = new ArrayList<>();\n-        for (final StreamThreadStateStoreProvider provider : storeProviders) {\n-            final List<T> stores = provider.stores(storeQueryParameters);\n-            allStores.addAll(stores);\n+        for (final StreamThreadStateStoreProvider storeProvider : storeProviders) {\n+            final List<T> stores = storeProvider.stores(storeQueryParameters);\n+            if (!stores.isEmpty()) {\n+                allStores.addAll(stores);\n+                if (storeQueryParameters.partition() != null) {\n+                    break;\n+                }\n+            }\n         }\n         if (allStores.isEmpty()) {\n+            if (storeQueryParameters.partition() != null) {\n+                throw new InvalidStateStoreException(\n+                        String.format(\"The specified partition %d for store %s does not exist.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d38c6ed55dae174de77de429cb94fa1c26344c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzOTQ5MQ==", "bodyText": "L65 catches on rebalancing, while L60 is parameter validation for incorrect partition case.", "url": "https://github.com/apache/kafka/pull/9020#discussion_r455939491", "createdAt": "2020-07-16T17:07:34Z", "author": {"login": "dima5rr"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/WrappingStoreProvider.java", "diffHunk": "@@ -46,11 +46,22 @@ public void setStoreQueryParameters(final StoreQueryParameters storeQueryParamet\n     public <T> List<T> stores(final String storeName,\n                               final QueryableStoreType<T> queryableStoreType) {\n         final List<T> allStores = new ArrayList<>();\n-        for (final StreamThreadStateStoreProvider provider : storeProviders) {\n-            final List<T> stores = provider.stores(storeQueryParameters);\n-            allStores.addAll(stores);\n+        for (final StreamThreadStateStoreProvider storeProvider : storeProviders) {\n+            final List<T> stores = storeProvider.stores(storeQueryParameters);\n+            if (!stores.isEmpty()) {\n+                allStores.addAll(stores);\n+                if (storeQueryParameters.partition() != null) {\n+                    break;\n+                }\n+            }\n         }\n         if (allStores.isEmpty()) {\n+            if (storeQueryParameters.partition() != null) {\n+                throw new InvalidStateStoreException(\n+                        String.format(\"The specified partition %d for store %s does not exist.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMDcyNg=="}, "originalCommit": {"oid": "b7d38c6ed55dae174de77de429cb94fa1c26344c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0NzI1MA==", "bodyText": "Could you elaborate a bit more about this? If allStores.isEmpty() is empty, it is always possible that the specified store-partition or just store-\"null\" does not exist in this client. Why they are different failure cases?", "url": "https://github.com/apache/kafka/pull/9020#discussion_r494747250", "createdAt": "2020-09-25T04:57:13Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/WrappingStoreProvider.java", "diffHunk": "@@ -46,11 +46,22 @@ public void setStoreQueryParameters(final StoreQueryParameters storeQueryParamet\n     public <T> List<T> stores(final String storeName,\n                               final QueryableStoreType<T> queryableStoreType) {\n         final List<T> allStores = new ArrayList<>();\n-        for (final StreamThreadStateStoreProvider provider : storeProviders) {\n-            final List<T> stores = provider.stores(storeQueryParameters);\n-            allStores.addAll(stores);\n+        for (final StreamThreadStateStoreProvider storeProvider : storeProviders) {\n+            final List<T> stores = storeProvider.stores(storeQueryParameters);\n+            if (!stores.isEmpty()) {\n+                allStores.addAll(stores);\n+                if (storeQueryParameters.partition() != null) {\n+                    break;\n+                }\n+            }\n         }\n         if (allStores.isEmpty()) {\n+            if (storeQueryParameters.partition() != null) {\n+                throw new InvalidStateStoreException(\n+                        String.format(\"The specified partition %d for store %s does not exist.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMDcyNg=="}, "originalCommit": {"oid": "b7d38c6ed55dae174de77de429cb94fa1c26344c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5NjQyOQ==", "bodyText": "Hey @dima5rr , I think Guozhang's question was hidden because the conversation was already \"resolved\". Do you mind answering this concern?", "url": "https://github.com/apache/kafka/pull/9020#discussion_r496796429", "createdAt": "2020-09-29T15:08:16Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/WrappingStoreProvider.java", "diffHunk": "@@ -46,11 +46,22 @@ public void setStoreQueryParameters(final StoreQueryParameters storeQueryParamet\n     public <T> List<T> stores(final String storeName,\n                               final QueryableStoreType<T> queryableStoreType) {\n         final List<T> allStores = new ArrayList<>();\n-        for (final StreamThreadStateStoreProvider provider : storeProviders) {\n-            final List<T> stores = provider.stores(storeQueryParameters);\n-            allStores.addAll(stores);\n+        for (final StreamThreadStateStoreProvider storeProvider : storeProviders) {\n+            final List<T> stores = storeProvider.stores(storeQueryParameters);\n+            if (!stores.isEmpty()) {\n+                allStores.addAll(stores);\n+                if (storeQueryParameters.partition() != null) {\n+                    break;\n+                }\n+            }\n         }\n         if (allStores.isEmpty()) {\n+            if (storeQueryParameters.partition() != null) {\n+                throw new InvalidStateStoreException(\n+                        String.format(\"The specified partition %d for store %s does not exist.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMDcyNg=="}, "originalCommit": {"oid": "b7d38c6ed55dae174de77de429cb94fa1c26344c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA1NTU2Nw==", "bodyText": "Hey @guozhangwang, you're right, this check is ambiguous, it's more likely parameter sanity validation when user explicitly specify a single partition.", "url": "https://github.com/apache/kafka/pull/9020#discussion_r498055567", "createdAt": "2020-10-01T08:01:20Z", "author": {"login": "dima5rr"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/WrappingStoreProvider.java", "diffHunk": "@@ -46,11 +46,22 @@ public void setStoreQueryParameters(final StoreQueryParameters storeQueryParamet\n     public <T> List<T> stores(final String storeName,\n                               final QueryableStoreType<T> queryableStoreType) {\n         final List<T> allStores = new ArrayList<>();\n-        for (final StreamThreadStateStoreProvider provider : storeProviders) {\n-            final List<T> stores = provider.stores(storeQueryParameters);\n-            allStores.addAll(stores);\n+        for (final StreamThreadStateStoreProvider storeProvider : storeProviders) {\n+            final List<T> stores = storeProvider.stores(storeQueryParameters);\n+            if (!stores.isEmpty()) {\n+                allStores.addAll(stores);\n+                if (storeQueryParameters.partition() != null) {\n+                    break;\n+                }\n+            }\n         }\n         if (allStores.isEmpty()) {\n+            if (storeQueryParameters.partition() != null) {\n+                throw new InvalidStateStoreException(\n+                        String.format(\"The specified partition %d for store %s does not exist.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMDcyNg=="}, "originalCommit": {"oid": "b7d38c6ed55dae174de77de429cb94fa1c26344c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMzkyMg==", "bodyText": "Got it, in that case how about we just encode the partition in the thrown's message so that upon throwing, people can still check if the partition is null or not when debugging?\nOtherwise, this PR all LGTM :)", "url": "https://github.com/apache/kafka/pull/9020#discussion_r498533922", "createdAt": "2020-10-01T21:59:14Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/WrappingStoreProvider.java", "diffHunk": "@@ -46,11 +46,22 @@ public void setStoreQueryParameters(final StoreQueryParameters storeQueryParamet\n     public <T> List<T> stores(final String storeName,\n                               final QueryableStoreType<T> queryableStoreType) {\n         final List<T> allStores = new ArrayList<>();\n-        for (final StreamThreadStateStoreProvider provider : storeProviders) {\n-            final List<T> stores = provider.stores(storeQueryParameters);\n-            allStores.addAll(stores);\n+        for (final StreamThreadStateStoreProvider storeProvider : storeProviders) {\n+            final List<T> stores = storeProvider.stores(storeQueryParameters);\n+            if (!stores.isEmpty()) {\n+                allStores.addAll(stores);\n+                if (storeQueryParameters.partition() != null) {\n+                    break;\n+                }\n+            }\n         }\n         if (allStores.isEmpty()) {\n+            if (storeQueryParameters.partition() != null) {\n+                throw new InvalidStateStoreException(\n+                        String.format(\"The specified partition %d for store %s does not exist.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMDcyNg=="}, "originalCommit": {"oid": "b7d38c6ed55dae174de77de429cb94fa1c26344c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYyNzk1MQ==", "bodyText": "Hey @guozhangwang, I am just care that in case of partition is null, the error message is referenced in official FAQ.\nhttps://docs.confluent.io/current/streams/faq.html#handling-invalidstatestoreexception-the-state-store-may-have-migrated-to-another-instance", "url": "https://github.com/apache/kafka/pull/9020#discussion_r498627951", "createdAt": "2020-10-02T05:53:04Z", "author": {"login": "dima5rr"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/WrappingStoreProvider.java", "diffHunk": "@@ -46,11 +46,22 @@ public void setStoreQueryParameters(final StoreQueryParameters storeQueryParamet\n     public <T> List<T> stores(final String storeName,\n                               final QueryableStoreType<T> queryableStoreType) {\n         final List<T> allStores = new ArrayList<>();\n-        for (final StreamThreadStateStoreProvider provider : storeProviders) {\n-            final List<T> stores = provider.stores(storeQueryParameters);\n-            allStores.addAll(stores);\n+        for (final StreamThreadStateStoreProvider storeProvider : storeProviders) {\n+            final List<T> stores = storeProvider.stores(storeQueryParameters);\n+            if (!stores.isEmpty()) {\n+                allStores.addAll(stores);\n+                if (storeQueryParameters.partition() != null) {\n+                    break;\n+                }\n+            }\n         }\n         if (allStores.isEmpty()) {\n+            if (storeQueryParameters.partition() != null) {\n+                throw new InvalidStateStoreException(\n+                        String.format(\"The specified partition %d for store %s does not exist.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMDcyNg=="}, "originalCommit": {"oid": "b7d38c6ed55dae174de77de429cb94fa1c26344c"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTEwMTg0OA==", "bodyText": "That's a fair point, let's just merge it as is then.", "url": "https://github.com/apache/kafka/pull/9020#discussion_r499101848", "createdAt": "2020-10-03T01:10:57Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/WrappingStoreProvider.java", "diffHunk": "@@ -46,11 +46,22 @@ public void setStoreQueryParameters(final StoreQueryParameters storeQueryParamet\n     public <T> List<T> stores(final String storeName,\n                               final QueryableStoreType<T> queryableStoreType) {\n         final List<T> allStores = new ArrayList<>();\n-        for (final StreamThreadStateStoreProvider provider : storeProviders) {\n-            final List<T> stores = provider.stores(storeQueryParameters);\n-            allStores.addAll(stores);\n+        for (final StreamThreadStateStoreProvider storeProvider : storeProviders) {\n+            final List<T> stores = storeProvider.stores(storeQueryParameters);\n+            if (!stores.isEmpty()) {\n+                allStores.addAll(stores);\n+                if (storeQueryParameters.partition() != null) {\n+                    break;\n+                }\n+            }\n         }\n         if (allStores.isEmpty()) {\n+            if (storeQueryParameters.partition() != null) {\n+                throw new InvalidStateStoreException(\n+                        String.format(\"The specified partition %d for store %s does not exist.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwMDcyNg=="}, "originalCommit": {"oid": "b7d38c6ed55dae174de77de429cb94fa1c26344c"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Mzc1MjcwOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/StreamThreadStateStoreProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNjoxMTo0MFrOGyyN8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNjo1OToyMFrOGy0CdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwNDc1Mg==", "bodyText": "The nested early-return pattern is pretty hard to follow. Do you mind rewriting it to use if/else blocks? I know it was previously doing some early returns; it'd be better to migrate to a more maintainable style when we update the code, though.", "url": "https://github.com/apache/kafka/pull/9020#discussion_r455904752", "createdAt": "2020-07-16T16:11:40Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/StreamThreadStateStoreProvider.java", "diffHunk": "@@ -20,62 +20,49 @@\n import org.apache.kafka.streams.errors.InvalidStateStoreException;\n import org.apache.kafka.streams.processor.StateStore;\n import org.apache.kafka.streams.processor.TaskId;\n-import org.apache.kafka.streams.processor.internals.InternalTopologyBuilder;\n import org.apache.kafka.streams.processor.internals.StreamThread;\n import org.apache.kafka.streams.processor.internals.Task;\n import org.apache.kafka.streams.state.QueryableStoreType;\n import org.apache.kafka.streams.state.QueryableStoreTypes;\n import org.apache.kafka.streams.state.TimestampedKeyValueStore;\n import org.apache.kafka.streams.state.TimestampedWindowStore;\n \n-import java.util.ArrayList;\n import java.util.Collections;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n \n public class StreamThreadStateStoreProvider {\n \n     private final StreamThread streamThread;\n-    private final InternalTopologyBuilder internalTopologyBuilder;\n \n-    public StreamThreadStateStoreProvider(final StreamThread streamThread,\n-                                          final InternalTopologyBuilder internalTopologyBuilder) {\n+    public StreamThreadStateStoreProvider(final StreamThread streamThread) {\n         this.streamThread = streamThread;\n-        this.internalTopologyBuilder = internalTopologyBuilder;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public <T> List<T> stores(final StoreQueryParameters storeQueryParams) {\n         final String storeName = storeQueryParams.storeName();\n         final QueryableStoreType<T> queryableStoreType = storeQueryParams.queryableStoreType();\n-        final TaskId keyTaskId = createKeyTaskId(storeName, storeQueryParams.partition());\n         if (streamThread.state() == StreamThread.State.DEAD) {\n             return Collections.emptyList();\n         }\n         final StreamThread.State state = streamThread.state();\n         if (storeQueryParams.staleStoresEnabled() ? state.isAlive() : state == StreamThread.State.RUNNING) {\n             final Map<TaskId, ? extends Task> tasks = storeQueryParams.staleStoresEnabled() ? streamThread.allTasks() : streamThread.activeTaskMap();\n-            final List<T> stores = new ArrayList<>();\n-            if (keyTaskId != null) {\n-                final Task task = tasks.get(keyTaskId);\n-                if (task == null) {\n+            if (storeQueryParams.partition() != null) {\n+                final Task streamTask = findStreamTask(tasks, storeName, storeQueryParams.partition());\n+                if (streamTask == null) {\n                     return Collections.emptyList();\n                 }\n-                final T store = validateAndListStores(task.getStore(storeName), queryableStoreType, storeName, keyTaskId);\n-                if (store != null) {\n-                    return Collections.singletonList(store);\n-                }\n-            } else {\n-                for (final Task streamTask : tasks.values()) {\n-                    final T store = validateAndListStores(streamTask.getStore(storeName), queryableStoreType, storeName, streamTask.id());\n-                    if (store != null) {\n-                        stores.add(store);\n-                    }\n-                }\n+                final T store = validateAndListStores(streamTask.getStore(storeName), queryableStoreType, storeName, streamTask.id());\n+                return store != null ? Collections.singletonList(store) : Collections.emptyList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7d38c6ed55dae174de77de429cb94fa1c26344c"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzNDU4MA==", "bodyText": "sure", "url": "https://github.com/apache/kafka/pull/9020#discussion_r455934580", "createdAt": "2020-07-16T16:59:20Z", "author": {"login": "dima5rr"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/StreamThreadStateStoreProvider.java", "diffHunk": "@@ -20,62 +20,49 @@\n import org.apache.kafka.streams.errors.InvalidStateStoreException;\n import org.apache.kafka.streams.processor.StateStore;\n import org.apache.kafka.streams.processor.TaskId;\n-import org.apache.kafka.streams.processor.internals.InternalTopologyBuilder;\n import org.apache.kafka.streams.processor.internals.StreamThread;\n import org.apache.kafka.streams.processor.internals.Task;\n import org.apache.kafka.streams.state.QueryableStoreType;\n import org.apache.kafka.streams.state.QueryableStoreTypes;\n import org.apache.kafka.streams.state.TimestampedKeyValueStore;\n import org.apache.kafka.streams.state.TimestampedWindowStore;\n \n-import java.util.ArrayList;\n import java.util.Collections;\n-import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n-import java.util.Set;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n \n public class StreamThreadStateStoreProvider {\n \n     private final StreamThread streamThread;\n-    private final InternalTopologyBuilder internalTopologyBuilder;\n \n-    public StreamThreadStateStoreProvider(final StreamThread streamThread,\n-                                          final InternalTopologyBuilder internalTopologyBuilder) {\n+    public StreamThreadStateStoreProvider(final StreamThread streamThread) {\n         this.streamThread = streamThread;\n-        this.internalTopologyBuilder = internalTopologyBuilder;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     public <T> List<T> stores(final StoreQueryParameters storeQueryParams) {\n         final String storeName = storeQueryParams.storeName();\n         final QueryableStoreType<T> queryableStoreType = storeQueryParams.queryableStoreType();\n-        final TaskId keyTaskId = createKeyTaskId(storeName, storeQueryParams.partition());\n         if (streamThread.state() == StreamThread.State.DEAD) {\n             return Collections.emptyList();\n         }\n         final StreamThread.State state = streamThread.state();\n         if (storeQueryParams.staleStoresEnabled() ? state.isAlive() : state == StreamThread.State.RUNNING) {\n             final Map<TaskId, ? extends Task> tasks = storeQueryParams.staleStoresEnabled() ? streamThread.allTasks() : streamThread.activeTaskMap();\n-            final List<T> stores = new ArrayList<>();\n-            if (keyTaskId != null) {\n-                final Task task = tasks.get(keyTaskId);\n-                if (task == null) {\n+            if (storeQueryParams.partition() != null) {\n+                final Task streamTask = findStreamTask(tasks, storeName, storeQueryParams.partition());\n+                if (streamTask == null) {\n                     return Collections.emptyList();\n                 }\n-                final T store = validateAndListStores(task.getStore(storeName), queryableStoreType, storeName, keyTaskId);\n-                if (store != null) {\n-                    return Collections.singletonList(store);\n-                }\n-            } else {\n-                for (final Task streamTask : tasks.values()) {\n-                    final T store = validateAndListStores(streamTask.getStore(storeName), queryableStoreType, storeName, streamTask.id());\n-                    if (store != null) {\n-                        stores.add(store);\n-                    }\n-                }\n+                final T store = validateAndListStores(streamTask.getStore(storeName), queryableStoreType, storeName, streamTask.id());\n+                return store != null ? Collections.singletonList(store) : Collections.emptyList();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkwNDc1Mg=="}, "originalCommit": {"oid": "b7d38c6ed55dae174de77de429cb94fa1c26344c"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NDAyNzIxOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/StreamThreadStateStoreProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzoyMjozMVrOGy05oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxODowNToxNVrOGy2eTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk0ODcwNA==", "bodyText": "Ah, sorry, I can see that my prior comment was ambiguous. This is what I meant:\n            if (storeQueryParams.partition() == null) {\n                return tasks.values().stream().\n                        map(streamTask -> validateAndListStores(streamTask.getStore(storeName), queryableStoreType, storeName, streamTask.id())).\n                        filter(Objects::nonNull).\n                        collect(Collectors.toList());\n            } else {\n                final Task streamTask = findStreamTask(tasks, storeName, storeQueryParams.partition());\n                if (streamTask == null) {\n                    return Collections.emptyList();\n                } else {\n                    final T store = validateAndListStores(streamTask.getStore(storeName), queryableStoreType, storeName, streamTask.id());\n                    return store == null ? Collections.emptyList() : Collections.singletonList(store);\n                }\n            }\nThe reason this is better for maintenence is that you only have to trace a path through the nested conditionals into a single inner block to understand what gets returned. I.e., code comprehension complexity is only the depth of the conditional tree.\nIn contrast, if we do early returns, you have to fully read all the conditional blocks that lead up to the one you're interested (depth-first traversal), so code comprehension is linear instead of logarithmic. If we mutate the collection, you actually have to read all the conditionals to understand what is going to happen, so code comprehension is also linear instead of logarithmic.", "url": "https://github.com/apache/kafka/pull/9020#discussion_r455948704", "createdAt": "2020-07-16T17:22:31Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/StreamThreadStateStoreProvider.java", "diffHunk": "@@ -51,18 +51,22 @@ public StreamThreadStateStoreProvider(final StreamThread streamThread) {\n         final StreamThread.State state = streamThread.state();\n         if (storeQueryParams.staleStoresEnabled() ? state.isAlive() : state == StreamThread.State.RUNNING) {\n             final Map<TaskId, ? extends Task> tasks = storeQueryParams.staleStoresEnabled() ? streamThread.allTasks() : streamThread.activeTaskMap();\n+            final List<T> stores = new ArrayList<>();\n             if (storeQueryParams.partition() != null) {\n                 final Task streamTask = findStreamTask(tasks, storeName, storeQueryParams.partition());\n-                if (streamTask == null) {\n-                    return Collections.emptyList();\n+                if (streamTask != null) {\n+                    final T store = validateAndListStores(streamTask.getStore(storeName), queryableStoreType, storeName, streamTask.id());\n+                    if (store != null) {\n+                        stores.add(store);\n+                    }\n                 }\n-                final T store = validateAndListStores(streamTask.getStore(storeName), queryableStoreType, storeName, streamTask.id());\n-                return store != null ? Collections.singletonList(store) : Collections.emptyList();\n+            } else {\n+                tasks.values().stream().\n+                        map(streamTask -> validateAndListStores(streamTask.getStore(storeName), queryableStoreType, storeName, streamTask.id())).\n+                        filter(Objects::nonNull).\n+                        forEach(stores::add);\n             }\n-            return tasks.values().stream().\n-                    map(streamTask -> validateAndListStores(streamTask.getStore(storeName), queryableStoreType, storeName, streamTask.id())).\n-                    filter(Objects::nonNull).\n-                    collect(Collectors.toList());\n+            return Collections.unmodifiableList(stores);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89ac008bbe0763619a68d5cb455f73ec1aee54be"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk3NDQ3Ng==", "bodyText": "Will concise it into functional way.", "url": "https://github.com/apache/kafka/pull/9020#discussion_r455974476", "createdAt": "2020-07-16T18:05:15Z", "author": {"login": "dima5rr"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/StreamThreadStateStoreProvider.java", "diffHunk": "@@ -51,18 +51,22 @@ public StreamThreadStateStoreProvider(final StreamThread streamThread) {\n         final StreamThread.State state = streamThread.state();\n         if (storeQueryParams.staleStoresEnabled() ? state.isAlive() : state == StreamThread.State.RUNNING) {\n             final Map<TaskId, ? extends Task> tasks = storeQueryParams.staleStoresEnabled() ? streamThread.allTasks() : streamThread.activeTaskMap();\n+            final List<T> stores = new ArrayList<>();\n             if (storeQueryParams.partition() != null) {\n                 final Task streamTask = findStreamTask(tasks, storeName, storeQueryParams.partition());\n-                if (streamTask == null) {\n-                    return Collections.emptyList();\n+                if (streamTask != null) {\n+                    final T store = validateAndListStores(streamTask.getStore(storeName), queryableStoreType, storeName, streamTask.id());\n+                    if (store != null) {\n+                        stores.add(store);\n+                    }\n                 }\n-                final T store = validateAndListStores(streamTask.getStore(storeName), queryableStoreType, storeName, streamTask.id());\n-                return store != null ? Collections.singletonList(store) : Collections.emptyList();\n+            } else {\n+                tasks.values().stream().\n+                        map(streamTask -> validateAndListStores(streamTask.getStore(storeName), queryableStoreType, storeName, streamTask.id())).\n+                        filter(Objects::nonNull).\n+                        forEach(stores::add);\n             }\n-            return tasks.values().stream().\n-                    map(streamTask -> validateAndListStores(streamTask.getStore(storeName), queryableStoreType, storeName, streamTask.id())).\n-                    filter(Objects::nonNull).\n-                    collect(Collectors.toList());\n+            return Collections.unmodifiableList(stores);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk0ODcwNA=="}, "originalCommit": {"oid": "89ac008bbe0763619a68d5cb455f73ec1aee54be"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NjUxODk1OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StreamStreamJoinIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNDo1NzozOFrOHX0-tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNDo1NzozOFrOHX0-tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0NzMxOQ==", "bodyText": "A good coverage improvement! Thanks.", "url": "https://github.com/apache/kafka/pull/9020#discussion_r494747319", "createdAt": "2020-09-25T04:57:38Z", "author": {"login": "guozhangwang"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/StreamStreamJoinIntegrationTest.java", "diffHunk": "@@ -60,6 +60,34 @@ public void prepareTopology() throws InterruptedException {\n         rightStream = builder.stream(INPUT_TOPIC_RIGHT);\n     }\n \n+    @Test\n+    public void shouldNotAccessJoinStoresWhenGivingName() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fb7fe29473956dad54e73440152ec90df86ae78"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NjUyNDA4OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/StreamThreadStateStoreProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTowMDo0NVrOHX1BkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTowMDo0NVrOHX1BkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0ODA0OQ==", "bodyText": "This is a great find, thanks!", "url": "https://github.com/apache/kafka/pull/9020#discussion_r494748049", "createdAt": "2020-09-25T05:00:45Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/StreamThreadStateStoreProvider.java", "diffHunk": "@@ -104,19 +95,11 @@ public StreamThreadStateStoreProvider(final StreamThread streamThread,\n         }\n     }\n \n-    private TaskId createKeyTaskId(final String storeName, final Integer partition) {\n-        if (partition == null) {\n-            return null;\n-        }\n-        final List<String> sourceTopics = internalTopologyBuilder.stateStoreNameToSourceTopics().get(storeName);\n-        final Set<String> sourceTopicsSet = new HashSet<>(sourceTopics);\n-        final Map<Integer, InternalTopologyBuilder.TopicsInfo> topicGroups = internalTopologyBuilder.topicGroups();\n-        for (final Map.Entry<Integer, InternalTopologyBuilder.TopicsInfo> topicGroup : topicGroups.entrySet()) {\n-            if (topicGroup.getValue().sourceTopics.containsAll(sourceTopicsSet)) {\n-                return new TaskId(topicGroup.getKey(), partition);\n-            }\n-        }\n-        throw new InvalidStateStoreException(\"Cannot get state store \" + storeName + \" because the requested partition \" +\n-            partition + \" is not available on this instance\");\n+    private Optional<Task> findStreamTask(final Collection<Task> tasks, final String storeName, final int partition) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fb7fe29473956dad54e73440152ec90df86ae78"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NjUyNDIyOnYy", "diffSide": "LEFT", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/QueryableStoreProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTowMDo1MVrOHX1Bpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNTowMDo1MVrOHX1Bpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc0ODA3MA==", "bodyText": "LGTM.", "url": "https://github.com/apache/kafka/pull/9020#discussion_r494748070", "createdAt": "2020-09-25T05:00:51Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/QueryableStoreProvider.java", "diffHunk": "@@ -56,25 +55,6 @@ public QueryableStoreProvider(final List<StreamThreadStateStoreProvider> storePr\n         if (!globalStore.isEmpty()) {\n             return queryableStoreType.create(globalStoreProvider, storeName);\n         }\n-        final List<T> allStores = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fb7fe29473956dad54e73440152ec90df86ae78"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2255, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}