{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5Mjc0NDA1", "number": 7897, "title": "KAFKA-9365: Add server side change  to include consumer group information within transaction commit", "bodyText": "To be able to correctly fence zombie producer txn commit, we propose to add (member.id, group.instance.id, generation) into the transaction commit protocol to raise the same level of correctness guarantee as consumer commit.\nMajor changes involve:\n\nUpgrade transaction commit protocol with  (member.id, group.instance.id, generation). The client will fail if the broker is not supporting the new protocol.\nRefactor group coordinator logic to handle new txn commit errors such as FENCED_INSTANCE_ID, UNKNOWN_MEMBER_ID and ILLEGAL_GENERATION. We loose the check on transaction commit when the member.id is set to empty. This is because the member.id check is an add-on safety for producer commit, and we also need to consider backward compatibility for old producer clients without member.id information. And if producer equips with group.instance.id, then it must provide a valid member.id (not empty definitely), the same as a consumer commit.\n\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-01-05T05:58:01Z", "url": "https://github.com/apache/kafka/pull/7897", "merged": true, "mergeCommit": {"oid": "ed7c071e07f1f90e4c2895582f61ca090ced3c42"}, "closed": true, "closedAt": "2020-01-14T23:04:19Z", "author": {"login": "abbccdda"}, "timelineItems": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb3ROexAFqTMzODM4MjMxMw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABb6ZVs4AFqTM0Mjg4MTkwOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4MzgyMzEz", "url": "https://github.com/apache/kafka/pull/7897#pullrequestreview-338382313", "createdAt": "2020-01-05T06:04:57Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQwNjowNDo1N1rOFaQIeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQwNjowNDo1N1rOFaQIeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTYwOA==", "bodyText": "This is a clean-up as there is a duplicate struct in JoinGroupRequest already", "url": "https://github.com/apache/kafka/pull/7897#discussion_r363071608", "createdAt": "2020-01-05T06:04:57Z", "author": {"login": "abbccdda"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/JoinGroupResponse.java", "diffHunk": "@@ -31,7 +31,6 @@\n \n     public static final String UNKNOWN_PROTOCOL = \"\";\n     public static final int UNKNOWN_GENERATION_ID = -1;\n-    public static final String UNKNOWN_MEMBER_ID = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4MzgyMzI3", "url": "https://github.com/apache/kafka/pull/7897#pullrequestreview-338382327", "createdAt": "2020-01-05T06:05:32Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQwNjowNTozMlrOFaQIhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQwNjowNTozMlrOFaQIhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTYyMw==", "bodyText": "This file only contains clean-ups.", "url": "https://github.com/apache/kafka/pull/7897#discussion_r363071623", "createdAt": "2020-01-05T06:05:32Z", "author": {"login": "abbccdda"}, "path": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/AbstractCoordinatorTest.java", "diffHunk": "@@ -279,7 +279,7 @@ public void testGroupMaxSizeExceptionIsFatal() {\n         mockClient.prepareResponse(groupCoordinatorResponse(node, Errors.NONE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4MzgyMzQ2", "url": "https://github.com/apache/kafka/pull/7897#pullrequestreview-338382346", "createdAt": "2020-01-05T06:06:07Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQwNjowNjowN1rOFaQIpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQwNjowNjowN1rOFaQIpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTY1Mw==", "bodyText": "We couldn't use JoinGroupRequest/Response defined structs here due to import control", "url": "https://github.com/apache/kafka/pull/7897#discussion_r363071653", "createdAt": "2020-01-05T06:06:07Z", "author": {"login": "abbccdda"}, "path": "clients/src/test/java/org/apache/kafka/common/message/MessageTest.java", "diffHunk": "@@ -419,10 +425,16 @@ public void testTxnOffsetCommitRequestVersions() throws Exception {\n \n         for (short version = 0; version <= ApiKeys.TXN_OFFSET_COMMIT.latestVersion(); version++) {\n             TxnOffsetCommitRequestData requestData = request.get();\n-            if (version < 6) {\n+            if (version < 2) {\n                 requestData.topics().get(0).partitions().get(0).setCommittedLeaderEpoch(-1);\n             }\n \n+            if (version < 3) {\n+                requestData.setGroupInstanceId(null);\n+                requestData.setMemberId(\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4MzgyMzkz", "url": "https://github.com/apache/kafka/pull/7897#pullrequestreview-338382393", "createdAt": "2020-01-05T06:07:29Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQwNjowNzozMFrOFaQI4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQwNjowNzozMFrOFaQI4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTcxMg==", "bodyText": "The generation.id check needs to be put upfront before L734 as it treats txn commit same as assign mode consumer", "url": "https://github.com/apache/kafka/pull/7897#discussion_r363071712", "createdAt": "2020-01-05T06:07:30Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -723,14 +726,14 @@ class GroupCoordinator(val brokerId: Int,\n         responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.COORDINATOR_NOT_AVAILABLE })\n       } else if (group.isStaticMemberFenced(memberId, groupInstanceId)) {\n         responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.FENCED_INSTANCE_ID })\n-      } else if ((generationId < 0 && group.is(Empty)) || (producerId != NO_PRODUCER_ID)) {\n+      } else if (generationId >= 0 && generationId != group.generationId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4MzgyNDU3", "url": "https://github.com/apache/kafka/pull/7897#pullrequestreview-338382457", "createdAt": "2020-01-05T06:09:48Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQwNjowOTo0OFrOFaQJNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQwNjowOTo0OFrOFaQJNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTc5Ng==", "bodyText": "It's debatable whether we should continue going to group state based for commit logic for transactional commit as well. We decide to leave it as it is for now, unless the group state becomes concerning factor.", "url": "https://github.com/apache/kafka/pull/7897#discussion_r363071796", "createdAt": "2020-01-05T06:09:48Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -723,14 +726,14 @@ class GroupCoordinator(val brokerId: Int,\n         responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.COORDINATOR_NOT_AVAILABLE })\n       } else if (group.isStaticMemberFenced(memberId, groupInstanceId)) {\n         responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.FENCED_INSTANCE_ID })\n-      } else if ((generationId < 0 && group.is(Empty)) || (producerId != NO_PRODUCER_ID)) {\n+      } else if (generationId >= 0 && generationId != group.generationId) {\n+        // Validate non-zero generation id for both transactional and non-transactional commits.\n+        responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.ILLEGAL_GENERATION })\n+      } else if (group.isUnknownCommit(memberId, producerId)) {\n+        responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.UNKNOWN_MEMBER_ID })\n+      } else if (generationId < 0 && group.is(Empty) || producerId != NO_PRODUCER_ID) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4MzgyNDY0", "url": "https://github.com/apache/kafka/pull/7897#pullrequestreview-338382464", "createdAt": "2020-01-05T06:10:12Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQwNjoxMDoxMlrOFaQJOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQwNjoxMDoxMlrOFaQJOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTgwMA==", "bodyText": "clean-up for duplicate val.", "url": "https://github.com/apache/kafka/pull/7897#discussion_r363071800", "createdAt": "2020-01-05T06:10:12Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -1169,7 +1172,6 @@ object GroupCoordinator {\n   val NoProtocol = \"\"\n   val NoLeader = \"\"\n   val NoGeneration = -1\n-  val NoMemberId = \"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4MzgyNDky", "url": "https://github.com/apache/kafka/pull/7897#pullrequestreview-338382492", "createdAt": "2020-01-05T06:11:23Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQwNjoxMToyNFrOFaQJag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQwNjoxMToyNFrOFaQJag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTg1MA==", "bodyText": "Although it is possible to create a more condensed xx and (yy || zz) expression, I found current verbose version is more readable and understandable.", "url": "https://github.com/apache/kafka/pull/7897#discussion_r363071850", "createdAt": "2020-01-05T06:11:24Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadata.scala", "diffHunk": "@@ -402,6 +404,15 @@ private[group] class GroupMetadata(val groupId: String, initialState: GroupState\n       false\n   }\n \n+  def isUnknownCommit(memberId: String,\n+                      producerId: Long): Boolean = {\n+    if (producerId != NO_PRODUCER_ID) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4MzgyNTUy", "url": "https://github.com/apache/kafka/pull/7897#pullrequestreview-338382552", "createdAt": "2020-01-05T06:14:08Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQwNjoxNDowOFrOFaQJug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNVQwNjoxNDowOFrOFaQJug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTkzMA==", "bodyText": "By adding reset in the end of helper function, we reduced redundant replica manager reset.", "url": "https://github.com/apache/kafka/pull/7897#discussion_r363071930", "createdAt": "2020-01-05T06:14:08Z", "author": {"login": "abbccdda"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -1222,6 +1200,7 @@ class GroupCoordinatorTest {\n     assertEquals(Errors.NONE, followerSyncGroupResult._2)\n     assertTrue(getGroup(groupId).is(Stable))\n \n+    EasyMock.reset(replicaManager)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 182}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwMTY4NDc5", "url": "https://github.com/apache/kafka/pull/7897#pullrequestreview-340168479", "createdAt": "2020-01-08T21:51:57Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQyMTo1MTo1N1rOFbk8Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQyMjowNzoyM1rOFblT7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2MTE1NA==", "bodyText": "qq: Hmm, why we can retry with UNKNOWN_MEMBER_ID?", "url": "https://github.com/apache/kafka/pull/7897#discussion_r364461154", "createdAt": "2020-01-08T21:51:57Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java", "diffHunk": "@@ -1465,15 +1465,14 @@ public void handleResponse(AbstractResponse response) {\n                         lookupCoordinator(FindCoordinatorRequest.CoordinatorType.GROUP, builder.data.groupId());\n                     }\n                 } else if (error == Errors.UNKNOWN_TOPIC_OR_PARTITION\n-                        || error == Errors.COORDINATOR_LOAD_IN_PROGRESS) {\n-                    // If the topic is unknown or the coordinator is loading, retry with the current coordinator\n+                        || error == Errors.COORDINATOR_LOAD_IN_PROGRESS\n+                        || error == Errors.UNKNOWN_MEMBER_ID) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2MTIyNw==", "bodyText": "Great!", "url": "https://github.com/apache/kafka/pull/7897#discussion_r364461227", "createdAt": "2020-01-08T21:52:11Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/JoinGroupResponse.java", "diffHunk": "@@ -31,7 +31,6 @@\n \n     public static final String UNKNOWN_PROTOCOL = \"\";\n     public static final int UNKNOWN_GENERATION_ID = -1;\n-    public static final String UNKNOWN_MEMBER_ID = \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTYwOA=="}, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2MjM0OA==", "bodyText": "qq: Why not setting the default to UNKNOWN_GENERATION_ID etc for those new fields? It seems above we treat them as sentinel values anyways -- i.e. if they are not set, then setting them to those \"unknown\" values is safe and we check that if they are not unknown then the version should be newer.", "url": "https://github.com/apache/kafka/pull/7897#discussion_r364462348", "createdAt": "2020-01-08T21:55:00Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/resources/common/message/TxnOffsetCommitRequest.json", "diffHunk": "@@ -31,8 +33,15 @@\n       \"about\": \"The current producer ID in use by the transactional ID.\" },\n     { \"name\": \"ProducerEpoch\", \"type\": \"int16\", \"versions\": \"0+\",\n       \"about\": \"The current epoch associated with the producer ID.\" },\n+    { \"name\": \"GenerationId\", \"type\": \"int32\", \"versions\": \"3+\", \"default\": \"-1\", \"ignorable\": true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2NjAzOQ==", "bodyText": "prop: I'd propose we just make the producerId != NO_PRODUCER_ID condition in the first place to explicitly separate the checking logic for transactional / non-txnal commit starting at 732, e.g.:\nif (producerId != NO_PRODUCER_ID) {\n   // check if it is unknown\n} else {\n   // check if it is unknown, and\n   // check if it is manual\n}\n\nBecause if producer != NO_PRODUCER_ID it should never be manual, or am I wrong?", "url": "https://github.com/apache/kafka/pull/7897#discussion_r364466039", "createdAt": "2020-01-08T22:04:18Z", "author": {"login": "guozhangwang"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -723,14 +726,14 @@ class GroupCoordinator(val brokerId: Int,\n         responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.COORDINATOR_NOT_AVAILABLE })\n       } else if (group.isStaticMemberFenced(memberId, groupInstanceId)) {\n         responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.FENCED_INSTANCE_ID })\n-      } else if ((generationId < 0 && group.is(Empty)) || (producerId != NO_PRODUCER_ID)) {\n+      } else if (generationId >= 0 && generationId != group.generationId) {\n+        // Validate non-zero generation id for both transactional and non-transactional commits.\n+        responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.ILLEGAL_GENERATION })\n+      } else if (group.isUnknownCommit(memberId, producerId, generationId)) {\n+        responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.UNKNOWN_MEMBER_ID })\n+      } else if (group.isManualCommit(generationId) || producerId != NO_PRODUCER_ID) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2Njc1Nw==", "bodyText": "prop: See my other comment: I think manual commit could not happen for txnal commit, and if yes we could make the caller logic more explicit -- it means a bit more LOC, but the logic is more readable.", "url": "https://github.com/apache/kafka/pull/7897#discussion_r364466757", "createdAt": "2020-01-08T22:06:18Z", "author": {"login": "guozhangwang"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadata.scala", "diffHunk": "@@ -402,6 +404,15 @@ private[group] class GroupMetadata(val groupId: String, initialState: GroupState\n       false\n   }\n \n+  def isUnknownCommit(memberId: String,\n+                      producerId: Long): Boolean = {\n+    if (producerId != NO_PRODUCER_ID) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzA3MTg1MA=="}, "originalCommit": null, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2NzE4MQ==", "bodyText": "nit: why UNKNOWN_GENERATION_ID and UNKNOWN_PROTOCOL belongs to response while UNKNOWN_MEMBER_ID belongs to request? If there's no real good reason let's put them in a single class.", "url": "https://github.com/apache/kafka/pull/7897#discussion_r364467181", "createdAt": "2020-01-08T22:07:23Z", "author": {"login": "guozhangwang"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1410,10 +1410,10 @@ class KafkaApis(val requestChannel: RequestChannel,\n       // the group.instance.id field, so static members could accidentally become \"dynamic\", which leads to wrong states.\n       sendResponseCallback(JoinGroupResult(\n         List.empty,\n-        JoinGroupResponse.UNKNOWN_MEMBER_ID,\n+        JoinGroupRequest.UNKNOWN_MEMBER_ID,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxNDgyMTI5", "url": "https://github.com/apache/kafka/pull/7897#pullrequestreview-341482129", "createdAt": "2020-01-11T00:07:58Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMVQwMDowNzo1OFrOFci9Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMVQwMDowOTowNVrOFci98Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3NzE3NQ==", "bodyText": "What I'm thinking is mainly for debuggability, wondering if we explicitly separate the logic of txn / non-txn commit it is more readable -- currently the isUnknownCommit and isManualCommit are a bit mixed.\nThinking about this a bit more, how about the following within a single function (ordered):\n\n\nif generation id < 0 or state is Empty, we just bindly store offset (we can actually be stricter and check that member.id should always be UNKNOWN, but this is not there before so we do not really need to enforce it).\n\n\nelse, check memberId != JoinGroupRequest.UNKNOWN_MEMBER_ID && !has(memberId).\n\n\nFor both txn commit or consumer commit, 2) should be the case. So we do not need to really distinguish on producerId --- i.e. previously if the producerId is set we do not do the check of 2), now we always do it regardless. Is that correct?", "url": "https://github.com/apache/kafka/pull/7897#discussion_r365477175", "createdAt": "2020-01-11T00:07:58Z", "author": {"login": "guozhangwang"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -723,14 +726,14 @@ class GroupCoordinator(val brokerId: Int,\n         responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.COORDINATOR_NOT_AVAILABLE })\n       } else if (group.isStaticMemberFenced(memberId, groupInstanceId)) {\n         responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.FENCED_INSTANCE_ID })\n-      } else if ((generationId < 0 && group.is(Empty)) || (producerId != NO_PRODUCER_ID)) {\n+      } else if (generationId >= 0 && generationId != group.generationId) {\n+        // Validate non-zero generation id for both transactional and non-transactional commits.\n+        responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.ILLEGAL_GENERATION })\n+      } else if (group.isUnknownCommit(memberId, producerId, generationId)) {\n+        responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.UNKNOWN_MEMBER_ID })\n+      } else if (group.isManualCommit(generationId) || producerId != NO_PRODUCER_ID) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2NjAzOQ=="}, "originalCommit": null, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3NzM2MQ==", "bodyText": "Why reset the replica manager mock here?", "url": "https://github.com/apache/kafka/pull/7897#discussion_r365477361", "createdAt": "2020-01-11T00:09:05Z", "author": {"login": "guozhangwang"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -2443,6 +2422,74 @@ class GroupCoordinatorTest {\n     assertEquals(Errors.ILLEGAL_GENERATION, commitOffsetResult(tp))\n   }\n \n+  @Test\n+  def testTxnCommitOffsetWithFencedInstanceId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val rebalanceResult = staticMembersJoinAndRebalance(leaderInstanceId, followerInstanceId)\n+\n+    val leaderNoMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), groupInstanceId = leaderInstanceId)\n+    assertEquals(Errors.FENCED_INSTANCE_ID, leaderNoMemberIdCommitOffsetResult (tp))\n+\n+    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), rebalanceResult.leaderId, leaderInstanceId)\n+    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))\n+  }\n+\n+  @Test\n+  def testTxnCommitOffsetWithUnknownMemberId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val joinGroupResult = dynamicJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols)\n+    val joinGroupError = joinGroupResult.error\n+    assertEquals(Errors.NONE, joinGroupError)\n+\n+    EasyMock.reset(replicaManager)\n+    val invalidIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), \"invalid-member\", Option.empty)\n+    assertEquals(Errors.UNKNOWN_MEMBER_ID, invalidIdCommitOffsetResult (tp))\n+\n+    val unknownMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), JoinGroupRequest.UNKNOWN_MEMBER_ID, Option.empty)\n+    assertEquals(Errors.NONE, unknownMemberIdCommitOffsetResult (tp))\n+\n+    val assignedConsumerId = joinGroupResult.memberId\n+    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), assignedConsumerId, Option.empty)\n+    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))\n+  }\n+\n+  @Test\n+  def testTxnCommitOffsetWithIllegalGeneration(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val joinGroupResult = dynamicJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols)\n+    val joinGroupError = joinGroupResult.error\n+    assertEquals(Errors.NONE, joinGroupError)\n+\n+    EasyMock.reset(replicaManager)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 245}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMTc4NTkx", "url": "https://github.com/apache/kafka/pull/7897#pullrequestreview-342178591", "createdAt": "2020-01-13T22:18:58Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QyMjoxODo1OFrOFdGfGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QyMjoxODo1OFrOFdGfGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjA1OTI4OQ==", "bodyText": "Since TxnOffsetCommit has been converted to use the generated protocol and we are bumping it here, let's add flexible version support. I was going to do this in #7931, but we may as well just do one version bump instead of two.", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366059289", "createdAt": "2020-01-13T22:18:58Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/resources/common/message/TxnOffsetCommitRequest.json", "diffHunk": "@@ -20,7 +20,9 @@\n   // Version 1 is the same as version 0.\n   //\n   // Version 2 adds the committed leader epoch.\n-  \"validVersions\": \"0-2\",\n+  //\n+  // Version 3 adds the member.id, group.instance.id and generation.id.\n+  \"validVersions\": \"0-3\",\n   \"flexibleVersions\": \"none\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNjY1OTE1", "url": "https://github.com/apache/kafka/pull/7897#pullrequestreview-342665915", "createdAt": "2020-01-14T16:27:35Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxNjoyNzozNVrOFddtjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxNjoyOTo0MVrOFddylg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQzOTgyMg==", "bodyText": "If we make these fatal errors, then the user will have to close the producer and instantiate a new one. I think as long as the producer can still abort the transaction, they should be abortable errors.", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366439822", "createdAt": "2020-01-14T16:27:35Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java", "diffHunk": "@@ -1497,4 +1495,13 @@ public void handleResponse(AbstractResponse response) {\n             }\n         }\n     }\n+\n+    private boolean isFatalException(Errors error) {\n+        return error == Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED\n+                || error == Errors.INVALID_PRODUCER_EPOCH\n+                || error == Errors.UNSUPPORTED_FOR_MESSAGE_FORMAT\n+                || error == Errors.FENCED_INSTANCE_ID\n+                || error == Errors.UNKNOWN_MEMBER_ID", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ0MTExMA==", "bodyText": "Let's add flexible version support in the response also.", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366441110", "createdAt": "2020-01-14T16:29:41Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/resources/common/message/TxnOffsetCommitResponse.json", "diffHunk": "@@ -18,8 +18,11 @@\n   \"type\": \"response\",\n   \"name\": \"TxnOffsetCommitResponse\",\n   // Starting in version 1, on quota violation, brokers send out responses before throttling.\n+  //\n   // Version 2 is the same as version 1.\n-  \"validVersions\": \"0-2\",\n+  //\n+  // Version 3 adds illegal generation, fenced instance id, and unknown member id errors.\n+  \"validVersions\": \"0-3\",\n   \"flexibleVersions\": \"none\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc0e77f6488028214fa1242869005f618c20d395", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/dc0e77f6488028214fa1242869005f618c20d395", "committedDate": "2020-01-14T17:39:48Z", "message": "add fencing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1624afa9d42316240d02521aa43cb3a057888015", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/1624afa9d42316240d02521aa43cb3a057888015", "committedDate": "2020-01-14T17:39:48Z", "message": "enforce on consumer commit generation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0bdca618ccb5488ee6b543255a2f5e0a3efcf09", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/a0bdca618ccb5488ee6b543255a2f5e0a3efcf09", "committedDate": "2020-01-14T17:39:48Z", "message": "consolidate constants and put unknown.member.id as fatal exception"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04e4d269eb9b50c3352ea40be017795e98ec79e2", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/04e4d269eb9b50c3352ea40be017795e98ec79e2", "committedDate": "2020-01-14T17:39:48Z", "message": "fencing fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3ec3429abbff25111d74d03250296b43e61dca0", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/a3ec3429abbff25111d74d03250296b43e61dca0", "committedDate": "2020-01-14T17:39:48Z", "message": "address Guozhang's comment on simplifying the commit logic"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c001dd81a295dd3eb649c191c87ae3f7db017e3", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/6c001dd81a295dd3eb649c191c87ae3f7db017e3", "committedDate": "2020-01-14T17:39:48Z", "message": "bump flexible versions for txn commit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2017357b974b1e12dca6a9ea4c822c6aa8380756", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/2017357b974b1e12dca6a9ea4c822c6aa8380756", "committedDate": "2020-01-14T17:39:48Z", "message": "convert to abortable error"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "2017357b974b1e12dca6a9ea4c822c6aa8380756", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/2017357b974b1e12dca6a9ea4c822c6aa8380756", "committedDate": "2020-01-14T17:39:48Z", "message": "convert to abortable error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fbb4528f1f1b71649df4a60751d03271aa03ec3", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/9fbb4528f1f1b71649df4a60751d03271aa03ec3", "committedDate": "2020-01-14T17:59:41Z", "message": "minor clean"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNzQyNTE5", "url": "https://github.com/apache/kafka/pull/7897#pullrequestreview-342742519", "createdAt": "2020-01-14T18:23:54Z", "commit": {"oid": "9fbb4528f1f1b71649df4a60751d03271aa03ec3"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxODoyMzo1NFrOFdhT_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQxODozMToxMVrOFdhh2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ5ODgxMg==", "bodyText": "Should we set the default to \"\"?", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366498812", "createdAt": "2020-01-14T18:23:54Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/resources/common/message/TxnOffsetCommitRequest.json", "diffHunk": "@@ -31,8 +33,15 @@\n       \"about\": \"The current producer ID in use by the transactional ID.\" },\n     { \"name\": \"ProducerEpoch\", \"type\": \"int16\", \"versions\": \"0+\",\n       \"about\": \"The current epoch associated with the producer ID.\" },\n+    { \"name\": \"GenerationId\", \"type\": \"int32\", \"versions\": \"3+\", \"default\": \"-1\", \"ignorable\": true,\n+      \"about\": \"The generation of the consumer.\" },\n+    { \"name\": \"MemberId\", \"type\": \"string\", \"versions\": \"3+\", \"ignorable\": true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fbb4528f1f1b71649df4a60751d03271aa03ec3"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjQ5OTcxNA==", "bodyText": "It's a bit inconsistent to set these as ignorable if the builder actually raises an exception. I would suggest making them non-ignorable and removing the checks inside the builder.", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366499714", "createdAt": "2020-01-14T18:25:47Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/resources/common/message/TxnOffsetCommitRequest.json", "diffHunk": "@@ -31,8 +33,15 @@\n       \"about\": \"The current producer ID in use by the transactional ID.\" },\n     { \"name\": \"ProducerEpoch\", \"type\": \"int16\", \"versions\": \"0+\",\n       \"about\": \"The current epoch associated with the producer ID.\" },\n+    { \"name\": \"GenerationId\", \"type\": \"int32\", \"versions\": \"3+\", \"default\": \"-1\", \"ignorable\": true,\n+      \"about\": \"The generation of the consumer.\" },\n+    { \"name\": \"MemberId\", \"type\": \"string\", \"versions\": \"3+\", \"ignorable\": true,\n+      \"about\": \"The member ID assigned by the group coordinator.\" },\n+    { \"name\": \"GroupInstanceId\", \"type\": \"string\", \"versions\": \"3+\", \"ignorable\": true,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fbb4528f1f1b71649df4a60751d03271aa03ec3"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUwMTY2NA==", "bodyText": "These test cases are a bit odd. Why would we get a FENCED_INSTANCE_ID if we have not provided an instance id? I think it would make sense to do all of the client changes in a single PR and all the server changes in a separate PR. I'm ok doing them all at once also since this PR is not that big.", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366501664", "createdAt": "2020-01-14T18:29:43Z", "author": {"login": "hachikuji"}, "path": "clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java", "diffHunk": "@@ -940,6 +943,99 @@ public void testUnsupportedForMessageFormatInTxnOffsetCommit() {\n         assertFatalError(UnsupportedForMessageFormatException.class);\n     }\n \n+    @Test\n+    public void testFencedInstanceIdInTxnOffsetCommit() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fbb4528f1f1b71649df4a60751d03271aa03ec3"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjUwMjM2Mw==", "bodyText": "nit: I think it would be a little cleaner to rely on the defaults from the schema. So if we don't have a GroupMetadata object, then we don't set anything.", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366502363", "createdAt": "2020-01-14T18:31:11Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/JoinGroupRequest.java", "diffHunk": "@@ -120,10 +122,10 @@ public AbstractResponse getErrorResponse(int throttleTimeMs, Throwable e) {\n         return new JoinGroupResponse(new JoinGroupResponseData()\n                 .setThrottleTimeMs(throttleTimeMs)\n                 .setErrorCode(Errors.forException(e).code())\n-                .setGenerationId(JoinGroupResponse.UNKNOWN_GENERATION_ID)\n-                .setProtocolName(JoinGroupResponse.UNKNOWN_PROTOCOL)\n-                .setLeader(JoinGroupResponse.UNKNOWN_MEMBER_ID)\n-                .setMemberId(JoinGroupResponse.UNKNOWN_MEMBER_ID)\n+                .setGenerationId(UNKNOWN_GENERATION_ID)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fbb4528f1f1b71649df4a60751d03271aa03ec3"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57b278e7c538a2810e0d4da36a364d31d5319ce1", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/57b278e7c538a2810e0d4da36a364d31d5319ce1", "committedDate": "2020-01-14T19:29:21Z", "message": "Some comments from Jason"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "437f8456983ba6234644c62a5cbfee5e77814cfb", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/437f8456983ba6234644c62a5cbfee5e77814cfb", "committedDate": "2020-01-14T19:34:25Z", "message": "revert client side changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyNzk1NzUw", "url": "https://github.com/apache/kafka/pull/7897#pullrequestreview-342795750", "createdAt": "2020-01-14T19:49:46Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "943bdf3604b662dfd20e7cfd586ada10e3412bc8", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/943bdf3604b662dfd20e7cfd586ada10e3412bc8", "committedDate": "2020-01-14T20:19:53Z", "message": "checkstyle fix"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "943bdf3604b662dfd20e7cfd586ada10e3412bc8", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/943bdf3604b662dfd20e7cfd586ada10e3412bc8", "committedDate": "2020-01-14T20:19:53Z", "message": "checkstyle fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyODgxOTA4", "url": "https://github.com/apache/kafka/pull/7897#pullrequestreview-342881908", "createdAt": "2020-01-14T22:28:31Z", "commit": {"oid": "943bdf3604b662dfd20e7cfd586ada10e3412bc8"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMjoyODozMVrOFdn49g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMzoxMzowOVrOFdo2MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwNjU4Mg==", "bodyText": "It's confusing that we call testAllMessageRoundTripsFromVersion here, because it will fail for the first version we pass in (ie, the internal for loop is not required. It would be easier to understand the test if we call testEquivalentMessageRoundTrip instead.\nApplies to there places too -- also to PR you do in parallel IIRC.", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366606582", "createdAt": "2020-01-14T22:28:31Z", "author": {"login": "mjsax"}, "path": "clients/src/test/java/org/apache/kafka/common/message/MessageTest.java", "diffHunk": "@@ -419,10 +425,20 @@ public void testTxnOffsetCommitRequestVersions() throws Exception {\n \n         for (short version = 0; version <= ApiKeys.TXN_OFFSET_COMMIT.latestVersion(); version++) {\n             TxnOffsetCommitRequestData requestData = request.get();\n-            if (version < 6) {\n+            if (version < 2) {\n                 requestData.topics().get(0).partitions().get(0).setCommittedLeaderEpoch(-1);\n             }\n \n+            if (version < 3) {\n+                final short finalVersion = version;\n+                assertThrows(UnsupportedVersionException.class, () -> testAllMessageRoundTripsFromVersion(finalVersion, requestData));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "943bdf3604b662dfd20e7cfd586ada10e3412bc8"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwNzc2MQ==", "bodyText": "Same here -- we actually loop through the version in the outer loop, so why do we need to loop through them again? Effectively, we run tests for smaller versions multiple times?", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366607761", "createdAt": "2020-01-14T22:31:51Z", "author": {"login": "mjsax"}, "path": "clients/src/test/java/org/apache/kafka/common/message/MessageTest.java", "diffHunk": "@@ -419,10 +425,20 @@ public void testTxnOffsetCommitRequestVersions() throws Exception {\n \n         for (short version = 0; version <= ApiKeys.TXN_OFFSET_COMMIT.latestVersion(); version++) {\n             TxnOffsetCommitRequestData requestData = request.get();\n-            if (version < 6) {\n+            if (version < 2) {\n                 requestData.topics().get(0).partitions().get(0).setCommittedLeaderEpoch(-1);\n             }\n \n+            if (version < 3) {\n+                final short finalVersion = version;\n+                assertThrows(UnsupportedVersionException.class, () -> testAllMessageRoundTripsFromVersion(finalVersion, requestData));\n+                requestData.setGroupInstanceId(null);\n+                assertThrows(UnsupportedVersionException.class, () -> testAllMessageRoundTripsFromVersion(finalVersion, requestData));\n+                requestData.setMemberId(\"\");\n+                assertThrows(UnsupportedVersionException.class, () -> testAllMessageRoundTripsFromVersion(finalVersion, requestData));\n+                requestData.setGenerationId(-1);\n+            }\n+\n             testAllMessageRoundTripsFromVersion(version, requestData);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "943bdf3604b662dfd20e7cfd586ada10e3412bc8"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwODYxOQ==", "bodyText": "Also, we actually want to test that, if any of the three new fields is set on a lower version we get UnsupportedVersionException -- hence, for each case, we should set two fields to null IMHO. Atm, the test logic is somewhat confusing.", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366608619", "createdAt": "2020-01-14T22:34:09Z", "author": {"login": "mjsax"}, "path": "clients/src/test/java/org/apache/kafka/common/message/MessageTest.java", "diffHunk": "@@ -419,10 +425,20 @@ public void testTxnOffsetCommitRequestVersions() throws Exception {\n \n         for (short version = 0; version <= ApiKeys.TXN_OFFSET_COMMIT.latestVersion(); version++) {\n             TxnOffsetCommitRequestData requestData = request.get();\n-            if (version < 6) {\n+            if (version < 2) {\n                 requestData.topics().get(0).partitions().get(0).setCommittedLeaderEpoch(-1);\n             }\n \n+            if (version < 3) {\n+                final short finalVersion = version;\n+                assertThrows(UnsupportedVersionException.class, () -> testAllMessageRoundTripsFromVersion(finalVersion, requestData));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwNjU4Mg=="}, "originalCommit": {"oid": "943bdf3604b662dfd20e7cfd586ada10e3412bc8"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwOTk3MA==", "bodyText": "Why do we need to check generationId >= 0 ?", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366609970", "createdAt": "2020-01-14T22:37:48Z", "author": {"login": "mjsax"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -706,12 +706,39 @@ class GroupCoordinator(val brokerId: Int,\n     groupManager.scheduleHandleTxnCompletion(producerId, offsetsPartitions.map(_.partition).toSet, isCommit)\n   }\n \n+  private def doTxnCommitOffsets(group: GroupMetadata,\n+                                 memberId: String,\n+                                 groupInstanceId: Option[String],\n+                                 generationId: Int,\n+                                 producerId: Long,\n+                                 producerEpoch: Short,\n+                                 offsetMetadata: immutable.Map[TopicPartition, OffsetAndMetadata],\n+                                 responseCallback: immutable.Map[TopicPartition, Errors] => Unit): Unit = {\n+    group.inLock {\n+      if (group.is(Dead)) {\n+        // if the group is marked as dead, it means some other thread has just removed the group\n+        // from the coordinator metadata; it is likely that the group has migrated to some other\n+        // coordinator OR the group is in a transient unstable phase. Let the member retry\n+        // finding the correct coordinator and rejoin.\n+        responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.COORDINATOR_NOT_AVAILABLE })\n+      } else if (group.isStaticMemberFenced(memberId, groupInstanceId)) {\n+        responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.FENCED_INSTANCE_ID })\n+      } else if (memberId != JoinGroupRequest.UNKNOWN_MEMBER_ID && !group.has(memberId)) {\n+        // Enforce member id when it is set.\n+        responseCallback(offsetMetadata.map { case (k, _) => k -> Errors.UNKNOWN_MEMBER_ID })\n+      } else if (generationId >= 0 && generationId != group.generationId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "943bdf3604b662dfd20e7cfd586ada10e3412bc8"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYyMDA3Ng==", "bodyText": "I am not sure if I understand this test. (1) why do we test with a static member? Fencing could also happen for non-static members now? (2) Why does the member get fenced at all (it seems that staticMembersJoinAndRebalance should successfully add two members to the consumer group?) (3) Why do we no pass a groupInstanceId into commitTransactionalOffsets() on the first call, as we use static group membership?", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366620076", "createdAt": "2020-01-14T23:06:38Z", "author": {"login": "mjsax"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -2500,6 +2479,74 @@ class GroupCoordinatorTest {\n     assertEquals(Errors.ILLEGAL_GENERATION, commitOffsetResult(tp))\n   }\n \n+  @Test\n+  def testTxnCommitOffsetWithFencedInstanceId(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "943bdf3604b662dfd20e7cfd586ada10e3412bc8"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYyMDgyOA==", "bodyText": "Why do we pass Option.empty -- isn't this the default anyway?", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366620828", "createdAt": "2020-01-14T23:08:54Z", "author": {"login": "mjsax"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -2500,6 +2479,74 @@ class GroupCoordinatorTest {\n     assertEquals(Errors.ILLEGAL_GENERATION, commitOffsetResult(tp))\n   }\n \n+  @Test\n+  def testTxnCommitOffsetWithFencedInstanceId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val rebalanceResult = staticMembersJoinAndRebalance(leaderInstanceId, followerInstanceId)\n+\n+    val leaderNoMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), groupInstanceId = leaderInstanceId)\n+    assertEquals(Errors.FENCED_INSTANCE_ID, leaderNoMemberIdCommitOffsetResult (tp))\n+\n+    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), rebalanceResult.leaderId, leaderInstanceId)\n+    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))\n+  }\n+\n+  @Test\n+  def testTxnCommitOffsetWithUnknownMemberId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val joinGroupResult = dynamicJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols)\n+    val joinGroupError = joinGroupResult.error\n+    assertEquals(Errors.NONE, joinGroupError)\n+\n+    EasyMock.reset(replicaManager)\n+    val invalidIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), \"invalid-member\", Option.empty)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "943bdf3604b662dfd20e7cfd586ada10e3412bc8"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYyMTU1Nw==", "bodyText": "This should be it's own test -- it test backward compatibility for older clients if I read it correctly.", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366621557", "createdAt": "2020-01-14T23:10:54Z", "author": {"login": "mjsax"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -2500,6 +2479,74 @@ class GroupCoordinatorTest {\n     assertEquals(Errors.ILLEGAL_GENERATION, commitOffsetResult(tp))\n   }\n \n+  @Test\n+  def testTxnCommitOffsetWithFencedInstanceId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val rebalanceResult = staticMembersJoinAndRebalance(leaderInstanceId, followerInstanceId)\n+\n+    val leaderNoMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), groupInstanceId = leaderInstanceId)\n+    assertEquals(Errors.FENCED_INSTANCE_ID, leaderNoMemberIdCommitOffsetResult (tp))\n+\n+    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), rebalanceResult.leaderId, leaderInstanceId)\n+    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))\n+  }\n+\n+  @Test\n+  def testTxnCommitOffsetWithUnknownMemberId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val joinGroupResult = dynamicJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols)\n+    val joinGroupError = joinGroupResult.error\n+    assertEquals(Errors.NONE, joinGroupError)\n+\n+    EasyMock.reset(replicaManager)\n+    val invalidIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), \"invalid-member\", Option.empty)\n+    assertEquals(Errors.UNKNOWN_MEMBER_ID, invalidIdCommitOffsetResult (tp))\n+\n+    val unknownMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), JoinGroupRequest.UNKNOWN_MEMBER_ID, Option.empty)\n+    assertEquals(Errors.NONE, unknownMemberIdCommitOffsetResult (tp))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "943bdf3604b662dfd20e7cfd586ada10e3412bc8"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYyMTg4MA==", "bodyText": "This should be it's own test -- the test name says WithUnknownMemberId but this test passes a known memberId", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366621880", "createdAt": "2020-01-14T23:11:53Z", "author": {"login": "mjsax"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -2500,6 +2479,74 @@ class GroupCoordinatorTest {\n     assertEquals(Errors.ILLEGAL_GENERATION, commitOffsetResult(tp))\n   }\n \n+  @Test\n+  def testTxnCommitOffsetWithFencedInstanceId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val rebalanceResult = staticMembersJoinAndRebalance(leaderInstanceId, followerInstanceId)\n+\n+    val leaderNoMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), groupInstanceId = leaderInstanceId)\n+    assertEquals(Errors.FENCED_INSTANCE_ID, leaderNoMemberIdCommitOffsetResult (tp))\n+\n+    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), rebalanceResult.leaderId, leaderInstanceId)\n+    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))\n+  }\n+\n+  @Test\n+  def testTxnCommitOffsetWithUnknownMemberId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val joinGroupResult = dynamicJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols)\n+    val joinGroupError = joinGroupResult.error\n+    assertEquals(Errors.NONE, joinGroupError)\n+\n+    EasyMock.reset(replicaManager)\n+    val invalidIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), \"invalid-member\", Option.empty)\n+    assertEquals(Errors.UNKNOWN_MEMBER_ID, invalidIdCommitOffsetResult (tp))\n+\n+    val unknownMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), JoinGroupRequest.UNKNOWN_MEMBER_ID, Option.empty)\n+    assertEquals(Errors.NONE, unknownMemberIdCommitOffsetResult (tp))\n+\n+    val assignedConsumerId = joinGroupResult.memberId\n+    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), assignedConsumerId, Option.empty)\n+    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "943bdf3604b662dfd20e7cfd586ada10e3412bc8"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYyMjI1Ng==", "bodyText": "The test name says WithIllegalGeneration -- but this is a positive test using the correct generationId -- should be two tests.", "url": "https://github.com/apache/kafka/pull/7897#discussion_r366622256", "createdAt": "2020-01-14T23:13:09Z", "author": {"login": "mjsax"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -2500,6 +2479,74 @@ class GroupCoordinatorTest {\n     assertEquals(Errors.ILLEGAL_GENERATION, commitOffsetResult(tp))\n   }\n \n+  @Test\n+  def testTxnCommitOffsetWithFencedInstanceId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val rebalanceResult = staticMembersJoinAndRebalance(leaderInstanceId, followerInstanceId)\n+\n+    val leaderNoMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), groupInstanceId = leaderInstanceId)\n+    assertEquals(Errors.FENCED_INSTANCE_ID, leaderNoMemberIdCommitOffsetResult (tp))\n+\n+    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), rebalanceResult.leaderId, leaderInstanceId)\n+    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))\n+  }\n+\n+  @Test\n+  def testTxnCommitOffsetWithUnknownMemberId(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val joinGroupResult = dynamicJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols)\n+    val joinGroupError = joinGroupResult.error\n+    assertEquals(Errors.NONE, joinGroupError)\n+\n+    EasyMock.reset(replicaManager)\n+    val invalidIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), \"invalid-member\", Option.empty)\n+    assertEquals(Errors.UNKNOWN_MEMBER_ID, invalidIdCommitOffsetResult (tp))\n+\n+    val unknownMemberIdCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), JoinGroupRequest.UNKNOWN_MEMBER_ID, Option.empty)\n+    assertEquals(Errors.NONE, unknownMemberIdCommitOffsetResult (tp))\n+\n+    val assignedConsumerId = joinGroupResult.memberId\n+    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), assignedConsumerId, Option.empty)\n+    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))\n+  }\n+\n+  @Test\n+  def testTxnCommitOffsetWithIllegalGeneration(): Unit = {\n+    val tp = new TopicPartition(\"topic\", 0)\n+    val offset = offsetAndMetadata(0)\n+    val producerId = 1000L\n+    val producerEpoch : Short = 2\n+\n+    val joinGroupResult = dynamicJoinGroup(groupId, JoinGroupRequest.UNKNOWN_MEMBER_ID, protocolType, protocols)\n+    val joinGroupError = joinGroupResult.error\n+    assertEquals(Errors.NONE, joinGroupError)\n+\n+    EasyMock.reset(replicaManager)\n+\n+    val assignedConsumerId = joinGroupResult.memberId\n+    val initialGenerationId = joinGroupResult.generationId\n+    val leaderCommitOffsetResult = commitTransactionalOffsets(groupId, producerId, producerEpoch,\n+      Map(tp -> offset), assignedConsumerId, Option.empty, initialGenerationId)\n+    assertEquals(Errors.NONE, leaderCommitOffsetResult (tp))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "943bdf3604b662dfd20e7cfd586ada10e3412bc8"}, "originalPosition": 251}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2182, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}