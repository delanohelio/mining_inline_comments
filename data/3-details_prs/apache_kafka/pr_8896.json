{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2NjU5MTA4", "number": 8896, "title": "KAFKA-10185: Restoration info logging", "bodyText": "Committer Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-06-18T17:28:44Z", "url": "https://github.com/apache/kafka/pull/8896", "merged": true, "mergeCommit": {"oid": "68db063aa4918ac7dc40cb5c0be48ec731c160f7"}, "closed": true, "closedAt": "2020-06-19T19:17:59Z", "author": {"login": "vvcephei"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcsiL1fgFqTQzMzUxMDc4MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcs1hakgFqTQzNDE5NTM1OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNTEwNzgw", "url": "https://github.com/apache/kafka/pull/8896#pullrequestreview-433510780", "createdAt": "2020-06-18T17:44:31Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNzo0NDozMVrOGl5zUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNzo0Nzo0N1rOGl56mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM5NzUyMw==", "bodyText": "trivial cleanup", "url": "https://github.com/apache/kafka/pull/8896#discussion_r442397523", "createdAt": "2020-06-18T17:44:31Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -415,19 +418,20 @@ public void restore() {\n                 // for restoring active and updating standby we may prefer different poll time\n                 // in order to make sure we call the main consumer#poll in time.\n                 // TODO: once we move ChangelogReader to a separate thread this may no longer be a concern\n-                polledRecords = restoreConsumer.poll(state.equals(ChangelogReaderState.STANDBY_UPDATING) ? Duration.ZERO : pollTime);\n+                polledRecords = restoreConsumer.poll(state == ChangelogReaderState.STANDBY_UPDATING ? Duration.ZERO : pollTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM5ODI2OA==", "bodyText": "Added the exception itself as the \"cause\" of the warning. The actual message of the IOE is actually pretty good at explaining the root cause.", "url": "https://github.com/apache/kafka/pull/8896#discussion_r442398268", "createdAt": "2020-06-18T17:45:49Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -415,19 +418,20 @@ public void restore() {\n                 // for restoring active and updating standby we may prefer different poll time\n                 // in order to make sure we call the main consumer#poll in time.\n                 // TODO: once we move ChangelogReader to a separate thread this may no longer be a concern\n-                polledRecords = restoreConsumer.poll(state.equals(ChangelogReaderState.STANDBY_UPDATING) ? Duration.ZERO : pollTime);\n+                polledRecords = restoreConsumer.poll(state == ChangelogReaderState.STANDBY_UPDATING ? Duration.ZERO : pollTime);\n             } catch (final InvalidOffsetException e) {\n-                log.warn(\"Encountered {} fetching records from restore consumer for partitions {}, it is likely that \" +\n+                log.warn(\"Encountered \" + e.getClass().getName() +\n+                    \" fetching records from restore consumer for partitions \" + e.partitions() + \", it is likely that \" +\n                     \"the consumer's position has fallen out of the topic partition offset range because the topic was \" +\n                     \"truncated or compacted on the broker, marking the corresponding tasks as corrupted and re-initializing\" +\n-                    \" it later.\", e.getClass().getName(), e.partitions());\n+                    \" it later.\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM5ODQzMw==", "bodyText": "Also added the cause to the thrown exception.", "url": "https://github.com/apache/kafka/pull/8896#discussion_r442398433", "createdAt": "2020-06-18T17:46:06Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -415,19 +418,20 @@ public void restore() {\n                 // for restoring active and updating standby we may prefer different poll time\n                 // in order to make sure we call the main consumer#poll in time.\n                 // TODO: once we move ChangelogReader to a separate thread this may no longer be a concern\n-                polledRecords = restoreConsumer.poll(state.equals(ChangelogReaderState.STANDBY_UPDATING) ? Duration.ZERO : pollTime);\n+                polledRecords = restoreConsumer.poll(state == ChangelogReaderState.STANDBY_UPDATING ? Duration.ZERO : pollTime);\n             } catch (final InvalidOffsetException e) {\n-                log.warn(\"Encountered {} fetching records from restore consumer for partitions {}, it is likely that \" +\n+                log.warn(\"Encountered \" + e.getClass().getName() +\n+                    \" fetching records from restore consumer for partitions \" + e.partitions() + \", it is likely that \" +\n                     \"the consumer's position has fallen out of the topic partition offset range because the topic was \" +\n                     \"truncated or compacted on the broker, marking the corresponding tasks as corrupted and re-initializing\" +\n-                    \" it later.\", e.getClass().getName(), e.partitions());\n+                    \" it later.\", e);\n \n                 final Map<TaskId, Collection<TopicPartition>> taskWithCorruptedChangelogs = new HashMap<>();\n                 for (final TopicPartition partition : e.partitions()) {\n                     final TaskId taskId = changelogs.get(partition).stateManager.taskId();\n                     taskWithCorruptedChangelogs.computeIfAbsent(taskId, k -> new HashSet<>()).add(partition);\n                 }\n-                throw new TaskCorruptedException(taskWithCorruptedChangelogs);\n+                throw new TaskCorruptedException(taskWithCorruptedChangelogs, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM5OTM4Ng==", "bodyText": "This is the main change. Once every ten seconds, we will log the progress for each active restoring changelog.", "url": "https://github.com/apache/kafka/pull/8896#discussion_r442399386", "createdAt": "2020-06-18T17:47:47Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -446,6 +450,38 @@ public void restore() {\n             }\n \n             maybeUpdateLimitOffsetsForStandbyChangelogs();\n+\n+            maybeLogRestorationProgress();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjgxODIw", "url": "https://github.com/apache/kafka/pull/8896#pullrequestreview-433681820", "createdAt": "2020-06-18T22:11:23Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjoxMToyM1rOGmB4tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjoxMToyM1rOGmB4tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyOTk3NQ==", "bodyText": "I've rolled back a bunch of accidental formatting changes, but left the ones that are actually code style compliance issues (like using brackets around conditional bodies).", "url": "https://github.com/apache/kafka/pull/8896#discussion_r442529975", "createdAt": "2020-06-18T22:11:23Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -496,8 +539,9 @@ private void bufferChangelogRecords(final ChangelogMetadata changelogMetadata, f\n             } else {\n                 changelogMetadata.bufferedRecords.add(record);\n                 final long offset = record.offset();\n-                if (changelogMetadata.restoreEndOffset == null || offset < changelogMetadata.restoreEndOffset)\n+                if (changelogMetadata.restoreEndOffset == null || offset < changelogMetadata.restoreEndOffset) {\n                     changelogMetadata.bufferedLimitIndex = changelogMetadata.bufferedRecords.size();\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjgzNTM2", "url": "https://github.com/apache/kafka/pull/8896#pullrequestreview-433683536", "createdAt": "2020-06-18T22:15:17Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjoxNToxN1rOGmB95A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjoxNToxN1rOGmB95A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMTMwMA==", "bodyText": "This is moderately obnoxious... The addition of logging these values means that these tests will get a NullPointerException unless we mock this call, but the mock is irrelevant to the test outcome.", "url": "https://github.com/apache/kafka/pull/8896#discussion_r442531300", "createdAt": "2020-06-18T22:15:17Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StoreChangelogReaderTest.java", "diffHunk": "@@ -223,6 +227,7 @@ public void shouldInitializeChangelogAndCheckForCompletion() {\n     @Test\n     public void shouldPollWithRightTimeout() {\n         EasyMock.expect(storeMetadata.offset()).andReturn(null).andReturn(9L).anyTimes();\n+        EasyMock.expect(stateManager.changelogOffsets()).andReturn(singletonMap(tp, 5L));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6431b199f51feb7a4fc92b446780d85721e56879", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/6431b199f51feb7a4fc92b446780d85721e56879", "committedDate": "2020-06-18T22:19:48Z", "message": "KAFKA-10185: Restoration info logging"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MTk1MzU5", "url": "https://github.com/apache/kafka/pull/8896#pullrequestreview-434195359", "createdAt": "2020-06-19T16:11:32Z", "commit": {"oid": "6431b199f51feb7a4fc92b446780d85721e56879"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNjoxMTozMlrOGmaM5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNjoxOTozOFrOGmaa1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkyODM1OQ==", "bodyText": "The exception message may not always contain the partitions() list, maybe we should still print that as part of warn log?", "url": "https://github.com/apache/kafka/pull/8896#discussion_r442928359", "createdAt": "2020-06-19T16:11:32Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -415,19 +418,20 @@ public void restore() {\n                 // for restoring active and updating standby we may prefer different poll time\n                 // in order to make sure we call the main consumer#poll in time.\n                 // TODO: once we move ChangelogReader to a separate thread this may no longer be a concern\n-                polledRecords = restoreConsumer.poll(state.equals(ChangelogReaderState.STANDBY_UPDATING) ? Duration.ZERO : pollTime);\n+                polledRecords = restoreConsumer.poll(state == ChangelogReaderState.STANDBY_UPDATING ? Duration.ZERO : pollTime);\n             } catch (final InvalidOffsetException e) {\n-                log.warn(\"Encountered {} fetching records from restore consumer for partitions {}, it is likely that \" +\n+                log.warn(\"Encountered \" + e.getClass().getName() +\n+                    \" fetching records from restore consumer for partitions \" + e.partitions() + \", it is likely that \" +\n                     \"the consumer's position has fallen out of the topic partition offset range because the topic was \" +\n                     \"truncated or compacted on the broker, marking the corresponding tasks as corrupted and re-initializing\" +\n-                    \" it later.\", e.getClass().getName(), e.partitions());\n+                    \" it later.\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM5ODI2OA=="}, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkzMTM1Ng==", "bodyText": "nit: should we have a newline for each partition? Otherwise that ling maybe too long.", "url": "https://github.com/apache/kafka/pull/8896#discussion_r442931356", "createdAt": "2020-06-19T16:18:20Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -458,9 +462,48 @@ public void restore() {\n             }\n \n             maybeUpdateLimitOffsetsForStandbyChangelogs();\n+\n+            maybeLogRestorationProgress();\n+        }\n+    }\n+\n+    private void maybeLogRestorationProgress() {\n+        if (state == ChangelogReaderState.ACTIVE_RESTORING) {\n+            if (time.milliseconds() - lastRestoreLogTime > RESTORE_LOG_INTERVAL_MS) {\n+                final Set<TopicPartition> topicPartitions = activeRestoringChangelogs();\n+                if (!topicPartitions.isEmpty()) {\n+                    final StringBuilder builder = new StringBuilder().append(\"Restoration in progress for \")\n+                                                                     .append(topicPartitions.size())\n+                                                                     .append(\" partitions.\");\n+                    for (final TopicPartition partition : topicPartitions) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6431b199f51feb7a4fc92b446780d85721e56879"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkzMTkyNA==", "bodyText": "This comment seems worth adding to the code :)", "url": "https://github.com/apache/kafka/pull/8896#discussion_r442931924", "createdAt": "2020-06-19T16:19:38Z", "author": {"login": "guozhangwang"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StoreChangelogReaderTest.java", "diffHunk": "@@ -223,6 +227,7 @@ public void shouldInitializeChangelogAndCheckForCompletion() {\n     @Test\n     public void shouldPollWithRightTimeout() {\n         EasyMock.expect(storeMetadata.offset()).andReturn(null).andReturn(9L).anyTimes();\n+        EasyMock.expect(stateManager.changelogOffsets()).andReturn(singletonMap(tp, 5L));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMTMwMA=="}, "originalCommit": null, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 669, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}