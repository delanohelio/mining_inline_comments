{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5Mzc4MDUx", "number": 8164, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMToyNTo1OVrODo5NLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjo1NzoxOFrODrAGkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MjA2ODkzOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionCoordinator.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMToyNTo1OVrOF3uotQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMToyNTo1OVrOF3uotQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk4MDA4NQ==", "bodyText": "I think reusing handleEndTransaction to handle coordinator aborts has always been a little confusing. As an alternative, we could move the logic here to an internal helper, maybe just named endTransaction. Then we can assume calls from handleEndTransaction are from the client.", "url": "https://github.com/apache/kafka/pull/8164#discussion_r393980085", "createdAt": "2020-03-17T21:25:59Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionCoordinator.scala", "diffHunk": "@@ -351,6 +352,7 @@ class TransactionCoordinator(brokerId: Int,\n                            producerId: Long,\n                            producerEpoch: Short,\n                            txnMarkerResult: TransactionResult,\n+                           fromClient: Boolean,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MjA4MDAwOnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/coordinator/transaction/TransactionCoordinatorTest.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMToyOTozOVrOF3uvmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMToyOTozOVrOF3uvmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk4MTg0OA==", "bodyText": "At a quick glance, these tests look basically the same except for the epoch which is sent and the expected error. Is it possible to factor out a helper?", "url": "https://github.com/apache/kafka/pull/8164#discussion_r393981848", "createdAt": "2020-03-17T21:29:39Z", "author": {"login": "hachikuji"}, "path": "core/src/test/scala/unit/kafka/coordinator/transaction/TransactionCoordinatorTest.scala", "diffHunk": "@@ -495,10 +495,62 @@ class TransactionCoordinatorTest {\n \n     EasyMock.replay(transactionManager)\n \n-    coordinator.handleEndTransaction(transactionalId, 0, 0, TransactionResult.COMMIT, errorsCallback)\n+    coordinator.handleEndTransaction(transactionalId, 0, 0, TransactionResult.COMMIT, false, errorsCallback)\n     assertEquals(Errors.COORDINATOR_LOAD_IN_PROGRESS, error)\n   }\n \n+  @Test\n+  def shouldReturnInvalidEpochWhenEndTxnIsFromClientAndEpochIsLarger(): Unit = {\n+    val serverProducerEpoch = 1.toShort", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTIxODExOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionCoordinator.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjo0NzowOVrOF4N6Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxNjo0NzowOVrOF4N6Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5MjQyMw==", "bodyText": "This is a little awkward. I think the isFromClient flag was easier to understand and avoided the need to duplicate the check in a couple places.", "url": "https://github.com/apache/kafka/pull/8164#discussion_r394492423", "createdAt": "2020-03-18T16:47:09Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionCoordinator.scala", "diffHunk": "@@ -352,6 +353,21 @@ class TransactionCoordinator(brokerId: Int,\n                            producerEpoch: Short,\n                            txnMarkerResult: TransactionResult,\n                            responseCallback: EndTxnCallback): Unit = {\n+    endTransaction(transactionalId,\n+      producerId,\n+      producerEpoch,\n+      txnMarkerResult,\n+      // Strict equality is enforced on the client side requests, as they shouldn't bump the producer epoch.\n+      (producerEpoch, txnMetadata) => producerEpoch != txnMetadata.producerEpoch,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDE1ODMwOnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/coordinator/transaction/TransactionCoordinatorTest.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMDoyNDo0MFrOF4_HsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwMTo0MTowMVrOF5FpIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5ODczNg==", "bodyText": "Tests which capture logging output tend to be brittle. Would it be more direct to call abortTimedOutTransactions directly?", "url": "https://github.com/apache/kafka/pull/8164#discussion_r395298736", "createdAt": "2020-03-19T20:24:40Z", "author": {"login": "hachikuji"}, "path": "core/src/test/scala/unit/kafka/coordinator/transaction/TransactionCoordinatorTest.scala", "diffHunk": "@@ -842,6 +897,43 @@ class TransactionCoordinatorTest {\n     EasyMock.verify(transactionManager)\n   }\n \n+  @Test\n+  def shouldNotAcceptSmallerEpochDuringTransactionExpiration(): Unit = {\n+    val now = time.milliseconds()\n+    val txnMetadata = new TransactionMetadata(transactionalId, producerId, producerId, producerEpoch,\n+      RecordBatch.NO_PRODUCER_EPOCH, txnTimeoutMs, Ongoing, partitions, now, now)\n+\n+    EasyMock.expect(transactionManager.timedOutTransactions())\n+      .andReturn(List(TransactionalIdAndProducerIdEpoch(transactionalId, producerId, producerEpoch)))\n+    EasyMock.expect(transactionManager.getTransactionState(EasyMock.eq(transactionalId)))\n+      .andReturn(Right(Some(CoordinatorEpochAndTxnMetadata(coordinatorEpoch, txnMetadata))))\n+\n+    val bumpedTxnMetadata = new TransactionMetadata(transactionalId, producerId, producerId, (producerEpoch + 2).toShort,\n+      RecordBatch.NO_PRODUCER_EPOCH, txnTimeoutMs, Ongoing, partitions, now, now)\n+    EasyMock.expect(transactionManager.getTransactionState(EasyMock.eq(transactionalId)))\n+      .andReturn(Right(Some(CoordinatorEpochAndTxnMetadata(coordinatorEpoch, bumpedTxnMetadata))))\n+\n+    val appender = LogCaptureAppender.createAndRegister()\n+    LogCaptureAppender.setClassLoggerLevel(coordinator.getClass, Level.DEBUG)\n+    try {\n+\n+      EasyMock.replay(transactionManager, transactionMarkerChannelManager)\n+\n+      coordinator.startup(false)\n+      time.sleep(TransactionStateManager.DefaultAbortTimedOutTransactionsIntervalMs)\n+      scheduler.tick()\n+      EasyMock.verify(transactionManager)\n+\n+      val event = appender.getMessages.find(e => e.getMessage.equals(\"Rollback of \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQwNTYwMg==", "bodyText": "The tricky thing is abortTimedOutTransactions is private and we don't want to expose a function just for testing purpose I guess?", "url": "https://github.com/apache/kafka/pull/8164#discussion_r395405602", "createdAt": "2020-03-20T01:41:01Z", "author": {"login": "abbccdda"}, "path": "core/src/test/scala/unit/kafka/coordinator/transaction/TransactionCoordinatorTest.scala", "diffHunk": "@@ -842,6 +897,43 @@ class TransactionCoordinatorTest {\n     EasyMock.verify(transactionManager)\n   }\n \n+  @Test\n+  def shouldNotAcceptSmallerEpochDuringTransactionExpiration(): Unit = {\n+    val now = time.milliseconds()\n+    val txnMetadata = new TransactionMetadata(transactionalId, producerId, producerId, producerEpoch,\n+      RecordBatch.NO_PRODUCER_EPOCH, txnTimeoutMs, Ongoing, partitions, now, now)\n+\n+    EasyMock.expect(transactionManager.timedOutTransactions())\n+      .andReturn(List(TransactionalIdAndProducerIdEpoch(transactionalId, producerId, producerEpoch)))\n+    EasyMock.expect(transactionManager.getTransactionState(EasyMock.eq(transactionalId)))\n+      .andReturn(Right(Some(CoordinatorEpochAndTxnMetadata(coordinatorEpoch, txnMetadata))))\n+\n+    val bumpedTxnMetadata = new TransactionMetadata(transactionalId, producerId, producerId, (producerEpoch + 2).toShort,\n+      RecordBatch.NO_PRODUCER_EPOCH, txnTimeoutMs, Ongoing, partitions, now, now)\n+    EasyMock.expect(transactionManager.getTransactionState(EasyMock.eq(transactionalId)))\n+      .andReturn(Right(Some(CoordinatorEpochAndTxnMetadata(coordinatorEpoch, bumpedTxnMetadata))))\n+\n+    val appender = LogCaptureAppender.createAndRegister()\n+    LogCaptureAppender.setClassLoggerLevel(coordinator.getClass, Level.DEBUG)\n+    try {\n+\n+      EasyMock.replay(transactionManager, transactionMarkerChannelManager)\n+\n+      coordinator.startup(false)\n+      time.sleep(TransactionStateManager.DefaultAbortTimedOutTransactionsIntervalMs)\n+      scheduler.tick()\n+      EasyMock.verify(transactionManager)\n+\n+      val event = appender.getMessages.find(e => e.getMessage.equals(\"Rollback of \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5ODczNg=="}, "originalCommit": null, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NDE3MDQyOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionCoordinator.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjo1NzoxOFrOF7GLDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMjo1NzoxOFrOF7GLDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUxMTQzNg==", "bodyText": "Can this be private?", "url": "https://github.com/apache/kafka/pull/8164#discussion_r397511436", "createdAt": "2020-03-24T22:57:18Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionCoordinator.scala", "diffHunk": "@@ -500,24 +516,25 @@ class TransactionCoordinator(brokerId: Int,\n \n   def partitionFor(transactionalId: String): Int = txnManager.partitionFor(transactionalId)\n \n-  private def abortTimedOutTransactions(): Unit = {\n-    def onComplete(txnIdAndPidEpoch: TransactionalIdAndProducerIdEpoch)(error: Errors): Unit = {\n-      error match {\n-        case Errors.NONE =>\n-          info(\"Completed rollback of ongoing transaction for transactionalId \" +\n-            s\"${txnIdAndPidEpoch.transactionalId} due to timeout\")\n-\n-        case error@(Errors.INVALID_PRODUCER_ID_MAPPING |\n-                    Errors.INVALID_PRODUCER_EPOCH |\n-                    Errors.CONCURRENT_TRANSACTIONS) =>\n-          debug(s\"Rollback of ongoing transaction for transactionalId ${txnIdAndPidEpoch.transactionalId} \" +\n-            s\"has been cancelled due to error $error\")\n-\n-        case error =>\n-          warn(s\"Rollback of ongoing transaction for transactionalId ${txnIdAndPidEpoch.transactionalId} \" +\n-            s\"failed due to error $error\")\n-      }\n+  def onEndTransactionComplete(txnIdAndPidEpoch: TransactionalIdAndProducerIdEpoch)(error: Errors): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43dad623a744f3d3564a938af6ced0e3e103118c"}, "originalPosition": 65}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4083, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}