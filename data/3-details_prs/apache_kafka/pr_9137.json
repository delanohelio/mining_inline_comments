{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0Njk2NzYx", "number": 9137, "title": "KAFKA-9929: Support reverse iterator on KeyValueStore", "bodyText": "Implements KIP-617 on KeyValueStore.\nTesting strategy: extend existing tests to validate reverse operations are supported.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-08-07T16:20:51Z", "url": "https://github.com/apache/kafka/pull/9137", "merged": true, "mergeCommit": {"oid": "89d06780a0f5f27a7420fc2cd8063294367f6693"}, "closed": true, "closedAt": "2020-08-22T01:29:41Z", "author": {"login": "jeqo"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc99GU_gFqTQ2NTMxMTYyMQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdBPGKaAFqTQ3Mjg4NjA2MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MzExNjIx", "url": "https://github.com/apache/kafka/pull/9137#pullrequestreview-465311621", "createdAt": "2020-08-11T18:12:54Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxODoxMjo1NVrOG_DjBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMDo0MTozNVrOG_IeFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3MTU4OQ==", "bodyText": "Seems a bit tricky to say that to is the variable where iteration starts from \ud83d\ude09  But I can see it both ways, so being clear in the javadocs is good enough for me", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468771589", "createdAt": "2020-08-11T18:12:55Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/ReadOnlyKeyValueStore.java", "diffHunk": "@@ -38,35 +38,68 @@\n      *\n      * @param key The key to fetch\n      * @return The value or null if no value is found.\n-     * @throws NullPointerException If null is used for key.\n+     * @throws NullPointerException       If null is used for key.\n      * @throws InvalidStateStoreException if the store is not initialized\n      */\n     V get(K key);\n \n     /**\n      * Get an iterator over a given range of keys. This iterator must be closed after use.\n      * The returned iterator must be safe from {@link java.util.ConcurrentModificationException}s\n-     * and must not return null values. No ordering guarantees are provided.\n-     * @param from The first key that could be in the range\n-     * @param to The last key that could be in the range\n-     * @return The iterator for this range.\n-     * @throws NullPointerException If null is used for from or to.\n+     * and must not return null values.\n+     * Order is not guaranteed as bytes lexicographical ordering might not represent key order.\n+     *\n+     * @param from The first key that could be in the range, where iteration starts from.\n+     * @param to   The last key that could be in the range, where iteration ends.\n+     * @return The iterator for this range, from smallest to largest bytes.\n+     * @throws NullPointerException       If null is used for from or to.\n      * @throws InvalidStateStoreException if the store is not initialized\n      */\n     KeyValueIterator<K, V> range(K from, K to);\n \n+    /**\n+     * Get a reverse iterator over a given range of keys. This iterator must be closed after use.\n+     * The returned iterator must be safe from {@link java.util.ConcurrentModificationException}s\n+     * and must not return null values.\n+     * Order is not guaranteed as bytes lexicographical ordering might not represent key order.\n+     *\n+     * @param from The first key that could be in the range, where iteration ends.\n+     * @param to   The last key that could be in the range, where iteration starts from.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4MTAxMw==", "bodyText": "Should be private", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468781013", "createdAt": "2020-08-11T18:29:54Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/InMemoryKeyValueStore.java", "diffHunk": "@@ -110,7 +111,15 @@ public void putAll(final List<KeyValue<Bytes, byte[]>> entries) {\n \n     @Override\n     public synchronized KeyValueIterator<Bytes, byte[]> range(final Bytes from, final Bytes to) {\n+        return range(from, to, false);\n+    }\n+\n+    @Override\n+    public KeyValueIterator<Bytes, byte[]> reverseRange(final Bytes from, final Bytes to) {\n+        return range(from, to, true);\n+    }\n \n+    KeyValueIterator<Bytes, byte[]> range(final Bytes from, final Bytes to, final boolean reverse) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc4MTgyNg==", "bodyText": "nit: Use braces & separate lines", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468781826", "createdAt": "2020-08-11T18:31:29Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/InMemoryKeyValueStore.java", "diffHunk": "@@ -150,8 +166,9 @@ public void close() {\n     private class InMemoryKeyValueIterator implements KeyValueIterator<Bytes, byte[]> {\n         private final Iterator<Bytes> iter;\n \n-        private InMemoryKeyValueIterator(final Set<Bytes> keySet) {\n-            this.iter = new TreeSet<>(keySet).iterator();\n+        private InMemoryKeyValueIterator(final Set<Bytes> keySet, final boolean reverse) {\n+            if (reverse) this.iter = new TreeSet<>(keySet).descendingIterator();\n+            else this.iter = new TreeSet<>(keySet).iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgzMTIwMA==", "bodyText": "nit: braces + separate lines", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468831200", "createdAt": "2020-08-11T20:00:40Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/NamedCache.java", "diffHunk": "@@ -281,15 +281,24 @@ public boolean isEmpty() {\n     }\n \n     synchronized Iterator<Bytes> keyRange(final Bytes from, final Bytes to) {\n-        return keySetIterator(cache.navigableKeySet().subSet(from, true, to, true));\n+        return keySetIterator(cache.navigableKeySet().subSet(from, true, to, true), false);\n     }\n \n-    private Iterator<Bytes> keySetIterator(final Set<Bytes> keySet) {\n-        return new TreeSet<>(keySet).iterator();\n+    synchronized Iterator<Bytes> reverseKeyRange(final Bytes from, final Bytes to) {\n+        return keySetIterator(cache.navigableKeySet().subSet(from, true, to, true), true);\n+    }\n+\n+    private Iterator<Bytes> keySetIterator(final Set<Bytes> keySet, final boolean reverse) {\n+        if (reverse) return new TreeSet<>(keySet).descendingIterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0MTc1Nw==", "bodyText": "nit: RawToKey --> RawLastKey", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468841757", "createdAt": "2020-08-11T20:21:59Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBRangeIterator.java", "diffHunk": "@@ -29,32 +29,41 @@\n     // comparator to be pluggable, and the default is lexicographic, so it's\n     // safe to just force lexicographic comparator here for now.\n     private final Comparator<byte[]> comparator = Bytes.BYTES_LEXICO_COMPARATOR;\n-    private final byte[] rawToKey;\n+    private final byte[] rawLastKey;\n+    private final boolean reverse;\n \n     RocksDBRangeIterator(final String storeName,\n                          final RocksIterator iter,\n                          final Set<KeyValueIterator<Bytes, byte[]>> openIterators,\n                          final Bytes from,\n-                         final Bytes to) {\n-        super(storeName, iter, openIterators);\n-        iter.seek(from.get());\n-        rawToKey = to.get();\n-        if (rawToKey == null) {\n+                         final Bytes to,\n+                         final boolean reverse) {\n+        super(storeName, iter, openIterators, reverse);\n+        this.reverse = reverse;\n+        if (reverse) {\n+            iter.seekForPrev(to.get());\n+            rawLastKey = from.get();\n+        } else {\n+            iter.seek(from.get());\n+            rawLastKey = to.get();\n+        }\n+        if (rawLastKey == null) {\n             throw new NullPointerException(\"RocksDBRangeIterator: RawToKey is null for key \" + to);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0MjE5OQ==", "bodyText": "Also it should be from for the reverse case, right?", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468842199", "createdAt": "2020-08-11T20:22:46Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBRangeIterator.java", "diffHunk": "@@ -29,32 +29,41 @@\n     // comparator to be pluggable, and the default is lexicographic, so it's\n     // safe to just force lexicographic comparator here for now.\n     private final Comparator<byte[]> comparator = Bytes.BYTES_LEXICO_COMPARATOR;\n-    private final byte[] rawToKey;\n+    private final byte[] rawLastKey;\n+    private final boolean reverse;\n \n     RocksDBRangeIterator(final String storeName,\n                          final RocksIterator iter,\n                          final Set<KeyValueIterator<Bytes, byte[]>> openIterators,\n                          final Bytes from,\n-                         final Bytes to) {\n-        super(storeName, iter, openIterators);\n-        iter.seek(from.get());\n-        rawToKey = to.get();\n-        if (rawToKey == null) {\n+                         final Bytes to,\n+                         final boolean reverse) {\n+        super(storeName, iter, openIterators, reverse);\n+        this.reverse = reverse;\n+        if (reverse) {\n+            iter.seekForPrev(to.get());\n+            rawLastKey = from.get();\n+        } else {\n+            iter.seek(from.get());\n+            rawLastKey = to.get();\n+        }\n+        if (rawLastKey == null) {\n             throw new NullPointerException(\"RocksDBRangeIterator: RawToKey is null for key \" + to);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0MTc1Nw=="}, "originalCommit": null, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0MjQ1OQ==", "bodyText": "nit: braces & separate lines", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468842459", "createdAt": "2020-08-11T20:23:20Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBRangeIterator.java", "diffHunk": "@@ -29,32 +29,41 @@\n     // comparator to be pluggable, and the default is lexicographic, so it's\n     // safe to just force lexicographic comparator here for now.\n     private final Comparator<byte[]> comparator = Bytes.BYTES_LEXICO_COMPARATOR;\n-    private final byte[] rawToKey;\n+    private final byte[] rawLastKey;\n+    private final boolean reverse;\n \n     RocksDBRangeIterator(final String storeName,\n                          final RocksIterator iter,\n                          final Set<KeyValueIterator<Bytes, byte[]>> openIterators,\n                          final Bytes from,\n-                         final Bytes to) {\n-        super(storeName, iter, openIterators);\n-        iter.seek(from.get());\n-        rawToKey = to.get();\n-        if (rawToKey == null) {\n+                         final Bytes to,\n+                         final boolean reverse) {\n+        super(storeName, iter, openIterators, reverse);\n+        this.reverse = reverse;\n+        if (reverse) {\n+            iter.seekForPrev(to.get());\n+            rawLastKey = from.get();\n+        } else {\n+            iter.seek(from.get());\n+            rawLastKey = to.get();\n+        }\n+        if (rawLastKey == null) {\n             throw new NullPointerException(\"RocksDBRangeIterator: RawToKey is null for key \" + to);\n         }\n     }\n \n     @Override\n     public KeyValue<Bytes, byte[]> makeNext() {\n         final KeyValue<Bytes, byte[]> next = super.makeNext();\n-\n         if (next == null) {\n             return allDone();\n         } else {\n-            if (comparator.compare(next.key.get(), rawToKey) <= 0) {\n-                return next;\n+            if (!reverse) {\n+                if (comparator.compare(next.key.get(), rawLastKey) <= 0) return next;\n+                else return allDone();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0MzE3OA==", "bodyText": "braces & separate lines", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468843178", "createdAt": "2020-08-11T20:24:41Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBTimestampedStore.java", "diffHunk": "@@ -193,22 +193,26 @@ public void prepareBatch(final List<KeyValue<Bytes, byte[]>> entries,\n \n         @Override\n         public KeyValueIterator<Bytes, byte[]> range(final Bytes from,\n-                                                     final Bytes to) {\n+                                                     final Bytes to,\n+                                                     final boolean reverse) {\n             return new RocksDBDualCFRangeIterator(\n                 name,\n                 db.newIterator(newColumnFamily),\n                 db.newIterator(oldColumnFamily),\n                 from,\n-                to);\n+                to,\n+                reverse);\n         }\n \n         @Override\n-        public KeyValueIterator<Bytes, byte[]> all() {\n+        public KeyValueIterator<Bytes, byte[]> all(final boolean reverse) {\n             final RocksIterator innerIterWithTimestamp = db.newIterator(newColumnFamily);\n-            innerIterWithTimestamp.seekToFirst();\n+            if (reverse) innerIterWithTimestamp.seekToLast();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0MzQ2NQ==", "bodyText": "separate lines \ud83d\ude42", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468843465", "createdAt": "2020-08-11T20:25:18Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDbIterator.java", "diffHunk": "@@ -58,7 +61,8 @@ public synchronized boolean hasNext() {\n             return allDone();\n         } else {\n             next = getKeyValue();\n-            iter.next();\n+            if (reverse) iter.prev();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0MzczNw==", "bodyText": "braces & separate lines here and below", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468843737", "createdAt": "2020-08-11T20:25:49Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBTimestampedStore.java", "diffHunk": "@@ -306,26 +313,29 @@ public synchronized boolean hasNext() {\n                 } else {\n                     next = KeyValue.pair(new Bytes(nextWithTimestamp), iterWithTimestamp.value());\n                     nextWithTimestamp = null;\n-                    iterWithTimestamp.next();\n+                    if (reverse) iterWithTimestamp.prev();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0NzQ3Nw==", "bodyText": "Can we add tests for some other invalid range cases? For example with both bounds positive but from > to", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468847477", "createdAt": "2020-08-11T20:31:45Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/AbstractKeyValueStoreTest.java", "diffHunk": "@@ -422,6 +503,21 @@ public void shouldNotThrowInvalidRangeExceptionWithNegativeFromKey() {\n                     \" Note that the built-in numerical serdes do not follow this for negative numbers\")\n             );\n         }\n+    }\n+\n+    @Test\n+    public void shouldNotThrowInvalidReverseRangeExceptionWithNegativeFromKey() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0ODMwNQ==", "bodyText": "Can we add some tests that verify the actual contents + order of the reverse range?", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468848305", "createdAt": "2020-08-11T20:33:24Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CachingKeyValueStoreTest.java", "diffHunk": "@@ -294,13 +305,27 @@ public void shouldIterateOverRange() {\n         assertEquals(items, results.size());\n     }\n \n+    @Test\n+    public void shouldReverseIterateOverRange() {\n+        final int items = addItemsToCache();\n+        final KeyValueIterator<Bytes, byte[]> range =\n+            store.reverseRange(bytesKey(String.valueOf(0)), bytesKey(String.valueOf(items)));\n+        final List<Bytes> results = new ArrayList<>();\n+        while (range.hasNext()) {\n+            results.add(range.next().key);\n+        }\n+        assertEquals(items, results.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0OTE0NQ==", "bodyText": "Use assertThrows -- we've been (slowly) migrating away from @Test(expected) in the Streams tests", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468849145", "createdAt": "2020-08-11T20:35:15Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CachingKeyValueStoreTest.java", "diffHunk": "@@ -339,12 +366,24 @@ public void shouldThrowIfTryingToDoRangeQueryOnClosedCachingStore() {\n         store.range(bytesKey(\"a\"), bytesKey(\"b\"));\n     }\n \n+    @Test(expected = InvalidStateStoreException.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0OTQ1Mw==", "bodyText": "use assertThrows here as well", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468849453", "createdAt": "2020-08-11T20:35:58Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CompositeReadOnlyKeyValueStoreTest.java", "diffHunk": "@@ -150,6 +161,17 @@ public void shouldThrowUnsupportedOperationExceptionWhileRemove() {\n         } catch (final UnsupportedOperationException e) { }\n     }\n \n+    @Test\n+    public void shouldThrowUnsupportedOperationExceptionWhileReverseRange() {\n+        stubOneUnderlying.put(\"a\", \"1\");\n+        stubOneUnderlying.put(\"b\", \"1\");\n+        final KeyValueIterator<String, String> keyValueIterator = theStore.reverseRange(\"a\", \"b\");\n+        try {\n+            keyValueIterator.remove();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg1MjI0NQ==", "bodyText": "I think the best we can do is just make sure that order is correct within a store. ie if a, m are all in stubOneUnderling then make sure the reverse range returns m before a.\nI also think it would be fine to just make sure all the expected values are returned without checking the order, since there are other tests to verify that the order within a store is correct", "url": "https://github.com/apache/kafka/pull/9137#discussion_r468852245", "createdAt": "2020-08-11T20:41:35Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CompositeReadOnlyKeyValueStoreTest.java", "diffHunk": "@@ -199,11 +236,44 @@ public void shouldSupportRangeAcrossMultipleKVStores() {\n         cache.put(\"x\", \"x\");\n \n         final List<KeyValue<String, String>> results = toList(theStore.range(\"a\", \"e\"));\n+        assertArrayEquals(\n+            asList(\n+                new KeyValue<>(\"a\", \"a\"),\n+                new KeyValue<>(\"b\", \"b\"),\n+                new KeyValue<>(\"c\", \"c\"),\n+                new KeyValue<>(\"d\", \"d\")\n+            ).toArray(),\n+            results.toArray());\n+    }\n+\n+    @Test\n+    public void shouldSupportReverseRangeAcrossMultipleKVStores() {\n+        final KeyValueStore<String, String> cache = newStoreInstance();\n+        stubProviderTwo.addStore(storeName, cache);\n+\n+        stubOneUnderlying.put(\"a\", \"a\");\n+        stubOneUnderlying.put(\"b\", \"b\");\n+        stubOneUnderlying.put(\"z\", \"z\");\n+\n+        cache.put(\"c\", \"c\");\n+        cache.put(\"d\", \"d\");\n+        cache.put(\"x\", \"x\");\n+\n+        final List<KeyValue<String, String>> results = toList(theStore.reverseRange(\"a\", \"e\"));\n         assertTrue(results.contains(new KeyValue<>(\"a\", \"a\")));\n         assertTrue(results.contains(new KeyValue<>(\"b\", \"b\")));\n         assertTrue(results.contains(new KeyValue<>(\"c\", \"c\")));\n         assertTrue(results.contains(new KeyValue<>(\"d\", \"d\")));\n         assertEquals(4, results.size());\n+        //FIXME: order does not hold between stores, how to validate order here?", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 98}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MjE2Mjcx", "url": "https://github.com/apache/kafka/pull/9137#pullrequestreview-467216271", "createdAt": "2020-08-13T23:56:52Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMzo1Njo1MlrOHAhglg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMToyNzowN1rOHAkmfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMxMTA2Mg==", "bodyText": "This class is still unused so maybe we should just take it out. Someone's working on a prefix seek KIP at the moment so it'll be replaced soon anyway", "url": "https://github.com/apache/kafka/pull/9137#discussion_r470311062", "createdAt": "2020-08-13T23:56:52Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBPrefixIterator.java", "diffHunk": "@@ -29,7 +29,7 @@\n                           final RocksIterator newIterator,\n                           final Set<KeyValueIterator<Bytes, byte[]>> openIterators,\n                           final Bytes prefix) {\n-        super(name, newIterator, openIterators);\n+        super(name, newIterator, openIterators, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMzODI0NA==", "bodyText": "We need to branch on reverse here too, right?", "url": "https://github.com/apache/kafka/pull/9137#discussion_r470338244", "createdAt": "2020-08-14T00:42:57Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBTimestampedStore.java", "diffHunk": "@@ -374,7 +412,7 @@ public Bytes peekNextKey() {\n             if (next == null) {\n                 return allDone();\n             } else {\n-                if (comparator.compare(next.key.get(), upperBoundKey) <= 0) {\n+                if (comparator.compare(next.key.get(), lastKey) <= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM0NTUxMw==", "bodyText": "Kind of unrelated, but WDYT about renaming RocksDBDualCFIterator to RocksDBDualCFAllIterator or something on the side? I feel like these iterators could be cleaned up a bit in general to be more understandable -- for example, it's weird that we do the iterator#seek-ing in the actual all() method but for range queries we do the seeking inside the iterator constructor.\nJust thinking out loud though, we can do some followup refactoring once this is merged", "url": "https://github.com/apache/kafka/pull/9137#discussion_r470345513", "createdAt": "2020-08-14T00:53:56Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBTimestampedStore.java", "diffHunk": "@@ -374,7 +412,7 @@ public Bytes peekNextKey() {\n             if (next == null) {\n                 return allDone();\n             } else {\n-                if (comparator.compare(next.key.get(), upperBoundKey) <= 0) {\n+                if (comparator.compare(next.key.get(), lastKey) <= 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMzODI0NA=="}, "originalCommit": null, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM1MDMwOQ==", "bodyText": "If compare(noTimestamp, withTimestamp) <= 0 then withTimestamp >= noTimestamp, so for the reverse case we would actually want to return withTimestamp next here (and vice versa in the else block)", "url": "https://github.com/apache/kafka/pull/9137#discussion_r470350309", "createdAt": "2020-08-14T01:00:53Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBTimestampedStore.java", "diffHunk": "@@ -306,26 +319,41 @@ public synchronized boolean hasNext() {\n                 } else {\n                     next = KeyValue.pair(new Bytes(nextWithTimestamp), iterWithTimestamp.value());\n                     nextWithTimestamp = null;\n-                    iterWithTimestamp.next();\n+                    if (reverse) {\n+                        iterWithTimestamp.prev();\n+                    } else {\n+                        iterWithTimestamp.next();\n+                    }\n                 }\n             } else {\n                 if (nextWithTimestamp == null) {\n                     next = KeyValue.pair(new Bytes(nextNoTimestamp), convertToTimestampedFormat(iterNoTimestamp.value()));\n                     nextNoTimestamp = null;\n-                    iterNoTimestamp.next();\n+                    if (reverse) {\n+                        iterNoTimestamp.prev();\n+                    } else {\n+                        iterNoTimestamp.next();\n+                    }\n                 } else {\n                     if (comparator.compare(nextNoTimestamp, nextWithTimestamp) <= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM1ODM4NA==", "bodyText": "Instead of storing and checking the reverse flag on every iteration, can we define something like\njava.util.function.Consumer<RocksIterator> advanceIterator = reverse ? RocksIterator::prev : RocksIterator::next;\n\nso then we can just blindly call advanceIterator.accept(iter)", "url": "https://github.com/apache/kafka/pull/9137#discussion_r470358384", "createdAt": "2020-08-14T01:12:40Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDbIterator.java", "diffHunk": "@@ -58,7 +61,11 @@ public synchronized boolean hasNext() {\n             return allDone();\n         } else {\n             next = getKeyValue();\n-            iter.next();\n+            if (reverse) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM1OTQ4Nw==", "bodyText": "Awesome, thank you for cleaning up the whole class \ud83d\ude4f", "url": "https://github.com/apache/kafka/pull/9137#discussion_r470359487", "createdAt": "2020-08-14T01:17:32Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CachingKeyValueStoreTest.java", "diffHunk": "@@ -321,67 +368,94 @@ public void shouldClearNamespaceCacheOnClose() {\n         assertEquals(0, cache.size());\n     }\n \n-    @Test(expected = InvalidStateStoreException.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM2MTcyNg==", "bodyText": "I think we should add some tests to RocksDBTimestampedStoreTest. I thought it would extend AbstractKeyValueStoreTest and thus benefit from everything you added here, but doesn't seem to be the case :/\nPersonally I found the RocksDBDualCFIterator logic a bit difficult to follow even before the reverse iteration,  so it would be nice to have some tests specifically covering reverse iterators over multi-column-family timestamped stores", "url": "https://github.com/apache/kafka/pull/9137#discussion_r470361726", "createdAt": "2020-08-14T01:27:07Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/AbstractKeyValueStoreTest.java", "diffHunk": "@@ -188,7 +188,55 @@ public void testPutGetRange() {\n     }\n \n     @Test\n-    public void testPutGetRangeWithDefaultSerdes() {\n+    public void testPutGetReverseRange() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4OTA1NDcw", "url": "https://github.com/apache/kafka/pull/9137#pullrequestreview-468905470", "createdAt": "2020-08-17T23:57:33Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5NzE3NDQ3", "url": "https://github.com/apache/kafka/pull/9137#pullrequestreview-469717447", "createdAt": "2020-08-18T18:27:49Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQxODoyNzo0OVrOHCg2_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMjozNTo0OVrOHCpBJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5NzU2NQ==", "bodyText": "This warning seems to miss the most likely scenario, that the user just passed the arguments in the wrong order.", "url": "https://github.com/apache/kafka/pull/9137#discussion_r472397565", "createdAt": "2020-08-18T18:27:49Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingKeyValueStore.java", "diffHunk": "@@ -249,7 +248,23 @@ public void putAll(final List<KeyValue<Bytes, byte[]>> entries) {\n         validateStoreOpen();\n         final KeyValueIterator<Bytes, byte[]> storeIterator = wrapped().range(from, to);\n         final ThreadCache.MemoryLRUCacheBytesIterator cacheIterator = context.cache().range(cacheName, from, to);\n-        return new MergedSortedCacheKeyValueBytesStoreIterator(cacheIterator, storeIterator);\n+        return new MergedSortedCacheKeyValueBytesStoreIterator(cacheIterator, storeIterator, false);\n+    }\n+\n+    @Override\n+    public KeyValueIterator<Bytes, byte[]> reverseRange(final Bytes from,\n+                                                        final Bytes to) {\n+        if (from.compareTo(to) > 0) {\n+            LOG.warn(\"Returning empty iterator for fetch with invalid key range: from > to. \"\n+                + \"This may be due to serdes that don't preserve ordering when lexicographically comparing the serialized bytes. \" +\n+                \"Note that the built-in numerical serdes do not follow this for negative numbers\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUzMTIzNw==", "bodyText": "Was this class unused or something?", "url": "https://github.com/apache/kafka/pull/9137#discussion_r472531237", "createdAt": "2020-08-18T22:35:49Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDBPrefixIterator.java", "diffHunk": "@@ -1,54 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- *    http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.kafka.streams.state.internals;\n-\n-import org.apache.kafka.common.utils.Bytes;\n-import org.apache.kafka.streams.state.KeyValueIterator;\n-import org.rocksdb.RocksIterator;\n-\n-import java.util.Set;\n-\n-class RocksDBPrefixIterator extends RocksDbIterator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwNTEzMzc5", "url": "https://github.com/apache/kafka/pull/9137#pullrequestreview-470513379", "createdAt": "2020-08-19T14:26:23Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNDoyNjoyM1rOHDJ-YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNDoyNjoyM1rOHDJ-YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA3MTIwMA==", "bodyText": "clever!", "url": "https://github.com/apache/kafka/pull/9137#discussion_r473071200", "createdAt": "2020-08-19T14:26:23Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/RocksDbIterator.java", "diffHunk": "@@ -58,7 +62,7 @@ public synchronized boolean hasNext() {\n             return allDone();\n         } else {\n             next = getKeyValue();\n-            iter.next();\n+            advanceIterator.accept(iter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f7f70b1918acf456b12384d1e63ccc85394ddac", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/3f7f70b1918acf456b12384d1e63ccc85394ddac", "committedDate": "2020-08-20T09:21:00Z", "message": "key/value reverse operations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07acb80d25bcc934904079c8d00cd7fecc3df38e", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/07acb80d25bcc934904079c8d00cd7fecc3df38e", "committedDate": "2020-08-20T09:21:01Z", "message": "refactor choose next key and value"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58f6c197be396a75c2a15dcffe6b8db07c6d483d", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/58f6c197be396a75c2a15dcffe6b8db07c6d483d", "committedDate": "2020-08-20T09:21:01Z", "message": "fix final params"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7ddbb9c78714995c4c3c5233b82626bf7da40a1", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/e7ddbb9c78714995c4c3c5233b82626bf7da40a1", "committedDate": "2020-08-20T09:21:01Z", "message": "improve ordering docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39d8e6339b6b268d27b295d378be5bce3dba4f5a", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/39d8e6339b6b268d27b295d378be5bce3dba4f5a", "committedDate": "2020-08-20T09:21:02Z", "message": "fix range validator not needed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dddfa75530ee8939273d1eb9fe551d8ac9c20598", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/dddfa75530ee8939273d1eb9fe551d8ac9c20598", "committedDate": "2020-08-20T09:21:02Z", "message": "resolve nits"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "834da345e1336d9db801a3280c0a3c2869b9d4f8", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/834da345e1336d9db801a3280c0a3c2869b9d4f8", "committedDate": "2020-08-20T09:21:02Z", "message": "improve tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "842c358d5f657996f9398c168dcfab3c88c5e557", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/842c358d5f657996f9398c168dcfab3c88c5e557", "committedDate": "2020-08-20T09:21:03Z", "message": "improve tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c634673602018315aebf2272273ffeacb5d93db7", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/c634673602018315aebf2272273ffeacb5d93db7", "committedDate": "2020-08-20T09:21:03Z", "message": "complete reverse paths"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8bdfd453b62b2b1c2c464d95504083348252909", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/a8bdfd453b62b2b1c2c464d95504083348252909", "committedDate": "2020-08-20T09:21:03Z", "message": "complete kvstore implementations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b124cb7b758941f957e23f20f87ee417a8055aea", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/b124cb7b758941f957e23f20f87ee417a8055aea", "committedDate": "2020-08-20T09:21:04Z", "message": "replace backward flag to forward flag"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "b124cb7b758941f957e23f20f87ee417a8055aea", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/b124cb7b758941f957e23f20f87ee417a8055aea", "committedDate": "2020-08-20T09:21:04Z", "message": "replace backward flag to forward flag"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a0adeb57ccb7c8c9a6174010e3a3c4bcffdec08", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/9a0adeb57ccb7c8c9a6174010e3a3c4bcffdec08", "committedDate": "2020-08-20T09:28:13Z", "message": "improve range wrong order warning"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4dd41696e7d9855f77603c13b53648257981bfd0", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/4dd41696e7d9855f77603c13b53648257981bfd0", "committedDate": "2020-08-20T15:49:04Z", "message": "fix style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38c3bb5e35a11c4e553c896b685ca141c960dbed", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/38c3bb5e35a11c4e553c896b685ca141c960dbed", "committedDate": "2020-08-20T16:39:08Z", "message": "fix concat style"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyODg2MDYw", "url": "https://github.com/apache/kafka/pull/9137#pullrequestreview-472886060", "createdAt": "2020-08-22T01:26:28Z", "commit": {"oid": "38c3bb5e35a11c4e553c896b685ca141c960dbed"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1079, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}