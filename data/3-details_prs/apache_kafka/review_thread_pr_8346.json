{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzNjMyNzU0", "number": 8346, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODowNTo0MFrODrVgGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODoyNDoxMFrODrV8vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2NzY3NjQyOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/log/LazyIndex.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODowNTo0MFrOF7n4Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODowNTo0MFrOF7n4Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA2MzcwMg==", "bodyText": "Identation of *. Also there seems to be tab in front of AbstractIndex.", "url": "https://github.com/apache/kafka/pull/8346#discussion_r398063702", "createdAt": "2020-03-25T18:05:40Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/log/LazyIndex.scala", "diffHunk": "@@ -18,22 +18,32 @@\n package kafka.log\n \n import java.io.File\n+import java.nio.file.{Files, NoSuchFileException}\n import java.util.concurrent.locks.ReentrantLock\n \n import LazyIndex._\n import kafka.utils.CoreUtils.inLock\n import kafka.utils.threadsafe\n+import org.apache.kafka.common.utils.Utils\n \n /**\n-  * A wrapper over an `AbstractIndex` instance that provides a mechanism to defer loading (i.e. memory mapping) the\n-  * underlying index until it is accessed for the first time via the `get` method.\n+  * A wrapper over an `AbstractIndex` instance that provides a mechanism to defer loading\n+  * (i.e. memory mapping) the underlying index until it is accessed for the first time via the\n+  * `get` method.\n   *\n-  * This is an important optimization with regards to broker start-up time if it has a large number of segments.\n+  * In addition, this class exposes a number of methods (e.g. updateParentDir, renameTo, close,\n+  * etc.) that provide the desired behavior without causing the index to be loaded. If the index\n+  * had previously been loaded, the methods in this class simply delegate to the relevant method in\n+  * the index.\n   *\n-  * Methods of this class are thread safe. Make sure to check `AbstractIndex` subclasses documentation\n-  * to establish their thread safety.\n+  * This is an important optimization with regards to broker start-up and shutdown time if it has a\n+  * large number of segments.\n   *\n-  * @param loadIndex A function that takes a `File` pointing to an index and returns a loaded `AbstractIndex` instance.\n+  * Methods of this class are thread safe. Make sure to check `AbstractIndex` subclasses\n+  * documentation to establish their thread safety.\n+  *\n+  * @param loadIndex A function that takes a `File` pointing to an index and returns a loaded\n+ *                  `AbstractIndex` instance.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2Nzc0OTcyOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/log/LazyIndex.scala", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxODoyNDoxMFrOF7onkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwNTowMjozOFrOF73egQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA3NTc5NQ==", "bodyText": "Hmm, we didn't do that before. Is there a reason that we should hide this exception?", "url": "https://github.com/apache/kafka/pull/8346#discussion_r398075795", "createdAt": "2020-03-25T18:24:10Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/log/LazyIndex.scala", "diffHunk": "@@ -75,15 +109,57 @@ object LazyIndex {\n     new LazyIndex(new IndexFile(file), file => new TimeIndex(file, baseOffset, maxIndexSize, writable))\n \n   private sealed trait IndexWrapper {\n+\n     def file: File\n-    def file_=(f: File): Unit\n+\n+    def updateParentDir(f: File): Unit\n+\n+    def renameTo(f: File): Unit\n+\n+    def deleteIfExists(): Boolean\n+\n+    def close(): Unit\n+\n+    def closeHandler(): Unit\n+\n   }\n \n-  private class IndexFile(@volatile var file: File) extends IndexWrapper\n+  private class IndexFile(@volatile private var _file: File) extends IndexWrapper {\n+\n+    def file: File = _file\n+\n+    def updateParentDir(parentDir: File): Unit = _file = new File(parentDir, file.getName)\n+\n+    def renameTo(f: File): Unit = {\n+      try Utils.atomicMoveWithFallback(file.toPath, f.toPath)\n+      catch {\n+        case _: NoSuchFileException if !file.exists => ()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE4MDY2Mg==", "bodyText": "We may call renameTo when the index file has not been created yet with this new approach. So we catch this case and ignore it. We could alternatively check if the file exists before calling atomicMoveWithFallback.", "url": "https://github.com/apache/kafka/pull/8346#discussion_r398180662", "createdAt": "2020-03-25T21:27:34Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/log/LazyIndex.scala", "diffHunk": "@@ -75,15 +109,57 @@ object LazyIndex {\n     new LazyIndex(new IndexFile(file), file => new TimeIndex(file, baseOffset, maxIndexSize, writable))\n \n   private sealed trait IndexWrapper {\n+\n     def file: File\n-    def file_=(f: File): Unit\n+\n+    def updateParentDir(f: File): Unit\n+\n+    def renameTo(f: File): Unit\n+\n+    def deleteIfExists(): Boolean\n+\n+    def close(): Unit\n+\n+    def closeHandler(): Unit\n+\n   }\n \n-  private class IndexFile(@volatile var file: File) extends IndexWrapper\n+  private class IndexFile(@volatile private var _file: File) extends IndexWrapper {\n+\n+    def file: File = _file\n+\n+    def updateParentDir(parentDir: File): Unit = _file = new File(parentDir, file.getName)\n+\n+    def renameTo(f: File): Unit = {\n+      try Utils.atomicMoveWithFallback(file.toPath, f.toPath)\n+      catch {\n+        case _: NoSuchFileException if !file.exists => ()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA3NTc5NQ=="}, "originalCommit": null, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMxOTIzMw==", "bodyText": "Interesting. That's true for the active segment.", "url": "https://github.com/apache/kafka/pull/8346#discussion_r398319233", "createdAt": "2020-03-26T05:02:38Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/log/LazyIndex.scala", "diffHunk": "@@ -75,15 +109,57 @@ object LazyIndex {\n     new LazyIndex(new IndexFile(file), file => new TimeIndex(file, baseOffset, maxIndexSize, writable))\n \n   private sealed trait IndexWrapper {\n+\n     def file: File\n-    def file_=(f: File): Unit\n+\n+    def updateParentDir(f: File): Unit\n+\n+    def renameTo(f: File): Unit\n+\n+    def deleteIfExists(): Boolean\n+\n+    def close(): Unit\n+\n+    def closeHandler(): Unit\n+\n   }\n \n-  private class IndexFile(@volatile var file: File) extends IndexWrapper\n+  private class IndexFile(@volatile private var _file: File) extends IndexWrapper {\n+\n+    def file: File = _file\n+\n+    def updateParentDir(parentDir: File): Unit = _file = new File(parentDir, file.getName)\n+\n+    def renameTo(f: File): Unit = {\n+      try Utils.atomicMoveWithFallback(file.toPath, f.toPath)\n+      catch {\n+        case _: NoSuchFileException if !file.exists => ()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODA3NTc5NQ=="}, "originalCommit": null, "originalPosition": 119}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3085, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}