{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4MzExNzE5", "number": 8015, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMDozMDoyOFrODbawZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxOTo0NVrODe6RBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDc2NTE5OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMDozMDoyOFrOFi5P4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzozMDoxOVrOFoSQxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzMzg1OQ==", "bodyText": "We're creating the store builder, even though we might not use it, since we'd otherwise have to push the Materialized into the topology builder layer.", "url": "https://github.com/apache/kafka/pull/8015#discussion_r372133859", "createdAt": "2020-01-29T00:30:28Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java", "diffHunk": "@@ -1107,9 +1107,8 @@ boolean sendingOldValueEnabled() {\n         );\n \n         final StoreBuilder<TimestampedKeyValueStore<K, VR>> resultStore =\n-            materializedInternal.queryableStoreName() == null\n-                ? null\n-                : new TimestampedKeyValueStoreMaterializer<>(materializedInternal).materialize();\n+            new TimestampedKeyValueStoreMaterializer<>(materializedInternal).materialize();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzNDUwOA==", "bodyText": "It might be easier to create the store within TableProcessorNode#writeToTopology() and encapsulate the decision if we need to materialize on not there?", "url": "https://github.com/apache/kafka/pull/8015#discussion_r374434508", "createdAt": "2020-02-04T01:36:53Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java", "diffHunk": "@@ -1107,9 +1107,8 @@ boolean sendingOldValueEnabled() {\n         );\n \n         final StoreBuilder<TimestampedKeyValueStore<K, VR>> resultStore =\n-            materializedInternal.queryableStoreName() == null\n-                ? null\n-                : new TimestampedKeyValueStoreMaterializer<>(materializedInternal).materialize();\n+            new TimestampedKeyValueStoreMaterializer<>(materializedInternal).materialize();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzMzg1OQ=="}, "originalCommit": null, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1ODA0MQ==", "bodyText": "I took your other advice, which cleaned up this PR a lot. For this one, though, I think it's better this way. Note that materialize doesn't really \"materialize\" anything, it just converts the Materialized config object into a StoreBuilder topology object. It should be harmless to create a StoreBuilder that we never actually use.\nThis approach lets us keep Materialized in the DSL \"parsing\" layer, which is otherwise universally where it lives.", "url": "https://github.com/apache/kafka/pull/8015#discussion_r376658041", "createdAt": "2020-02-07T23:44:06Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java", "diffHunk": "@@ -1107,9 +1107,8 @@ boolean sendingOldValueEnabled() {\n         );\n \n         final StoreBuilder<TimestampedKeyValueStore<K, VR>> resultStore =\n-            materializedInternal.queryableStoreName() == null\n-                ? null\n-                : new TimestampedKeyValueStoreMaterializer<>(materializedInternal).materialize();\n+            new TimestampedKeyValueStoreMaterializer<>(materializedInternal).materialize();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzMzg1OQ=="}, "originalCommit": null, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc4NjU2NQ==", "bodyText": "SG", "url": "https://github.com/apache/kafka/pull/8015#discussion_r377786565", "createdAt": "2020-02-11T17:30:19Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java", "diffHunk": "@@ -1107,9 +1107,8 @@ boolean sendingOldValueEnabled() {\n         );\n \n         final StoreBuilder<TimestampedKeyValueStore<K, VR>> resultStore =\n-            materializedInternal.queryableStoreName() == null\n-                ? null\n-                : new TimestampedKeyValueStoreMaterializer<>(materializedInternal).materialize();\n+            new TimestampedKeyValueStoreMaterializer<>(materializedInternal).materialize();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzMzg1OQ=="}, "originalCommit": null, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDc2ODQwOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMDozMjoxNVrOFi5RyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMDozMjoxNVrOFi5RyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNDM0NA==", "bodyText": "Since we passed in a store builder, TableProcessorNode will assume that we actually want to use it, but we're only sure we need it if it's queryable.", "url": "https://github.com/apache/kafka/pull/8015#discussion_r372134344", "createdAt": "2020-01-29T00:32:15Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java", "diffHunk": "@@ -1118,6 +1117,9 @@ boolean sendingOldValueEnabled() {\n             ),\n             resultStore\n         );\n+        resultNode.setStoreNeeded(materializedInternal.queryableStoreName() != null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDc3MTgwOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMDozNDo0MlrOFi5T8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxODozODoyMFrOFlfC3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNDg5Nw==", "bodyText": "We're actually passing the TableProcessorNode into the KTableSource, so that later on, if the downsteam operation requests materialization, we can let the TableProcessorNode know we do need the store, even if it's not queriable. This is accomplished with setStoreNeeded from within the KTableSource#materialize()", "url": "https://github.com/apache/kafka/pull/8015#discussion_r372134897", "createdAt": "2020-01-29T00:34:42Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java", "diffHunk": "@@ -1118,6 +1117,9 @@ boolean sendingOldValueEnabled() {\n             ),\n             resultStore\n         );\n+        resultNode.setStoreNeeded(materializedInternal.queryableStoreName() != null);\n+        resultProcessorSupplier.setTableProcessorNode(resultNode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzNjE3NQ==", "bodyText": "KTableSource#materialize() should be good enough -- it will set the queryableName (AFAIK, this won't make the store really queryable, but it's just a proxy to enforce materialization).", "url": "https://github.com/apache/kafka/pull/8015#discussion_r374436175", "createdAt": "2020-02-04T01:44:08Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java", "diffHunk": "@@ -1118,6 +1117,9 @@ boolean sendingOldValueEnabled() {\n             ),\n             resultStore\n         );\n+        resultNode.setStoreNeeded(materializedInternal.queryableStoreName() != null);\n+        resultProcessorSupplier.setTableProcessorNode(resultNode);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNDg5Nw=="}, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MDI2OQ==", "bodyText": "+1.", "url": "https://github.com/apache/kafka/pull/8015#discussion_r374850269", "createdAt": "2020-02-04T18:38:20Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java", "diffHunk": "@@ -1118,6 +1117,9 @@ boolean sendingOldValueEnabled() {\n             ),\n             resultStore\n         );\n+        resultNode.setStoreNeeded(materializedInternal.queryableStoreName() != null);\n+        resultProcessorSupplier.setTableProcessorNode(resultNode);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNDg5Nw=="}, "originalCommit": null, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDc3MzI2OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableSource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMDozNTozOVrOFi5U5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMTo0NDo0OFrOFlFx4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNTE0MQ==", "bodyText": "This is where we force registration of the store builder, even if it wasn't otherwise required.", "url": "https://github.com/apache/kafka/pull/8015#discussion_r372135141", "createdAt": "2020-01-29T00:35:39Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableSource.java", "diffHunk": "@@ -66,6 +73,9 @@ public void enableSendingOldValues() {\n     // need to set the queryable name as the store name to enforce materialization\n     public void materialize() {\n         this.queryableName = storeName;\n+        if (tableProcessorNode != null) {\n+            tableProcessorNode.setStoreNeeded(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzNjMyMw==", "bodyText": "I don't think we need all this, if we delay adding the store to writeToTopology()", "url": "https://github.com/apache/kafka/pull/8015#discussion_r374436323", "createdAt": "2020-02-04T01:44:48Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableSource.java", "diffHunk": "@@ -66,6 +73,9 @@ public void enableSendingOldValues() {\n     // need to set the queryable name as the store name to enforce materialization\n     public void materialize() {\n         this.queryableName = storeName;\n+        if (tableProcessorNode != null) {\n+            tableProcessorNode.setStoreNeeded(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNTE0MQ=="}, "originalCommit": null, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDc3ODIzOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/graph/TableProcessorNode.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMDozODozMFrOFi5X2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzo0MDoxOFrOFnNVZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNTg5Nw==", "bodyText": "This is what allows us to register the store builder \"optimistically\" in the foreign key join, but still control later whether it really gets registered and used.", "url": "https://github.com/apache/kafka/pull/8015#discussion_r372135897", "createdAt": "2020-01-29T00:38:30Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/graph/TableProcessorNode.java", "diffHunk": "@@ -65,8 +72,9 @@ public void writeToTopology(final InternalTopologyBuilder topologyBuilder) {\n         }\n \n         // TODO: we are enforcing this as a keyvalue store, but it should go beyond any type of stores\n-        if (storeBuilder != null) {\n-            topologyBuilder.addStateStore(storeBuilder, processorName);\n+        if (storeNeeded) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzNjcwOA==", "bodyText": "We can just use ktableSource.queryableName() != null to do this check (we can get the source ktable node via:\nfinal KTableSource<K, V> ktableSource = (KTableSource<K, V>) processorParameters.processorSupplier();", "url": "https://github.com/apache/kafka/pull/8015#discussion_r374436708", "createdAt": "2020-02-04T01:46:28Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/graph/TableProcessorNode.java", "diffHunk": "@@ -65,8 +72,9 @@ public void writeToTopology(final InternalTopologyBuilder topologyBuilder) {\n         }\n \n         // TODO: we are enforcing this as a keyvalue store, but it should go beyond any type of stores\n-        if (storeBuilder != null) {\n-            topologyBuilder.addStateStore(storeBuilder, processorName);\n+        if (storeNeeded) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNTg5Nw=="}, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1NzI1NA==", "bodyText": "Nice!", "url": "https://github.com/apache/kafka/pull/8015#discussion_r376657254", "createdAt": "2020-02-07T23:40:18Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/graph/TableProcessorNode.java", "diffHunk": "@@ -65,8 +72,9 @@ public void writeToTopology(final InternalTopologyBuilder topologyBuilder) {\n         }\n \n         // TODO: we are enforcing this as a keyvalue store, but it should go beyond any type of stores\n-        if (storeBuilder != null) {\n-            topologyBuilder.addStateStore(storeBuilder, processorName);\n+        if (storeNeeded) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNTg5Nw=="}, "originalCommit": null, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDc3ODc2OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/RecordQueue.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMDozODo0NlrOFi5YJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMDozODo0NlrOFi5YJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzNTk3NQ==", "bodyText": "I found this handy while debugging, so I figured I'd leave it in.", "url": "https://github.com/apache/kafka/pull/8015#discussion_r372135975", "createdAt": "2020-01-29T00:38:46Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/RecordQueue.java", "diffHunk": "@@ -208,4 +208,9 @@ private void updateHead() {\n     long partitionTime() {\n         return partitionTime;\n     }\n+\n+    @Override\n+    public String toString() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMjg5NjYwOnYy", "diffSide": "RIGHT", "path": "streams/test-utils/src/main/java/org/apache/kafka/streams/TopologyTestDriver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNTo0NzozMFrOFjNaTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxODozOTo1OFrOFlfGag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ2NDIwNQ==", "bodyText": "Previously, we would just directly process a record, and then iterate over the outputs, directly processing each of those as we get them...\nIf the first record R1 outputs R2 and R3, and R2 outputs R4, and R3 outputs R5, the correct observation order of outputs would be R2, R3, R4, R5, but the prior algorithm results in R2, R4, R3, R5.\nThe new algorithm is queue-based. We enqueue the first record, then we \"drain the queue\". \"Drain the queue\" means we repeatedly pull the head record, process it, and append its outputs to the end of the queue.", "url": "https://github.com/apache/kafka/pull/8015#discussion_r372464205", "createdAt": "2020-01-29T15:47:30Z", "author": {"login": "vvcephei"}, "path": "streams/test-utils/src/main/java/org/apache/kafka/streams/TopologyTestDriver.java", "diffHunk": "@@ -447,27 +443,50 @@ private void pipeRecord(final String topicName,\n         if (!internalTopologyBuilder.sourceTopicNames().isEmpty()) {\n             validateSourceTopicNameRegexPattern(topicName);\n         }\n+        enqueue(topicName, timestamp, key, value, headers);\n+\n+        drainProcessingQueue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MTE3OA==", "bodyText": "Thanks for the great catch!", "url": "https://github.com/apache/kafka/pull/8015#discussion_r374851178", "createdAt": "2020-02-04T18:39:58Z", "author": {"login": "guozhangwang"}, "path": "streams/test-utils/src/main/java/org/apache/kafka/streams/TopologyTestDriver.java", "diffHunk": "@@ -447,27 +443,50 @@ private void pipeRecord(final String topicName,\n         if (!internalTopologyBuilder.sourceTopicNames().isEmpty()) {\n             validateSourceTopicNameRegexPattern(topicName);\n         }\n+        enqueue(topicName, timestamp, key, value, headers);\n+\n+        drainProcessingQueue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ2NDIwNQ=="}, "originalCommit": null, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMjkyOTg4OnYy", "diffSide": "RIGHT", "path": "streams/test-utils/src/main/java/org/apache/kafka/streams/TopologyTestDriver.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNTo1NTo0MlrOFjNu5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxODo0MTo0NFrOFlfJ2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ2OTQ3OA==", "bodyText": "This \"processed\" boolean loop condition is a bit awkward, but there's otherwise no easy way to ask \"is the queue empty\", since the partition group is encapsulated in the task, and the record queue is encapsulated in the partition group.\nI think this algorithm is correct, but if the reviewers are uncomfortable with it, I'd propose to just add an \"isEmpty\" method to all of the record queue, partition group, and task interfaces so that we can just say \"keep processing until inputs are empty\" here.", "url": "https://github.com/apache/kafka/pull/8015#discussion_r372469478", "createdAt": "2020-01-29T15:55:42Z", "author": {"login": "vvcephei"}, "path": "streams/test-utils/src/main/java/org/apache/kafka/streams/TopologyTestDriver.java", "diffHunk": "@@ -447,27 +443,50 @@ private void pipeRecord(final String topicName,\n         if (!internalTopologyBuilder.sourceTopicNames().isEmpty()) {\n             validateSourceTopicNameRegexPattern(topicName);\n         }\n+        enqueue(topicName, timestamp, key, value, headers);\n+\n+        drainProcessingQueue();\n+    }\n+\n+    private void drainProcessingQueue() {\n+        boolean keepProcessing = true;\n+        while (keepProcessing) {\n+            // Since we can't directly inspect the enqueued records, we're using an indirect approach of\n+            // just continuing to process as long as either process() actually processed a record or\n+            // we enqueued some work while capturing output.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MjA1OQ==", "bodyText": "Hmm if we continue processing if captureOutputRecordsAndEnqueueInternalForwards returns true would that be a stack-like behavior as well? To mimic Stream thread's behavior, if draining the current queue generates new records to the queue, they would not be processed immediately but only be processed in the next iteration.", "url": "https://github.com/apache/kafka/pull/8015#discussion_r374852059", "createdAt": "2020-02-04T18:41:44Z", "author": {"login": "guozhangwang"}, "path": "streams/test-utils/src/main/java/org/apache/kafka/streams/TopologyTestDriver.java", "diffHunk": "@@ -447,27 +443,50 @@ private void pipeRecord(final String topicName,\n         if (!internalTopologyBuilder.sourceTopicNames().isEmpty()) {\n             validateSourceTopicNameRegexPattern(topicName);\n         }\n+        enqueue(topicName, timestamp, key, value, headers);\n+\n+        drainProcessingQueue();\n+    }\n+\n+    private void drainProcessingQueue() {\n+        boolean keepProcessing = true;\n+        while (keepProcessing) {\n+            // Since we can't directly inspect the enqueued records, we're using an indirect approach of\n+            // just continuing to process as long as either process() actually processed a record or\n+            // we enqueued some work while capturing output.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ2OTQ3OA=="}, "originalCommit": null, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMjk0Njc0OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/integration/KTableKTableForeignKeyJoinIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNTo1OTo0MlrOFjN5Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNTo1OTo0MlrOFjN5Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ3MjE1NQ==", "bodyText": "Two main changes in this class:\n\nnew test parameter for explicitly materialized  or not\nnew test parameter for whether to add an extra equi-join after the FK join (aka rejoin). This is primarily just a way to verify if the \"upstream value getter enforced materialization\" mechanism actually works.\n\nI think it makes sense to verify that the FK join works on all the permutations of how the feature might be used.", "url": "https://github.com/apache/kafka/pull/8015#discussion_r372472155", "createdAt": "2020-01-29T15:59:42Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/KTableKTableForeignKeyJoinIntegrationTest.java", "diffHunk": "@@ -58,36 +60,66 @@\n     private static final String LEFT_TABLE = \"left_table\";\n     private static final String RIGHT_TABLE = \"right_table\";\n     private static final String OUTPUT = \"output-topic\";\n+    private static final String REJOIN_OUTPUT = \"rejoin-output-topic\";\n     private final Properties streamsConfig;\n     private final boolean leftJoin;\n+    private final boolean materialized;\n+    private final boolean rejoin;\n \n-    public KTableKTableForeignKeyJoinIntegrationTest(final boolean leftJoin, final String optimization) {\n+    public KTableKTableForeignKeyJoinIntegrationTest(final boolean leftJoin,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTYyNDMzOnYy", "diffSide": "RIGHT", "path": "streams/test-utils/src/main/java/org/apache/kafka/streams/TopologyTestDriver.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMTo1NTozNVrOFlF7WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMDoyNzo1N1rOFmGGXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzODc0NA==", "bodyText": "This fix seems rather complex. Why not just loop over output twice? In the first loop, we only remove output records that don't need further processing, and in the second loop, we call pipeRecord() directly for each?", "url": "https://github.com/apache/kafka/pull/8015#discussion_r374438744", "createdAt": "2020-02-04T01:55:35Z", "author": {"login": "mjsax"}, "path": "streams/test-utils/src/main/java/org/apache/kafka/streams/TopologyTestDriver.java", "diffHunk": "@@ -513,24 +532,33 @@ private TopicPartition getTopicPartition(final String topicName) {\n         return topicPartition;\n     }\n \n-    private void captureOutputRecords() {\n+    private boolean captureOutputRecordsAndEnqueueInternalForwards() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc1NzczNg==", "bodyText": "Thanks for the review. At a glance, that does seem like it would result in the right output for this particular topology, but it seems like this would still process intermediate results in LIFO order instead of FIFO.\nI agree that the current fix is a bit complex, mostly because we can't actually query whether the task's priority queue is empty. I can explore adding that capability, which would simplify this algorithm.\nI'll give that a shot after I factor out the TTD change as a separate PR.", "url": "https://github.com/apache/kafka/pull/8015#discussion_r374757736", "createdAt": "2020-02-04T15:54:38Z", "author": {"login": "vvcephei"}, "path": "streams/test-utils/src/main/java/org/apache/kafka/streams/TopologyTestDriver.java", "diffHunk": "@@ -513,24 +532,33 @@ private TopicPartition getTopicPartition(final String topicName) {\n         return topicPartition;\n     }\n \n-    private void captureOutputRecords() {\n+    private boolean captureOutputRecordsAndEnqueueInternalForwards() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzODc0NA=="}, "originalCommit": null, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ5MDE0MA==", "bodyText": "but it seems like this would still process intermediate results in LIFO order instead of FIFO\n\nWhy that?", "url": "https://github.com/apache/kafka/pull/8015#discussion_r375490140", "createdAt": "2020-02-05T20:27:57Z", "author": {"login": "mjsax"}, "path": "streams/test-utils/src/main/java/org/apache/kafka/streams/TopologyTestDriver.java", "diffHunk": "@@ -513,24 +532,33 @@ private TopicPartition getTopicPartition(final String topicName) {\n         return topicPartition;\n     }\n \n-    private void captureOutputRecords() {\n+    private boolean captureOutputRecordsAndEnqueueInternalForwards() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzODc0NA=="}, "originalCommit": null, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxODI0NTQ3OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/graph/TableProcessorNode.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxODozOToxMVrOFlfEmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxODozOToxMVrOFlfEmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1MDcxMg==", "bodyText": "nit: not related to this PR, but the above TODO can be renamed as TODO KIP-300 to be more specific.", "url": "https://github.com/apache/kafka/pull/8015#discussion_r374850712", "createdAt": "2020-02-04T18:39:11Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/graph/TableProcessorNode.java", "diffHunk": "@@ -65,8 +72,9 @@ public void writeToTopology(final InternalTopologyBuilder topologyBuilder) {\n         }\n \n         // TODO: we are enforcing this as a keyvalue store, but it should go beyond any type of stores\n-        if (storeBuilder != null) {\n-            topologyBuilder.addStateStore(storeBuilder, processorName);\n+        if (storeNeeded) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTc1MTE2OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/graph/TableProcessorNode.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzo0NTo1OVrOFnNaGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzo0NTo1OVrOFnNaGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1ODQ1OA==", "bodyText": "changed the TODO at @guozhangwang 's request.", "url": "https://github.com/apache/kafka/pull/8015#discussion_r376658458", "createdAt": "2020-02-07T23:45:59Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/graph/TableProcessorNode.java", "diffHunk": "@@ -64,9 +66,10 @@ public void writeToTopology(final InternalTopologyBuilder topologyBuilder) {\n             topologyBuilder.connectProcessorAndStateStores(processorName, storeNames);\n         }\n \n-        // TODO: we are enforcing this as a keyvalue store, but it should go beyond any type of stores\n-        if (storeBuilder != null) {\n-            topologyBuilder.addStateStore(storeBuilder, processorName);\n+        // TODO KIP-300: we are enforcing this as a keyvalue store, but it should go beyond any type of stores", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTc1MjM5OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/RecordQueue.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzo0Njo1NlrOFnNa1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzo0Njo1NlrOFnNa1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1ODY0NQ==", "bodyText": "Either Git or IDEA is inserting this change, and I can't get it to stop.", "url": "https://github.com/apache/kafka/pull/8015#discussion_r376658645", "createdAt": "2020-02-07T23:46:56Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/RecordQueue.java", "diffHunk": "@@ -75,7 +75,7 @@\n         );\n         this.log = logContext.logger(RecordQueue.class);\n     }\n- \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTk3NDY3OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/graph/TableProcessorNode.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwNTo0MzoxMlrOFnPUVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDoyNzoxOVrOFoX6tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY4OTc0OA==", "bodyText": "Ok, I figured out how to implement @mjsax 's suggestion specifically for KTableSource nodes, without affecting all the other kinds of KTable nodes.", "url": "https://github.com/apache/kafka/pull/8015#discussion_r376689748", "createdAt": "2020-02-08T05:43:12Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/graph/TableProcessorNode.java", "diffHunk": "@@ -64,8 +67,12 @@ public void writeToTopology(final InternalTopologyBuilder topologyBuilder) {\n             topologyBuilder.connectProcessorAndStateStores(processorName, storeNames);\n         }\n \n-        // TODO: we are enforcing this as a keyvalue store, but it should go beyond any type of stores\n-        if (storeBuilder != null) {\n+        if (processorParameters.processorSupplier() instanceof KTableSource) {\n+            if (((KTableSource<?, ?>) processorParameters.processorSupplier()).materialized()) {\n+                topologyBuilder.addStateStore(Objects.requireNonNull(storeBuilder, \"storeBuilder was null\"),\n+                                              processorName);\n+            }\n+        } else if (storeBuilder != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY5MDI0MQ==", "bodyText": "In retrospect, that might have been what you meant all along. Sorry if I misunderstood.", "url": "https://github.com/apache/kafka/pull/8015#discussion_r376690241", "createdAt": "2020-02-08T05:54:51Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/graph/TableProcessorNode.java", "diffHunk": "@@ -64,8 +67,12 @@ public void writeToTopology(final InternalTopologyBuilder topologyBuilder) {\n             topologyBuilder.connectProcessorAndStateStores(processorName, storeNames);\n         }\n \n-        // TODO: we are enforcing this as a keyvalue store, but it should go beyond any type of stores\n-        if (storeBuilder != null) {\n+        if (processorParameters.processorSupplier() instanceof KTableSource) {\n+            if (((KTableSource<?, ?>) processorParameters.processorSupplier()).materialized()) {\n+                topologyBuilder.addStateStore(Objects.requireNonNull(storeBuilder, \"storeBuilder was null\"),\n+                                              processorName);\n+            }\n+        } else if (storeBuilder != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY4OTc0OA=="}, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc4ODYyMg==", "bodyText": "As a further thought, I think TableProcessorNode should be used for KTableSource as well (today they are only used in filter, map, transformValues and joinForeignKey that results in a KTable), so that we do not need this extra condition. But we can do this cleanup later (our current internal representation has a few such gaps already so some refactoring might be in request in future anyways).", "url": "https://github.com/apache/kafka/pull/8015#discussion_r377788622", "createdAt": "2020-02-11T17:34:19Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/graph/TableProcessorNode.java", "diffHunk": "@@ -64,8 +67,12 @@ public void writeToTopology(final InternalTopologyBuilder topologyBuilder) {\n             topologyBuilder.connectProcessorAndStateStores(processorName, storeNames);\n         }\n \n-        // TODO: we are enforcing this as a keyvalue store, but it should go beyond any type of stores\n-        if (storeBuilder != null) {\n+        if (processorParameters.processorSupplier() instanceof KTableSource) {\n+            if (((KTableSource<?, ?>) processorParameters.processorSupplier()).materialized()) {\n+                topologyBuilder.addStateStore(Objects.requireNonNull(storeBuilder, \"storeBuilder was null\"),\n+                                              processorName);\n+            }\n+        } else if (storeBuilder != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY4OTc0OA=="}, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg3OTIyMA==", "bodyText": "I agree with you, and I actually tried to do it at some point. There's a problem with the types because (IIRC) TableProcessorNodes are processors over Change<V>, but TableSourceNodes are processors over <V>. I wanted to revisit it after KIP-478, but never managed to get around to actually implementing it (yet).", "url": "https://github.com/apache/kafka/pull/8015#discussion_r377879220", "createdAt": "2020-02-11T20:27:19Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/graph/TableProcessorNode.java", "diffHunk": "@@ -64,8 +67,12 @@ public void writeToTopology(final InternalTopologyBuilder topologyBuilder) {\n             topologyBuilder.connectProcessorAndStateStores(processorName, storeNames);\n         }\n \n-        // TODO: we are enforcing this as a keyvalue store, but it should go beyond any type of stores\n-        if (storeBuilder != null) {\n+        if (processorParameters.processorSupplier() instanceof KTableSource) {\n+            if (((KTableSource<?, ?>) processorParameters.processorSupplier()).materialized()) {\n+                topologyBuilder.addStateStore(Objects.requireNonNull(storeBuilder, \"storeBuilder was null\"),\n+                                              processorName);\n+            }\n+        } else if (storeBuilder != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY4OTc0OA=="}, "originalCommit": null, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM4NTAyOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableSource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoxOTo0NVrOFoT2EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMDozMjozOFrOFoeH-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMjQ5Ng==", "bodyText": "In TableSourceNode and StreamToTableNode we use if (ktableSource. queryableName() != null) to make a decision about materialization -- given this new method, can we update both to also use this new method?\nNit: should the method be called needsMaterialization() ? The flag does not indicate that the table is materialized but that it must be materialized?", "url": "https://github.com/apache/kafka/pull/8015#discussion_r377812496", "createdAt": "2020-02-11T18:19:45Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableSource.java", "diffHunk": "@@ -68,6 +68,10 @@ public void materialize() {\n         this.queryableName = storeName;\n     }\n \n+    public boolean materialized() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk4MDkyMg==", "bodyText": "Good idea! I've added that in the latest commit. I decided not to change the method name because it gets into whether materialize() should be like requestMaterialization(), etc, but that's a bigger change. void materialize() and boolean materialized() seem like a good pair.", "url": "https://github.com/apache/kafka/pull/8015#discussion_r377980922", "createdAt": "2020-02-12T00:32:38Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableSource.java", "diffHunk": "@@ -68,6 +68,10 @@ public void materialize() {\n         this.queryableName = storeName;\n     }\n \n+    public boolean materialized() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMjQ5Ng=="}, "originalCommit": null, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4439, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}