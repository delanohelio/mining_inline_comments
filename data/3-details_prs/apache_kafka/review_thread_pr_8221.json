{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzNDEyMzg4", "number": 8221, "reviewThreads": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QxODozNDo0MFrODmC2rA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjowMzoyM1rOD9QDcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMjE5MjQ0OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/AbstractTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QxODozNDo0MVrOFzRJJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMDoxOToxOVrOF0fedw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMjU2Ng==", "bodyText": "nit: remove empty line", "url": "https://github.com/apache/kafka/pull/8221#discussion_r389302566", "createdAt": "2020-03-07T18:34:41Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/AbstractTask.java", "diffHunk": "@@ -100,4 +105,14 @@ final void transitionTo(final Task.State newState) {\n             throw new IllegalStateException(\"Invalid transition from \" + oldState + \" to \" + newState);\n         }\n     }\n+\n+    @Override\n+    public ProcessorTopology getProcessorTopology() {\n+        return topology;\n+    }\n+\n+    public void setProcessorTopology(final ProcessorTopology topology) {\n+        this.topology = topology;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4NTk3NQ==", "bodyText": "sure. fixed", "url": "https://github.com/apache/kafka/pull/8221#discussion_r390585975", "createdAt": "2020-03-10T20:19:19Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/AbstractTask.java", "diffHunk": "@@ -100,4 +105,14 @@ final void transitionTo(final Task.State newState) {\n             throw new IllegalStateException(\"Invalid transition from \" + oldState + \" to \" + newState);\n         }\n     }\n+\n+    @Override\n+    public ProcessorTopology getProcessorTopology() {\n+        return topology;\n+    }\n+\n+    public void setProcessorTopology(final ProcessorTopology topology) {\n+        this.topology = topology;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMjU2Ng=="}, "originalCommit": null, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMjE5MjYxOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QxODozNToxM1rOFzRJPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMDoxOTowOFrOF0fd5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMjU4OQ==", "bodyText": "Remove commented out line", "url": "https://github.com/apache/kafka/pull/8221#discussion_r389302589", "createdAt": "2020-03-07T18:35:13Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java", "diffHunk": "@@ -161,6 +164,7 @@ private Properties configProps(final boolean enableEoS) {\n             mkEntry(StreamsConfig.PROCESSING_GUARANTEE_CONFIG, enableEoS ? StreamsConfig.EXACTLY_ONCE : StreamsConfig.AT_LEAST_ONCE)\n         ));\n     }\n+    //mkEntry(ProducerConfig.TRANSACTIONAL_ID_CONFIG, APPLICATION_ID + \"-1\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4NTgyOQ==", "bodyText": "I checked - this line no longer in commit Dif", "url": "https://github.com/apache/kafka/pull/8221#discussion_r390585829", "createdAt": "2020-03-10T20:19:08Z", "author": {"login": "avalsa"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java", "diffHunk": "@@ -161,6 +164,7 @@ private Properties configProps(final boolean enableEoS) {\n             mkEntry(StreamsConfig.PROCESSING_GUARANTEE_CONFIG, enableEoS ? StreamsConfig.EXACTLY_ONCE : StreamsConfig.AT_LEAST_ONCE)\n         ));\n     }\n+    //mkEntry(ProducerConfig.TRANSACTIONAL_ID_CONFIG, APPLICATION_ID + \"-1\"),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMjU4OQ=="}, "originalCommit": null, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTYxMDc4OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/SourceNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjozMDoxNVrOFzwAuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMDoxODoyOVrOF0fcgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwODMxNQ==", "bodyText": "nit: space after //", "url": "https://github.com/apache/kafka/pull/8221#discussion_r389808315", "createdAt": "2020-03-09T16:30:15Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/SourceNode.java", "diffHunk": "@@ -128,4 +129,9 @@ public String toString(final String indent) {\n     public TimestampExtractor getTimestampExtractor() {\n         return timestampExtractor;\n     }\n+\n+    //for test purposes only", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4NTQ3NQ==", "bodyText": "fixed", "url": "https://github.com/apache/kafka/pull/8221#discussion_r390585475", "createdAt": "2020-03-10T20:18:29Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/SourceNode.java", "diffHunk": "@@ -128,4 +129,9 @@ public String toString(final String indent) {\n     public TimestampExtractor getTimestampExtractor() {\n         return timestampExtractor;\n     }\n+\n+    //for test purposes only", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwODMxNQ=="}, "originalCommit": null, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTYyMTcwOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjozMjoyM1rOFzwHAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMDoxNzo0MVrOF0fa1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwOTkyMQ==", "bodyText": "We could just call inputPartitions on L170", "url": "https://github.com/apache/kafka/pull/8221#discussion_r389809921", "createdAt": "2020-03-09T16:32:23Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -146,15 +148,25 @@ public StreamTask(final TaskId id,\n         // initialize the consumed and committed offset cache\n         consumedOffsets = new HashMap<>();\n \n-        // create queues for each assigned partition and associate them\n-        // to corresponding source nodes in the processor topology\n-        final Map<TopicPartition, RecordQueue> partitionQueues = new HashMap<>();\n+        defaultTimestampExtractor = config.defaultTimestampExtractor();\n+        defaultDeserializationExceptionHandler = config.defaultDeserializationExceptionHandler();\n \n         // initialize the topology with its own context\n         processorContext = new ProcessorContextImpl(id, this, config, this.recordCollector, stateMgr, streamsMetrics, cache);\n \n-        final TimestampExtractor defaultTimestampExtractor = config.defaultTimestampExtractor();\n-        final DeserializationExceptionHandler defaultDeserializationExceptionHandler = config.defaultDeserializationExceptionHandler();\n+        recordInfo = new PartitionGroup.RecordInfo();\n+        partitionGroup = new PartitionGroup(createPartitionQueues(logContext),\n+                                            TaskMetrics.recordLatenessSensor(threadId, taskId, streamsMetrics));\n+\n+        stateMgr.registerGlobalStateStores(topology.globalStateStores());\n+    }\n+\n+    // create queues for each assigned partition and associate them\n+    // to corresponding source nodes in the processor topology\n+    private Map<TopicPartition, RecordQueue> createPartitionQueues(final LogContext logContext) {\n+        final Set<TopicPartition> partitions = inputPartitions();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4NTA0Ng==", "bodyText": "Yes, inlined this", "url": "https://github.com/apache/kafka/pull/8221#discussion_r390585046", "createdAt": "2020-03-10T20:17:41Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -146,15 +148,25 @@ public StreamTask(final TaskId id,\n         // initialize the consumed and committed offset cache\n         consumedOffsets = new HashMap<>();\n \n-        // create queues for each assigned partition and associate them\n-        // to corresponding source nodes in the processor topology\n-        final Map<TopicPartition, RecordQueue> partitionQueues = new HashMap<>();\n+        defaultTimestampExtractor = config.defaultTimestampExtractor();\n+        defaultDeserializationExceptionHandler = config.defaultDeserializationExceptionHandler();\n \n         // initialize the topology with its own context\n         processorContext = new ProcessorContextImpl(id, this, config, this.recordCollector, stateMgr, streamsMetrics, cache);\n \n-        final TimestampExtractor defaultTimestampExtractor = config.defaultTimestampExtractor();\n-        final DeserializationExceptionHandler defaultDeserializationExceptionHandler = config.defaultDeserializationExceptionHandler();\n+        recordInfo = new PartitionGroup.RecordInfo();\n+        partitionGroup = new PartitionGroup(createPartitionQueues(logContext),\n+                                            TaskMetrics.recordLatenessSensor(threadId, taskId, streamsMetrics));\n+\n+        stateMgr.registerGlobalStateStores(topology.globalStateStores());\n+    }\n+\n+    // create queues for each assigned partition and associate them\n+    // to corresponding source nodes in the processor topology\n+    private Map<TopicPartition, RecordQueue> createPartitionQueues(final LogContext logContext) {\n+        final Set<TopicPartition> partitions = inputPartitions();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwOTkyMQ=="}, "originalCommit": null, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTYyNzQyOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjozMzo0N1rOFzwKhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMDoxNzo1N1rOF0fbYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgxMDgyMA==", "bodyText": "remove", "url": "https://github.com/apache/kafka/pull/8221#discussion_r389810820", "createdAt": "2020-03-09T16:33:47Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -284,6 +291,7 @@ public void resume() {\n             case SUSPENDED:\n                 // just transit the state without any logical changes: suspended and restoring states\n                 // are not actually any different for inner modules\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4NTE4Ng==", "bodyText": "sure, fixed", "url": "https://github.com/apache/kafka/pull/8221#discussion_r390585186", "createdAt": "2020-03-10T20:17:57Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -284,6 +291,7 @@ public void resume() {\n             case SUSPENDED:\n                 // just transit the state without any logical changes: suspended and restoring states\n                 // are not actually any different for inner modules\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgxMDgyMA=="}, "originalCommit": null, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNTY1ODMyOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjo0MTo0MlrOFzwdig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMDoxODoxOVrOF0fcGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgxNTY5MA==", "bodyText": "Let's log more context here, for example:\nlog.trace(\"Update task {} inputPartitions: current {}, new {}\", task,  task. inputPartitions(), topicPartitions);", "url": "https://github.com/apache/kafka/pull/8221#discussion_r389815690", "createdAt": "2020-03-09T16:41:42Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -244,14 +247,25 @@ public void handleAssignment(final Map<TaskId, Set<TopicPartition>> activeTasks,\n             }\n         }\n \n-        builder.addSubscribedTopicsFromAssignment(\n-            activeTasks.values().stream().flatMap(Collection::stream).collect(Collectors.toList()),\n-            logPrefix\n-        );\n-\n         changelogReader.transitToRestoreActive();\n     }\n \n+    private void updateInputPartitionsAndResume(final Task task, final Set<TopicPartition> topicPartitions) {\n+        final boolean requiresUpdate = !task.inputPartitions().equals(topicPartitions);\n+        if (requiresUpdate) {\n+            log.trace(\"update inputPartitions {} {}\", task, topicPartitions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU4NTM2OA==", "bodyText": "Agree. used proposed log format", "url": "https://github.com/apache/kafka/pull/8221#discussion_r390585368", "createdAt": "2020-03-10T20:18:19Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -244,14 +247,25 @@ public void handleAssignment(final Map<TaskId, Set<TopicPartition>> activeTasks,\n             }\n         }\n \n-        builder.addSubscribedTopicsFromAssignment(\n-            activeTasks.values().stream().flatMap(Collection::stream).collect(Collectors.toList()),\n-            logPrefix\n-        );\n-\n         changelogReader.transitToRestoreActive();\n     }\n \n+    private void updateInputPartitionsAndResume(final Task task, final Set<TopicPartition> topicPartitions) {\n+        final boolean requiresUpdate = !task.inputPartitions().equals(topicPartitions);\n+        if (requiresUpdate) {\n+            log.trace(\"update inputPartitions {} {}\", task, topicPartitions);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgxNTY5MA=="}, "originalCommit": null, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTEwMTg2OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjozMTo0NlrOF1LhsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxOToyNzo1M1rOF2P4vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwNzY5Nw==", "bodyText": "We should unit test this function", "url": "https://github.com/apache/kafka/pull/8221#discussion_r391307697", "createdAt": "2020-03-11T22:31:46Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +93,11 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    void updatePartitions(final Map<TopicPartition, RecordQueue> partitionQueues) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQyNzcxMA==", "bodyText": "created couple of tests", "url": "https://github.com/apache/kafka/pull/8221#discussion_r392427710", "createdAt": "2020-03-13T19:27:53Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +93,11 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    void updatePartitions(final Map<TopicPartition, RecordQueue> partitionQueues) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwNzY5Nw=="}, "originalCommit": null, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTExMDU1OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjozNToyNFrOF1LmzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxOToyODowNFrOF2P5DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwOTAwNQ==", "bodyText": "Let's move the updatePartitions logic out of initializeTopology, instead just call it inside resume", "url": "https://github.com/apache/kafka/pull/8221#discussion_r391309005", "createdAt": "2020-03-11T22:35:24Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -679,10 +689,13 @@ private void initializeTaskTime(final Map<TopicPartition, OffsetAndMetadata> off\n         return purgableConsumedOffsets;\n     }\n \n-    private void initializeTopology() {\n+    private void initializeTopology(final boolean updatePartitionQueues) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQyNzc4OA==", "bodyText": "moved", "url": "https://github.com/apache/kafka/pull/8221#discussion_r392427788", "createdAt": "2020-03-13T19:28:04Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -679,10 +689,13 @@ private void initializeTaskTime(final Map<TopicPartition, OffsetAndMetadata> off\n         return purgableConsumedOffsets;\n     }\n \n-    private void initializeTopology() {\n+    private void initializeTopology(final boolean updatePartitionQueues) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwOTAwNQ=="}, "originalCommit": null, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTExNjQ2OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/AbstractTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjozNzo0MlrOF1LqFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxOToyOToxOVrOF2P7Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwOTg0Ng==", "bodyText": "Why do we need this helper function? Shouldn't it be protected?", "url": "https://github.com/apache/kafka/pull/8221#discussion_r391309846", "createdAt": "2020-03-11T22:37:42Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/AbstractTask.java", "diffHunk": "@@ -116,4 +121,13 @@ static void executeAndMaybeSwallow(final boolean clean,\n             }\n         }\n     }\n+\n+    @Override\n+    public ProcessorTopology getProcessorTopology() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQyODMzNQ==", "bodyText": "Idea was that mutable variable should be 'protected' with method calls from external places. But agree protected would work better here.", "url": "https://github.com/apache/kafka/pull/8221#discussion_r392428335", "createdAt": "2020-03-13T19:29:19Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/AbstractTask.java", "diffHunk": "@@ -116,4 +121,13 @@ static void executeAndMaybeSwallow(final boolean clean,\n             }\n         }\n     }\n+\n+    @Override\n+    public ProcessorTopology getProcessorTopology() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwOTg0Ng=="}, "originalCommit": null, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTEyNzc5OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/integration/RegexSourceIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo0Mjo1NlrOF1LxJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxOToyOToyOFrOF2P7ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMTY1NQ==", "bodyText": "nit: we could put topic2 initialization before L196", "url": "https://github.com/apache/kafka/pull/8221#discussion_r391311655", "createdAt": "2020-03-11T22:42:56Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/RegexSourceIntegrationTest.java", "diffHunk": "@@ -178,6 +178,44 @@ public void subscribe(final Pattern topics, final ConsumerRebalanceListener list\n \n         TestUtils.waitForCondition(() -> assignedTopics.equals(expectedSecondAssignment), STREAM_TASKS_NOT_UPDATED);\n \n+        CLUSTER.deleteTopicsAndWait(\"TEST-TOPIC-1\", \"TEST-TOPIC-2\");\n+    }\n+\n+    @Test\n+    public void testRegexRecordsAreProcessedAfterReassignment() throws Exception {\n+        final String topic1 = \"TEST-TOPIC-1\";\n+        final String topic2 = \"TEST-TOPIC-2\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQyODM4OA==", "bodyText": "agree", "url": "https://github.com/apache/kafka/pull/8221#discussion_r392428388", "createdAt": "2020-03-13T19:29:28Z", "author": {"login": "avalsa"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/RegexSourceIntegrationTest.java", "diffHunk": "@@ -178,6 +178,44 @@ public void subscribe(final Pattern topics, final ConsumerRebalanceListener list\n \n         TestUtils.waitForCondition(() -> assignedTopics.equals(expectedSecondAssignment), STREAM_TASKS_NOT_UPDATED);\n \n+        CLUSTER.deleteTopicsAndWait(\"TEST-TOPIC-1\", \"TEST-TOPIC-2\");\n+    }\n+\n+    @Test\n+    public void testRegexRecordsAreProcessedAfterReassignment() throws Exception {\n+        final String topic1 = \"TEST-TOPIC-1\";\n+        final String topic2 = \"TEST-TOPIC-2\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMTY1NQ=="}, "originalCommit": null, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTEzMzMwOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo0NToyNFrOF1L0cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxOToyOTo1MlrOF2P77Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMjQ5OA==", "bodyText": "Could we also add a test case for when we call task.resume(true)?", "url": "https://github.com/apache/kafka/pull/8221#discussion_r391312498", "createdAt": "2020-03-11T22:45:24Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "diffHunk": "@@ -1103,7 +1103,7 @@ public void shouldNotReInitializeTopologyWhenResuming() throws IOException {\n         assertFalse(source1.initialized);\n         assertFalse(source2.initialized);\n \n-        task.resume();\n+        task.resume(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQyODUyNQ==", "bodyText": "Yes, of course", "url": "https://github.com/apache/kafka/pull/8221#discussion_r392428525", "createdAt": "2020-03-13T19:29:52Z", "author": {"login": "avalsa"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "diffHunk": "@@ -1103,7 +1103,7 @@ public void shouldNotReInitializeTopologyWhenResuming() throws IOException {\n         assertFalse(source1.initialized);\n         assertFalse(source2.initialized);\n \n-        task.resume();\n+        task.resume(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMjQ5OA=="}, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTEzNjUxOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo0Njo0OFrOF1L2XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxOTozMTozOVrOF2P-0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMjk4OA==", "bodyText": "Could we also verify consumer and changeLogReader?", "url": "https://github.com/apache/kafka/pull/8221#discussion_r391312988", "createdAt": "2020-03-11T22:46:48Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -342,6 +343,31 @@ public void shouldAddNonResumedSuspendedTasks() {\n         verify(activeTaskCreator);\n     }\n \n+    @Test\n+    public void shouldAddNonResumedSuspendedTasks2() {\n+        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n+\n+        expectRestoreToBeCompleted(consumer, changeLogReader);\n+        // expect these calls twice (because we're going to tryToCompleteRestoration twice)\n+        expectRestoreToBeCompleted(consumer, changeLogReader);\n+        expect(activeTaskCreator.createTasks(anyObject(), eq(taskId00Assignment))).andReturn(singletonList(task00));\n+        replay(activeTaskCreator, consumer, changeLogReader);\n+\n+\n+        taskManager.handleAssignment(taskId00Assignment, emptyMap());\n+        assertThat(taskManager.tryToCompleteRestoration(), is(true));\n+        assertThat(task00.state(), is(Task.State.RUNNING));\n+\n+        final Set<TopicPartition> newPartitionsSet = mkSet(t1p1);\n+        final Map<TaskId, Set<TopicPartition>> taskIdSetMap = singletonMap(taskId00, newPartitionsSet);\n+        taskManager.handleAssignment(taskIdSetMap, emptyMap());\n+        assertThat(taskManager.tryToCompleteRestoration(), is(true));\n+        assertThat(task00.state(), is(Task.State.RUNNING));\n+        assertEquals(newPartitionsSet, task00.inputPartitions());\n+        assertEquals(task00, taskManager.taskForInputPartition(t1p1));\n+        verify(activeTaskCreator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQyOTI2Nw==", "bodyText": "Fixed, just copy-pasted from near test =). In this class they are almost everywhere are not verified. May be should create task for this?", "url": "https://github.com/apache/kafka/pull/8221#discussion_r392429267", "createdAt": "2020-03-13T19:31:39Z", "author": {"login": "avalsa"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -342,6 +343,31 @@ public void shouldAddNonResumedSuspendedTasks() {\n         verify(activeTaskCreator);\n     }\n \n+    @Test\n+    public void shouldAddNonResumedSuspendedTasks2() {\n+        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n+\n+        expectRestoreToBeCompleted(consumer, changeLogReader);\n+        // expect these calls twice (because we're going to tryToCompleteRestoration twice)\n+        expectRestoreToBeCompleted(consumer, changeLogReader);\n+        expect(activeTaskCreator.createTasks(anyObject(), eq(taskId00Assignment))).andReturn(singletonList(task00));\n+        replay(activeTaskCreator, consumer, changeLogReader);\n+\n+\n+        taskManager.handleAssignment(taskId00Assignment, emptyMap());\n+        assertThat(taskManager.tryToCompleteRestoration(), is(true));\n+        assertThat(task00.state(), is(Task.State.RUNNING));\n+\n+        final Set<TopicPartition> newPartitionsSet = mkSet(t1p1);\n+        final Map<TaskId, Set<TopicPartition>> taskIdSetMap = singletonMap(taskId00, newPartitionsSet);\n+        taskManager.handleAssignment(taskIdSetMap, emptyMap());\n+        assertThat(taskManager.tryToCompleteRestoration(), is(true));\n+        assertThat(task00.state(), is(Task.State.RUNNING));\n+        assertEquals(newPartitionsSet, task00.inputPartitions());\n+        assertEquals(task00, taskManager.taskForInputPartition(t1p1));\n+        verify(activeTaskCreator);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMjk4OA=="}, "originalCommit": null, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTE0MzQ4OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo1MDowM1rOF1L6kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxOTozMTo1MFrOF2P_HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNDA2NA==", "bodyText": "What does Task2 mean?", "url": "https://github.com/apache/kafka/pull/8221#discussion_r391314064", "createdAt": "2020-03-11T22:50:03Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -342,6 +343,31 @@ public void shouldAddNonResumedSuspendedTasks() {\n         verify(activeTaskCreator);\n     }\n \n+    @Test\n+    public void shouldAddNonResumedSuspendedTasks2() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQyOTM0MA==", "bodyText": "gave it meaningful name", "url": "https://github.com/apache/kafka/pull/8221#discussion_r392429340", "createdAt": "2020-03-13T19:31:50Z", "author": {"login": "avalsa"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -342,6 +343,31 @@ public void shouldAddNonResumedSuspendedTasks() {\n         verify(activeTaskCreator);\n     }\n \n+    @Test\n+    public void shouldAddNonResumedSuspendedTasks2() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNDA2NA=="}, "originalCommit": null, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMjU3MTI4OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMToyODoyOVrOF2Tsbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNVQwOTowNzoxNFrOF2dvig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5MDA5NA==", "bodyText": "nit: let's put iterator initialization closer to the start of while loop", "url": "https://github.com/apache/kafka/pull/8221#discussion_r392490094", "createdAt": "2020-03-13T21:28:29Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +96,33 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    // creates queues for new partitions, removes old queues, saves cached records for previously assigned partitions\n+    void updatePartitions(final Set<TopicPartition> newInputPartitions, final Function<TopicPartition, RecordQueue> recordQueueCreator) {\n+        final Iterator<Map.Entry<TopicPartition, RecordQueue>> queuesIterator = partitionQueues.entrySet().iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY1NDczMA==", "bodyText": "fixed", "url": "https://github.com/apache/kafka/pull/8221#discussion_r392654730", "createdAt": "2020-03-15T09:07:14Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +96,33 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    // creates queues for new partitions, removes old queues, saves cached records for previously assigned partitions\n+    void updatePartitions(final Set<TopicPartition> newInputPartitions, final Function<TopicPartition, RecordQueue> recordQueueCreator) {\n+        final Iterator<Map.Entry<TopicPartition, RecordQueue>> queuesIterator = partitionQueues.entrySet().iterator();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5MDA5NA=="}, "originalCommit": null, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMjU4NzI2OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMTozMjoxOFrOF2T1UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNVQwOTowNzoxOVrOF2dvkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5MjM2OQ==", "bodyText": "nit: this seems unnecessary", "url": "https://github.com/apache/kafka/pull/8221#discussion_r392492369", "createdAt": "2020-03-13T21:32:18Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -55,6 +55,7 @@\n import java.util.Set;\n import java.util.function.Function;\n import java.util.stream.Collectors;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY1NDczNg==", "bodyText": "fixed", "url": "https://github.com/apache/kafka/pull/8221#discussion_r392654736", "createdAt": "2020-03-15T09:07:19Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -55,6 +55,7 @@\n import java.util.Set;\n import java.util.function.Function;\n import java.util.stream.Collectors;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5MjM2OQ=="}, "originalCommit": null, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMjU5NTAxOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMTozNDoxMFrOF2T5kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNVQwOTowNjo0MlrOF2dvcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5MzQ1Nw==", "bodyText": "This is nice!", "url": "https://github.com/apache/kafka/pull/8221#discussion_r392493457", "createdAt": "2020-03-13T21:34:10Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -952,4 +952,32 @@ int numBuffered() {\n     long streamTime() {\n         return partitionGroup.streamTime();\n     }\n+\n+    private class RecordQueueCreator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY1NDcwNw==", "bodyText": "Thank you", "url": "https://github.com/apache/kafka/pull/8221#discussion_r392654707", "createdAt": "2020-03-15T09:06:42Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -952,4 +952,32 @@ int numBuffered() {\n     long streamTime() {\n         return partitionGroup.streamTime();\n     }\n+\n+    private class RecordQueueCreator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5MzQ1Nw=="}, "originalCommit": null, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMjY1NTQ0OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMTo0OTo1NFrOF2Ub6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNVQwOTowNjoyMFrOF2dvTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUwMjI1MA==", "bodyText": "What's the reasoning for resetting streamTime here?", "url": "https://github.com/apache/kafka/pull/8221#discussion_r392502250", "createdAt": "2020-03-13T21:49:54Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +96,33 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    // creates queues for new partitions, removes old queues, saves cached records for previously assigned partitions\n+    void updatePartitions(final Set<TopicPartition> newInputPartitions, final Function<TopicPartition, RecordQueue> recordQueueCreator) {\n+        final Iterator<Map.Entry<TopicPartition, RecordQueue>> queuesIterator = partitionQueues.entrySet().iterator();\n+        final Set<TopicPartition> removedPartitions = new HashSet<>();\n+        streamTime = RecordQueue.UNKNOWN;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY1NDY3MQ==", "bodyText": "def from src: stream-time of this partition group defined as the largest timestamp seen across all partitions. E.g. we removed partition with largest value so we have to update stream-time with new value (max from rest of partitions) or if all of them removed it should be UNKOWN.\nBut I haven't investigate where this property is used so may be it's not very necessary.", "url": "https://github.com/apache/kafka/pull/8221#discussion_r392654671", "createdAt": "2020-03-15T09:06:20Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +96,33 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    // creates queues for new partitions, removes old queues, saves cached records for previously assigned partitions\n+    void updatePartitions(final Set<TopicPartition> newInputPartitions, final Function<TopicPartition, RecordQueue> recordQueueCreator) {\n+        final Iterator<Map.Entry<TopicPartition, RecordQueue>> queuesIterator = partitionQueues.entrySet().iterator();\n+        final Set<TopicPartition> removedPartitions = new HashSet<>();\n+        streamTime = RecordQueue.UNKNOWN;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUwMjI1MA=="}, "originalCommit": null, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MzA3Njk4OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxODo0MTozOVrOF93N8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQwNzo1NDo0NFrOF_fbQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxMjE0Nw==", "bodyText": "Could we move the comment to next line?", "url": "https://github.com/apache/kafka/pull/8221#discussion_r400412147", "createdAt": "2020-03-30T18:41:39Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +96,33 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    // creates queues for new partitions, removes old queues, saves cached records for previously assigned partitions\n+    void updatePartitions(final Set<TopicPartition> newInputPartitions, final Function<TopicPartition, RecordQueue> recordQueueCreator) {\n+        final Set<TopicPartition> removedPartitions = new HashSet<>();\n+        streamTime = RecordQueue.UNKNOWN;\n+        final Iterator<Map.Entry<TopicPartition, RecordQueue>> queuesIterator = partitionQueues.entrySet().iterator();\n+        while (queuesIterator.hasNext()) {\n+            final Map.Entry<TopicPartition, RecordQueue> queueEntry = queuesIterator.next();\n+            final TopicPartition topicPartition = queueEntry.getKey();\n+            if (newInputPartitions.contains(topicPartition)) { // if partition is left should save it's queue", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjExOTQ5MQ==", "bodyText": "of course", "url": "https://github.com/apache/kafka/pull/8221#discussion_r402119491", "createdAt": "2020-04-02T07:54:44Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +96,33 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    // creates queues for new partitions, removes old queues, saves cached records for previously assigned partitions\n+    void updatePartitions(final Set<TopicPartition> newInputPartitions, final Function<TopicPartition, RecordQueue> recordQueueCreator) {\n+        final Set<TopicPartition> removedPartitions = new HashSet<>();\n+        streamTime = RecordQueue.UNKNOWN;\n+        final Iterator<Map.Entry<TopicPartition, RecordQueue>> queuesIterator = partitionQueues.entrySet().iterator();\n+        while (queuesIterator.hasNext()) {\n+            final Map.Entry<TopicPartition, RecordQueue> queueEntry = queuesIterator.next();\n+            final TopicPartition topicPartition = queueEntry.getKey();\n+            if (newInputPartitions.contains(topicPartition)) { // if partition is left should save it's queue", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxMjE0Nw=="}, "originalCommit": null, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTE5OTUyOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/integration/RegexSourceIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNTo1MTozNVrOGGVjbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwMzoyMToxOFrOGL95zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5Nzc3Mg==", "bodyText": "Thanks for the added tests. Have you verified the test would fail with current trunk?\nAlso this test takes one minute for me on local, could you take a look and see whether it takes so long?", "url": "https://github.com/apache/kafka/pull/8221#discussion_r409297772", "createdAt": "2020-04-16T05:51:35Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/RegexSourceIntegrationTest.java", "diffHunk": "@@ -179,6 +179,44 @@ public void subscribe(final Pattern topics, final ConsumerRebalanceListener list\n \n         TestUtils.waitForCondition(() -> assignedTopics.equals(expectedSecondAssignment), STREAM_TASKS_NOT_UPDATED);\n \n+        CLUSTER.deleteTopicsAndWait(\"TEST-TOPIC-1\", \"TEST-TOPIC-2\");\n+    }\n+\n+    @Test\n+    public void testRegexRecordsAreProcessedAfterReassignment() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE3ODk1Mg==", "bodyText": "Yes, it fails on trunk.\nI found reason: here I tried to isolate tests: so we can create same topic in one test, delete it after we are done, do the same in next test, so on. But after each test it calls streams.close() in teardown method. I guess It tries to do smth with removed topics and gets TimeoutException because can't do it. may be it's issue but probably it happens only when close. But it seems to be not related to this task. @abbccdda What do you think? I fixed it easily (may be not best approach): call streams.close in test method body before deleting topics.", "url": "https://github.com/apache/kafka/pull/8221#discussion_r412178952", "createdAt": "2020-04-21T13:21:41Z", "author": {"login": "avalsa"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/RegexSourceIntegrationTest.java", "diffHunk": "@@ -179,6 +179,44 @@ public void subscribe(final Pattern topics, final ConsumerRebalanceListener list\n \n         TestUtils.waitForCondition(() -> assignedTopics.equals(expectedSecondAssignment), STREAM_TASKS_NOT_UPDATED);\n \n+        CLUSTER.deleteTopicsAndWait(\"TEST-TOPIC-1\", \"TEST-TOPIC-2\");\n+    }\n+\n+    @Test\n+    public void testRegexRecordsAreProcessedAfterReassignment() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5Nzc3Mg=="}, "originalCommit": null, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTIwMTc0MQ==", "bodyText": "I see, sounds good", "url": "https://github.com/apache/kafka/pull/8221#discussion_r415201741", "createdAt": "2020-04-26T03:21:18Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/RegexSourceIntegrationTest.java", "diffHunk": "@@ -179,6 +179,44 @@ public void subscribe(final Pattern topics, final ConsumerRebalanceListener list\n \n         TestUtils.waitForCondition(() -> assignedTopics.equals(expectedSecondAssignment), STREAM_TASKS_NOT_UPDATED);\n \n+        CLUSTER.deleteTopicsAndWait(\"TEST-TOPIC-1\", \"TEST-TOPIC-2\");\n+    }\n+\n+    @Test\n+    public void testRegexRecordsAreProcessedAfterReassignment() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5Nzc3Mg=="}, "originalCommit": null, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTIxNjg5OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNTo1ODo1M1rOGGVtZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwOToxMzo0OFrOGI7ahA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwMDMyNA==", "bodyText": "The map itself should still be final", "url": "https://github.com/apache/kafka/pull/8221#discussion_r409300324", "createdAt": "2020-04-16T05:58:53Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -50,7 +53,7 @@\n  */\n public class PartitionGroup {\n \n-    private final Map<TopicPartition, RecordQueue> partitionQueues;\n+    private Map<TopicPartition, RecordQueue> partitionQueues;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAxNTIzNg==", "bodyText": "agree", "url": "https://github.com/apache/kafka/pull/8221#discussion_r412015236", "createdAt": "2020-04-21T09:13:48Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -50,7 +53,7 @@\n  */\n public class PartitionGroup {\n \n-    private final Map<TopicPartition, RecordQueue> partitionQueues;\n+    private Map<TopicPartition, RecordQueue> partitionQueues;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwMDMyNA=="}, "originalCommit": null, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTIyMzYzOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjowMjowMFrOGGVxRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwOToyMToyOFrOGI7vHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwMTMxOQ==", "bodyText": "remove should be a no-op if the topicPartition doesn't exist. Might be able to rephrase:\nif (!newInputPartitions.contains(topicPartition)) {\n   totalBuffered -= queueEntry.getValue().size();\n   queuesIterator.remove();\n   removedPartitions.add(topicPartition);\n}\nnewInputPartitions.remove(topicPartition);", "url": "https://github.com/apache/kafka/pull/8221#discussion_r409301319", "createdAt": "2020-04-16T06:02:00Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +96,29 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    // creates queues for new partitions, removes old queues, saves cached records for previously assigned partitions\n+    void updatePartitions(final Set<TopicPartition> newInputPartitions, final Function<TopicPartition, RecordQueue> recordQueueCreator) {\n+        final Set<TopicPartition> removedPartitions = new HashSet<>();\n+        final Iterator<Map.Entry<TopicPartition, RecordQueue>> queuesIterator = partitionQueues.entrySet().iterator();\n+        while (queuesIterator.hasNext()) {\n+            final Map.Entry<TopicPartition, RecordQueue> queueEntry = queuesIterator.next();\n+            final TopicPartition topicPartition = queueEntry.getKey();\n+            if (newInputPartitions.contains(topicPartition)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAyMDUxMA==", "bodyText": "Yes, can rephrase as you offer.", "url": "https://github.com/apache/kafka/pull/8221#discussion_r412020510", "createdAt": "2020-04-21T09:21:28Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +96,29 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    // creates queues for new partitions, removes old queues, saves cached records for previously assigned partitions\n+    void updatePartitions(final Set<TopicPartition> newInputPartitions, final Function<TopicPartition, RecordQueue> recordQueueCreator) {\n+        final Set<TopicPartition> removedPartitions = new HashSet<>();\n+        final Iterator<Map.Entry<TopicPartition, RecordQueue>> queuesIterator = partitionQueues.entrySet().iterator();\n+        while (queuesIterator.hasNext()) {\n+            final Map.Entry<TopicPartition, RecordQueue> queueEntry = queuesIterator.next();\n+            final TopicPartition topicPartition = queueEntry.getKey();\n+            if (newInputPartitions.contains(topicPartition)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwMTMxOQ=="}, "originalCommit": null, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTIzMDQ1OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjowNTowNlrOGGV1iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDoxMToyMlrOGI914A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwMjQwOA==", "bodyText": "IIUC we are trying to avoid calling the initializeTopology twice, I'm thinking whether this optimization is necessary, as the guarantee to call  initializeTopology in RESTORING state is weak, which might be implicitly changed in the future, cc @guozhangwang", "url": "https://github.com/apache/kafka/pull/8221#discussion_r409302408", "createdAt": "2020-04-16T06:05:06Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -305,6 +297,12 @@ public void resume() {\n             default:\n                 throw new IllegalStateException(\"Illegal state \" + state() + \" while resuming active task \" + id);\n         }\n+        if (requiresUpdate) {\n+            partitionGroup.updatePartitions(inputPartitions(), recordQueueCreator::createQueue);\n+            if (state() != State.RESTORING) { // if task is RESTORING then topology will be initialized in completeRestoration", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA1NTAwOA==", "bodyText": "when work on this task it fails some test that ensure that initializeTopology called once here. I thought that it might be important and decided to support this.", "url": "https://github.com/apache/kafka/pull/8221#discussion_r412055008", "createdAt": "2020-04-21T10:11:22Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -305,6 +297,12 @@ public void resume() {\n             default:\n                 throw new IllegalStateException(\"Illegal state \" + state() + \" while resuming active task \" + id);\n         }\n+        if (requiresUpdate) {\n+            partitionGroup.updatePartitions(inputPartitions(), recordQueueCreator::createQueue);\n+            if (state() != State.RESTORING) { // if task is RESTORING then topology will be initialized in completeRestoration", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwMjQwOA=="}, "originalCommit": null, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTIzMzcxOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjowNjozM1rOGGV3jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDowMzoyNlrOGI9iAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwMjkyNw==", "bodyText": "s/WithFalseFlag/WhenRequireUpdate", "url": "https://github.com/apache/kafka/pull/8221#discussion_r409302927", "createdAt": "2020-04-16T06:06:33Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "diffHunk": "@@ -1127,7 +1127,7 @@ public void shouldReadCommittedOffsetAndRethrowTimeoutWhenCompleteRestoration()\n     }\n \n     @Test\n-    public void shouldNotReInitializeTopologyWhenResuming() throws IOException {\n+    public void shouldNotReInitializeTopologyWhenResumingWithFalseFlag() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA0OTkyMg==", "bodyText": "fixed", "url": "https://github.com/apache/kafka/pull/8221#discussion_r412049922", "createdAt": "2020-04-21T10:03:26Z", "author": {"login": "avalsa"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "diffHunk": "@@ -1127,7 +1127,7 @@ public void shouldReadCommittedOffsetAndRethrowTimeoutWhenCompleteRestoration()\n     }\n \n     @Test\n-    public void shouldNotReInitializeTopologyWhenResuming() throws IOException {\n+    public void shouldNotReInitializeTopologyWhenResumingWithFalseFlag() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwMjkyNw=="}, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0MTIzNzE3OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjowODowNlrOGGV5ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMToyMzoxNVrOGJAiXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwMzQ1NA==", "bodyText": "Why do we use third-person singular instead of calling the flag requireUpdate? I feel updateInputPartitions is more explicit here.", "url": "https://github.com/apache/kafka/pull/8221#discussion_r409303454", "createdAt": "2020-04-16T06:08:06Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -115,7 +115,7 @@ public void suspend() {\n     }\n \n     @Override\n-    public void resume() {\n+    public void resume(final boolean requiresUpdate) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA5OTE2NQ==", "bodyText": "agree. beautified it.", "url": "https://github.com/apache/kafka/pull/8221#discussion_r412099165", "createdAt": "2020-04-21T11:23:15Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -115,7 +115,7 @@ public void suspend() {\n     }\n \n     @Override\n-    public void resume() {\n+    public void resume(final boolean requiresUpdate) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwMzQ1NA=="}, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMTIyMTIyOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQwNDozMzoyNlrOGTAa7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMTowMzoxN1rOGUBZMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4MzAyMw==", "bodyText": "If the state was RUNNING then we would effectively call initializeTopology twice. Is that intentional?", "url": "https://github.com/apache/kafka/pull/8221#discussion_r422583023", "createdAt": "2020-05-10T04:33:26Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -429,6 +421,15 @@ public void closeDirty() {\n         log.info(\"Closed dirty\");\n     }\n \n+    @Override\n+    public void updateInputPartitions(final Set<TopicPartition> topicPartitions) {\n+        super.updateInputPartitions(topicPartitions);\n+        partitionGroup.updatePartitions(topicPartitions, recordQueueCreator::createQueue);\n+        if (state() != State.RESTORING) { // if task is RESTORING then topology will be initialized in completeRestoration", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY0NzUzNg==", "bodyText": "if I correctly remember if state==RUNNING initializeTopology is called only once in update method. Only if state == RESTORING it will be called later. It's no problem to call this method twice but it's aka optimization.", "url": "https://github.com/apache/kafka/pull/8221#discussion_r423647536", "createdAt": "2020-05-12T11:03:17Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -429,6 +421,15 @@ public void closeDirty() {\n         log.info(\"Closed dirty\");\n     }\n \n+    @Override\n+    public void updateInputPartitions(final Set<TopicPartition> topicPartitions) {\n+        super.updateInputPartitions(topicPartitions);\n+        partitionGroup.updatePartitions(topicPartitions, recordQueueCreator::createQueue);\n+        if (state() != State.RESTORING) { // if task is RESTORING then topology will be initialized in completeRestoration", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4MzAyMw=="}, "originalCommit": null, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMTIyMjExOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/Task.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQwNDozNToxMlrOGTAbVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxMTowNTozMVrOGUBdNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4MzEyNw==", "bodyText": "These two newly added functions are always called at the same time, I'd suggest we merge them into a single function, e.g. named update(topicPartitions, topology).", "url": "https://github.com/apache/kafka/pull/8221#discussion_r422583127", "createdAt": "2020-05-10T04:35:12Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/Task.java", "diffHunk": "@@ -170,6 +170,8 @@ public boolean isValidTransition(final State newState) {\n      */\n     void closeDirty();\n \n+    void updateInputPartitions(final Set<TopicPartition> topicPartitions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzY0ODU2Nw==", "bodyText": "agree. changed to one function call", "url": "https://github.com/apache/kafka/pull/8221#discussion_r423648567", "createdAt": "2020-05-12T11:05:31Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/Task.java", "diffHunk": "@@ -170,6 +170,8 @@ public boolean isValidTransition(final State newState) {\n      */\n     void closeDirty();\n \n+    void updateInputPartitions(final Set<TopicPartition> topicPartitions);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4MzEyNw=="}, "originalCommit": null, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTQ3MjAwOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/Task.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNTozMzoyNlrOGWoCpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwOTo0MTo0NVrOGWvcdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3Nzg5NA==", "bodyText": "nit: could we add some comments for this function?", "url": "https://github.com/apache/kafka/pull/8221#discussion_r426377894", "createdAt": "2020-05-18T05:33:26Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/Task.java", "diffHunk": "@@ -170,6 +170,8 @@ public boolean isValidTransition(final State newState) {\n      */\n     void closeDirty();\n \n+    void update(final Set<TopicPartition> topicPartitions, final ProcessorTopology processorTopology);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ5OTE4OQ==", "bodyText": "yes, added short description", "url": "https://github.com/apache/kafka/pull/8221#discussion_r426499189", "createdAt": "2020-05-18T09:41:45Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/Task.java", "diffHunk": "@@ -170,6 +170,8 @@ public boolean isValidTransition(final State newState) {\n      */\n     void closeDirty();\n \n+    void update(final Set<TopicPartition> topicPartitions, final ProcessorTopology processorTopology);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3Nzg5NA=="}, "originalCommit": null, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTUyNzA5OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjowMzoxMFrOGWoi0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwOTo0MToxNFrOGWvbPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4NjEyOQ==", "bodyText": "nit: allBuffered &= newInputPartitions.isEmpty();", "url": "https://github.com/apache/kafka/pull/8221#discussion_r426386129", "createdAt": "2020-05-18T06:03:10Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +96,28 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    // creates queues for new partitions, removes old queues, saves cached records for previously assigned partitions\n+    void updatePartitions(final Set<TopicPartition> newInputPartitions, final Function<TopicPartition, RecordQueue> recordQueueCreator) {\n+        final Set<TopicPartition> removedPartitions = new HashSet<>();\n+        final Iterator<Map.Entry<TopicPartition, RecordQueue>> queuesIterator = partitionQueues.entrySet().iterator();\n+        while (queuesIterator.hasNext()) {\n+            final Map.Entry<TopicPartition, RecordQueue> queueEntry = queuesIterator.next();\n+            final TopicPartition topicPartition = queueEntry.getKey();\n+            if (!newInputPartitions.contains(topicPartition)) {\n+                // if partition is removed should delete it's queue\n+                totalBuffered -= queueEntry.getValue().size();\n+                queuesIterator.remove();\n+                removedPartitions.add(topicPartition);\n+            }\n+            newInputPartitions.remove(topicPartition);\n+        }\n+        for (final TopicPartition newInputPartition : newInputPartitions) {\n+            partitionQueues.put(newInputPartition, recordQueueCreator.apply(newInputPartition));\n+        }\n+        nonEmptyQueuesByTime.removeIf(q -> removedPartitions.contains(q.partition()));\n+        allBuffered = allBuffered && newInputPartitions.isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ5ODg3Nw==", "bodyText": "fixed", "url": "https://github.com/apache/kafka/pull/8221#discussion_r426498877", "createdAt": "2020-05-18T09:41:14Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +96,28 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    // creates queues for new partitions, removes old queues, saves cached records for previously assigned partitions\n+    void updatePartitions(final Set<TopicPartition> newInputPartitions, final Function<TopicPartition, RecordQueue> recordQueueCreator) {\n+        final Set<TopicPartition> removedPartitions = new HashSet<>();\n+        final Iterator<Map.Entry<TopicPartition, RecordQueue>> queuesIterator = partitionQueues.entrySet().iterator();\n+        while (queuesIterator.hasNext()) {\n+            final Map.Entry<TopicPartition, RecordQueue> queueEntry = queuesIterator.next();\n+            final TopicPartition topicPartition = queueEntry.getKey();\n+            if (!newInputPartitions.contains(topicPartition)) {\n+                // if partition is removed should delete it's queue\n+                totalBuffered -= queueEntry.getValue().size();\n+                queuesIterator.remove();\n+                removedPartitions.add(topicPartition);\n+            }\n+            newInputPartitions.remove(topicPartition);\n+        }\n+        for (final TopicPartition newInputPartition : newInputPartitions) {\n+            partitionQueues.put(newInputPartition, recordQueueCreator.apply(newInputPartition));\n+        }\n+        nonEmptyQueuesByTime.removeIf(q -> removedPartitions.contains(q.partition()));\n+        allBuffered = allBuffered && newInputPartitions.isEmpty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4NjEyOQ=="}, "originalCommit": null, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NTUyNzUzOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjowMzoyM1rOGWojFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwOTo0MTowMVrOGWvawQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4NjE5OQ==", "bodyText": "s/it's/its", "url": "https://github.com/apache/kafka/pull/8221#discussion_r426386199", "createdAt": "2020-05-18T06:03:23Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +96,28 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    // creates queues for new partitions, removes old queues, saves cached records for previously assigned partitions\n+    void updatePartitions(final Set<TopicPartition> newInputPartitions, final Function<TopicPartition, RecordQueue> recordQueueCreator) {\n+        final Set<TopicPartition> removedPartitions = new HashSet<>();\n+        final Iterator<Map.Entry<TopicPartition, RecordQueue>> queuesIterator = partitionQueues.entrySet().iterator();\n+        while (queuesIterator.hasNext()) {\n+            final Map.Entry<TopicPartition, RecordQueue> queueEntry = queuesIterator.next();\n+            final TopicPartition topicPartition = queueEntry.getKey();\n+            if (!newInputPartitions.contains(topicPartition)) {\n+                // if partition is removed should delete it's queue", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ5ODc1Mw==", "bodyText": "fixed", "url": "https://github.com/apache/kafka/pull/8221#discussion_r426498753", "createdAt": "2020-05-18T09:41:01Z", "author": {"login": "avalsa"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +96,28 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    // creates queues for new partitions, removes old queues, saves cached records for previously assigned partitions\n+    void updatePartitions(final Set<TopicPartition> newInputPartitions, final Function<TopicPartition, RecordQueue> recordQueueCreator) {\n+        final Set<TopicPartition> removedPartitions = new HashSet<>();\n+        final Iterator<Map.Entry<TopicPartition, RecordQueue>> queuesIterator = partitionQueues.entrySet().iterator();\n+        while (queuesIterator.hasNext()) {\n+            final Map.Entry<TopicPartition, RecordQueue> queueEntry = queuesIterator.next();\n+            final TopicPartition topicPartition = queueEntry.getKey();\n+            if (!newInputPartitions.contains(topicPartition)) {\n+                // if partition is removed should delete it's queue", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4NjE5OQ=="}, "originalCommit": null, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3416, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}