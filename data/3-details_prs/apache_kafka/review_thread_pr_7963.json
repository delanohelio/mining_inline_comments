{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyOTEyNjMz", "number": 7963, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMToyNzozOVrODYCh0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMTozNzoxOFrODYCnTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTMzODQwOnYy", "diffSide": "LEFT", "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionStateManager.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMToyNzozOVrOFdq_Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMToyNzozOVrOFdq_Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY1NzMwNw==", "bodyText": "Note I got rid of this because there didn't seem to be a strong reason to do transaction state unloading asynchronously (all we do is remove a key from a map).", "url": "https://github.com/apache/kafka/pull/7963#discussion_r366657307", "createdAt": "2020-01-15T01:27:39Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionStateManager.scala", "diffHunk": "@@ -90,9 +90,6 @@ class TransactionStateManager(brokerId: Int,\n   /** partitions of transaction topic that are being loaded, state lock should be called BEFORE accessing this set */\n   private[transaction] val loadingPartitions: mutable.Set[TransactionPartitionAndLeaderEpoch] = mutable.Set()\n \n-  /** partitions of transaction topic that are being removed, state lock should be called BEFORE accessing this set */\n-  private[transaction] val leavingPartitions: mutable.Set[TransactionPartitionAndLeaderEpoch] = mutable.Set()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66e378c273f89b0918156f01908638443f2f6172"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTM1MjQ2OnYy", "diffSide": "LEFT", "path": "core/src/test/scala/unit/kafka/coordinator/transaction/TransactionStateManagerTest.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMTozNzoxOFrOFdrHXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMTozNzoxOFrOFdrHXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY1OTQyMQ==", "bodyText": "Minor test bug fix here.", "url": "https://github.com/apache/kafka/pull/7963#discussion_r366659421", "createdAt": "2020-01-15T01:37:18Z", "author": {"login": "hachikuji"}, "path": "core/src/test/scala/unit/kafka/coordinator/transaction/TransactionStateManagerTest.scala", "diffHunk": "@@ -106,11 +107,103 @@ class TransactionStateManagerTest {\n \n     assertEquals(Right(None), transactionManager.getTransactionState(transactionalId1))\n     assertEquals(Right(CoordinatorEpochAndTxnMetadata(coordinatorEpoch, txnMetadata1)),\n-      transactionManager.putTransactionStateIfNotExists(transactionalId1, txnMetadata1))\n+      transactionManager.putTransactionStateIfNotExists(txnMetadata1))\n     assertEquals(Right(Some(CoordinatorEpochAndTxnMetadata(coordinatorEpoch, txnMetadata1))),\n       transactionManager.getTransactionState(transactionalId1))\n-    assertEquals(Right(CoordinatorEpochAndTxnMetadata(coordinatorEpoch, txnMetadata1)),\n-      transactionManager.putTransactionStateIfNotExists(transactionalId1, txnMetadata2))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66e378c273f89b0918156f01908638443f2f6172"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4370, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}