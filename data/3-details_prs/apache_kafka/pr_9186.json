{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY4NDE3OTEy", "number": 9186, "title": "KAFKA-10277: Allow null keys with non-null mappedKey in KStreamKGlobalTable join", "bodyText": "Committer Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-08-16T08:50:47Z", "url": "https://github.com/apache/kafka/pull/9186", "merged": true, "mergeCommit": {"oid": "6e0a10b41ab1a5e68fc1d5b972a91dd43a86c40e"}, "closed": true, "closedAt": "2020-09-30T18:59:12Z", "author": {"login": "JoelWee"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc_Zy_bAH2gAyNDY4NDE3OTEyOjZiNGIzYTRmN2ZmMmNlNDY0NjdhOWZjNmEzMjMwMTYwNGE1M2FiMzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdHDAHmgFqTQ4NDYyMzk4OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6b4b3a4f7ff2ce46467a9fc6a32301604a53ab30", "author": {"user": {"login": "JoelWee", "name": null}}, "url": "https://github.com/apache/kafka/commit/6b4b3a4f7ff2ce46467a9fc6a32301604a53ab30", "committedDate": "2020-08-16T08:46:38Z", "message": "KAFKA-10277: Allow null keys with non-null mappedKey in KStreamGlobalKTable join"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyNzg4NTIy", "url": "https://github.com/apache/kafka/pull/9186#pullrequestreview-472788522", "createdAt": "2020-08-21T20:05:12Z", "commit": {"oid": "6b4b3a4f7ff2ce46467a9fc6a32301604a53ab30"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQyMDoxNjoyOVrOHE7gWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQyMDoyOTozMVrOHE8JKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDkzMTI4OQ==", "bodyText": "Should we really catch NPE here? It seems like if the user wants to return a non-null mapped key from a null key, then they should handle the null case specifically in their keyMapper and not just throw an NPE. In general, an NPE is a sign that something has gone wrong. I would be pretty surprised if I threw an NPE explicitly in my user code and it just got swallowed and interpreted as if I had actually returned null.", "url": "https://github.com/apache/kafka/pull/9186#discussion_r474931289", "createdAt": "2020-08-21T20:16:29Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java", "diffHunk": "@@ -58,29 +60,46 @@ public void init(final ProcessorContext context) {\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // we do join iff keys are equal, thus, if key is null we cannot join and just ignore the record\n-        // If {@code keyMapper} returns {@code null} it implies there is no match,\n-        // so ignore unless it is a left join\n+        // we do join iff the joining keys are equal, thus, if the mappedKey is null we cannot join\n+        // and just ignore the record.\n         //\n         // we also ignore the record if value is null, because in a key-value data model a null-value indicates\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n-        if (key == null || value == null) {\n+        final Optional<K2> maybeMappedKey = maybeExtractMappedKey(key, value);\n+        if (!maybeMappedKey.isPresent()) {\n             LOG.warn(\n                 \"Skipping record due to null key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n                 key, value, context().topic(), context().partition(), context().offset()\n             );\n             droppedRecordsSensor.record();\n         } else {\n-            final K2 mappedKey = keyMapper.apply(key, value);\n-            final V2 value2 = mappedKey == null ? null : getValueOrNull(valueGetter.get(mappedKey));\n+            final K2 mappedKey = maybeMappedKey.get();\n+            final V2 value2 = getValueOrNull(valueGetter.get(mappedKey));\n             if (leftJoin || value2 != null) {\n                 context().forward(key, joiner.apply(value, value2));\n             }\n         }\n     }\n \n+    private Optional<K2> maybeExtractMappedKey(final K1 key, final V1 value) {\n+        if (value == null) {\n+            return Optional.empty();\n+        }\n+\n+        // we allow the case where the key is null but mappedKey is not null and thus\n+        // we need to guard against nullPointerExceptions. This may happen for GlobalKTables.\n+        // For KTables, the keyMapper simply returns the key, so this will never happen\n+        Optional<K2> maybeMappedKey;\n+        try {\n+            maybeMappedKey = Optional.ofNullable(keyMapper.apply(key, value));\n+        } catch (final NullPointerException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b4b3a4f7ff2ce46467a9fc6a32301604a53ab30"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDkzNTcyNg==", "bodyText": "Why remove this check? The valueGetter.get does an actual table lookup, which would be wasteful if we're going to skip this record anyways because the mapped key is null. Also, I'm pretty sure the lookup would throw an NPE", "url": "https://github.com/apache/kafka/pull/9186#discussion_r474935726", "createdAt": "2020-08-21T20:21:58Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java", "diffHunk": "@@ -58,29 +60,46 @@ public void init(final ProcessorContext context) {\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // we do join iff keys are equal, thus, if key is null we cannot join and just ignore the record\n-        // If {@code keyMapper} returns {@code null} it implies there is no match,\n-        // so ignore unless it is a left join\n+        // we do join iff the joining keys are equal, thus, if the mappedKey is null we cannot join\n+        // and just ignore the record.\n         //\n         // we also ignore the record if value is null, because in a key-value data model a null-value indicates\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n-        if (key == null || value == null) {\n+        final Optional<K2> maybeMappedKey = maybeExtractMappedKey(key, value);\n+        if (!maybeMappedKey.isPresent()) {\n             LOG.warn(\n                 \"Skipping record due to null key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n                 key, value, context().topic(), context().partition(), context().offset()\n             );\n             droppedRecordsSensor.record();\n         } else {\n-            final K2 mappedKey = keyMapper.apply(key, value);\n-            final V2 value2 = mappedKey == null ? null : getValueOrNull(valueGetter.get(mappedKey));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b4b3a4f7ff2ce46467a9fc6a32301604a53ab30"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDk0MTczOA==", "bodyText": "We need to remove this too, right? We shouldn't forward anything regardless of whether it's a left join, if the mapped key is null then there's nothing to map it to", "url": "https://github.com/apache/kafka/pull/9186#discussion_r474941738", "createdAt": "2020-08-21T20:29:31Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java", "diffHunk": "@@ -58,29 +60,46 @@ public void init(final ProcessorContext context) {\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // we do join iff keys are equal, thus, if key is null we cannot join and just ignore the record\n-        // If {@code keyMapper} returns {@code null} it implies there is no match,\n-        // so ignore unless it is a left join\n+        // we do join iff the joining keys are equal, thus, if the mappedKey is null we cannot join\n+        // and just ignore the record.\n         //\n         // we also ignore the record if value is null, because in a key-value data model a null-value indicates\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n-        if (key == null || value == null) {\n+        final Optional<K2> maybeMappedKey = maybeExtractMappedKey(key, value);\n+        if (!maybeMappedKey.isPresent()) {\n             LOG.warn(\n                 \"Skipping record due to null key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n                 key, value, context().topic(), context().partition(), context().offset()\n             );\n             droppedRecordsSensor.record();\n         } else {\n-            final K2 mappedKey = keyMapper.apply(key, value);\n-            final V2 value2 = mappedKey == null ? null : getValueOrNull(valueGetter.get(mappedKey));\n+            final K2 mappedKey = maybeMappedKey.get();\n+            final V2 value2 = getValueOrNull(valueGetter.get(mappedKey));\n             if (leftJoin || value2 != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b4b3a4f7ff2ce46467a9fc6a32301604a53ab30"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNzI4NDAz", "url": "https://github.com/apache/kafka/pull/9186#pullrequestreview-473728403", "createdAt": "2020-08-24T17:53:23Z", "commit": {"oid": "6b4b3a4f7ff2ce46467a9fc6a32301604a53ab30"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzo1MzoyNFrOHFwFaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNzo1MzoyNFrOHFwFaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc5Mjc0NQ==", "bodyText": "This seems a little subtle. Can we just return the actual mapped key (or .empty()) in this method, and keep the explicit null check for value up above?", "url": "https://github.com/apache/kafka/pull/9186#discussion_r475792745", "createdAt": "2020-08-24T17:53:24Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java", "diffHunk": "@@ -58,29 +60,46 @@ public void init(final ProcessorContext context) {\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // we do join iff keys are equal, thus, if key is null we cannot join and just ignore the record\n-        // If {@code keyMapper} returns {@code null} it implies there is no match,\n-        // so ignore unless it is a left join\n+        // we do join iff the joining keys are equal, thus, if the mappedKey is null we cannot join\n+        // and just ignore the record.\n         //\n         // we also ignore the record if value is null, because in a key-value data model a null-value indicates\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n-        if (key == null || value == null) {\n+        final Optional<K2> maybeMappedKey = maybeExtractMappedKey(key, value);\n+        if (!maybeMappedKey.isPresent()) {\n             LOG.warn(\n                 \"Skipping record due to null key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n                 key, value, context().topic(), context().partition(), context().offset()\n             );\n             droppedRecordsSensor.record();\n         } else {\n-            final K2 mappedKey = keyMapper.apply(key, value);\n-            final V2 value2 = mappedKey == null ? null : getValueOrNull(valueGetter.get(mappedKey));\n+            final K2 mappedKey = maybeMappedKey.get();\n+            final V2 value2 = getValueOrNull(valueGetter.get(mappedKey));\n             if (leftJoin || value2 != null) {\n                 context().forward(key, joiner.apply(value, value2));\n             }\n         }\n     }\n \n+    private Optional<K2> maybeExtractMappedKey(final K1 key, final V1 value) {\n+        if (value == null) {\n+            return Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b4b3a4f7ff2ce46467a9fc6a32301604a53ab30"}, "originalPosition": 44}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9616c64dfdc33481d0b831f80ecd0385801c761", "author": {"user": {"login": "JoelWee", "name": null}}, "url": "https://github.com/apache/kafka/commit/e9616c64dfdc33481d0b831f80ecd0385801c761", "committedDate": "2020-08-26T03:55:01Z", "message": "KAFKA-10277: refactor join processor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwNDU1NzU2", "url": "https://github.com/apache/kafka/pull/9186#pullrequestreview-480455756", "createdAt": "2020-09-02T03:24:43Z", "commit": {"oid": "e9616c64dfdc33481d0b831f80ecd0385801c761"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMzoyNDo0M1rOHLSp2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMzoyNDo0M1rOHLSp2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTYwMjAxMA==", "bodyText": "It looks like we removed this comment about not ignoring it if it's a left join, but we didn't actually remove the code for that (yet). Which one is right? It seems like the comment is correct, and we shouldn't ignore the null key regardless of whether it is a left join. In that case, we should remove the leftJoin  part of the condition on line 78 below", "url": "https://github.com/apache/kafka/pull/9186#discussion_r481602010", "createdAt": "2020-09-02T03:24:43Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java", "diffHunk": "@@ -58,23 +58,22 @@ public void init(final ProcessorContext context) {\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // we do join iff keys are equal, thus, if key is null we cannot join and just ignore the record\n-        // If {@code keyMapper} returns {@code null} it implies there is no match,\n-        // so ignore unless it is a left join", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9616c64dfdc33481d0b831f80ecd0385801c761"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29c988afbb5d506474413ab387a45438cc0528d6", "author": {"user": {"login": "JoelWee", "name": null}}, "url": "https://github.com/apache/kafka/commit/29c988afbb5d506474413ab387a45438cc0528d6", "committedDate": "2020-09-05T23:07:09Z", "message": "KAFKA-10277: Fix null mappedKey with leftJoin condition"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "29c988afbb5d506474413ab387a45438cc0528d6", "author": {"user": {"login": "JoelWee", "name": null}}, "url": "https://github.com/apache/kafka/commit/29c988afbb5d506474413ab387a45438cc0528d6", "committedDate": "2020-09-05T23:07:09Z", "message": "KAFKA-10277: Fix null mappedKey with leftJoin condition"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MzY2OTI0", "url": "https://github.com/apache/kafka/pull/9186#pullrequestreview-484366924", "createdAt": "2020-09-08T17:50:50Z", "commit": {"oid": "29c988afbb5d506474413ab387a45438cc0528d6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNzo1MDo1MFrOHOn5Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNzo1MDo1MFrOHOn5Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5NTczNQ==", "bodyText": "I guess we don't care about the original key any longer and only consider if keyMapper returns null or not?", "url": "https://github.com/apache/kafka/pull/9186#discussion_r485095735", "createdAt": "2020-09-08T17:50:50Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java", "diffHunk": "@@ -58,22 +58,23 @@ public void init(final ProcessorContext context) {\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // we do join iff keys are equal, thus, if key is null we cannot join and just ignore the record\n-        // If {@code keyMapper} returns {@code null} it implies there is no match,\n+        // We allow null keys unless {@code keyMapper} returns {@code null} and we ignore it as invalid.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29c988afbb5d506474413ab387a45438cc0528d6"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MzY3MzU4", "url": "https://github.com/apache/kafka/pull/9186#pullrequestreview-484367358", "createdAt": "2020-09-08T17:51:26Z", "commit": {"oid": "29c988afbb5d506474413ab387a45438cc0528d6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNzo1MToyNlrOHOn6mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNzo1MToyNlrOHOn6mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5NjA5MA==", "bodyText": "This condition seems unnecessary complex. Should it not just be:\nif (mappedKey == null || value == null) {", "url": "https://github.com/apache/kafka/pull/9186#discussion_r485096090", "createdAt": "2020-09-08T17:51:26Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java", "diffHunk": "@@ -58,22 +58,23 @@ public void init(final ProcessorContext context) {\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // we do join iff keys are equal, thus, if key is null we cannot join and just ignore the record\n-        // If {@code keyMapper} returns {@code null} it implies there is no match,\n+        // We allow null keys unless {@code keyMapper} returns {@code null} and we ignore it as invalid.\n+        // This happens for GlobalKTables but never for KTables since keyMapper just returns the key.\n+        // For non-null keys, if {@code keyMapper} returns {@code null} it implies there is no match,\n         // so ignore unless it is a left join\n         //\n         // we also ignore the record if value is null, because in a key-value data model a null-value indicates\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n-        if (key == null || value == null) {\n+        final K2 mappedKey = keyMapper.apply(key, value);\n+        if ((key == null && mappedKey == null) || (!leftJoin && mappedKey == null) || value == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29c988afbb5d506474413ab387a45438cc0528d6"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MzY3OTU2", "url": "https://github.com/apache/kafka/pull/9186#pullrequestreview-484367956", "createdAt": "2020-09-08T17:52:22Z", "commit": {"oid": "29c988afbb5d506474413ab387a45438cc0528d6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNzo1MjoyMlrOHOn8hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNzo1MjoyMlrOHOn8hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5NjU4MQ==", "bodyText": "At this point, we know that mappedKey != null, otherwise, we would have dropped the record.", "url": "https://github.com/apache/kafka/pull/9186#discussion_r485096581", "createdAt": "2020-09-08T17:52:22Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamKTableJoinProcessor.java", "diffHunk": "@@ -58,22 +58,23 @@ public void init(final ProcessorContext context) {\n \n     @Override\n     public void process(final K1 key, final V1 value) {\n-        // we do join iff keys are equal, thus, if key is null we cannot join and just ignore the record\n-        // If {@code keyMapper} returns {@code null} it implies there is no match,\n+        // We allow null keys unless {@code keyMapper} returns {@code null} and we ignore it as invalid.\n+        // This happens for GlobalKTables but never for KTables since keyMapper just returns the key.\n+        // For non-null keys, if {@code keyMapper} returns {@code null} it implies there is no match,\n         // so ignore unless it is a left join\n         //\n         // we also ignore the record if value is null, because in a key-value data model a null-value indicates\n         // an empty message (ie, there is nothing to be joined) -- this contrast SQL NULL semantics\n         // furthermore, on left/outer joins 'null' in ValueJoiner#apply() indicates a missing record --\n         // thus, to be consistent and to avoid ambiguous null semantics, null values are ignored\n-        if (key == null || value == null) {\n+        final K2 mappedKey = keyMapper.apply(key, value);\n+        if ((key == null && mappedKey == null) || (!leftJoin && mappedKey == null) || value == null) {\n             LOG.warn(\n                 \"Skipping record due to null key or value. key=[{}] value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n                 key, value, context().topic(), context().partition(), context().offset()\n             );\n             droppedRecordsSensor.record();\n         } else {\n-            final K2 mappedKey = keyMapper.apply(key, value);\n             final V2 value2 = mappedKey == null ? null : getValueOrNull(valueGetter.get(mappedKey));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29c988afbb5d506474413ab387a45438cc0528d6"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d23f46c11c41b03834d67e5cdc6b558923365d61", "author": {"user": {"login": "JoelWee", "name": null}}, "url": "https://github.com/apache/kafka/commit/d23f46c11c41b03834d67e5cdc6b558923365d61", "committedDate": "2020-09-08T23:03:41Z", "message": "KAFKA-10277: fix mappedKey logic"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NjIzOTg5", "url": "https://github.com/apache/kafka/pull/9186#pullrequestreview-484623989", "createdAt": "2020-09-09T02:44:33Z", "commit": {"oid": "d23f46c11c41b03834d67e5cdc6b558923365d61"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 773, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}