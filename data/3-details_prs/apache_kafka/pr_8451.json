{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwOTM5NjE2", "number": 8451, "title": "KAFKA-9835; Protect `FileRecords.slice` from concurrent write", "bodyText": "A read from the end of the log interleaved with a concurrent write can result in reading data above the expected limit. In particular, this would allow a read above the high watermark. The root of the problem is consecutive calls to sizeInBytes in FileRecords.slice which do not account for an increase in size. This patch fixes the problem by using a single call to sizeInBytes and caching the result.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-04-08T16:02:08Z", "url": "https://github.com/apache/kafka/pull/8451", "merged": true, "mergeCommit": {"oid": "778b1e3f5435c5b98fb52a4e15fc32d5cfa2c92c"}, "closed": true, "closedAt": "2020-04-08T18:31:28Z", "author": {"login": "hachikuji"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcVqEBjAH2gAyNDAwOTM5NjE2OmEzNjJiNDViODE0YTU3MTI4NjFkN2VjYTY2ZjE0NTMzNjFhYTFiZmY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcVqkvTAFqTM5MDE0MTUxNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a362b45b814a5712861d7eca66f1453361aa1bff", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/a362b45b814a5712861d7eca66f1453361aa1bff", "committedDate": "2020-04-08T15:58:54Z", "message": "KAFKA-9835; Protect `FileRecords.slice` from concurrent write"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMTI3Njk5", "url": "https://github.com/apache/kafka/pull/8451#pullrequestreview-390127699", "createdAt": "2020-04-08T16:16:17Z", "commit": {"oid": "a362b45b814a5712861d7eca66f1453361aa1bff"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjoxNjoxN1rOGC2syA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjoxNjoxN1rOGC2syA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0NjUzNg==", "bodyText": "Was the boundary check wrong? You changed >= to >.", "url": "https://github.com/apache/kafka/pull/8451#discussion_r405646536", "createdAt": "2020-04-08T16:16:17Z", "author": {"login": "ijuma"}, "path": "clients/src/main/java/org/apache/kafka/common/record/FileRecords.java", "diffHunk": "@@ -135,17 +135,20 @@ public void readInto(ByteBuffer buffer, int position) throws IOException {\n      * @return A sliced wrapper on this message set limited based on the given position and size\n      */\n     public FileRecords slice(int position, int size) throws IOException {\n+        // Cache current size in case concurrent write changes it\n+        int currentSizeInBytes = sizeInBytes();\n+\n         if (position < 0)\n             throw new IllegalArgumentException(\"Invalid position: \" + position + \" in read from \" + this);\n-        if (position > sizeInBytes() - start)\n+        if (position > currentSizeInBytes - start)\n             throw new IllegalArgumentException(\"Slice from position \" + position + \" exceeds end position of \" + this);\n         if (size < 0)\n             throw new IllegalArgumentException(\"Invalid size: \" + size + \" in read from \" + this);\n \n         int end = this.start + position + size;\n         // handle integer overflow or if end is beyond the end of the file\n-        if (end < 0 || end >= start + sizeInBytes())\n-            end = start + sizeInBytes();\n+        if (end < 0 || end > start + currentSizeInBytes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a362b45b814a5712861d7eca66f1453361aa1bff"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMTQxNTE2", "url": "https://github.com/apache/kafka/pull/8451#pullrequestreview-390141516", "createdAt": "2020-04-08T16:33:34Z", "commit": {"oid": "a362b45b814a5712861d7eca66f1453361aa1bff"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjozMzozNFrOGC3ZsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjozMzozNFrOGC3ZsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1ODAzMg==", "bodyText": "How often does this fail?", "url": "https://github.com/apache/kafka/pull/8451#discussion_r405658032", "createdAt": "2020-04-08T16:33:34Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/record/FileRecordsTest.java", "diffHunk": "@@ -118,6 +121,36 @@ public void testIterationOverPartialAndTruncation() throws IOException {\n         testPartialWrite(6, fileRecords);\n     }\n \n+    @Test\n+    public void testSliceSizeLimitWithConcurrentWrite() throws Exception {\n+        FileRecords log = FileRecords.open(tempFile());\n+        ExecutorService executor = Executors.newFixedThreadPool(2);\n+        int maxSizeInBytes = 16384;\n+\n+        try {\n+            Future<Object> readerCompletion = executor.submit(() -> {\n+                while (log.sizeInBytes() < maxSizeInBytes) {\n+                    int currentSize = log.sizeInBytes();\n+                    FileRecords slice = log.slice(0, currentSize);\n+                    assertEquals(currentSize, slice.sizeInBytes());\n+                }\n+                return null;\n+            });\n+\n+            Future<Object> writerCompletion = executor.submit(() -> {\n+                while (log.sizeInBytes() < maxSizeInBytes) {\n+                    append(log, values);\n+                }\n+                return null;\n+            });\n+\n+            writerCompletion.get();\n+            readerCompletion.get();\n+        } finally {\n+            executor.shutdownNow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a362b45b814a5712861d7eca66f1453361aa1bff"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1432, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}