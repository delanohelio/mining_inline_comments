{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwMzEyNDcy", "number": 8695, "title": "KAFKA-9320: Enable TLSv1.3 by default (KIP-573)", "bodyText": "Enables TLSv1.3 by default with Java 11 or newer.\nAdd unit tests that cover the various TLSv1.2 and TLSv1.3 combinations.\nExtend benchmark_test.py and replication_test.py to run with 'TLSv1.2'\nor 'TLSv1.3'.\n\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-05-19T19:12:57Z", "url": "https://github.com/apache/kafka/pull/8695", "merged": true, "mergeCommit": {"oid": "8b22b8159673bfe22d8ac5dcd4e4312d4f2c863c"}, "closed": true, "closedAt": "2020-06-02T22:34:44Z", "author": {"login": "nizhikov"}, "timelineItems": {"totalCount": 52, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcixLEqgH2gAyNDIwMzEyNDcyOjE4YTFiY2EzODVkOTIxMjkyMzY5NjUwZjMyOTliNWNjYjJlMmY3OGQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcnabuygH2gAyNDIwMzEyNDcyOmIyOTM1NzgzYzU0ZTE3YjIwODgzMmE3NDk2MDBhMTI5MjNiNjI1ZDg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "18a1bca385d921292369650f3299b5ccb2e2f78d", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/18a1bca385d921292369650f3299b5ccb2e2f78d", "committedDate": "2020-05-19T09:36:57Z", "message": "KAFKA-9320: Initial commit."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1076e5187fa045ec8198842e109b3afc14b6c059", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/1076e5187fa045ec8198842e109b3afc14b6c059", "committedDate": "2020-05-19T19:17:19Z", "message": "KAFKA-9320: Initial commit."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1MzQ2NDkw", "url": "https://github.com/apache/kafka/pull/8695#pullrequestreview-415346490", "createdAt": "2020-05-20T13:41:38Z", "commit": {"oid": "1076e5187fa045ec8198842e109b3afc14b6c059"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMzo0MTozOFrOGYMRaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxMzo0MTozOFrOGYMRaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODAyMDA3Mg==", "bodyText": "I think you want to leave this as the default and see if it works correctly.", "url": "https://github.com/apache/kafka/pull/8695#discussion_r428020072", "createdAt": "2020-05-20T13:41:38Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +622,34 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2() throws Exception {\n+        String node = \"0\";\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(SslConfigs.DEFAULT_SSL_ENABLED_PROTOCOLS.split(\",\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1076e5187fa045ec8198842e109b3afc14b6c059"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7dec0d658a1972fff7d3cf37ab293c6b0460cdbc", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/7dec0d658a1972fff7d3cf37ab293c6b0460cdbc", "committedDate": "2020-05-20T16:56:35Z", "message": "KAFKA-9320: Test added"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6afbb92ff2b5255e18ce76af2c1c20f6cef6eee", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/f6afbb92ff2b5255e18ce76af2c1c20f6cef6eee", "committedDate": "2020-05-20T17:08:11Z", "message": "KAFKA-9320: Test added"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "142e487e9eea558d145a9487fcd054753ea50615", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/142e487e9eea558d145a9487fcd054753ea50615", "committedDate": "2020-05-20T17:10:10Z", "message": "KAFKA-9320: Test added"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac448d173f5ce727d3aee02ef4dbac15a38f28ff", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/ac448d173f5ce727d3aee02ef4dbac15a38f28ff", "committedDate": "2020-05-20T17:21:44Z", "message": "KAFKA-9320: Test added"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1287c610f938bf0c379fa892cb0a13dee27a444", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/e1287c610f938bf0c379fa892cb0a13dee27a444", "committedDate": "2020-05-25T14:58:50Z", "message": "KAFKA-9320: SslVersionsTransportLayerTest added."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b310e6052600fde7db7187dfc781e5f650d56bf0", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/b310e6052600fde7db7187dfc781e5f650d56bf0", "committedDate": "2020-05-26T08:54:36Z", "message": "KAFKA-9320: Tests fix."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "518eb77b5bf4075db449bc4cf0aff89981987eae", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/518eb77b5bf4075db449bc4cf0aff89981987eae", "committedDate": "2020-05-26T16:49:20Z", "message": "KAFKA-9320: system tests updated."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b5f37e458e0bfb0a017cabfa8ac8b677a6efbc5", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/5b5f37e458e0bfb0a017cabfa8ac8b677a6efbc5", "committedDate": "2020-05-27T07:08:20Z", "message": "KAFKA-9320: system tests updated."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/c7000d9e7372824762db02cf4a5dd6688726ba32", "committedDate": "2020-05-27T09:41:30Z", "message": "KAFKA-9320: system tests updated."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NzgyNTA4", "url": "https://github.com/apache/kafka/pull/8695#pullrequestreview-419782508", "createdAt": "2020-05-28T05:15:00Z", "commit": {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32"}, "state": "COMMENTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNToxNTowMFrOGbl6GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQwNTo0ODozMlrOGbmebQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4NTgxNg==", "bodyText": "Why do we need this change?", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431585816", "createdAt": "2020-05-28T05:15:00Z", "author": {"login": "ijuma"}, "path": "tests/kafkatest/services/kafka/kafka.py", "diffHunk": "@@ -352,17 +357,18 @@ def start_cmd(self, node):\n                 KafkaService.STDOUT_STDERR_CAPTURE)\n         return cmd\n \n-    def start_node(self, node, timeout_sec=60):\n+    def start_node(self, node, timeout_sec=180):", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4NTkxMg==", "bodyText": "Is this intentional?", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431585912", "createdAt": "2020-05-28T05:15:21Z", "author": {"login": "ijuma"}, "path": "tests/kafkatest/services/kafka/kafka.py", "diffHunk": "@@ -52,6 +51,7 @@ def advertised_listener(self, node):\n     def listener_security_protocol(self):\n         return \"%s:%s\" % (self.name, self.security_protocol)\n \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4NzcwMg==", "bodyText": "We can use assume to do this in a more idiomatic way. Same for other places where we do something similar.", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431587702", "createdAt": "2020-05-28T05:22:28Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +619,81 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2_FailsForTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4Nzk1OQ==", "bodyText": "This comment seems incorrect.", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431587959", "createdAt": "2020-05-28T05:23:26Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +619,81 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2_FailsForTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+        server.verifyAuthenticationMetrics(0, 1);\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4ODcxNw==", "bodyText": "Can we replace\nArrays.asList(SslConfigs.DEFAULT_SSL_ENABLED_PROTOCOLS.split(\",\"))\nwith\nSslConfigs.DEFAULT_SSL_ENABLED_PROTOCOLS\nDoesn't the code handle comma separated Strings?", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431588717", "createdAt": "2020-05-28T05:26:09Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +619,81 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2_FailsForTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+        server.verifyAuthenticationMetrics(0, 1);\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteFailForServerTLSv1_2_ClientTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.2\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2() throws Exception {\n+        String node = \"0\";\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(SslConfigs.DEFAULT_SSL_ENABLED_PROTOCOLS.split(\",\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4ODk0Mg==", "bodyText": "Do these have to be public or can they be package private?", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431588942", "createdAt": "2020-05-28T05:27:01Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -1250,7 +1322,7 @@ private NioEchoServer createEchoServer(SecurityProtocol securityProtocol) throws\n         void run() throws IOException;\n     }\n \n-    private static class TestSslChannelBuilder extends SslChannelBuilder {\n+    public static class TestSslChannelBuilder extends SslChannelBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4OTUyMw==", "bodyText": "The important detail is that TLS 1.3 is enabled too, right?", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431589523", "createdAt": "2020-05-28T05:28:48Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +619,81 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2_FailsForTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+        server.verifyAuthenticationMetrics(0, 1);\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteFailForServerTLSv1_2_ClientTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.2\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4OTY3Mw==", "bodyText": "Can we set this to DEFAULT_SSL_PROTOCOL?", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431589673", "createdAt": "2020-05-28T05:29:26Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +619,81 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2_FailsForTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+        server.verifyAuthenticationMetrics(0, 1);\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteFailForServerTLSv1_2_ClientTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.2\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2() throws Exception {\n+        String node = \"0\";\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU4OTc1Nw==", "bodyText": "Same here, can we SslConfigs.DEFAULT_SSL_PROTOCOL?", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431589757", "createdAt": "2020-05-28T05:29:50Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +619,81 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2_FailsForTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+        server.verifyAuthenticationMetrics(0, 1);\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteFailForServerTLSv1_2_ClientTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.2\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2() throws Exception {\n+        String node = \"0\";\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(SslConfigs.DEFAULT_SSL_ENABLED_PROTOCOLS.split(\",\")));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MTA2OQ==", "bodyText": "If we take the suggestions to use DEFAULT_SSL_PROTOCOL, then this test is checking that we can negotiate TLSv1.2 if the custom cipher suites are only compatible with TLSv1.2 and we use the default protocol configuration (TLSv1.3).", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431591069", "createdAt": "2020-05-28T05:34:12Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +619,81 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2_FailsForTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+        server.verifyAuthenticationMetrics(0, 1);\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteFailForServerTLSv1_2_ClientTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.2\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MTE2OQ==", "bodyText": "Why did we remove both lines above?", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431591169", "createdAt": "2020-05-28T05:34:32Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -591,10 +591,7 @@ public void testUnsupportedCipher() throws Exception {\n             createSelector(sslClientConfigs);\n \n             checkAuthentiationFailed(\"1\", \"TLSv1.1\");\n-            server.verifyAuthenticationMetrics(0, 1);\n-\n             checkAuthentiationFailed(\"2\", \"TLSv1\");\n-            server.verifyAuthenticationMetrics(0, 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MTUzNw==", "bodyText": "Nit: the test should be testTlsDefaults to match the naming convention.", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431591537", "createdAt": "2020-05-28T05:35:44Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslVersionsTransportLayerTest.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.network;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.kafka.common.metrics.Metrics;\n+import org.apache.kafka.common.security.TestSecurityConfig;\n+import org.apache.kafka.common.security.auth.SecurityProtocol;\n+import org.apache.kafka.common.utils.Java;\n+import org.apache.kafka.common.utils.LogContext;\n+import org.apache.kafka.common.utils.Time;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests for the SSL transport layer.\n+ * Checks different versions of the protocol usage on the server and client.\n+ */\n+@RunWith(value = Parameterized.class)\n+public class SslVersionsTransportLayerTest {\n+    private static final int BUFFER_SIZE = 4 * 1024;\n+    private static final Time TIME = Time.SYSTEM;\n+\n+    private final String tlsServerProtocol;\n+    private final String tlsClientProtocol;\n+\n+    @Parameterized.Parameters(name = \"tlsServerProtocol={0},tlsClientProtocol={1}\")\n+    public static Collection<Object[]> data() {\n+        List<Object[]> values = new ArrayList<>();\n+        values.add(new Object[] {\"TLSv1.2\", \"TLSv1.2\"});\n+        if (Java.IS_JAVA11_COMPATIBLE) {\n+            values.add(new Object[] {\"TLSv1.2\", \"TLSv1.3\"});\n+            values.add(new Object[] {\"TLSv1.3\", \"TLSv1.2\"});\n+            values.add(new Object[] {\"TLSv1.3\", \"TLSv1.3\"});\n+        }\n+        return values;\n+    }\n+\n+    public SslVersionsTransportLayerTest(String tlsServerProtocol, String tlsClientProtocol) {\n+        this.tlsServerProtocol = tlsServerProtocol;\n+        this.tlsClientProtocol = tlsClientProtocol;\n+    }\n+\n+    /**\n+     * Tests that connection success with the default TLS version.\n+     */\n+    @Test\n+    public void testTLSDefaults() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MTkwMw==", "bodyText": "We probably don't need these empty lines.", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431591903", "createdAt": "2020-05-28T05:37:05Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslVersionsTransportLayerTest.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.network;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.kafka.common.metrics.Metrics;\n+import org.apache.kafka.common.security.TestSecurityConfig;\n+import org.apache.kafka.common.security.auth.SecurityProtocol;\n+import org.apache.kafka.common.utils.Java;\n+import org.apache.kafka.common.utils.LogContext;\n+import org.apache.kafka.common.utils.Time;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests for the SSL transport layer.\n+ * Checks different versions of the protocol usage on the server and client.\n+ */\n+@RunWith(value = Parameterized.class)\n+public class SslVersionsTransportLayerTest {\n+    private static final int BUFFER_SIZE = 4 * 1024;\n+    private static final Time TIME = Time.SYSTEM;\n+\n+    private final String tlsServerProtocol;\n+    private final String tlsClientProtocol;\n+\n+    @Parameterized.Parameters(name = \"tlsServerProtocol={0},tlsClientProtocol={1}\")\n+    public static Collection<Object[]> data() {\n+        List<Object[]> values = new ArrayList<>();\n+        values.add(new Object[] {\"TLSv1.2\", \"TLSv1.2\"});\n+        if (Java.IS_JAVA11_COMPATIBLE) {\n+            values.add(new Object[] {\"TLSv1.2\", \"TLSv1.3\"});\n+            values.add(new Object[] {\"TLSv1.3\", \"TLSv1.2\"});\n+            values.add(new Object[] {\"TLSv1.3\", \"TLSv1.3\"});\n+        }\n+        return values;\n+    }\n+\n+    public SslVersionsTransportLayerTest(String tlsServerProtocol, String tlsClientProtocol) {\n+        this.tlsServerProtocol = tlsServerProtocol;\n+        this.tlsClientProtocol = tlsClientProtocol;\n+    }\n+\n+    /**\n+     * Tests that connection success with the default TLS version.\n+     */\n+    @Test\n+    public void testTLSDefaults() throws Exception {\n+        // Create certificates for use by client and server. Add server cert to client truststore and vice versa.\n+        CertStores serverCertStores = new CertStores(true, \"server\",  \"localhost\");\n+        CertStores clientCertStores = new CertStores(false, \"client\", \"localhost\");\n+\n+        Map<String, Object> sslClientConfigs = getTrustingConfig(clientCertStores, serverCertStores, tlsClientProtocol);\n+        Map<String, Object> sslServerConfigs = getTrustingConfig(serverCertStores, clientCertStores, tlsServerProtocol);\n+\n+        NioEchoServer server = NetworkTestUtils.createEchoServer(ListenerName.forSecurityProtocol(SecurityProtocol.SSL),\n+             SecurityProtocol.SSL,\n+             new TestSecurityConfig(sslServerConfigs),\n+             null,\n+            TIME);\n+        Selector selector = createSelector(sslClientConfigs);\n+\n+        String node = \"0\";\n+        selector.connect(node, new InetSocketAddress(\"localhost\", server.port()), BUFFER_SIZE, BUFFER_SIZE);\n+\n+        if (tlsServerProtocol.equals(tlsClientProtocol)) {\n+            NetworkTestUtils.waitForChannelReady(selector, node);\n+\n+            int msgSz = 1024 * 1024;\n+            String message = TestUtils.randomString(msgSz);\n+            selector.send(new NetworkSend(node, ByteBuffer.wrap(message.getBytes())));\n+            while (selector.completedReceives().isEmpty()) {\n+                selector.poll(100L);\n+            }\n+            int totalBytes = msgSz + 4; // including 4-byte size\n+            server.waitForMetric(\"incoming-byte\", totalBytes);\n+            server.waitForMetric(\"outgoing-byte\", totalBytes);\n+            server.waitForMetric(\"request\", 1);\n+            server.waitForMetric(\"response\", 1);\n+        } else {\n+            NetworkTestUtils.waitForChannelClose(selector, node, ChannelState.State.AUTHENTICATION_FAILED);\n+        }\n+    }\n+\n+    public static Map<String, Object> sslConfig(String tlsServerProtocol) {\n+        Map<String, Object> sslConfig = new HashMap<>();\n+\n+        sslConfig.put(SslConfigs.SSL_PROTOCOL_CONFIG, tlsServerProtocol);\n+        sslConfig.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Collections.singletonList(tlsServerProtocol));\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MjM1Nw==", "bodyText": "Could we have each parameter be a list so that we can set enabled protocols with more than one element?", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431592357", "createdAt": "2020-05-28T05:38:32Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslVersionsTransportLayerTest.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.network;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.kafka.common.metrics.Metrics;\n+import org.apache.kafka.common.security.TestSecurityConfig;\n+import org.apache.kafka.common.security.auth.SecurityProtocol;\n+import org.apache.kafka.common.utils.Java;\n+import org.apache.kafka.common.utils.LogContext;\n+import org.apache.kafka.common.utils.Time;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests for the SSL transport layer.\n+ * Checks different versions of the protocol usage on the server and client.\n+ */\n+@RunWith(value = Parameterized.class)\n+public class SslVersionsTransportLayerTest {\n+    private static final int BUFFER_SIZE = 4 * 1024;\n+    private static final Time TIME = Time.SYSTEM;\n+\n+    private final String tlsServerProtocol;\n+    private final String tlsClientProtocol;\n+\n+    @Parameterized.Parameters(name = \"tlsServerProtocol={0},tlsClientProtocol={1}\")\n+    public static Collection<Object[]> data() {\n+        List<Object[]> values = new ArrayList<>();\n+        values.add(new Object[] {\"TLSv1.2\", \"TLSv1.2\"});\n+        if (Java.IS_JAVA11_COMPATIBLE) {\n+            values.add(new Object[] {\"TLSv1.2\", \"TLSv1.3\"});\n+            values.add(new Object[] {\"TLSv1.3\", \"TLSv1.2\"});\n+            values.add(new Object[] {\"TLSv1.3\", \"TLSv1.3\"});\n+        }\n+        return values;\n+    }\n+\n+    public SslVersionsTransportLayerTest(String tlsServerProtocol, String tlsClientProtocol) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MjQ4NA==", "bodyText": "Do we intend to change this temporarily or permanently?", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431592484", "createdAt": "2020-05-28T05:39:06Z", "author": {"login": "ijuma"}, "path": "tests/docker/run_tests.sh", "diffHunk": "@@ -30,6 +30,6 @@ if [ \"$REBUILD\" == \"t\" ]; then\n fi\n \n if ${SCRIPT_DIR}/ducker-ak ssh | grep -q '(none)'; then\n-    ${SCRIPT_DIR}/ducker-ak up -n \"${KAFKA_NUM_CONTAINERS}\" || die \"ducker-ak up failed\"\n+    ${SCRIPT_DIR}/ducker-ak up -j 'openjdk:11' -n \"${KAFKA_NUM_CONTAINERS}\" || die \"ducker-ak up failed\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MjY0Ng==", "bodyText": "We should also add a similar test where the custom cipher is a TLS 1.3 cipher.", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431592646", "createdAt": "2020-05-28T05:39:40Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +619,81 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2_FailsForTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+        server.verifyAuthenticationMetrics(0, 1);\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteFailForServerTLSv1_2_ClientTLSv1_3() throws Exception {\n+        if (!Java.IS_JAVA11_COMPATIBLE)\n+            return;\n+\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.2\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5MTA2OQ=="}, "originalCommit": {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTU5NTExNw==", "bodyText": "Maybe we can configure the TLS version for benchmark_test.py and replication_test.py only. The rest can use the default, which will be TLS 1.3 for Java 11 and TLS 1.2 for Java 8. That would not inflate test times by too much. What do you think?", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431595117", "createdAt": "2020-05-28T05:48:32Z", "author": {"login": "ijuma"}, "path": "tests/kafkatest/benchmarks/core/benchmark_test.py", "diffHunk": "@@ -236,9 +238,9 @@ def test_producer_and_consumer(self, compression_type=\"none\", security_protocol=\n         return data\n \n     @cluster(num_nodes=6)\n-    @parametrize(security_protocol='SSL', interbroker_security_protocol='PLAINTEXT')\n-    @matrix(security_protocol=['PLAINTEXT', 'SSL'], compression_type=[\"none\", \"snappy\"])\n-    def test_consumer_throughput(self, compression_type=\"none\", security_protocol=\"PLAINTEXT\",\n+    @matrix(security_protocol=['SSL'], interbroker_security_protocol=['PLAINTEXT'], tls_version=['TLSv1.2', 'TLSv1.3'], compression_type=[\"none\", \"snappy\"])\n+    @matrix(security_protocol=['PLAINTEXT'], compression_type=[\"none\", \"snappy\"])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7000d9e7372824762db02cf4a5dd6688726ba32"}, "originalPosition": 116}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "862f7ae4eceeb43135409da0762c3519260739a4", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/862f7ae4eceeb43135409da0762c3519260739a4", "committedDate": "2020-05-28T08:48:24Z", "message": "KAFKA-9320: code review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1dd114ffbdf17f24253681c9b90186181bc560a", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/d1dd114ffbdf17f24253681c9b90186181bc560a", "committedDate": "2020-05-28T08:49:03Z", "message": "Merge branch 'trunk' into KAFKA-9320"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5578192735c999fc070b1c9559c7a3d3f3cbe2df", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/5578192735c999fc070b1c9559c7a3d3f3cbe2df", "committedDate": "2020-05-28T09:09:28Z", "message": "KAFKA-9320: code review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1847e7e30e61633e6616e5c2e8bb93d8cfb4eb6", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/c1847e7e30e61633e6616e5c2e8bb93d8cfb4eb6", "committedDate": "2020-05-28T09:13:39Z", "message": "KAFKA-9320: code review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9012549a724719e641e2ab8c3883c7aaf4c4fa1", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/c9012549a724719e641e2ab8c3883c7aaf4c4fa1", "committedDate": "2020-05-28T09:14:27Z", "message": "KAFKA-9320: code review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61cd6c5e667a9ca1f1b7b94dd0590c4b8c1d0899", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/61cd6c5e667a9ca1f1b7b94dd0590c4b8c1d0899", "committedDate": "2020-05-28T11:48:27Z", "message": "KAFKA-9320: code review fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMDk2MjU5", "url": "https://github.com/apache/kafka/pull/8695#pullrequestreview-420096259", "createdAt": "2020-05-28T13:17:37Z", "commit": {"oid": "61cd6c5e667a9ca1f1b7b94dd0590c4b8c1d0899"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzoxNzozN1rOGb0n4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzoxNzozN1rOGb0n4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyNjkxNQ==", "bodyText": "Shouldn't this check if the intersection of server and client protocols is non empty?", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431826915", "createdAt": "2020-05-28T13:17:37Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslVersionsTransportLayerTest.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.network;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.kafka.common.metrics.Metrics;\n+import org.apache.kafka.common.security.TestSecurityConfig;\n+import org.apache.kafka.common.security.auth.SecurityProtocol;\n+import org.apache.kafka.common.utils.Java;\n+import org.apache.kafka.common.utils.LogContext;\n+import org.apache.kafka.common.utils.Time;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests for the SSL transport layer.\n+ * Checks different versions of the protocol usage on the server and client.\n+ */\n+@RunWith(value = Parameterized.class)\n+public class SslVersionsTransportLayerTest {\n+    private static final int BUFFER_SIZE = 4 * 1024;\n+    private static final Time TIME = Time.SYSTEM;\n+\n+    private final List<String> tlsServerProtocols;\n+    private final List<String> tlsClientProtocols;\n+\n+    @Parameterized.Parameters(name = \"tlsServerProtocol={0},tlsClientProtocol={1}\")\n+    public static Collection<Object[]> data() {\n+        List<Object[]> values = new ArrayList<>();\n+        values.add(new Object[] {Arrays.asList(\"TLSv1.2\"), Arrays.asList(\"TLSv1.2\")});\n+        if (Java.IS_JAVA11_COMPATIBLE) {\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\"), Arrays.asList(\"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\"), Arrays.asList(\"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\"), Arrays.asList(\"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Arrays.asList(\"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Arrays.asList(\"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+        }\n+        return values;\n+    }\n+\n+    public SslVersionsTransportLayerTest(List<String> tlsServerProtocols, List<String> tlsClientProtocols) {\n+        this.tlsServerProtocols = tlsServerProtocols;\n+        this.tlsClientProtocols = tlsClientProtocols;\n+    }\n+\n+    /**\n+     * Tests that connection success with the default TLS version.\n+     */\n+    @Test\n+    public void testTlsDefaults() throws Exception {\n+        // Create certificates for use by client and server. Add server cert to client truststore and vice versa.\n+        CertStores serverCertStores = new CertStores(true, \"server\",  \"localhost\");\n+        CertStores clientCertStores = new CertStores(false, \"client\", \"localhost\");\n+\n+        Map<String, Object> sslClientConfigs = getTrustingConfig(clientCertStores, serverCertStores, tlsClientProtocols);\n+        Map<String, Object> sslServerConfigs = getTrustingConfig(serverCertStores, clientCertStores, tlsServerProtocols);\n+\n+        NioEchoServer server = NetworkTestUtils.createEchoServer(ListenerName.forSecurityProtocol(SecurityProtocol.SSL),\n+             SecurityProtocol.SSL,\n+             new TestSecurityConfig(sslServerConfigs),\n+             null,\n+            TIME);\n+        Selector selector = createSelector(sslClientConfigs);\n+\n+        String node = \"0\";\n+        selector.connect(node, new InetSocketAddress(\"localhost\", server.port()), BUFFER_SIZE, BUFFER_SIZE);\n+\n+        if (tlsServerProtocols.contains(tlsClientProtocols.get(0))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61cd6c5e667a9ca1f1b7b94dd0590c4b8c1d0899"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwMDk5OTkw", "url": "https://github.com/apache/kafka/pull/8695#pullrequestreview-420099990", "createdAt": "2020-05-28T13:22:01Z", "commit": {"oid": "61cd6c5e667a9ca1f1b7b94dd0590c4b8c1d0899"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzoyMjowMlrOGb0zCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzoyMjowMlrOGb0zCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyOTc3MA==", "bodyText": "Do we want server.verifyAuthenticationMetrics(0, 1); here as in the other test?", "url": "https://github.com/apache/kafka/pull/8695#discussion_r431829770", "createdAt": "2020-05-28T13:22:02Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +623,79 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTLSv1_2_FailsForTLSv1_3() throws Exception {\n+        assumeTrue(Java.IS_JAVA11_COMPATIBLE);\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        //Note, that only some ciphers works out of the box. Others requires additional configuration.\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.3\"));\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+        server.verifyAuthenticationMetrics(0, 1);\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.2 and custom cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteFailForServerTLSv1_2_ClientTLSv1_3() throws Exception {\n+        assumeTrue(Java.IS_JAVA11_COMPATIBLE);\n+\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Arrays.asList(\"TLSv1.2\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "61cd6c5e667a9ca1f1b7b94dd0590c4b8c1d0899"}, "originalPosition": 54}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fd1f48b04519a65cdb91f5a28b6a2bd6886adc61", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/fd1f48b04519a65cdb91f5a28b6a2bd6886adc61", "committedDate": "2020-05-29T08:47:11Z", "message": "KAFKA-9320: code review fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1a2fe47c9eb4d8a6799a1086f7070edec148827", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/e1a2fe47c9eb4d8a6799a1086f7070edec148827", "committedDate": "2020-05-29T08:47:47Z", "message": "Merge branch 'trunk' into KAFKA-9320"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e7eaec600e094062cdd312fadb1177119aabdfa", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/4e7eaec600e094062cdd312fadb1177119aabdfa", "committedDate": "2020-05-29T13:56:42Z", "message": "KAFKA-9320: test fix."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c756720b15c35e22f09a1ee7613dae6e2a190a29", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/c756720b15c35e22f09a1ee7613dae6e2a190a29", "committedDate": "2020-05-29T17:33:53Z", "message": "KAFKA-9320: code review fixes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a231e2f3a556be7b0cbca51b46d290e3b70ef47e", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/a231e2f3a556be7b0cbca51b46d290e3b70ef47e", "committedDate": "2020-05-29T17:51:28Z", "message": "KAFKA-9320: code review fixes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNDI0MTkw", "url": "https://github.com/apache/kafka/pull/8695#pullrequestreview-421424190", "createdAt": "2020-05-30T15:59:35Z", "commit": {"oid": "a231e2f3a556be7b0cbca51b46d290e3b70ef47e"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNTo1OTozNVrOGc0DAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQyMTo1MjozOVrOGc7elA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg2NjA1MA==", "bodyText": "What is the reason for this?", "url": "https://github.com/apache/kafka/pull/8695#discussion_r432866050", "createdAt": "2020-05-30T15:59:35Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -580,7 +581,16 @@ public void testTLSDefaults() throws Exception {\n \n     @Test\n     public void testUnsupportedCipher() throws Exception {\n-        String[] cipherSuites = ((SSLServerSocketFactory) SSLServerSocketFactory.getDefault()).getSupportedCipherSuites();\n+        String[] cipherSuites;\n+        if (Java.IS_JAVA11_COMPATIBLE) {\n+            cipherSuites = new String[] {\n+                \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a231e2f3a556be7b0cbca51b46d290e3b70ef47e"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4NzM5NA==", "bodyText": "Why do we need this change?", "url": "https://github.com/apache/kafka/pull/8695#discussion_r432987394", "createdAt": "2020-05-31T21:48:28Z", "author": {"login": "ijuma"}, "path": "tests/kafkatest/services/kafka/kafka.py", "diffHunk": "@@ -354,15 +358,16 @@ def start_cmd(self, node):\n \n     def start_node(self, node, timeout_sec=60):\n         node.account.mkdirs(KafkaService.PERSISTENT_ROOT)\n+\n+        self.security_config.setup_node(node)\n+        self.security_config.setup_credentials(node, self.path, self.zk_connect_setting(), broker=True)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a231e2f3a556be7b0cbca51b46d290e3b70ef47e"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4NzU5MA==", "bodyText": "For consistency, shall we use 11 here?", "url": "https://github.com/apache/kafka/pull/8695#discussion_r432987590", "createdAt": "2020-05-31T21:50:39Z", "author": {"login": "ijuma"}, "path": "tests/kafkatest/services/security/security_config.py", "diffHunk": "@@ -259,6 +267,9 @@ def setup_node(self, node):\n         if self.has_sasl:\n             self.setup_sasl(node)\n \n+        if java_version(node) <= 9 and self.properties['tls.version'] == 'TLSv1.3':", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a231e2f3a556be7b0cbca51b46d290e3b70ef47e"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4NzY5MQ==", "bodyText": "I think we can change one of the SASL_SSL entries to include multiple TLS versions. This way, we also verify that it works for SASL_SSL without increasing test time too much.", "url": "https://github.com/apache/kafka/pull/8695#discussion_r432987691", "createdAt": "2020-05-31T21:51:53Z", "author": {"login": "ijuma"}, "path": "tests/kafkatest/tests/core/replication_test.py", "diffHunk": "@@ -126,9 +126,11 @@ def min_cluster_size(self):\n             security_protocol=\"SASL_SSL\", client_sasl_mechanism=\"SCRAM-SHA-256\", interbroker_sasl_mechanism=\"SCRAM-SHA-512\")\n     @matrix(failure_mode=[\"clean_shutdown\", \"hard_shutdown\", \"clean_bounce\", \"hard_bounce\"],\n             security_protocol=[\"PLAINTEXT\"], broker_type=[\"leader\"], compression_type=[\"gzip\"])\n+    @matrix(failure_mode=[\"clean_shutdown\", \"hard_shutdown\", \"clean_bounce\", \"hard_bounce\"],\n+            security_protocol=[\"SSL\"], broker_type=[\"leader\"], compression_type=[\"gzip\"], tls_version=[\"TLSv1.2\", \"TLSv1.3\"])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a231e2f3a556be7b0cbca51b46d290e3b70ef47e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4Nzc5Ng==", "bodyText": "We normally don't have _ in method names. Can we remove it from here and other test methods?", "url": "https://github.com/apache/kafka/pull/8695#discussion_r432987796", "createdAt": "2020-05-31T21:52:39Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +632,108 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTls12_FailsForTls13() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a231e2f3a556be7b0cbca51b46d290e3b70ef47e"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ab2f390cfda9601f69dc0000d3ec8ccba1ec2fb", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/7ab2f390cfda9601f69dc0000d3ec8ccba1ec2fb", "committedDate": "2020-06-01T09:54:31Z", "message": "KAFKA-9320: code review fixes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17612acc5acd40f33f133df18c679ad4fb07d8f4", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/17612acc5acd40f33f133df18c679ad4fb07d8f4", "committedDate": "2020-06-01T13:24:53Z", "message": "KAFKA-9320: code review fixes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxODY5MTE0", "url": "https://github.com/apache/kafka/pull/8695#pullrequestreview-421869114", "createdAt": "2020-06-01T14:03:50Z", "commit": {"oid": "17612acc5acd40f33f133df18c679ad4fb07d8f4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNDowMzo1MFrOGdLq4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNDowMzo1MFrOGdLq4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI1MzA4OA==", "bodyText": "Why did we make these changes? I think what we had was good.", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433253088", "createdAt": "2020-06-01T14:03:50Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslVersionsTransportLayerTest.java", "diffHunk": "@@ -54,21 +54,16 @@\n         List<Object[]> values = new ArrayList<>();\n         values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Collections.singletonList(\"TLSv1.2\")});\n         if (Java.IS_JAVA11_COMPATIBLE) {\n-            values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Collections.singletonList(\"TLSv1.3\")});\n-            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Collections.singletonList(\"TLSv1.2\")});\n-            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Collections.singletonList(\"TLSv1.3\")});\n-            values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n-            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n-            values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n-            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n             values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Collections.singletonList(\"TLSv1.3\")});\n             values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Collections.singletonList(\"TLSv1.2\")});\n-            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Collections.singletonList(\"TLSv1.3\")});\n-            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Collections.singletonList(\"TLSv1.2\")});\n             values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n             values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Collections.singletonList(\"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Collections.singletonList(\"TLSv1.2\")});\n             values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n             values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17612acc5acd40f33f133df18c679ad4fb07d8f4"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxODgwNjM1", "url": "https://github.com/apache/kafka/pull/8695#pullrequestreview-421880635", "createdAt": "2020-06-01T14:16:38Z", "commit": {"oid": "17612acc5acd40f33f133df18c679ad4fb07d8f4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNDoxNjozOFrOGdMIrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNDoxNjozOFrOGdMIrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI2MDcxNg==", "bodyText": "Hmm, these tests seem to take a long time. Do you know why? See:", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433260716", "createdAt": "2020-06-01T14:16:38Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +632,108 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTls12FailsForTls13() throws Exception {\n+        assumeTrue(Java.IS_JAVA11_COMPATIBLE);\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);\n+\n+        String cipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Collections.singletonList(\"TLSv1.3\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Collections.singletonList(cipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Collections.singletonList(\"TLSv1.3\"));\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Collections.singletonList(cipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+        server.verifyAuthenticationMetrics(0, 1);\n+    }\n+\n+    /**\n+     * Tests that connections can't be made if server uses TLSv1.2 with custom cipher suite and client uses TLSv1.3.\n+     */\n+    @Test\n+    public void testCiphersSuiteFailForServerTls12ClientTls13() throws Exception {\n+        assumeTrue(Java.IS_JAVA11_COMPATIBLE);\n+\n+        String tls12CipherSuite = \"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384\";\n+        String tls13CipherSuite = \"TLS_AES_128_GCM_SHA256\";\n+\n+        sslServerConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.2\");\n+        sslServerConfigs.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, Collections.singletonList(\"TLSv1.2\"));\n+        sslServerConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Collections.singletonList(tls12CipherSuite));\n+        server = createEchoServer(SecurityProtocol.SSL);\n+\n+        sslClientConfigs.put(SslConfigs.SSL_PROTOCOL_CONFIG, \"TLSv1.3\");\n+        sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Collections.singletonList(tls13CipherSuite));\n+\n+        checkAuthentiationFailed(\"0\", \"TLSv1.3\");\n+        server.verifyAuthenticationMetrics(0, 1);\n+    }\n+\n+    /**\n+     * Tests that connections can be made with TLSv1.3 cipher suite.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTls13() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17612acc5acd40f33f133df18c679ad4fb07d8f4"}, "originalPosition": 80}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebb20e1b1bf8d067f61e615eadcf5b760db56917", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/ebb20e1b1bf8d067f61e615eadcf5b760db56917", "committedDate": "2020-06-01T14:20:16Z", "message": "KAFKA-9320: revert test changes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b5558745b59da61594b2b728d99593bc6c620f3", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/1b5558745b59da61594b2b728d99593bc6c620f3", "committedDate": "2020-06-01T14:35:09Z", "message": "KAFKA-9320: fix test duration."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxOTA2Njcz", "url": "https://github.com/apache/kafka/pull/8695#pullrequestreview-421906673", "createdAt": "2020-06-01T14:49:00Z", "commit": {"oid": "17612acc5acd40f33f133df18c679ad4fb07d8f4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNDo0OTowMVrOGdNS1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNDo0OTowMVrOGdNS1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI3OTcwMQ==", "bodyText": "These two lines are unused. Similar for other tests.", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433279701", "createdAt": "2020-06-01T14:49:01Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +632,108 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTls12FailsForTls13() throws Exception {\n+        assumeTrue(Java.IS_JAVA11_COMPATIBLE);\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);\n+        context.init(null, null, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17612acc5acd40f33f133df18c679ad4fb07d8f4"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxOTEwNzIx", "url": "https://github.com/apache/kafka/pull/8695#pullrequestreview-421910721", "createdAt": "2020-06-01T14:53:49Z", "commit": {"oid": "17612acc5acd40f33f133df18c679ad4fb07d8f4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNDo1Mzo0OVrOGdNelA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNDo1Mzo0OVrOGdNelA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI4MjcwOA==", "bodyText": "I had not noticed that this test is parameterized on tlsProtocol. Maybe we should move these tests to a separate class? It's a bit weird to run them twice and ignore the parameterized value.", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433282708", "createdAt": "2020-06-01T14:53:49Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -622,6 +632,108 @@ public void testUnsupportedTLSVersion() throws Exception {\n         server.verifyAuthenticationMetrics(0, 1);\n     }\n \n+    /**\n+     * Tests that connections fails if TLSv1.3 enabled but cipher suite suitable only for TLSv1.2 used.\n+     */\n+    @Test\n+    public void testCiphersSuiteForTls12FailsForTls13() throws Exception {\n+        assumeTrue(Java.IS_JAVA11_COMPATIBLE);\n+\n+        SSLContext context = SSLContext.getInstance(tlsProtocol);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17612acc5acd40f33f133df18c679ad4fb07d8f4"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9da1c210fcd6db5bc9f8c37c3fd13c1be88ae6f7", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/9da1c210fcd6db5bc9f8c37c3fd13c1be88ae6f7", "committedDate": "2020-06-01T15:12:05Z", "message": "KAFKA-9320: unused code removed."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e6c445cf9ef9f7d229c90bf3c6debdf19aa96bd", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/3e6c445cf9ef9f7d229c90bf3c6debdf19aa96bd", "committedDate": "2020-06-01T16:34:41Z", "message": "KAFKA-9320: code review fixes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMDgyNTMx", "url": "https://github.com/apache/kafka/pull/8695#pullrequestreview-422082531", "createdAt": "2020-06-01T18:31:40Z", "commit": {"oid": "3e6c445cf9ef9f7d229c90bf3c6debdf19aa96bd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxODozMTo0MVrOGdVcgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxODozMTo0MVrOGdVcgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQxMzI1MA==", "bodyText": "Shall we keep the authentication metrics check?", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433413250", "createdAt": "2020-06-01T18:31:41Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslTransportLayerTest.java", "diffHunk": "@@ -732,11 +614,8 @@ public void testUnsupportedCiphers() throws Exception {\n \n         sslClientConfigs.put(SslConfigs.SSL_CIPHER_SUITES_CONFIG, Arrays.asList(cipherSuites[1]));\n         createSelector(sslClientConfigs);\n-        InetSocketAddress addr = new InetSocketAddress(\"localhost\", server.port());\n-        selector.connect(node, addr, BUFFER_SIZE, BUFFER_SIZE);\n \n-        NetworkTestUtils.waitForChannelClose(selector, node, ChannelState.State.AUTHENTICATION_FAILED);\n-        server.verifyAuthenticationMetrics(0, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e6c445cf9ef9f7d229c90bf3c6debdf19aa96bd"}, "originalPosition": 152}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14bf85aab93eabd5eb5045315edf104079b4d353", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/14bf85aab93eabd5eb5045315edf104079b4d353", "committedDate": "2020-06-02T12:38:30Z", "message": "KAFKA-9320: TLSv1.3 vs TLSv1.2 explanation comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67f0ef90d9f9e687b0f9792d043cb3819617d85c", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/67f0ef90d9f9e687b0f9792d043cb3819617d85c", "committedDate": "2020-06-02T13:05:50Z", "message": "Merge branch 'trunk' into KAFKA-9320"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNjk4NjY3", "url": "https://github.com/apache/kafka/pull/8695#pullrequestreview-422698667", "createdAt": "2020-06-02T13:53:06Z", "commit": {"oid": "14bf85aab93eabd5eb5045315edf104079b4d353"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzo1MzowNlrOGdyrrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzo1MzowNlrOGdyrrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5MjI2OQ==", "bodyText": "Should this be called createClientSelector?", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433892269", "createdAt": "2020-06-02T13:53:06Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslVersionsTransportLayerTest.java", "diffHunk": "@@ -117,24 +123,51 @@ public void testTlsDefaults() throws Exception {\n             server.waitForMetric(\"response\", 1);\n         } else {\n             NetworkTestUtils.waitForChannelClose(selector, node, ChannelState.State.AUTHENTICATION_FAILED);\n+            server.verifyAuthenticationMetrics(0, 1);\n         }\n     }\n \n+    /**\n+     * <p>\n+     * The explanation of this check in the structure of the ClientHello SSL message.\n+     * Please, take a look at the <a href=\"https://docs.oracle.com/en/java/javase/11/security/java-secure-socket-extension-jsse-reference-guide.html#GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6\">Guide</a>,\n+     * \"Send ClientHello Message\" section.\n+     * <p>\n+     * > Client version: For TLS 1.3, this has a fixed value, TLSv1.2; TLS 1.3 uses the extension supported_versions and not this field to negotiate protocol version\n+     * ...\n+     * > supported_versions: Lists which versions of TLS the client supports. In particular, if the client\n+     * > requests TLS 1.3, then the client version field has the value TLSv1.2 and this extension\n+     * > contains the value TLSv1.3; if the client requests TLS 1.2, then the client version field has the\n+     * > value TLSv1.2 and this extension either doesn\u2019t exist or contains the value TLSv1.2 but not the value TLSv1.3.\n+     * <p>\n+     *\n+     * This mean that TLSv1.3 client can fallback to TLSv1.2 but TLSv1.2 client can't change protocol to TLSv1.3.\n+     *\n+     * @param serverProtocols Server protocols.\n+     * @param clientProtocols Client protocols.\n+     * @return {@code True} if client should be able to connect to the server.\n+     */\n+    private boolean isCompatible(List<String> serverProtocols, List<String> clientProtocols) {\n+        return serverProtocols.contains(clientProtocols.get(0)) ||\n+            (clientProtocols.get(0).equals(\"TLSv1.3\") && clientProtocols.contains(\"TLSv1.2\"));\n+    }\n+\n     private static Map<String, Object> getTrustingConfig(CertStores certStores, CertStores peerCertStores, List<String> tlsProtocols) {\n         Map<String, Object> configs = certStores.getTrustingConfig(peerCertStores);\n         configs.putAll(sslConfig(tlsProtocols));\n         return configs;\n     }\n \n-    private static Map<String, Object> sslConfig(List<String> tlsServerProtocols) {\n+    private static Map<String, Object> sslConfig(List<String> tlsProtocols) {\n         Map<String, Object> sslConfig = new HashMap<>();\n-        sslConfig.put(SslConfigs.SSL_PROTOCOL_CONFIG, tlsServerProtocols.get(0));\n-        sslConfig.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsServerProtocols);\n+        sslConfig.put(SslConfigs.SSL_PROTOCOL_CONFIG, tlsProtocols.get(0));\n+        sslConfig.put(SslConfigs.SSL_ENABLED_PROTOCOLS_CONFIG, tlsProtocols);\n         return sslConfig;\n     }\n \n     private Selector createSelector(Map<String, Object> sslClientConfigs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14bf85aab93eabd5eb5045315edf104079b4d353"}, "originalPosition": 117}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "869e342f4cc0dd5b3f7120cfadb3175bb6f48ff7", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/869e342f4cc0dd5b3f7120cfadb3175bb6f48ff7", "committedDate": "2020-06-02T14:02:26Z", "message": "KAFKA-9320: code review fixes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNzA5Nzkx", "url": "https://github.com/apache/kafka/pull/8695#pullrequestreview-422709791", "createdAt": "2020-06-02T14:01:16Z", "commit": {"oid": "67f0ef90d9f9e687b0f9792d043cb3819617d85c"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNDowMToxNlrOGdzFmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNDowOToxNlrOGdzjZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5ODkwNw==", "bodyText": "Nit: True should be lower case.", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433898907", "createdAt": "2020-06-02T14:01:16Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslVersionsTransportLayerTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.network;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.kafka.common.metrics.Metrics;\n+import org.apache.kafka.common.security.TestSecurityConfig;\n+import org.apache.kafka.common.security.auth.SecurityProtocol;\n+import org.apache.kafka.common.utils.Java;\n+import org.apache.kafka.common.utils.LogContext;\n+import org.apache.kafka.common.utils.Time;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests for the SSL transport layer.\n+ * Checks different versions of the protocol usage on the server and client.\n+ */\n+@RunWith(value = Parameterized.class)\n+public class SslVersionsTransportLayerTest {\n+    private static final int BUFFER_SIZE = 4 * 1024;\n+    private static final Time TIME = Time.SYSTEM;\n+\n+    private final List<String> serverProtocols;\n+    private final List<String> clientProtocols;\n+\n+    @Parameterized.Parameters(name = \"tlsServerProtocol={0},tlsClientProtocol={1}\")\n+    public static Collection<Object[]> data() {\n+        List<Object[]> values = new ArrayList<>();\n+\n+        values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Collections.singletonList(\"TLSv1.2\")});\n+\n+        if (Java.IS_JAVA11_COMPATIBLE) {\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Collections.singletonList(\"TLSv1.3\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Collections.singletonList(\"TLSv1.2\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Collections.singletonList(\"TLSv1.3\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Collections.singletonList(\"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Collections.singletonList(\"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Collections.singletonList(\"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Collections.singletonList(\"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Be aware that you can turn on debug mode for a javax.net.ssl library with the line {@code System.setProperty(\"javax.net.debug\", \"ssl:handshake\");}\n+     * @param serverProtocols Server protocols.\n+     * @param clientProtocols Client protocols.\n+     */\n+    public SslVersionsTransportLayerTest(List<String> serverProtocols, List<String> clientProtocols) {\n+        this.serverProtocols = serverProtocols;\n+        this.clientProtocols = clientProtocols;\n+    }\n+\n+    /**\n+     * Tests that connection success with the default TLS version.\n+     */\n+    @Test\n+    public void testTlsDefaults() throws Exception {\n+        // Create certificates for use by client and server. Add server cert to client truststore and vice versa.\n+        CertStores serverCertStores = new CertStores(true, \"server\",  \"localhost\");\n+        CertStores clientCertStores = new CertStores(false, \"client\", \"localhost\");\n+\n+        Map<String, Object> sslClientConfigs = getTrustingConfig(clientCertStores, serverCertStores, clientProtocols);\n+        Map<String, Object> sslServerConfigs = getTrustingConfig(serverCertStores, clientCertStores, serverProtocols);\n+\n+        NioEchoServer server = NetworkTestUtils.createEchoServer(ListenerName.forSecurityProtocol(SecurityProtocol.SSL),\n+            SecurityProtocol.SSL,\n+            new TestSecurityConfig(sslServerConfigs),\n+            null,\n+            TIME);\n+        Selector selector = createSelector(sslClientConfigs);\n+\n+        String node = \"0\";\n+        selector.connect(node, new InetSocketAddress(\"localhost\", server.port()), BUFFER_SIZE, BUFFER_SIZE);\n+\n+        if (isCompatible(serverProtocols, clientProtocols)) {\n+            NetworkTestUtils.waitForChannelReady(selector, node);\n+\n+            int msgSz = 1024 * 1024;\n+            String message = TestUtils.randomString(msgSz);\n+            selector.send(new NetworkSend(node, ByteBuffer.wrap(message.getBytes())));\n+            while (selector.completedReceives().isEmpty()) {\n+                selector.poll(100L);\n+            }\n+            int totalBytes = msgSz + 4; // including 4-byte size\n+            server.waitForMetric(\"incoming-byte\", totalBytes);\n+            server.waitForMetric(\"outgoing-byte\", totalBytes);\n+            server.waitForMetric(\"request\", 1);\n+            server.waitForMetric(\"response\", 1);\n+        } else {\n+            NetworkTestUtils.waitForChannelClose(selector, node, ChannelState.State.AUTHENTICATION_FAILED);\n+            server.verifyAuthenticationMetrics(0, 1);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * The explanation of this check in the structure of the ClientHello SSL message.\n+     * Please, take a look at the <a href=\"https://docs.oracle.com/en/java/javase/11/security/java-secure-socket-extension-jsse-reference-guide.html#GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6\">Guide</a>,\n+     * \"Send ClientHello Message\" section.\n+     * <p>\n+     * > Client version: For TLS 1.3, this has a fixed value, TLSv1.2; TLS 1.3 uses the extension supported_versions and not this field to negotiate protocol version\n+     * ...\n+     * > supported_versions: Lists which versions of TLS the client supports. In particular, if the client\n+     * > requests TLS 1.3, then the client version field has the value TLSv1.2 and this extension\n+     * > contains the value TLSv1.3; if the client requests TLS 1.2, then the client version field has the\n+     * > value TLSv1.2 and this extension either doesn\u2019t exist or contains the value TLSv1.2 but not the value TLSv1.3.\n+     * <p>\n+     *\n+     * This mean that TLSv1.3 client can fallback to TLSv1.2 but TLSv1.2 client can't change protocol to TLSv1.3.\n+     *\n+     * @param serverProtocols Server protocols.\n+     * @param clientProtocols Client protocols.\n+     * @return {@code True} if client should be able to connect to the server.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67f0ef90d9f9e687b0f9792d043cb3819617d85c"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwMzA5OQ==", "bodyText": "Maybe we should document that serverProtocols and clientProtocols are expected to be non empty as the code below assumes it.", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433903099", "createdAt": "2020-06-02T14:05:24Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslVersionsTransportLayerTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.network;\n+\n+import java.net.InetSocketAddress;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.kafka.common.metrics.Metrics;\n+import org.apache.kafka.common.security.TestSecurityConfig;\n+import org.apache.kafka.common.security.auth.SecurityProtocol;\n+import org.apache.kafka.common.utils.Java;\n+import org.apache.kafka.common.utils.LogContext;\n+import org.apache.kafka.common.utils.Time;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+/**\n+ * Tests for the SSL transport layer.\n+ * Checks different versions of the protocol usage on the server and client.\n+ */\n+@RunWith(value = Parameterized.class)\n+public class SslVersionsTransportLayerTest {\n+    private static final int BUFFER_SIZE = 4 * 1024;\n+    private static final Time TIME = Time.SYSTEM;\n+\n+    private final List<String> serverProtocols;\n+    private final List<String> clientProtocols;\n+\n+    @Parameterized.Parameters(name = \"tlsServerProtocol={0},tlsClientProtocol={1}\")\n+    public static Collection<Object[]> data() {\n+        List<Object[]> values = new ArrayList<>();\n+\n+        values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Collections.singletonList(\"TLSv1.2\")});\n+\n+        if (Java.IS_JAVA11_COMPATIBLE) {\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Collections.singletonList(\"TLSv1.3\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Collections.singletonList(\"TLSv1.2\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Collections.singletonList(\"TLSv1.3\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.2\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Collections.singletonList(\"TLSv1.3\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Collections.singletonList(\"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Collections.singletonList(\"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.3\", \"TLSv1.2\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Collections.singletonList(\"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Collections.singletonList(\"TLSv1.2\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Arrays.asList(\"TLSv1.2\", \"TLSv1.3\")});\n+            values.add(new Object[] {Arrays.asList(\"TLSv1.2\", \"TLSv1.3\"), Arrays.asList(\"TLSv1.3\", \"TLSv1.2\")});\n+        }\n+        return values;\n+    }\n+\n+    /**\n+     * Be aware that you can turn on debug mode for a javax.net.ssl library with the line {@code System.setProperty(\"javax.net.debug\", \"ssl:handshake\");}\n+     * @param serverProtocols Server protocols.\n+     * @param clientProtocols Client protocols.\n+     */\n+    public SslVersionsTransportLayerTest(List<String> serverProtocols, List<String> clientProtocols) {\n+        this.serverProtocols = serverProtocols;\n+        this.clientProtocols = clientProtocols;\n+    }\n+\n+    /**\n+     * Tests that connection success with the default TLS version.\n+     */\n+    @Test\n+    public void testTlsDefaults() throws Exception {\n+        // Create certificates for use by client and server. Add server cert to client truststore and vice versa.\n+        CertStores serverCertStores = new CertStores(true, \"server\",  \"localhost\");\n+        CertStores clientCertStores = new CertStores(false, \"client\", \"localhost\");\n+\n+        Map<String, Object> sslClientConfigs = getTrustingConfig(clientCertStores, serverCertStores, clientProtocols);\n+        Map<String, Object> sslServerConfigs = getTrustingConfig(serverCertStores, clientCertStores, serverProtocols);\n+\n+        NioEchoServer server = NetworkTestUtils.createEchoServer(ListenerName.forSecurityProtocol(SecurityProtocol.SSL),\n+            SecurityProtocol.SSL,\n+            new TestSecurityConfig(sslServerConfigs),\n+            null,\n+            TIME);\n+        Selector selector = createSelector(sslClientConfigs);\n+\n+        String node = \"0\";\n+        selector.connect(node, new InetSocketAddress(\"localhost\", server.port()), BUFFER_SIZE, BUFFER_SIZE);\n+\n+        if (isCompatible(serverProtocols, clientProtocols)) {\n+            NetworkTestUtils.waitForChannelReady(selector, node);\n+\n+            int msgSz = 1024 * 1024;\n+            String message = TestUtils.randomString(msgSz);\n+            selector.send(new NetworkSend(node, ByteBuffer.wrap(message.getBytes())));\n+            while (selector.completedReceives().isEmpty()) {\n+                selector.poll(100L);\n+            }\n+            int totalBytes = msgSz + 4; // including 4-byte size\n+            server.waitForMetric(\"incoming-byte\", totalBytes);\n+            server.waitForMetric(\"outgoing-byte\", totalBytes);\n+            server.waitForMetric(\"request\", 1);\n+            server.waitForMetric(\"response\", 1);\n+        } else {\n+            NetworkTestUtils.waitForChannelClose(selector, node, ChannelState.State.AUTHENTICATION_FAILED);\n+            server.verifyAuthenticationMetrics(0, 1);\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * The explanation of this check in the structure of the ClientHello SSL message.\n+     * Please, take a look at the <a href=\"https://docs.oracle.com/en/java/javase/11/security/java-secure-socket-extension-jsse-reference-guide.html#GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6\">Guide</a>,\n+     * \"Send ClientHello Message\" section.\n+     * <p>\n+     * > Client version: For TLS 1.3, this has a fixed value, TLSv1.2; TLS 1.3 uses the extension supported_versions and not this field to negotiate protocol version\n+     * ...\n+     * > supported_versions: Lists which versions of TLS the client supports. In particular, if the client\n+     * > requests TLS 1.3, then the client version field has the value TLSv1.2 and this extension\n+     * > contains the value TLSv1.3; if the client requests TLS 1.2, then the client version field has the\n+     * > value TLSv1.2 and this extension either doesn\u2019t exist or contains the value TLSv1.2 but not the value TLSv1.3.\n+     * <p>\n+     *\n+     * This mean that TLSv1.3 client can fallback to TLSv1.2 but TLSv1.2 client can't change protocol to TLSv1.3.\n+     *\n+     * @param serverProtocols Server protocols.\n+     * @param clientProtocols Client protocols.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67f0ef90d9f9e687b0f9792d043cb3819617d85c"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwNjUzMw==", "bodyText": "Would the second check if clearer if it was like:\nclientProtocols.get(0).equals(\"TLSv1.3\") && !Collections.disjoint(tlsServerProtocols, tlsClientProtocols)\nWe're basically saying that we check all the client protocols against the broker protocols if the client uses TLS 1.3. The first condition checks the case where the first client protocol is supported by the server (TLS 1.2).", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433906533", "createdAt": "2020-06-02T14:09:16Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/network/SslVersionsTransportLayerTest.java", "diffHunk": "@@ -117,24 +123,51 @@ public void testTlsDefaults() throws Exception {\n             server.waitForMetric(\"response\", 1);\n         } else {\n             NetworkTestUtils.waitForChannelClose(selector, node, ChannelState.State.AUTHENTICATION_FAILED);\n+            server.verifyAuthenticationMetrics(0, 1);\n         }\n     }\n \n+    /**\n+     * <p>\n+     * The explanation of this check in the structure of the ClientHello SSL message.\n+     * Please, take a look at the <a href=\"https://docs.oracle.com/en/java/javase/11/security/java-secure-socket-extension-jsse-reference-guide.html#GUID-4D421910-C36D-40A2-8BA2-7D42CCBED3C6\">Guide</a>,\n+     * \"Send ClientHello Message\" section.\n+     * <p>\n+     * > Client version: For TLS 1.3, this has a fixed value, TLSv1.2; TLS 1.3 uses the extension supported_versions and not this field to negotiate protocol version\n+     * ...\n+     * > supported_versions: Lists which versions of TLS the client supports. In particular, if the client\n+     * > requests TLS 1.3, then the client version field has the value TLSv1.2 and this extension\n+     * > contains the value TLSv1.3; if the client requests TLS 1.2, then the client version field has the\n+     * > value TLSv1.2 and this extension either doesn\u2019t exist or contains the value TLSv1.2 but not the value TLSv1.3.\n+     * <p>\n+     *\n+     * This mean that TLSv1.3 client can fallback to TLSv1.2 but TLSv1.2 client can't change protocol to TLSv1.3.\n+     *\n+     * @param serverProtocols Server protocols.\n+     * @param clientProtocols Client protocols.\n+     * @return {@code True} if client should be able to connect to the server.\n+     */\n+    private boolean isCompatible(List<String> serverProtocols, List<String> clientProtocols) {\n+        return serverProtocols.contains(clientProtocols.get(0)) ||\n+            (clientProtocols.get(0).equals(\"TLSv1.3\") && clientProtocols.contains(\"TLSv1.2\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14bf85aab93eabd5eb5045315edf104079b4d353"}, "originalPosition": 98}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca81fcd1c1d40491cb756e12e0c26b875e12c0b4", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/ca81fcd1c1d40491cb756e12e0c26b875e12c0b4", "committedDate": "2020-06-02T14:37:05Z", "message": "KAFKA-9320: code review fixes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a82441c99dbd97ce820fed4891b2b237a3f2ea9", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/6a82441c99dbd97ce820fed4891b2b237a3f2ea9", "committedDate": "2020-06-02T14:40:17Z", "message": "KAFKA-9320: SSL_PROTOCOL_DOC updated."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyODE5NzA2", "url": "https://github.com/apache/kafka/pull/8695#pullrequestreview-422819706", "createdAt": "2020-06-02T15:49:27Z", "commit": {"oid": "6a82441c99dbd97ce820fed4891b2b237a3f2ea9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNTo0OToyN1rOGd4JxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNTo0OToyN1rOGd4JxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk4MTg5Mg==", "bodyText": "How about:\n\"The SSL protocol used to generate the SSLContext. \"\n            + \"The default is TLSv1.3 when running with Java 11 or newer, TLSv1.2 otherwise. \"\n            + \"This value should be fine for most use cases. \"\n            + \"Allowed values in recent JVMs are TLSv1.2 and TLSv1.3. TLS, TLSv1.1, SSL, SSLv2 and SSLv3 \"\n            + \"may be supported in older JVMs, but their usage is discouraged due to known security vulnerabilities. \";\n            + \"With the default value for this config and ssl.enabled.protocols, clients will downgrade to TLSv1.2 if \"\n            + \"the server does not support TLSv1.3. If this config is set to TLSv1.2, clients will not use TLSv1.3 even \"\n            + \"if it is one of the values in ssl.enabled.protocols and the server only supports TLSv1.3.\"", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433981892", "createdAt": "2020-06-02T15:49:27Z", "author": {"login": "ijuma"}, "path": "clients/src/main/java/org/apache/kafka/common/config/SslConfigs.java", "diffHunk": "@@ -49,11 +50,12 @@\n \n     public static final String SSL_PROTOCOL_CONFIG = \"ssl.protocol\";\n     public static final String SSL_PROTOCOL_DOC = \"The SSL protocol used to generate the SSLContext. \"\n-            + \"Default setting is TLSv1.2, which is fine for most cases. \"\n+            + \"Default setting is TLSv1.2(TLSv1.3 for modern JVM), which is fine for most cases. \"\n             + \"Allowed values in recent JVMs are TLSv1.2 and TLSv1.3. TLS, TLSv1.1, SSL, SSLv2 and SSLv3 \"\n-            + \"may be supported in older JVMs, but their usage is discouraged due to known security vulnerabilities.\";\n+            + \"may be supported in older JVMs, but their usage is discouraged due to known security vulnerabilities.\"\n+            + \"Please, note, TLSv1.2 clients can't connect to the servers with TLSv1.3 only even if ssl.enabled.protocols contains TLSv1.3\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a82441c99dbd97ce820fed4891b2b237a3f2ea9"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyODI0NjA5", "url": "https://github.com/apache/kafka/pull/8695#pullrequestreview-422824609", "createdAt": "2020-06-02T15:54:49Z", "commit": {"oid": "6a82441c99dbd97ce820fed4891b2b237a3f2ea9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNTo1NDo0OVrOGd4fOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNTo1NDo0OVrOGd4fOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk4NzM4NA==", "bodyText": "How about:\nThe list of protocols enabled for SSL connections. The default is 'TLSv1.2,TLSv1.3' when running with Java 11 or newer, 'TLSv1.2' otherwise. With the default value for Java 11, clients and servers will prefer TLSv1.3 if both support it and fallback to TLSv1.2 otherwise (assuming both support at least TLSv1.2). This default should be fine for most cases. Also see the `ssl.protocol` config documentation.", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433987384", "createdAt": "2020-06-02T15:54:49Z", "author": {"login": "ijuma"}, "path": "clients/src/main/java/org/apache/kafka/common/config/SslConfigs.java", "diffHunk": "@@ -64,7 +66,17 @@\n \n     public static final String SSL_ENABLED_PROTOCOLS_CONFIG = \"ssl.enabled.protocols\";\n     public static final String SSL_ENABLED_PROTOCOLS_DOC = \"The list of protocols enabled for SSL connections.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a82441c99dbd97ce820fed4891b2b237a3f2ea9"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyODI3NjMx", "url": "https://github.com/apache/kafka/pull/8695#pullrequestreview-422827631", "createdAt": "2020-06-02T15:58:09Z", "commit": {"oid": "6a82441c99dbd97ce820fed4891b2b237a3f2ea9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNTo1ODowOVrOGd4sag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNTo1ODowOVrOGd4sag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk5MDc2Mg==", "bodyText": "One more nit: \"TLSv1.3 has been enabled by default for Java 11 or newer. The client and server will negotiate TLSv1.3 if both support it and fallback to TLSv1.2 otherwise. See...", "url": "https://github.com/apache/kafka/pull/8695#discussion_r433990762", "createdAt": "2020-06-02T15:58:09Z", "author": {"login": "ijuma"}, "path": "docs/upgrade.html", "diffHunk": "@@ -18,6 +18,10 @@\n <script><!--#include virtual=\"js/templateData.js\" --></script>\n \n <script id=\"upgrade-template\" type=\"text/x-handlebars-template\">\n+<h5><a id=\"upgrade_270_notable\" href=\"#upgrade_270_notable\">Notable changes in 2.7.0</a></h5>\n+<ul>\n+    <li>TLSv1.3 have been enabled by default for JDK11+. See <a href=\"https://cwiki.apache.org/confluence/display/KAFKA/KIP-573%3A+Enable+TLSv1.3+by+default\">KIP-573</a> for full details.</li>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6a82441c99dbd97ce820fed4891b2b237a3f2ea9"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce7505f17c030b942dfa931a03fab6b779a92d94", "author": {"user": {"login": "ijuma", "name": "Ismael Juma"}}, "url": "https://github.com/apache/kafka/commit/ce7505f17c030b942dfa931a03fab6b779a92d94", "committedDate": "2020-06-02T19:10:15Z", "message": "Documentation tweaks"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "ce7505f17c030b942dfa931a03fab6b779a92d94", "author": {"user": {"login": "ijuma", "name": "Ismael Juma"}}, "url": "https://github.com/apache/kafka/commit/ce7505f17c030b942dfa931a03fab6b779a92d94", "committedDate": "2020-06-02T19:10:15Z", "message": "Documentation tweaks"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyOTgzODA2", "url": "https://github.com/apache/kafka/pull/8695#pullrequestreview-422983806", "createdAt": "2020-06-02T19:15:01Z", "commit": {"oid": "ce7505f17c030b942dfa931a03fab6b779a92d94"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2935783c54e17b208832a749600a12923b625d8", "author": {"user": {"login": "nizhikov", "name": "Nikolay"}}, "url": "https://github.com/apache/kafka/commit/b2935783c54e17b208832a749600a12923b625d8", "committedDate": "2020-06-02T19:56:57Z", "message": "Merge branch 'trunk' into KAFKA-9320"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1099, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}