{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5NzYwNzgy", "number": 9749, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxOTo1ODoxMVrOFFMArA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQyMDoxMToyMFrOFN2sqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwOTgzOTgwOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxOTo1ODoxMVrOIFkqAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwNToyOTozMVrOIF5m7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcxNDM3MQ==", "bodyText": "The 50ms delay here acts like a simplistic linger time to allow ISR updates to batch. If we schedule the thread immediately after the first call to enqueue, we'll likely only send a single partition in the AlterIsr request. With the small delay, we give partitions a chance to accumulate for sending as one batch.\nWe might consider adding a real linger time with maximum delay if we find that we're sending inefficient batches in practice.", "url": "https://github.com/apache/kafka/pull/9749#discussion_r542714371", "createdAt": "2020-12-14T19:58:11Z", "author": {"login": "mumrah"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -62,27 +61,38 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private val lastIsrPropagationMs = new AtomicLong(0)\n \n-  override def start(): Unit = {\n-    scheduler.schedule(\"send-alter-isr\", propagateIsrChanges, 50, 50, TimeUnit.MILLISECONDS)\n-  }\n+  override def start(): Unit = { }\n \n   override def enqueue(alterIsrItem: AlterIsrItem): Boolean = {\n-    unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null\n+    if (unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null) {\n+      if (inflightRequest.compareAndSet(false, true)) {\n+        // optimistically set the inflight flag even though we haven't sent the request yet\n+        scheduler.schedule(\"send-alter-isr\", propagateIsrChanges, 50, -1, TimeUnit.MILLISECONDS)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "430ce4b8ae5bf44263a4bd32c803f12008dcf79e"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA1NzY0NQ==", "bodyText": "The linger attempt feels a tad clumsy. I wonder if it is necessary. With the constraint of only having one inflight request, I think we will end up batching effectively when the rate of requests goes up. Most importantly, we'll be able to batch effectively when the controller is slow to respond. Would this be complex to implement?", "url": "https://github.com/apache/kafka/pull/9749#discussion_r543057645", "createdAt": "2020-12-15T05:29:31Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -62,27 +61,38 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private val lastIsrPropagationMs = new AtomicLong(0)\n \n-  override def start(): Unit = {\n-    scheduler.schedule(\"send-alter-isr\", propagateIsrChanges, 50, 50, TimeUnit.MILLISECONDS)\n-  }\n+  override def start(): Unit = { }\n \n   override def enqueue(alterIsrItem: AlterIsrItem): Boolean = {\n-    unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null\n+    if (unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null) {\n+      if (inflightRequest.compareAndSet(false, true)) {\n+        // optimistically set the inflight flag even though we haven't sent the request yet\n+        scheduler.schedule(\"send-alter-isr\", propagateIsrChanges, 50, -1, TimeUnit.MILLISECONDS)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjcxNDM3MQ=="}, "originalCommit": {"oid": "430ce4b8ae5bf44263a4bd32c803f12008dcf79e"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NzczNDM1OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxODowMzo0MFrOIQb6YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxODoxOTowN1rOIQcYqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDEwNTQ0MA==", "bodyText": "If we are only waiting 1ms, would it be simpler to call propagateIsrChanges directly? Similarly after receiving a response with no error.", "url": "https://github.com/apache/kafka/pull/9749#discussion_r554105440", "createdAt": "2021-01-08T18:03:40Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -122,43 +121,47 @@ class DefaultAlterIsrManager(\n \n   override def start(): Unit = {\n     controllerChannelManager.start()\n-    scheduler.schedule(\"send-alter-isr\", propagateIsrChanges, 50, 50, TimeUnit.MILLISECONDS)\n   }\n \n   override def shutdown(): Unit = {\n     controllerChannelManager.shutdown()\n   }\n \n   override def submit(alterIsrItem: AlterIsrItem): Boolean = {\n-    unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null\n+    if (unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null) {\n+      if (inflightRequest.compareAndSet(false, true)) {\n+        // optimistically set the inflight flag even though we haven't sent the request yet\n+        scheduler.schedule(\"send-alter-isr\", propagateIsrChanges, 1, -1, TimeUnit.MILLISECONDS)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "261670e909334bf6c7888c96f2a0b3ee9097974b"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDExMzE5NQ==", "bodyText": "Yea I don't see any problem with that", "url": "https://github.com/apache/kafka/pull/9749#discussion_r554113195", "createdAt": "2021-01-08T18:19:07Z", "author": {"login": "mumrah"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -122,43 +121,47 @@ class DefaultAlterIsrManager(\n \n   override def start(): Unit = {\n     controllerChannelManager.start()\n-    scheduler.schedule(\"send-alter-isr\", propagateIsrChanges, 50, 50, TimeUnit.MILLISECONDS)\n   }\n \n   override def shutdown(): Unit = {\n     controllerChannelManager.shutdown()\n   }\n \n   override def submit(alterIsrItem: AlterIsrItem): Boolean = {\n-    unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null\n+    if (unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null) {\n+      if (inflightRequest.compareAndSet(false, true)) {\n+        // optimistically set the inflight flag even though we haven't sent the request yet\n+        scheduler.schedule(\"send-alter-isr\", propagateIsrChanges, 1, -1, TimeUnit.MILLISECONDS)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDEwNTQ0MA=="}, "originalCommit": {"oid": "261670e909334bf6c7888c96f2a0b3ee9097974b"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4Nzc2NTUwOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxODoxMzozMVrOIQcNiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxODoxOTozM1rOIQcZZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDExMDM0Nw==", "bodyText": "This seems to introduce a race condition. Say we have an inflight request. Is the following sequence possible?\n\nthe response returns and the io thread calls propagateIsrChanges and sees an empty unsentIsrUpdates\nrequest thread calls submit and inserts a new item in unsentIsrUpdates\nrequest thread fails compareAndSet on inflightRequest\nio thread clears inflightRequest\n\nIt seems like we might need a lock.", "url": "https://github.com/apache/kafka/pull/9749#discussion_r554110347", "createdAt": "2021-01-08T18:13:31Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -122,43 +121,47 @@ class DefaultAlterIsrManager(\n \n   override def start(): Unit = {\n     controllerChannelManager.start()\n-    scheduler.schedule(\"send-alter-isr\", propagateIsrChanges, 50, 50, TimeUnit.MILLISECONDS)\n   }\n \n   override def shutdown(): Unit = {\n     controllerChannelManager.shutdown()\n   }\n \n   override def submit(alterIsrItem: AlterIsrItem): Boolean = {\n-    unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null\n+    if (unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null) {\n+      if (inflightRequest.compareAndSet(false, true)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "261670e909334bf6c7888c96f2a0b3ee9097974b"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDExMzM4MA==", "bodyText": "You're right, there's a race between the isEmpty check and clearing the inflight flag. Good catch", "url": "https://github.com/apache/kafka/pull/9749#discussion_r554113380", "createdAt": "2021-01-08T18:19:33Z", "author": {"login": "mumrah"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -122,43 +121,47 @@ class DefaultAlterIsrManager(\n \n   override def start(): Unit = {\n     controllerChannelManager.start()\n-    scheduler.schedule(\"send-alter-isr\", propagateIsrChanges, 50, 50, TimeUnit.MILLISECONDS)\n   }\n \n   override def shutdown(): Unit = {\n     controllerChannelManager.shutdown()\n   }\n \n   override def submit(alterIsrItem: AlterIsrItem): Boolean = {\n-    unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null\n+    if (unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null) {\n+      if (inflightRequest.compareAndSet(false, true)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDExMDM0Nw=="}, "originalCommit": {"oid": "261670e909334bf6c7888c96f2a0b3ee9097974b"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4ODUyMjY3OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQyMjozNTowNlrOIQjgMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxNToyOToxNlrOIRaSPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDIyOTgwOA==", "bodyText": "Do you think contention for this lock will be an issue? It seems unlikely to me. That makes me think we might be able to simplify the concurrency if we replace the read-write lock with a simple ReentrantLock. Then we could design this around two methods\ndef maybePropagateIsrChanges(): Unit = lock synchronized {\n if (!inflightRequest) {\n   ... \n }\n}\n\ndef clearInFlightRequest(): Unit = lock synchronized {\n  inFlightRequest = false\n}\nWhat do you think?", "url": "https://github.com/apache/kafka/pull/9749#discussion_r554229808", "createdAt": "2021-01-08T22:35:06Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -116,63 +116,78 @@ class DefaultAlterIsrManager(\n   private val unsentIsrUpdates: util.Map[TopicPartition, AlterIsrItem] = new ConcurrentHashMap[TopicPartition, AlterIsrItem]()\n \n   // Used to allow only one in-flight request at a time\n-  private val inflightRequest: AtomicBoolean = new AtomicBoolean(false)\n+  @volatile\n+  private var inflightRequest: Boolean = false\n \n-  private val lastIsrPropagationMs = new AtomicLong(0)\n+  // Protects the updates of the inflight flag and prevents new pending items from being submitted while we are\n+  // preparing a request\n+  private val inflightLock: ReentrantReadWriteLock = new ReentrantReadWriteLock()\n \n   override def start(): Unit = {\n     controllerChannelManager.start()\n-    scheduler.schedule(\"send-alter-isr\", propagateIsrChanges, 50, 50, TimeUnit.MILLISECONDS)\n   }\n \n   override def shutdown(): Unit = {\n     controllerChannelManager.shutdown()\n   }\n \n   override def submit(alterIsrItem: AlterIsrItem): Boolean = {\n-    unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null\n+    val (didSubmit, needsPropagate) = inReadLock(inflightLock) {\n+      if (unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null) {\n+        (true, !inflightRequest)\n+      } else {\n+        (false, false)\n+      }\n+    }\n+    if (needsPropagate) {\n+      propagateIsrChanges(true)\n+    }\n+    didSubmit\n   }\n \n   override def clearPending(topicPartition: TopicPartition): Unit = {\n     unsentIsrUpdates.remove(topicPartition)\n   }\n \n-  private def propagateIsrChanges(): Unit = {\n-    if (!unsentIsrUpdates.isEmpty && inflightRequest.compareAndSet(false, true)) {\n-      // Copy current unsent ISRs but don't remove from the map\n-      val inflightAlterIsrItems = new ListBuffer[AlterIsrItem]()\n-      unsentIsrUpdates.values().forEach(item => inflightAlterIsrItems.append(item))\n-\n-      val now = time.milliseconds()\n-      lastIsrPropagationMs.set(now)\n-      sendRequest(inflightAlterIsrItems.toSeq)\n+  private def propagateIsrChanges(checkInflight: Boolean): Unit = inWriteLock(inflightLock) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6345f632515c761af5871def8b86d5a45b862747"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTEyNzM1Ng==", "bodyText": "I was thinking of the case when lots of partitions come up at once, like in a rolling restart scenario. However, not much happens in the submit call, so it's probably negligible. I tried this change out this morning and there's no noticeable difference. I'll polish it up and fix the tests.", "url": "https://github.com/apache/kafka/pull/9749#discussion_r555127356", "createdAt": "2021-01-11T15:29:16Z", "author": {"login": "mumrah"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -116,63 +116,78 @@ class DefaultAlterIsrManager(\n   private val unsentIsrUpdates: util.Map[TopicPartition, AlterIsrItem] = new ConcurrentHashMap[TopicPartition, AlterIsrItem]()\n \n   // Used to allow only one in-flight request at a time\n-  private val inflightRequest: AtomicBoolean = new AtomicBoolean(false)\n+  @volatile\n+  private var inflightRequest: Boolean = false\n \n-  private val lastIsrPropagationMs = new AtomicLong(0)\n+  // Protects the updates of the inflight flag and prevents new pending items from being submitted while we are\n+  // preparing a request\n+  private val inflightLock: ReentrantReadWriteLock = new ReentrantReadWriteLock()\n \n   override def start(): Unit = {\n     controllerChannelManager.start()\n-    scheduler.schedule(\"send-alter-isr\", propagateIsrChanges, 50, 50, TimeUnit.MILLISECONDS)\n   }\n \n   override def shutdown(): Unit = {\n     controllerChannelManager.shutdown()\n   }\n \n   override def submit(alterIsrItem: AlterIsrItem): Boolean = {\n-    unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null\n+    val (didSubmit, needsPropagate) = inReadLock(inflightLock) {\n+      if (unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null) {\n+        (true, !inflightRequest)\n+      } else {\n+        (false, false)\n+      }\n+    }\n+    if (needsPropagate) {\n+      propagateIsrChanges(true)\n+    }\n+    didSubmit\n   }\n \n   override def clearPending(topicPartition: TopicPartition): Unit = {\n     unsentIsrUpdates.remove(topicPartition)\n   }\n \n-  private def propagateIsrChanges(): Unit = {\n-    if (!unsentIsrUpdates.isEmpty && inflightRequest.compareAndSet(false, true)) {\n-      // Copy current unsent ISRs but don't remove from the map\n-      val inflightAlterIsrItems = new ListBuffer[AlterIsrItem]()\n-      unsentIsrUpdates.values().forEach(item => inflightAlterIsrItems.append(item))\n-\n-      val now = time.milliseconds()\n-      lastIsrPropagationMs.set(now)\n-      sendRequest(inflightAlterIsrItems.toSeq)\n+  private def propagateIsrChanges(checkInflight: Boolean): Unit = inWriteLock(inflightLock) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDIyOTgwOA=="}, "originalCommit": {"oid": "6345f632515c761af5871def8b86d5a45b862747"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NTc4MzA3OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxOTo0NDowOVrOIRkg5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxOTo0NDowOVrOIRkg5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI5NDk0OA==", "bodyText": "nit: shall we pull this out of the match since it is done regardless? It would also make the code a little more resilient since we got rid of the try/catch to put it before handleAlterIsrResponse.", "url": "https://github.com/apache/kafka/pull/9749#discussion_r555294948", "createdAt": "2021-01-11T19:44:09Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -116,63 +116,75 @@ class DefaultAlterIsrManager(\n   private val unsentIsrUpdates: util.Map[TopicPartition, AlterIsrItem] = new ConcurrentHashMap[TopicPartition, AlterIsrItem]()\n \n   // Used to allow only one in-flight request at a time\n-  private val inflightRequest: AtomicBoolean = new AtomicBoolean(false)\n+  @volatile\n+  private var inflightRequest: Boolean = false\n \n-  private val lastIsrPropagationMs = new AtomicLong(0)\n+  // Protect updates of the inflight flag and prevent additional pending items from being submitted while we are\n+  // preparing a request\n+  private val inflightLock: ReentrantLock = new ReentrantLock()\n \n   override def start(): Unit = {\n     controllerChannelManager.start()\n-    scheduler.schedule(\"send-alter-isr\", propagateIsrChanges, 50, 50, TimeUnit.MILLISECONDS)\n   }\n \n   override def shutdown(): Unit = {\n     controllerChannelManager.shutdown()\n   }\n \n   override def submit(alterIsrItem: AlterIsrItem): Boolean = {\n-    unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null\n+    inLock(inflightLock) {\n+      if (unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null) {\n+        maybePropagateIsrChanges()\n+        true\n+      } else {\n+        false\n+      }\n+    }\n   }\n \n   override def clearPending(topicPartition: TopicPartition): Unit = {\n     unsentIsrUpdates.remove(topicPartition)\n   }\n \n-  private def propagateIsrChanges(): Unit = {\n-    if (!unsentIsrUpdates.isEmpty && inflightRequest.compareAndSet(false, true)) {\n-      // Copy current unsent ISRs but don't remove from the map\n+  private[server] def maybePropagateIsrChanges(): Unit = inLock(inflightLock) {\n+    // Send all pending items if there is not already a request in-flight.\n+    if (!inflightRequest && !unsentIsrUpdates.isEmpty) {\n+      // Copy current unsent ISRs but don't remove from the map, they get cleared in the response handler\n       val inflightAlterIsrItems = new ListBuffer[AlterIsrItem]()\n       unsentIsrUpdates.values().forEach(item => inflightAlterIsrItems.append(item))\n-\n-      val now = time.milliseconds()\n-      lastIsrPropagationMs.set(now)\n       sendRequest(inflightAlterIsrItems.toSeq)\n+      inflightRequest = true\n     }\n   }\n \n-  private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n-    val message = buildRequest(inflightAlterIsrItems)\n-\n-    def clearInflightRequests(): Unit = {\n-      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-      if (!inflightRequest.compareAndSet(true, false)) {\n-        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n-      }\n+  private[server] def clearInFlightRequest(): Unit = inLock(inflightLock) {\n+    if (!inflightRequest) {\n+      warn(\"Attempting to clear AlterIsr in-flight flag when no apparent request is in-flight\")\n     }\n+    inflightRequest = false\n+  }\n \n+  private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n+    val message = buildRequest(inflightAlterIsrItems)\n     debug(s\"Sending AlterIsr to controller $message\")\n \n     // We will not timeout AlterISR request, instead letting it retry indefinitely\n     // until a response is received, or a new LeaderAndIsr overwrites the existing isrState\n-    // which causes the inflight requests to be ignored.\n+    // which causes the response for those partitions to be ignored.\n     controllerChannelManager.sendRequest(new AlterIsrRequest.Builder(message),\n       new ControllerRequestCompletionHandler {\n         override def onComplete(response: ClientResponse): Unit = {\n-          try {\n-            debug(s\"Received AlterIsr response $response\")\n-            val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-            handleAlterIsrResponse(body, message.brokerEpoch, inflightAlterIsrItems)\n-          } finally {\n-            clearInflightRequests()\n+          debug(s\"Received AlterIsr response $response\")\n+          val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n+          handleAlterIsrResponse(body, message.brokerEpoch, inflightAlterIsrItems) match {\n+            case Errors.NONE =>\n+              // In the normal case, check for pending updates to send immediately\n+              clearInFlightRequest()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1d3d9af0b42ac0fe76ae516493f53a164986b3"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NTc4OTc3OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxOTo0NjowN1rOIRkk8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxOTo0NjowN1rOIRkk8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTI5NTk4NA==", "bodyText": "Do we still need this? It looks like all accesses are protected with the lock.", "url": "https://github.com/apache/kafka/pull/9749#discussion_r555295984", "createdAt": "2021-01-11T19:46:07Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -116,63 +116,75 @@ class DefaultAlterIsrManager(\n   private val unsentIsrUpdates: util.Map[TopicPartition, AlterIsrItem] = new ConcurrentHashMap[TopicPartition, AlterIsrItem]()\n \n   // Used to allow only one in-flight request at a time\n-  private val inflightRequest: AtomicBoolean = new AtomicBoolean(false)\n+  @volatile", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1d3d9af0b42ac0fe76ae516493f53a164986b3"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NTgyOTU2OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxOTo1ODowOVrOIRk9lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMVQxOTo1ODowOVrOIRk9lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTMwMjI5NQ==", "bodyText": "Just doublechecking our locking order. When we call submit from Partition, we first have the leader and ISR write lock and then we acquire the inflight lock added here. Now when we call handleAlterIsrResponse, we may need to reacquire the leader and ISR write lock, but that is ok, because do not need to hold the inflight lock when we do so. I think it might be worth adding some comments on the locking order somewhere in this class since the use of the leader and ISR lock is kind of hidden.", "url": "https://github.com/apache/kafka/pull/9749#discussion_r555302295", "createdAt": "2021-01-11T19:58:09Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -116,63 +116,75 @@ class DefaultAlterIsrManager(\n   private val unsentIsrUpdates: util.Map[TopicPartition, AlterIsrItem] = new ConcurrentHashMap[TopicPartition, AlterIsrItem]()\n \n   // Used to allow only one in-flight request at a time\n-  private val inflightRequest: AtomicBoolean = new AtomicBoolean(false)\n+  @volatile\n+  private var inflightRequest: Boolean = false\n \n-  private val lastIsrPropagationMs = new AtomicLong(0)\n+  // Protect updates of the inflight flag and prevent additional pending items from being submitted while we are\n+  // preparing a request\n+  private val inflightLock: ReentrantLock = new ReentrantLock()\n \n   override def start(): Unit = {\n     controllerChannelManager.start()\n-    scheduler.schedule(\"send-alter-isr\", propagateIsrChanges, 50, 50, TimeUnit.MILLISECONDS)\n   }\n \n   override def shutdown(): Unit = {\n     controllerChannelManager.shutdown()\n   }\n \n   override def submit(alterIsrItem: AlterIsrItem): Boolean = {\n-    unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null\n+    inLock(inflightLock) {\n+      if (unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null) {\n+        maybePropagateIsrChanges()\n+        true\n+      } else {\n+        false\n+      }\n+    }\n   }\n \n   override def clearPending(topicPartition: TopicPartition): Unit = {\n     unsentIsrUpdates.remove(topicPartition)\n   }\n \n-  private def propagateIsrChanges(): Unit = {\n-    if (!unsentIsrUpdates.isEmpty && inflightRequest.compareAndSet(false, true)) {\n-      // Copy current unsent ISRs but don't remove from the map\n+  private[server] def maybePropagateIsrChanges(): Unit = inLock(inflightLock) {\n+    // Send all pending items if there is not already a request in-flight.\n+    if (!inflightRequest && !unsentIsrUpdates.isEmpty) {\n+      // Copy current unsent ISRs but don't remove from the map, they get cleared in the response handler\n       val inflightAlterIsrItems = new ListBuffer[AlterIsrItem]()\n       unsentIsrUpdates.values().forEach(item => inflightAlterIsrItems.append(item))\n-\n-      val now = time.milliseconds()\n-      lastIsrPropagationMs.set(now)\n       sendRequest(inflightAlterIsrItems.toSeq)\n+      inflightRequest = true\n     }\n   }\n \n-  private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n-    val message = buildRequest(inflightAlterIsrItems)\n-\n-    def clearInflightRequests(): Unit = {\n-      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-      if (!inflightRequest.compareAndSet(true, false)) {\n-        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n-      }\n+  private[server] def clearInFlightRequest(): Unit = inLock(inflightLock) {\n+    if (!inflightRequest) {\n+      warn(\"Attempting to clear AlterIsr in-flight flag when no apparent request is in-flight\")\n     }\n+    inflightRequest = false\n+  }\n \n+  private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n+    val message = buildRequest(inflightAlterIsrItems)\n     debug(s\"Sending AlterIsr to controller $message\")\n \n     // We will not timeout AlterISR request, instead letting it retry indefinitely\n     // until a response is received, or a new LeaderAndIsr overwrites the existing isrState\n-    // which causes the inflight requests to be ignored.\n+    // which causes the response for those partitions to be ignored.\n     controllerChannelManager.sendRequest(new AlterIsrRequest.Builder(message),\n       new ControllerRequestCompletionHandler {\n         override def onComplete(response: ClientResponse): Unit = {\n-          try {\n-            debug(s\"Received AlterIsr response $response\")\n-            val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-            handleAlterIsrResponse(body, message.brokerEpoch, inflightAlterIsrItems)\n-          } finally {\n-            clearInflightRequests()\n+          debug(s\"Received AlterIsr response $response\")\n+          val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n+          handleAlterIsrResponse(body, message.brokerEpoch, inflightAlterIsrItems) match {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1d3d9af0b42ac0fe76ae516493f53a164986b3"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUwMDcxOTc2OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQyMDoxMToyMFrOISS09Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQyMDoxMToyMFrOISS09Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjA1Mzc0OQ==", "bodyText": "nit: space after if", "url": "https://github.com/apache/kafka/pull/9749#discussion_r556053749", "createdAt": "2021-01-12T20:11:20Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -112,68 +111,74 @@ class DefaultAlterIsrManager(\n   val brokerEpochSupplier: () => Long\n ) extends AlterIsrManager with Logging with KafkaMetricsGroup {\n \n-  // Used to allow only one pending ISR update per partition\n-  private val unsentIsrUpdates: util.Map[TopicPartition, AlterIsrItem] = new ConcurrentHashMap[TopicPartition, AlterIsrItem]()\n+  // Used to allow only one pending ISR update per partition (visible for testing)\n+  private[server] val unsentIsrUpdates: util.Map[TopicPartition, AlterIsrItem] = new ConcurrentHashMap[TopicPartition, AlterIsrItem]()\n \n   // Used to allow only one in-flight request at a time\n   private val inflightRequest: AtomicBoolean = new AtomicBoolean(false)\n \n-  private val lastIsrPropagationMs = new AtomicLong(0)\n-\n   override def start(): Unit = {\n     controllerChannelManager.start()\n-    scheduler.schedule(\"send-alter-isr\", propagateIsrChanges, 50, 50, TimeUnit.MILLISECONDS)\n   }\n \n   override def shutdown(): Unit = {\n     controllerChannelManager.shutdown()\n   }\n \n   override def submit(alterIsrItem: AlterIsrItem): Boolean = {\n-    unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null\n+    val enqueued = unsentIsrUpdates.putIfAbsent(alterIsrItem.topicPartition, alterIsrItem) == null\n+    maybePropagateIsrChanges()\n+    enqueued\n   }\n \n   override def clearPending(topicPartition: TopicPartition): Unit = {\n     unsentIsrUpdates.remove(topicPartition)\n   }\n \n-  private def propagateIsrChanges(): Unit = {\n+  private[server] def maybePropagateIsrChanges(): Unit = {\n+    // Send all pending items if there is not already a request in-flight.\n     if (!unsentIsrUpdates.isEmpty && inflightRequest.compareAndSet(false, true)) {\n-      // Copy current unsent ISRs but don't remove from the map\n+      // Copy current unsent ISRs but don't remove from the map, they get cleared in the response handler\n       val inflightAlterIsrItems = new ListBuffer[AlterIsrItem]()\n       unsentIsrUpdates.values().forEach(item => inflightAlterIsrItems.append(item))\n-\n-      val now = time.milliseconds()\n-      lastIsrPropagationMs.set(now)\n       sendRequest(inflightAlterIsrItems.toSeq)\n     }\n   }\n \n-  private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n-    val message = buildRequest(inflightAlterIsrItems)\n-\n-    def clearInflightRequests(): Unit = {\n-      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-      if (!inflightRequest.compareAndSet(true, false)) {\n-        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n-      }\n+  private[server] def clearInFlightRequest(): Unit = {\n+    if(!inflightRequest.compareAndSet(true, false)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d44d25d7d2e72c374fa777abc1f738a970c9861"}, "originalPosition": 76}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3509, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}