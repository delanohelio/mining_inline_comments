{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE3OTM1NDUz", "number": 9579, "title": "KAFKA-9751: Forward CreateTopicsRequest for FindCoordinator/Metadata when topic creation is needed", "bodyText": "This PR forward the entire FindCoordinator request to the active controller when the internal topic being queried is not ready to be served yet.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-11-09T17:52:50Z", "url": "https://github.com/apache/kafka/pull/9579", "merged": true, "mergeCommit": {"oid": "d2cb2dc45d536ae124e3da25d6d5a4e932a23a27"}, "closed": true, "closedAt": "2021-02-06T21:04:31Z", "author": {"login": "abbccdda"}, "timelineItems": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdbPLRsgBqjM5ODA3NjI0MzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABd3iDsygH2gAyNTE3OTM1NDUzOjFkMjFmYzQ2OTNiMjg5Y2FlYjkyZGJjZmNiOWQxOWQ4NDU1ZDdjMGU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "309d45a14e274b1206b6d8c81462b99f40ccc0a5", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/309d45a14e274b1206b6d8c81462b99f40ccc0a5", "committedDate": "2020-11-17T02:48:41Z", "message": "fix test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "309d45a14e274b1206b6d8c81462b99f40ccc0a5", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/309d45a14e274b1206b6d8c81462b99f40ccc0a5", "committedDate": "2020-11-17T02:48:41Z", "message": "fix test"}, "afterCommit": {"oid": "a1c802a751e45d5afc846f03ea4223700dd2b572", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/a1c802a751e45d5afc846f03ea4223700dd2b572", "committedDate": "2021-01-19T18:46:34Z", "message": "rebase fix"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a1c802a751e45d5afc846f03ea4223700dd2b572", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/a1c802a751e45d5afc846f03ea4223700dd2b572", "committedDate": "2021-01-19T18:46:34Z", "message": "rebase fix"}, "afterCommit": {"oid": "c95723a8e735cb6257e2fad515c7e456e4d3eb2a", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/c95723a8e735cb6257e2fad515c7e456e4d3eb2a", "committedDate": "2021-01-19T19:11:51Z", "message": "rebase fix"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "becebdba60480f721d32d5e7218be0231f85520e", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/becebdba60480f721d32d5e7218be0231f85520e", "committedDate": "2021-01-19T19:34:39Z", "message": "rename class"}, "afterCommit": {"oid": "ab42e9fda9d5829ba163163052f03a33586c0a85", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/ab42e9fda9d5829ba163163052f03a33586c0a85", "committedDate": "2021-01-19T19:40:37Z", "message": "rename class"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcyODE5NTk2", "url": "https://github.com/apache/kafka/pull/9579#pullrequestreview-572819596", "createdAt": "2021-01-21T00:59:34Z", "commit": {"oid": "1d626d2bfea3fe6171083404acdaf08ee9779988"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQwMDo1OTozNFrOIXb4hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMVQwMTozMTozMlrOIXcjKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTQ0NDk5OA==", "bodyText": "An alternative that we have done elsewhere would be to introduce an AbstractMetadataRequestTest which we can pull the common cases up to. A more elegant option might be to figure out how to use @ParameterizedTest so that we can provide config overrides. This would be a little difficult at the moment because we initialize brokers in a @Before method. Probably means we need to move away from this approach long term. For now, the abstract class seems preferable. Similar for CreateTopicsRequestWithForwardingTest.", "url": "https://github.com/apache/kafka/pull/9579#discussion_r561444998", "createdAt": "2021-01-21T00:59:34Z", "author": {"login": "hachikuji"}, "path": "core/src/test/scala/unit/kafka/server/MetadataRequestWithForwardingTest.scala", "diffHunk": "@@ -0,0 +1,92 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package unit.kafka.server\n+\n+import java.util.Properties\n+\n+import kafka.server.{KafkaConfig, MetadataRequestTest}\n+import org.junit.jupiter.api.Test\n+\n+class MetadataRequestWithForwardingTest extends MetadataRequestTest {\n+\n+  override def brokerPropertyOverrides(properties: Properties): Unit = {\n+    super.brokerPropertyOverrides(properties)\n+    properties.put(KafkaConfig.EnableMetadataQuorumProp, true.toString)\n+  }\n+\n+  @Test\n+  override def testAutoTopicCreation(): Unit = {\n+    super.testAutoTopicCreation()\n+  }\n+\n+  @Test\n+  override def testAutoCreateOfCollidingTopics(): Unit = {\n+    super.testAutoCreateOfCollidingTopics()\n+  }\n+\n+  @Test\n+  override def testAutoCreateTopicWithInvalidReplicationFactor(): Unit = {\n+    super.testAutoCreateTopicWithInvalidReplicationFactor()\n+  }\n+\n+  /* the rest of tests are not enabled */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d626d2bfea3fe6171083404acdaf08ee9779988"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTQ1MDU0NQ==", "bodyText": "The controller should have these configurations as well. Perhaps it is better to use -1 for this and replication factor and let the controller fill them in?", "url": "https://github.com/apache/kafka/pull/9579#discussion_r561450545", "createdAt": "2021-01-21T01:16:13Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1370,55 +1345,164 @@ class KafkaApis(val requestChannel: RequestChannel,\n         !authHelper.authorize(request.context, DESCRIBE, TRANSACTIONAL_ID, findCoordinatorRequest.data.key))\n       requestHelper.sendErrorResponseMaybeThrottle(request, Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED.exception)\n     else {\n-      // get metadata (and create the topic if necessary)\n-      val (partition, topicMetadata) = CoordinatorType.forId(findCoordinatorRequest.data.keyType) match {\n+      val (partition, internalTopicName) = CoordinatorType.forId(findCoordinatorRequest.data.keyType) match {\n         case CoordinatorType.GROUP =>\n-          val partition = groupCoordinator.partitionFor(findCoordinatorRequest.data.key)\n-          val metadata = getOrCreateInternalTopic(GROUP_METADATA_TOPIC_NAME, request.context.listenerName)\n-          (partition, metadata)\n+          (groupCoordinator.partitionFor(findCoordinatorRequest.data.key), GROUP_METADATA_TOPIC_NAME)\n \n         case CoordinatorType.TRANSACTION =>\n-          val partition = txnCoordinator.partitionFor(findCoordinatorRequest.data.key)\n-          val metadata = getOrCreateInternalTopic(TRANSACTION_STATE_TOPIC_NAME, request.context.listenerName)\n-          (partition, metadata)\n+          (txnCoordinator.partitionFor(findCoordinatorRequest.data.key), TRANSACTION_STATE_TOPIC_NAME)\n+      }\n \n-        case _ =>\n-          throw new InvalidRequestException(\"Unknown coordinator type in FindCoordinator request\")\n+      val topicMetadata = metadataCache.getTopicMetadata(Set(internalTopicName), request.context.listenerName)\n+      def createFindCoordinatorResponse(error: Errors,\n+                                        node: Node,\n+                                        requestThrottleMs: Int,\n+                                        errorMessage: Option[String] = None): FindCoordinatorResponse = {\n+        new FindCoordinatorResponse(\n+          new FindCoordinatorResponseData()\n+            .setErrorCode(error.code)\n+            .setErrorMessage(errorMessage.getOrElse(error.message))\n+            .setNodeId(node.id)\n+            .setHost(node.host)\n+            .setPort(node.port)\n+            .setThrottleTimeMs(requestThrottleMs))\n       }\n \n-      def createResponse(requestThrottleMs: Int): AbstractResponse = {\n-        def createFindCoordinatorResponse(error: Errors, node: Node): FindCoordinatorResponse = {\n-          new FindCoordinatorResponse(\n-              new FindCoordinatorResponseData()\n-                .setErrorCode(error.code)\n-                .setErrorMessage(error.message)\n-                .setNodeId(node.id)\n-                .setHost(node.host)\n-                .setPort(node.port)\n-                .setThrottleTimeMs(requestThrottleMs))\n+      val topicCreationNeeded = topicMetadata.headOption.isEmpty\n+      if (topicCreationNeeded) {\n+        if (hasEnoughAliveBrokers(internalTopicName)) {\n+          if (shouldForwardRequest(request)) {\n+            forwardingManager.sendInterBrokerRequest(\n+              getCreateTopicsRequest(Seq(internalTopicName)),\n+              _ => ())\n+          } else {\n+            val controllerMutationQuota = quotas.controllerMutation.newQuotaFor(request, strictSinceVersion = 6)\n+\n+            val topicConfigs = Map(internalTopicName -> getTopicConfigs(internalTopicName))\n+            adminManager.createTopics(\n+              config.requestTimeoutMs,\n+              validateOnly = false,\n+              topicConfigs,\n+              Map.empty,\n+              controllerMutationQuota,\n+              _ => ())\n+          }\n         }\n-        val responseBody = if (topicMetadata.errorCode != Errors.NONE.code) {\n-          createFindCoordinatorResponse(Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode)\n-        } else {\n-          val coordinatorEndpoint = topicMetadata.partitions.asScala\n-            .find(_.partitionIndex == partition)\n-            .filter(_.leaderId != MetadataResponse.NO_LEADER_ID)\n-            .flatMap(metadata => metadataCache.getAliveBroker(metadata.leaderId))\n-            .flatMap(_.getNode(request.context.listenerName))\n-            .filterNot(_.isEmpty)\n-\n-          coordinatorEndpoint match {\n-            case Some(endpoint) =>\n-              createFindCoordinatorResponse(Errors.NONE, endpoint)\n-            case _ =>\n-              createFindCoordinatorResponse(Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode)\n+\n+        requestHelper.sendResponseMaybeThrottle(request, requestThrottleMs => createFindCoordinatorResponse(\n+          Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode, requestThrottleMs))\n+      } else {\n+        def createResponse(requestThrottleMs: Int): AbstractResponse = {\n+          val responseBody = if (topicMetadata.head.errorCode != Errors.NONE.code) {\n+            createFindCoordinatorResponse(Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode, requestThrottleMs)\n+          } else {\n+            val coordinatorEndpoint = topicMetadata.head.partitions.asScala\n+              .find(_.partitionIndex == partition)\n+              .filter(_.leaderId != MetadataResponse.NO_LEADER_ID)\n+              .flatMap(metadata => metadataCache.getAliveBroker(metadata.leaderId))\n+              .flatMap(_.getNode(request.context.listenerName))\n+              .filterNot(_.isEmpty)\n+\n+            coordinatorEndpoint match {\n+              case Some(endpoint) =>\n+                createFindCoordinatorResponse(Errors.NONE, endpoint, requestThrottleMs)\n+              case _ =>\n+                createFindCoordinatorResponse(Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode, requestThrottleMs)\n+            }\n           }\n+          trace(\"Sending FindCoordinator response %s for correlation id %d to client %s.\"\n+            .format(responseBody, request.header.correlationId, request.header.clientId))\n+          responseBody\n         }\n-        trace(\"Sending FindCoordinator response %s for correlation id %d to client %s.\"\n-          .format(responseBody, request.header.correlationId, request.header.clientId))\n-        responseBody\n+\n+        requestHelper.sendResponseMaybeThrottle(request, createResponse)\n+      }\n+    }\n+  }\n+\n+  private def getCreateTopicsRequest(topics: Seq[String]): CreateTopicsRequest.Builder = {\n+    val topicCollection = new CreateTopicsRequestData.CreatableTopicCollection\n+    topics.foreach(topic => {\n+      topicCollection.add(getTopicConfigs(topic))\n+    })\n+\n+    new CreateTopicsRequest.Builder(\n+      new CreateTopicsRequestData()\n+        .setTimeoutMs(config.requestTimeoutMs)\n+        .setTopics(topicCollection)\n+    )\n+  }\n+\n+  private def getTopicConfigs(topic: String): CreatableTopic = {\n+    topic match {\n+      case GROUP_METADATA_TOPIC_NAME =>\n+        new CreatableTopic()\n+          .setName(topic)\n+          .setNumPartitions(config.offsetsTopicPartitions)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d626d2bfea3fe6171083404acdaf08ee9779988"}, "originalPosition": 433}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTQ1MTYwMg==", "bodyText": "In the case of forwarding, maybe we can let the controller decide if there are enough alive brokers.", "url": "https://github.com/apache/kafka/pull/9579#discussion_r561451602", "createdAt": "2021-01-21T01:19:00Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1370,55 +1345,164 @@ class KafkaApis(val requestChannel: RequestChannel,\n         !authHelper.authorize(request.context, DESCRIBE, TRANSACTIONAL_ID, findCoordinatorRequest.data.key))\n       requestHelper.sendErrorResponseMaybeThrottle(request, Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED.exception)\n     else {\n-      // get metadata (and create the topic if necessary)\n-      val (partition, topicMetadata) = CoordinatorType.forId(findCoordinatorRequest.data.keyType) match {\n+      val (partition, internalTopicName) = CoordinatorType.forId(findCoordinatorRequest.data.keyType) match {\n         case CoordinatorType.GROUP =>\n-          val partition = groupCoordinator.partitionFor(findCoordinatorRequest.data.key)\n-          val metadata = getOrCreateInternalTopic(GROUP_METADATA_TOPIC_NAME, request.context.listenerName)\n-          (partition, metadata)\n+          (groupCoordinator.partitionFor(findCoordinatorRequest.data.key), GROUP_METADATA_TOPIC_NAME)\n \n         case CoordinatorType.TRANSACTION =>\n-          val partition = txnCoordinator.partitionFor(findCoordinatorRequest.data.key)\n-          val metadata = getOrCreateInternalTopic(TRANSACTION_STATE_TOPIC_NAME, request.context.listenerName)\n-          (partition, metadata)\n+          (txnCoordinator.partitionFor(findCoordinatorRequest.data.key), TRANSACTION_STATE_TOPIC_NAME)\n+      }\n \n-        case _ =>\n-          throw new InvalidRequestException(\"Unknown coordinator type in FindCoordinator request\")\n+      val topicMetadata = metadataCache.getTopicMetadata(Set(internalTopicName), request.context.listenerName)\n+      def createFindCoordinatorResponse(error: Errors,\n+                                        node: Node,\n+                                        requestThrottleMs: Int,\n+                                        errorMessage: Option[String] = None): FindCoordinatorResponse = {\n+        new FindCoordinatorResponse(\n+          new FindCoordinatorResponseData()\n+            .setErrorCode(error.code)\n+            .setErrorMessage(errorMessage.getOrElse(error.message))\n+            .setNodeId(node.id)\n+            .setHost(node.host)\n+            .setPort(node.port)\n+            .setThrottleTimeMs(requestThrottleMs))\n       }\n \n-      def createResponse(requestThrottleMs: Int): AbstractResponse = {\n-        def createFindCoordinatorResponse(error: Errors, node: Node): FindCoordinatorResponse = {\n-          new FindCoordinatorResponse(\n-              new FindCoordinatorResponseData()\n-                .setErrorCode(error.code)\n-                .setErrorMessage(error.message)\n-                .setNodeId(node.id)\n-                .setHost(node.host)\n-                .setPort(node.port)\n-                .setThrottleTimeMs(requestThrottleMs))\n+      val topicCreationNeeded = topicMetadata.headOption.isEmpty\n+      if (topicCreationNeeded) {\n+        if (hasEnoughAliveBrokers(internalTopicName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d626d2bfea3fe6171083404acdaf08ee9779988"}, "originalPosition": 347}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTQ1MjU4Mg==", "bodyText": "nit: seems misaligned", "url": "https://github.com/apache/kafka/pull/9579#discussion_r561452582", "createdAt": "2021-01-21T01:22:07Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1110,82 +1098,39 @@ class KafkaApis(val requestChannel: RequestChannel,\n       .setPartitions(partitionData)\n   }\n \n-  private def createInternalTopic(topic: String): MetadataResponseTopic = {\n-    if (topic == null)\n-      throw new IllegalArgumentException(\"topic must not be null\")\n-\n-    val aliveBrokers = metadataCache.getAliveBrokers\n-\n-    topic match {\n-      case GROUP_METADATA_TOPIC_NAME =>\n-        if (aliveBrokers.size < config.offsetsTopicReplicationFactor) {\n-          error(s\"Number of alive brokers '${aliveBrokers.size}' does not meet the required replication factor \" +\n-            s\"'${config.offsetsTopicReplicationFactor}' for the offsets topic (configured via \" +\n-            s\"'${KafkaConfig.OffsetsTopicReplicationFactorProp}'). This error can be ignored if the cluster is starting up \" +\n-            s\"and not all brokers are up yet.\")\n-          metadataResponseTopic(Errors.COORDINATOR_NOT_AVAILABLE, topic, true, util.Collections.emptyList())\n-        } else {\n-          createTopic(topic, config.offsetsTopicPartitions, config.offsetsTopicReplicationFactor.toInt,\n-            groupCoordinator.offsetsTopicConfigs)\n-        }\n-      case TRANSACTION_STATE_TOPIC_NAME =>\n-        if (aliveBrokers.size < config.transactionTopicReplicationFactor) {\n-          error(s\"Number of alive brokers '${aliveBrokers.size}' does not meet the required replication factor \" +\n-            s\"'${config.transactionTopicReplicationFactor}' for the transactions state topic (configured via \" +\n-            s\"'${KafkaConfig.TransactionsTopicReplicationFactorProp}'). This error can be ignored if the cluster is starting up \" +\n-            s\"and not all brokers are up yet.\")\n-          metadataResponseTopic(Errors.COORDINATOR_NOT_AVAILABLE, topic, true, util.Collections.emptyList())\n-        } else {\n-          createTopic(topic, config.transactionTopicPartitions, config.transactionTopicReplicationFactor.toInt,\n-            txnCoordinator.transactionTopicConfigs)\n-        }\n-      case _ => throw new IllegalArgumentException(s\"Unexpected internal topic name: $topic\")\n-    }\n-  }\n-\n-  private def getOrCreateInternalTopic(topic: String, listenerName: ListenerName): MetadataResponseData.MetadataResponseTopic = {\n-    val topicMetadata = metadataCache.getTopicMetadata(Set(topic), listenerName)\n-    topicMetadata.headOption.getOrElse(createInternalTopic(topic))\n-  }\n-\n-  private def getTopicMetadata(allowAutoTopicCreation: Boolean, isFetchAllMetadata: Boolean,\n-                               topics: Set[String], listenerName: ListenerName,\n+  private def getTopicMetadata(allowAutoTopicCreation: Boolean,\n+                               isFetchAllMetadata: Boolean,\n+                               topics: Set[String],\n+                               listenerName: ListenerName,\n                                errorUnavailableEndpoints: Boolean,\n-                               errorUnavailableListeners: Boolean): Seq[MetadataResponseTopic] = {\n+                               errorUnavailableListeners: Boolean): (Seq[MetadataResponseTopic], Seq[MetadataResponseTopic]) = {\n     val topicResponses = metadataCache.getTopicMetadata(topics, listenerName,\n         errorUnavailableEndpoints, errorUnavailableListeners)\n \n     if (topics.isEmpty || topicResponses.size == topics.size) {\n-      topicResponses\n+      (topicResponses, Seq.empty[MetadataResponseTopic])\n     } else {\n       val nonExistentTopics = topics.diff(topicResponses.map(_.name).toSet)\n       val responsesForNonExistentTopics = nonExistentTopics.flatMap { topic =>\n-        if (isInternal(topic)) {\n-          val topicMetadata = createInternalTopic(topic)\n-          Some(\n-            if (topicMetadata.errorCode == Errors.COORDINATOR_NOT_AVAILABLE.code)\n-              metadataResponseTopic(Errors.INVALID_REPLICATION_FACTOR, topic, true, util.Collections.emptyList())\n-            else\n-              topicMetadata\n-          )\n-        } else if (isFetchAllMetadata) {\n+       if (isFetchAllMetadata) {\n           // A metadata request for all topics should never result in topic auto creation, but a topic may be deleted\n           // in between the creation of the topics parameter and topicResponses, so make sure to return None for this case.\n           None\n-        } else if (allowAutoTopicCreation && config.autoCreateTopicsEnable) {\n-          Some(createTopic(topic, config.numPartitions, config.defaultReplicationFactor))\n-        } else {\n-          Some(metadataResponseTopic(Errors.UNKNOWN_TOPIC_OR_PARTITION, topic, false, util.Collections.emptyList()))\n+       } else {\n+        Some(metadataResponseTopic(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d626d2bfea3fe6171083404acdaf08ee9779988"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTQ1NTIyMw==", "bodyText": "We seem to have lost this handling or am I missing something?", "url": "https://github.com/apache/kafka/pull/9579#discussion_r561455223", "createdAt": "2021-01-21T01:29:31Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1084,24 +1087,9 @@ class KafkaApis(val requestChannel: RequestChannel,\n     (responseTopics ++ unauthorizedResponseStatus).toList\n   }\n \n-  private def createTopic(topic: String,\n-                          numPartitions: Int,\n-                          replicationFactor: Int,\n-                          properties: util.Properties = new util.Properties()): MetadataResponseTopic = {\n-    try {\n-      adminZkClient.createTopic(topic, numPartitions, replicationFactor, properties, RackAwareMode.Safe)\n-      info(\"Auto creation of topic %s with %d partitions and replication factor %d is successful\"\n-        .format(topic, numPartitions, replicationFactor))\n-      metadataResponseTopic(Errors.LEADER_NOT_AVAILABLE, topic, isInternal(topic), util.Collections.emptyList())\n-    } catch {\n-      case _: TopicExistsException => // let it go, possibly another broker created this topic", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d626d2bfea3fe6171083404acdaf08ee9779988"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTQ1NTkxNA==", "bodyText": "Hmm.. In the old logic, we would attempt topic creation through zookeeper first. Then, if the topic was created successfully, we would return LEADER_NOT_AVAILABLE to give time for the controller to elect a leader. Now we return LEADER_NOT_AVAILABLE immediately and we send the CreateTopic request asynchronously. We don't know if the CreateTopic request will ultimately succeed or not. Perhaps it would be better to keep returning UNKNOWN_TOPIC_OR_PARTITION until we see that the topic exists.", "url": "https://github.com/apache/kafka/pull/9579#discussion_r561455914", "createdAt": "2021-01-21T01:31:32Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1110,82 +1098,39 @@ class KafkaApis(val requestChannel: RequestChannel,\n       .setPartitions(partitionData)\n   }\n \n-  private def createInternalTopic(topic: String): MetadataResponseTopic = {\n-    if (topic == null)\n-      throw new IllegalArgumentException(\"topic must not be null\")\n-\n-    val aliveBrokers = metadataCache.getAliveBrokers\n-\n-    topic match {\n-      case GROUP_METADATA_TOPIC_NAME =>\n-        if (aliveBrokers.size < config.offsetsTopicReplicationFactor) {\n-          error(s\"Number of alive brokers '${aliveBrokers.size}' does not meet the required replication factor \" +\n-            s\"'${config.offsetsTopicReplicationFactor}' for the offsets topic (configured via \" +\n-            s\"'${KafkaConfig.OffsetsTopicReplicationFactorProp}'). This error can be ignored if the cluster is starting up \" +\n-            s\"and not all brokers are up yet.\")\n-          metadataResponseTopic(Errors.COORDINATOR_NOT_AVAILABLE, topic, true, util.Collections.emptyList())\n-        } else {\n-          createTopic(topic, config.offsetsTopicPartitions, config.offsetsTopicReplicationFactor.toInt,\n-            groupCoordinator.offsetsTopicConfigs)\n-        }\n-      case TRANSACTION_STATE_TOPIC_NAME =>\n-        if (aliveBrokers.size < config.transactionTopicReplicationFactor) {\n-          error(s\"Number of alive brokers '${aliveBrokers.size}' does not meet the required replication factor \" +\n-            s\"'${config.transactionTopicReplicationFactor}' for the transactions state topic (configured via \" +\n-            s\"'${KafkaConfig.TransactionsTopicReplicationFactorProp}'). This error can be ignored if the cluster is starting up \" +\n-            s\"and not all brokers are up yet.\")\n-          metadataResponseTopic(Errors.COORDINATOR_NOT_AVAILABLE, topic, true, util.Collections.emptyList())\n-        } else {\n-          createTopic(topic, config.transactionTopicPartitions, config.transactionTopicReplicationFactor.toInt,\n-            txnCoordinator.transactionTopicConfigs)\n-        }\n-      case _ => throw new IllegalArgumentException(s\"Unexpected internal topic name: $topic\")\n-    }\n-  }\n-\n-  private def getOrCreateInternalTopic(topic: String, listenerName: ListenerName): MetadataResponseData.MetadataResponseTopic = {\n-    val topicMetadata = metadataCache.getTopicMetadata(Set(topic), listenerName)\n-    topicMetadata.headOption.getOrElse(createInternalTopic(topic))\n-  }\n-\n-  private def getTopicMetadata(allowAutoTopicCreation: Boolean, isFetchAllMetadata: Boolean,\n-                               topics: Set[String], listenerName: ListenerName,\n+  private def getTopicMetadata(allowAutoTopicCreation: Boolean,\n+                               isFetchAllMetadata: Boolean,\n+                               topics: Set[String],\n+                               listenerName: ListenerName,\n                                errorUnavailableEndpoints: Boolean,\n-                               errorUnavailableListeners: Boolean): Seq[MetadataResponseTopic] = {\n+                               errorUnavailableListeners: Boolean): (Seq[MetadataResponseTopic], Seq[MetadataResponseTopic]) = {\n     val topicResponses = metadataCache.getTopicMetadata(topics, listenerName,\n         errorUnavailableEndpoints, errorUnavailableListeners)\n \n     if (topics.isEmpty || topicResponses.size == topics.size) {\n-      topicResponses\n+      (topicResponses, Seq.empty[MetadataResponseTopic])\n     } else {\n       val nonExistentTopics = topics.diff(topicResponses.map(_.name).toSet)\n       val responsesForNonExistentTopics = nonExistentTopics.flatMap { topic =>\n-        if (isInternal(topic)) {\n-          val topicMetadata = createInternalTopic(topic)\n-          Some(\n-            if (topicMetadata.errorCode == Errors.COORDINATOR_NOT_AVAILABLE.code)\n-              metadataResponseTopic(Errors.INVALID_REPLICATION_FACTOR, topic, true, util.Collections.emptyList())\n-            else\n-              topicMetadata\n-          )\n-        } else if (isFetchAllMetadata) {\n+       if (isFetchAllMetadata) {\n           // A metadata request for all topics should never result in topic auto creation, but a topic may be deleted\n           // in between the creation of the topics parameter and topicResponses, so make sure to return None for this case.\n           None\n-        } else if (allowAutoTopicCreation && config.autoCreateTopicsEnable) {\n-          Some(createTopic(topic, config.numPartitions, config.defaultReplicationFactor))\n-        } else {\n-          Some(metadataResponseTopic(Errors.UNKNOWN_TOPIC_OR_PARTITION, topic, false, util.Collections.emptyList()))\n+       } else {\n+        Some(metadataResponseTopic(\n+          if (!hasEnoughAliveBrokers(topic))\n+            Errors.INVALID_REPLICATION_FACTOR\n+          else if (allowAutoTopicCreation && config.autoCreateTopicsEnable)\n+            Errors.LEADER_NOT_AVAILABLE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d626d2bfea3fe6171083404acdaf08ee9779988"}, "originalPosition": 202}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1d626d2bfea3fe6171083404acdaf08ee9779988", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/1d626d2bfea3fe6171083404acdaf08ee9779988", "committedDate": "2021-01-19T21:44:28Z", "message": "fix test"}, "afterCommit": {"oid": "0dcd806b2aad55f0aa7bd66cdbe882dc5594ea99", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/0dcd806b2aad55f0aa7bd66cdbe882dc5594ea99", "committedDate": "2021-01-25T17:41:29Z", "message": "auto topic manager"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0dcd806b2aad55f0aa7bd66cdbe882dc5594ea99", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/0dcd806b2aad55f0aa7bd66cdbe882dc5594ea99", "committedDate": "2021-01-25T17:41:29Z", "message": "auto topic manager"}, "afterCommit": {"oid": "b303f129e4dfe126cec919f952b6196d1fbfe355", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/b303f129e4dfe126cec919f952b6196d1fbfe355", "committedDate": "2021-01-27T05:15:54Z", "message": "auto topic manager"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc2OTkyMDEz", "url": "https://github.com/apache/kafka/pull/9579#pullrequestreview-576992013", "createdAt": "2021-01-27T05:20:18Z", "commit": {"oid": "b303f129e4dfe126cec919f952b6196d1fbfe355"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QwNToyMDoxOFrOIa3Bdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yN1QwNToyMDoxOFrOIa3Bdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTAzNTM4Mw==", "bodyText": "Side cleanup which is called within requestThread.shutdown()", "url": "https://github.com/apache/kafka/pull/9579#discussion_r565035383", "createdAt": "2021-01-27T05:20:18Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManager.scala", "diffHunk": "@@ -61,7 +61,6 @@ class BrokerToControllerChannelManager(\n \n   def shutdown(): Unit = {\n     requestThread.shutdown()\n-    requestThread.awaitShutdown()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b303f129e4dfe126cec919f952b6196d1fbfe355"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b303f129e4dfe126cec919f952b6196d1fbfe355", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/b303f129e4dfe126cec919f952b6196d1fbfe355", "committedDate": "2021-01-27T05:15:54Z", "message": "auto topic manager"}, "afterCommit": {"oid": "ed3d1d6cb03c14e75792f87835225a17fe350a86", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/ed3d1d6cb03c14e75792f87835225a17fe350a86", "committedDate": "2021-01-28T04:41:44Z", "message": "test fix (no forwarding)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ed3d1d6cb03c14e75792f87835225a17fe350a86", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/ed3d1d6cb03c14e75792f87835225a17fe350a86", "committedDate": "2021-01-28T04:41:44Z", "message": "test fix (no forwarding)"}, "afterCommit": {"oid": "f6b5586b7e43bf17aac45280b883096c9778a994", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/f6b5586b7e43bf17aac45280b883096c9778a994", "committedDate": "2021-01-28T05:01:49Z", "message": "test fix (no forwarding)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f6b5586b7e43bf17aac45280b883096c9778a994", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/f6b5586b7e43bf17aac45280b883096c9778a994", "committedDate": "2021-01-28T05:01:49Z", "message": "test fix (no forwarding)"}, "afterCommit": {"oid": "e5e9d624742633139e134e72747dcf1fe5adbca7", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/e5e9d624742633139e134e72747dcf1fe5adbca7", "committedDate": "2021-01-29T03:22:01Z", "message": "test fix (no forwarding)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8aa1c6122bbf85d5b744b22a0f4f31f600517b02", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/8aa1c6122bbf85d5b744b22a0f4f31f600517b02", "committedDate": "2021-01-29T22:00:47Z", "message": "always define auto topic creation manager"}, "afterCommit": {"oid": "be8dc498e00d032674447eb7d0a6c749b4ed5e95", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/be8dc498e00d032674447eb7d0a6c749b4ed5e95", "committedDate": "2021-01-29T22:02:57Z", "message": "always define auto topic creation manager"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "be8dc498e00d032674447eb7d0a6c749b4ed5e95", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/be8dc498e00d032674447eb7d0a6c749b4ed5e95", "committedDate": "2021-01-29T22:02:57Z", "message": "always define auto topic creation manager"}, "afterCommit": {"oid": "eb0562c4d10fe0f2677c776ee7514167238cc7db", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/eb0562c4d10fe0f2677c776ee7514167238cc7db", "committedDate": "2021-01-30T17:45:19Z", "message": "always define auto topic creation manager"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eb0562c4d10fe0f2677c776ee7514167238cc7db", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/eb0562c4d10fe0f2677c776ee7514167238cc7db", "committedDate": "2021-01-30T17:45:19Z", "message": "always define auto topic creation manager"}, "afterCommit": {"oid": "d3124cf11ad8db9cb91bc778fd2c7ca63788c85c", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/d3124cf11ad8db9cb91bc778fd2c7ca63788c85c", "committedDate": "2021-02-02T21:10:46Z", "message": "always define auto topic creation manager"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d3124cf11ad8db9cb91bc778fd2c7ca63788c85c", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/d3124cf11ad8db9cb91bc778fd2c7ca63788c85c", "committedDate": "2021-02-02T21:10:46Z", "message": "always define auto topic creation manager"}, "afterCommit": {"oid": "9b4521af2982c477658e286c4ee181416c4f5195", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/9b4521af2982c477658e286c4ee181416c4f5195", "committedDate": "2021-02-03T00:50:00Z", "message": "forward FindCoordinator/Metadata request when topic creation is needed\n\nalways define auto topic creation manager"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9b4521af2982c477658e286c4ee181416c4f5195", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/9b4521af2982c477658e286c4ee181416c4f5195", "committedDate": "2021-02-03T00:50:00Z", "message": "forward FindCoordinator/Metadata request when topic creation is needed\n\nalways define auto topic creation manager"}, "afterCommit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/2848e8d7e72e3857f6e8422820f9c5ad13621228", "committedDate": "2021-02-03T01:25:55Z", "message": "forward FindCoordinator/Metadata request when topic creation is needed\n\nalways define auto topic creation manager"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgxOTQwODI5", "url": "https://github.com/apache/kafka/pull/9579#pullrequestreview-581940829", "createdAt": "2021-02-03T01:51:13Z", "commit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228"}, "state": "COMMENTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwMTo1MToxM1rOIessZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwNTo1NToyOVrOIeyHTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA2MDQ1NQ==", "bodyText": "nit: do we need default implementations?", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569060455", "createdAt": "2021-02-03T01:51:13Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AutoTopicCreationManager.scala", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import kafka.controller.KafkaController\n+import kafka.utils.Logging\n+import org.apache.kafka.clients.ClientResponse\n+import org.apache.kafka.common.message.CreateTopicsRequestData\n+import org.apache.kafka.common.message.CreateTopicsRequestData.CreatableTopic\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.requests.CreateTopicsRequest\n+import org.apache.kafka.common.utils.Time\n+\n+import scala.collection.Map\n+\n+trait AutoTopicCreationManager {\n+\n+  def createTopics(\n+    topicNames: Set[CreatableTopic],\n+    controllerMutationQuota: ControllerMutationQuota\n+  ): Unit\n+\n+  def start(): Unit = {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA2MTAzOA==", "bodyText": "Let's leave this for a follow-up, but just want to mention that it is probably better if we can reuse the same BrokerToControllerChannelManager as ForwardingManager. Can you file a JIRA for a follow-up?", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569061038", "createdAt": "2021-02-03T01:51:59Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AutoTopicCreationManager.scala", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import kafka.controller.KafkaController\n+import kafka.utils.Logging\n+import org.apache.kafka.clients.ClientResponse\n+import org.apache.kafka.common.message.CreateTopicsRequestData\n+import org.apache.kafka.common.message.CreateTopicsRequestData.CreatableTopic\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.requests.CreateTopicsRequest\n+import org.apache.kafka.common.utils.Time\n+\n+import scala.collection.Map\n+\n+trait AutoTopicCreationManager {\n+\n+  def createTopics(\n+    topicNames: Set[CreatableTopic],\n+    controllerMutationQuota: ControllerMutationQuota\n+  ): Unit\n+\n+  def start(): Unit = {}\n+\n+  def shutdown(): Unit = {}\n+}\n+\n+object AutoTopicCreationManager {\n+\n+  def apply(\n+    config: KafkaConfig,\n+    metadataCache: MetadataCache,\n+    time: Time,\n+    metrics: Metrics,\n+    threadNamePrefix: Option[String],\n+    adminManager: ZkAdminManager,\n+    controller: KafkaController,\n+    enableForwarding: Boolean\n+  ): AutoTopicCreationManager = {\n+\n+    val channelManager =\n+      if (enableForwarding)\n+        Some(new BrokerToControllerChannelManager(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA3MjM4MQ==", "bodyText": "Hmm, I agree the ordering of these checks was weird. So if isFetchAllMetadata is set, then responsesForNonExistentTopics will be empty and we will return (topicResponses, Seq.empty[MetadataResponseTopic]). Does that mean we can add this check to the first clause?\n  if (isFetchAllMetadata || topics.isEmpty || topicResponses.size == topics.size) {\n       (topicResponses, Seq.empty[MetadataResponseTopic])", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569072381", "createdAt": "2021-02-03T02:06:38Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1113,82 +1097,36 @@ class KafkaApis(val requestChannel: RequestChannel,\n       .setPartitions(partitionData)\n   }\n \n-  private def createInternalTopic(topic: String): MetadataResponseTopic = {\n-    if (topic == null)\n-      throw new IllegalArgumentException(\"topic must not be null\")\n-\n-    val aliveBrokers = metadataCache.getAliveBrokers\n-\n-    topic match {\n-      case GROUP_METADATA_TOPIC_NAME =>\n-        if (aliveBrokers.size < config.offsetsTopicReplicationFactor) {\n-          error(s\"Number of alive brokers '${aliveBrokers.size}' does not meet the required replication factor \" +\n-            s\"'${config.offsetsTopicReplicationFactor}' for the offsets topic (configured via \" +\n-            s\"'${KafkaConfig.OffsetsTopicReplicationFactorProp}'). This error can be ignored if the cluster is starting up \" +\n-            s\"and not all brokers are up yet.\")\n-          metadataResponseTopic(Errors.COORDINATOR_NOT_AVAILABLE, topic, true, util.Collections.emptyList())\n-        } else {\n-          createTopic(topic, config.offsetsTopicPartitions, config.offsetsTopicReplicationFactor.toInt,\n-            groupCoordinator.offsetsTopicConfigs)\n-        }\n-      case TRANSACTION_STATE_TOPIC_NAME =>\n-        if (aliveBrokers.size < config.transactionTopicReplicationFactor) {\n-          error(s\"Number of alive brokers '${aliveBrokers.size}' does not meet the required replication factor \" +\n-            s\"'${config.transactionTopicReplicationFactor}' for the transactions state topic (configured via \" +\n-            s\"'${KafkaConfig.TransactionsTopicReplicationFactorProp}'). This error can be ignored if the cluster is starting up \" +\n-            s\"and not all brokers are up yet.\")\n-          metadataResponseTopic(Errors.COORDINATOR_NOT_AVAILABLE, topic, true, util.Collections.emptyList())\n-        } else {\n-          createTopic(topic, config.transactionTopicPartitions, config.transactionTopicReplicationFactor.toInt,\n-            txnCoordinator.transactionTopicConfigs)\n-        }\n-      case _ => throw new IllegalArgumentException(s\"Unexpected internal topic name: $topic\")\n-    }\n-  }\n-\n-  private def getOrCreateInternalTopic(topic: String, listenerName: ListenerName): MetadataResponseData.MetadataResponseTopic = {\n-    val topicMetadata = metadataCache.getTopicMetadata(Set(topic), listenerName)\n-    topicMetadata.headOption.getOrElse(createInternalTopic(topic))\n-  }\n-\n-  private def getTopicMetadata(allowAutoTopicCreation: Boolean, isFetchAllMetadata: Boolean,\n-                               topics: Set[String], listenerName: ListenerName,\n+  private def getTopicMetadata(isFetchAllMetadata: Boolean,\n+                               topics: Set[String],\n+                               listenerName: ListenerName,\n                                errorUnavailableEndpoints: Boolean,\n-                               errorUnavailableListeners: Boolean): Seq[MetadataResponseTopic] = {\n+                               errorUnavailableListeners: Boolean): (Seq[MetadataResponseTopic], Seq[MetadataResponseTopic]) = {\n     val topicResponses = metadataCache.getTopicMetadata(topics, listenerName,\n         errorUnavailableEndpoints, errorUnavailableListeners)\n \n     if (topics.isEmpty || topicResponses.size == topics.size) {\n-      topicResponses\n+      (topicResponses, Seq.empty[MetadataResponseTopic])\n     } else {\n       val nonExistentTopics = topics.diff(topicResponses.map(_.name).toSet)\n       val responsesForNonExistentTopics = nonExistentTopics.flatMap { topic =>\n-        if (isInternal(topic)) {\n-          val topicMetadata = createInternalTopic(topic)\n-          Some(\n-            if (topicMetadata.errorCode == Errors.COORDINATOR_NOT_AVAILABLE.code)\n-              metadataResponseTopic(Errors.INVALID_REPLICATION_FACTOR, topic, true, util.Collections.emptyList())\n-            else\n-              topicMetadata\n-          )\n-        } else if (isFetchAllMetadata) {\n+       if (isFetchAllMetadata) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA3MzE3MA==", "bodyText": "nit: usually we write as\nnonExistTopicMetadata.foreach { metadata =>", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569073170", "createdAt": "2021-02-03T02:07:38Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1234,19 +1171,28 @@ class KafkaApis(val requestChannel: RequestChannel,\n     // In versions 5 and below, we returned LEADER_NOT_AVAILABLE if a matching listener was not found on the leader.\n     // From version 6 onwards, we return LISTENER_NOT_FOUND to enable diagnosis of configuration errors.\n     val errorUnavailableListeners = requestVersion >= 6\n-    val topicMetadata =\n+    val (topicMetadata, nonExistTopicMetadata) =\n       if (authorizedTopics.isEmpty)\n-        Seq.empty[MetadataResponseTopic]\n-      else {\n-        getTopicMetadata(\n-          metadataRequest.allowAutoTopicCreation,\n-          metadataRequest.isAllTopics,\n-          authorizedTopics,\n-          request.context.listenerName,\n-          errorUnavailableEndpoints,\n-          errorUnavailableListeners\n-        )\n+        (Seq.empty[MetadataResponseTopic], Seq.empty[MetadataResponseTopic])\n+      else\n+        getTopicMetadata(metadataRequest.isAllTopics, authorizedTopics,\n+          request.context.listenerName, errorUnavailableEndpoints, errorUnavailableListeners)\n+\n+    nonExistTopicMetadata.foreach(metadata =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA5MzYzNg==", "bodyText": "I don't think it is equivalent, at least not completely. My thought was to reduce the reliance on the broker's configuration, which is more likely to be stale than the controller. This actually raises an interesting question about the CreateTopic API which I had not thought of before. If we receive a CreateTopic request for an internal topic, which configuration should we use? Currently it looks like we will apply the standard topic defaults, but that does not seem right. I filed https://issues.apache.org/jira/browse/KAFKA-12280, so we can consider this later.", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569093636", "createdAt": "2021-02-03T02:45:46Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1370,55 +1345,164 @@ class KafkaApis(val requestChannel: RequestChannel,\n         !authHelper.authorize(request.context, DESCRIBE, TRANSACTIONAL_ID, findCoordinatorRequest.data.key))\n       requestHelper.sendErrorResponseMaybeThrottle(request, Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED.exception)\n     else {\n-      // get metadata (and create the topic if necessary)\n-      val (partition, topicMetadata) = CoordinatorType.forId(findCoordinatorRequest.data.keyType) match {\n+      val (partition, internalTopicName) = CoordinatorType.forId(findCoordinatorRequest.data.keyType) match {\n         case CoordinatorType.GROUP =>\n-          val partition = groupCoordinator.partitionFor(findCoordinatorRequest.data.key)\n-          val metadata = getOrCreateInternalTopic(GROUP_METADATA_TOPIC_NAME, request.context.listenerName)\n-          (partition, metadata)\n+          (groupCoordinator.partitionFor(findCoordinatorRequest.data.key), GROUP_METADATA_TOPIC_NAME)\n \n         case CoordinatorType.TRANSACTION =>\n-          val partition = txnCoordinator.partitionFor(findCoordinatorRequest.data.key)\n-          val metadata = getOrCreateInternalTopic(TRANSACTION_STATE_TOPIC_NAME, request.context.listenerName)\n-          (partition, metadata)\n+          (txnCoordinator.partitionFor(findCoordinatorRequest.data.key), TRANSACTION_STATE_TOPIC_NAME)\n+      }\n \n-        case _ =>\n-          throw new InvalidRequestException(\"Unknown coordinator type in FindCoordinator request\")\n+      val topicMetadata = metadataCache.getTopicMetadata(Set(internalTopicName), request.context.listenerName)\n+      def createFindCoordinatorResponse(error: Errors,\n+                                        node: Node,\n+                                        requestThrottleMs: Int,\n+                                        errorMessage: Option[String] = None): FindCoordinatorResponse = {\n+        new FindCoordinatorResponse(\n+          new FindCoordinatorResponseData()\n+            .setErrorCode(error.code)\n+            .setErrorMessage(errorMessage.getOrElse(error.message))\n+            .setNodeId(node.id)\n+            .setHost(node.host)\n+            .setPort(node.port)\n+            .setThrottleTimeMs(requestThrottleMs))\n       }\n \n-      def createResponse(requestThrottleMs: Int): AbstractResponse = {\n-        def createFindCoordinatorResponse(error: Errors, node: Node): FindCoordinatorResponse = {\n-          new FindCoordinatorResponse(\n-              new FindCoordinatorResponseData()\n-                .setErrorCode(error.code)\n-                .setErrorMessage(error.message)\n-                .setNodeId(node.id)\n-                .setHost(node.host)\n-                .setPort(node.port)\n-                .setThrottleTimeMs(requestThrottleMs))\n+      val topicCreationNeeded = topicMetadata.headOption.isEmpty\n+      if (topicCreationNeeded) {\n+        if (hasEnoughAliveBrokers(internalTopicName)) {\n+          if (shouldForwardRequest(request)) {\n+            forwardingManager.sendInterBrokerRequest(\n+              getCreateTopicsRequest(Seq(internalTopicName)),\n+              _ => ())\n+          } else {\n+            val controllerMutationQuota = quotas.controllerMutation.newQuotaFor(request, strictSinceVersion = 6)\n+\n+            val topicConfigs = Map(internalTopicName -> getTopicConfigs(internalTopicName))\n+            adminManager.createTopics(\n+              config.requestTimeoutMs,\n+              validateOnly = false,\n+              topicConfigs,\n+              Map.empty,\n+              controllerMutationQuota,\n+              _ => ())\n+          }\n         }\n-        val responseBody = if (topicMetadata.errorCode != Errors.NONE.code) {\n-          createFindCoordinatorResponse(Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode)\n-        } else {\n-          val coordinatorEndpoint = topicMetadata.partitions.asScala\n-            .find(_.partitionIndex == partition)\n-            .filter(_.leaderId != MetadataResponse.NO_LEADER_ID)\n-            .flatMap(metadata => metadataCache.getAliveBroker(metadata.leaderId))\n-            .flatMap(_.getNode(request.context.listenerName))\n-            .filterNot(_.isEmpty)\n-\n-          coordinatorEndpoint match {\n-            case Some(endpoint) =>\n-              createFindCoordinatorResponse(Errors.NONE, endpoint)\n-            case _ =>\n-              createFindCoordinatorResponse(Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode)\n+\n+        requestHelper.sendResponseMaybeThrottle(request, requestThrottleMs => createFindCoordinatorResponse(\n+          Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode, requestThrottleMs))\n+      } else {\n+        def createResponse(requestThrottleMs: Int): AbstractResponse = {\n+          val responseBody = if (topicMetadata.head.errorCode != Errors.NONE.code) {\n+            createFindCoordinatorResponse(Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode, requestThrottleMs)\n+          } else {\n+            val coordinatorEndpoint = topicMetadata.head.partitions.asScala\n+              .find(_.partitionIndex == partition)\n+              .filter(_.leaderId != MetadataResponse.NO_LEADER_ID)\n+              .flatMap(metadata => metadataCache.getAliveBroker(metadata.leaderId))\n+              .flatMap(_.getNode(request.context.listenerName))\n+              .filterNot(_.isEmpty)\n+\n+            coordinatorEndpoint match {\n+              case Some(endpoint) =>\n+                createFindCoordinatorResponse(Errors.NONE, endpoint, requestThrottleMs)\n+              case _ =>\n+                createFindCoordinatorResponse(Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode, requestThrottleMs)\n+            }\n           }\n+          trace(\"Sending FindCoordinator response %s for correlation id %d to client %s.\"\n+            .format(responseBody, request.header.correlationId, request.header.clientId))\n+          responseBody\n         }\n-        trace(\"Sending FindCoordinator response %s for correlation id %d to client %s.\"\n-          .format(responseBody, request.header.correlationId, request.header.clientId))\n-        responseBody\n+\n+        requestHelper.sendResponseMaybeThrottle(request, createResponse)\n+      }\n+    }\n+  }\n+\n+  private def getCreateTopicsRequest(topics: Seq[String]): CreateTopicsRequest.Builder = {\n+    val topicCollection = new CreateTopicsRequestData.CreatableTopicCollection\n+    topics.foreach(topic => {\n+      topicCollection.add(getTopicConfigs(topic))\n+    })\n+\n+    new CreateTopicsRequest.Builder(\n+      new CreateTopicsRequestData()\n+        .setTimeoutMs(config.requestTimeoutMs)\n+        .setTopics(topicCollection)\n+    )\n+  }\n+\n+  private def getTopicConfigs(topic: String): CreatableTopic = {\n+    topic match {\n+      case GROUP_METADATA_TOPIC_NAME =>\n+        new CreatableTopic()\n+          .setName(topic)\n+          .setNumPartitions(config.offsetsTopicPartitions)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTQ1MDU0NQ=="}, "originalCommit": {"oid": "1d626d2bfea3fe6171083404acdaf08ee9779988"}, "originalPosition": 433}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA5NjMwNA==", "bodyText": "Feels to me like we would benefit by moving this logic into AutoTopicCreationManager. The configuration for auto-created topics can always be derived from the broker configuration. Hence we could simplify the interface by letting it take only the topic names. The advantage is that we can move all of this logic out of KafkaApis (which is now up to 3500 LOC).", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569096304", "createdAt": "2021-02-03T02:54:18Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1375,55 +1325,137 @@ class KafkaApis(val requestChannel: RequestChannel,\n         !authHelper.authorize(request.context, DESCRIBE, TRANSACTIONAL_ID, findCoordinatorRequest.data.key))\n       requestHelper.sendErrorResponseMaybeThrottle(request, Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED.exception)\n     else {\n-      // get metadata (and create the topic if necessary)\n-      val (partition, topicMetadata) = CoordinatorType.forId(findCoordinatorRequest.data.keyType) match {\n+      val (partition, internalTopicName) = CoordinatorType.forId(findCoordinatorRequest.data.keyType) match {\n         case CoordinatorType.GROUP =>\n-          val partition = groupCoordinator.partitionFor(findCoordinatorRequest.data.key)\n-          val metadata = getOrCreateInternalTopic(GROUP_METADATA_TOPIC_NAME, request.context.listenerName)\n-          (partition, metadata)\n+          (groupCoordinator.partitionFor(findCoordinatorRequest.data.key), GROUP_METADATA_TOPIC_NAME)\n \n         case CoordinatorType.TRANSACTION =>\n-          val partition = txnCoordinator.partitionFor(findCoordinatorRequest.data.key)\n-          val metadata = getOrCreateInternalTopic(TRANSACTION_STATE_TOPIC_NAME, request.context.listenerName)\n-          (partition, metadata)\n+          (txnCoordinator.partitionFor(findCoordinatorRequest.data.key), TRANSACTION_STATE_TOPIC_NAME)\n+      }\n \n-        case _ =>\n-          throw new InvalidRequestException(\"Unknown coordinator type in FindCoordinator request\")\n+      val topicMetadata = metadataCache.getTopicMetadata(Set(internalTopicName), request.context.listenerName)\n+      def createFindCoordinatorResponse(error: Errors,\n+                                        node: Node,\n+                                        requestThrottleMs: Int,\n+                                        errorMessage: Option[String] = None): FindCoordinatorResponse = {\n+        new FindCoordinatorResponse(\n+          new FindCoordinatorResponseData()\n+            .setErrorCode(error.code)\n+            .setErrorMessage(errorMessage.getOrElse(error.message))\n+            .setNodeId(node.id)\n+            .setHost(node.host)\n+            .setPort(node.port)\n+            .setThrottleTimeMs(requestThrottleMs))\n       }\n \n-      def createResponse(requestThrottleMs: Int): AbstractResponse = {\n-        def createFindCoordinatorResponse(error: Errors, node: Node): FindCoordinatorResponse = {\n-          new FindCoordinatorResponse(\n-              new FindCoordinatorResponseData()\n-                .setErrorCode(error.code)\n-                .setErrorMessage(error.message)\n-                .setNodeId(node.id)\n-                .setHost(node.host)\n-                .setPort(node.port)\n-                .setThrottleTimeMs(requestThrottleMs))\n+      if (topicMetadata.headOption.isEmpty) {\n+        if (hasEnoughAliveBrokers(internalTopicName)) {\n+          val controllerMutationQuota = quotas.controllerMutation.newQuotaFor(request, strictSinceVersion = 6)\n+          autoTopicCreationManager.createTopics(\n+            Seq(getTopicConfigs(internalTopicName)).toSet, controllerMutationQuota)\n         }\n-        val responseBody = if (topicMetadata.errorCode != Errors.NONE.code) {\n-          createFindCoordinatorResponse(Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode)\n-        } else {\n-          val coordinatorEndpoint = topicMetadata.partitions.asScala\n-            .find(_.partitionIndex == partition)\n-            .filter(_.leaderId != MetadataResponse.NO_LEADER_ID)\n-            .flatMap(metadata => metadataCache.getAliveBroker(metadata.leaderId))\n-            .flatMap(_.getNode(request.context.listenerName))\n-            .filterNot(_.isEmpty)\n-\n-          coordinatorEndpoint match {\n-            case Some(endpoint) =>\n-              createFindCoordinatorResponse(Errors.NONE, endpoint)\n-            case _ =>\n-              createFindCoordinatorResponse(Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode)\n+        requestHelper.sendResponseMaybeThrottle(request, requestThrottleMs => createFindCoordinatorResponse(\n+          Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode, requestThrottleMs))\n+      } else {\n+        def createResponse(requestThrottleMs: Int): AbstractResponse = {\n+          val responseBody = if (topicMetadata.head.errorCode != Errors.NONE.code) {\n+            createFindCoordinatorResponse(Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode, requestThrottleMs)\n+          } else {\n+            val coordinatorEndpoint = topicMetadata.head.partitions.asScala\n+              .find(_.partitionIndex == partition)\n+              .filter(_.leaderId != MetadataResponse.NO_LEADER_ID)\n+              .flatMap(metadata => metadataCache.getAliveBroker(metadata.leaderId))\n+              .flatMap(_.getNode(request.context.listenerName))\n+              .filterNot(_.isEmpty)\n+\n+            coordinatorEndpoint match {\n+              case Some(endpoint) =>\n+                createFindCoordinatorResponse(Errors.NONE, endpoint, requestThrottleMs)\n+              case _ =>\n+                createFindCoordinatorResponse(Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode, requestThrottleMs)\n+            }\n           }\n+          trace(\"Sending FindCoordinator response %s for correlation id %d to client %s.\"\n+            .format(responseBody, request.header.correlationId, request.header.clientId))\n+          responseBody\n         }\n-        trace(\"Sending FindCoordinator response %s for correlation id %d to client %s.\"\n-          .format(responseBody, request.header.correlationId, request.header.clientId))\n-        responseBody\n+\n+        requestHelper.sendResponseMaybeThrottle(request, createResponse)\n       }\n-      requestHelper.sendResponseMaybeThrottle(request, createResponse)\n+    }\n+  }\n+\n+  private def getTopicConfigs(topic: String): CreatableTopic = {\n+    topic match {\n+      case GROUP_METADATA_TOPIC_NAME =>\n+        new CreatableTopic()\n+          .setName(topic)\n+          .setNumPartitions(config.offsetsTopicPartitions)\n+          .setReplicationFactor(config.offsetsTopicReplicationFactor)\n+          .setConfigs(convertToTopicConfigCollections(groupCoordinator.offsetsTopicConfigs))\n+      case TRANSACTION_STATE_TOPIC_NAME =>\n+        new CreatableTopic()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228"}, "originalPosition": 400}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEyNTcyMQ==", "bodyText": "The differences between these log lines are minor. Can we factor out a helper?", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569125721", "createdAt": "2021-02-03T04:36:48Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1375,55 +1325,137 @@ class KafkaApis(val requestChannel: RequestChannel,\n         !authHelper.authorize(request.context, DESCRIBE, TRANSACTIONAL_ID, findCoordinatorRequest.data.key))\n       requestHelper.sendErrorResponseMaybeThrottle(request, Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED.exception)\n     else {\n-      // get metadata (and create the topic if necessary)\n-      val (partition, topicMetadata) = CoordinatorType.forId(findCoordinatorRequest.data.keyType) match {\n+      val (partition, internalTopicName) = CoordinatorType.forId(findCoordinatorRequest.data.keyType) match {\n         case CoordinatorType.GROUP =>\n-          val partition = groupCoordinator.partitionFor(findCoordinatorRequest.data.key)\n-          val metadata = getOrCreateInternalTopic(GROUP_METADATA_TOPIC_NAME, request.context.listenerName)\n-          (partition, metadata)\n+          (groupCoordinator.partitionFor(findCoordinatorRequest.data.key), GROUP_METADATA_TOPIC_NAME)\n \n         case CoordinatorType.TRANSACTION =>\n-          val partition = txnCoordinator.partitionFor(findCoordinatorRequest.data.key)\n-          val metadata = getOrCreateInternalTopic(TRANSACTION_STATE_TOPIC_NAME, request.context.listenerName)\n-          (partition, metadata)\n+          (txnCoordinator.partitionFor(findCoordinatorRequest.data.key), TRANSACTION_STATE_TOPIC_NAME)\n+      }\n \n-        case _ =>\n-          throw new InvalidRequestException(\"Unknown coordinator type in FindCoordinator request\")\n+      val topicMetadata = metadataCache.getTopicMetadata(Set(internalTopicName), request.context.listenerName)\n+      def createFindCoordinatorResponse(error: Errors,\n+                                        node: Node,\n+                                        requestThrottleMs: Int,\n+                                        errorMessage: Option[String] = None): FindCoordinatorResponse = {\n+        new FindCoordinatorResponse(\n+          new FindCoordinatorResponseData()\n+            .setErrorCode(error.code)\n+            .setErrorMessage(errorMessage.getOrElse(error.message))\n+            .setNodeId(node.id)\n+            .setHost(node.host)\n+            .setPort(node.port)\n+            .setThrottleTimeMs(requestThrottleMs))\n       }\n \n-      def createResponse(requestThrottleMs: Int): AbstractResponse = {\n-        def createFindCoordinatorResponse(error: Errors, node: Node): FindCoordinatorResponse = {\n-          new FindCoordinatorResponse(\n-              new FindCoordinatorResponseData()\n-                .setErrorCode(error.code)\n-                .setErrorMessage(error.message)\n-                .setNodeId(node.id)\n-                .setHost(node.host)\n-                .setPort(node.port)\n-                .setThrottleTimeMs(requestThrottleMs))\n+      if (topicMetadata.headOption.isEmpty) {\n+        if (hasEnoughAliveBrokers(internalTopicName)) {\n+          val controllerMutationQuota = quotas.controllerMutation.newQuotaFor(request, strictSinceVersion = 6)\n+          autoTopicCreationManager.createTopics(\n+            Seq(getTopicConfigs(internalTopicName)).toSet, controllerMutationQuota)\n         }\n-        val responseBody = if (topicMetadata.errorCode != Errors.NONE.code) {\n-          createFindCoordinatorResponse(Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode)\n-        } else {\n-          val coordinatorEndpoint = topicMetadata.partitions.asScala\n-            .find(_.partitionIndex == partition)\n-            .filter(_.leaderId != MetadataResponse.NO_LEADER_ID)\n-            .flatMap(metadata => metadataCache.getAliveBroker(metadata.leaderId))\n-            .flatMap(_.getNode(request.context.listenerName))\n-            .filterNot(_.isEmpty)\n-\n-          coordinatorEndpoint match {\n-            case Some(endpoint) =>\n-              createFindCoordinatorResponse(Errors.NONE, endpoint)\n-            case _ =>\n-              createFindCoordinatorResponse(Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode)\n+        requestHelper.sendResponseMaybeThrottle(request, requestThrottleMs => createFindCoordinatorResponse(\n+          Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode, requestThrottleMs))\n+      } else {\n+        def createResponse(requestThrottleMs: Int): AbstractResponse = {\n+          val responseBody = if (topicMetadata.head.errorCode != Errors.NONE.code) {\n+            createFindCoordinatorResponse(Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode, requestThrottleMs)\n+          } else {\n+            val coordinatorEndpoint = topicMetadata.head.partitions.asScala\n+              .find(_.partitionIndex == partition)\n+              .filter(_.leaderId != MetadataResponse.NO_LEADER_ID)\n+              .flatMap(metadata => metadataCache.getAliveBroker(metadata.leaderId))\n+              .flatMap(_.getNode(request.context.listenerName))\n+              .filterNot(_.isEmpty)\n+\n+            coordinatorEndpoint match {\n+              case Some(endpoint) =>\n+                createFindCoordinatorResponse(Errors.NONE, endpoint, requestThrottleMs)\n+              case _ =>\n+                createFindCoordinatorResponse(Errors.COORDINATOR_NOT_AVAILABLE, Node.noNode, requestThrottleMs)\n+            }\n           }\n+          trace(\"Sending FindCoordinator response %s for correlation id %d to client %s.\"\n+            .format(responseBody, request.header.correlationId, request.header.clientId))\n+          responseBody\n         }\n-        trace(\"Sending FindCoordinator response %s for correlation id %d to client %s.\"\n-          .format(responseBody, request.header.correlationId, request.header.clientId))\n-        responseBody\n+\n+        requestHelper.sendResponseMaybeThrottle(request, createResponse)\n       }\n-      requestHelper.sendResponseMaybeThrottle(request, createResponse)\n+    }\n+  }\n+\n+  private def getTopicConfigs(topic: String): CreatableTopic = {\n+    topic match {\n+      case GROUP_METADATA_TOPIC_NAME =>\n+        new CreatableTopic()\n+          .setName(topic)\n+          .setNumPartitions(config.offsetsTopicPartitions)\n+          .setReplicationFactor(config.offsetsTopicReplicationFactor)\n+          .setConfigs(convertToTopicConfigCollections(groupCoordinator.offsetsTopicConfigs))\n+      case TRANSACTION_STATE_TOPIC_NAME =>\n+        new CreatableTopic()\n+          .setName(topic)\n+          .setNumPartitions(config.transactionTopicPartitions)\n+          .setReplicationFactor(config.transactionTopicReplicationFactor)\n+          .setConfigs(convertToTopicConfigCollections(\n+            txnCoordinator.transactionTopicConfigs))\n+      case topicName =>\n+        new CreatableTopic()\n+          .setName(topicName)\n+          .setNumPartitions(config.numPartitions)\n+          .setReplicationFactor(config.defaultReplicationFactor.shortValue)\n+    }\n+  }\n+\n+  private def convertToTopicConfigCollections(config: Properties): CreateableTopicConfigCollection = {\n+    val topicConfigs = new CreateableTopicConfigCollection()\n+    config.forEach {\n+      case (name, value) =>\n+        topicConfigs.add(new CreateableTopicConfig()\n+          .setName(name.toString)\n+          .setValue(value.toString))\n+    }\n+    topicConfigs\n+  }\n+\n+  private def hasEnoughAliveBrokers(topic: String): Boolean = {\n+    if (topic == null)\n+      throw new IllegalArgumentException(\"topic must not be null\")\n+\n+    val aliveBrokers = metadataCache.getAliveBrokers\n+\n+    topic match {\n+      case GROUP_METADATA_TOPIC_NAME =>\n+        if (aliveBrokers.size < config.offsetsTopicReplicationFactor) {\n+          error(s\"Number of alive brokers '${aliveBrokers.size}' does not meet the required replication factor \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228"}, "originalPosition": 434}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEyNjg4Mg==", "bodyText": "nit: is error.message actually useful to send back? It doesn't provide any information beyond the error code. Could we just use errorMessage.orNull?", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569126882", "createdAt": "2021-02-03T04:40:34Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1375,55 +1325,137 @@ class KafkaApis(val requestChannel: RequestChannel,\n         !authHelper.authorize(request.context, DESCRIBE, TRANSACTIONAL_ID, findCoordinatorRequest.data.key))\n       requestHelper.sendErrorResponseMaybeThrottle(request, Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED.exception)\n     else {\n-      // get metadata (and create the topic if necessary)\n-      val (partition, topicMetadata) = CoordinatorType.forId(findCoordinatorRequest.data.keyType) match {\n+      val (partition, internalTopicName) = CoordinatorType.forId(findCoordinatorRequest.data.keyType) match {\n         case CoordinatorType.GROUP =>\n-          val partition = groupCoordinator.partitionFor(findCoordinatorRequest.data.key)\n-          val metadata = getOrCreateInternalTopic(GROUP_METADATA_TOPIC_NAME, request.context.listenerName)\n-          (partition, metadata)\n+          (groupCoordinator.partitionFor(findCoordinatorRequest.data.key), GROUP_METADATA_TOPIC_NAME)\n \n         case CoordinatorType.TRANSACTION =>\n-          val partition = txnCoordinator.partitionFor(findCoordinatorRequest.data.key)\n-          val metadata = getOrCreateInternalTopic(TRANSACTION_STATE_TOPIC_NAME, request.context.listenerName)\n-          (partition, metadata)\n+          (txnCoordinator.partitionFor(findCoordinatorRequest.data.key), TRANSACTION_STATE_TOPIC_NAME)\n+      }\n \n-        case _ =>\n-          throw new InvalidRequestException(\"Unknown coordinator type in FindCoordinator request\")\n+      val topicMetadata = metadataCache.getTopicMetadata(Set(internalTopicName), request.context.listenerName)\n+      def createFindCoordinatorResponse(error: Errors,\n+                                        node: Node,\n+                                        requestThrottleMs: Int,\n+                                        errorMessage: Option[String] = None): FindCoordinatorResponse = {\n+        new FindCoordinatorResponse(\n+          new FindCoordinatorResponseData()\n+            .setErrorCode(error.code)\n+            .setErrorMessage(errorMessage.getOrElse(error.message))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228"}, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEyNzMyOA==", "bodyText": "Maybe I'm missing it, but where is this argument used?", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569127328", "createdAt": "2021-02-03T04:42:16Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1375,55 +1325,137 @@ class KafkaApis(val requestChannel: RequestChannel,\n         !authHelper.authorize(request.context, DESCRIBE, TRANSACTIONAL_ID, findCoordinatorRequest.data.key))\n       requestHelper.sendErrorResponseMaybeThrottle(request, Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED.exception)\n     else {\n-      // get metadata (and create the topic if necessary)\n-      val (partition, topicMetadata) = CoordinatorType.forId(findCoordinatorRequest.data.keyType) match {\n+      val (partition, internalTopicName) = CoordinatorType.forId(findCoordinatorRequest.data.keyType) match {\n         case CoordinatorType.GROUP =>\n-          val partition = groupCoordinator.partitionFor(findCoordinatorRequest.data.key)\n-          val metadata = getOrCreateInternalTopic(GROUP_METADATA_TOPIC_NAME, request.context.listenerName)\n-          (partition, metadata)\n+          (groupCoordinator.partitionFor(findCoordinatorRequest.data.key), GROUP_METADATA_TOPIC_NAME)\n \n         case CoordinatorType.TRANSACTION =>\n-          val partition = txnCoordinator.partitionFor(findCoordinatorRequest.data.key)\n-          val metadata = getOrCreateInternalTopic(TRANSACTION_STATE_TOPIC_NAME, request.context.listenerName)\n-          (partition, metadata)\n+          (txnCoordinator.partitionFor(findCoordinatorRequest.data.key), TRANSACTION_STATE_TOPIC_NAME)\n+      }\n \n-        case _ =>\n-          throw new InvalidRequestException(\"Unknown coordinator type in FindCoordinator request\")\n+      val topicMetadata = metadataCache.getTopicMetadata(Set(internalTopicName), request.context.listenerName)\n+      def createFindCoordinatorResponse(error: Errors,\n+                                        node: Node,\n+                                        requestThrottleMs: Int,\n+                                        errorMessage: Option[String] = None): FindCoordinatorResponse = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228"}, "originalPosition": 314}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEyNzU1OA==", "bodyText": "Pre-existing issue. CoordinatorType.forId returns IllegalArgumentException if the key type is unknown. That will get translated to UNKNOWN_SERVER_ERROR. It would be better to return INVALID_REQUEST.", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569127558", "createdAt": "2021-02-03T04:43:21Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1375,55 +1325,137 @@ class KafkaApis(val requestChannel: RequestChannel,\n         !authHelper.authorize(request.context, DESCRIBE, TRANSACTIONAL_ID, findCoordinatorRequest.data.key))\n       requestHelper.sendErrorResponseMaybeThrottle(request, Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED.exception)\n     else {\n-      // get metadata (and create the topic if necessary)\n-      val (partition, topicMetadata) = CoordinatorType.forId(findCoordinatorRequest.data.keyType) match {\n+      val (partition, internalTopicName) = CoordinatorType.forId(findCoordinatorRequest.data.keyType) match {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEzMDA5OA==", "bodyText": "Inside ZkAdminManager.createTopics, I see that we catch TopicExistsException. However, I do not see any logic to translate it to LEADER_NOT_AVAILABLE. Can you show me where this happens?", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569130098", "createdAt": "2021-02-03T04:52:05Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1084,24 +1087,9 @@ class KafkaApis(val requestChannel: RequestChannel,\n     (responseTopics ++ unauthorizedResponseStatus).toList\n   }\n \n-  private def createTopic(topic: String,\n-                          numPartitions: Int,\n-                          replicationFactor: Int,\n-                          properties: util.Properties = new util.Properties()): MetadataResponseTopic = {\n-    try {\n-      adminZkClient.createTopic(topic, numPartitions, replicationFactor, properties, RackAwareMode.Safe)\n-      info(\"Auto creation of topic %s with %d partitions and replication factor %d is successful\"\n-        .format(topic, numPartitions, replicationFactor))\n-      metadataResponseTopic(Errors.LEADER_NOT_AVAILABLE, topic, isInternal(topic), util.Collections.emptyList())\n-    } catch {\n-      case _: TopicExistsException => // let it go, possibly another broker created this topic", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTQ1NTIyMw=="}, "originalCommit": {"oid": "1d626d2bfea3fe6171083404acdaf08ee9779988"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEzMjA4MQ==", "bodyText": "Ok. My thought is to reduce the reliance on the broker metadata. We will need the replication factor check on the controller anyway, so I'm not sure it is worth optimizing for the case when the cluster is initializing.\nPerhaps at least we can move this validation into AutoTopicCreationManager to better encapsulate the logic.", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569132081", "createdAt": "2021-02-03T04:58:55Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1370,55 +1345,164 @@ class KafkaApis(val requestChannel: RequestChannel,\n         !authHelper.authorize(request.context, DESCRIBE, TRANSACTIONAL_ID, findCoordinatorRequest.data.key))\n       requestHelper.sendErrorResponseMaybeThrottle(request, Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED.exception)\n     else {\n-      // get metadata (and create the topic if necessary)\n-      val (partition, topicMetadata) = CoordinatorType.forId(findCoordinatorRequest.data.keyType) match {\n+      val (partition, internalTopicName) = CoordinatorType.forId(findCoordinatorRequest.data.keyType) match {\n         case CoordinatorType.GROUP =>\n-          val partition = groupCoordinator.partitionFor(findCoordinatorRequest.data.key)\n-          val metadata = getOrCreateInternalTopic(GROUP_METADATA_TOPIC_NAME, request.context.listenerName)\n-          (partition, metadata)\n+          (groupCoordinator.partitionFor(findCoordinatorRequest.data.key), GROUP_METADATA_TOPIC_NAME)\n \n         case CoordinatorType.TRANSACTION =>\n-          val partition = txnCoordinator.partitionFor(findCoordinatorRequest.data.key)\n-          val metadata = getOrCreateInternalTopic(TRANSACTION_STATE_TOPIC_NAME, request.context.listenerName)\n-          (partition, metadata)\n+          (txnCoordinator.partitionFor(findCoordinatorRequest.data.key), TRANSACTION_STATE_TOPIC_NAME)\n+      }\n \n-        case _ =>\n-          throw new InvalidRequestException(\"Unknown coordinator type in FindCoordinator request\")\n+      val topicMetadata = metadataCache.getTopicMetadata(Set(internalTopicName), request.context.listenerName)\n+      def createFindCoordinatorResponse(error: Errors,\n+                                        node: Node,\n+                                        requestThrottleMs: Int,\n+                                        errorMessage: Option[String] = None): FindCoordinatorResponse = {\n+        new FindCoordinatorResponse(\n+          new FindCoordinatorResponseData()\n+            .setErrorCode(error.code)\n+            .setErrorMessage(errorMessage.getOrElse(error.message))\n+            .setNodeId(node.id)\n+            .setHost(node.host)\n+            .setPort(node.port)\n+            .setThrottleTimeMs(requestThrottleMs))\n       }\n \n-      def createResponse(requestThrottleMs: Int): AbstractResponse = {\n-        def createFindCoordinatorResponse(error: Errors, node: Node): FindCoordinatorResponse = {\n-          new FindCoordinatorResponse(\n-              new FindCoordinatorResponseData()\n-                .setErrorCode(error.code)\n-                .setErrorMessage(error.message)\n-                .setNodeId(node.id)\n-                .setHost(node.host)\n-                .setPort(node.port)\n-                .setThrottleTimeMs(requestThrottleMs))\n+      val topicCreationNeeded = topicMetadata.headOption.isEmpty\n+      if (topicCreationNeeded) {\n+        if (hasEnoughAliveBrokers(internalTopicName)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTQ1MTYwMg=="}, "originalCommit": {"oid": "1d626d2bfea3fe6171083404acdaf08ee9779988"}, "originalPosition": 347}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEzOTgzMQ==", "bodyText": "Is the idea to validate before sending the CreateTopic? Could we move this to AutoTopicManager?", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569139831", "createdAt": "2021-02-03T05:25:33Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1234,19 +1171,28 @@ class KafkaApis(val requestChannel: RequestChannel,\n     // In versions 5 and below, we returned LEADER_NOT_AVAILABLE if a matching listener was not found on the leader.\n     // From version 6 onwards, we return LISTENER_NOT_FOUND to enable diagnosis of configuration errors.\n     val errorUnavailableListeners = requestVersion >= 6\n-    val topicMetadata =\n+    val (topicMetadata, nonExistTopicMetadata) =\n       if (authorizedTopics.isEmpty)\n-        Seq.empty[MetadataResponseTopic]\n-      else {\n-        getTopicMetadata(\n-          metadataRequest.allowAutoTopicCreation,\n-          metadataRequest.isAllTopics,\n-          authorizedTopics,\n-          request.context.listenerName,\n-          errorUnavailableEndpoints,\n-          errorUnavailableListeners\n-        )\n+        (Seq.empty[MetadataResponseTopic], Seq.empty[MetadataResponseTopic])\n+      else\n+        getTopicMetadata(metadataRequest.isAllTopics, authorizedTopics,\n+          request.context.listenerName, errorUnavailableEndpoints, errorUnavailableListeners)\n+\n+    nonExistTopicMetadata.foreach(metadata =>\n+      try {\n+        // Validate topic name and propagate error if failed\n+        Topic.validate(metadata.name())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE0MDY0NQ==", "bodyText": "Not sure if I am missing something, but doesn't nonExistTopicMetadata include topics which failed the Topic.validate check above?", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569140645", "createdAt": "2021-02-03T05:27:35Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1234,19 +1171,28 @@ class KafkaApis(val requestChannel: RequestChannel,\n     // In versions 5 and below, we returned LEADER_NOT_AVAILABLE if a matching listener was not found on the leader.\n     // From version 6 onwards, we return LISTENER_NOT_FOUND to enable diagnosis of configuration errors.\n     val errorUnavailableListeners = requestVersion >= 6\n-    val topicMetadata =\n+    val (topicMetadata, nonExistTopicMetadata) =\n       if (authorizedTopics.isEmpty)\n-        Seq.empty[MetadataResponseTopic]\n-      else {\n-        getTopicMetadata(\n-          metadataRequest.allowAutoTopicCreation,\n-          metadataRequest.isAllTopics,\n-          authorizedTopics,\n-          request.context.listenerName,\n-          errorUnavailableEndpoints,\n-          errorUnavailableListeners\n-        )\n+        (Seq.empty[MetadataResponseTopic], Seq.empty[MetadataResponseTopic])\n+      else\n+        getTopicMetadata(metadataRequest.isAllTopics, authorizedTopics,\n+          request.context.listenerName, errorUnavailableEndpoints, errorUnavailableListeners)\n+\n+    nonExistTopicMetadata.foreach(metadata =>\n+      try {\n+        // Validate topic name and propagate error if failed\n+        Topic.validate(metadata.name())\n+      } catch {\n+        case e: Exception =>\n+          metadata.setErrorCode(Errors.forException(e).code)\n       }\n+    )\n+\n+    if (nonExistTopicMetadata.nonEmpty && metadataRequest.allowAutoTopicCreation && config.autoCreateTopicsEnable) {\n+      val controllerMutationQuota = quotas.controllerMutation.newQuotaFor(request, strictSinceVersion = 6)\n+      autoTopicCreationManager.createTopics(\n+        nonExistTopicMetadata.map(metadata => getTopicConfigs(metadata.name())).toSet, controllerMutationQuota)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE0NTExNw==", "bodyText": "nit: unnecessary braces", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569145117", "createdAt": "2021-02-03T05:41:49Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AutoTopicCreationManager.scala", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import kafka.controller.KafkaController\n+import kafka.utils.Logging\n+import org.apache.kafka.clients.ClientResponse\n+import org.apache.kafka.common.message.CreateTopicsRequestData\n+import org.apache.kafka.common.message.CreateTopicsRequestData.CreatableTopic\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.requests.CreateTopicsRequest\n+import org.apache.kafka.common.utils.Time\n+\n+import scala.collection.Map\n+\n+trait AutoTopicCreationManager {\n+\n+  def createTopics(\n+    topicNames: Set[CreatableTopic],\n+    controllerMutationQuota: ControllerMutationQuota\n+  ): Unit\n+\n+  def start(): Unit = {}\n+\n+  def shutdown(): Unit = {}\n+}\n+\n+object AutoTopicCreationManager {\n+\n+  def apply(\n+    config: KafkaConfig,\n+    metadataCache: MetadataCache,\n+    time: Time,\n+    metrics: Metrics,\n+    threadNamePrefix: Option[String],\n+    adminManager: ZkAdminManager,\n+    controller: KafkaController,\n+    enableForwarding: Boolean\n+  ): AutoTopicCreationManager = {\n+\n+    val channelManager =\n+      if (enableForwarding)\n+        Some(new BrokerToControllerChannelManager(\n+          controllerNodeProvider = MetadataCacheControllerNodeProvider(\n+            config, metadataCache),\n+          time = time,\n+          metrics = metrics,\n+          config = config,\n+          channelName = \"autoTopicCreationChannel\",\n+          threadNamePrefix = threadNamePrefix,\n+          retryTimeoutMs = config.requestTimeoutMs.longValue\n+        ))\n+      else\n+        None\n+    new AutoTopicCreationManagerImpl(channelManager, adminManager, controller, config.requestTimeoutMs)\n+  }\n+}\n+\n+class AutoTopicCreationManagerImpl(\n+  channelManager: Option[BrokerToControllerChannelManager],\n+  adminManager: ZkAdminManager,\n+  controller: KafkaController,\n+  requestTimeout: Int\n+) extends AutoTopicCreationManager with Logging {\n+\n+  private val inflightTopics = new ConcurrentHashMap[String, CreatableTopic]\n+\n+  override def start(): Unit = {\n+    channelManager.foreach(_.start())\n+  }\n+\n+  override def shutdown(): Unit = {\n+    channelManager.foreach(_.shutdown())\n+  }\n+\n+  override def createTopics(topics: Set[CreatableTopic],\n+                            controllerMutationQuota: ControllerMutationQuota): Unit = {\n+    val topicConfigs = topics\n+      .filter(topic => !inflightTopics.contains(topic.name()))\n+      .map(topic => {(topic.name(), topic)}).toMap", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE0NTIzNw==", "bodyText": "nit: there are a few of these throughout, but the parenthesis are unnecessary", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569145237", "createdAt": "2021-02-03T05:42:13Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AutoTopicCreationManager.scala", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import kafka.controller.KafkaController\n+import kafka.utils.Logging\n+import org.apache.kafka.clients.ClientResponse\n+import org.apache.kafka.common.message.CreateTopicsRequestData\n+import org.apache.kafka.common.message.CreateTopicsRequestData.CreatableTopic\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.requests.CreateTopicsRequest\n+import org.apache.kafka.common.utils.Time\n+\n+import scala.collection.Map\n+\n+trait AutoTopicCreationManager {\n+\n+  def createTopics(\n+    topicNames: Set[CreatableTopic],\n+    controllerMutationQuota: ControllerMutationQuota\n+  ): Unit\n+\n+  def start(): Unit = {}\n+\n+  def shutdown(): Unit = {}\n+}\n+\n+object AutoTopicCreationManager {\n+\n+  def apply(\n+    config: KafkaConfig,\n+    metadataCache: MetadataCache,\n+    time: Time,\n+    metrics: Metrics,\n+    threadNamePrefix: Option[String],\n+    adminManager: ZkAdminManager,\n+    controller: KafkaController,\n+    enableForwarding: Boolean\n+  ): AutoTopicCreationManager = {\n+\n+    val channelManager =\n+      if (enableForwarding)\n+        Some(new BrokerToControllerChannelManager(\n+          controllerNodeProvider = MetadataCacheControllerNodeProvider(\n+            config, metadataCache),\n+          time = time,\n+          metrics = metrics,\n+          config = config,\n+          channelName = \"autoTopicCreationChannel\",\n+          threadNamePrefix = threadNamePrefix,\n+          retryTimeoutMs = config.requestTimeoutMs.longValue\n+        ))\n+      else\n+        None\n+    new AutoTopicCreationManagerImpl(channelManager, adminManager, controller, config.requestTimeoutMs)\n+  }\n+}\n+\n+class AutoTopicCreationManagerImpl(\n+  channelManager: Option[BrokerToControllerChannelManager],\n+  adminManager: ZkAdminManager,\n+  controller: KafkaController,\n+  requestTimeout: Int\n+) extends AutoTopicCreationManager with Logging {\n+\n+  private val inflightTopics = new ConcurrentHashMap[String, CreatableTopic]\n+\n+  override def start(): Unit = {\n+    channelManager.foreach(_.start())\n+  }\n+\n+  override def shutdown(): Unit = {\n+    channelManager.foreach(_.shutdown())\n+  }\n+\n+  override def createTopics(topics: Set[CreatableTopic],\n+                            controllerMutationQuota: ControllerMutationQuota): Unit = {\n+    val topicConfigs = topics\n+      .filter(topic => !inflightTopics.contains(topic.name()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE0NjA1OA==", "bodyText": "We only get this message if all of the topics are already inflight. Perhaps it is still useful if only some of them are inflight?", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569146058", "createdAt": "2021-02-03T05:44:56Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AutoTopicCreationManager.scala", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import kafka.controller.KafkaController\n+import kafka.utils.Logging\n+import org.apache.kafka.clients.ClientResponse\n+import org.apache.kafka.common.message.CreateTopicsRequestData\n+import org.apache.kafka.common.message.CreateTopicsRequestData.CreatableTopic\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.requests.CreateTopicsRequest\n+import org.apache.kafka.common.utils.Time\n+\n+import scala.collection.Map\n+\n+trait AutoTopicCreationManager {\n+\n+  def createTopics(\n+    topicNames: Set[CreatableTopic],\n+    controllerMutationQuota: ControllerMutationQuota\n+  ): Unit\n+\n+  def start(): Unit = {}\n+\n+  def shutdown(): Unit = {}\n+}\n+\n+object AutoTopicCreationManager {\n+\n+  def apply(\n+    config: KafkaConfig,\n+    metadataCache: MetadataCache,\n+    time: Time,\n+    metrics: Metrics,\n+    threadNamePrefix: Option[String],\n+    adminManager: ZkAdminManager,\n+    controller: KafkaController,\n+    enableForwarding: Boolean\n+  ): AutoTopicCreationManager = {\n+\n+    val channelManager =\n+      if (enableForwarding)\n+        Some(new BrokerToControllerChannelManager(\n+          controllerNodeProvider = MetadataCacheControllerNodeProvider(\n+            config, metadataCache),\n+          time = time,\n+          metrics = metrics,\n+          config = config,\n+          channelName = \"autoTopicCreationChannel\",\n+          threadNamePrefix = threadNamePrefix,\n+          retryTimeoutMs = config.requestTimeoutMs.longValue\n+        ))\n+      else\n+        None\n+    new AutoTopicCreationManagerImpl(channelManager, adminManager, controller, config.requestTimeoutMs)\n+  }\n+}\n+\n+class AutoTopicCreationManagerImpl(\n+  channelManager: Option[BrokerToControllerChannelManager],\n+  adminManager: ZkAdminManager,\n+  controller: KafkaController,\n+  requestTimeout: Int\n+) extends AutoTopicCreationManager with Logging {\n+\n+  private val inflightTopics = new ConcurrentHashMap[String, CreatableTopic]\n+\n+  override def start(): Unit = {\n+    channelManager.foreach(_.start())\n+  }\n+\n+  override def shutdown(): Unit = {\n+    channelManager.foreach(_.shutdown())\n+  }\n+\n+  override def createTopics(topics: Set[CreatableTopic],\n+                            controllerMutationQuota: ControllerMutationQuota): Unit = {\n+    val topicConfigs = topics\n+      .filter(topic => !inflightTopics.contains(topic.name()))\n+      .map(topic => {(topic.name(), topic)}).toMap\n+\n+    if (topicConfigs.nonEmpty) {\n+      if (!controller.isActive && channelManager.isDefined) {\n+        // Mark the topics as inflight during auto creation through forwarding.\n+        topicConfigs.foreach(config => inflightTopics.put(config._1, config._2))\n+\n+        val topicsToCreate = new CreateTopicsRequestData.CreatableTopicCollection\n+        topicConfigs.foreach(config => topicsToCreate.add(config._2))\n+        val createTopicsRequest = new CreateTopicsRequest.Builder(\n+          new CreateTopicsRequestData()\n+            .setTimeoutMs(requestTimeout)\n+            .setTopics(topicsToCreate)\n+        )\n+\n+        channelManager.get.sendRequest(createTopicsRequest, new ControllerRequestCompletionHandler {\n+          override def onTimeout(): Unit = {\n+            clearInflightRequests(topicConfigs)\n+          }\n+\n+          override def onComplete(response: ClientResponse): Unit = {\n+            clearInflightRequests(topicConfigs)\n+          }\n+        })\n+      } else {\n+        adminManager.createTopics(\n+          requestTimeout,\n+          validateOnly = false,\n+          topicConfigs,\n+          Map.empty,\n+          controllerMutationQuota,\n+          _ => ())\n+      }\n+    } else {\n+      debug(s\"Topics $topics are under creation already, skip sending additional \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE0NjgzOQ==", "bodyText": "Eventually we need to figure out quota behavior for forwarded requests. I am wondering if it makes sense to apply the quota on each broker separately before sending the CreateTopic to the controller or if we rely on the controller exclusively.\ncc @dajac", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569146839", "createdAt": "2021-02-03T05:47:23Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AutoTopicCreationManager.scala", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import kafka.controller.KafkaController\n+import kafka.utils.Logging\n+import org.apache.kafka.clients.ClientResponse\n+import org.apache.kafka.common.message.CreateTopicsRequestData\n+import org.apache.kafka.common.message.CreateTopicsRequestData.CreatableTopic\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.requests.CreateTopicsRequest\n+import org.apache.kafka.common.utils.Time\n+\n+import scala.collection.Map\n+\n+trait AutoTopicCreationManager {\n+\n+  def createTopics(\n+    topicNames: Set[CreatableTopic],\n+    controllerMutationQuota: ControllerMutationQuota\n+  ): Unit\n+\n+  def start(): Unit = {}\n+\n+  def shutdown(): Unit = {}\n+}\n+\n+object AutoTopicCreationManager {\n+\n+  def apply(\n+    config: KafkaConfig,\n+    metadataCache: MetadataCache,\n+    time: Time,\n+    metrics: Metrics,\n+    threadNamePrefix: Option[String],\n+    adminManager: ZkAdminManager,\n+    controller: KafkaController,\n+    enableForwarding: Boolean\n+  ): AutoTopicCreationManager = {\n+\n+    val channelManager =\n+      if (enableForwarding)\n+        Some(new BrokerToControllerChannelManager(\n+          controllerNodeProvider = MetadataCacheControllerNodeProvider(\n+            config, metadataCache),\n+          time = time,\n+          metrics = metrics,\n+          config = config,\n+          channelName = \"autoTopicCreationChannel\",\n+          threadNamePrefix = threadNamePrefix,\n+          retryTimeoutMs = config.requestTimeoutMs.longValue\n+        ))\n+      else\n+        None\n+    new AutoTopicCreationManagerImpl(channelManager, adminManager, controller, config.requestTimeoutMs)\n+  }\n+}\n+\n+class AutoTopicCreationManagerImpl(\n+  channelManager: Option[BrokerToControllerChannelManager],\n+  adminManager: ZkAdminManager,\n+  controller: KafkaController,\n+  requestTimeout: Int\n+) extends AutoTopicCreationManager with Logging {\n+\n+  private val inflightTopics = new ConcurrentHashMap[String, CreatableTopic]\n+\n+  override def start(): Unit = {\n+    channelManager.foreach(_.start())\n+  }\n+\n+  override def shutdown(): Unit = {\n+    channelManager.foreach(_.shutdown())\n+  }\n+\n+  override def createTopics(topics: Set[CreatableTopic],\n+                            controllerMutationQuota: ControllerMutationQuota): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE0NzExOQ==", "bodyText": "Could this be a set? As far as I can tell, we do not rely on the value.", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569147119", "createdAt": "2021-02-03T05:48:10Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AutoTopicCreationManager.scala", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import kafka.controller.KafkaController\n+import kafka.utils.Logging\n+import org.apache.kafka.clients.ClientResponse\n+import org.apache.kafka.common.message.CreateTopicsRequestData\n+import org.apache.kafka.common.message.CreateTopicsRequestData.CreatableTopic\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.requests.CreateTopicsRequest\n+import org.apache.kafka.common.utils.Time\n+\n+import scala.collection.Map\n+\n+trait AutoTopicCreationManager {\n+\n+  def createTopics(\n+    topicNames: Set[CreatableTopic],\n+    controllerMutationQuota: ControllerMutationQuota\n+  ): Unit\n+\n+  def start(): Unit = {}\n+\n+  def shutdown(): Unit = {}\n+}\n+\n+object AutoTopicCreationManager {\n+\n+  def apply(\n+    config: KafkaConfig,\n+    metadataCache: MetadataCache,\n+    time: Time,\n+    metrics: Metrics,\n+    threadNamePrefix: Option[String],\n+    adminManager: ZkAdminManager,\n+    controller: KafkaController,\n+    enableForwarding: Boolean\n+  ): AutoTopicCreationManager = {\n+\n+    val channelManager =\n+      if (enableForwarding)\n+        Some(new BrokerToControllerChannelManager(\n+          controllerNodeProvider = MetadataCacheControllerNodeProvider(\n+            config, metadataCache),\n+          time = time,\n+          metrics = metrics,\n+          config = config,\n+          channelName = \"autoTopicCreationChannel\",\n+          threadNamePrefix = threadNamePrefix,\n+          retryTimeoutMs = config.requestTimeoutMs.longValue\n+        ))\n+      else\n+        None\n+    new AutoTopicCreationManagerImpl(channelManager, adminManager, controller, config.requestTimeoutMs)\n+  }\n+}\n+\n+class AutoTopicCreationManagerImpl(\n+  channelManager: Option[BrokerToControllerChannelManager],\n+  adminManager: ZkAdminManager,\n+  controller: KafkaController,\n+  requestTimeout: Int\n+) extends AutoTopicCreationManager with Logging {\n+\n+  private val inflightTopics = new ConcurrentHashMap[String, CreatableTopic]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE0ODU3Ng==", "bodyText": "nit: requestTimeoutMs?", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569148576", "createdAt": "2021-02-03T05:53:09Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AutoTopicCreationManager.scala", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import kafka.controller.KafkaController\n+import kafka.utils.Logging\n+import org.apache.kafka.clients.ClientResponse\n+import org.apache.kafka.common.message.CreateTopicsRequestData\n+import org.apache.kafka.common.message.CreateTopicsRequestData.CreatableTopic\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.requests.CreateTopicsRequest\n+import org.apache.kafka.common.utils.Time\n+\n+import scala.collection.Map\n+\n+trait AutoTopicCreationManager {\n+\n+  def createTopics(\n+    topicNames: Set[CreatableTopic],\n+    controllerMutationQuota: ControllerMutationQuota\n+  ): Unit\n+\n+  def start(): Unit = {}\n+\n+  def shutdown(): Unit = {}\n+}\n+\n+object AutoTopicCreationManager {\n+\n+  def apply(\n+    config: KafkaConfig,\n+    metadataCache: MetadataCache,\n+    time: Time,\n+    metrics: Metrics,\n+    threadNamePrefix: Option[String],\n+    adminManager: ZkAdminManager,\n+    controller: KafkaController,\n+    enableForwarding: Boolean\n+  ): AutoTopicCreationManager = {\n+\n+    val channelManager =\n+      if (enableForwarding)\n+        Some(new BrokerToControllerChannelManager(\n+          controllerNodeProvider = MetadataCacheControllerNodeProvider(\n+            config, metadataCache),\n+          time = time,\n+          metrics = metrics,\n+          config = config,\n+          channelName = \"autoTopicCreationChannel\",\n+          threadNamePrefix = threadNamePrefix,\n+          retryTimeoutMs = config.requestTimeoutMs.longValue\n+        ))\n+      else\n+        None\n+    new AutoTopicCreationManagerImpl(channelManager, adminManager, controller, config.requestTimeoutMs)\n+  }\n+}\n+\n+class AutoTopicCreationManagerImpl(\n+  channelManager: Option[BrokerToControllerChannelManager],\n+  adminManager: ZkAdminManager,\n+  controller: KafkaController,\n+  requestTimeout: Int", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTE0OTI2Mw==", "bodyText": "Probably useful to have some logging when we send the CreateTopic request and in the callbacks.", "url": "https://github.com/apache/kafka/pull/9579#discussion_r569149263", "createdAt": "2021-02-03T05:55:29Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AutoTopicCreationManager.scala", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.util.concurrent.ConcurrentHashMap\n+\n+import kafka.controller.KafkaController\n+import kafka.utils.Logging\n+import org.apache.kafka.clients.ClientResponse\n+import org.apache.kafka.common.message.CreateTopicsRequestData\n+import org.apache.kafka.common.message.CreateTopicsRequestData.CreatableTopic\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.requests.CreateTopicsRequest\n+import org.apache.kafka.common.utils.Time\n+\n+import scala.collection.Map\n+\n+trait AutoTopicCreationManager {\n+\n+  def createTopics(\n+    topicNames: Set[CreatableTopic],\n+    controllerMutationQuota: ControllerMutationQuota\n+  ): Unit\n+\n+  def start(): Unit = {}\n+\n+  def shutdown(): Unit = {}\n+}\n+\n+object AutoTopicCreationManager {\n+\n+  def apply(\n+    config: KafkaConfig,\n+    metadataCache: MetadataCache,\n+    time: Time,\n+    metrics: Metrics,\n+    threadNamePrefix: Option[String],\n+    adminManager: ZkAdminManager,\n+    controller: KafkaController,\n+    enableForwarding: Boolean\n+  ): AutoTopicCreationManager = {\n+\n+    val channelManager =\n+      if (enableForwarding)\n+        Some(new BrokerToControllerChannelManager(\n+          controllerNodeProvider = MetadataCacheControllerNodeProvider(\n+            config, metadataCache),\n+          time = time,\n+          metrics = metrics,\n+          config = config,\n+          channelName = \"autoTopicCreationChannel\",\n+          threadNamePrefix = threadNamePrefix,\n+          retryTimeoutMs = config.requestTimeoutMs.longValue\n+        ))\n+      else\n+        None\n+    new AutoTopicCreationManagerImpl(channelManager, adminManager, controller, config.requestTimeoutMs)\n+  }\n+}\n+\n+class AutoTopicCreationManagerImpl(\n+  channelManager: Option[BrokerToControllerChannelManager],\n+  adminManager: ZkAdminManager,\n+  controller: KafkaController,\n+  requestTimeout: Int\n+) extends AutoTopicCreationManager with Logging {\n+\n+  private val inflightTopics = new ConcurrentHashMap[String, CreatableTopic]\n+\n+  override def start(): Unit = {\n+    channelManager.foreach(_.start())\n+  }\n+\n+  override def shutdown(): Unit = {\n+    channelManager.foreach(_.shutdown())\n+  }\n+\n+  override def createTopics(topics: Set[CreatableTopic],\n+                            controllerMutationQuota: ControllerMutationQuota): Unit = {\n+    val topicConfigs = topics\n+      .filter(topic => !inflightTopics.contains(topic.name()))\n+      .map(topic => {(topic.name(), topic)}).toMap\n+\n+    if (topicConfigs.nonEmpty) {\n+      if (!controller.isActive && channelManager.isDefined) {\n+        // Mark the topics as inflight during auto creation through forwarding.\n+        topicConfigs.foreach(config => inflightTopics.put(config._1, config._2))\n+\n+        val topicsToCreate = new CreateTopicsRequestData.CreatableTopicCollection\n+        topicConfigs.foreach(config => topicsToCreate.add(config._2))\n+        val createTopicsRequest = new CreateTopicsRequest.Builder(\n+          new CreateTopicsRequestData()\n+            .setTimeoutMs(requestTimeout)\n+            .setTopics(topicsToCreate)\n+        )\n+\n+        channelManager.get.sendRequest(createTopicsRequest, new ControllerRequestCompletionHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2848e8d7e72e3857f6e8422820f9c5ad13621228"}, "originalPosition": 112}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dce308a42a8aef5f4b91c2eef5890aed5db27e01", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/dce308a42a8aef5f4b91c2eef5890aed5db27e01", "committedDate": "2021-02-05T01:15:45Z", "message": "address comments"}, "afterCommit": {"oid": "2fc0011a1fdd65fd5e5f042228758495d0a9a3d8", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/2fc0011a1fdd65fd5e5f042228758495d0a9a3d8", "committedDate": "2021-02-05T01:45:52Z", "message": "forward FindCoordinator/Metadata request when topic creation is needed\n\nalways define auto topic creation manager"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2fc0011a1fdd65fd5e5f042228758495d0a9a3d8", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/2fc0011a1fdd65fd5e5f042228758495d0a9a3d8", "committedDate": "2021-02-05T01:45:52Z", "message": "forward FindCoordinator/Metadata request when topic creation is needed\n\nalways define auto topic creation manager"}, "afterCommit": {"oid": "c68c7d02b3a360b0f29722a4db2fbcfbf0a53b0d", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/c68c7d02b3a360b0f29722a4db2fbcfbf0a53b0d", "committedDate": "2021-02-05T01:49:41Z", "message": "forward FindCoordinator/Metadata request when topic creation is needed\n\nalways define auto topic creation manager"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c68c7d02b3a360b0f29722a4db2fbcfbf0a53b0d", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/c68c7d02b3a360b0f29722a4db2fbcfbf0a53b0d", "committedDate": "2021-02-05T01:49:41Z", "message": "forward FindCoordinator/Metadata request when topic creation is needed\n\nalways define auto topic creation manager"}, "afterCommit": {"oid": "85ea8979fab9d9556b92f8124114446bb553c5e0", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/85ea8979fab9d9556b92f8124114446bb553c5e0", "committedDate": "2021-02-06T00:10:19Z", "message": "forward FindCoordinator/Metadata request when topic creation is needed\n\nalways define auto topic creation manager"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "85ea8979fab9d9556b92f8124114446bb553c5e0", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/85ea8979fab9d9556b92f8124114446bb553c5e0", "committedDate": "2021-02-06T00:10:19Z", "message": "forward FindCoordinator/Metadata request when topic creation is needed\n\nalways define auto topic creation manager"}, "afterCommit": {"oid": "c68c7d02b3a360b0f29722a4db2fbcfbf0a53b0d", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/c68c7d02b3a360b0f29722a4db2fbcfbf0a53b0d", "committedDate": "2021-02-05T01:49:41Z", "message": "forward FindCoordinator/Metadata request when topic creation is needed\n\nalways define auto topic creation manager"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7e745dadbe5d07b2fbb4f9b4371d5e4533705eb3", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/7e745dadbe5d07b2fbb4f9b4371d5e4533705eb3", "committedDate": "2021-02-06T00:32:17Z", "message": "Merge pull request #6 from hachikuji/KAFKA-9751\n\nFix a few lingering problems"}, "afterCommit": {"oid": "15596477577f07d55175ec81c3bf55270b81352f", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/15596477577f07d55175ec81c3bf55270b81352f", "committedDate": "2021-02-06T01:35:21Z", "message": "test fix and logical fix after rebase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ef0b5a3312af543480661971473ba106547eed2", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/8ef0b5a3312af543480661971473ba106547eed2", "committedDate": "2021-02-06T01:46:19Z", "message": "forward FindCoordinator/Metadata request when topic creation is needed\n\nalways define auto topic creation manager"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb919e956caea27a388ae78656cfbbbdeac05409", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/cb919e956caea27a388ae78656cfbbbdeac05409", "committedDate": "2021-02-06T01:46:19Z", "message": "Fix a few lingering problems"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bdba7efb738fc3042d9586ddb3e6bff275f2422", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/3bdba7efb738fc3042d9586ddb3e6bff275f2422", "committedDate": "2021-02-06T01:46:19Z", "message": "Still need to do topic validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a2df64c9f2e5ff1e322105b3254e87f79bc4baf", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/6a2df64c9f2e5ff1e322105b3254e87f79bc4baf", "committedDate": "2021-02-06T01:46:19Z", "message": "CreatTopics request test should not allow auto-creation during validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "878a4ee93028e833fdacd35cf847ef3a804b8063", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/878a4ee93028e833fdacd35cf847ef3a804b8063", "committedDate": "2021-02-06T01:49:30Z", "message": "test fix and logical fix after rebase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abf30d8746390a54a3752af21032afd7e47b1dc1", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/abf30d8746390a54a3752af21032afd7e47b1dc1", "committedDate": "2021-02-06T02:26:03Z", "message": "add topic validation"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "15596477577f07d55175ec81c3bf55270b81352f", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/15596477577f07d55175ec81c3bf55270b81352f", "committedDate": "2021-02-06T01:35:21Z", "message": "test fix and logical fix after rebase"}, "afterCommit": {"oid": "abf30d8746390a54a3752af21032afd7e47b1dc1", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/abf30d8746390a54a3752af21032afd7e47b1dc1", "committedDate": "2021-02-06T02:26:03Z", "message": "add topic validation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg0ODEyNTU2", "url": "https://github.com/apache/kafka/pull/9579#pullrequestreview-584812556", "createdAt": "2021-02-06T02:35:21Z", "commit": {"oid": "abf30d8746390a54a3752af21032afd7e47b1dc1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "829cec76398e3d560bc02b63db75f81b6ad3a3c3", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/829cec76398e3d560bc02b63db75f81b6ad3a3c3", "committedDate": "2021-02-06T02:43:03Z", "message": "fix scala 2.12 missing API"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65310eb9d9c5cfa7fdd4e51c8c64965a20f78ddb", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/65310eb9d9c5cfa7fdd4e51c8c64965a20f78ddb", "committedDate": "2021-02-06T04:37:46Z", "message": "Revert \"KAFKA-9274: handle TimeoutException on task reset (#10000)\"\n\nThis reverts commit 0bc394cc1d19f1e41dd6646e9ac0e09b91fb1398."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0dedb3d3a9b2c5c13ef7cc1a5800439810d309f", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/e0dedb3d3a9b2c5c13ef7cc1a5800439810d309f", "committedDate": "2021-02-06T05:14:39Z", "message": "clear inflight requests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg0ODI1Njcy", "url": "https://github.com/apache/kafka/pull/9579#pullrequestreview-584825672", "createdAt": "2021-02-06T05:35:10Z", "commit": {"oid": "e0dedb3d3a9b2c5c13ef7cc1a5800439810d309f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNlQwNTozNToxMFrOIg5ObA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNlQwNTozNToxMFrOIg5ObA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTM2MjkyNA==", "bodyText": "Can you use a try/finally here?", "url": "https://github.com/apache/kafka/pull/9579#discussion_r571362924", "createdAt": "2021-02-06T05:35:10Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AutoTopicCreationManager.scala", "diffHunk": "@@ -169,6 +169,8 @@ class DefaultAutoTopicCreationManager(\n         }\n     }\n \n+    clearInflightRequests(creatableTopics)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0dedb3d3a9b2c5c13ef7cc1a5800439810d309f"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0796658d5a9408bcbe3467d3fa27dbb292fd22b1", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/0796658d5a9408bcbe3467d3fa27dbb292fd22b1", "committedDate": "2021-02-06T06:21:19Z", "message": "try finally for clear topics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92e5cda9dc9168e0717b7c016a954863c4edd7af", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/92e5cda9dc9168e0717b7c016a954863c4edd7af", "committedDate": "2021-02-06T08:33:23Z", "message": "fix seq ordering for scala 2.12"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d21fc4693b289caeb92dbcfcb9d19d8455d7c0e", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/1d21fc4693b289caeb92dbcfcb9d19d8455d7c0e", "committedDate": "2021-02-06T18:03:53Z", "message": "rewrite testAutoCreateOfCollidingTopics to not depend on ordering"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2743, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}