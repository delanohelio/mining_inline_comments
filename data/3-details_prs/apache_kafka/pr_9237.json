{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc2OTUzMzk1", "number": 9237, "title": "KAFKA-10454 / Update copartitionSourceGroups when optimization algorithm is triggered", "bodyText": "Fix KAFKA-10454 bug\nMain issue was that when optimization algorithm was removing repartition nodes, corresponding copartitionSourceGroups was never updated. As a result, copartition enforcer wasn't able to do the checks and set proper number of partitions.\nTest ensures that whenever optimization is set, changelog topic for the table is not created. And whenever optimization is turned off, appropriate changelog topic for the table is created.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-09-01T09:37:59Z", "url": "https://github.com/apache/kafka/pull/9237", "merged": true, "mergeCommit": {"oid": "d87cd00f5acc3d48181b4b9f084bbc638184c903"}, "closed": true, "closedAt": "2020-10-20T22:39:37Z", "author": {"login": "lkokhreidze"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdEkG8dAH2gAyNDc2OTUzMzk1OjdhMjNjNjkyMmFkNmYxNjIzYzhhMDRkZGRlOTljMGFlMTg2MmY1Mjc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdUgf89gFqTUxMzE4MDc2Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "7a23c6922ad6f1623c8a04ddde99c0ae1862f527", "author": {"user": {"login": "lkokhreidze", "name": "Levani Kokhreidze"}}, "url": "https://github.com/apache/kafka/commit/7a23c6922ad6f1623c8a04ddde99c0ae1862f527", "committedDate": "2020-09-01T09:37:06Z", "message": "KAFKA-10454 / integration test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f0ce0198458fa0bbf74c64c2020151acfa98447", "author": {"user": {"login": "lkokhreidze", "name": "Levani Kokhreidze"}}, "url": "https://github.com/apache/kafka/commit/6f0ce0198458fa0bbf74c64c2020151acfa98447", "committedDate": "2020-09-09T19:46:39Z", "message": "KAFKA-10454 / Fix copartition sources when topology optimization is triggered"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec84a86fce571219696a2351724bc652c4db7311", "author": {"user": {"login": "lkokhreidze", "name": "Levani Kokhreidze"}}, "url": "https://github.com/apache/kafka/commit/ec84a86fce571219696a2351724bc652c4db7311", "committedDate": "2020-09-09T19:50:01Z", "message": "KAFKA-10454 / revert some changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac26e58942ddeeed9e66fea3c7b5b53bb6aab143", "author": {"user": {"login": "lkokhreidze", "name": "Levani Kokhreidze"}}, "url": "https://github.com/apache/kafka/commit/ac26e58942ddeeed9e66fea3c7b5b53bb6aab143", "committedDate": "2020-09-09T19:51:14Z", "message": "KAFKA-10454 / remove extra line"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e61f2eaba369bcc1b4da8991b5ce22c45fba16fb", "author": {"user": {"login": "lkokhreidze", "name": "Levani Kokhreidze"}}, "url": "https://github.com/apache/kafka/commit/e61f2eaba369bcc1b4da8991b5ce22c45fba16fb", "committedDate": "2020-09-09T19:58:13Z", "message": "KAFKA-10454 / fix checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MzU5ODMy", "url": "https://github.com/apache/kafka/pull/9237#pullrequestreview-485359832", "createdAt": "2020-09-09T19:58:54Z", "commit": {"oid": "ac26e58942ddeeed9e66fea3c7b5b53bb6aab143"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxOTo1ODo1NFrOHPYHyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxOTo1ODo1NFrOHPYHyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg4NTg5OA==", "bodyText": "I'm not really sure what the threading model is when building the topology, but chose to be safe and made all the accessors synchronized.", "url": "https://github.com/apache/kafka/pull/9237#discussion_r485885898", "createdAt": "2020-09-09T19:58:54Z", "author": {"login": "lkokhreidze"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopologyBuilder.java", "diffHunk": "@@ -632,8 +632,18 @@ public final void addInternalTopic(final String topicName,\n         internalTopicNamesWithProperties.put(topicName, internalTopicProperties);\n     }\n \n-    public final void copartitionSources(final Collection<String> sourceNodes) {\n-        copartitionSourceGroups.add(Collections.unmodifiableSet(new HashSet<>(sourceNodes)));\n+    public final synchronized void copartitionSources(final Collection<String> sourceNodes) {\n+        copartitionSourceGroups.add(new HashSet<>(sourceNodes));\n+    }\n+\n+    public final synchronized void maybeUpdateCopartitionSourceGroups(final String replacedNodeName,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac26e58942ddeeed9e66fea3c7b5b53bb6aab143"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MzYwMjUy", "url": "https://github.com/apache/kafka/pull/9237#pullrequestreview-485360252", "createdAt": "2020-09-09T19:59:37Z", "commit": {"oid": "ac26e58942ddeeed9e66fea3c7b5b53bb6aab143"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxOTo1OTozOFrOHPYJ1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxOTo1OTozOFrOHPYJ1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg4NjQyMw==", "bodyText": "There's already another StreamTableIntegrationTest present, but it works with TopologyTestDriver so I thought it would be better and easier to keep them separate.", "url": "https://github.com/apache/kafka/pull/9237#discussion_r485886423", "createdAt": "2020-09-09T19:59:38Z", "author": {"login": "lkokhreidze"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/StreamTableJoinTopologyOptimizationIntegrationTest.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package org.apache.kafka.streams.integration;\n+\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.admin.AdminClientConfig;\n+import org.apache.kafka.clients.admin.TopicDescription;\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.common.serialization.Deserializer;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.LongDeserializer;\n+import org.apache.kafka.common.serialization.LongSerializer;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.integration.utils.EmbeddedKafkaCluster;\n+import org.apache.kafka.streams.integration.utils.IntegrationTestUtils;\n+import org.apache.kafka.streams.kstream.KStream;\n+import org.apache.kafka.streams.kstream.KTable;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.kstream.Named;\n+import org.apache.kafka.test.IntegrationTest;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.kafka.streams.integration.utils.IntegrationTestUtils.safeUniqueTestName;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(value = Parameterized.class)\n+@Category({IntegrationTest.class})\n+public class StreamTableJoinTopologyOptimizationIntegrationTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac26e58942ddeeed9e66fea3c7b5b53bb6aab143"}, "originalPosition": 54}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "203cbc6f60926e3e169c2c81defb681ca2c49f1e", "author": {"user": {"login": "lkokhreidze", "name": "Levani Kokhreidze"}}, "url": "https://github.com/apache/kafka/commit/203cbc6f60926e3e169c2c81defb681ca2c49f1e", "committedDate": "2020-09-09T20:04:41Z", "message": "KAFKA-10454 / fix test checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ab1e18e5d0a57206ef3fbbcbc376aca0103eebe", "author": {"user": {"login": "lkokhreidze", "name": "Levani Kokhreidze"}}, "url": "https://github.com/apache/kafka/commit/3ab1e18e5d0a57206ef3fbbcbc376aca0103eebe", "committedDate": "2020-09-09T20:27:50Z", "message": "KAFKA-10454 / make validateCopartition synchronized"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3365f2c046a839101288a0e56be2f73423bf6b4", "author": {"user": {"login": "lkokhreidze", "name": "Levani Kokhreidze"}}, "url": "https://github.com/apache/kafka/commit/b3365f2c046a839101288a0e56be2f73423bf6b4", "committedDate": "2020-09-14T10:26:29Z", "message": "Merge branch 'trunk' into KAFKA-10454"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36ec38bd292d8b0b139c15c69392542eef3e438b", "author": {"user": {"login": "lkokhreidze", "name": "Levani Kokhreidze"}}, "url": "https://github.com/apache/kafka/commit/36ec38bd292d8b0b139c15c69392542eef3e438b", "committedDate": "2020-09-22T07:31:51Z", "message": "Merge branch 'trunk' into KAFKA-10454"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk5ODY3OTIy", "url": "https://github.com/apache/kafka/pull/9237#pullrequestreview-499867922", "createdAt": "2020-09-30T22:58:20Z", "commit": {"oid": "36ec38bd292d8b0b139c15c69392542eef3e438b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMjo1ODoyMFrOHayIaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMjo1ODoyMFrOHayIaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg0NjM3OQ==", "bodyText": "building a topology is done on the main thread when calling StreamBuilder.build() so I think it's safe to remove synchronized.", "url": "https://github.com/apache/kafka/pull/9237#discussion_r497846379", "createdAt": "2020-09-30T22:58:20Z", "author": {"login": "bbejeck"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopologyBuilder.java", "diffHunk": "@@ -632,11 +632,21 @@ public final void addInternalTopic(final String topicName,\n         internalTopicNamesWithProperties.put(topicName, internalTopicProperties);\n     }\n \n-    public final void copartitionSources(final Collection<String> sourceNodes) {\n-        copartitionSourceGroups.add(Collections.unmodifiableSet(new HashSet<>(sourceNodes)));\n+    public final synchronized void copartitionSources(final Collection<String> sourceNodes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36ec38bd292d8b0b139c15c69392542eef3e438b"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ad0a87d45177a1f36a141f841848f4825832597", "author": {"user": {"login": "lkokhreidze", "name": "Levani Kokhreidze"}}, "url": "https://github.com/apache/kafka/commit/1ad0a87d45177a1f36a141f841848f4825832597", "committedDate": "2020-10-01T16:32:30Z", "message": "Merge branch 'trunk' into KAFKA-10454"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6eb3686facb4acc705ca7932f8eb5fc28548619", "author": {"user": {"login": "lkokhreidze", "name": "Levani Kokhreidze"}}, "url": "https://github.com/apache/kafka/commit/a6eb3686facb4acc705ca7932f8eb5fc28548619", "committedDate": "2020-10-01T16:47:01Z", "message": "KAFKA-10454 / remove synchronized"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMTU0NjU1", "url": "https://github.com/apache/kafka/pull/9237#pullrequestreview-502154655", "createdAt": "2020-10-05T15:08:36Z", "commit": {"oid": "a6eb3686facb4acc705ca7932f8eb5fc28548619"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNTowODozN1rOHchfDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNTowODozN1rOHchfDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY3MDc5OQ==", "bodyText": "nit: I think we can remove synchronized here as well", "url": "https://github.com/apache/kafka/pull/9237#discussion_r499670799", "createdAt": "2020-10-05T15:08:37Z", "author": {"login": "bbejeck"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopologyBuilder.java", "diffHunk": "@@ -633,10 +633,20 @@ public final void addInternalTopic(final String topicName,\n     }\n \n     public final void copartitionSources(final Collection<String> sourceNodes) {\n-        copartitionSourceGroups.add(Collections.unmodifiableSet(new HashSet<>(sourceNodes)));\n+        copartitionSourceGroups.add(new HashSet<>(sourceNodes));\n     }\n \n-    public void validateCopartition() {\n+    public final void maybeUpdateCopartitionSourceGroups(final String replacedNodeName,\n+                                                         final String optimizedNodeName) {\n+        for (final Set<String> copartitionSourceGroup : copartitionSourceGroups) {\n+            if (copartitionSourceGroup.contains(replacedNodeName)) {\n+                copartitionSourceGroup.remove(replacedNodeName);\n+                copartitionSourceGroup.add(optimizedNodeName);\n+            }\n+        }\n+    }\n+\n+    public synchronized void validateCopartition() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6eb3686facb4acc705ca7932f8eb5fc28548619"}, "originalPosition": 19}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66366e4b98b60dabf4e477a32aae8ca88a33f508", "author": {"user": {"login": "lkokhreidze", "name": "Levani Kokhreidze"}}, "url": "https://github.com/apache/kafka/commit/66366e4b98b60dabf4e477a32aae8ca88a33f508", "committedDate": "2020-10-05T15:37:57Z", "message": "KAFKA-10454 / remove synchronized from validateCopartition"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyNDY3MTQ5", "url": "https://github.com/apache/kafka/pull/9237#pullrequestreview-502467149", "createdAt": "2020-10-05T22:34:46Z", "commit": {"oid": "66366e4b98b60dabf4e477a32aae8ca88a33f508"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMjozNDo0NlrOHcwAkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQyMjozNDo0NlrOHcwAkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwODc1Mw==", "bodyText": "super nit: I missed this before, but the last statement could be an else", "url": "https://github.com/apache/kafka/pull/9237#discussion_r499908753", "createdAt": "2020-10-05T22:34:46Z", "author": {"login": "bbejeck"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/StreamTableJoinTopologyOptimizationIntegrationTest.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.integration;\n+\n+import org.apache.kafka.clients.admin.AdminClient;\n+import org.apache.kafka.clients.admin.AdminClientConfig;\n+import org.apache.kafka.clients.admin.TopicDescription;\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.common.serialization.Deserializer;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.common.serialization.StringDeserializer;\n+import org.apache.kafka.common.serialization.StringSerializer;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.integration.utils.EmbeddedKafkaCluster;\n+import org.apache.kafka.streams.integration.utils.IntegrationTestUtils;\n+import org.apache.kafka.streams.kstream.KStream;\n+import org.apache.kafka.streams.kstream.KTable;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.kstream.Named;\n+import org.apache.kafka.test.IntegrationTest;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.TestName;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.kafka.streams.integration.utils.IntegrationTestUtils.safeUniqueTestName;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(value = Parameterized.class)\n+@Category({IntegrationTest.class})\n+public class StreamTableJoinTopologyOptimizationIntegrationTest {\n+    private static final int NUM_BROKERS = 1;\n+\n+    @ClassRule\n+    public static final EmbeddedKafkaCluster CLUSTER = new EmbeddedKafkaCluster(NUM_BROKERS);\n+\n+    private String tableTopic;\n+    private String inputTopic;\n+    private String outputTopic;\n+    private String applicationId;\n+\n+    private Properties streamsConfiguration;\n+\n+    @Rule\n+    public TestName testName = new TestName();\n+\n+    @Parameterized.Parameter\n+    public String topologyOptimization;\n+\n+    @Parameterized.Parameters(name = \"Optimization = {0}\")\n+    public static Collection<?> topologyOptimization() {\n+        return Arrays.asList(new String[][]{\n+            {StreamsConfig.OPTIMIZE},\n+            {StreamsConfig.NO_OPTIMIZATION}\n+        });\n+    }\n+\n+    @Before\n+    public void before() throws InterruptedException {\n+        streamsConfiguration = new Properties();\n+\n+        final String safeTestName = safeUniqueTestName(getClass(), testName);\n+\n+        tableTopic = \"table-topic\" + safeTestName;\n+        inputTopic = \"stream-topic-\" + safeTestName;\n+        outputTopic = \"output-topic-\" + safeTestName;\n+        applicationId = \"app-\" + safeTestName;\n+\n+        CLUSTER.createTopic(inputTopic, 4, 1);\n+        CLUSTER.createTopic(tableTopic, 2, 1);\n+        CLUSTER.createTopic(outputTopic, 4, 1);\n+\n+        streamsConfiguration.put(StreamsConfig.APPLICATION_ID_CONFIG, applicationId);\n+        streamsConfiguration.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, CLUSTER.bootstrapServers());\n+        streamsConfiguration.put(StreamsConfig.STATE_DIR_CONFIG, TestUtils.tempDirectory().getPath());\n+        streamsConfiguration.put(StreamsConfig.CACHE_MAX_BYTES_BUFFERING_CONFIG, 0);\n+        streamsConfiguration.put(StreamsConfig.COMMIT_INTERVAL_MS_CONFIG, 100);\n+        streamsConfiguration.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.Integer().getClass());\n+        streamsConfiguration.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass());\n+        streamsConfiguration.put(StreamsConfig.TOPOLOGY_OPTIMIZATION_CONFIG, topologyOptimization);\n+    }\n+\n+    @After\n+    public void whenShuttingDown() throws IOException {\n+        IntegrationTestUtils.purgeLocalStreamsState(streamsConfiguration);\n+    }\n+\n+    @Test\n+    public void shouldDoStreamTableJoinWithDifferentNumberOfPartitions() throws Exception {\n+        final String storeName = \"store\";\n+        final String selectKeyName = \"selectKey\";\n+\n+        final StreamsBuilder streamsBuilder = new StreamsBuilder();\n+\n+        final KStream<Integer, String> stream = streamsBuilder.stream(inputTopic);\n+        final KTable<Integer, String> table = streamsBuilder.table(tableTopic, Materialized.as(storeName));\n+\n+        stream\n+            .selectKey((key, value) -> key, Named.as(selectKeyName))\n+            .join(table, (value1, value2) -> value2)\n+            .to(outputTopic);\n+\n+        startStreams(streamsBuilder);\n+\n+        final long timestamp = System.currentTimeMillis();\n+\n+        final List<KeyValue<Integer, String>> expectedRecords = Arrays.asList(\n+            new KeyValue<>(1, \"A\"),\n+            new KeyValue<>(2, \"B\")\n+        );\n+\n+        sendEvents(inputTopic, timestamp, expectedRecords);\n+        sendEvents(outputTopic, timestamp, expectedRecords);\n+\n+        startStreams(streamsBuilder);\n+\n+        validateReceivedMessages(\n+            outputTopic,\n+            new IntegerDeserializer(),\n+            new StringDeserializer(),\n+            expectedRecords\n+        );\n+\n+        final Set<String> allTopicsInCluster = CLUSTER.getAllTopicsInCluster();\n+\n+        final String repartitionTopicName = applicationId + \"-\" + selectKeyName + \"-repartition\";\n+        final String tableChangelogStoreName = applicationId + \"-\" + storeName + \"-changelog\";\n+\n+        assertTrue(topicExists(repartitionTopicName));\n+        assertEquals(2, getNumberOfPartitionsForTopic(repartitionTopicName));\n+\n+        if (StreamsConfig.OPTIMIZE.equals(topologyOptimization)) {\n+            assertFalse(allTopicsInCluster.contains(tableChangelogStoreName));\n+        } else if (StreamsConfig.NO_OPTIMIZATION.equals(topologyOptimization)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66366e4b98b60dabf4e477a32aae8ca88a33f508"}, "originalPosition": 171}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMTgwNzYy", "url": "https://github.com/apache/kafka/pull/9237#pullrequestreview-513180762", "createdAt": "2020-10-20T22:27:35Z", "commit": {"oid": "66366e4b98b60dabf4e477a32aae8ca88a33f508"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 858, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}