{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxMjMyMTI5", "number": 7927, "title": "KAFKA-9294: Add tests for Named parameter", "bodyText": "Part (2) -- stateful KStream operators\nFollow up to #7874\nKStream interface contains some method reordering (I also renamed some parameters as highlighted)\nCall for review @bbejeck @vvcephei", "createdAt": "2020-01-10T01:16:33Z", "url": "https://github.com/apache/kafka/pull/7927", "merged": true, "mergeCommit": {"oid": "81fcb809249e9f7152232ec8aa66a79155327e6f"}, "closed": true, "closedAt": "2020-01-14T21:50:37Z", "author": {"login": "mjsax"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb40DYtgH2gAyMzYxMjMyMTI5OjBiNTRhYWEwYjU4N2IzMWRhY2I4NGQxNzFkNmU0NzJkOWZhN2E2ZGE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb5DaT8AFqTM0MTM2MzczMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da", "author": {"user": {"login": "mjsax", "name": "Matthias J. Sax"}}, "url": "https://github.com/apache/kafka/commit/0b54aaa0b587b31dacb84d171d6e472d9fa7a6da", "committedDate": "2020-01-10T01:13:27Z", "message": "KAFKA-9294: Add tests for Named parameter\n\nPart (2) -- stateful KStream operators"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwOTA5Nzk0", "url": "https://github.com/apache/kafka/pull/7927#pullrequestreview-340909794", "createdAt": "2020-01-10T01:17:08Z", "commit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxNzowOFrOFcH_YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxNzowOFrOFcH_YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTM2MA==", "bodyText": "renamed selector to keySelector", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035360", "createdAt": "2020-01-10T01:17:08Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -875,192 +875,192 @@ void to(final TopicNameExtractor<K, V> topicExtractor,\n             final Produced<K, V> produced);\n \n     /**\n-     * Group the records by their current key into a {@link KGroupedStream} while preserving the original values\n+     * Group the records of this {@code KStream} on a new key that is selected using the provided {@link KeyValueMapper}\n      * and default serializers and deserializers.\n      * {@link KGroupedStream} can be further grouped with other streams to form a {@link CogroupedKStream}.\n      * Grouping a stream on the record key is required before an aggregation operator can be applied to the data\n      * (cf. {@link KGroupedStream}).\n-     * If a record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}.\n+     * The {@link KeyValueMapper} selects a new key (which may or may not be of the same type) while preserving the\n+     * original values.\n+     * If the new record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}\n      * <p>\n-     * If a key changing operator was used before this operation (e.g., {@link #selectKey(KeyValueMapper)},\n-     * {@link #map(KeyValueMapper)}, {@link #flatMap(KeyValueMapper)}, or\n-     * {@link #transform(TransformerSupplier, String...)}), and no data redistribution happened afterwards (e.g., via\n-     * {@link #through(String)}) an internal repartitioning topic may need to be created in Kafka if a later\n-     * operator depends on the newly selected key.\n+     * Because a new key is selected, an internal repartitioning topic may need to be created in Kafka if a\n+     * later operator depends on the newly selected key.\n      * This topic will be named \"${applicationId}-&lt;name&gt;-repartition\", where \"applicationId\" is user-specified in\n      * {@link StreamsConfig} via parameter {@link StreamsConfig#APPLICATION_ID_CONFIG APPLICATION_ID_CONFIG},\n      * \"&lt;name&gt;\" is an internally generated name, and \"-repartition\" is a fixed suffix.\n      * <p>\n      * You can retrieve all generated internal topic names via {@link Topology#describe()}.\n      * <p>\n-     * For this case, all data of this stream will be redistributed through the repartitioning topic by writing all\n-     * records to it, and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned\n-     * correctly on its key.\n-     * If the last key changing operator changed the key type, it is recommended to use\n-     * {@link #groupByKey(org.apache.kafka.streams.kstream.Grouped)} instead.\n+     * All data of this stream will be redistributed through the repartitioning topic by writing all records to it,\n+     * and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned on the new key.\n+     * <p>\n+     * This operation is equivalent to calling {@link #selectKey(KeyValueMapper)} followed by {@link #groupByKey()}.\n+     * If the key type is changed, it is recommended to use {@link #groupBy(KeyValueMapper, Grouped)} instead.\n      *\n+     * @param keySelector a {@link KeyValueMapper} that computes a new key for grouping\n+     * @param <KR>        the key type of the result {@link KGroupedStream}\n      * @return a {@link KGroupedStream} that contains the grouped records of the original {@code KStream}\n-     * @see #groupBy(KeyValueMapper)\n      */\n-    KGroupedStream<K, V> groupByKey();\n+    <KR> KGroupedStream<KR, V> groupBy(final KeyValueMapper<? super K, ? super V, KR> keySelector);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwOTA5ODIx", "url": "https://github.com/apache/kafka/pull/7927#pullrequestreview-340909821", "createdAt": "2020-01-10T01:17:16Z", "commit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxNzoxNlrOFcH_cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxNzoxNlrOFcH_cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTM3OA==", "bodyText": "renamed selector to keySelector", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035378", "createdAt": "2020-01-10T01:17:16Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -875,192 +875,192 @@ void to(final TopicNameExtractor<K, V> topicExtractor,\n             final Produced<K, V> produced);\n \n     /**\n-     * Group the records by their current key into a {@link KGroupedStream} while preserving the original values\n+     * Group the records of this {@code KStream} on a new key that is selected using the provided {@link KeyValueMapper}\n      * and default serializers and deserializers.\n      * {@link KGroupedStream} can be further grouped with other streams to form a {@link CogroupedKStream}.\n      * Grouping a stream on the record key is required before an aggregation operator can be applied to the data\n      * (cf. {@link KGroupedStream}).\n-     * If a record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}.\n+     * The {@link KeyValueMapper} selects a new key (which may or may not be of the same type) while preserving the\n+     * original values.\n+     * If the new record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}\n      * <p>\n-     * If a key changing operator was used before this operation (e.g., {@link #selectKey(KeyValueMapper)},\n-     * {@link #map(KeyValueMapper)}, {@link #flatMap(KeyValueMapper)}, or\n-     * {@link #transform(TransformerSupplier, String...)}), and no data redistribution happened afterwards (e.g., via\n-     * {@link #through(String)}) an internal repartitioning topic may need to be created in Kafka if a later\n-     * operator depends on the newly selected key.\n+     * Because a new key is selected, an internal repartitioning topic may need to be created in Kafka if a\n+     * later operator depends on the newly selected key.\n      * This topic will be named \"${applicationId}-&lt;name&gt;-repartition\", where \"applicationId\" is user-specified in\n      * {@link StreamsConfig} via parameter {@link StreamsConfig#APPLICATION_ID_CONFIG APPLICATION_ID_CONFIG},\n      * \"&lt;name&gt;\" is an internally generated name, and \"-repartition\" is a fixed suffix.\n      * <p>\n      * You can retrieve all generated internal topic names via {@link Topology#describe()}.\n      * <p>\n-     * For this case, all data of this stream will be redistributed through the repartitioning topic by writing all\n-     * records to it, and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned\n-     * correctly on its key.\n-     * If the last key changing operator changed the key type, it is recommended to use\n-     * {@link #groupByKey(org.apache.kafka.streams.kstream.Grouped)} instead.\n+     * All data of this stream will be redistributed through the repartitioning topic by writing all records to it,\n+     * and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned on the new key.\n+     * <p>\n+     * This operation is equivalent to calling {@link #selectKey(KeyValueMapper)} followed by {@link #groupByKey()}.\n+     * If the key type is changed, it is recommended to use {@link #groupBy(KeyValueMapper, Grouped)} instead.\n      *\n+     * @param keySelector a {@link KeyValueMapper} that computes a new key for grouping\n+     * @param <KR>        the key type of the result {@link KGroupedStream}\n      * @return a {@link KGroupedStream} that contains the grouped records of the original {@code KStream}\n-     * @see #groupBy(KeyValueMapper)\n      */\n-    KGroupedStream<K, V> groupByKey();\n+    <KR> KGroupedStream<KR, V> groupBy(final KeyValueMapper<? super K, ? super V, KR> keySelector);\n \n     /**\n-     * Group the records by their current key into a {@link KGroupedStream} while preserving the original values\n-     * and using the serializers as defined by {@link Serialized}.\n+     * Group the records of this {@code KStream} on a new key that is selected using the provided {@link KeyValueMapper}\n+     * and {@link Serde}s as specified by {@link Serialized}.\n      * {@link KGroupedStream} can be further grouped with other streams to form a {@link CogroupedKStream}.\n      * Grouping a stream on the record key is required before an aggregation operator can be applied to the data\n      * (cf. {@link KGroupedStream}).\n-     * If a record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}.\n+     * The {@link KeyValueMapper} selects a new key (which may or may not be of the same type) while preserving the\n+     * original values.\n+     * If the new record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}.\n      * <p>\n-     * If a key changing operator was used before this operation (e.g., {@link #selectKey(KeyValueMapper)},\n-     * {@link #map(KeyValueMapper)}, {@link #flatMap(KeyValueMapper)}, or\n-     * {@link #transform(TransformerSupplier, String...)}), and no data redistribution happened afterwards (e.g., via\n-     * {@link #through(String)}) an internal repartitioning topic may need to be created in Kafka\n-     * if a later operator depends on the newly selected key.\n-     * This topic will be named \"${applicationId}-&lt;name&gt;-repartition\", where \"applicationId\" is user-specified in\n+     * Because a new key is selected, an internal repartitioning topic may need to be created in Kafka if a\n+     * later operator depends on the newly selected key.\n+     * This topic will be as \"${applicationId}-&lt;name&gt;-repartition\", where \"applicationId\" is user-specified in\n      * {@link StreamsConfig} via parameter {@link StreamsConfig#APPLICATION_ID_CONFIG APPLICATION_ID_CONFIG},\n      * \"&lt;name&gt;\" is an internally generated name, and \"-repartition\" is a fixed suffix.\n      * <p>\n      * You can retrieve all generated internal topic names via {@link Topology#describe()}.\n      * <p>\n-     * For this case, all data of this stream will be redistributed through the repartitioning topic by writing all\n-     * records to it, and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned\n-     * correctly on its key.\n+     * All data of this stream will be redistributed through the repartitioning topic by writing all records to it,\n+     * and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned on the new key.\n+     * <p>\n+     * This operation is equivalent to calling {@link #selectKey(KeyValueMapper)} followed by {@link #groupByKey()}.\n      *\n+     * @param keySelector a {@link KeyValueMapper} that computes a new key for grouping\n+     * @param <KR>        the key type of the result {@link KGroupedStream}\n      * @return a {@link KGroupedStream} that contains the grouped records of the original {@code KStream}\n-     * @see #groupBy(KeyValueMapper)\n      *\n-     * @deprecated since 2.1. Use {@link org.apache.kafka.streams.kstream.KStream#groupByKey(Grouped)} instead\n+     * @deprecated since 2.1. Use {@link org.apache.kafka.streams.kstream.KStream#groupBy(KeyValueMapper, Grouped)} instead\n      */\n     @Deprecated\n-    KGroupedStream<K, V> groupByKey(final Serialized<K, V> serialized);\n+    <KR> KGroupedStream<KR, V> groupBy(final KeyValueMapper<? super K, ? super V, KR> keySelector,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwOTA5ODQ0", "url": "https://github.com/apache/kafka/pull/7927#pullrequestreview-340909844", "createdAt": "2020-01-10T01:17:23Z", "commit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxNzoyM1rOFcH_gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxNzoyM1rOFcH_gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTM5Mw==", "bodyText": "renamed selector to keySelector", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035393", "createdAt": "2020-01-10T01:17:23Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -875,192 +875,192 @@ void to(final TopicNameExtractor<K, V> topicExtractor,\n             final Produced<K, V> produced);\n \n     /**\n-     * Group the records by their current key into a {@link KGroupedStream} while preserving the original values\n+     * Group the records of this {@code KStream} on a new key that is selected using the provided {@link KeyValueMapper}\n      * and default serializers and deserializers.\n      * {@link KGroupedStream} can be further grouped with other streams to form a {@link CogroupedKStream}.\n      * Grouping a stream on the record key is required before an aggregation operator can be applied to the data\n      * (cf. {@link KGroupedStream}).\n-     * If a record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}.\n+     * The {@link KeyValueMapper} selects a new key (which may or may not be of the same type) while preserving the\n+     * original values.\n+     * If the new record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}\n      * <p>\n-     * If a key changing operator was used before this operation (e.g., {@link #selectKey(KeyValueMapper)},\n-     * {@link #map(KeyValueMapper)}, {@link #flatMap(KeyValueMapper)}, or\n-     * {@link #transform(TransformerSupplier, String...)}), and no data redistribution happened afterwards (e.g., via\n-     * {@link #through(String)}) an internal repartitioning topic may need to be created in Kafka if a later\n-     * operator depends on the newly selected key.\n+     * Because a new key is selected, an internal repartitioning topic may need to be created in Kafka if a\n+     * later operator depends on the newly selected key.\n      * This topic will be named \"${applicationId}-&lt;name&gt;-repartition\", where \"applicationId\" is user-specified in\n      * {@link StreamsConfig} via parameter {@link StreamsConfig#APPLICATION_ID_CONFIG APPLICATION_ID_CONFIG},\n      * \"&lt;name&gt;\" is an internally generated name, and \"-repartition\" is a fixed suffix.\n      * <p>\n      * You can retrieve all generated internal topic names via {@link Topology#describe()}.\n      * <p>\n-     * For this case, all data of this stream will be redistributed through the repartitioning topic by writing all\n-     * records to it, and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned\n-     * correctly on its key.\n-     * If the last key changing operator changed the key type, it is recommended to use\n-     * {@link #groupByKey(org.apache.kafka.streams.kstream.Grouped)} instead.\n+     * All data of this stream will be redistributed through the repartitioning topic by writing all records to it,\n+     * and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned on the new key.\n+     * <p>\n+     * This operation is equivalent to calling {@link #selectKey(KeyValueMapper)} followed by {@link #groupByKey()}.\n+     * If the key type is changed, it is recommended to use {@link #groupBy(KeyValueMapper, Grouped)} instead.\n      *\n+     * @param keySelector a {@link KeyValueMapper} that computes a new key for grouping\n+     * @param <KR>        the key type of the result {@link KGroupedStream}\n      * @return a {@link KGroupedStream} that contains the grouped records of the original {@code KStream}\n-     * @see #groupBy(KeyValueMapper)\n      */\n-    KGroupedStream<K, V> groupByKey();\n+    <KR> KGroupedStream<KR, V> groupBy(final KeyValueMapper<? super K, ? super V, KR> keySelector);\n \n     /**\n-     * Group the records by their current key into a {@link KGroupedStream} while preserving the original values\n-     * and using the serializers as defined by {@link Serialized}.\n+     * Group the records of this {@code KStream} on a new key that is selected using the provided {@link KeyValueMapper}\n+     * and {@link Serde}s as specified by {@link Serialized}.\n      * {@link KGroupedStream} can be further grouped with other streams to form a {@link CogroupedKStream}.\n      * Grouping a stream on the record key is required before an aggregation operator can be applied to the data\n      * (cf. {@link KGroupedStream}).\n-     * If a record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}.\n+     * The {@link KeyValueMapper} selects a new key (which may or may not be of the same type) while preserving the\n+     * original values.\n+     * If the new record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}.\n      * <p>\n-     * If a key changing operator was used before this operation (e.g., {@link #selectKey(KeyValueMapper)},\n-     * {@link #map(KeyValueMapper)}, {@link #flatMap(KeyValueMapper)}, or\n-     * {@link #transform(TransformerSupplier, String...)}), and no data redistribution happened afterwards (e.g., via\n-     * {@link #through(String)}) an internal repartitioning topic may need to be created in Kafka\n-     * if a later operator depends on the newly selected key.\n-     * This topic will be named \"${applicationId}-&lt;name&gt;-repartition\", where \"applicationId\" is user-specified in\n+     * Because a new key is selected, an internal repartitioning topic may need to be created in Kafka if a\n+     * later operator depends on the newly selected key.\n+     * This topic will be as \"${applicationId}-&lt;name&gt;-repartition\", where \"applicationId\" is user-specified in\n      * {@link StreamsConfig} via parameter {@link StreamsConfig#APPLICATION_ID_CONFIG APPLICATION_ID_CONFIG},\n      * \"&lt;name&gt;\" is an internally generated name, and \"-repartition\" is a fixed suffix.\n      * <p>\n      * You can retrieve all generated internal topic names via {@link Topology#describe()}.\n      * <p>\n-     * For this case, all data of this stream will be redistributed through the repartitioning topic by writing all\n-     * records to it, and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned\n-     * correctly on its key.\n+     * All data of this stream will be redistributed through the repartitioning topic by writing all records to it,\n+     * and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned on the new key.\n+     * <p>\n+     * This operation is equivalent to calling {@link #selectKey(KeyValueMapper)} followed by {@link #groupByKey()}.\n      *\n+     * @param keySelector a {@link KeyValueMapper} that computes a new key for grouping\n+     * @param <KR>        the key type of the result {@link KGroupedStream}\n      * @return a {@link KGroupedStream} that contains the grouped records of the original {@code KStream}\n-     * @see #groupBy(KeyValueMapper)\n      *\n-     * @deprecated since 2.1. Use {@link org.apache.kafka.streams.kstream.KStream#groupByKey(Grouped)} instead\n+     * @deprecated since 2.1. Use {@link org.apache.kafka.streams.kstream.KStream#groupBy(KeyValueMapper, Grouped)} instead\n      */\n     @Deprecated\n-    KGroupedStream<K, V> groupByKey(final Serialized<K, V> serialized);\n+    <KR> KGroupedStream<KR, V> groupBy(final KeyValueMapper<? super K, ? super V, KR> keySelector,\n+                                       final Serialized<KR, V> serialized);\n \n     /**\n-     * Group the records by their current key into a {@link KGroupedStream} while preserving the original values\n-     * and using the serializers as defined by {@link Grouped}.\n+     * Group the records of this {@code KStream} on a new key that is selected using the provided {@link KeyValueMapper}\n+     * and {@link Serde}s as specified by {@link Grouped}.\n      * {@link KGroupedStream} can be further grouped with other streams to form a {@link CogroupedKStream}.\n      * Grouping a stream on the record key is required before an aggregation operator can be applied to the data\n      * (cf. {@link KGroupedStream}).\n-     * If a record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}.\n+     * The {@link KeyValueMapper} selects a new key (which may or may not be of the same type) while preserving the\n+     * original values.\n+     * If the new record key is {@code null} the record will not be included in the resulting {@link KGroupedStream}.\n      * <p>\n-     * If a key changing operator was used before this operation (e.g., {@link #selectKey(KeyValueMapper)},\n-     * {@link #map(KeyValueMapper)}, {@link #flatMap(KeyValueMapper)}, or\n-     * {@link #transform(TransformerSupplier, String...)}), and no data redistribution happened afterwards (e.g., via\n-     * {@link #through(String)}) an internal repartitioning topic may need to be created in Kafka if a later operator\n-     * depends on the newly selected key.\n+     * Because a new key is selected, an internal repartitioning topic may need to be created in Kafka if a later\n+     * operator depends on the newly selected key.\n      * This topic will be named \"${applicationId}-&lt;name&gt;-repartition\", where \"applicationId\" is user-specified in\n      * {@link StreamsConfig} via parameter {@link StreamsConfig#APPLICATION_ID_CONFIG APPLICATION_ID_CONFIG},\n-     * &lt;name&gt; is either provided via {@link org.apache.kafka.streams.kstream.Grouped#as(String)} or an internally\n-     * generated name, and \"-repartition\" is a fixed suffix.\n+     * \"&lt;name&gt;\" is either provided via {@link org.apache.kafka.streams.kstream.Grouped#as(String)} or an\n+     * internally generated name.\n      * <p>\n      * You can retrieve all generated internal topic names via {@link Topology#describe()}.\n      * <p>\n-     * For this case, all data of this stream will be redistributed through the repartitioning topic by writing all\n-     * records to it, and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned\n-     * correctly on its key.\n+     * All data of this stream will be redistributed through the repartitioning topic by writing all records to it,\n+     * and rereading all records from it, such that the resulting {@link KGroupedStream} is partitioned on the new key.\n+     * <p>\n+     * This operation is equivalent to calling {@link #selectKey(KeyValueMapper)} followed by {@link #groupByKey()}.\n      *\n-     * @param  grouped  the {@link Grouped} instance used to specify {@link org.apache.kafka.common.serialization.Serdes}\n-     *                  and part of the name for a repartition topic if repartitioning is required.\n+     * @param keySelector a {@link KeyValueMapper} that computes a new key for grouping\n+     * @param grouped     the {@link Grouped} instance used to specify {@link org.apache.kafka.common.serialization.Serdes}\n+     *                    and part of the name for a repartition topic if repartitioning is required.\n+     * @param <KR>        the key type of the result {@link KGroupedStream}\n      * @return a {@link KGroupedStream} that contains the grouped records of the original {@code KStream}\n-     * @see #groupBy(KeyValueMapper)\n      */\n-    KGroupedStream<K, V> groupByKey(final Grouped<K, V> grouped);\n+    <KR> KGroupedStream<KR, V> groupBy(final KeyValueMapper<? super K, ? super V, KR> keySelector,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "originalPosition": 142}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwOTEwMTM5", "url": "https://github.com/apache/kafka/pull/7927#pullrequestreview-340910139", "createdAt": "2020-01-10T01:18:23Z", "commit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxODoyM1rOFcIAZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxODoyM1rOFcIAZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTYyMw==", "bodyText": "renamed globalKTable to globalTable\nrenamed keyValueMapper  to keySelector", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035623", "createdAt": "2020-01-10T01:18:23Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -2144,8 +2144,8 @@ void to(final TopicNameExtractor<K, V> topicExtractor,\n      * {@link ValueJoiner}, one output for each input {@code KStream} record\n      * @see #leftJoin(GlobalKTable, KeyValueMapper, ValueJoiner)\n      */\n-    <GK, GV, RV> KStream<K, RV> join(final GlobalKTable<GK, GV> globalKTable,\n-                                     final KeyValueMapper<? super K, ? super V, ? extends GK> keyValueMapper,\n+    <GK, GV, RV> KStream<K, RV> join(final GlobalKTable<GK, GV> globalTable,\n+                                     final KeyValueMapper<? super K, ? super V, ? extends GK> keySelector,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "originalPosition": 307}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwOTEwMTc0", "url": "https://github.com/apache/kafka/pull/7927#pullrequestreview-340910174", "createdAt": "2020-01-10T01:18:31Z", "commit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxODozMVrOFcIAgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxODozMVrOFcIAgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTY0OA==", "bodyText": "renamed globalKTable to globalTable\nrenamed keyValueMapper  to keySelector", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035648", "createdAt": "2020-01-10T01:18:31Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -2178,8 +2178,8 @@ void to(final TopicNameExtractor<K, V> topicExtractor,\n      * {@link ValueJoiner}, one output for each input {@code KStream} record\n      * @see #leftJoin(GlobalKTable, KeyValueMapper, ValueJoiner)\n      */\n-    <GK, GV, RV> KStream<K, RV> join(final GlobalKTable<GK, GV> globalKTable,\n-                                     final KeyValueMapper<? super K, ? super V, ? extends GK> keyValueMapper,\n+    <GK, GV, RV> KStream<K, RV> join(final GlobalKTable<GK, GV> globalTable,\n+                                     final KeyValueMapper<? super K, ? super V, ? extends GK> keySelector,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "originalPosition": 329}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwOTEwMjEx", "url": "https://github.com/apache/kafka/pull/7927#pullrequestreview-340910211", "createdAt": "2020-01-10T01:18:36Z", "commit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxODozNlrOFcIAmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxODozNlrOFcIAmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTY3NQ==", "bodyText": "renamed globalKTable to globalTable\nrenamed keyValueMapper  to keySelector", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035675", "createdAt": "2020-01-10T01:18:36Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -2216,8 +2216,8 @@ void to(final TopicNameExtractor<K, V> topicExtractor,\n      * {@link ValueJoiner}, one output for each input {@code KStream} record\n      * @see #join(GlobalKTable, KeyValueMapper, ValueJoiner)\n      */\n-    <GK, GV, RV> KStream<K, RV> leftJoin(final GlobalKTable<GK, GV> globalKTable,\n-                                         final KeyValueMapper<? super K, ? super V, ? extends GK> keyValueMapper,\n+    <GK, GV, RV> KStream<K, RV> leftJoin(final GlobalKTable<GK, GV> globalTable,\n+                                         final KeyValueMapper<? super K, ? super V, ? extends GK> keySelector,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "originalPosition": 351}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwOTEwMjI4", "url": "https://github.com/apache/kafka/pull/7927#pullrequestreview-340910228", "createdAt": "2020-01-10T01:18:41Z", "commit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxODo0MVrOFcIAqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxODo0MVrOFcIAqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTY5MA==", "bodyText": "renamed globalKTable to globalTable\nrenamed keyValueMapper  to keySelector", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035690", "createdAt": "2020-01-10T01:18:41Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -2254,8 +2254,8 @@ void to(final TopicNameExtractor<K, V> topicExtractor,\n      * {@link ValueJoiner}, one output for each input {@code KStream} record\n      * @see #join(GlobalKTable, KeyValueMapper, ValueJoiner)\n      */\n-    <GK, GV, RV> KStream<K, RV> leftJoin(final GlobalKTable<GK, GV> globalKTable,\n-                                         final KeyValueMapper<? super K, ? super V, ? extends GK> keyValueMapper,\n+    <GK, GV, RV> KStream<K, RV> leftJoin(final GlobalKTable<GK, GV> globalTable,\n+                                         final KeyValueMapper<? super K, ? super V, ? extends GK> keySelector,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "originalPosition": 373}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwOTEwMzM3", "url": "https://github.com/apache/kafka/pull/7927#pullrequestreview-340910337", "createdAt": "2020-01-10T01:19:10Z", "commit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxOToxMFrOFcIBAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxOToxMFrOFcIBAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTc3Nw==", "bodyText": "As in the interface; renamed parameter", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035777", "createdAt": "2020-01-10T01:19:10Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -601,30 +601,30 @@ private void to(final TopicNameExtractor<K, V> topicExtractor,\n     }\n \n     @Override\n-    public <KR> KGroupedStream<KR, V> groupBy(final KeyValueMapper<? super K, ? super V, KR> selector) {\n-        return groupBy(selector, Grouped.with(null, valSerde));\n+    public <KR> KGroupedStream<KR, V> groupBy(final KeyValueMapper<? super K, ? super V, KR> keySelector) {\n+        return groupBy(keySelector, Grouped.with(null, valSerde));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwOTEwNDM5", "url": "https://github.com/apache/kafka/pull/7927#pullrequestreview-340910439", "createdAt": "2020-01-10T01:19:36Z", "commit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxOTozNlrOFcIBTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxOTozNlrOFcIBTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTg1Mw==", "bodyText": "It's called otherStream in the interface -- aligning both", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035853", "createdAt": "2020-01-10T01:19:36Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -664,10 +668,10 @@ private void to(final TopicNameExtractor<K, V> topicExtractor,\n     }\n \n     @Override\n-    public <VO, VR> KStream<K, VR> join(final KStream<K, VO> other,\n+    public <VO, VR> KStream<K, VR> join(final KStream<K, VO> otherStream,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwOTEwNTM4", "url": "https://github.com/apache/kafka/pull/7927#pullrequestreview-340910538", "createdAt": "2020-01-10T01:19:57Z", "commit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxOTo1N1rOFcIBlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToxOTo1N1rOFcIBlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTkyNw==", "bodyText": "It's called table in the interface -- aligning both", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035927", "createdAt": "2020-01-10T01:19:57Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -857,55 +900,16 @@ private void to(final TopicNameExtractor<K, V> topicExtractor,\n     }\n \n     @Override\n-    public <VO, VR> KStream<K, VR> leftJoin(final KStream<K, VO> other,\n-                                            final ValueJoiner<? super V, ? super VO, ? extends VR> joiner,\n-                                            final JoinWindows windows) {\n-        return leftJoin(other, joiner, windows, Joined.with(null, null, null));\n-    }\n-\n-    @Override\n-    @Deprecated\n-    public <VO, VR> KStream<K, VR> leftJoin(final KStream<K, VO> other,\n-                                            final ValueJoiner<? super V, ? super VO, ? extends VR> joiner,\n-                                            final JoinWindows windows,\n-                                            final Joined<K, V, VO> joined) {\n-        Objects.requireNonNull(joined, \"Joined can't be null\");\n-\n-        final JoinedInternal<K, V, VO> joinedInternal = new JoinedInternal<>(joined);\n-        final StreamJoined<K, V, VO> streamJoined = StreamJoined\n-            .with(\n-                joinedInternal.keySerde(),\n-                joinedInternal.valueSerde(),\n-                joinedInternal.otherValueSerde())\n-            .withName(joinedInternal.name());\n-\n-        return leftJoin(other, joiner, windows, streamJoined);\n-    }\n-\n-    @Override\n-    public <VO, VR> KStream<K, VR> leftJoin(final KStream<K, VO> other,\n-                                            final ValueJoiner<? super V, ? super VO, ? extends VR> joiner,\n-                                            final JoinWindows windows,\n-                                            final StreamJoined<K, V, VO> streamJoined) {\n-        return doJoin(\n-            other,\n-            joiner,\n-            windows,\n-            streamJoined,\n-            new KStreamImplJoin(builder, true, false));\n-    }\n-\n-    @Override\n-    public <VO, VR> KStream<K, VR> join(final KTable<K, VO> other,\n+    public <VO, VR> KStream<K, VR> join(final KTable<K, VO> table,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "originalPosition": 213}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwOTEwNjMy", "url": "https://github.com/apache/kafka/pull/7927#pullrequestreview-340910632", "createdAt": "2020-01-10T01:20:22Z", "commit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToyMDoyMlrOFcIB2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToyMDoyMlrOFcIB2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNTk5NA==", "bodyText": "As in the interface; renamed parameter", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365035994", "createdAt": "2020-01-10T01:20:22Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -946,49 +950,49 @@ private void to(final TopicNameExtractor<K, V> topicExtractor,\n                 joined.keySerde(),\n                 joined.valueSerde()\n             );\n-            return thisStreamRepartitioned.doStreamTableJoin(other, joiner, joined, true);\n+            return thisStreamRepartitioned.doStreamTableJoin(table, joiner, joined, true);\n         } else {\n-            return doStreamTableJoin(other, joiner, joined, true);\n+            return doStreamTableJoin(table, joiner, joined, true);\n         }\n     }\n \n     @Override\n     public <KG, VG, VR> KStream<K, VR> join(final GlobalKTable<KG, VG> globalTable,\n-                                            final KeyValueMapper<? super K, ? super V, ? extends KG> keyMapper,\n+                                            final KeyValueMapper<? super K, ? super V, ? extends KG> keySelector,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "originalPosition": 273}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwOTEwNzYx", "url": "https://github.com/apache/kafka/pull/7927#pullrequestreview-340910761", "createdAt": "2020-01-10T01:20:56Z", "commit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToyMDo1NlrOFcICSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToyMDo1NlrOFcICSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNjEwNQ==", "bodyText": "As in the interface; renamed parameter\n(note, that the first parameter is already called globalTable)", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365036105", "createdAt": "2020-01-10T01:20:56Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -946,49 +950,49 @@ private void to(final TopicNameExtractor<K, V> topicExtractor,\n                 joined.keySerde(),\n                 joined.valueSerde()\n             );\n-            return thisStreamRepartitioned.doStreamTableJoin(other, joiner, joined, true);\n+            return thisStreamRepartitioned.doStreamTableJoin(table, joiner, joined, true);\n         } else {\n-            return doStreamTableJoin(other, joiner, joined, true);\n+            return doStreamTableJoin(table, joiner, joined, true);\n         }\n     }\n \n     @Override\n     public <KG, VG, VR> KStream<K, VR> join(final GlobalKTable<KG, VG> globalTable,\n-                                            final KeyValueMapper<? super K, ? super V, ? extends KG> keyMapper,\n+                                            final KeyValueMapper<? super K, ? super V, ? extends KG> keySelector,\n                                             final ValueJoiner<? super V, ? super VG, ? extends VR> joiner) {\n-        return globalTableJoin(globalTable, keyMapper, joiner, false, NamedInternal.empty());\n+        return globalTableJoin(globalTable, keySelector, joiner, false, NamedInternal.empty());\n     }\n \n     @Override\n     public <KG, VG, VR> KStream<K, VR> join(final GlobalKTable<KG, VG> globalTable,\n-                                            final KeyValueMapper<? super K, ? super V, ? extends KG> keyMapper,\n+                                            final KeyValueMapper<? super K, ? super V, ? extends KG> keySelector,\n                                             final ValueJoiner<? super V, ? super VG, ? extends VR> joiner,\n                                             final Named named) {\n-        return globalTableJoin(globalTable, keyMapper, joiner, false, named);\n+        return globalTableJoin(globalTable, keySelector, joiner, false, named);\n     }\n \n     @Override\n     public <KG, VG, VR> KStream<K, VR> leftJoin(final GlobalKTable<KG, VG> globalTable,\n-                                                final KeyValueMapper<? super K, ? super V, ? extends KG> keyMapper,\n+                                                final KeyValueMapper<? super K, ? super V, ? extends KG> keySelector,\n                                                 final ValueJoiner<? super V, ? super VG, ? extends VR> joiner) {\n-        return globalTableJoin(globalTable, keyMapper, joiner, true, NamedInternal.empty());\n+        return globalTableJoin(globalTable, keySelector, joiner, true, NamedInternal.empty());\n     }\n \n     @Override\n     public <KG, VG, VR> KStream<K, VR> leftJoin(final GlobalKTable<KG, VG> globalTable,\n-                                                final KeyValueMapper<? super K, ? super V, ? extends KG> keyMapper,\n+                                                final KeyValueMapper<? super K, ? super V, ? extends KG> keySelector,\n                                                 final ValueJoiner<? super V, ? super VG, ? extends VR> joiner,\n                                                 final Named named) {\n-        return globalTableJoin(globalTable, keyMapper, joiner, true, named);\n+        return globalTableJoin(globalTable, keySelector, joiner, true, named);\n     }\n \n     private <KG, VG, VR> KStream<K, VR> globalTableJoin(final GlobalKTable<KG, VG> globalTable,\n-                                                        final KeyValueMapper<? super K, ? super V, ? extends KG> keyMapper,\n+                                                        final KeyValueMapper<? super K, ? super V, ? extends KG> keySelector,\n                                                         final ValueJoiner<? super V, ? super VG, ? extends VR> joiner,\n                                                         final boolean leftJoin,\n                                                         final Named named) {\n         Objects.requireNonNull(globalTable, \"globalTable can't be null\");\n-        Objects.requireNonNull(keyMapper, \"keyMapper can't be null\");\n+        Objects.requireNonNull(keySelector, \"keySelector can't be null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "originalPosition": 316}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwOTEwODg3", "url": "https://github.com/apache/kafka/pull/7927#pullrequestreview-340910887", "createdAt": "2020-01-10T01:21:29Z", "commit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToyMTozMFrOFcICuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xMFQwMToyMTozMFrOFcICuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTAzNjIxOQ==", "bodyText": "Cannot use import as we cannot suppress deprecation warning on import (similar in the tests).", "url": "https://github.com/apache/kafka/pull/7927#discussion_r365036219", "createdAt": "2020-01-10T01:21:30Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -79,11 +79,14 @@\n import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertThrows;\n import static org.junit.Assert.assertTrue;\n-import static org.junit.Assert.fail;\n \n public class KStreamImplTest {\n \n     private final Consumed<String, String> stringConsumed = Consumed.with(Serdes.String(), Serdes.String());\n+    @SuppressWarnings(\"deprecation\")\n+    private final org.apache.kafka.streams.kstream.Serialized<String, String> stringSerialized =\n+        org.apache.kafka.streams.kstream.Serialized.with(Serdes.String(), Serdes.String());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQxMzYzNzMx", "url": "https://github.com/apache/kafka/pull/7927#pullrequestreview-341363731", "createdAt": "2020-01-10T19:07:04Z", "commit": {"oid": "0b54aaa0b587b31dacb84d171d6e472d9fa7a6da"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1933, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}