{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyNTI1MTE0", "number": 9531, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwODo0Mzo0MVrOEzspng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNDo1MDo1MFrOE2mpTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjQ0MzgyOnYy", "diffSide": "RIGHT", "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwODo0Mzo0MVrOHrFwZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNzozNjo0NFrOHrZitA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk0NTEyNQ==", "bodyText": "If the cluster resigns from candidateState, it will also send EndQuorumEpochRequest to all voters?", "url": "https://github.com/apache/kafka/pull/9531#discussion_r514945125", "createdAt": "2020-10-30T08:43:41Z", "author": {"login": "dengziming"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1543,9 +1516,40 @@ private long maybeAppendBatches(\n         return timeUnitFlush;\n     }\n \n+    private long pollResigned(long currentTimeMs) throws IOException {\n+        GracefulShutdown shutdown = this.shutdown.get();\n+        ResignedState state = quorum.resignedStateOrThrow();\n+\n+        long endQuorumBackoffMs = maybeSendRequests(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI2OTMwMA==", "bodyText": "Yeah, that is why the EndQuorumEpoch specifies both a leaderId and a replicaId. The idea is that this allows a voter who had voted for the candidate to start a new election more quickly. Admittedly, I am not sure how valuable this optimization is in practice. We could consider simplifying the protocol so that it is only sent by leaders.", "url": "https://github.com/apache/kafka/pull/9531#discussion_r515269300", "createdAt": "2020-10-30T17:36:44Z", "author": {"login": "hachikuji"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1543,9 +1516,40 @@ private long maybeAppendBatches(\n         return timeUnitFlush;\n     }\n \n+    private long pollResigned(long currentTimeMs) throws IOException {\n+        GracefulShutdown shutdown = this.shutdown.get();\n+        ResignedState state = quorum.resignedStateOrThrow();\n+\n+        long endQuorumBackoffMs = maybeSendRequests(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk0NTEyNQ=="}, "originalCommit": null, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODQ2NjU0OnYy", "diffSide": "RIGHT", "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNzoyOTozMVrOHrZEYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNzo0MTowMlrOHrZuzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI2MTUzNw==", "bodyText": "If we are shutting down, why we still want to care about election at all?", "url": "https://github.com/apache/kafka/pull/9531#discussion_r515261537", "createdAt": "2020-10-30T17:29:31Z", "author": {"login": "guozhangwang"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1543,9 +1516,40 @@ private long maybeAppendBatches(\n         return timeUnitFlush;\n     }\n \n+    private long pollResigned(long currentTimeMs) throws IOException {\n+        GracefulShutdown shutdown = this.shutdown.get();\n+        ResignedState state = quorum.resignedStateOrThrow();\n+\n+        long endQuorumBackoffMs = maybeSendRequests(\n+            currentTimeMs,\n+            state.unackedVoters(),\n+            () -> buildEndQuorumEpochRequest(state.preferredSuccessors())\n+        );\n+\n+        final long stateTimeoutMs;\n+        if (shutdown != null) {\n+            // If we are shutting down, then we will remain in the resigned state\n+            // until either the shutdown expires or an election bumps the epoch", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI3MjM5Ng==", "bodyText": "This node can stick around long enough to help another leader get elected.", "url": "https://github.com/apache/kafka/pull/9531#discussion_r515272396", "createdAt": "2020-10-30T17:41:02Z", "author": {"login": "hachikuji"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1543,9 +1516,40 @@ private long maybeAppendBatches(\n         return timeUnitFlush;\n     }\n \n+    private long pollResigned(long currentTimeMs) throws IOException {\n+        GracefulShutdown shutdown = this.shutdown.get();\n+        ResignedState state = quorum.resignedStateOrThrow();\n+\n+        long endQuorumBackoffMs = maybeSendRequests(\n+            currentTimeMs,\n+            state.unackedVoters(),\n+            () -> buildEndQuorumEpochRequest(state.preferredSuccessors())\n+        );\n+\n+        final long stateTimeoutMs;\n+        if (shutdown != null) {\n+            // If we are shutting down, then we will remain in the resigned state\n+            // until either the shutdown expires or an election bumps the epoch", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI2MTUzNw=="}, "originalCommit": null, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyOTc2OTczOnYy", "diffSide": "RIGHT", "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQwNToyNTowM1rOHrlFKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwMTozNjo1OVrOHsdqhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1ODM0NA==", "bodyText": "should this be Math.min(shutdown.remainingTimeMs(), minRequestBackoffMs, state.remainingElectionTimeMs(currentTimeMs))", "url": "https://github.com/apache/kafka/pull/9531#discussion_r515458344", "createdAt": "2020-10-31T05:25:03Z", "author": {"login": "dengziming"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1560,9 +1558,34 @@ private long pollLeader(long currentTimeMs) {\n         return Math.min(timeUntilFlush, timeUntilSend);\n     }\n \n+    private long maybeSendVoteRequests(\n+        CandidateState state,\n+        long currentTimeMs\n+    ) {\n+        // Continue sending Vote requests as long as we still have a chance to win the election\n+        if (!state.isVoteRejected()) {\n+            return maybeSendRequests(\n+                currentTimeMs,\n+                state.unrecordedVoters(),\n+                this::buildVoteRequest\n+            );\n+        }\n+        return Long.MAX_VALUE;\n+    }\n+\n     private long pollCandidate(long currentTimeMs) throws IOException {\n         CandidateState state = quorum.candidateStateOrThrow();\n-        if (state.isBackingOff()) {\n+        GracefulShutdown shutdown = this.shutdown.get();\n+\n+        if (shutdown != null) {\n+            // If we happen to shutdown while we are a candidate, we will continue\n+            // with the current election until one of the following conditions is met:\n+            //  1) we are elected as leader (which allows us to resign)\n+            //  2) another leader is elected\n+            //  3) the shutdown timer expires\n+            long minRequestBackoffMs = maybeSendVoteRequests(state, currentTimeMs);\n+            return Math.min(shutdown.remainingTimeMs(), minRequestBackoffMs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE5ODU2OA==", "bodyText": "The intent is to ignore the election timeout in order to prevent a shutting down broker from becoming a candidate. Does that make sense?", "url": "https://github.com/apache/kafka/pull/9531#discussion_r516198568", "createdAt": "2020-11-02T19:15:21Z", "author": {"login": "hachikuji"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1560,9 +1558,34 @@ private long pollLeader(long currentTimeMs) {\n         return Math.min(timeUntilFlush, timeUntilSend);\n     }\n \n+    private long maybeSendVoteRequests(\n+        CandidateState state,\n+        long currentTimeMs\n+    ) {\n+        // Continue sending Vote requests as long as we still have a chance to win the election\n+        if (!state.isVoteRejected()) {\n+            return maybeSendRequests(\n+                currentTimeMs,\n+                state.unrecordedVoters(),\n+                this::buildVoteRequest\n+            );\n+        }\n+        return Long.MAX_VALUE;\n+    }\n+\n     private long pollCandidate(long currentTimeMs) throws IOException {\n         CandidateState state = quorum.candidateStateOrThrow();\n-        if (state.isBackingOff()) {\n+        GracefulShutdown shutdown = this.shutdown.get();\n+\n+        if (shutdown != null) {\n+            // If we happen to shutdown while we are a candidate, we will continue\n+            // with the current election until one of the following conditions is met:\n+            //  1) we are elected as leader (which allows us to resign)\n+            //  2) another leader is elected\n+            //  3) the shutdown timer expires\n+            long minRequestBackoffMs = maybeSendVoteRequests(state, currentTimeMs);\n+            return Math.min(shutdown.remainingTimeMs(), minRequestBackoffMs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1ODM0NA=="}, "originalCommit": null, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM4NTQxNQ==", "bodyText": "Understand, The candidate will try to complete only the current election when shutting down, so just ignore the election timeout.", "url": "https://github.com/apache/kafka/pull/9531#discussion_r516385415", "createdAt": "2020-11-03T01:36:59Z", "author": {"login": "dengziming"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1560,9 +1558,34 @@ private long pollLeader(long currentTimeMs) {\n         return Math.min(timeUntilFlush, timeUntilSend);\n     }\n \n+    private long maybeSendVoteRequests(\n+        CandidateState state,\n+        long currentTimeMs\n+    ) {\n+        // Continue sending Vote requests as long as we still have a chance to win the election\n+        if (!state.isVoteRejected()) {\n+            return maybeSendRequests(\n+                currentTimeMs,\n+                state.unrecordedVoters(),\n+                this::buildVoteRequest\n+            );\n+        }\n+        return Long.MAX_VALUE;\n+    }\n+\n     private long pollCandidate(long currentTimeMs) throws IOException {\n         CandidateState state = quorum.candidateStateOrThrow();\n-        if (state.isBackingOff()) {\n+        GracefulShutdown shutdown = this.shutdown.get();\n+\n+        if (shutdown != null) {\n+            // If we happen to shutdown while we are a candidate, we will continue\n+            // with the current election until one of the following conditions is met:\n+            //  1) we are elected as leader (which allows us to resign)\n+            //  2) another leader is elected\n+            //  3) the shutdown timer expires\n+            long minRequestBackoffMs = maybeSendVoteRequests(state, currentTimeMs);\n+            return Math.min(shutdown.remainingTimeMs(), minRequestBackoffMs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ1ODM0NA=="}, "originalCommit": null, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjkwNzU2OnYy", "diffSide": "RIGHT", "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNDo0NDoxOFrOHve0Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNjo1ODoxN1rOHv4ZuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0OTk1OA==", "bodyText": "Why the behavior of pollFollowerAsVoter and pollVoted are different when shutting down? Could the former case still help in casting and completing a vote as well?", "url": "https://github.com/apache/kafka/pull/9531#discussion_r519549958", "createdAt": "2020-11-09T04:44:18Z", "author": {"login": "guozhangwang"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1601,7 +1618,12 @@ private long pollFollower(long currentTimeMs) throws IOException {\n     }\n \n     private long pollFollowerAsVoter(FollowerState state, long currentTimeMs) throws IOException {\n-        if (state.hasFetchTimeoutExpired(currentTimeMs)) {\n+        GracefulShutdown shutdown = this.shutdown.get();\n+        if (shutdown != null) {\n+            // If we are a follower, then we can shutdown immediately. We want to\n+            // skip the transition to candidate in any case.\n+            return 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk2OTIwOA==", "bodyText": "If we are a follower, then there is no election in progress to help with.", "url": "https://github.com/apache/kafka/pull/9531#discussion_r519969208", "createdAt": "2020-11-09T16:58:17Z", "author": {"login": "hachikuji"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1601,7 +1618,12 @@ private long pollFollower(long currentTimeMs) throws IOException {\n     }\n \n     private long pollFollowerAsVoter(FollowerState state, long currentTimeMs) throws IOException {\n-        if (state.hasFetchTimeoutExpired(currentTimeMs)) {\n+        GracefulShutdown shutdown = this.shutdown.get();\n+        if (shutdown != null) {\n+            // If we are a follower, then we can shutdown immediately. We want to\n+            // skip the transition to candidate in any case.\n+            return 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0OTk1OA=="}, "originalCommit": null, "originalPosition": 250}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1NjkxNzI3OnYy", "diffSide": "RIGHT", "path": "raft/src/main/java/org/apache/kafka/raft/QuorumState.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNDo1MDo1MFrOHve5og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxODoxNzowMFrOHv7gPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU1MTM5NA==", "bodyText": "Makes me thinking: if we have an even number sized quorum (say 2N), and the leader is resigning. Then before the leader shutdown we need N+1 votes, while after the leader shutdown, the quorum size shrink to 2N-1 and we would only need N votes. So if the resigning leader gives it a vote to a candidate and then shutdown, while the candidates thinks they only need N votes, would that potentially result in two candidates claiming victory --- somehow this sounds quite close to the real world :P --- each with N votes while one of them has the vote from the resigned leader?", "url": "https://github.com/apache/kafka/pull/9531#discussion_r519551394", "createdAt": "2020-11-09T04:50:50Z", "author": {"login": "guozhangwang"}, "path": "raft/src/main/java/org/apache/kafka/raft/QuorumState.java", "diffHunk": "@@ -21,18 +21,21 @@\n import org.slf4j.Logger;\n \n import java.io.IOException;\n+import java.util.Collections;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Optional;\n import java.util.OptionalInt;\n import java.util.Random;\n import java.util.Set;\n import java.util.stream.Collectors;\n \n /**\n- * This class is responsible for managing the current state of this node and ensuring only\n- * valid state transitions.\n+ * This class is responsible for managing the current state of this node and ensuring\n+ * only valid state transitions. Below we define the possible state transitions and\n+ * how they are triggered:\n  *\n- * Unattached =>\n+ * Unattached|Resigned =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk2NTAwOA==", "bodyText": "Hmm.. The quorum size does not change because a leader resigns. If there are 2N nodes in the cluster, then we always need N + 1 votes, so I don't think this case is possible.", "url": "https://github.com/apache/kafka/pull/9531#discussion_r519965008", "createdAt": "2020-11-09T16:53:06Z", "author": {"login": "hachikuji"}, "path": "raft/src/main/java/org/apache/kafka/raft/QuorumState.java", "diffHunk": "@@ -21,18 +21,21 @@\n import org.slf4j.Logger;\n \n import java.io.IOException;\n+import java.util.Collections;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Optional;\n import java.util.OptionalInt;\n import java.util.Random;\n import java.util.Set;\n import java.util.stream.Collectors;\n \n /**\n- * This class is responsible for managing the current state of this node and ensuring only\n- * valid state transitions.\n+ * This class is responsible for managing the current state of this node and ensuring\n+ * only valid state transitions. Below we define the possible state transitions and\n+ * how they are triggered:\n  *\n- * Unattached =>\n+ * Unattached|Resigned =>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU1MTM5NA=="}, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk2ODE0NQ==", "bodyText": "In the future, when we have reassignment, we will still have to protect every quorum change with a majority of the current nodes. The proposal we had previously only allowed single-node changes, which meant that any majority was a majority before and after the state was applied.", "url": "https://github.com/apache/kafka/pull/9531#discussion_r519968145", "createdAt": "2020-11-09T16:56:53Z", "author": {"login": "hachikuji"}, "path": "raft/src/main/java/org/apache/kafka/raft/QuorumState.java", "diffHunk": "@@ -21,18 +21,21 @@\n import org.slf4j.Logger;\n \n import java.io.IOException;\n+import java.util.Collections;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Optional;\n import java.util.OptionalInt;\n import java.util.Random;\n import java.util.Set;\n import java.util.stream.Collectors;\n \n /**\n- * This class is responsible for managing the current state of this node and ensuring only\n- * valid state transitions.\n+ * This class is responsible for managing the current state of this node and ensuring\n+ * only valid state transitions. Below we define the possible state transitions and\n+ * how they are triggered:\n  *\n- * Unattached =>\n+ * Unattached|Resigned =>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU1MTM5NA=="}, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAyMDAyOQ==", "bodyText": "Okay now I remembered what we discussed before.\nWhat I was wondering is, say with quorum size 6, we would need 4 votes to elect leader; if the current leader shutdown and before it is restarted, the quorum size is 5 so logically we only need 3 votes --- but as long as we require that during this transition we still require 4 votes even with 5 alive quorum members we are fine.", "url": "https://github.com/apache/kafka/pull/9531#discussion_r520020029", "createdAt": "2020-11-09T18:17:00Z", "author": {"login": "guozhangwang"}, "path": "raft/src/main/java/org/apache/kafka/raft/QuorumState.java", "diffHunk": "@@ -21,18 +21,21 @@\n import org.slf4j.Logger;\n \n import java.io.IOException;\n+import java.util.Collections;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Optional;\n import java.util.OptionalInt;\n import java.util.Random;\n import java.util.Set;\n import java.util.stream.Collectors;\n \n /**\n- * This class is responsible for managing the current state of this node and ensuring only\n- * valid state transitions.\n+ * This class is responsible for managing the current state of this node and ensuring\n+ * only valid state transitions. Below we define the possible state transitions and\n+ * how they are triggered:\n  *\n- * Unattached =>\n+ * Unattached|Resigned =>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU1MTM5NA=="}, "originalCommit": null, "originalPosition": 21}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3755, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}