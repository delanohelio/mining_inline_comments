{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNjQyNzky", "number": 8457, "title": "KAFKA-9842; Add test case for OffsetsForLeaderEpoch grouping in Fetcher", "bodyText": "This is a follow-up to #8077. The bug exposed a testing gap in how we group partitions. This patch adds a test case which reproduces the reported problem.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-04-09T21:01:17Z", "url": "https://github.com/apache/kafka/pull/8457", "merged": true, "mergeCommit": {"oid": "799183b3f8d5e8d4c955e7d3ce654b97f8309aad"}, "closed": true, "closedAt": "2020-04-14T00:20:02Z", "author": {"login": "hachikuji"}, "timelineItems": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcWC9owgH2gAyNDAxNjQyNzkyOjIwMWE0ZWM0NjUxMTQ5YWEwMTUwZjYyMjkxNWRhNGZlNzYwNjI4YWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcXU9QagFqTM5MjQxNzIxMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "201a4ec4651149aa0150f622915da4fe760628ab", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/201a4ec4651149aa0150f622915da4fe760628ab", "committedDate": "2020-04-09T20:59:33Z", "message": "KAFKA-9842; Add test case for OffsetsForLeaderEpoch grouping in Fetcher"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNDE3MjEy", "url": "https://github.com/apache/kafka/pull/8457#pullrequestreview-392417212", "createdAt": "2020-04-13T20:31:04Z", "commit": {"oid": "201a4ec4651149aa0150f622915da4fe760628ab"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDozMTowNFrOGE0M9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDozMTowNFrOGE0M9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwMjc3NA==", "bodyText": "So here we are checking that the request sent from validateOffsetsIfNeeded only includes the partitions whose leader is the current node? If the match fails do we get a nice junit assertion failure, or some funky mockito stack trace?", "url": "https://github.com/apache/kafka/pull/8457#discussion_r407702774", "createdAt": "2020-04-13T20:31:04Z", "author": {"login": "mumrah"}, "path": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/FetcherTest.java", "diffHunk": "@@ -3555,6 +3556,60 @@ public void testSubscriptionPositionUpdatedWithEpoch() {\n         assertOptional(subscriptions.position(tp0).offsetEpoch, value -> assertEquals(value.intValue(), 1));\n     }\n \n+    @Test\n+    public void testOffsetValidationRequestGrouping() {\n+        buildFetcher();\n+        assignFromUser(Utils.mkSet(tp0, tp1, tp2, tp3));\n+\n+        metadata.updateWithCurrentRequestVersion(TestUtils.metadataUpdateWith(\"dummy\", 3,\n+            Collections.emptyMap(), singletonMap(topicName, 4),\n+            tp -> 5), false, 0L);\n+\n+        for (TopicPartition tp : subscriptions.assignedPartitions()) {\n+            Metadata.LeaderAndEpoch leaderAndEpoch = new Metadata.LeaderAndEpoch(\n+                metadata.currentLeader(tp).leader, Optional.of(4));\n+            subscriptions.seekUnvalidated(tp,\n+                new SubscriptionState.FetchPosition(0, Optional.of(4), leaderAndEpoch));\n+        }\n+\n+        Set<TopicPartition> allRequestedPartitions = new HashSet<>();\n+\n+        for (Node node : metadata.fetch().nodes()) {\n+            apiVersions.update(node.idString(), NodeApiVersions.create());\n+\n+            Set<TopicPartition> expectedPartitions = subscriptions.assignedPartitions().stream()\n+                .filter(tp ->\n+                    metadata.currentLeader(tp).leader.equals(Optional.of(node)))\n+                .collect(Collectors.toSet());\n+\n+            assertTrue(expectedPartitions.stream().noneMatch(allRequestedPartitions::contains));\n+            assertTrue(expectedPartitions.size() > 0);\n+            allRequestedPartitions.addAll(expectedPartitions);\n+\n+            Map<TopicPartition, EpochEndOffset> endOffsets = expectedPartitions.stream().collect(Collectors.toMap(\n+                Function.identity(),\n+                tp -> new EpochEndOffset(Errors.NONE, 4, 0)\n+            ));\n+\n+            OffsetsForLeaderEpochResponse response = new OffsetsForLeaderEpochResponse(endOffsets);\n+            client.prepareResponseFrom(new MockClient.RequestMatcher() {\n+                @Override\n+                public boolean matches(AbstractRequest body) {\n+                    OffsetsForLeaderEpochRequest request = (OffsetsForLeaderEpochRequest) body;\n+                    return expectedPartitions.equals(request.epochsByTopicPartition().keySet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "201a4ec4651149aa0150f622915da4fe760628ab"}, "originalPosition": 52}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1448, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}