{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2MDE2NjEw", "number": 8262, "title": "KAFKA-6145: Add constrained balanced assignment algorithm", "bodyText": "Committer Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-03-10T09:15:09Z", "url": "https://github.com/apache/kafka/pull/8262", "merged": true, "mergeCommit": {"oid": "cbdd0d6cf1c7033dde6cd51f41d52034fd59c59d"}, "closed": true, "closedAt": "2020-03-20T18:51:25Z", "author": {"login": "cadonna"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcMO5AxgH2gAyMzg2MDE2NjEwOjhhYWFkMDgzZjMyY2E2Nzk0NmE2YzNkZjdmOTU2NTBkZDM0OGMyNGM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcPTl0XgH2gAyMzg2MDE2NjEwOmIzNWIwYWIwZTU4NzQzYjg2MjlmYmZhZjNkYjdiMDdhODEyYmZhMjM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c", "author": {"user": {"login": "cadonna", "name": "Bruno Cadonna"}}, "url": "https://github.com/apache/kafka/commit/8aaad083f32ca67946a6c3df7f95650dd348c24c", "committedDate": "2020-03-10T09:14:07Z", "message": "[WIP] KAFKA-6145: Add constrained balanced assignment algorithm"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczMTMxODk4", "url": "https://github.com/apache/kafka/pull/8262#pullrequestreview-373131898", "createdAt": "2020-03-11T21:17:27Z", "commit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "state": "COMMENTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMToyMDoyNVrOF1JhDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMToyNDowNVrOF1OfWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI3NDc2NA==", "bodyText": "req: The clientId type should be UUID, or a generic for easier testing (c.f StickyTaskAssignor)", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391274764", "createdAt": "2020-03-11T21:20:25Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/StateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public interface StateConstrainedBalancedAssignor {\n+\n+    class ClientIdAndLag {\n+        private final String clientId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI3NTExMg==", "bodyText": "req: Lag should be a long", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391275112", "createdAt": "2020-03-11T21:21:10Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/StateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public interface StateConstrainedBalancedAssignor {\n+\n+    class ClientIdAndLag {\n+        private final String clientId;\n+        private final int lag;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI3NzM1NA==", "bodyText": "req: The client String should be a UUID (or generic, see comment below) here and elsewhere", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391277354", "createdAt": "2020-03-11T21:25:59Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI4MzU5OA==", "bodyText": "prop: make the value a SortedSet so we can just insert clients as we build the map and use a custom comparator to automatically sort the clients based on lag", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391283598", "createdAt": "2020-03-11T21:39:09Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI4OTA4NQ==", "bodyText": "req: I think we want to introduce some acceptableLag config within which a task is considered caught-up, otherwise this is way too strict. ie the condition should be lag <= acceptableLag", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391289085", "createdAt": "2020-03-11T21:52:17Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMjg0MA==", "bodyText": "See #8282", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391312840", "createdAt": "2020-03-11T22:46:23Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI4OTA4NQ=="}, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMyOTkwNA==", "bodyText": "req: rename to tasksToPreviousClients or something similar that works  \"previous\" into it", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391329904", "createdAt": "2020-03-11T23:39:52Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzMjc2MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n          \n          \n            \n                    // If a task was previously assigned to a client that that is caught-up and still exists, give it back", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391332761", "createdAt": "2020-03-11T23:49:17Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzMzA0OA==", "bodyText": "req: rename clientHostingTask -> previousHostingClient (or similar)", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391333048", "createdAt": "2020-03-11T23:50:25Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {\n+                final String clientHostingTask = tasksToHostClients.get(taskId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzNTU3Ng==", "bodyText": "req: drop the !caughtUpClients.isEmpty() check here, if it's in the map it should have at least 1 caught-up client", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391335576", "createdAt": "2020-03-11T23:59:09Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzNjQ3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return map from task IDs to lists of caught-up clients\n          \n          \n            \n                 * @return map from tasks with caught-up clients to the list of client candidates\n          \n      \n    \n    \n  \n\nor something similar to make it clear the map only contains tasks with caught-up clients", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391336470", "createdAt": "2020-03-12T00:02:27Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzODI3Mw==", "bodyText": "Hmm...I'm wondering if Map<String, List<TaskId>> previousAssignment is sufficient to pass in, won't we lose all the tasks that were assigned to a client that no longer exists for whatever reason? Maybe we should just pass in Map<TaskId, String> tasksToPreviousClients (aka tasksToHostClients) directly. We can build that map up during other steps in assign", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391338273", "createdAt": "2020-03-12T00:09:17Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzOTU3Nw==", "bodyText": "req: we'll never hit this, as taskToCaughtUpClients only contains tasks with caught-up clients IIUC. Can we just construct unassignedTasksWithoutCaughtUpClients as the set totalTasks - taskToCaughtUpClients.keySet? We can do that in assignTasksWithoutCaughtUpClients and remove unassignedTasksWithoutCaughtUpClients from assignTasksWithCaughtUpClients entirely", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391339577", "createdAt": "2020-03-12T00:14:30Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {\n+                final String clientHostingTask = tasksToHostClients.get(taskId);\n+                if (clientHostingTask != null && caughtUpClients.contains(clientHostingTask)) {\n+                    assignment.get(clientHostingTask).add(taskId);\n+                } else {\n+                    unassignedTasksWithCaughtUpClients.add(taskId);\n+                }\n+            } else {\n+                unassignedTasksWithoutCaughtUpClients.add(taskId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0MDA4Mw==", "bodyText": "Not sure if this will actually be cleaner or end up more complicated, but you may be able to reuse some of the StickyTaskAssignor code here which does similar things", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391340083", "createdAt": "2020-03-12T00:16:32Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {\n+                final String clientHostingTask = tasksToHostClients.get(taskId);\n+                if (clientHostingTask != null && caughtUpClients.contains(clientHostingTask)) {\n+                    assignment.get(clientHostingTask).add(taskId);\n+                } else {\n+                    unassignedTasksWithCaughtUpClients.add(taskId);\n+                }\n+            } else {\n+                unassignedTasksWithoutCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task has not been assigned to a caught-up client, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0MzM5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // If a task has not been assigned to a caught-up client, assign it to the caught-up client with the least tasks\n          \n          \n            \n                    // If a task's previous host client was not caught-up or no longer exists, assign it to the caught-up client with the least tasks", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391343391", "createdAt": "2020-03-12T00:29:50Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {\n+                final String clientHostingTask = tasksToHostClients.get(taskId);\n+                if (clientHostingTask != null && caughtUpClients.contains(clientHostingTask)) {\n+                    assignment.get(clientHostingTask).add(taskId);\n+                } else {\n+                    unassignedTasksWithCaughtUpClients.add(taskId);\n+                }\n+            } else {\n+                unassignedTasksWithoutCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task has not been assigned to a caught-up client, assign it to the caught-up client with the least tasks", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NDkxNQ==", "bodyText": "Actually, do we even need this at all? It seems like we get everything we need from statefulTasksToRankedClients -- it should have all tasks (and clients), and either\na) the previous client was caught-up, in which case it should be the first rank and we can determine it was the previous host from a lag of Task.LATEST_OFFSET, or\nb) the previous client was not caught-up, in which case we don't really care what the previous host was for that task", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391344915", "createdAt": "2020-03-12T00:35:34Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzODI3Mw=="}, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0NjAxNA==", "bodyText": "prop: rename taskCount -> minTaskCount", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391346014", "createdAt": "2020-03-12T00:40:24Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {\n+                final String clientHostingTask = tasksToHostClients.get(taskId);\n+                if (clientHostingTask != null && caughtUpClients.contains(clientHostingTask)) {\n+                    assignment.get(clientHostingTask).add(taskId);\n+                } else {\n+                    unassignedTasksWithCaughtUpClients.add(taskId);\n+                }\n+            } else {\n+                unassignedTasksWithoutCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task has not been assigned to a caught-up client, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {\n+            final List<String> caughtUpClients = tasksToCaughtUpClients.get(taskId);\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            for (final String client : caughtUpClients) {\n+                final int assignedTasksCount = assignment.get(client).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = client;\n+                    taskCount = assignedTasksCount;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Assigns tasks for which no caught-up clients exist.\n+     * A task is assigned to one of the clients with the least lag and the least tasks assigned.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param statefulTasksToRankedClients ranked clients map\n+     */\n+    private void assignTasksWithoutCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                   final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                   final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        for (final TaskId taskId : unassignedTasksWithoutCaughtUpClients) {\n+            List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.get(taskId);\n+            int previousLag = clientIdAndLags.get(0).lag();\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1MjU4Nw==", "bodyText": "prop: move this condition to a descriptively named and/or commented helper function, eg hasMoveableTask\n-- also would be nice to include brief explanation as to why we check the last task only (because all tasks that are caught-up come before the moveable/un-caught-up tasks?)", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391352587", "createdAt": "2020-03-12T01:07:49Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {\n+                final String clientHostingTask = tasksToHostClients.get(taskId);\n+                if (clientHostingTask != null && caughtUpClients.contains(clientHostingTask)) {\n+                    assignment.get(clientHostingTask).add(taskId);\n+                } else {\n+                    unassignedTasksWithCaughtUpClients.add(taskId);\n+                }\n+            } else {\n+                unassignedTasksWithoutCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task has not been assigned to a caught-up client, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {\n+            final List<String> caughtUpClients = tasksToCaughtUpClients.get(taskId);\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            for (final String client : caughtUpClients) {\n+                final int assignedTasksCount = assignment.get(client).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = client;\n+                    taskCount = assignedTasksCount;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Assigns tasks for which no caught-up clients exist.\n+     * A task is assigned to one of the clients with the least lag and the least tasks assigned.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param statefulTasksToRankedClients ranked clients map\n+     */\n+    private void assignTasksWithoutCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                   final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                   final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        for (final TaskId taskId : unassignedTasksWithoutCaughtUpClients) {\n+            List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.get(taskId);\n+            int previousLag = clientIdAndLags.get(0).lag();\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            int i = 0;\n+            while (clientIdAndLags.get(i).lag() == previousLag) {\n+                final String clientId = clientIdAndLags.get(i).clientId();\n+                final int assignedTasksCount = assignment.get(clientId).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = clientId;\n+                    taskCount = assignedTasksCount;\n+                }\n+                ++i;\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Balance the assignment.\n+     *\n+     * @param assignment assignment\n+     * @param balanceFactor balance factor\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void balance(final Map<String, List<TaskId>> assignment,\n+                         final int balanceFactor,\n+                         final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                         final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        final List<String> clients = new ArrayList<>(assignment.keySet());\n+        if (clients.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        Collections.sort(clients);\n+        for (final String client1 : clients) {\n+            for (final String client2 : clients) {\n+                final List<TaskId> taskIds1 = assignment.get(client1);\n+                final List<TaskId> taskIds2 =  assignment.get(client2);\n+                final List<TaskId> source = taskIds1.size() > taskIds2.size() ? taskIds1 : taskIds2;\n+                final List<TaskId> destination = source == taskIds1 ? taskIds2 : taskIds1;\n+                while (\n+                    source.size() - destination.size() > balanceFactor &&\n+                    !tasksToCaughtUpClients.containsKey(source.get(source.size() - 1))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1MzE0Nw==", "bodyText": "maybe also add a lastAssignedTask(List<TaskId>) helper to clean up source.get(source.size() - 1) used here and below", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391353147", "createdAt": "2020-03-12T01:10:17Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {\n+                final String clientHostingTask = tasksToHostClients.get(taskId);\n+                if (clientHostingTask != null && caughtUpClients.contains(clientHostingTask)) {\n+                    assignment.get(clientHostingTask).add(taskId);\n+                } else {\n+                    unassignedTasksWithCaughtUpClients.add(taskId);\n+                }\n+            } else {\n+                unassignedTasksWithoutCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task has not been assigned to a caught-up client, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {\n+            final List<String> caughtUpClients = tasksToCaughtUpClients.get(taskId);\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            for (final String client : caughtUpClients) {\n+                final int assignedTasksCount = assignment.get(client).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = client;\n+                    taskCount = assignedTasksCount;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Assigns tasks for which no caught-up clients exist.\n+     * A task is assigned to one of the clients with the least lag and the least tasks assigned.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param statefulTasksToRankedClients ranked clients map\n+     */\n+    private void assignTasksWithoutCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                   final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                   final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        for (final TaskId taskId : unassignedTasksWithoutCaughtUpClients) {\n+            List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.get(taskId);\n+            int previousLag = clientIdAndLags.get(0).lag();\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            int i = 0;\n+            while (clientIdAndLags.get(i).lag() == previousLag) {\n+                final String clientId = clientIdAndLags.get(i).clientId();\n+                final int assignedTasksCount = assignment.get(clientId).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = clientId;\n+                    taskCount = assignedTasksCount;\n+                }\n+                ++i;\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Balance the assignment.\n+     *\n+     * @param assignment assignment\n+     * @param balanceFactor balance factor\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void balance(final Map<String, List<TaskId>> assignment,\n+                         final int balanceFactor,\n+                         final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                         final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        final List<String> clients = new ArrayList<>(assignment.keySet());\n+        if (clients.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        Collections.sort(clients);\n+        for (final String client1 : clients) {\n+            for (final String client2 : clients) {\n+                final List<TaskId> taskIds1 = assignment.get(client1);\n+                final List<TaskId> taskIds2 =  assignment.get(client2);\n+                final List<TaskId> source = taskIds1.size() > taskIds2.size() ? taskIds1 : taskIds2;\n+                final List<TaskId> destination = source == taskIds1 ? taskIds2 : taskIds1;\n+                while (\n+                    source.size() - destination.size() > balanceFactor &&\n+                    !tasksToCaughtUpClients.containsKey(source.get(source.size() - 1))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1MjU4Nw=="}, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NTk2NQ==", "bodyText": "I'm a little confused with the use of destination here -- seems like we only use the destination client to see if we need to try and improve on the balance factor, but when actually moving tasks we loop through all the clients again looking for candidates with fewer assigned tasks.\nDo we need the second for (final String client2 : clients)  loop, or can we just loop through clients once and then for each one loop through rankedClients  to find candidates?", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391355965", "createdAt": "2020-03-12T01:22:50Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {\n+                final String clientHostingTask = tasksToHostClients.get(taskId);\n+                if (clientHostingTask != null && caughtUpClients.contains(clientHostingTask)) {\n+                    assignment.get(clientHostingTask).add(taskId);\n+                } else {\n+                    unassignedTasksWithCaughtUpClients.add(taskId);\n+                }\n+            } else {\n+                unassignedTasksWithoutCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task has not been assigned to a caught-up client, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {\n+            final List<String> caughtUpClients = tasksToCaughtUpClients.get(taskId);\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            for (final String client : caughtUpClients) {\n+                final int assignedTasksCount = assignment.get(client).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = client;\n+                    taskCount = assignedTasksCount;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Assigns tasks for which no caught-up clients exist.\n+     * A task is assigned to one of the clients with the least lag and the least tasks assigned.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param statefulTasksToRankedClients ranked clients map\n+     */\n+    private void assignTasksWithoutCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                   final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                   final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        for (final TaskId taskId : unassignedTasksWithoutCaughtUpClients) {\n+            List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.get(taskId);\n+            int previousLag = clientIdAndLags.get(0).lag();\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            int i = 0;\n+            while (clientIdAndLags.get(i).lag() == previousLag) {\n+                final String clientId = clientIdAndLags.get(i).clientId();\n+                final int assignedTasksCount = assignment.get(clientId).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = clientId;\n+                    taskCount = assignedTasksCount;\n+                }\n+                ++i;\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Balance the assignment.\n+     *\n+     * @param assignment assignment\n+     * @param balanceFactor balance factor\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void balance(final Map<String, List<TaskId>> assignment,\n+                         final int balanceFactor,\n+                         final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                         final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        final List<String> clients = new ArrayList<>(assignment.keySet());\n+        if (clients.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        Collections.sort(clients);\n+        for (final String client1 : clients) {\n+            for (final String client2 : clients) {\n+                final List<TaskId> taskIds1 = assignment.get(client1);\n+                final List<TaskId> taskIds2 =  assignment.get(client2);\n+                final List<TaskId> source = taskIds1.size() > taskIds2.size() ? taskIds1 : taskIds2;\n+                final List<TaskId> destination = source == taskIds1 ? taskIds2 : taskIds1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NjI0OA==", "bodyText": "req: If clients is empty I think we can/should catch it earlier, like back in initAssignment?", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391356248", "createdAt": "2020-03-12T01:24:05Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {\n+                final String clientHostingTask = tasksToHostClients.get(taskId);\n+                if (clientHostingTask != null && caughtUpClients.contains(clientHostingTask)) {\n+                    assignment.get(clientHostingTask).add(taskId);\n+                } else {\n+                    unassignedTasksWithCaughtUpClients.add(taskId);\n+                }\n+            } else {\n+                unassignedTasksWithoutCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task has not been assigned to a caught-up client, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {\n+            final List<String> caughtUpClients = tasksToCaughtUpClients.get(taskId);\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            for (final String client : caughtUpClients) {\n+                final int assignedTasksCount = assignment.get(client).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = client;\n+                    taskCount = assignedTasksCount;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Assigns tasks for which no caught-up clients exist.\n+     * A task is assigned to one of the clients with the least lag and the least tasks assigned.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param statefulTasksToRankedClients ranked clients map\n+     */\n+    private void assignTasksWithoutCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                   final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                   final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        for (final TaskId taskId : unassignedTasksWithoutCaughtUpClients) {\n+            List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.get(taskId);\n+            int previousLag = clientIdAndLags.get(0).lag();\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            int i = 0;\n+            while (clientIdAndLags.get(i).lag() == previousLag) {\n+                final String clientId = clientIdAndLags.get(i).clientId();\n+                final int assignedTasksCount = assignment.get(clientId).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = clientId;\n+                    taskCount = assignedTasksCount;\n+                }\n+                ++i;\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Balance the assignment.\n+     *\n+     * @param assignment assignment\n+     * @param balanceFactor balance factor\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void balance(final Map<String, List<TaskId>> assignment,\n+                         final int balanceFactor,\n+                         final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                         final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        final List<String> clients = new ArrayList<>(assignment.keySet());\n+        if (clients.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 189}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36e5cdcb619f90b85e264d94a95b7175b96699fc", "author": {"user": {"login": "cadonna", "name": "Bruno Cadonna"}}, "url": "https://github.com/apache/kafka/commit/36e5cdcb619f90b85e264d94a95b7175b96699fc", "committedDate": "2020-03-12T10:03:50Z", "message": "Update streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java\n\nCo-Authored-By: A. Sophie Blee-Goldman <ableegoldman@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf9453fa0a71f3b4d758fde3bb002951219a031d", "author": {"user": {"login": "cadonna", "name": "Bruno Cadonna"}}, "url": "https://github.com/apache/kafka/commit/bf9453fa0a71f3b4d758fde3bb002951219a031d", "committedDate": "2020-03-12T10:18:26Z", "message": "Update streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java\n\nCo-Authored-By: A. Sophie Blee-Goldman <ableegoldman@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNDE3MDgw", "url": "https://github.com/apache/kafka/pull/8262#pullrequestreview-373417080", "createdAt": "2020-03-12T10:01:35Z", "commit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMDowMTozNVrOF1YClw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxMzoxMTo1MFrOF1d9hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUxMjcyNw==", "bodyText": "I assumed, the algorithm gets statefulTasksToRankedClients already \"normalized\" as described in KIP-441 with 0 for all caught-up clients. With caught-up clients, I mean clients with an acceptable lag. I was not aware of Task.LATEST_OFFSET before I reviewed your PR about the offset sums.\nI guess the question to answer is what is passed to this algorithm.\nAFAIU, statefulTasksToRankedClients should also be passed to the proposeBalancedAssignment() algorithm. That means, we should pass the \"normalized\" version of statefulTasksToRankedClients to this algorithm. I guess StreamsPartitionAssignor#buildClientRankingsByTask() is the right place to construct this map. Still we could use Task.LATEST_OFFSET to encode the client that previously hosted the task and remove previousAssignment.", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391512727", "createdAt": "2020-03-12T10:01:35Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzODI3Mw=="}, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUxNDg3NA==", "bodyText": "I guess my comment above answers this comment.", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391514874", "createdAt": "2020-03-12T10:05:34Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI4OTA4NQ=="}, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUxODk5OA==", "bodyText": "True! I also wondering, why I check for null. They must be some refactoring artefacts.", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391518998", "createdAt": "2020-03-12T10:13:16Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzNTU3Ng=="}, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUzNTQ4MQ==", "bodyText": "Good that you mentioned the easier testing. I was wondering why it was a generic.", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391535481", "createdAt": "2020-03-12T10:43:41Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/StateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public interface StateConstrainedBalancedAssignor {\n+\n+    class ClientIdAndLag {\n+        private final String clientId;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI3NDc2NA=="}, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU5NzI1OA==", "bodyText": "I like the idea. Will try to realize it.", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391597258", "createdAt": "2020-03-12T12:48:39Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {\n+                final String clientHostingTask = tasksToHostClients.get(taskId);\n+                if (clientHostingTask != null && caughtUpClients.contains(clientHostingTask)) {\n+                    assignment.get(clientHostingTask).add(taskId);\n+                } else {\n+                    unassignedTasksWithCaughtUpClients.add(taskId);\n+                }\n+            } else {\n+                unassignedTasksWithoutCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task has not been assigned to a caught-up client, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {\n+            final List<String> caughtUpClients = tasksToCaughtUpClients.get(taskId);\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            for (final String client : caughtUpClients) {\n+                final int assignedTasksCount = assignment.get(client).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = client;\n+                    taskCount = assignedTasksCount;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Assigns tasks for which no caught-up clients exist.\n+     * A task is assigned to one of the clients with the least lag and the least tasks assigned.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param statefulTasksToRankedClients ranked clients map\n+     */\n+    private void assignTasksWithoutCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                   final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                   final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        for (final TaskId taskId : unassignedTasksWithoutCaughtUpClients) {\n+            List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.get(taskId);\n+            int previousLag = clientIdAndLags.get(0).lag();\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            int i = 0;\n+            while (clientIdAndLags.get(i).lag() == previousLag) {\n+                final String clientId = clientIdAndLags.get(i).clientId();\n+                final int assignedTasksCount = assignment.get(clientId).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = clientId;\n+                    taskCount = assignedTasksCount;\n+                }\n+                ++i;\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Balance the assignment.\n+     *\n+     * @param assignment assignment\n+     * @param balanceFactor balance factor\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void balance(final Map<String, List<TaskId>> assignment,\n+                         final int balanceFactor,\n+                         final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                         final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        final List<String> clients = new ArrayList<>(assignment.keySet());\n+        if (clients.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        Collections.sort(clients);\n+        for (final String client1 : clients) {\n+            for (final String client2 : clients) {\n+                final List<TaskId> taskIds1 = assignment.get(client1);\n+                final List<TaskId> taskIds2 =  assignment.get(client2);\n+                final List<TaskId> source = taskIds1.size() > taskIds2.size() ? taskIds1 : taskIds2;\n+                final List<TaskId> destination = source == taskIds1 ? taskIds2 : taskIds1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1NTk2NQ=="}, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTYwOTczMw==", "bodyText": "Ack", "url": "https://github.com/apache/kafka/pull/8262#discussion_r391609733", "createdAt": "2020-03-12T13:11:50Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {\n+        this.previousAssignment = previousAssignment;\n+    }\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<String, List<TaskId>> assign(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                                            final int balanceFactor) {\n+        final Map<String, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<String>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithoutCaughtUpClients = new ArrayList<>();\n+        assignTasksWithCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            tasksToCaughtUpClients\n+        );\n+        assignTasksWithoutCaughtUpClients(\n+            assignment,\n+            unassignedTasksWithoutCaughtUpClients,\n+            statefulTasksToRankedClients\n+        );\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<String, List<TaskId>> initAssignment(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<String, List<TaskId>> assignment = new HashMap<>();\n+        final List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from task IDs to lists of caught-up clients\n+     */\n+    private Map<TaskId, List<String>> tasksToCaughtUpClients(final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<String>> taskToCaughtUpClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, List<ClientIdAndLag>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final List<ClientIdAndLag> clientRanking = taskToRankedClient.getValue();\n+            final List<String> caughtUpClients = new ArrayList<>();\n+            int i = 0;\n+            while (clientRanking.get(i).lag() == 0) {\n+                final TaskId taskId = taskToRankedClient.getKey();\n+                taskToCaughtUpClients\n+                    .computeIfAbsent(taskId, ignored -> caughtUpClients).add(clientRanking.get(i).clientId());\n+                ++i;\n+            }\n+            Collections.sort(caughtUpClients);\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, String> tasksToHostClients() {\n+        final Map<TaskId, String> tasksToHostClients = new HashMap<>();\n+        for (final Map.Entry<String, List<TaskId>> clientToTasks : previousAssignment.entrySet()) {\n+            for (final TaskId taskId : clientToTasks.getValue()) {\n+                tasksToHostClients.put(taskId, clientToTasks.getKey());\n+            }\n+        }\n+        return tasksToHostClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        // If a task has already been assigned to a caught-up client that still exists, assign it back to the client\n+        final Map<TaskId, String> tasksToHostClients = tasksToHostClients();\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<String>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<String> caughtUpClients = taskToCaughtUpClients.getValue();\n+            if (caughtUpClients != null && !caughtUpClients.isEmpty()) {\n+                final String clientHostingTask = tasksToHostClients.get(taskId);\n+                if (clientHostingTask != null && caughtUpClients.contains(clientHostingTask)) {\n+                    assignment.get(clientHostingTask).add(taskId);\n+                } else {\n+                    unassignedTasksWithCaughtUpClients.add(taskId);\n+                }\n+            } else {\n+                unassignedTasksWithoutCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task has not been assigned to a caught-up client, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {\n+            final List<String> caughtUpClients = tasksToCaughtUpClients.get(taskId);\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            for (final String client : caughtUpClients) {\n+                final int assignedTasksCount = assignment.get(client).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = client;\n+                    taskCount = assignedTasksCount;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Assigns tasks for which no caught-up clients exist.\n+     * A task is assigned to one of the clients with the least lag and the least tasks assigned.\n+     *\n+     * @param assignment assignment\n+     * @param unassignedTasksWithoutCaughtUpClients list of task that could not be assigned since no caught-up client exists for them\n+     * @param statefulTasksToRankedClients ranked clients map\n+     */\n+    private void assignTasksWithoutCaughtUpClients(final Map<String, List<TaskId>> assignment,\n+                                                   final List<TaskId> unassignedTasksWithoutCaughtUpClients,\n+                                                   final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients) {\n+        for (final TaskId taskId : unassignedTasksWithoutCaughtUpClients) {\n+            List<ClientIdAndLag> clientIdAndLags = statefulTasksToRankedClients.get(taskId);\n+            int previousLag = clientIdAndLags.get(0).lag();\n+            String clientWithLeastTasks = null;\n+            int taskCount = Integer.MAX_VALUE;\n+            int i = 0;\n+            while (clientIdAndLags.get(i).lag() == previousLag) {\n+                final String clientId = clientIdAndLags.get(i).clientId();\n+                final int assignedTasksCount = assignment.get(clientId).size();\n+                if (taskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = clientId;\n+                    taskCount = assignedTasksCount;\n+                }\n+                ++i;\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Balance the assignment.\n+     *\n+     * @param assignment assignment\n+     * @param balanceFactor balance factor\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void balance(final Map<String, List<TaskId>> assignment,\n+                         final int balanceFactor,\n+                         final Map<TaskId, List<ClientIdAndLag>> statefulTasksToRankedClients,\n+                         final Map<TaskId, List<String>> tasksToCaughtUpClients) {\n+        final List<String> clients = new ArrayList<>(assignment.keySet());\n+        if (clients.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        Collections.sort(clients);\n+        for (final String client1 : clients) {\n+            for (final String client2 : clients) {\n+                final List<TaskId> taskIds1 = assignment.get(client1);\n+                final List<TaskId> taskIds2 =  assignment.get(client2);\n+                final List<TaskId> source = taskIds1.size() > taskIds2.size() ? taskIds1 : taskIds2;\n+                final List<TaskId> destination = source == taskIds1 ? taskIds2 : taskIds1;\n+                while (\n+                    source.size() - destination.size() > balanceFactor &&\n+                    !tasksToCaughtUpClients.containsKey(source.get(source.size() - 1))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1MjU4Nw=="}, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 200}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8372c270297778efa59299f50be310ffcb1a6560", "author": {"user": {"login": "cadonna", "name": "Bruno Cadonna"}}, "url": "https://github.com/apache/kafka/commit/8372c270297778efa59299f50be310ffcb1a6560", "committedDate": "2020-03-12T14:52:38Z", "message": "Include feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "author": {"user": {"login": "cadonna", "name": "Bruno Cadonna"}}, "url": "https://github.com/apache/kafka/commit/5987b9c462772ac9cc43fa8bc16e407b3ae654d5", "committedDate": "2020-03-13T13:40:14Z", "message": "Add unit tests for state constrained balanced assignment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NjQ5ODA3", "url": "https://github.com/apache/kafka/pull/8262#pullrequestreview-374649807", "createdAt": "2020-03-13T22:21:56Z", "commit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMjoyMTo1NlrOF2VAvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMjoyOToyOVrOF2VImg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxMTY3OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n          \n          \n            \n                 * Assigns tasks for which one or more caught-up clients exist to one of the caught-up clients.", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392511679", "createdAt": "2020-03-13T22:21:56Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, ID> tasksToPreviousClients(final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, ID> tasksToPreviousClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClients : statefulTasksToRankedClients.entrySet()) {\n+            final ClientIdAndLag<ID> topRankedClient = taskToRankedClients.getValue().first();\n+            if (topRankedClient.lag() == Task.LATEST_OFFSET) {\n+                tasksToPreviousClients.put(taskToRankedClients.getKey(), topRankedClient.clientId());\n+            }\n+        }\n+        return tasksToPreviousClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxMjI3Mg==", "bodyText": "I think you mentioned this in another comment, but we can drop the null check here right? There should never be an entry with a null value here", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392512272", "createdAt": "2020-03-13T22:24:12Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, ID> tasksToPreviousClients(final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, ID> tasksToPreviousClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClients : statefulTasksToRankedClients.entrySet()) {\n+            final ClientIdAndLag<ID> topRankedClient = taskToRankedClients.getValue().first();\n+            if (topRankedClient.lag() == Task.LATEST_OFFSET) {\n+                tasksToPreviousClients.put(taskToRankedClients.getKey(), topRankedClient.clientId());\n+            }\n+        }\n+        return tasksToPreviousClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        // If a task was previously assigned to a client that is caught-up and still exists, give it back to the client\n+        final Map<TaskId, ID> tasksToPreviousClients = tasksToPreviousClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<ID>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<ID> caughtUpClients = taskToCaughtUpClients.getValue();\n+            final ID previousHostingClients = tasksToPreviousClients.get(taskId);\n+            if (previousHostingClients != null && caughtUpClients.contains(previousHostingClients)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxMjUzMA==", "bodyText": "prop: rename taskToCaughtUpClient to taskEntry or something, looks confusingly similar to tasksToCaughtUpClients", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392512530", "createdAt": "2020-03-13T22:25:12Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, ID> tasksToPreviousClients(final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, ID> tasksToPreviousClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClients : statefulTasksToRankedClients.entrySet()) {\n+            final ClientIdAndLag<ID> topRankedClient = taskToRankedClients.getValue().first();\n+            if (topRankedClient.lag() == Task.LATEST_OFFSET) {\n+                tasksToPreviousClients.put(taskToRankedClients.getKey(), topRankedClient.clientId());\n+            }\n+        }\n+        return tasksToPreviousClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        // If a task was previously assigned to a client that is caught-up and still exists, give it back to the client\n+        final Map<TaskId, ID> tasksToPreviousClients = tasksToPreviousClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<ID>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxMzY5MA==", "bodyText": "We synced on this, and agreed this map should be \"normalized\" as described above (ie all caught-up clients are encoded with 0, or Task.LATEST_OFFSET if they had the active task)", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392513690", "createdAt": "2020-03-13T22:29:29Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,218 @@\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class DefaultStateConstrainedBalancedAssignor implements StateConstrainedBalancedAssignor {\n+\n+    private final Map<String, List<TaskId>> previousAssignment;\n+\n+    public DefaultStateConstrainedBalancedAssignor(final Map<String, List<TaskId>> previousAssignment) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzODI3Mw=="}, "originalCommit": {"oid": "8aaad083f32ca67946a6c3df7f95650dd348c24c"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NjU4Mjk3", "url": "https://github.com/apache/kafka/pull/8262#pullrequestreview-374658297", "createdAt": "2020-03-13T22:50:55Z", "commit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMjo1MDo1NlrOF2Vcwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMzoyOToyM1rOF2V88Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxODg1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n          \n          \n            \n                    for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n          \n          \n            \n                        final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n          \n          \n            \n                        for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n          \n          \n            \n                            if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n          \n          \n            \n                                final TaskId taskId = taskToRankedClient.getKey();\n          \n          \n            \n                                taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n          \n          \n            \n                            } else {\n          \n          \n            \n                                break;\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    return taskToCaughtUpClients;\n          \n          \n            \n                    final Map<TaskId, List<ID>> taskToCaughtUpClients =\n          \n          \n            \n                        statefulTasksToRankedClients.entrySet().stream().collect(Collectors.toMap(\n          \n          \n            \n                            Entry::getKey, \n          \n          \n            \n                            t -> t.getValue().stream()\n          \n          \n            \n                                     .filter(c -> c.lag() == 0 || c.lag() == Task.LATEST_OFFSET)\n          \n          \n            \n                                     .map(ClientIdAndLag::clientId)\n          \n          \n            \n                                     .collect(Collectors.toList())));", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392518850", "createdAt": "2020-03-13T22:50:56Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMTg5OA==", "bodyText": "Since this only returns tasks whose previous client was caught up, I think we can simplify the first half of assignTasksWithCaughtUpClients  as just\ntasksToPreviousClients.forEach((t, c) -> assignment.computeIfPresent(c, (k, v) -> { v.add(t);  return v;}));\nunassignedTasksWithCaughtUpClients = new ArrayList<>(tasksToCaughtUpClients.keySet());\nunassignedTasksWithCaughtUpClients.removeAll(tasksToPreviousClients.keySet());", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392521898", "createdAt": "2020-03-13T23:04:22Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, ID> tasksToPreviousClients(final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, ID> tasksToPreviousClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClients : statefulTasksToRankedClients.entrySet()) {\n+            final ClientIdAndLag<ID> topRankedClient = taskToRankedClients.getValue().first();\n+            if (topRankedClient.lag() == Task.LATEST_OFFSET) {\n+                tasksToPreviousClients.put(taskToRankedClients.getKey(), topRankedClient.clientId());\n+            }\n+        }\n+        return tasksToPreviousClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        // If a task was previously assigned to a client that is caught-up and still exists, give it back to the client\n+        final Map<TaskId, ID> tasksToPreviousClients = tasksToPreviousClients(statefulTasksToRankedClients);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMjIwOA==", "bodyText": "req: clarify (either in name or in javadocs) that this only returns tasks whose previous client was caught-up (ie the task got to RUNNING)", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392522208", "createdAt": "2020-03-13T23:05:44Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, ID> tasksToPreviousClients(final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMzA5Nw==", "bodyText": "req: I think we need to iterate forwards in this case?", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392523097", "createdAt": "2020-03-13T23:09:07Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, ID> tasksToPreviousClients(final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, ID> tasksToPreviousClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClients : statefulTasksToRankedClients.entrySet()) {\n+            final ClientIdAndLag<ID> topRankedClient = taskToRankedClients.getValue().first();\n+            if (topRankedClient.lag() == Task.LATEST_OFFSET) {\n+                tasksToPreviousClients.put(taskToRankedClients.getKey(), topRankedClient.clientId());\n+            }\n+        }\n+        return tasksToPreviousClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        // If a task was previously assigned to a client that is caught-up and still exists, give it back to the client\n+        final Map<TaskId, ID> tasksToPreviousClients = tasksToPreviousClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<ID>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<ID> caughtUpClients = taskToCaughtUpClients.getValue();\n+            final ID previousHostingClients = tasksToPreviousClients.get(taskId);\n+            if (previousHostingClients != null && caughtUpClients.contains(previousHostingClients)) {\n+                assignment.get(previousHostingClients).add(taskId);\n+            } else {\n+                unassignedTasksWithCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task's previous host client was not caught-up or no longer exists, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {\n+            final List<ID> caughtUpClients = tasksToCaughtUpClients.get(taskId);\n+            ID clientWithLeastTasks = null;\n+            int minTaskCount = Integer.MAX_VALUE;\n+            for (final ID client : caughtUpClients) {\n+                final int assignedTasksCount = assignment.get(client).size();\n+                if (minTaskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = client;\n+                    minTaskCount = assignedTasksCount;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Assigns tasks for which no caught-up clients exist.\n+     * A task is assigned to one of the clients with the least lag and the least tasks assigned.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     * @param statefulTasksToRankedClients ranked clients map\n+     */\n+    private void assignTasksWithoutCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                   final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                   final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final SortedSet<TaskId> unassignedTasksWithoutCaughtUpClients = new TreeSet<>(statefulTasksToRankedClients.keySet());\n+        unassignedTasksWithoutCaughtUpClients.removeAll(tasksToCaughtUpClients.keySet());\n+        for (final TaskId taskId : unassignedTasksWithoutCaughtUpClients) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = statefulTasksToRankedClients.get(taskId);\n+            final long minLag = rankedClients.first().lag();\n+            int minTasksCount = Integer.MAX_VALUE;\n+            ID clientWithLeastTasks = rankedClients.first().clientId();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == minLag) {\n+                    final ID clientId = clientIdAndLag.clientId();\n+                    final int assignedTasksCount = assignment.get(clientId).size();\n+                    if (minTasksCount > assignedTasksCount) {\n+                        clientWithLeastTasks = clientId;\n+                        minTasksCount = assignedTasksCount;\n+                    }\n+                } else {\n+                    break;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Balance the assignment.\n+     *\n+     * @param assignment assignment\n+     * @param balanceFactor balance factor\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void balance(final Map<ID, List<TaskId>> assignment,\n+                         final int balanceFactor,\n+                         final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                         final Map<TaskId, List<ID>> tasksToCaughtUpClients) {\n+        final List<ID> clients = new ArrayList<>(assignment.keySet());\n+        Collections.sort(clients);\n+        for (final ID client : clients) {\n+            final List<TaskId> source = assignment.get(client);\n+            for (final TaskId task : assignedTasksWithoutCaughtUpClients(source, tasksToCaughtUpClients)) {\n+                for (final ClientIdAndLag<ID> clientAndLag : statefulTasksToRankedClients.get(task)) {\n+                    final List<TaskId> destination = assignment.get(clientAndLag.clientId());\n+                    if (source.size() - destination.size() > balanceFactor) {\n+                        source.remove(task);\n+                        destination.add(task);\n+                    }\n+                }\n+            }\n+            for (final TaskId task : assignedTasksWithCaughtUpClients(source, tasksToCaughtUpClients)) {\n+                for (final ID caughtUpClient : tasksToCaughtUpClients.get(task)) {\n+                    final List<TaskId> destination = assignment.get(caughtUpClient);\n+                    if (source.size() - destination.size() > balanceFactor) {\n+                        source.remove(task);\n+                        destination.add(task);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns a sublist of tasks in the given list that does not have a caught-up client.\n+     *\n+     * @param tasks list of task IDs\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     * @return a list of task IDs that does not have a caught-up client\n+     */\n+    private List<TaskId> assignedTasksWithoutCaughtUpClients(final List<TaskId> tasks,\n+                                                             final Map<TaskId, List<ID>> tasksToCaughtUpClients) {\n+        final List<TaskId> tasksWithoutCaughtUpClients = new ArrayList<>();\n+        for (int i = tasks.size() - 1; i >= 0; --i) {\n+            final TaskId task = tasks.get(i);\n+            if (!tasksToCaughtUpClients.containsKey(task)) {\n+                tasksWithoutCaughtUpClients.add(task);\n+            } else {\n+                break;\n+            }\n+        }\n+        return Collections.unmodifiableList(tasksWithoutCaughtUpClients);\n+    }\n+    private List<TaskId> assignedTasksWithCaughtUpClients(final List<TaskId> tasks,\n+                                                          final Map<TaskId, List<ID>> tasksToCaughtUpClients) {\n+        final List<TaskId> tasksWithCaughtUpClients = new ArrayList<>();\n+        for (int i = tasks.size() - 1; i >= 0; --i) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMzIxMw==", "bodyText": "Nice helper, this makes the balance code a lot easier to read", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392523213", "createdAt": "2020-03-13T23:09:41Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, ID> tasksToPreviousClients(final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, ID> tasksToPreviousClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClients : statefulTasksToRankedClients.entrySet()) {\n+            final ClientIdAndLag<ID> topRankedClient = taskToRankedClients.getValue().first();\n+            if (topRankedClient.lag() == Task.LATEST_OFFSET) {\n+                tasksToPreviousClients.put(taskToRankedClients.getKey(), topRankedClient.clientId());\n+            }\n+        }\n+        return tasksToPreviousClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        // If a task was previously assigned to a client that is caught-up and still exists, give it back to the client\n+        final Map<TaskId, ID> tasksToPreviousClients = tasksToPreviousClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<ID>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<ID> caughtUpClients = taskToCaughtUpClients.getValue();\n+            final ID previousHostingClients = tasksToPreviousClients.get(taskId);\n+            if (previousHostingClients != null && caughtUpClients.contains(previousHostingClients)) {\n+                assignment.get(previousHostingClients).add(taskId);\n+            } else {\n+                unassignedTasksWithCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task's previous host client was not caught-up or no longer exists, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {\n+            final List<ID> caughtUpClients = tasksToCaughtUpClients.get(taskId);\n+            ID clientWithLeastTasks = null;\n+            int minTaskCount = Integer.MAX_VALUE;\n+            for (final ID client : caughtUpClients) {\n+                final int assignedTasksCount = assignment.get(client).size();\n+                if (minTaskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = client;\n+                    minTaskCount = assignedTasksCount;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Assigns tasks for which no caught-up clients exist.\n+     * A task is assigned to one of the clients with the least lag and the least tasks assigned.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     * @param statefulTasksToRankedClients ranked clients map\n+     */\n+    private void assignTasksWithoutCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                   final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                   final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final SortedSet<TaskId> unassignedTasksWithoutCaughtUpClients = new TreeSet<>(statefulTasksToRankedClients.keySet());\n+        unassignedTasksWithoutCaughtUpClients.removeAll(tasksToCaughtUpClients.keySet());\n+        for (final TaskId taskId : unassignedTasksWithoutCaughtUpClients) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = statefulTasksToRankedClients.get(taskId);\n+            final long minLag = rankedClients.first().lag();\n+            int minTasksCount = Integer.MAX_VALUE;\n+            ID clientWithLeastTasks = rankedClients.first().clientId();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == minLag) {\n+                    final ID clientId = clientIdAndLag.clientId();\n+                    final int assignedTasksCount = assignment.get(clientId).size();\n+                    if (minTasksCount > assignedTasksCount) {\n+                        clientWithLeastTasks = clientId;\n+                        minTasksCount = assignedTasksCount;\n+                    }\n+                } else {\n+                    break;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Balance the assignment.\n+     *\n+     * @param assignment assignment\n+     * @param balanceFactor balance factor\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void balance(final Map<ID, List<TaskId>> assignment,\n+                         final int balanceFactor,\n+                         final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                         final Map<TaskId, List<ID>> tasksToCaughtUpClients) {\n+        final List<ID> clients = new ArrayList<>(assignment.keySet());\n+        Collections.sort(clients);\n+        for (final ID client : clients) {\n+            final List<TaskId> source = assignment.get(client);\n+            for (final TaskId task : assignedTasksWithoutCaughtUpClients(source, tasksToCaughtUpClients)) {\n+                for (final ClientIdAndLag<ID> clientAndLag : statefulTasksToRankedClients.get(task)) {\n+                    final List<TaskId> destination = assignment.get(clientAndLag.clientId());\n+                    if (source.size() - destination.size() > balanceFactor) {\n+                        source.remove(task);\n+                        destination.add(task);\n+                    }\n+                }\n+            }\n+            for (final TaskId task : assignedTasksWithCaughtUpClients(source, tasksToCaughtUpClients)) {\n+                for (final ID caughtUpClient : tasksToCaughtUpClients.get(task)) {\n+                    final List<TaskId> destination = assignment.get(caughtUpClient);\n+                    if (source.size() - destination.size() > balanceFactor) {\n+                        source.remove(task);\n+                        destination.add(task);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns a sublist of tasks in the given list that does not have a caught-up client.\n+     *\n+     * @param tasks list of task IDs\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     * @return a list of task IDs that does not have a caught-up client\n+     */\n+    private List<TaskId> assignedTasksWithoutCaughtUpClients(final List<TaskId> tasks,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMzQ4MA==", "bodyText": "(just a suggestion based on what I personally find easier to read)", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392523480", "createdAt": "2020-03-13T23:11:01Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxODg1MA=="}, "originalCommit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNTU1NQ==", "bodyText": "req: should we break out of the statefulTasksToRankedClients loop here?", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392525555", "createdAt": "2020-03-13T23:21:23Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, ID> tasksToPreviousClients(final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, ID> tasksToPreviousClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClients : statefulTasksToRankedClients.entrySet()) {\n+            final ClientIdAndLag<ID> topRankedClient = taskToRankedClients.getValue().first();\n+            if (topRankedClient.lag() == Task.LATEST_OFFSET) {\n+                tasksToPreviousClients.put(taskToRankedClients.getKey(), topRankedClient.clientId());\n+            }\n+        }\n+        return tasksToPreviousClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        // If a task was previously assigned to a client that is caught-up and still exists, give it back to the client\n+        final Map<TaskId, ID> tasksToPreviousClients = tasksToPreviousClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<ID>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<ID> caughtUpClients = taskToCaughtUpClients.getValue();\n+            final ID previousHostingClients = tasksToPreviousClients.get(taskId);\n+            if (previousHostingClients != null && caughtUpClients.contains(previousHostingClients)) {\n+                assignment.get(previousHostingClients).add(taskId);\n+            } else {\n+                unassignedTasksWithCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task's previous host client was not caught-up or no longer exists, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {\n+            final List<ID> caughtUpClients = tasksToCaughtUpClients.get(taskId);\n+            ID clientWithLeastTasks = null;\n+            int minTaskCount = Integer.MAX_VALUE;\n+            for (final ID client : caughtUpClients) {\n+                final int assignedTasksCount = assignment.get(client).size();\n+                if (minTaskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = client;\n+                    minTaskCount = assignedTasksCount;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Assigns tasks for which no caught-up clients exist.\n+     * A task is assigned to one of the clients with the least lag and the least tasks assigned.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     * @param statefulTasksToRankedClients ranked clients map\n+     */\n+    private void assignTasksWithoutCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                   final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                   final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final SortedSet<TaskId> unassignedTasksWithoutCaughtUpClients = new TreeSet<>(statefulTasksToRankedClients.keySet());\n+        unassignedTasksWithoutCaughtUpClients.removeAll(tasksToCaughtUpClients.keySet());\n+        for (final TaskId taskId : unassignedTasksWithoutCaughtUpClients) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = statefulTasksToRankedClients.get(taskId);\n+            final long minLag = rankedClients.first().lag();\n+            int minTasksCount = Integer.MAX_VALUE;\n+            ID clientWithLeastTasks = rankedClients.first().clientId();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == minLag) {\n+                    final ID clientId = clientIdAndLag.clientId();\n+                    final int assignedTasksCount = assignment.get(clientId).size();\n+                    if (minTasksCount > assignedTasksCount) {\n+                        clientWithLeastTasks = clientId;\n+                        minTasksCount = assignedTasksCount;\n+                    }\n+                } else {\n+                    break;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Balance the assignment.\n+     *\n+     * @param assignment assignment\n+     * @param balanceFactor balance factor\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void balance(final Map<ID, List<TaskId>> assignment,\n+                         final int balanceFactor,\n+                         final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                         final Map<TaskId, List<ID>> tasksToCaughtUpClients) {\n+        final List<ID> clients = new ArrayList<>(assignment.keySet());\n+        Collections.sort(clients);\n+        for (final ID client : clients) {\n+            final List<TaskId> source = assignment.get(client);\n+            for (final TaskId task : assignedTasksWithoutCaughtUpClients(source, tasksToCaughtUpClients)) {\n+                for (final ClientIdAndLag<ID> clientAndLag : statefulTasksToRankedClients.get(task)) {\n+                    final List<TaskId> destination = assignment.get(clientAndLag.clientId());\n+                    if (source.size() - destination.size() > balanceFactor) {\n+                        source.remove(task);\n+                        destination.add(task);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNTgzMA==", "bodyText": "same here", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392525830", "createdAt": "2020-03-13T23:22:46Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = taskToRankedClient.getValue();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == Task.LATEST_OFFSET || clientIdAndLag.lag() == 0) {\n+                    final TaskId taskId = taskToRankedClient.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new ArrayList<>()).add(clientIdAndLag.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+\n+    /**\n+     * Maps a task to the client that host the task according to the previous assignment.\n+     *\n+     * @return map from task IDs to clients hosting the corresponding task\n+     */\n+    private Map<TaskId, ID> tasksToPreviousClients(final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, ID> tasksToPreviousClients = new HashMap<>();\n+        for (final Map.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClients : statefulTasksToRankedClients.entrySet()) {\n+            final ClientIdAndLag<ID> topRankedClient = taskToRankedClients.getValue().first();\n+            if (topRankedClient.lag() == Task.LATEST_OFFSET) {\n+                tasksToPreviousClients.put(taskToRankedClients.getKey(), topRankedClient.clientId());\n+            }\n+        }\n+        return tasksToPreviousClients;\n+    }\n+\n+    /**\n+     * Assigns task for which one or more caught-up clients exist to one of the caught-up clients.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void assignTasksWithCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        // If a task was previously assigned to a client that is caught-up and still exists, give it back to the client\n+        final Map<TaskId, ID> tasksToPreviousClients = tasksToPreviousClients(statefulTasksToRankedClients);\n+        final List<TaskId> unassignedTasksWithCaughtUpClients = new ArrayList<>();\n+        for (final Map.Entry<TaskId, List<ID>> taskToCaughtUpClients : tasksToCaughtUpClients.entrySet()) {\n+            final TaskId taskId = taskToCaughtUpClients.getKey();\n+            final List<ID> caughtUpClients = taskToCaughtUpClients.getValue();\n+            final ID previousHostingClients = tasksToPreviousClients.get(taskId);\n+            if (previousHostingClients != null && caughtUpClients.contains(previousHostingClients)) {\n+                assignment.get(previousHostingClients).add(taskId);\n+            } else {\n+                unassignedTasksWithCaughtUpClients.add(taskId);\n+            }\n+        }\n+        // If a task's previous host client was not caught-up or no longer exists, assign it to the caught-up client with the least tasks\n+        for (final TaskId taskId : unassignedTasksWithCaughtUpClients) {\n+            final List<ID> caughtUpClients = tasksToCaughtUpClients.get(taskId);\n+            ID clientWithLeastTasks = null;\n+            int minTaskCount = Integer.MAX_VALUE;\n+            for (final ID client : caughtUpClients) {\n+                final int assignedTasksCount = assignment.get(client).size();\n+                if (minTaskCount > assignedTasksCount) {\n+                    clientWithLeastTasks = client;\n+                    minTaskCount = assignedTasksCount;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Assigns tasks for which no caught-up clients exist.\n+     * A task is assigned to one of the clients with the least lag and the least tasks assigned.\n+     *\n+     * @param assignment assignment\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     * @param statefulTasksToRankedClients ranked clients map\n+     */\n+    private void assignTasksWithoutCaughtUpClients(final Map<ID, List<TaskId>> assignment,\n+                                                   final Map<TaskId, List<ID>> tasksToCaughtUpClients,\n+                                                   final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final SortedSet<TaskId> unassignedTasksWithoutCaughtUpClients = new TreeSet<>(statefulTasksToRankedClients.keySet());\n+        unassignedTasksWithoutCaughtUpClients.removeAll(tasksToCaughtUpClients.keySet());\n+        for (final TaskId taskId : unassignedTasksWithoutCaughtUpClients) {\n+            final SortedSet<ClientIdAndLag<ID>> rankedClients = statefulTasksToRankedClients.get(taskId);\n+            final long minLag = rankedClients.first().lag();\n+            int minTasksCount = Integer.MAX_VALUE;\n+            ID clientWithLeastTasks = rankedClients.first().clientId();\n+            for (final ClientIdAndLag<ID> clientIdAndLag : rankedClients) {\n+                if (clientIdAndLag.lag() == minLag) {\n+                    final ID clientId = clientIdAndLag.clientId();\n+                    final int assignedTasksCount = assignment.get(clientId).size();\n+                    if (minTasksCount > assignedTasksCount) {\n+                        clientWithLeastTasks = clientId;\n+                        minTasksCount = assignedTasksCount;\n+                    }\n+                } else {\n+                    break;\n+                }\n+            }\n+            assignment.get(clientWithLeastTasks).add(taskId);\n+        }\n+    }\n+\n+    /**\n+     * Balance the assignment.\n+     *\n+     * @param assignment assignment\n+     * @param balanceFactor balance factor\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param tasksToCaughtUpClients map from task IDs to lists of caught-up clients\n+     */\n+    private void balance(final Map<ID, List<TaskId>> assignment,\n+                         final int balanceFactor,\n+                         final Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                         final Map<TaskId, List<ID>> tasksToCaughtUpClients) {\n+        final List<ID> clients = new ArrayList<>(assignment.keySet());\n+        Collections.sort(clients);\n+        for (final ID client : clients) {\n+            final List<TaskId> source = assignment.get(client);\n+            for (final TaskId task : assignedTasksWithoutCaughtUpClients(source, tasksToCaughtUpClients)) {\n+                for (final ClientIdAndLag<ID> clientAndLag : statefulTasksToRankedClients.get(task)) {\n+                    final List<TaskId> destination = assignment.get(clientAndLag.clientId());\n+                    if (source.size() - destination.size() > balanceFactor) {\n+                        source.remove(task);\n+                        destination.add(task);\n+                    }\n+                }\n+            }\n+            for (final TaskId task : assignedTasksWithCaughtUpClients(source, tasksToCaughtUpClients)) {\n+                for (final ID caughtUpClient : tasksToCaughtUpClients.get(task)) {\n+                    final List<TaskId> destination = assignment.get(caughtUpClient);\n+                    if (source.size() - destination.size() > balanceFactor) {\n+                        source.remove(task);\n+                        destination.add(task);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjIyOQ==", "bodyText": "WDYT about renaming lag to rank, or effectiveLag, or something else that reminds us this isn't the actual literal lag? cc/ @vvcephei", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392526229", "createdAt": "2020-03-13T23:25:08Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/StateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+\n+public interface StateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> {\n+\n+    class ClientIdAndLag<ID extends Comparable<? super ID>> implements Comparable<ClientIdAndLag<ID>> {\n+        private final ID clientId;\n+        private final long lag;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjUyNA==", "bodyText": "req: move this to StreamsPartitionAssignor, where we'll be building and passing the Map<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients map around", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392526524", "createdAt": "2020-03-13T23:26:28Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/StateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+\n+public interface StateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> {\n+\n+    class ClientIdAndLag<ID extends Comparable<? super ID>> implements Comparable<ClientIdAndLag<ID>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNzA4OQ==", "bodyText": "I know we do the same for the StickyTaskAssignor, but I don't really see what we gain by adding an interface for this class. Do we need it?", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392527089", "createdAt": "2020-03-13T23:29:23Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/StateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+\n+public interface StateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0Njk2OTMy", "url": "https://github.com/apache/kafka/pull/8262#pullrequestreview-374696932", "createdAt": "2020-03-14T04:25:31Z", "commit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNFQwNDoyNTozMVrOF2XsNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNFQwNDo0NjowNlrOF2XwUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU1NTU3NQ==", "bodyText": "It looks like the primary purpose of this logic is to compute the list of clients, given the statefulTasksToRankedClients. Let's instead just make the set of clients an input to the assignment method instead. I realize it's not in the method signature I specified in the KIP, but then again, that was just algorithm pseudocode. This method isn't used anywhere (yet), so let's take advantage and just assume we'll be passed everything we need in the most convenient format for us.", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392555575", "createdAt": "2020-03-14T04:25:31Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU1NTc3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n          \n          \n            \n                    for (final Map.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {\n          \n      \n    \n    \n  \n\nJust to resolve a warning about referencing the subclass instead of the interface.", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392555774", "createdAt": "2020-03-14T04:28:56Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+public class DefaultStateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> implements StateConstrainedBalancedAssignor<ID> {\n+\n+    /**\n+     * This assignment algorithm guarantees that all task for which caught-up clients exist are assigned to one of the\n+     * caught-up clients. Tasks for which no caught-up client exist are assigned best-effort to satisfy the balance\n+     * factor. There is not guarantee that the balance factor is satisfied.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @param balanceFactor balance factor (at least 1)\n+     * @return assignment\n+     */\n+    @Override\n+    public Map<ID, List<TaskId>> assign(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients,\n+                                        final int balanceFactor) {\n+        final Map<ID, List<TaskId>> assignment = initAssignment(statefulTasksToRankedClients);\n+        final Map<TaskId, List<ID>> tasksToCaughtUpClients = tasksToCaughtUpClients(statefulTasksToRankedClients);\n+        assignTasksWithCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        assignTasksWithoutCaughtUpClients(assignment, tasksToCaughtUpClients, statefulTasksToRankedClients);\n+        balance(assignment, balanceFactor, statefulTasksToRankedClients, tasksToCaughtUpClients);\n+        return assignment;\n+    }\n+\n+    /**\n+     * Initialises the assignment with the clients in the ranked clients map and assigns to each client an empty list.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return initialised assignment with empty lists\n+     */\n+    private Map<ID, List<TaskId>> initAssignment(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<ID, List<TaskId>> assignment = new HashMap<>();\n+        final SortedSet<ClientIdAndLag<ID>> clientIdAndLags = statefulTasksToRankedClients.values().stream()\n+            .findFirst().orElseThrow(() -> new IllegalStateException(\"The list of clients and lags must not be empty\"));\n+        for (final ClientIdAndLag<ID> clientIdAndLag : clientIdAndLags) {\n+            assignment.put(clientIdAndLag.clientId(), new ArrayList<>());\n+        }\n+        if (assignment.isEmpty()) {\n+            throw new IllegalStateException(\"Clients within an assignment must not be empty\");\n+        }\n+        return assignment;\n+    }\n+\n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    private Map<TaskId, List<ID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<ClientIdAndLag<ID>>> statefulTasksToRankedClients) {\n+        final Map<TaskId, List<ID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<ClientIdAndLag<ID>>> taskToRankedClient : statefulTasksToRankedClients.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU1NjU3Mw==", "bodyText": "Good thought. Lag was originally proposed in the KIP, but it's not what we're using anymore.", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392556573", "createdAt": "2020-03-14T04:45:22Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/StateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+\n+public interface StateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> {\n+\n+    class ClientIdAndLag<ID extends Comparable<? super ID>> implements Comparable<ClientIdAndLag<ID>> {\n+        private final ID clientId;\n+        private final long lag;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjIyOQ=="}, "originalCommit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU1NjYyNQ==", "bodyText": "These utility methods can be static.", "url": "https://github.com/apache/kafka/pull/8262#discussion_r392556625", "createdAt": "2020-03-14T04:46:06Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignorTest.java", "diffHunk": "@@ -0,0 +1,463 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+import org.apache.kafka.streams.processor.internals.assignment.StateConstrainedBalancedAssignor.ClientIdAndLag;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import static org.apache.kafka.common.utils.Utils.mkEntry;\n+import static org.apache.kafka.common.utils.Utils.mkMap;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+public class DefaultStateConstrainedBalancedAssignorTest {\n+\n+    private static final TaskId TASK_01 = new TaskId(0, 1);\n+    private static final TaskId TASK_12 = new TaskId(1, 2);\n+    private static final TaskId TASK_23 = new TaskId(2, 3);\n+\n+    private static final String CLIENT_1 = \"client1\";\n+    private static final String CLIENT_2 = \"client2\";\n+    private static final String CLIENT_3 = \"client3\";\n+\n+    @Test\n+    public void shouldAssignTaskToCaughtUpClient() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = Long.MAX_VALUE;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToPreviouslyHostingClient() {\n+        final long lagOfClient1 = Long.MAX_VALUE;\n+        final long lagOfClient2 = Task.LATEST_OFFSET;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToPreviouslyHostingClientWhenOtherCaughtUpClientExists() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = Task.LATEST_OFFSET;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToCaughtUpClientThatIsFirstInSortOrder() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToMostCaughtUpClient() {\n+        final long lagOfClient1 = 3;\n+        final long lagOfClient2 = 5;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsThatAreNotPreviousHosts() {\n+        final long lagForTask01OnClient1 = 0;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 0;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1, \n+                lagForTask01OnClient2, \n+                lagForTask12OnClient1, \n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsThatAreNotPreviousHostsEvenIfNotRequiredByBalanceFactor() {\n+        final long lagForTask01OnClient1 = 0;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 0;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfBoth() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfBoth1() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 100;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfBoth2() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 100;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignBothTasksToPreviousHostSinceBalanceFactorSatisfied() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Arrays.asList(TASK_01, TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignOneTaskToPreviousHostAndOtherTaskToMostCaughtUpClient() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 20;\n+        final long lagForTask12OnClient2 = 10;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignOneTaskToPreviousHostAndOtherTaskToNotMostCaughtUpClientDueToBalanceFactor() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 10;\n+        final long lagForTask12OnClient2 = 20;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignBothTasksToSameClientSincePreviousHostAndMostCaughtUpAndBalanceFactorSatisfied() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 10;\n+        final long lagForTask12OnClient2 = 20;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Arrays.asList(TASK_01, TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTasksToMostCaughtUpClient() {\n+        final long lagForTask01OnClient1 = 40;\n+        final long lagForTask01OnClient2 = 30;\n+        final long lagForTask12OnClient1 = 10;\n+        final long lagForTask12OnClient2 = 20;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignOneTaskToNotMostCaughtUpClientsDueToBalanceFactor() {\n+        final long lagForTask01OnClient1 = 40;\n+        final long lagForTask01OnClient2 = 30;\n+        final long lagForTask12OnClient1 = 20;\n+        final long lagForTask12OnClient2 = 10;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignBothTasksToSameMostCaughtUpClientSinceBalanceFactorSatisfied() {\n+        final long lagForTask01OnClient1 = 40;\n+        final long lagForTask01OnClient2 = 30;\n+        final long lagForTask12OnClient1 = 20;\n+        final long lagForTask12OnClient2 = 10;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Arrays.asList(TASK_01, TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksOverClientsWithEqualRank() {\n+        final long lagForTask01OnClient1 = 40;\n+        final long lagForTask01OnClient2 = 40;\n+        final long lagForTask12OnClient1 = 40;\n+        final long lagForTask12OnClient2 = 40;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    private SortedMap<TaskId, SortedSet<ClientIdAndLag<String>>> oneStatefulTasksToTwoRankedClients(final long lagOfClient1,\n+                                                                                                    final long lagOfClient2) {\n+        final SortedSet<ClientIdAndLag<String>> rankedClients01 = new TreeSet<>();\n+        rankedClients01.add(ClientIdAndLag.make(CLIENT_1, lagOfClient1));\n+        rankedClients01.add(ClientIdAndLag.make(CLIENT_2, lagOfClient2));\n+        return new TreeMap<>(\n+            mkMap(mkEntry(TASK_01, rankedClients01))\n+        );\n+    }\n+\n+    private SortedMap<TaskId, SortedSet<ClientIdAndLag<String>>> twoStatefulTasksToTwoRankedClients(final long lagForTask01OnClient1,\n+                                                                                                    final long lagForTask01OnClient2,\n+                                                                                                    final long lagForTask12OnClient1,\n+                                                                                                    final long lagForTask12OnClient2) {\n+        final SortedSet<ClientIdAndLag<String>> rankedClients01 = new TreeSet<>();\n+        rankedClients01.add(ClientIdAndLag.make(CLIENT_1, lagForTask01OnClient1));\n+        rankedClients01.add(ClientIdAndLag.make(CLIENT_2, lagForTask01OnClient2));\n+        final SortedSet<ClientIdAndLag<String>> rankedClients12 = new TreeSet<>();\n+        rankedClients12.add(ClientIdAndLag.make(CLIENT_1, lagForTask12OnClient1));\n+        rankedClients12.add(ClientIdAndLag.make(CLIENT_2, lagForTask12OnClient2));\n+        return new TreeMap<>(\n+            mkMap(\n+                mkEntry(TASK_01, rankedClients01),\n+                mkEntry(TASK_12, rankedClients12)\n+            )\n+        );\n+    }\n+\n+    private Map<String, List<TaskId>> expectedAssignmentForTwoClients(final List<TaskId> assignedTasksForClient1,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5987b9c462772ac9cc43fa8bc16e407b3ae654d5"}, "originalPosition": 456}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63a179dcd01750933c15b8d53e1a6ab3bfd2dc2b", "author": {"user": {"login": "cadonna", "name": "Bruno Cadonna"}}, "url": "https://github.com/apache/kafka/commit/63a179dcd01750933c15b8d53e1a6ab3bfd2dc2b", "committedDate": "2020-03-17T11:01:04Z", "message": "Include feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2NDAyNTk5", "url": "https://github.com/apache/kafka/pull/8262#pullrequestreview-376402599", "createdAt": "2020-03-17T21:01:56Z", "commit": {"oid": "63a179dcd01750933c15b8d53e1a6ab3bfd2dc2b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMTowMTo1N1rOF3t66Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMTowMTo1N1rOF3t66Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk2ODM2MQ==", "bodyText": "Why do we need this?", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393968361", "createdAt": "2020-03-17T21:01:57Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/StateConstrainedBalancedAssignor.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+\n+public interface StateConstrainedBalancedAssignor<ID extends Comparable<? super ID>> {\n+\n+    class ClientIdAndRank<ID extends Comparable<? super ID>> implements Comparable<ClientIdAndRank<ID>> {\n+        private final ID clientId;\n+        private final long rank;\n+\n+        public ClientIdAndRank(final ID clientId, final long rank) {\n+            this.clientId = clientId;\n+            this.rank = rank;\n+        }\n+\n+        public static <ID extends Comparable<? super ID>> ClientIdAndRank<ID> make(final ID clientId, final long rank) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63a179dcd01750933c15b8d53e1a6ab3bfd2dc2b"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2NDA5NTg4", "url": "https://github.com/apache/kafka/pull/8262#pullrequestreview-376409588", "createdAt": "2020-03-17T21:13:09Z", "commit": {"oid": "63a179dcd01750933c15b8d53e1a6ab3bfd2dc2b"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMToxMzoxMFrOF3uQ8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMzozNDozOFrOF3xqlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk3NDAwMw==", "bodyText": "Do we really need this test and the one above? If they are testing something different, can you think of a way to include that in the name instead of the 1 or 2 suffix?", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393974003", "createdAt": "2020-03-17T21:13:10Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignorTest.java", "diffHunk": "@@ -0,0 +1,643 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+import org.apache.kafka.streams.processor.internals.assignment.StateConstrainedBalancedAssignor.ClientIdAndRank;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import static org.apache.kafka.common.utils.Utils.mkEntry;\n+import static org.apache.kafka.common.utils.Utils.mkMap;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+public class DefaultStateConstrainedBalancedAssignorTest {\n+\n+    private static final TaskId TASK_01 = new TaskId(0, 1);\n+    private static final TaskId TASK_12 = new TaskId(1, 2);\n+    private static final TaskId TASK_23 = new TaskId(2, 3);\n+    private static final TaskId TASK_34 = new TaskId(3, 4);\n+\n+    private static final String CLIENT_1 = \"client1\";\n+    private static final String CLIENT_2 = \"client2\";\n+    private static final String CLIENT_3 = \"client3\";\n+\n+    private static final Set<String> TWO_CLIENTS = new HashSet<>(Arrays.asList(CLIENT_1, CLIENT_2));\n+    private static final Set<String> THREE_CLIENTS = new HashSet<>(Arrays.asList(CLIENT_1, CLIENT_2, CLIENT_3));\n+\n+    @Test\n+    public void shouldAssignTaskToCaughtUpClient() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = Long.MAX_VALUE;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToPreviouslyHostingClient() {\n+        final long lagOfClient1 = Long.MAX_VALUE;\n+        final long lagOfClient2 = Task.LATEST_OFFSET;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToPreviouslyHostingClientWhenOtherCaughtUpClientExists() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = Task.LATEST_OFFSET;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToCaughtUpClientThatIsFirstInSortOrder() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToMostCaughtUpClient() {\n+        final long lagOfClient1 = 3;\n+        final long lagOfClient2 = 5;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsThatAreNotPreviousHosts() {\n+        final long lagForTask01OnClient1 = 0;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 0;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1, \n+                lagForTask01OnClient2, \n+                lagForTask12OnClient1, \n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsThatAreNotPreviousHostsEvenIfNotRequiredByBalanceFactor() {\n+        final long lagForTask01OnClient1 = 0;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 0;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfAll() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask01OnClient3 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final long lagForTask12OnClient3 = 0;\n+        final long lagForTask23OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask23OnClient2 = 0;\n+        final long lagForTask23OnClient3 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            threeStatefulTasksToThreeRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask01OnClient3,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2,\n+                lagForTask12OnClient3,\n+                lagForTask23OnClient1,\n+                lagForTask23OnClient2,\n+                lagForTask23OnClient3\n+            ),\n+            balanceFactor,\n+            THREE_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_23);\n+        final List<TaskId> assignedTasksForClient3 = Collections.singletonList(TASK_12);\n+        assertThat(\n+            assignment,\n+            is(expectedAssignmentForThreeClients(assignedTasksForClient1, assignedTasksForClient2, assignedTasksForClient3))\n+        );\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfBoth1() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 100;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfBoth2() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63a179dcd01750933c15b8d53e1a6ab3bfd2dc2b"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk3NTAzNw==", "bodyText": "prop: shouldAssignOneTaskToPreviousHostAndOtherTaskToLessCaughtUpClientDueToBalanceFactor", "url": "https://github.com/apache/kafka/pull/8262#discussion_r393975037", "createdAt": "2020-03-17T21:15:17Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignorTest.java", "diffHunk": "@@ -0,0 +1,643 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+import org.apache.kafka.streams.processor.internals.assignment.StateConstrainedBalancedAssignor.ClientIdAndRank;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import static org.apache.kafka.common.utils.Utils.mkEntry;\n+import static org.apache.kafka.common.utils.Utils.mkMap;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+public class DefaultStateConstrainedBalancedAssignorTest {\n+\n+    private static final TaskId TASK_01 = new TaskId(0, 1);\n+    private static final TaskId TASK_12 = new TaskId(1, 2);\n+    private static final TaskId TASK_23 = new TaskId(2, 3);\n+    private static final TaskId TASK_34 = new TaskId(3, 4);\n+\n+    private static final String CLIENT_1 = \"client1\";\n+    private static final String CLIENT_2 = \"client2\";\n+    private static final String CLIENT_3 = \"client3\";\n+\n+    private static final Set<String> TWO_CLIENTS = new HashSet<>(Arrays.asList(CLIENT_1, CLIENT_2));\n+    private static final Set<String> THREE_CLIENTS = new HashSet<>(Arrays.asList(CLIENT_1, CLIENT_2, CLIENT_3));\n+\n+    @Test\n+    public void shouldAssignTaskToCaughtUpClient() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = Long.MAX_VALUE;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToPreviouslyHostingClient() {\n+        final long lagOfClient1 = Long.MAX_VALUE;\n+        final long lagOfClient2 = Task.LATEST_OFFSET;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToPreviouslyHostingClientWhenOtherCaughtUpClientExists() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = Task.LATEST_OFFSET;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToCaughtUpClientThatIsFirstInSortOrder() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToMostCaughtUpClient() {\n+        final long lagOfClient1 = 3;\n+        final long lagOfClient2 = 5;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsThatAreNotPreviousHosts() {\n+        final long lagForTask01OnClient1 = 0;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 0;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1, \n+                lagForTask01OnClient2, \n+                lagForTask12OnClient1, \n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsThatAreNotPreviousHostsEvenIfNotRequiredByBalanceFactor() {\n+        final long lagForTask01OnClient1 = 0;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 0;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfAll() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask01OnClient3 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final long lagForTask12OnClient3 = 0;\n+        final long lagForTask23OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask23OnClient2 = 0;\n+        final long lagForTask23OnClient3 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            threeStatefulTasksToThreeRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask01OnClient3,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2,\n+                lagForTask12OnClient3,\n+                lagForTask23OnClient1,\n+                lagForTask23OnClient2,\n+                lagForTask23OnClient3\n+            ),\n+            balanceFactor,\n+            THREE_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_23);\n+        final List<TaskId> assignedTasksForClient3 = Collections.singletonList(TASK_12);\n+        assertThat(\n+            assignment,\n+            is(expectedAssignmentForThreeClients(assignedTasksForClient1, assignedTasksForClient2, assignedTasksForClient3))\n+        );\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfBoth1() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 100;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfBoth2() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 100;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignBothTasksToPreviousHostSinceBalanceFactorSatisfied() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Arrays.asList(TASK_01, TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignOneTaskToPreviousHostAndOtherTaskToMostCaughtUpClient() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 20;\n+        final long lagForTask12OnClient2 = 10;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignOneTaskToPreviousHostAndOtherTaskToNotMostCaughtUpClientDueToBalanceFactor() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63a179dcd01750933c15b8d53e1a6ab3bfd2dc2b"}, "originalPosition": 323}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAyOTcxNg==", "bodyText": "Nice find!", "url": "https://github.com/apache/kafka/pull/8262#discussion_r394029716", "createdAt": "2020-03-17T23:34:38Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignorTest.java", "diffHunk": "@@ -0,0 +1,643 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.Task;\n+import org.apache.kafka.streams.processor.internals.assignment.StateConstrainedBalancedAssignor.ClientIdAndRank;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import static org.apache.kafka.common.utils.Utils.mkEntry;\n+import static org.apache.kafka.common.utils.Utils.mkMap;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+public class DefaultStateConstrainedBalancedAssignorTest {\n+\n+    private static final TaskId TASK_01 = new TaskId(0, 1);\n+    private static final TaskId TASK_12 = new TaskId(1, 2);\n+    private static final TaskId TASK_23 = new TaskId(2, 3);\n+    private static final TaskId TASK_34 = new TaskId(3, 4);\n+\n+    private static final String CLIENT_1 = \"client1\";\n+    private static final String CLIENT_2 = \"client2\";\n+    private static final String CLIENT_3 = \"client3\";\n+\n+    private static final Set<String> TWO_CLIENTS = new HashSet<>(Arrays.asList(CLIENT_1, CLIENT_2));\n+    private static final Set<String> THREE_CLIENTS = new HashSet<>(Arrays.asList(CLIENT_1, CLIENT_2, CLIENT_3));\n+\n+    @Test\n+    public void shouldAssignTaskToCaughtUpClient() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = Long.MAX_VALUE;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToPreviouslyHostingClient() {\n+        final long lagOfClient1 = Long.MAX_VALUE;\n+        final long lagOfClient2 = Task.LATEST_OFFSET;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToPreviouslyHostingClientWhenOtherCaughtUpClientExists() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = Task.LATEST_OFFSET;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToCaughtUpClientThatIsFirstInSortOrder() {\n+        final long lagOfClient1 = 0;\n+        final long lagOfClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTaskToMostCaughtUpClient() {\n+        final long lagOfClient1 = 3;\n+        final long lagOfClient2 = 5;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            oneStatefulTasksToTwoRankedClients(lagOfClient1, lagOfClient2),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsThatAreNotPreviousHosts() {\n+        final long lagForTask01OnClient1 = 0;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 0;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1, \n+                lagForTask01OnClient2, \n+                lagForTask12OnClient1, \n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsThatAreNotPreviousHostsEvenIfNotRequiredByBalanceFactor() {\n+        final long lagForTask01OnClient1 = 0;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 0;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfAll() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask01OnClient3 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final long lagForTask12OnClient3 = 0;\n+        final long lagForTask23OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask23OnClient2 = 0;\n+        final long lagForTask23OnClient3 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            threeStatefulTasksToThreeRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask01OnClient3,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2,\n+                lagForTask12OnClient3,\n+                lagForTask23OnClient1,\n+                lagForTask23OnClient2,\n+                lagForTask23OnClient3\n+            ),\n+            balanceFactor,\n+            THREE_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_23);\n+        final List<TaskId> assignedTasksForClient3 = Collections.singletonList(TASK_12);\n+        assertThat(\n+            assignment,\n+            is(expectedAssignmentForThreeClients(assignedTasksForClient1, assignedTasksForClient2, assignedTasksForClient3))\n+        );\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfBoth1() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 100;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksToCaughtUpClientsEvenIfOneClientIsPreviousHostOfBoth2() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 100;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignBothTasksToPreviousHostSinceBalanceFactorSatisfied() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask12OnClient2 = 0;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Arrays.asList(TASK_01, TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignOneTaskToPreviousHostAndOtherTaskToMostCaughtUpClient() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 20;\n+        final long lagForTask12OnClient2 = 10;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignOneTaskToPreviousHostAndOtherTaskToNotMostCaughtUpClientDueToBalanceFactor() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 10;\n+        final long lagForTask12OnClient2 = 20;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignBothTasksToSameClientSincePreviousHostAndMostCaughtUpAndBalanceFactorSatisfied() {\n+        final long lagForTask01OnClient1 = Task.LATEST_OFFSET;\n+        final long lagForTask01OnClient2 = 0;\n+        final long lagForTask12OnClient1 = 10;\n+        final long lagForTask12OnClient2 = 20;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Arrays.asList(TASK_01, TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.emptyList();\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldAssignTasksToMostCaughtUpClient() {\n+        final long lagForTask01OnClient1 = 50;\n+        final long lagForTask01OnClient2 = 20;\n+        final long lagForTask12OnClient1 = 20;\n+        final long lagForTask12OnClient2 = 50;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_12);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_01);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksEvenIfClientsAreNotMostCaughtUpDueToBalanceFactor() {\n+        final long lagForTask01OnClient1 = 20;\n+        final long lagForTask01OnClient2 = 50;\n+        final long lagForTask01OnClient3 = 100;\n+        final long lagForTask12OnClient1 = 20;\n+        final long lagForTask12OnClient2 = 50;\n+        final long lagForTask12OnClient3 = 100;\n+        final long lagForTask23OnClient1 = 20;\n+        final long lagForTask23OnClient2 = 50;\n+        final long lagForTask23OnClient3 = 100;\n+        final int balanceFactor = 1;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            threeStatefulTasksToThreeRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask01OnClient3,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2,\n+                lagForTask12OnClient3,\n+                lagForTask23OnClient1,\n+                lagForTask23OnClient2,\n+                lagForTask23OnClient3\n+            ),\n+            balanceFactor,\n+            THREE_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_23);\n+        final List<TaskId> assignedTasksForClient3 = Collections.singletonList(TASK_12);\n+        assertThat(\n+            assignment,\n+            is(expectedAssignmentForThreeClients(assignedTasksForClient1, assignedTasksForClient2, assignedTasksForClient3))\n+        );\n+    }\n+\n+    @Test\n+    public void shouldAssignBothTasksToSameMostCaughtUpClientSinceBalanceFactorSatisfied() {\n+        final long lagForTask01OnClient1 = 40;\n+        final long lagForTask01OnClient2 = 30;\n+        final long lagForTask12OnClient1 = 20;\n+        final long lagForTask12OnClient2 = 10;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.emptyList();\n+        final List<TaskId> assignedTasksForClient2 = Arrays.asList(TASK_01, TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    @Test\n+    public void shouldEvenlyDistributeTasksOverClientsWithEqualRank() {\n+        final long lagForTask01OnClient1 = 40;\n+        final long lagForTask01OnClient2 = 40;\n+        final long lagForTask12OnClient1 = 40;\n+        final long lagForTask12OnClient2 = 40;\n+        final int balanceFactor = 2;\n+\n+        final Map<String, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor<String>().assign(\n+            twoStatefulTasksToTwoRankedClients(\n+                lagForTask01OnClient1,\n+                lagForTask01OnClient2,\n+                lagForTask12OnClient1,\n+                lagForTask12OnClient2\n+            ),\n+            balanceFactor,\n+            TWO_CLIENTS\n+        );\n+\n+        final List<TaskId> assignedTasksForClient1 = Collections.singletonList(TASK_01);\n+        final List<TaskId> assignedTasksForClient2 = Collections.singletonList(TASK_12);\n+        assertThat(assignment, is(expectedAssignmentForTwoClients(assignedTasksForClient1, assignedTasksForClient2)));\n+    }\n+\n+    /**\n+     * This test shows that in an assigment of one client the assumption that the set of tasks which are caught-up on\n+     * the given client is followed by the set of tasks that are not caught-up on the given client does NOT hold.\n+     * In fact, in this test, at some point during the execution of the algorithm the assignment for CLIENT_2\n+     * contains TASK_34 followed by TASK_23. TASK_23 is caught-up on CLIENT_2 whereas TASK_34 is not.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "63a179dcd01750933c15b8d53e1a6ab3bfd2dc2b"}, "originalPosition": 484}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ddf61034b88b75011f27ac35ef00a56d927384b", "author": {"user": {"login": "cadonna", "name": "Bruno Cadonna"}}, "url": "https://github.com/apache/kafka/commit/0ddf61034b88b75011f27ac35ef00a56d927384b", "committedDate": "2020-03-18T10:48:50Z", "message": "Improve tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b35b0ab0e58743b8629fbfaf3db7b07a812bfa23", "author": {"user": {"login": "cadonna", "name": "Bruno Cadonna"}}, "url": "https://github.com/apache/kafka/commit/b35b0ab0e58743b8629fbfaf3db7b07a812bfa23", "committedDate": "2020-03-19T22:24:27Z", "message": "Make algorithm stream thread aware"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 203, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}