{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0MTIxNDQ1", "number": 8497, "title": "KAFKA-6145: KIP-441 Build state constrained assignment from balanced one", "bodyText": "John's awesome TaskAssignorConvergenceTest revealed some issues with the current assignor, which he nailed down as being due to the state constrained and balanced assignments not converging.\nOne way to get an assignment that is as close to the balanced assignment as possible while still being state constrained is of course to start with the balanced assignment, and move tasks around as necessary to satisfy the state constraint. With this basic approach, the converge test is passing.\nThis PR also includes some semi-orthogonal refactoring, most significantly the removal of the  assignment maps; we now just immediately assign tasks to the ClientState rather than first sticking them in an intermediate map.\nAlso moves ValidClientsByTaskLoadQueue to its own file.\nApologies for the length of this PR due to the above, but it didn't seem reasonable to do things the wrong way in the parts I changed, just so they could be undone in a followup PR along with the other parts.", "createdAt": "2020-04-16T05:10:35Z", "url": "https://github.com/apache/kafka/pull/8497", "merged": true, "mergeCommit": {"oid": "5c548e5dfc223371f3109de14eddf0918b8dcad2"}, "closed": true, "closedAt": "2020-04-21T22:10:00Z", "author": {"login": "ableegoldman"}, "timelineItems": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcYljOxAFqTM5NTY3OTI3Ng==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZ4vklAFqTM5NzYwNDQ4MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1Njc5Mjc2", "url": "https://github.com/apache/kafka/pull/8497#pullrequestreview-395679276", "createdAt": "2020-04-17T18:25:13Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODoyNToxNFrOGHYn0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODoyNToxNFrOGHYn0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NjYyNQ==", "bodyText": "Do you feel like the source/destination definition has become a bit muddled, or does it still make sense to you? I guess it seems a bit weird to me because in some sense, the source is where we're putting the task now and the destination is where we plan to move it to later. But from another angle, since we now start with the balanced assignment, we are actually moving tasks from the destination to the source.  Does anyone else find that confusing or should I not worry so much", "url": "https://github.com/apache/kafka/pull/8497#discussion_r410396625", "createdAt": "2020-04-17T18:25:14Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovement.java", "diffHunk": "@@ -16,30 +16,35 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n+import static org.apache.kafka.streams.processor.internals.assignment.HighAvailabilityTaskAssignor.taskIsCaughtUpOnClient;\n+\n+import java.util.Comparator;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n-import java.util.Set;\n import java.util.SortedSet;\n+import java.util.TreeSet;\n import java.util.UUID;\n import org.apache.kafka.streams.processor.TaskId;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n public class TaskMovement {\n-    private static final Logger log = LoggerFactory.getLogger(TaskMovement.class);\n+    private static final UUID UNKNOWN = null;\n \n     final TaskId task;\n-    final UUID source;\n-    final UUID destination;\n+    private UUID source;\n+    private final UUID destination;\n \n-    TaskMovement(final TaskId task, final UUID source, final UUID destination) {\n+    TaskMovement(final TaskId task, final UUID destination) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NjgxNDQ3", "url": "https://github.com/apache/kafka/pull/8497#pullrequestreview-395681447", "createdAt": "2020-04-17T18:28:33Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODoyODozM1rOGHYutg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODoyODozM1rOGHYutg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5ODM5MA==", "bodyText": "I just moved this class to its own file from HATA, with one main change: we now just pass in the criteria to consider a client a valid candidate for a task.\nThe original criteria was that the client has no other version of this task already,  but now we are flexible enough to use other validation criteria (eg that the client is caught-up on this task)", "url": "https://github.com/apache/kafka/pull/8497#discussion_r410398390", "createdAt": "2020-04-17T18:28:33Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/ValidClientsByTaskLoadQueue.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+/**\n+ * Wraps a priority queue of clients and returns the next valid candidate(s) based on the current task assignment\n+ */\n+class ValidClientsByTaskLoadQueue {\n+    private final PriorityQueue<UUID> clientsByTaskLoad;\n+    private final BiFunction<UUID, TaskId, Boolean> validClientCriteria;\n+\n+    ValidClientsByTaskLoadQueue(final Map<UUID, ClientState> clientStates,\n+                                final BiFunction<UUID, TaskId, Boolean> validClientCriteria) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1Njk5Njc3", "url": "https://github.com/apache/kafka/pull/8497#pullrequestreview-395699677", "createdAt": "2020-04-17T18:57:41Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODo1Nzo0MlrOGHZmlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxOTo0Nzo1OVrOGHbA-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQxMjY5NQ==", "bodyText": "Can we create a util class and move this to it? There's currently a weird dependency relationship between TaskMovement and HATA involving this method.\nRecommendation:\npackage org.apache.kafka.streams.processor.internals.assignment;\n\nimport org.apache.kafka.streams.processor.TaskId;\n\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.UUID;\n\nfinal class AssignmentUtils {\n\n    private AssignmentUtils() {}\n\n    /**\n     * @return true if this client is caught-up for this task, or the task has no caught-up clients\n     */\n    static boolean taskIsCaughtUpOnClient(final TaskId task,\n                                          final UUID client,\n                                          final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients) {\n        final Set<UUID> caughtUpClients = tasksToCaughtUpClients.get(task);\n        return caughtUpClients == null || caughtUpClients.contains(client);\n    }\n}", "url": "https://github.com/apache/kafka/pull/8497#discussion_r410412695", "createdAt": "2020-04-17T18:57:42Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignor.java", "diffHunk": "@@ -198,52 +171,40 @@ boolean previousAssignmentIsValid() {\n \n             // Verify that this client was caught-up on all stateful active tasks\n             for (final TaskId activeTask : prevActiveTasks) {\n-                if (!taskIsCaughtUpOnClient(activeTask, client)) {\n+                if (!taskIsCaughtUpOnClient(activeTask, client, tasksToCaughtUpClients)) {\n                     return false;\n                 }\n             }\n+            if (!unassignedActiveTasks.containsAll(prevActiveTasks)) {\n+                return false;\n+            }\n             unassignedActiveTasks.removeAll(prevActiveTasks);\n \n-            if (!unassignedStandbyTasks.isEmpty()) {\n-                for (final TaskId task : state.prevStandbyTasks()) {\n-                    final Integer remainingStandbys = unassignedStandbyTasks.get(task);\n-                    if (remainingStandbys != null) {\n-                        if (remainingStandbys == 1) {\n-                            unassignedStandbyTasks.remove(task);\n-                        } else {\n-                            unassignedStandbyTasks.put(task, remainingStandbys - 1);\n-                        }\n+            for (final TaskId task : state.prevStandbyTasks()) {\n+                final Integer remainingStandbys = unassignedStandbyTasks.get(task);\n+                if (remainingStandbys != null) {\n+                    if (remainingStandbys == 1) {\n+                        unassignedStandbyTasks.remove(task);\n+                    } else {\n+                        unassignedStandbyTasks.put(task, remainingStandbys - 1);\n                     }\n+                } else {\n+                    return false;\n                 }\n             }\n+\n         }\n         return unassignedActiveTasks.isEmpty() && unassignedStandbyTasks.isEmpty();\n     }\n \n     /**\n      * @return true if this client is caught-up for this task, or the task has no caught-up clients\n      */\n-    boolean taskIsCaughtUpOnClient(final TaskId task, final UUID client) {\n-        boolean hasNoCaughtUpClients = true;\n-        final SortedSet<RankedClient> rankedClients = statefulTasksToRankedCandidates.get(task);\n-        if (rankedClients == null) {\n-            return true;\n-        }\n-        for (final RankedClient rankedClient : rankedClients) {\n-            if (rankedClient.rank() <= 0L) {\n-                if (rankedClient.clientId().equals(client)) {\n-                    return true;\n-                } else {\n-                    hasNoCaughtUpClients = false;\n-                }\n-            }\n-\n-            // If we haven't found our client yet, it must not be caught-up\n-            if (rankedClient.rank() > 0L) {\n-                break;\n-            }\n-        }\n-        return hasNoCaughtUpClients;\n+    static boolean taskIsCaughtUpOnClient(final TaskId task,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyMDkwMQ==", "bodyText": "I think the source/destination definition is still sensible (actually still the same), the source is where the task is now, and the destination is where we want it to be.\nHowever, now that the source field is mutable, the hashCode/equals implementations are unsafe. Really, the specific thing that's unsafe is that hashCode cannot be defined in terms of mutable fields, but you only need hashCode if you put the object in a hashed collection. So, if we don't need to use this in sets or as map keys, maybe we can delete the hashCode method and leave equals in place (I assume it's used in testing).\nOr, you can preserve the immutability of this class and do the initial bookkeeping in \"assignMovements\" differently.", "url": "https://github.com/apache/kafka/pull/8497#discussion_r410420901", "createdAt": "2020-04-17T19:15:12Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovement.java", "diffHunk": "@@ -16,30 +16,35 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n+import static org.apache.kafka.streams.processor.internals.assignment.HighAvailabilityTaskAssignor.taskIsCaughtUpOnClient;\n+\n+import java.util.Comparator;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n-import java.util.Set;\n import java.util.SortedSet;\n+import java.util.TreeSet;\n import java.util.UUID;\n import org.apache.kafka.streams.processor.TaskId;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n public class TaskMovement {\n-    private static final Logger log = LoggerFactory.getLogger(TaskMovement.class);\n+    private static final UUID UNKNOWN = null;\n \n     final TaskId task;\n-    final UUID source;\n-    final UUID destination;\n+    private UUID source;\n+    private final UUID destination;\n \n-    TaskMovement(final TaskId task, final UUID source, final UUID destination) {\n+    TaskMovement(final TaskId task, final UUID destination) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NjYyNQ=="}, "originalCommit": null, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQyODQ0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final PriorityQueue<UUID> queue = new PriorityQueue<>(\n          \n          \n            \n                        (client, other) -> {\n          \n          \n            \n                            final double clientTaskLoad = clientStates.get(client).taskLoad();\n          \n          \n            \n                            final double otherTaskLoad = clientStates.get(other).taskLoad();\n          \n          \n            \n                            if (clientTaskLoad < otherTaskLoad) {\n          \n          \n            \n                                return -1;\n          \n          \n            \n                            } else if (clientTaskLoad > otherTaskLoad) {\n          \n          \n            \n                                return 1;\n          \n          \n            \n                            } else {\n          \n          \n            \n                                return client.compareTo(other);\n          \n          \n            \n                            }\n          \n          \n            \n                        });\n          \n          \n            \n                    final PriorityQueue<UUID> queue = new PriorityQueue<>(\n          \n          \n            \n                        Comparator.comparingDouble(k -> clientStates.get(k).taskLoad())\n          \n          \n            \n                    );\n          \n      \n    \n    \n  \n\nUpon second reading, this does the same thing, right?", "url": "https://github.com/apache/kafka/pull/8497#discussion_r410428442", "createdAt": "2020-04-17T19:31:49Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/ValidClientsByTaskLoadQueue.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+/**\n+ * Wraps a priority queue of clients and returns the next valid candidate(s) based on the current task assignment\n+ */\n+class ValidClientsByTaskLoadQueue {\n+    private final PriorityQueue<UUID> clientsByTaskLoad;\n+    private final BiFunction<UUID, TaskId, Boolean> validClientCriteria;\n+\n+    ValidClientsByTaskLoadQueue(final Map<UUID, ClientState> clientStates,\n+                                final BiFunction<UUID, TaskId, Boolean> validClientCriteria) {\n+        clientsByTaskLoad = getClientPriorityQueueByTaskLoad(clientStates);\n+        this.validClientCriteria = validClientCriteria;\n+    }\n+\n+    /**\n+=     * @return the next least loaded client that satisfies the given criteria, or null if none do\n+     */\n+    UUID poll(final TaskId task) {\n+        final List<UUID> validClient = poll(task, 1);\n+        return validClient.isEmpty() ? null : validClient.get(0);\n+    }\n+\n+    /**\n+     * @return the next N <= {@code numClientsPerTask} clients in the underlying priority queue that are valid\n+     * candidates for the given task\n+     */\n+    List<UUID> poll(final TaskId task, final int numClients) {\n+        final List<UUID> nextLeastLoadedValidClients = new LinkedList<>();\n+        final Set<UUID> invalidPolledClients = new HashSet<>();\n+        while (nextLeastLoadedValidClients.size() < numClients) {\n+            UUID candidateClient;\n+            while (true) {\n+                candidateClient = clientsByTaskLoad.poll();\n+                if (candidateClient == null) {\n+                    returnPolledClientsToQueue(invalidPolledClients);\n+                    return nextLeastLoadedValidClients;\n+                }\n+\n+                if (validClientCriteria.apply(candidateClient, task)) {\n+                    nextLeastLoadedValidClients.add(candidateClient);\n+                    break;\n+                } else {\n+                    invalidPolledClients.add(candidateClient);\n+                }\n+            }\n+        }\n+        returnPolledClientsToQueue(invalidPolledClients);\n+        return nextLeastLoadedValidClients;\n+    }\n+\n+    void offerAll(final Collection<UUID> clients) {\n+        returnPolledClientsToQueue(clients);\n+    }\n+\n+    void offer(final UUID client) {\n+        clientsByTaskLoad.offer(client);\n+    }\n+\n+    private void returnPolledClientsToQueue(final Collection<UUID> polledClients) {\n+        for (final UUID client : polledClients) {\n+            clientsByTaskLoad.offer(client);\n+        }\n+    }\n+\n+    static PriorityQueue<UUID> getClientPriorityQueueByTaskLoad(final Map<UUID, ClientState> clientStates) {\n+        final PriorityQueue<UUID> queue = new PriorityQueue<>(\n+            (client, other) -> {\n+                final double clientTaskLoad = clientStates.get(client).taskLoad();\n+                final double otherTaskLoad = clientStates.get(other).taskLoad();\n+                if (clientTaskLoad < otherTaskLoad) {\n+                    return -1;\n+                } else if (clientTaskLoad > otherTaskLoad) {\n+                    return 1;\n+                } else {\n+                    return client.compareTo(other);\n+                }\n+            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQzNTgzMw==", "bodyText": "This seems suspicious... It doesn't look like we previously polled this client, but we did add all the clients while initializing the queue. Does this add the client twice in the queue?\nSince we know we want the queue to have a uniqueness property over its elements as well, and since the heap is already encapsulated, we could consider adding a simple hashset of elements alongside the internal heap, and remove before offering when we know the element is already present. Did that make sense?", "url": "https://github.com/apache/kafka/pull/8497#discussion_r410435833", "createdAt": "2020-04-17T19:47:59Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovement.java", "diffHunk": "@@ -62,82 +67,65 @@ public int hashCode() {\n     }\n \n     /**\n-     * Computes the movement of tasks from the state constrained to the balanced assignment, up to the configured\n-     * {@code max.warmup.replicas}. A movement corresponds to a warmup replica on the destination client, with\n-     * a few exceptional cases:\n-     * <p>\n-     * 1. Tasks whose destination clients are caught-up, or whose source clients are not caught-up, will be moved\n-     * immediately from the source to the destination in the state constrained assignment\n-     * 2. Tasks whose destination client previously had this task as a standby will not be counted towards the total\n-     * {@code max.warmup.replicas}. Instead they will be counted against that task's total {@code num.standby.replicas}.\n-     *\n-     * @param statefulActiveTaskAssignment the initial, state constrained assignment, with the source clients\n-     * @param balancedStatefulActiveTaskAssignment the final, balanced assignment, with the destination clients\n-     * @return list of the task movements from statefulActiveTaskAssignment to balancedStatefulActiveTaskAssignment\n+     * @return whether any warmup replicas were assigned\n      */\n-    static List<TaskMovement> getMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n-                                           final Map<UUID, List<TaskId>> balancedStatefulActiveTaskAssignment,\n-                                           final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n-                                           final Map<UUID, ClientState> clientStates,\n-                                           final Map<TaskId, Integer> tasksToRemainingStandbys,\n-                                           final int maxWarmupReplicas) {\n-        if (statefulActiveTaskAssignment.size() != balancedStatefulActiveTaskAssignment.size()) {\n-            throw new IllegalStateException(\"Tried to compute movements but assignments differ in size.\");\n-        }\n+    static boolean assignTaskMovements(final Map<UUID, ClientState> clientStates,\n+                                    final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n+                                    final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n+                                    final Map<TaskId, Integer> tasksToRemainingStandbys,\n+                                    final int maxWarmupReplicas) {\n+        boolean warmupReplicasAssigned = false;\n \n-        final Map<TaskId, UUID> taskToDestinationClient = new HashMap<>();\n-        for (final Map.Entry<UUID, List<TaskId>> clientEntry : balancedStatefulActiveTaskAssignment.entrySet()) {\n-            final UUID destination = clientEntry.getKey();\n-            for (final TaskId task : clientEntry.getValue()) {\n-                taskToDestinationClient.put(task, destination);\n-            }\n-        }\n+        final ValidClientsByTaskLoadQueue clientsByTaskLoad =\n+            new ValidClientsByTaskLoadQueue(\n+                clientStates,\n+                (client, task) -> taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)\n+            );\n \n-        int remainingAllowedWarmupReplicas = maxWarmupReplicas;\n-        final List<TaskMovement> movements = new LinkedList<>();\n-        for (final Map.Entry<UUID, List<TaskId>> sourceClientEntry : statefulActiveTaskAssignment.entrySet()) {\n-            final UUID source = sourceClientEntry.getKey();\n-\n-            final Iterator<TaskId> sourceClientTasksIterator = sourceClientEntry.getValue().iterator();\n-            while (sourceClientTasksIterator.hasNext()) {\n-                final TaskId task = sourceClientTasksIterator.next();\n-                final UUID destination = taskToDestinationClient.get(task);\n-                if (destination == null) {\n-                    log.error(\"Task {} is assigned to client {} in initial assignment but has no owner in the final \" +\n-                                  \"balanced assignment.\", task, source);\n-                    throw new IllegalStateException(\"Found task in initial assignment that was not assigned in the final.\");\n-                } else if (!source.equals(destination)) {\n-                    if (destinationClientIsCaughtUp(task, destination, tasksToCaughtUpClients)) {\n-                        sourceClientTasksIterator.remove();\n-                        statefulActiveTaskAssignment.get(destination).add(task);\n-                    } else {\n-                        if (clientStates.get(destination).prevStandbyTasks().contains(task)\n-                                && tasksToRemainingStandbys.get(task) > 0\n-                        ) {\n-                            decrementRemainingStandbys(task, tasksToRemainingStandbys);\n-                        } else {\n-                            --remainingAllowedWarmupReplicas;\n-                        }\n-\n-                        movements.add(new TaskMovement(task, source, destination));\n-                        if (remainingAllowedWarmupReplicas == 0) {\n-                            return movements;\n-                        }\n-                    }\n+        final SortedSet<TaskMovement> taskMovements = new TreeSet<>(Comparator.comparingInt(\n+            movement -> tasksToCaughtUpClients.get(movement.task).size()\n+        ));\n+\n+        for (final Map.Entry<UUID, List<TaskId>> assignmentEntry : statefulActiveTaskAssignment.entrySet()) {\n+            final UUID client = assignmentEntry.getKey();\n+            final ClientState state = clientStates.get(client);\n+            for (final TaskId task : assignmentEntry.getValue()) {\n+                if (taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)) {\n+                    state.assignActive(task);\n+                } else {\n+                    final TaskMovement taskMovement = new TaskMovement(task,  client);\n+                    taskMovements.add(taskMovement);\n                 }\n             }\n+            clientsByTaskLoad.offer(client);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 140}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1Nzk1OTM1", "url": "https://github.com/apache/kafka/pull/8497#pullrequestreview-395795935", "createdAt": "2020-04-17T21:56:38Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMTo1NjozOFrOGHeRnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMTo1NjozOFrOGHeRnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4OTI0NQ==", "bodyText": "This test now produces different assignments depending on which task assignor is used. Since the only thing its verifying is the actual assignment, and that's not really the responsibility of the StreamsPartitionAssignor anyway, I thought it made the most sense to just remove", "url": "https://github.com/apache/kafka/pull/8497#discussion_r410489245", "createdAt": "2020-04-17T21:56:38Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsPartitionAssignorTest.java", "diffHunk": "@@ -1610,79 +1610,6 @@ public void shouldReturnInterleavedAssignmentWithUnrevokedPartitionsRemovedWhenN\n             )));\n     }\n \n-    @Test\n-    public void shouldReturnNormalAssignmentForOldAndFutureInstancesDuringVersionProbing() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1OTQ3NDM2", "url": "https://github.com/apache/kafka/pull/8497#pullrequestreview-395947436", "createdAt": "2020-04-18T20:16:24Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQyMDoxNjoyNFrOGHt5jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQyMTowMzowMVrOGHuNsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc0NTIyOA==", "bodyText": "Unless I missed something, it's possible for tasksToCaughtUpClients not to contain a task, which would give us an NPE. Can we either add a test and handle the case or assert it here with an IllegalStateException, so we don't have to chase down an NPE later?", "url": "https://github.com/apache/kafka/pull/8497#discussion_r410745228", "createdAt": "2020-04-18T20:16:24Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovement.java", "diffHunk": "@@ -16,128 +16,94 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentUtils.taskIsCaughtUpOnClient;\n+\n import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n import java.util.SortedSet;\n+import java.util.TreeSet;\n import java.util.UUID;\n import org.apache.kafka.streams.processor.TaskId;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n public class TaskMovement {\n-    private static final Logger log = LoggerFactory.getLogger(TaskMovement.class);\n-\n     final TaskId task;\n-    final UUID source;\n-    final UUID destination;\n+    private final UUID destination;\n \n-    TaskMovement(final TaskId task, final UUID source, final UUID destination) {\n+    TaskMovement(final TaskId task, final UUID destination) {\n         this.task = task;\n-        this.source = source;\n         this.destination = destination;\n     }\n \n-    @Override\n-    public boolean equals(final Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        final TaskMovement movement = (TaskMovement) o;\n-        return Objects.equals(task, movement.task) &&\n-                   Objects.equals(source, movement.source) &&\n-                   Objects.equals(destination, movement.destination);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(task, source, destination);\n-    }\n-\n     /**\n-     * Computes the movement of tasks from the state constrained to the balanced assignment, up to the configured\n-     * {@code max.warmup.replicas}. A movement corresponds to a warmup replica on the destination client, with\n-     * a few exceptional cases:\n-     * <p>\n-     * 1. Tasks whose destination clients are caught-up, or whose source clients are not caught-up, will be moved\n-     * immediately from the source to the destination in the state constrained assignment\n-     * 2. Tasks whose destination client previously had this task as a standby will not be counted towards the total\n-     * {@code max.warmup.replicas}. Instead they will be counted against that task's total {@code num.standby.replicas}.\n-     *\n-     * @param statefulActiveTaskAssignment the initial, state constrained assignment, with the source clients\n-     * @param balancedStatefulActiveTaskAssignment the final, balanced assignment, with the destination clients\n-     * @return list of the task movements from statefulActiveTaskAssignment to balancedStatefulActiveTaskAssignment\n+     * @return whether any warmup replicas were assigned\n      */\n-    static List<TaskMovement> getMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n-                                           final Map<UUID, List<TaskId>> balancedStatefulActiveTaskAssignment,\n-                                           final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n-                                           final Map<UUID, ClientState> clientStates,\n-                                           final Map<TaskId, Integer> tasksToRemainingStandbys,\n-                                           final int maxWarmupReplicas) {\n-        if (statefulActiveTaskAssignment.size() != balancedStatefulActiveTaskAssignment.size()) {\n-            throw new IllegalStateException(\"Tried to compute movements but assignments differ in size.\");\n-        }\n+    static boolean assignTaskMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n+                                       final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n+                                       final Map<UUID, ClientState> clientStates,\n+                                       final Map<TaskId, Integer> tasksToRemainingStandbys,\n+                                       final int maxWarmupReplicas) {\n+        boolean warmupReplicasAssigned = false;\n+\n+        final ValidClientsByTaskLoadQueue clientsByTaskLoad =\n+            new ValidClientsByTaskLoadQueue(\n+                clientStates,\n+                (client, task) -> taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)\n+            );\n \n-        final Map<TaskId, UUID> taskToDestinationClient = new HashMap<>();\n-        for (final Map.Entry<UUID, List<TaskId>> clientEntry : balancedStatefulActiveTaskAssignment.entrySet()) {\n-            final UUID destination = clientEntry.getKey();\n-            for (final TaskId task : clientEntry.getValue()) {\n-                taskToDestinationClient.put(task, destination);\n+        final SortedSet<TaskMovement> taskMovements = new TreeSet<>(\n+            (movement, other) -> {\n+                final int numCaughtUpClients = tasksToCaughtUpClients.get(movement.task).size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc0NTQyMQ==", "bodyText": "IIRC, this is an anti-pattern for comparators (I think because of underflow). Can we delegate to Integer.compare instead?\nAlso, this line has no test coverage. Not sure if that's a bad sign or not.", "url": "https://github.com/apache/kafka/pull/8497#discussion_r410745421", "createdAt": "2020-04-18T20:18:19Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovement.java", "diffHunk": "@@ -16,128 +16,94 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentUtils.taskIsCaughtUpOnClient;\n+\n import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n import java.util.SortedSet;\n+import java.util.TreeSet;\n import java.util.UUID;\n import org.apache.kafka.streams.processor.TaskId;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n public class TaskMovement {\n-    private static final Logger log = LoggerFactory.getLogger(TaskMovement.class);\n-\n     final TaskId task;\n-    final UUID source;\n-    final UUID destination;\n+    private final UUID destination;\n \n-    TaskMovement(final TaskId task, final UUID source, final UUID destination) {\n+    TaskMovement(final TaskId task, final UUID destination) {\n         this.task = task;\n-        this.source = source;\n         this.destination = destination;\n     }\n \n-    @Override\n-    public boolean equals(final Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        final TaskMovement movement = (TaskMovement) o;\n-        return Objects.equals(task, movement.task) &&\n-                   Objects.equals(source, movement.source) &&\n-                   Objects.equals(destination, movement.destination);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(task, source, destination);\n-    }\n-\n     /**\n-     * Computes the movement of tasks from the state constrained to the balanced assignment, up to the configured\n-     * {@code max.warmup.replicas}. A movement corresponds to a warmup replica on the destination client, with\n-     * a few exceptional cases:\n-     * <p>\n-     * 1. Tasks whose destination clients are caught-up, or whose source clients are not caught-up, will be moved\n-     * immediately from the source to the destination in the state constrained assignment\n-     * 2. Tasks whose destination client previously had this task as a standby will not be counted towards the total\n-     * {@code max.warmup.replicas}. Instead they will be counted against that task's total {@code num.standby.replicas}.\n-     *\n-     * @param statefulActiveTaskAssignment the initial, state constrained assignment, with the source clients\n-     * @param balancedStatefulActiveTaskAssignment the final, balanced assignment, with the destination clients\n-     * @return list of the task movements from statefulActiveTaskAssignment to balancedStatefulActiveTaskAssignment\n+     * @return whether any warmup replicas were assigned\n      */\n-    static List<TaskMovement> getMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n-                                           final Map<UUID, List<TaskId>> balancedStatefulActiveTaskAssignment,\n-                                           final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n-                                           final Map<UUID, ClientState> clientStates,\n-                                           final Map<TaskId, Integer> tasksToRemainingStandbys,\n-                                           final int maxWarmupReplicas) {\n-        if (statefulActiveTaskAssignment.size() != balancedStatefulActiveTaskAssignment.size()) {\n-            throw new IllegalStateException(\"Tried to compute movements but assignments differ in size.\");\n-        }\n+    static boolean assignTaskMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n+                                       final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n+                                       final Map<UUID, ClientState> clientStates,\n+                                       final Map<TaskId, Integer> tasksToRemainingStandbys,\n+                                       final int maxWarmupReplicas) {\n+        boolean warmupReplicasAssigned = false;\n+\n+        final ValidClientsByTaskLoadQueue clientsByTaskLoad =\n+            new ValidClientsByTaskLoadQueue(\n+                clientStates,\n+                (client, task) -> taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)\n+            );\n \n-        final Map<TaskId, UUID> taskToDestinationClient = new HashMap<>();\n-        for (final Map.Entry<UUID, List<TaskId>> clientEntry : balancedStatefulActiveTaskAssignment.entrySet()) {\n-            final UUID destination = clientEntry.getKey();\n-            for (final TaskId task : clientEntry.getValue()) {\n-                taskToDestinationClient.put(task, destination);\n+        final SortedSet<TaskMovement> taskMovements = new TreeSet<>(\n+            (movement, other) -> {\n+                final int numCaughtUpClients = tasksToCaughtUpClients.get(movement.task).size();\n+                final int otherNumCaughtUpClients = tasksToCaughtUpClients.get(other.task).size();\n+                if (numCaughtUpClients != otherNumCaughtUpClients) {\n+                    return numCaughtUpClients - otherNumCaughtUpClients;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc0NTU5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                final TaskMovement taskMovement = new TaskMovement(task,  client);\n          \n          \n            \n                                final TaskMovement taskMovement = new TaskMovement(task, client);", "url": "https://github.com/apache/kafka/pull/8497#discussion_r410745590", "createdAt": "2020-04-18T20:19:41Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovement.java", "diffHunk": "@@ -16,128 +16,94 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentUtils.taskIsCaughtUpOnClient;\n+\n import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n import java.util.SortedSet;\n+import java.util.TreeSet;\n import java.util.UUID;\n import org.apache.kafka.streams.processor.TaskId;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n public class TaskMovement {\n-    private static final Logger log = LoggerFactory.getLogger(TaskMovement.class);\n-\n     final TaskId task;\n-    final UUID source;\n-    final UUID destination;\n+    private final UUID destination;\n \n-    TaskMovement(final TaskId task, final UUID source, final UUID destination) {\n+    TaskMovement(final TaskId task, final UUID destination) {\n         this.task = task;\n-        this.source = source;\n         this.destination = destination;\n     }\n \n-    @Override\n-    public boolean equals(final Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        final TaskMovement movement = (TaskMovement) o;\n-        return Objects.equals(task, movement.task) &&\n-                   Objects.equals(source, movement.source) &&\n-                   Objects.equals(destination, movement.destination);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(task, source, destination);\n-    }\n-\n     /**\n-     * Computes the movement of tasks from the state constrained to the balanced assignment, up to the configured\n-     * {@code max.warmup.replicas}. A movement corresponds to a warmup replica on the destination client, with\n-     * a few exceptional cases:\n-     * <p>\n-     * 1. Tasks whose destination clients are caught-up, or whose source clients are not caught-up, will be moved\n-     * immediately from the source to the destination in the state constrained assignment\n-     * 2. Tasks whose destination client previously had this task as a standby will not be counted towards the total\n-     * {@code max.warmup.replicas}. Instead they will be counted against that task's total {@code num.standby.replicas}.\n-     *\n-     * @param statefulActiveTaskAssignment the initial, state constrained assignment, with the source clients\n-     * @param balancedStatefulActiveTaskAssignment the final, balanced assignment, with the destination clients\n-     * @return list of the task movements from statefulActiveTaskAssignment to balancedStatefulActiveTaskAssignment\n+     * @return whether any warmup replicas were assigned\n      */\n-    static List<TaskMovement> getMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n-                                           final Map<UUID, List<TaskId>> balancedStatefulActiveTaskAssignment,\n-                                           final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n-                                           final Map<UUID, ClientState> clientStates,\n-                                           final Map<TaskId, Integer> tasksToRemainingStandbys,\n-                                           final int maxWarmupReplicas) {\n-        if (statefulActiveTaskAssignment.size() != balancedStatefulActiveTaskAssignment.size()) {\n-            throw new IllegalStateException(\"Tried to compute movements but assignments differ in size.\");\n-        }\n+    static boolean assignTaskMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n+                                       final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n+                                       final Map<UUID, ClientState> clientStates,\n+                                       final Map<TaskId, Integer> tasksToRemainingStandbys,\n+                                       final int maxWarmupReplicas) {\n+        boolean warmupReplicasAssigned = false;\n+\n+        final ValidClientsByTaskLoadQueue clientsByTaskLoad =\n+            new ValidClientsByTaskLoadQueue(\n+                clientStates,\n+                (client, task) -> taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)\n+            );\n \n-        final Map<TaskId, UUID> taskToDestinationClient = new HashMap<>();\n-        for (final Map.Entry<UUID, List<TaskId>> clientEntry : balancedStatefulActiveTaskAssignment.entrySet()) {\n-            final UUID destination = clientEntry.getKey();\n-            for (final TaskId task : clientEntry.getValue()) {\n-                taskToDestinationClient.put(task, destination);\n+        final SortedSet<TaskMovement> taskMovements = new TreeSet<>(\n+            (movement, other) -> {\n+                final int numCaughtUpClients = tasksToCaughtUpClients.get(movement.task).size();\n+                final int otherNumCaughtUpClients = tasksToCaughtUpClients.get(other.task).size();\n+                if (numCaughtUpClients != otherNumCaughtUpClients) {\n+                    return numCaughtUpClients - otherNumCaughtUpClients;\n+                } else {\n+                    return movement.task.compareTo(other.task);\n+                }\n             }\n+        );\n+\n+        for (final Map.Entry<UUID, List<TaskId>> assignmentEntry : statefulActiveTaskAssignment.entrySet()) {\n+            final UUID client = assignmentEntry.getKey();\n+            final ClientState state = clientStates.get(client);\n+            for (final TaskId task : assignmentEntry.getValue()) {\n+                if (taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)) {\n+                    state.assignActive(task);\n+                } else {\n+                    final TaskMovement taskMovement = new TaskMovement(task,  client);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc0NjAzNQ==", "bodyText": "can be private", "url": "https://github.com/apache/kafka/pull/8497#discussion_r410746035", "createdAt": "2020-04-18T20:23:53Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovement.java", "diffHunk": "@@ -16,128 +16,94 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentUtils.taskIsCaughtUpOnClient;\n+\n import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n import java.util.SortedSet;\n+import java.util.TreeSet;\n import java.util.UUID;\n import org.apache.kafka.streams.processor.TaskId;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n public class TaskMovement {\n-    private static final Logger log = LoggerFactory.getLogger(TaskMovement.class);\n-\n     final TaskId task;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc0NzA0NA==", "bodyText": "This also doesn't have any test coverage. It took me a while to figure out why this should be a illegal.\nIf I followed the code paths to this point correctly, it seems like the balanced assignor declared it wants task X to be on client A, and A is not caught up on X, so we don't immediately assign A to X. Instead, we try to find the least loaded valid client to host it for now. However, there was no valid client. At a glance, this means that there's no client that's caught up on the task, but the trick is that taskIsCaughtUpOnClient considers all clients valid if there are no caught-up ones. So, if we did get null here, it would either mean that A is the only caught-up client on X (and we shouldn't be here, since it means A is caught up on X, contradicting the earlier statement), or that there are no clients in the queue (which also shouldn't happen).\nWe can possibly clarify it my making the name of taskIsCaughtUpOnClient more complete: eitherClientIsCaughtUpOnTaskOrNoClientIs. But I wouldn't hesitate to also write a nice letter to future us here as a comment.", "url": "https://github.com/apache/kafka/pull/8497#discussion_r410747044", "createdAt": "2020-04-18T20:33:04Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovement.java", "diffHunk": "@@ -16,128 +16,94 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentUtils.taskIsCaughtUpOnClient;\n+\n import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n import java.util.SortedSet;\n+import java.util.TreeSet;\n import java.util.UUID;\n import org.apache.kafka.streams.processor.TaskId;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n public class TaskMovement {\n-    private static final Logger log = LoggerFactory.getLogger(TaskMovement.class);\n-\n     final TaskId task;\n-    final UUID source;\n-    final UUID destination;\n+    private final UUID destination;\n \n-    TaskMovement(final TaskId task, final UUID source, final UUID destination) {\n+    TaskMovement(final TaskId task, final UUID destination) {\n         this.task = task;\n-        this.source = source;\n         this.destination = destination;\n     }\n \n-    @Override\n-    public boolean equals(final Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        final TaskMovement movement = (TaskMovement) o;\n-        return Objects.equals(task, movement.task) &&\n-                   Objects.equals(source, movement.source) &&\n-                   Objects.equals(destination, movement.destination);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(task, source, destination);\n-    }\n-\n     /**\n-     * Computes the movement of tasks from the state constrained to the balanced assignment, up to the configured\n-     * {@code max.warmup.replicas}. A movement corresponds to a warmup replica on the destination client, with\n-     * a few exceptional cases:\n-     * <p>\n-     * 1. Tasks whose destination clients are caught-up, or whose source clients are not caught-up, will be moved\n-     * immediately from the source to the destination in the state constrained assignment\n-     * 2. Tasks whose destination client previously had this task as a standby will not be counted towards the total\n-     * {@code max.warmup.replicas}. Instead they will be counted against that task's total {@code num.standby.replicas}.\n-     *\n-     * @param statefulActiveTaskAssignment the initial, state constrained assignment, with the source clients\n-     * @param balancedStatefulActiveTaskAssignment the final, balanced assignment, with the destination clients\n-     * @return list of the task movements from statefulActiveTaskAssignment to balancedStatefulActiveTaskAssignment\n+     * @return whether any warmup replicas were assigned\n      */\n-    static List<TaskMovement> getMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n-                                           final Map<UUID, List<TaskId>> balancedStatefulActiveTaskAssignment,\n-                                           final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n-                                           final Map<UUID, ClientState> clientStates,\n-                                           final Map<TaskId, Integer> tasksToRemainingStandbys,\n-                                           final int maxWarmupReplicas) {\n-        if (statefulActiveTaskAssignment.size() != balancedStatefulActiveTaskAssignment.size()) {\n-            throw new IllegalStateException(\"Tried to compute movements but assignments differ in size.\");\n-        }\n+    static boolean assignTaskMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n+                                       final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n+                                       final Map<UUID, ClientState> clientStates,\n+                                       final Map<TaskId, Integer> tasksToRemainingStandbys,\n+                                       final int maxWarmupReplicas) {\n+        boolean warmupReplicasAssigned = false;\n+\n+        final ValidClientsByTaskLoadQueue clientsByTaskLoad =\n+            new ValidClientsByTaskLoadQueue(\n+                clientStates,\n+                (client, task) -> taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)\n+            );\n \n-        final Map<TaskId, UUID> taskToDestinationClient = new HashMap<>();\n-        for (final Map.Entry<UUID, List<TaskId>> clientEntry : balancedStatefulActiveTaskAssignment.entrySet()) {\n-            final UUID destination = clientEntry.getKey();\n-            for (final TaskId task : clientEntry.getValue()) {\n-                taskToDestinationClient.put(task, destination);\n+        final SortedSet<TaskMovement> taskMovements = new TreeSet<>(\n+            (movement, other) -> {\n+                final int numCaughtUpClients = tasksToCaughtUpClients.get(movement.task).size();\n+                final int otherNumCaughtUpClients = tasksToCaughtUpClients.get(other.task).size();\n+                if (numCaughtUpClients != otherNumCaughtUpClients) {\n+                    return numCaughtUpClients - otherNumCaughtUpClients;\n+                } else {\n+                    return movement.task.compareTo(other.task);\n+                }\n             }\n+        );\n+\n+        for (final Map.Entry<UUID, List<TaskId>> assignmentEntry : statefulActiveTaskAssignment.entrySet()) {\n+            final UUID client = assignmentEntry.getKey();\n+            final ClientState state = clientStates.get(client);\n+            for (final TaskId task : assignmentEntry.getValue()) {\n+                if (taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)) {\n+                    state.assignActive(task);\n+                } else {\n+                    final TaskMovement taskMovement = new TaskMovement(task,  client);\n+                    taskMovements.add(taskMovement);\n+                }\n+            }\n+            clientsByTaskLoad.offer(client);\n         }\n \n-        int remainingAllowedWarmupReplicas = maxWarmupReplicas;\n-        final List<TaskMovement> movements = new LinkedList<>();\n-        for (final Map.Entry<UUID, List<TaskId>> sourceClientEntry : statefulActiveTaskAssignment.entrySet()) {\n-            final UUID source = sourceClientEntry.getKey();\n+        int remainingWarmupReplicas = maxWarmupReplicas;\n+        for (final TaskMovement movement : taskMovements) {\n+            final UUID leastLoadedClient = clientsByTaskLoad.poll(movement.task);\n+            if (leastLoadedClient == null) {\n+                throw new IllegalStateException(\"Tried to move task to caught-up client but none exist\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc0NzYwNw==", "bodyText": "Should it be:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (destinationClientState.prevStandbyTasks().contains(movement.task) && tasksToRemainingStandbys.get(movement.task) > 0) {\n          \n          \n            \n                        if (destinationClientState.previousAssignedTasks().contains(movement.task) && tasksToRemainingStandbys.get(movement.task) > 0) {\n          \n      \n    \n    \n  \n\nIt doesn't seem like we care if the task was previously a standby or active, just that it wasn't caught up, and we have an available standby replica to give it, so we don't have to count it as a warmup.", "url": "https://github.com/apache/kafka/pull/8497#discussion_r410747607", "createdAt": "2020-04-18T20:38:06Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovement.java", "diffHunk": "@@ -16,128 +16,94 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentUtils.taskIsCaughtUpOnClient;\n+\n import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n import java.util.SortedSet;\n+import java.util.TreeSet;\n import java.util.UUID;\n import org.apache.kafka.streams.processor.TaskId;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n public class TaskMovement {\n-    private static final Logger log = LoggerFactory.getLogger(TaskMovement.class);\n-\n     final TaskId task;\n-    final UUID source;\n-    final UUID destination;\n+    private final UUID destination;\n \n-    TaskMovement(final TaskId task, final UUID source, final UUID destination) {\n+    TaskMovement(final TaskId task, final UUID destination) {\n         this.task = task;\n-        this.source = source;\n         this.destination = destination;\n     }\n \n-    @Override\n-    public boolean equals(final Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        final TaskMovement movement = (TaskMovement) o;\n-        return Objects.equals(task, movement.task) &&\n-                   Objects.equals(source, movement.source) &&\n-                   Objects.equals(destination, movement.destination);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(task, source, destination);\n-    }\n-\n     /**\n-     * Computes the movement of tasks from the state constrained to the balanced assignment, up to the configured\n-     * {@code max.warmup.replicas}. A movement corresponds to a warmup replica on the destination client, with\n-     * a few exceptional cases:\n-     * <p>\n-     * 1. Tasks whose destination clients are caught-up, or whose source clients are not caught-up, will be moved\n-     * immediately from the source to the destination in the state constrained assignment\n-     * 2. Tasks whose destination client previously had this task as a standby will not be counted towards the total\n-     * {@code max.warmup.replicas}. Instead they will be counted against that task's total {@code num.standby.replicas}.\n-     *\n-     * @param statefulActiveTaskAssignment the initial, state constrained assignment, with the source clients\n-     * @param balancedStatefulActiveTaskAssignment the final, balanced assignment, with the destination clients\n-     * @return list of the task movements from statefulActiveTaskAssignment to balancedStatefulActiveTaskAssignment\n+     * @return whether any warmup replicas were assigned\n      */\n-    static List<TaskMovement> getMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n-                                           final Map<UUID, List<TaskId>> balancedStatefulActiveTaskAssignment,\n-                                           final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n-                                           final Map<UUID, ClientState> clientStates,\n-                                           final Map<TaskId, Integer> tasksToRemainingStandbys,\n-                                           final int maxWarmupReplicas) {\n-        if (statefulActiveTaskAssignment.size() != balancedStatefulActiveTaskAssignment.size()) {\n-            throw new IllegalStateException(\"Tried to compute movements but assignments differ in size.\");\n-        }\n+    static boolean assignTaskMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n+                                       final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n+                                       final Map<UUID, ClientState> clientStates,\n+                                       final Map<TaskId, Integer> tasksToRemainingStandbys,\n+                                       final int maxWarmupReplicas) {\n+        boolean warmupReplicasAssigned = false;\n+\n+        final ValidClientsByTaskLoadQueue clientsByTaskLoad =\n+            new ValidClientsByTaskLoadQueue(\n+                clientStates,\n+                (client, task) -> taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)\n+            );\n \n-        final Map<TaskId, UUID> taskToDestinationClient = new HashMap<>();\n-        for (final Map.Entry<UUID, List<TaskId>> clientEntry : balancedStatefulActiveTaskAssignment.entrySet()) {\n-            final UUID destination = clientEntry.getKey();\n-            for (final TaskId task : clientEntry.getValue()) {\n-                taskToDestinationClient.put(task, destination);\n+        final SortedSet<TaskMovement> taskMovements = new TreeSet<>(\n+            (movement, other) -> {\n+                final int numCaughtUpClients = tasksToCaughtUpClients.get(movement.task).size();\n+                final int otherNumCaughtUpClients = tasksToCaughtUpClients.get(other.task).size();\n+                if (numCaughtUpClients != otherNumCaughtUpClients) {\n+                    return numCaughtUpClients - otherNumCaughtUpClients;\n+                } else {\n+                    return movement.task.compareTo(other.task);\n+                }\n             }\n+        );\n+\n+        for (final Map.Entry<UUID, List<TaskId>> assignmentEntry : statefulActiveTaskAssignment.entrySet()) {\n+            final UUID client = assignmentEntry.getKey();\n+            final ClientState state = clientStates.get(client);\n+            for (final TaskId task : assignmentEntry.getValue()) {\n+                if (taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)) {\n+                    state.assignActive(task);\n+                } else {\n+                    final TaskMovement taskMovement = new TaskMovement(task,  client);\n+                    taskMovements.add(taskMovement);\n+                }\n+            }\n+            clientsByTaskLoad.offer(client);\n         }\n \n-        int remainingAllowedWarmupReplicas = maxWarmupReplicas;\n-        final List<TaskMovement> movements = new LinkedList<>();\n-        for (final Map.Entry<UUID, List<TaskId>> sourceClientEntry : statefulActiveTaskAssignment.entrySet()) {\n-            final UUID source = sourceClientEntry.getKey();\n+        int remainingWarmupReplicas = maxWarmupReplicas;\n+        for (final TaskMovement movement : taskMovements) {\n+            final UUID leastLoadedClient = clientsByTaskLoad.poll(movement.task);\n+            if (leastLoadedClient == null) {\n+                throw new IllegalStateException(\"Tried to move task to caught-up client but none exist\");\n+            }\n \n-            final Iterator<TaskId> sourceClientTasksIterator = sourceClientEntry.getValue().iterator();\n-            while (sourceClientTasksIterator.hasNext()) {\n-                final TaskId task = sourceClientTasksIterator.next();\n-                final UUID destination = taskToDestinationClient.get(task);\n-                if (destination == null) {\n-                    log.error(\"Task {} is assigned to client {} in initial assignment but has no owner in the final \" +\n-                                  \"balanced assignment.\", task, source);\n-                    throw new IllegalStateException(\"Found task in initial assignment that was not assigned in the final.\");\n-                } else if (!source.equals(destination)) {\n-                    if (destinationClientIsCaughtUp(task, destination, tasksToCaughtUpClients)) {\n-                        sourceClientTasksIterator.remove();\n-                        statefulActiveTaskAssignment.get(destination).add(task);\n-                    } else {\n-                        if (clientStates.get(destination).prevStandbyTasks().contains(task)\n-                                && tasksToRemainingStandbys.get(task) > 0\n-                        ) {\n-                            decrementRemainingStandbys(task, tasksToRemainingStandbys);\n-                        } else {\n-                            --remainingAllowedWarmupReplicas;\n-                        }\n+            final ClientState sourceClientState = clientStates.get(leastLoadedClient);\n+            sourceClientState.assignActive(movement.task);\n \n-                        movements.add(new TaskMovement(task, source, destination));\n-                        if (remainingAllowedWarmupReplicas == 0) {\n-                            return movements;\n-                        }\n-                    }\n-                }\n+            final ClientState destinationClientState = clientStates.get(movement.destination);\n+            if (destinationClientState.prevStandbyTasks().contains(movement.task) && tasksToRemainingStandbys.get(movement.task) > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc0ODE4MQ==", "bodyText": "It feels like there's a missing condition here.\n\nif the task was previously on the destination AND we can consider it one of the configured standbys\nwe can assign the task to the destination as a warm-up\n\nWhat about:\n3. We have an available standby, and the task was not previously assigned to the client, but it also wasn't previously assigned to any client, so we can just choose to assign the standby to the destination client and call it a standby", "url": "https://github.com/apache/kafka/pull/8497#discussion_r410748181", "createdAt": "2020-04-18T20:43:22Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovement.java", "diffHunk": "@@ -16,128 +16,94 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentUtils.taskIsCaughtUpOnClient;\n+\n import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n import java.util.SortedSet;\n+import java.util.TreeSet;\n import java.util.UUID;\n import org.apache.kafka.streams.processor.TaskId;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n public class TaskMovement {\n-    private static final Logger log = LoggerFactory.getLogger(TaskMovement.class);\n-\n     final TaskId task;\n-    final UUID source;\n-    final UUID destination;\n+    private final UUID destination;\n \n-    TaskMovement(final TaskId task, final UUID source, final UUID destination) {\n+    TaskMovement(final TaskId task, final UUID destination) {\n         this.task = task;\n-        this.source = source;\n         this.destination = destination;\n     }\n \n-    @Override\n-    public boolean equals(final Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        final TaskMovement movement = (TaskMovement) o;\n-        return Objects.equals(task, movement.task) &&\n-                   Objects.equals(source, movement.source) &&\n-                   Objects.equals(destination, movement.destination);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(task, source, destination);\n-    }\n-\n     /**\n-     * Computes the movement of tasks from the state constrained to the balanced assignment, up to the configured\n-     * {@code max.warmup.replicas}. A movement corresponds to a warmup replica on the destination client, with\n-     * a few exceptional cases:\n-     * <p>\n-     * 1. Tasks whose destination clients are caught-up, or whose source clients are not caught-up, will be moved\n-     * immediately from the source to the destination in the state constrained assignment\n-     * 2. Tasks whose destination client previously had this task as a standby will not be counted towards the total\n-     * {@code max.warmup.replicas}. Instead they will be counted against that task's total {@code num.standby.replicas}.\n-     *\n-     * @param statefulActiveTaskAssignment the initial, state constrained assignment, with the source clients\n-     * @param balancedStatefulActiveTaskAssignment the final, balanced assignment, with the destination clients\n-     * @return list of the task movements from statefulActiveTaskAssignment to balancedStatefulActiveTaskAssignment\n+     * @return whether any warmup replicas were assigned\n      */\n-    static List<TaskMovement> getMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n-                                           final Map<UUID, List<TaskId>> balancedStatefulActiveTaskAssignment,\n-                                           final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n-                                           final Map<UUID, ClientState> clientStates,\n-                                           final Map<TaskId, Integer> tasksToRemainingStandbys,\n-                                           final int maxWarmupReplicas) {\n-        if (statefulActiveTaskAssignment.size() != balancedStatefulActiveTaskAssignment.size()) {\n-            throw new IllegalStateException(\"Tried to compute movements but assignments differ in size.\");\n-        }\n+    static boolean assignTaskMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n+                                       final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n+                                       final Map<UUID, ClientState> clientStates,\n+                                       final Map<TaskId, Integer> tasksToRemainingStandbys,\n+                                       final int maxWarmupReplicas) {\n+        boolean warmupReplicasAssigned = false;\n+\n+        final ValidClientsByTaskLoadQueue clientsByTaskLoad =\n+            new ValidClientsByTaskLoadQueue(\n+                clientStates,\n+                (client, task) -> taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)\n+            );\n \n-        final Map<TaskId, UUID> taskToDestinationClient = new HashMap<>();\n-        for (final Map.Entry<UUID, List<TaskId>> clientEntry : balancedStatefulActiveTaskAssignment.entrySet()) {\n-            final UUID destination = clientEntry.getKey();\n-            for (final TaskId task : clientEntry.getValue()) {\n-                taskToDestinationClient.put(task, destination);\n+        final SortedSet<TaskMovement> taskMovements = new TreeSet<>(\n+            (movement, other) -> {\n+                final int numCaughtUpClients = tasksToCaughtUpClients.get(movement.task).size();\n+                final int otherNumCaughtUpClients = tasksToCaughtUpClients.get(other.task).size();\n+                if (numCaughtUpClients != otherNumCaughtUpClients) {\n+                    return numCaughtUpClients - otherNumCaughtUpClients;\n+                } else {\n+                    return movement.task.compareTo(other.task);\n+                }\n             }\n+        );\n+\n+        for (final Map.Entry<UUID, List<TaskId>> assignmentEntry : statefulActiveTaskAssignment.entrySet()) {\n+            final UUID client = assignmentEntry.getKey();\n+            final ClientState state = clientStates.get(client);\n+            for (final TaskId task : assignmentEntry.getValue()) {\n+                if (taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)) {\n+                    state.assignActive(task);\n+                } else {\n+                    final TaskMovement taskMovement = new TaskMovement(task,  client);\n+                    taskMovements.add(taskMovement);\n+                }\n+            }\n+            clientsByTaskLoad.offer(client);\n         }\n \n-        int remainingAllowedWarmupReplicas = maxWarmupReplicas;\n-        final List<TaskMovement> movements = new LinkedList<>();\n-        for (final Map.Entry<UUID, List<TaskId>> sourceClientEntry : statefulActiveTaskAssignment.entrySet()) {\n-            final UUID source = sourceClientEntry.getKey();\n+        int remainingWarmupReplicas = maxWarmupReplicas;\n+        for (final TaskMovement movement : taskMovements) {\n+            final UUID leastLoadedClient = clientsByTaskLoad.poll(movement.task);\n+            if (leastLoadedClient == null) {\n+                throw new IllegalStateException(\"Tried to move task to caught-up client but none exist\");\n+            }\n \n-            final Iterator<TaskId> sourceClientTasksIterator = sourceClientEntry.getValue().iterator();\n-            while (sourceClientTasksIterator.hasNext()) {\n-                final TaskId task = sourceClientTasksIterator.next();\n-                final UUID destination = taskToDestinationClient.get(task);\n-                if (destination == null) {\n-                    log.error(\"Task {} is assigned to client {} in initial assignment but has no owner in the final \" +\n-                                  \"balanced assignment.\", task, source);\n-                    throw new IllegalStateException(\"Found task in initial assignment that was not assigned in the final.\");\n-                } else if (!source.equals(destination)) {\n-                    if (destinationClientIsCaughtUp(task, destination, tasksToCaughtUpClients)) {\n-                        sourceClientTasksIterator.remove();\n-                        statefulActiveTaskAssignment.get(destination).add(task);\n-                    } else {\n-                        if (clientStates.get(destination).prevStandbyTasks().contains(task)\n-                                && tasksToRemainingStandbys.get(task) > 0\n-                        ) {\n-                            decrementRemainingStandbys(task, tasksToRemainingStandbys);\n-                        } else {\n-                            --remainingAllowedWarmupReplicas;\n-                        }\n+            final ClientState sourceClientState = clientStates.get(leastLoadedClient);\n+            sourceClientState.assignActive(movement.task);\n \n-                        movements.add(new TaskMovement(task, source, destination));\n-                        if (remainingAllowedWarmupReplicas == 0) {\n-                            return movements;\n-                        }\n-                    }\n-                }\n+            final ClientState destinationClientState = clientStates.get(movement.destination);\n+            if (destinationClientState.prevStandbyTasks().contains(movement.task) && tasksToRemainingStandbys.get(movement.task) > 0) {\n+                decrementRemainingStandbys(movement.task, tasksToRemainingStandbys);\n+                destinationClientState.assignStandby(movement.task);\n+                warmupReplicasAssigned = true;\n+            } else if (remainingWarmupReplicas > 0) {\n+                --remainingWarmupReplicas;\n+                destinationClientState.assignStandby(movement.task);\n+                warmupReplicasAssigned = true;\n             }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc0ODM3Nw==", "bodyText": "We also might have assigned tasks to movement.destination, so we should re-offer it as well, right?", "url": "https://github.com/apache/kafka/pull/8497#discussion_r410748377", "createdAt": "2020-04-18T20:44:51Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovement.java", "diffHunk": "@@ -16,128 +16,94 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentUtils.taskIsCaughtUpOnClient;\n+\n import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n import java.util.SortedSet;\n+import java.util.TreeSet;\n import java.util.UUID;\n import org.apache.kafka.streams.processor.TaskId;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n public class TaskMovement {\n-    private static final Logger log = LoggerFactory.getLogger(TaskMovement.class);\n-\n     final TaskId task;\n-    final UUID source;\n-    final UUID destination;\n+    private final UUID destination;\n \n-    TaskMovement(final TaskId task, final UUID source, final UUID destination) {\n+    TaskMovement(final TaskId task, final UUID destination) {\n         this.task = task;\n-        this.source = source;\n         this.destination = destination;\n     }\n \n-    @Override\n-    public boolean equals(final Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        final TaskMovement movement = (TaskMovement) o;\n-        return Objects.equals(task, movement.task) &&\n-                   Objects.equals(source, movement.source) &&\n-                   Objects.equals(destination, movement.destination);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(task, source, destination);\n-    }\n-\n     /**\n-     * Computes the movement of tasks from the state constrained to the balanced assignment, up to the configured\n-     * {@code max.warmup.replicas}. A movement corresponds to a warmup replica on the destination client, with\n-     * a few exceptional cases:\n-     * <p>\n-     * 1. Tasks whose destination clients are caught-up, or whose source clients are not caught-up, will be moved\n-     * immediately from the source to the destination in the state constrained assignment\n-     * 2. Tasks whose destination client previously had this task as a standby will not be counted towards the total\n-     * {@code max.warmup.replicas}. Instead they will be counted against that task's total {@code num.standby.replicas}.\n-     *\n-     * @param statefulActiveTaskAssignment the initial, state constrained assignment, with the source clients\n-     * @param balancedStatefulActiveTaskAssignment the final, balanced assignment, with the destination clients\n-     * @return list of the task movements from statefulActiveTaskAssignment to balancedStatefulActiveTaskAssignment\n+     * @return whether any warmup replicas were assigned\n      */\n-    static List<TaskMovement> getMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n-                                           final Map<UUID, List<TaskId>> balancedStatefulActiveTaskAssignment,\n-                                           final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n-                                           final Map<UUID, ClientState> clientStates,\n-                                           final Map<TaskId, Integer> tasksToRemainingStandbys,\n-                                           final int maxWarmupReplicas) {\n-        if (statefulActiveTaskAssignment.size() != balancedStatefulActiveTaskAssignment.size()) {\n-            throw new IllegalStateException(\"Tried to compute movements but assignments differ in size.\");\n-        }\n+    static boolean assignTaskMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n+                                       final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n+                                       final Map<UUID, ClientState> clientStates,\n+                                       final Map<TaskId, Integer> tasksToRemainingStandbys,\n+                                       final int maxWarmupReplicas) {\n+        boolean warmupReplicasAssigned = false;\n+\n+        final ValidClientsByTaskLoadQueue clientsByTaskLoad =\n+            new ValidClientsByTaskLoadQueue(\n+                clientStates,\n+                (client, task) -> taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)\n+            );\n \n-        final Map<TaskId, UUID> taskToDestinationClient = new HashMap<>();\n-        for (final Map.Entry<UUID, List<TaskId>> clientEntry : balancedStatefulActiveTaskAssignment.entrySet()) {\n-            final UUID destination = clientEntry.getKey();\n-            for (final TaskId task : clientEntry.getValue()) {\n-                taskToDestinationClient.put(task, destination);\n+        final SortedSet<TaskMovement> taskMovements = new TreeSet<>(\n+            (movement, other) -> {\n+                final int numCaughtUpClients = tasksToCaughtUpClients.get(movement.task).size();\n+                final int otherNumCaughtUpClients = tasksToCaughtUpClients.get(other.task).size();\n+                if (numCaughtUpClients != otherNumCaughtUpClients) {\n+                    return numCaughtUpClients - otherNumCaughtUpClients;\n+                } else {\n+                    return movement.task.compareTo(other.task);\n+                }\n             }\n+        );\n+\n+        for (final Map.Entry<UUID, List<TaskId>> assignmentEntry : statefulActiveTaskAssignment.entrySet()) {\n+            final UUID client = assignmentEntry.getKey();\n+            final ClientState state = clientStates.get(client);\n+            for (final TaskId task : assignmentEntry.getValue()) {\n+                if (taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)) {\n+                    state.assignActive(task);\n+                } else {\n+                    final TaskMovement taskMovement = new TaskMovement(task,  client);\n+                    taskMovements.add(taskMovement);\n+                }\n+            }\n+            clientsByTaskLoad.offer(client);\n         }\n \n-        int remainingAllowedWarmupReplicas = maxWarmupReplicas;\n-        final List<TaskMovement> movements = new LinkedList<>();\n-        for (final Map.Entry<UUID, List<TaskId>> sourceClientEntry : statefulActiveTaskAssignment.entrySet()) {\n-            final UUID source = sourceClientEntry.getKey();\n+        int remainingWarmupReplicas = maxWarmupReplicas;\n+        for (final TaskMovement movement : taskMovements) {\n+            final UUID leastLoadedClient = clientsByTaskLoad.poll(movement.task);\n+            if (leastLoadedClient == null) {\n+                throw new IllegalStateException(\"Tried to move task to caught-up client but none exist\");\n+            }\n \n-            final Iterator<TaskId> sourceClientTasksIterator = sourceClientEntry.getValue().iterator();\n-            while (sourceClientTasksIterator.hasNext()) {\n-                final TaskId task = sourceClientTasksIterator.next();\n-                final UUID destination = taskToDestinationClient.get(task);\n-                if (destination == null) {\n-                    log.error(\"Task {} is assigned to client {} in initial assignment but has no owner in the final \" +\n-                                  \"balanced assignment.\", task, source);\n-                    throw new IllegalStateException(\"Found task in initial assignment that was not assigned in the final.\");\n-                } else if (!source.equals(destination)) {\n-                    if (destinationClientIsCaughtUp(task, destination, tasksToCaughtUpClients)) {\n-                        sourceClientTasksIterator.remove();\n-                        statefulActiveTaskAssignment.get(destination).add(task);\n-                    } else {\n-                        if (clientStates.get(destination).prevStandbyTasks().contains(task)\n-                                && tasksToRemainingStandbys.get(task) > 0\n-                        ) {\n-                            decrementRemainingStandbys(task, tasksToRemainingStandbys);\n-                        } else {\n-                            --remainingAllowedWarmupReplicas;\n-                        }\n+            final ClientState sourceClientState = clientStates.get(leastLoadedClient);\n+            sourceClientState.assignActive(movement.task);\n \n-                        movements.add(new TaskMovement(task, source, destination));\n-                        if (remainingAllowedWarmupReplicas == 0) {\n-                            return movements;\n-                        }\n-                    }\n-                }\n+            final ClientState destinationClientState = clientStates.get(movement.destination);\n+            if (destinationClientState.prevStandbyTasks().contains(movement.task) && tasksToRemainingStandbys.get(movement.task) > 0) {\n+                decrementRemainingStandbys(movement.task, tasksToRemainingStandbys);\n+                destinationClientState.assignStandby(movement.task);\n+                warmupReplicasAssigned = true;\n+            } else if (remainingWarmupReplicas > 0) {\n+                --remainingWarmupReplicas;\n+                destinationClientState.assignStandby(movement.task);\n+                warmupReplicasAssigned = true;\n             }\n-        }\n-        return movements;\n-    }\n \n-    private static boolean destinationClientIsCaughtUp(final TaskId task,\n-                                                       final UUID destination,\n-                                                       final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients) {\n-        final Set<UUID> caughtUpClients = tasksToCaughtUpClients.get(task);\n-        return caughtUpClients != null && caughtUpClients.contains(destination);\n+            clientsByTaskLoad.offer(leastLoadedClient);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc0ODg0OA==", "bodyText": "I'd just like to say what an awesome tool for optimization this class is. Kudos to you and @cadonna .", "url": "https://github.com/apache/kafka/pull/8497#discussion_r410748848", "createdAt": "2020-04-18T20:48:47Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/ValidClientsByTaskLoadQueue.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+/**\n+ * Wraps a priority queue of clients and returns the next valid candidate(s) based on the current task assignment\n+ */\n+class ValidClientsByTaskLoadQueue {\n+    private final PriorityQueue<UUID> clientsByTaskLoad;\n+    private final BiFunction<UUID, TaskId, Boolean> validClientCriteria;\n+\n+    ValidClientsByTaskLoadQueue(final Map<UUID, ClientState> clientStates,\n+                                final BiFunction<UUID, TaskId, Boolean> validClientCriteria) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5ODM5MA=="}, "originalCommit": null, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc0OTc4Nw==", "bodyText": "I'm wondering if we should use ValidClientsByTaskLoadQueue (with a (c,t)-> true predicate) instead of a plain PriorityQueue here, since our queue now nicely enforces uniqueness of elements.", "url": "https://github.com/apache/kafka/pull/8497#discussion_r410749787", "createdAt": "2020-04-18T20:57:36Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignor.java", "diffHunk": "@@ -89,95 +88,72 @@ public boolean assign() {\n             return false;\n         }\n \n-        final Map<UUID, List<TaskId>> warmupTaskAssignment = initializeEmptyTaskAssignmentMap(sortedClients);\n-        final Map<UUID, List<TaskId>> standbyTaskAssignment = initializeEmptyTaskAssignmentMap(sortedClients);\n-        final Map<UUID, List<TaskId>> statelessActiveTaskAssignment = initializeEmptyTaskAssignmentMap(sortedClients);\n+        final Map<TaskId, Integer> tasksToRemainingStandbys =\n+            statefulTasks.stream().collect(Collectors.toMap(task -> task, t -> configs.numStandbyReplicas));\n \n-        // ---------------- Stateful Active Tasks ---------------- //\n+        final boolean followupRebalanceNeeded = assignStatefulActiveTasks(tasksToRemainingStandbys);\n \n-        final Map<UUID, List<TaskId>> statefulActiveTaskAssignment =\n-            new DefaultStateConstrainedBalancedAssignor().assign(\n-                statefulTasksToRankedCandidates,\n-                configs.balanceFactor,\n-                sortedClients,\n-                clientsToNumberOfThreads,\n-                tasksToCaughtUpClients\n-            );\n+        assignStandbyReplicaTasks(tasksToRemainingStandbys);\n+\n+        assignStatelessActiveTasks();\n \n-        // ---------------- Warmup Replica Tasks ---------------- //\n+        return followupRebalanceNeeded;\n+    }\n \n-        final Map<UUID, List<TaskId>> balancedStatefulActiveTaskAssignment =\n+    private boolean assignStatefulActiveTasks(final Map<TaskId, Integer> tasksToRemainingStandbys) {\n+        final Map<UUID, List<TaskId>> statefulActiveTaskAssignment =\n             new DefaultBalancedAssignor().assign(\n                 sortedClients,\n                 statefulTasks,\n                 clientsToNumberOfThreads,\n                 configs.balanceFactor);\n \n-        final Map<TaskId, Integer> tasksToRemainingStandbys =\n-            statefulTasks.stream().collect(Collectors.toMap(task -> task, t -> configs.numStandbyReplicas));\n-\n-        final List<TaskMovement> movements = getMovements(\n+        return assignTaskMovements(\n             statefulActiveTaskAssignment,\n-            balancedStatefulActiveTaskAssignment,\n             tasksToCaughtUpClients,\n             clientStates,\n             tasksToRemainingStandbys,\n-            configs.maxWarmupReplicas);\n-\n-        for (final TaskMovement movement : movements) {\n-            warmupTaskAssignment.get(movement.destination).add(movement.task);\n-        }\n-\n-        // ---------------- Standby Replica Tasks ---------------- //\n-\n-        final List<Map<UUID, List<TaskId>>> allTaskAssignmentMaps = asList(\n-            statefulActiveTaskAssignment,\n-            warmupTaskAssignment,\n-            standbyTaskAssignment,\n-            statelessActiveTaskAssignment\n+            configs.maxWarmupReplicas\n         );\n+    }\n \n-        final ValidClientsByTaskLoadQueue<UUID> clientsByStandbyTaskLoad =\n-            new ValidClientsByTaskLoadQueue<>(\n-                getClientPriorityQueueByTaskLoad(allTaskAssignmentMaps),\n-                allTaskAssignmentMaps\n+    private void assignStandbyReplicaTasks(final Map<TaskId, Integer> tasksToRemainingStandbys) {\n+        final ValidClientsByTaskLoadQueue standbyTaskClientsByTaskLoad =\n+            new ValidClientsByTaskLoadQueue(\n+                clientStates,\n+                (client, task) -> !clientStates.get(client).assignedTasks().contains(task)\n             );\n+        standbyTaskClientsByTaskLoad.offerAll(clientStates.keySet());\n \n         for (final TaskId task : statefulTasksToRankedCandidates.keySet()) {\n             final int numRemainingStandbys = tasksToRemainingStandbys.get(task);\n-            final List<UUID> clients = clientsByStandbyTaskLoad.poll(task, numRemainingStandbys);\n+            final List<UUID> clients = standbyTaskClientsByTaskLoad.poll(task, numRemainingStandbys);\n             for (final UUID client : clients) {\n-                standbyTaskAssignment.get(client).add(task);\n+                clientStates.get(client).assignStandby(task);\n             }\n-            clientsByStandbyTaskLoad.offer(clients);\n+            standbyTaskClientsByTaskLoad.offerAll(clients);\n+\n             final int numStandbysAssigned = clients.size();\n-            if (numStandbysAssigned < configs.numStandbyReplicas) {\n+            if (numStandbysAssigned < numRemainingStandbys) {\n                 log.warn(\"Unable to assign {} of {} standby tasks for task [{}]. \" +\n                              \"There is not enough available capacity. You should \" +\n                              \"increase the number of threads and/or application instances \" +\n                              \"to maintain the requested number of standby replicas.\",\n-                    configs.numStandbyReplicas - numStandbysAssigned, configs.numStandbyReplicas, task);\n+                         numRemainingStandbys - numStandbysAssigned, configs.numStandbyReplicas, task);\n             }\n         }\n+    }\n \n-        // ---------------- Stateless Active Tasks ---------------- //\n-\n-        final PriorityQueue<UUID> statelessActiveTaskClientsQueue = getClientPriorityQueueByTaskLoad(allTaskAssignmentMaps);\n+    private void assignStatelessActiveTasks() {\n+        final PriorityQueue<UUID> statelessActiveTaskClientsQueue = getClientPriorityQueueByTaskLoad(clientStates);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc1MDIzMw==", "bodyText": "Should we instead adapt the test to verify that it produces a valid assignment for mixed instances during version probing? Or is that already covered?", "url": "https://github.com/apache/kafka/pull/8497#discussion_r410750233", "createdAt": "2020-04-18T21:01:35Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamsPartitionAssignorTest.java", "diffHunk": "@@ -1610,79 +1610,6 @@ public void shouldReturnInterleavedAssignmentWithUnrevokedPartitionsRemovedWhenN\n             )));\n     }\n \n-    @Test\n-    public void shouldReturnNormalAssignmentForOldAndFutureInstancesDuringVersionProbing() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4OTI0NQ=="}, "originalCommit": null, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc1MDM4Ng==", "bodyText": "Yay!", "url": "https://github.com/apache/kafka/pull/8497#discussion_r410750386", "createdAt": "2020-04-18T21:03:01Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskAssignorConvergenceTest.java", "diffHunk": "@@ -266,7 +265,6 @@ public void assignmentShouldConvergeAfterAddingNode() {\n         verifyValidAssignment(numStandbyReplicas, harness);\n     }\n \n-    @Ignore // Adding this failing test before adding the code that fixes it", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDM5ODQ0", "url": "https://github.com/apache/kafka/pull/8497#pullrequestreview-396439844", "createdAt": "2020-04-20T13:13:43Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxMzoxMzo0NFrOGITy3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNjo0MTo1OFrOGIdskg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM2NjExMQ==", "bodyText": "I love it when a comment gets killed by a meaningful method name!", "url": "https://github.com/apache/kafka/pull/8497#discussion_r411366111", "createdAt": "2020-04-20T13:13:44Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignor.java", "diffHunk": "@@ -89,95 +88,72 @@ public boolean assign() {\n             return false;\n         }\n \n-        final Map<UUID, List<TaskId>> warmupTaskAssignment = initializeEmptyTaskAssignmentMap(sortedClients);\n-        final Map<UUID, List<TaskId>> standbyTaskAssignment = initializeEmptyTaskAssignmentMap(sortedClients);\n-        final Map<UUID, List<TaskId>> statelessActiveTaskAssignment = initializeEmptyTaskAssignmentMap(sortedClients);\n+        final Map<TaskId, Integer> tasksToRemainingStandbys =\n+            statefulTasks.stream().collect(Collectors.toMap(task -> task, t -> configs.numStandbyReplicas));\n \n-        // ---------------- Stateful Active Tasks ---------------- //\n+        final boolean followupRebalanceNeeded = assignStatefulActiveTasks(tasksToRemainingStandbys);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM2ODk5MQ==", "bodyText": "prop:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Map<UUID, List<TaskId>> statefulActiveTaskAssignment =\n          \n          \n            \n                        new DefaultBalancedAssignor().assign(\n          \n          \n            \n                            sortedClients,\n          \n          \n            \n                            statefulTasks,\n          \n          \n            \n                            clientsToNumberOfThreads,\n          \n          \n            \n                            configs.balanceFactor);\n          \n          \n            \n                    final Map<UUID, List<TaskId>> statefulActiveTaskAssignment = new DefaultBalancedAssignor().assign(\n          \n          \n            \n                        sortedClients,\n          \n          \n            \n                        statefulTasks,\n          \n          \n            \n                        clientsToNumberOfThreads,\n          \n          \n            \n                        configs.balanceFactor\n          \n          \n            \n                    );", "url": "https://github.com/apache/kafka/pull/8497#discussion_r411368991", "createdAt": "2020-04-20T13:17:49Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignor.java", "diffHunk": "@@ -89,95 +88,72 @@ public boolean assign() {\n             return false;\n         }\n \n-        final Map<UUID, List<TaskId>> warmupTaskAssignment = initializeEmptyTaskAssignmentMap(sortedClients);\n-        final Map<UUID, List<TaskId>> standbyTaskAssignment = initializeEmptyTaskAssignmentMap(sortedClients);\n-        final Map<UUID, List<TaskId>> statelessActiveTaskAssignment = initializeEmptyTaskAssignmentMap(sortedClients);\n+        final Map<TaskId, Integer> tasksToRemainingStandbys =\n+            statefulTasks.stream().collect(Collectors.toMap(task -> task, t -> configs.numStandbyReplicas));\n \n-        // ---------------- Stateful Active Tasks ---------------- //\n+        final boolean followupRebalanceNeeded = assignStatefulActiveTasks(tasksToRemainingStandbys);\n \n-        final Map<UUID, List<TaskId>> statefulActiveTaskAssignment =\n-            new DefaultStateConstrainedBalancedAssignor().assign(\n-                statefulTasksToRankedCandidates,\n-                configs.balanceFactor,\n-                sortedClients,\n-                clientsToNumberOfThreads,\n-                tasksToCaughtUpClients\n-            );\n+        assignStandbyReplicaTasks(tasksToRemainingStandbys);\n+\n+        assignStatelessActiveTasks();\n \n-        // ---------------- Warmup Replica Tasks ---------------- //\n+        return followupRebalanceNeeded;\n+    }\n \n-        final Map<UUID, List<TaskId>> balancedStatefulActiveTaskAssignment =\n+    private boolean assignStatefulActiveTasks(final Map<TaskId, Integer> tasksToRemainingStandbys) {\n+        final Map<UUID, List<TaskId>> statefulActiveTaskAssignment =\n             new DefaultBalancedAssignor().assign(\n                 sortedClients,\n                 statefulTasks,\n                 clientsToNumberOfThreads,\n                 configs.balanceFactor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM4MzcyNQ==", "bodyText": "prop:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final ValidClientsByTaskLoadQueue clientsByTaskLoad =\n          \n          \n            \n                        new ValidClientsByTaskLoadQueue(\n          \n          \n            \n                            clientStates,\n          \n          \n            \n                            (client, task) -> taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)\n          \n          \n            \n                        );\n          \n          \n            \n                    final ValidClientsByTaskLoadQueue clientsByTaskLoad = new ValidClientsByTaskLoadQueue(\n          \n          \n            \n                        clientStates,\n          \n          \n            \n                        (client, task) -> taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)\n          \n          \n            \n                    );", "url": "https://github.com/apache/kafka/pull/8497#discussion_r411383725", "createdAt": "2020-04-20T13:38:08Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovement.java", "diffHunk": "@@ -16,128 +16,94 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentUtils.taskIsCaughtUpOnClient;\n+\n import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n import java.util.SortedSet;\n+import java.util.TreeSet;\n import java.util.UUID;\n import org.apache.kafka.streams.processor.TaskId;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n public class TaskMovement {\n-    private static final Logger log = LoggerFactory.getLogger(TaskMovement.class);\n-\n     final TaskId task;\n-    final UUID source;\n-    final UUID destination;\n+    private final UUID destination;\n \n-    TaskMovement(final TaskId task, final UUID source, final UUID destination) {\n+    TaskMovement(final TaskId task, final UUID destination) {\n         this.task = task;\n-        this.source = source;\n         this.destination = destination;\n     }\n \n-    @Override\n-    public boolean equals(final Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        final TaskMovement movement = (TaskMovement) o;\n-        return Objects.equals(task, movement.task) &&\n-                   Objects.equals(source, movement.source) &&\n-                   Objects.equals(destination, movement.destination);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(task, source, destination);\n-    }\n-\n     /**\n-     * Computes the movement of tasks from the state constrained to the balanced assignment, up to the configured\n-     * {@code max.warmup.replicas}. A movement corresponds to a warmup replica on the destination client, with\n-     * a few exceptional cases:\n-     * <p>\n-     * 1. Tasks whose destination clients are caught-up, or whose source clients are not caught-up, will be moved\n-     * immediately from the source to the destination in the state constrained assignment\n-     * 2. Tasks whose destination client previously had this task as a standby will not be counted towards the total\n-     * {@code max.warmup.replicas}. Instead they will be counted against that task's total {@code num.standby.replicas}.\n-     *\n-     * @param statefulActiveTaskAssignment the initial, state constrained assignment, with the source clients\n-     * @param balancedStatefulActiveTaskAssignment the final, balanced assignment, with the destination clients\n-     * @return list of the task movements from statefulActiveTaskAssignment to balancedStatefulActiveTaskAssignment\n+     * @return whether any warmup replicas were assigned\n      */\n-    static List<TaskMovement> getMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n-                                           final Map<UUID, List<TaskId>> balancedStatefulActiveTaskAssignment,\n-                                           final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n-                                           final Map<UUID, ClientState> clientStates,\n-                                           final Map<TaskId, Integer> tasksToRemainingStandbys,\n-                                           final int maxWarmupReplicas) {\n-        if (statefulActiveTaskAssignment.size() != balancedStatefulActiveTaskAssignment.size()) {\n-            throw new IllegalStateException(\"Tried to compute movements but assignments differ in size.\");\n-        }\n+    static boolean assignTaskMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n+                                       final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n+                                       final Map<UUID, ClientState> clientStates,\n+                                       final Map<TaskId, Integer> tasksToRemainingStandbys,\n+                                       final int maxWarmupReplicas) {\n+        boolean warmupReplicasAssigned = false;\n+\n+        final ValidClientsByTaskLoadQueue clientsByTaskLoad =\n+            new ValidClientsByTaskLoadQueue(\n+                clientStates,\n+                (client, task) -> taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)\n+            );", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQwNDM0NQ==", "bodyText": "Q: I do not understand why we need uniqueClients here? Would it not suffice to check for clientsByTaskLoad.contains(client)?", "url": "https://github.com/apache/kafka/pull/8497#discussion_r411404345", "createdAt": "2020-04-20T14:03:43Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/ValidClientsByTaskLoadQueue.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+/**\n+ * Wraps a priority queue of clients and returns the next valid candidate(s) based on the current task assignment\n+ */\n+class ValidClientsByTaskLoadQueue {\n+    private final PriorityQueue<UUID> clientsByTaskLoad;\n+    private final BiFunction<UUID, TaskId, Boolean> validClientCriteria;\n+    private final Set<UUID> uniqueClients = new HashSet<>();\n+\n+    ValidClientsByTaskLoadQueue(final Map<UUID, ClientState> clientStates,\n+                                final BiFunction<UUID, TaskId, Boolean> validClientCriteria) {\n+        clientsByTaskLoad = getClientPriorityQueueByTaskLoad(clientStates);\n+        this.validClientCriteria = validClientCriteria;\n+    }\n+\n+    /**\n+=     * @return the next least loaded client that satisfies the given criteria, or null if none do\n+     */\n+    UUID poll(final TaskId task) {\n+        final List<UUID> validClient = poll(task, 1);\n+        return validClient.isEmpty() ? null : validClient.get(0);\n+    }\n+\n+    /**\n+     * @return the next N <= {@code numClientsPerTask} clients in the underlying priority queue that are valid\n+     * candidates for the given task\n+     */\n+    List<UUID> poll(final TaskId task, final int numClients) {\n+        final List<UUID> nextLeastLoadedValidClients = new LinkedList<>();\n+        final Set<UUID> invalidPolledClients = new HashSet<>();\n+        while (nextLeastLoadedValidClients.size() < numClients) {\n+            UUID candidateClient;\n+            while (true) {\n+                candidateClient = clientsByTaskLoad.poll();\n+                if (candidateClient == null) {\n+                    offerAll(invalidPolledClients);\n+                    return nextLeastLoadedValidClients;\n+                }\n+\n+                if (validClientCriteria.apply(candidateClient, task)) {\n+                    nextLeastLoadedValidClients.add(candidateClient);\n+                    break;\n+                } else {\n+                    invalidPolledClients.add(candidateClient);\n+                }\n+            }\n+        }\n+        offerAll(invalidPolledClients);\n+        return nextLeastLoadedValidClients;\n+    }\n+\n+    void offerAll(final Collection<UUID> clients) {\n+        for (final UUID client : clients) {\n+            offer(client);\n+        }\n+    }\n+\n+    void offer(final UUID client) {\n+        if (uniqueClients.contains(client)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQzODAwOQ==", "bodyText": "We can possibly clarify it my making the name of taskIsCaughtUpOnClient more complete: eitherClientIsCaughtUpOnTaskOrNoClientIs.\n\nAgree on that\n\nBut I wouldn't hesitate to also write a nice letter to future us here as a comment.\n\nWhat about writing the nice letter to future us in the exception message instead of a comment?", "url": "https://github.com/apache/kafka/pull/8497#discussion_r411438009", "createdAt": "2020-04-20T14:46:10Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovement.java", "diffHunk": "@@ -16,128 +16,94 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentUtils.taskIsCaughtUpOnClient;\n+\n import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n import java.util.SortedSet;\n+import java.util.TreeSet;\n import java.util.UUID;\n import org.apache.kafka.streams.processor.TaskId;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n public class TaskMovement {\n-    private static final Logger log = LoggerFactory.getLogger(TaskMovement.class);\n-\n     final TaskId task;\n-    final UUID source;\n-    final UUID destination;\n+    private final UUID destination;\n \n-    TaskMovement(final TaskId task, final UUID source, final UUID destination) {\n+    TaskMovement(final TaskId task, final UUID destination) {\n         this.task = task;\n-        this.source = source;\n         this.destination = destination;\n     }\n \n-    @Override\n-    public boolean equals(final Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        final TaskMovement movement = (TaskMovement) o;\n-        return Objects.equals(task, movement.task) &&\n-                   Objects.equals(source, movement.source) &&\n-                   Objects.equals(destination, movement.destination);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(task, source, destination);\n-    }\n-\n     /**\n-     * Computes the movement of tasks from the state constrained to the balanced assignment, up to the configured\n-     * {@code max.warmup.replicas}. A movement corresponds to a warmup replica on the destination client, with\n-     * a few exceptional cases:\n-     * <p>\n-     * 1. Tasks whose destination clients are caught-up, or whose source clients are not caught-up, will be moved\n-     * immediately from the source to the destination in the state constrained assignment\n-     * 2. Tasks whose destination client previously had this task as a standby will not be counted towards the total\n-     * {@code max.warmup.replicas}. Instead they will be counted against that task's total {@code num.standby.replicas}.\n-     *\n-     * @param statefulActiveTaskAssignment the initial, state constrained assignment, with the source clients\n-     * @param balancedStatefulActiveTaskAssignment the final, balanced assignment, with the destination clients\n-     * @return list of the task movements from statefulActiveTaskAssignment to balancedStatefulActiveTaskAssignment\n+     * @return whether any warmup replicas were assigned\n      */\n-    static List<TaskMovement> getMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n-                                           final Map<UUID, List<TaskId>> balancedStatefulActiveTaskAssignment,\n-                                           final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n-                                           final Map<UUID, ClientState> clientStates,\n-                                           final Map<TaskId, Integer> tasksToRemainingStandbys,\n-                                           final int maxWarmupReplicas) {\n-        if (statefulActiveTaskAssignment.size() != balancedStatefulActiveTaskAssignment.size()) {\n-            throw new IllegalStateException(\"Tried to compute movements but assignments differ in size.\");\n-        }\n+    static boolean assignTaskMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n+                                       final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n+                                       final Map<UUID, ClientState> clientStates,\n+                                       final Map<TaskId, Integer> tasksToRemainingStandbys,\n+                                       final int maxWarmupReplicas) {\n+        boolean warmupReplicasAssigned = false;\n+\n+        final ValidClientsByTaskLoadQueue clientsByTaskLoad =\n+            new ValidClientsByTaskLoadQueue(\n+                clientStates,\n+                (client, task) -> taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)\n+            );\n \n-        final Map<TaskId, UUID> taskToDestinationClient = new HashMap<>();\n-        for (final Map.Entry<UUID, List<TaskId>> clientEntry : balancedStatefulActiveTaskAssignment.entrySet()) {\n-            final UUID destination = clientEntry.getKey();\n-            for (final TaskId task : clientEntry.getValue()) {\n-                taskToDestinationClient.put(task, destination);\n+        final SortedSet<TaskMovement> taskMovements = new TreeSet<>(\n+            (movement, other) -> {\n+                final int numCaughtUpClients = tasksToCaughtUpClients.get(movement.task).size();\n+                final int otherNumCaughtUpClients = tasksToCaughtUpClients.get(other.task).size();\n+                if (numCaughtUpClients != otherNumCaughtUpClients) {\n+                    return numCaughtUpClients - otherNumCaughtUpClients;\n+                } else {\n+                    return movement.task.compareTo(other.task);\n+                }\n             }\n+        );\n+\n+        for (final Map.Entry<UUID, List<TaskId>> assignmentEntry : statefulActiveTaskAssignment.entrySet()) {\n+            final UUID client = assignmentEntry.getKey();\n+            final ClientState state = clientStates.get(client);\n+            for (final TaskId task : assignmentEntry.getValue()) {\n+                if (taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)) {\n+                    state.assignActive(task);\n+                } else {\n+                    final TaskMovement taskMovement = new TaskMovement(task,  client);\n+                    taskMovements.add(taskMovement);\n+                }\n+            }\n+            clientsByTaskLoad.offer(client);\n         }\n \n-        int remainingAllowedWarmupReplicas = maxWarmupReplicas;\n-        final List<TaskMovement> movements = new LinkedList<>();\n-        for (final Map.Entry<UUID, List<TaskId>> sourceClientEntry : statefulActiveTaskAssignment.entrySet()) {\n-            final UUID source = sourceClientEntry.getKey();\n+        int remainingWarmupReplicas = maxWarmupReplicas;\n+        for (final TaskMovement movement : taskMovements) {\n+            final UUID leastLoadedClient = clientsByTaskLoad.poll(movement.task);\n+            if (leastLoadedClient == null) {\n+                throw new IllegalStateException(\"Tried to move task to caught-up client but none exist\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc0NzA0NA=="}, "originalCommit": null, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ1NzU3NQ==", "bodyText": "prop:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final ValidClientsByTaskLoadQueue standbyTaskClientsByTaskLoad =\n          \n          \n            \n                        new ValidClientsByTaskLoadQueue(\n          \n          \n            \n                            clientStates,\n          \n          \n            \n                            (client, task) -> !clientStates.get(client).assignedTasks().contains(task)\n          \n          \n            \n                        );\n          \n          \n            \n                    final ValidClientsByTaskLoadQueue standbyTaskClientsByTaskLoad = new ValidClientsByTaskLoadQueue(\n          \n          \n            \n                        clientStates,\n          \n          \n            \n                        (client, task) -> !clientStates.get(client).assignedTasks().contains(task)\n          \n          \n            \n                    );", "url": "https://github.com/apache/kafka/pull/8497#discussion_r411457575", "createdAt": "2020-04-20T15:10:25Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignor.java", "diffHunk": "@@ -89,95 +88,72 @@ public boolean assign() {\n             return false;\n         }\n \n-        final Map<UUID, List<TaskId>> warmupTaskAssignment = initializeEmptyTaskAssignmentMap(sortedClients);\n-        final Map<UUID, List<TaskId>> standbyTaskAssignment = initializeEmptyTaskAssignmentMap(sortedClients);\n-        final Map<UUID, List<TaskId>> statelessActiveTaskAssignment = initializeEmptyTaskAssignmentMap(sortedClients);\n+        final Map<TaskId, Integer> tasksToRemainingStandbys =\n+            statefulTasks.stream().collect(Collectors.toMap(task -> task, t -> configs.numStandbyReplicas));\n \n-        // ---------------- Stateful Active Tasks ---------------- //\n+        final boolean followupRebalanceNeeded = assignStatefulActiveTasks(tasksToRemainingStandbys);\n \n-        final Map<UUID, List<TaskId>> statefulActiveTaskAssignment =\n-            new DefaultStateConstrainedBalancedAssignor().assign(\n-                statefulTasksToRankedCandidates,\n-                configs.balanceFactor,\n-                sortedClients,\n-                clientsToNumberOfThreads,\n-                tasksToCaughtUpClients\n-            );\n+        assignStandbyReplicaTasks(tasksToRemainingStandbys);\n+\n+        assignStatelessActiveTasks();\n \n-        // ---------------- Warmup Replica Tasks ---------------- //\n+        return followupRebalanceNeeded;\n+    }\n \n-        final Map<UUID, List<TaskId>> balancedStatefulActiveTaskAssignment =\n+    private boolean assignStatefulActiveTasks(final Map<TaskId, Integer> tasksToRemainingStandbys) {\n+        final Map<UUID, List<TaskId>> statefulActiveTaskAssignment =\n             new DefaultBalancedAssignor().assign(\n                 sortedClients,\n                 statefulTasks,\n                 clientsToNumberOfThreads,\n                 configs.balanceFactor);\n \n-        final Map<TaskId, Integer> tasksToRemainingStandbys =\n-            statefulTasks.stream().collect(Collectors.toMap(task -> task, t -> configs.numStandbyReplicas));\n-\n-        final List<TaskMovement> movements = getMovements(\n+        return assignTaskMovements(\n             statefulActiveTaskAssignment,\n-            balancedStatefulActiveTaskAssignment,\n             tasksToCaughtUpClients,\n             clientStates,\n             tasksToRemainingStandbys,\n-            configs.maxWarmupReplicas);\n-\n-        for (final TaskMovement movement : movements) {\n-            warmupTaskAssignment.get(movement.destination).add(movement.task);\n-        }\n-\n-        // ---------------- Standby Replica Tasks ---------------- //\n-\n-        final List<Map<UUID, List<TaskId>>> allTaskAssignmentMaps = asList(\n-            statefulActiveTaskAssignment,\n-            warmupTaskAssignment,\n-            standbyTaskAssignment,\n-            statelessActiveTaskAssignment\n+            configs.maxWarmupReplicas\n         );\n+    }\n \n-        final ValidClientsByTaskLoadQueue<UUID> clientsByStandbyTaskLoad =\n-            new ValidClientsByTaskLoadQueue<>(\n-                getClientPriorityQueueByTaskLoad(allTaskAssignmentMaps),\n-                allTaskAssignmentMaps\n+    private void assignStandbyReplicaTasks(final Map<TaskId, Integer> tasksToRemainingStandbys) {\n+        final ValidClientsByTaskLoadQueue standbyTaskClientsByTaskLoad =\n+            new ValidClientsByTaskLoadQueue(\n+                clientStates,\n+                (client, task) -> !clientStates.get(client).assignedTasks().contains(task)\n             );", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ2ODcyMw==", "bodyText": "req: Please add unit tests for this class.", "url": "https://github.com/apache/kafka/pull/8497#discussion_r411468723", "createdAt": "2020-04-20T15:24:21Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/ValidClientsByTaskLoadQueue.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+/**\n+ * Wraps a priority queue of clients and returns the next valid candidate(s) based on the current task assignment\n+ */\n+class ValidClientsByTaskLoadQueue {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ3MTE2Nw==", "bodyText": "I do not remember having contributed to this awesomeness. It is all @ableegoldman 's merit.", "url": "https://github.com/apache/kafka/pull/8497#discussion_r411471167", "createdAt": "2020-04-20T15:27:22Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/ValidClientsByTaskLoadQueue.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+/**\n+ * Wraps a priority queue of clients and returns the next valid candidate(s) based on the current task assignment\n+ */\n+class ValidClientsByTaskLoadQueue {\n+    private final PriorityQueue<UUID> clientsByTaskLoad;\n+    private final BiFunction<UUID, TaskId, Boolean> validClientCriteria;\n+\n+    ValidClientsByTaskLoadQueue(final Map<UUID, ClientState> clientStates,\n+                                final BiFunction<UUID, TaskId, Boolean> validClientCriteria) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5ODM5MA=="}, "originalCommit": null, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUyODMzOA==", "bodyText": "Q: Why do we even care at all whether the task was running on the client? What if we just assign a real stand-by task if we have a spare one?", "url": "https://github.com/apache/kafka/pull/8497#discussion_r411528338", "createdAt": "2020-04-20T16:41:58Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovement.java", "diffHunk": "@@ -16,128 +16,94 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentUtils.taskIsCaughtUpOnClient;\n+\n import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n import java.util.SortedSet;\n+import java.util.TreeSet;\n import java.util.UUID;\n import org.apache.kafka.streams.processor.TaskId;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n public class TaskMovement {\n-    private static final Logger log = LoggerFactory.getLogger(TaskMovement.class);\n-\n     final TaskId task;\n-    final UUID source;\n-    final UUID destination;\n+    private final UUID destination;\n \n-    TaskMovement(final TaskId task, final UUID source, final UUID destination) {\n+    TaskMovement(final TaskId task, final UUID destination) {\n         this.task = task;\n-        this.source = source;\n         this.destination = destination;\n     }\n \n-    @Override\n-    public boolean equals(final Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-        final TaskMovement movement = (TaskMovement) o;\n-        return Objects.equals(task, movement.task) &&\n-                   Objects.equals(source, movement.source) &&\n-                   Objects.equals(destination, movement.destination);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(task, source, destination);\n-    }\n-\n     /**\n-     * Computes the movement of tasks from the state constrained to the balanced assignment, up to the configured\n-     * {@code max.warmup.replicas}. A movement corresponds to a warmup replica on the destination client, with\n-     * a few exceptional cases:\n-     * <p>\n-     * 1. Tasks whose destination clients are caught-up, or whose source clients are not caught-up, will be moved\n-     * immediately from the source to the destination in the state constrained assignment\n-     * 2. Tasks whose destination client previously had this task as a standby will not be counted towards the total\n-     * {@code max.warmup.replicas}. Instead they will be counted against that task's total {@code num.standby.replicas}.\n-     *\n-     * @param statefulActiveTaskAssignment the initial, state constrained assignment, with the source clients\n-     * @param balancedStatefulActiveTaskAssignment the final, balanced assignment, with the destination clients\n-     * @return list of the task movements from statefulActiveTaskAssignment to balancedStatefulActiveTaskAssignment\n+     * @return whether any warmup replicas were assigned\n      */\n-    static List<TaskMovement> getMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n-                                           final Map<UUID, List<TaskId>> balancedStatefulActiveTaskAssignment,\n-                                           final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n-                                           final Map<UUID, ClientState> clientStates,\n-                                           final Map<TaskId, Integer> tasksToRemainingStandbys,\n-                                           final int maxWarmupReplicas) {\n-        if (statefulActiveTaskAssignment.size() != balancedStatefulActiveTaskAssignment.size()) {\n-            throw new IllegalStateException(\"Tried to compute movements but assignments differ in size.\");\n-        }\n+    static boolean assignTaskMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n+                                       final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n+                                       final Map<UUID, ClientState> clientStates,\n+                                       final Map<TaskId, Integer> tasksToRemainingStandbys,\n+                                       final int maxWarmupReplicas) {\n+        boolean warmupReplicasAssigned = false;\n+\n+        final ValidClientsByTaskLoadQueue clientsByTaskLoad =\n+            new ValidClientsByTaskLoadQueue(\n+                clientStates,\n+                (client, task) -> taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)\n+            );\n \n-        final Map<TaskId, UUID> taskToDestinationClient = new HashMap<>();\n-        for (final Map.Entry<UUID, List<TaskId>> clientEntry : balancedStatefulActiveTaskAssignment.entrySet()) {\n-            final UUID destination = clientEntry.getKey();\n-            for (final TaskId task : clientEntry.getValue()) {\n-                taskToDestinationClient.put(task, destination);\n+        final SortedSet<TaskMovement> taskMovements = new TreeSet<>(\n+            (movement, other) -> {\n+                final int numCaughtUpClients = tasksToCaughtUpClients.get(movement.task).size();\n+                final int otherNumCaughtUpClients = tasksToCaughtUpClients.get(other.task).size();\n+                if (numCaughtUpClients != otherNumCaughtUpClients) {\n+                    return numCaughtUpClients - otherNumCaughtUpClients;\n+                } else {\n+                    return movement.task.compareTo(other.task);\n+                }\n             }\n+        );\n+\n+        for (final Map.Entry<UUID, List<TaskId>> assignmentEntry : statefulActiveTaskAssignment.entrySet()) {\n+            final UUID client = assignmentEntry.getKey();\n+            final ClientState state = clientStates.get(client);\n+            for (final TaskId task : assignmentEntry.getValue()) {\n+                if (taskIsCaughtUpOnClient(task, client, tasksToCaughtUpClients)) {\n+                    state.assignActive(task);\n+                } else {\n+                    final TaskMovement taskMovement = new TaskMovement(task,  client);\n+                    taskMovements.add(taskMovement);\n+                }\n+            }\n+            clientsByTaskLoad.offer(client);\n         }\n \n-        int remainingAllowedWarmupReplicas = maxWarmupReplicas;\n-        final List<TaskMovement> movements = new LinkedList<>();\n-        for (final Map.Entry<UUID, List<TaskId>> sourceClientEntry : statefulActiveTaskAssignment.entrySet()) {\n-            final UUID source = sourceClientEntry.getKey();\n+        int remainingWarmupReplicas = maxWarmupReplicas;\n+        for (final TaskMovement movement : taskMovements) {\n+            final UUID leastLoadedClient = clientsByTaskLoad.poll(movement.task);\n+            if (leastLoadedClient == null) {\n+                throw new IllegalStateException(\"Tried to move task to caught-up client but none exist\");\n+            }\n \n-            final Iterator<TaskId> sourceClientTasksIterator = sourceClientEntry.getValue().iterator();\n-            while (sourceClientTasksIterator.hasNext()) {\n-                final TaskId task = sourceClientTasksIterator.next();\n-                final UUID destination = taskToDestinationClient.get(task);\n-                if (destination == null) {\n-                    log.error(\"Task {} is assigned to client {} in initial assignment but has no owner in the final \" +\n-                                  \"balanced assignment.\", task, source);\n-                    throw new IllegalStateException(\"Found task in initial assignment that was not assigned in the final.\");\n-                } else if (!source.equals(destination)) {\n-                    if (destinationClientIsCaughtUp(task, destination, tasksToCaughtUpClients)) {\n-                        sourceClientTasksIterator.remove();\n-                        statefulActiveTaskAssignment.get(destination).add(task);\n-                    } else {\n-                        if (clientStates.get(destination).prevStandbyTasks().contains(task)\n-                                && tasksToRemainingStandbys.get(task) > 0\n-                        ) {\n-                            decrementRemainingStandbys(task, tasksToRemainingStandbys);\n-                        } else {\n-                            --remainingAllowedWarmupReplicas;\n-                        }\n+            final ClientState sourceClientState = clientStates.get(leastLoadedClient);\n+            sourceClientState.assignActive(movement.task);\n \n-                        movements.add(new TaskMovement(task, source, destination));\n-                        if (remainingAllowedWarmupReplicas == 0) {\n-                            return movements;\n-                        }\n-                    }\n-                }\n+            final ClientState destinationClientState = clientStates.get(movement.destination);\n+            if (destinationClientState.prevStandbyTasks().contains(movement.task) && tasksToRemainingStandbys.get(movement.task) > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDc0NzYwNw=="}, "originalCommit": null, "originalPosition": 163}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42b300e7c21d31ac08354ab3419c96181339a37a", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/42b300e7c21d31ac08354ab3419c96181339a37a", "committedDate": "2020-04-20T22:26:01Z", "message": "fix bugs in previousAssignmentIsValid"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22a670750c1998b2ada9d732dba3acb4360dcf9e", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/22a670750c1998b2ada9d732dba3acb4360dcf9e", "committedDate": "2020-04-20T22:26:01Z", "message": "random convergence test is passing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "957ee75f9fea26907609dc129697be70ecff3a73", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/957ee75f9fea26907609dc129697be70ecff3a73", "committedDate": "2020-04-20T22:26:01Z", "message": "remove unused classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2ba04e79c5dd0fe92a92d3d03717c22481a2739", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/c2ba04e79c5dd0fe92a92d3d03717c22481a2739", "committedDate": "2020-04-20T22:26:01Z", "message": "clean up TaskMovementTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73aa71a13bbd02ab915b0a7996a1fcd0549cf443", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/73aa71a13bbd02ab915b0a7996a1fcd0549cf443", "committedDate": "2020-04-20T22:26:01Z", "message": "fix broken HATAT test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae3aebf2b2a4b0600d66ad6480023e68410fa564", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/ae3aebf2b2a4b0600d66ad6480023e68410fa564", "committedDate": "2020-04-20T22:26:01Z", "message": "fix remaining HATAT tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e5cddb00c1535406a3ac85da19c1b16d66148a7", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/1e5cddb00c1535406a3ac85da19c1b16d66148a7", "committedDate": "2020-04-20T22:26:01Z", "message": "checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3271af6a83daded756be70e8026cb92ad701fa3", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/e3271af6a83daded756be70e8026cb92ad701fa3", "committedDate": "2020-04-20T22:26:01Z", "message": "fix up SPAT tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0071faf053d48961272d0c8c9d4a1ee2c59d074", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/e0071faf053d48961272d0c8c9d4a1ee2c59d074", "committedDate": "2020-04-20T22:26:01Z", "message": "first set of github reviews"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ebc11ce1bd2e3185b62454598a0a0a6c83503ef", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/8ebc11ce1bd2e3185b62454598a0a0a6c83503ef", "committedDate": "2020-04-20T22:26:01Z", "message": "remove ignore annotation from convergence tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2709ba0245cddcf4a6c4051050f34923f99cd36a", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/2709ba0245cddcf4a6c4051050f34923f99cd36a", "committedDate": "2020-04-20T22:26:01Z", "message": "remove unused ignore import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "864a539e33f5927d00d0914901d918da78662260", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/864a539e33f5927d00d0914901d918da78662260", "committedDate": "2020-04-21T03:30:46Z", "message": "first set of github review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "864a539e33f5927d00d0914901d918da78662260", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/864a539e33f5927d00d0914901d918da78662260", "committedDate": "2020-04-21T03:30:46Z", "message": "first set of github review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67d20fdc83eb780157be6f1aecd20932b94c916b", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/67d20fdc83eb780157be6f1aecd20932b94c916b", "committedDate": "2020-04-21T04:12:12Z", "message": "add tests, helper method for ClientState in tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MTc2NjIz", "url": "https://github.com/apache/kafka/pull/8497#pullrequestreview-397176623", "createdAt": "2020-04-21T09:58:14Z", "commit": {"oid": "67d20fdc83eb780157be6f1aecd20932b94c916b"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwOTo1ODoxNFrOGI9UXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMDo1MzoxNFrOGI_b5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA0NjQyOQ==", "bodyText": "Got it!\nThat means, we get O(n) for all cases where we first poll() and then offer() the same clients because those clients are contained in uniqueClients, i.e.:\n\nHighAvailabilityTaskAssignor@155\nHighAvailabilityTaskAssignor@131\nTaskMovement@94\nValidClientsByTaskLoadQueue@76\nValidClientsByTaskLoadQueue@88\n\nThose are the majority of the calls to offer() and offerAll(). Additionally, the last two occurrences in the list are called in each call to poll(). In poll(), if the top does not satisfy the criteria it is added to invalidPolledClients which then is added with offerAll(). For each element of invalidPolledClients the whole queue clientsByTaskLoad is scanned, since each element is contained in uniqueClients but not in clientsByTaskLoad. This results in O(n^2).\nAFAIU, we need the uniqueness check because of TaskMovement@99.\nIf we update uniqueClients also in poll(), we would avoid O(n^2) for poll() and restrict O(n) to the case at TaskMovement@99.\n\nDoes it really matter?\n\nI'm not also sure. Performance test would be the only way to tell.", "url": "https://github.com/apache/kafka/pull/8497#discussion_r412046429", "createdAt": "2020-04-21T09:58:14Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/ValidClientsByTaskLoadQueue.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+/**\n+ * Wraps a priority queue of clients and returns the next valid candidate(s) based on the current task assignment\n+ */\n+class ValidClientsByTaskLoadQueue {\n+    private final PriorityQueue<UUID> clientsByTaskLoad;\n+    private final BiFunction<UUID, TaskId, Boolean> validClientCriteria;\n+    private final Set<UUID> uniqueClients = new HashSet<>();\n+\n+    ValidClientsByTaskLoadQueue(final Map<UUID, ClientState> clientStates,\n+                                final BiFunction<UUID, TaskId, Boolean> validClientCriteria) {\n+        clientsByTaskLoad = getClientPriorityQueueByTaskLoad(clientStates);\n+        this.validClientCriteria = validClientCriteria;\n+    }\n+\n+    /**\n+=     * @return the next least loaded client that satisfies the given criteria, or null if none do\n+     */\n+    UUID poll(final TaskId task) {\n+        final List<UUID> validClient = poll(task, 1);\n+        return validClient.isEmpty() ? null : validClient.get(0);\n+    }\n+\n+    /**\n+     * @return the next N <= {@code numClientsPerTask} clients in the underlying priority queue that are valid\n+     * candidates for the given task\n+     */\n+    List<UUID> poll(final TaskId task, final int numClients) {\n+        final List<UUID> nextLeastLoadedValidClients = new LinkedList<>();\n+        final Set<UUID> invalidPolledClients = new HashSet<>();\n+        while (nextLeastLoadedValidClients.size() < numClients) {\n+            UUID candidateClient;\n+            while (true) {\n+                candidateClient = clientsByTaskLoad.poll();\n+                if (candidateClient == null) {\n+                    offerAll(invalidPolledClients);\n+                    return nextLeastLoadedValidClients;\n+                }\n+\n+                if (validClientCriteria.apply(candidateClient, task)) {\n+                    nextLeastLoadedValidClients.add(candidateClient);\n+                    break;\n+                } else {\n+                    invalidPolledClients.add(candidateClient);\n+                }\n+            }\n+        }\n+        offerAll(invalidPolledClients);\n+        return nextLeastLoadedValidClients;\n+    }\n+\n+    void offerAll(final Collection<UUID> clients) {\n+        for (final UUID client : clients) {\n+            offer(client);\n+        }\n+    }\n+\n+    void offer(final UUID client) {\n+        if (uniqueClients.contains(client)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQwNDM0NQ=="}, "originalCommit": null, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA0NzMzMg==", "bodyText": "prop: I would not add the client if it is already contained in the set.", "url": "https://github.com/apache/kafka/pull/8497#discussion_r412047332", "createdAt": "2020-04-21T09:59:32Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/ValidClientsByTaskLoadQueue.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.processor.internals.assignment;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.PriorityQueue;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.BiFunction;\n+import org.apache.kafka.streams.processor.TaskId;\n+\n+/**\n+ * Wraps a priority queue of clients and returns the next valid candidate(s) based on the current task assignment\n+ */\n+class ValidClientsByTaskLoadQueue {\n+\n+    private final PriorityQueue<UUID> clientsByTaskLoad;\n+    private final BiFunction<UUID, TaskId, Boolean> validClientCriteria;\n+    private final Set<UUID> uniqueClients = new HashSet<>();\n+\n+    ValidClientsByTaskLoadQueue(final Map<UUID, ClientState> clientStates,\n+                                final BiFunction<UUID, TaskId, Boolean> validClientCriteria) {\n+        this.validClientCriteria = validClientCriteria;\n+\n+        clientsByTaskLoad = new PriorityQueue<>(\n+            (client, other) -> {\n+                final double clientTaskLoad = clientStates.get(client).taskLoad();\n+                final double otherTaskLoad = clientStates.get(other).taskLoad();\n+                if (clientTaskLoad < otherTaskLoad) {\n+                    return -1;\n+                } else if (clientTaskLoad > otherTaskLoad) {\n+                    return 1;\n+                } else {\n+                    return client.compareTo(other);\n+                }\n+            });\n+    }\n+\n+    /**\n+     * @return the next least loaded client that satisfies the given criteria, or null if none do\n+     */\n+    UUID poll(final TaskId task) {\n+        final List<UUID> validClient = poll(task, 1);\n+        return validClient.isEmpty() ? null : validClient.get(0);\n+    }\n+\n+    /**\n+     * @return the next N <= {@code numClientsPerTask} clients in the underlying priority queue that are valid candidates for the given task\n+     */\n+    List<UUID> poll(final TaskId task, final int numClients) {\n+        final List<UUID> nextLeastLoadedValidClients = new LinkedList<>();\n+        final Set<UUID> invalidPolledClients = new HashSet<>();\n+        while (nextLeastLoadedValidClients.size() < numClients) {\n+            UUID candidateClient;\n+            while (true) {\n+                candidateClient = clientsByTaskLoad.poll();\n+                if (candidateClient == null) {\n+                    offerAll(invalidPolledClients);\n+                    return nextLeastLoadedValidClients;\n+                }\n+\n+                if (validClientCriteria.apply(candidateClient, task)) {\n+                    nextLeastLoadedValidClients.add(candidateClient);\n+                    break;\n+                } else {\n+                    invalidPolledClients.add(candidateClient);\n+                }\n+            }\n+        }\n+        offerAll(invalidPolledClients);\n+        return nextLeastLoadedValidClients;\n+    }\n+\n+    void offerAll(final Collection<UUID> clients) {\n+        for (final UUID client : clients) {\n+            offer(client);\n+        }\n+    }\n+\n+    void offer(final UUID client) {\n+        if (uniqueClients.contains(client)) {\n+            clientsByTaskLoad.remove(client);\n+        }\n+        clientsByTaskLoad.offer(client);\n+        uniqueClients.add(client);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67d20fdc83eb780157be6f1aecd20932b94c916b"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA4MTEyNQ==", "bodyText": "This question from my previous review went unnoticed (or you did simply not care ;-)).\n\nQ: Why do we even care at all whether the task was running on the client? What if we just assign a real stand-by task if we have a spare one?", "url": "https://github.com/apache/kafka/pull/8497#discussion_r412081125", "createdAt": "2020-04-21T10:53:14Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovement.java", "diffHunk": "@@ -16,128 +16,103 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n+import static org.apache.kafka.streams.processor.internals.assignment.AssignmentUtils.taskIsCaughtUpOnClientOrNoCaughtUpClientsExist;\n+\n import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n import java.util.SortedSet;\n+import java.util.TreeSet;\n import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicInteger;\n import org.apache.kafka.streams.processor.TaskId;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class TaskMovement {\n-    private static final Logger log = LoggerFactory.getLogger(TaskMovement.class);\n \n-    final TaskId task;\n-    final UUID source;\n-    final UUID destination;\n+class TaskMovement {\n+    private final TaskId task;\n+    private final UUID destination;\n+    private final SortedSet<UUID> caughtUpClients;\n \n-    TaskMovement(final TaskId task, final UUID source, final UUID destination) {\n+    private TaskMovement(final TaskId task, final UUID destination, final SortedSet<UUID> caughtUpClients) {\n         this.task = task;\n-        this.source = source;\n         this.destination = destination;\n-    }\n+        this.caughtUpClients = caughtUpClients;\n \n-    @Override\n-    public boolean equals(final Object o) {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n+        if (caughtUpClients == null || caughtUpClients.isEmpty()) {\n+            throw new IllegalStateException(\"Should not attempt to move a task if no caught up clients exist\");\n         }\n-        final TaskMovement movement = (TaskMovement) o;\n-        return Objects.equals(task, movement.task) &&\n-                   Objects.equals(source, movement.source) &&\n-                   Objects.equals(destination, movement.destination);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return Objects.hash(task, source, destination);\n     }\n \n     /**\n-     * Computes the movement of tasks from the state constrained to the balanced assignment, up to the configured\n-     * {@code max.warmup.replicas}. A movement corresponds to a warmup replica on the destination client, with\n-     * a few exceptional cases:\n-     * <p>\n-     * 1. Tasks whose destination clients are caught-up, or whose source clients are not caught-up, will be moved\n-     * immediately from the source to the destination in the state constrained assignment\n-     * 2. Tasks whose destination client previously had this task as a standby will not be counted towards the total\n-     * {@code max.warmup.replicas}. Instead they will be counted against that task's total {@code num.standby.replicas}.\n-     *\n-     * @param statefulActiveTaskAssignment the initial, state constrained assignment, with the source clients\n-     * @param balancedStatefulActiveTaskAssignment the final, balanced assignment, with the destination clients\n-     * @return list of the task movements from statefulActiveTaskAssignment to balancedStatefulActiveTaskAssignment\n+     * @return whether any warmup replicas were assigned\n      */\n-    static List<TaskMovement> getMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n-                                           final Map<UUID, List<TaskId>> balancedStatefulActiveTaskAssignment,\n-                                           final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n-                                           final Map<UUID, ClientState> clientStates,\n-                                           final Map<TaskId, Integer> tasksToRemainingStandbys,\n-                                           final int maxWarmupReplicas) {\n-        if (statefulActiveTaskAssignment.size() != balancedStatefulActiveTaskAssignment.size()) {\n-            throw new IllegalStateException(\"Tried to compute movements but assignments differ in size.\");\n-        }\n+    static boolean assignTaskMovements(final Map<UUID, List<TaskId>> statefulActiveTaskAssignment,\n+                                       final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients,\n+                                       final Map<UUID, ClientState> clientStates,\n+                                       final Map<TaskId, Integer> tasksToRemainingStandbys,\n+                                       final int maxWarmupReplicas) {\n+        boolean warmupReplicasAssigned = false;\n+\n+        final ValidClientsByTaskLoadQueue clientsByTaskLoad = new ValidClientsByTaskLoadQueue(\n+            clientStates,\n+            (client, task) -> taskIsCaughtUpOnClientOrNoCaughtUpClientsExist(task, client, tasksToCaughtUpClients)\n+        );\n \n-        final Map<TaskId, UUID> taskToDestinationClient = new HashMap<>();\n-        for (final Map.Entry<UUID, List<TaskId>> clientEntry : balancedStatefulActiveTaskAssignment.entrySet()) {\n-            final UUID destination = clientEntry.getKey();\n-            for (final TaskId task : clientEntry.getValue()) {\n-                taskToDestinationClient.put(task, destination);\n+        final SortedSet<TaskMovement> taskMovements = new TreeSet<>(\n+            (movement, other) -> {\n+                final int numCaughtUpClients = movement.caughtUpClients.size();\n+                final int otherNumCaughtUpClients = other.caughtUpClients.size();\n+                if (numCaughtUpClients != otherNumCaughtUpClients) {\n+                    return Integer.compare(numCaughtUpClients, otherNumCaughtUpClients);\n+                } else {\n+                    return movement.task.compareTo(other.task);\n+                }\n             }\n+        );\n+\n+        for (final Map.Entry<UUID, List<TaskId>> assignmentEntry : statefulActiveTaskAssignment.entrySet()) {\n+            final UUID client = assignmentEntry.getKey();\n+            final ClientState state = clientStates.get(client);\n+            for (final TaskId task : assignmentEntry.getValue()) {\n+                if (taskIsCaughtUpOnClientOrNoCaughtUpClientsExist(task, client, tasksToCaughtUpClients)) {\n+                    state.assignActive(task);\n+                } else {\n+                    final TaskMovement taskMovement = new TaskMovement(task, client, tasksToCaughtUpClients.get(task));\n+                    taskMovements.add(taskMovement);\n+                }\n+            }\n+            clientsByTaskLoad.offer(client);\n         }\n \n-        int remainingAllowedWarmupReplicas = maxWarmupReplicas;\n-        final List<TaskMovement> movements = new LinkedList<>();\n-        for (final Map.Entry<UUID, List<TaskId>> sourceClientEntry : statefulActiveTaskAssignment.entrySet()) {\n-            final UUID source = sourceClientEntry.getKey();\n+        final AtomicInteger remainingWarmupReplicas = new AtomicInteger(maxWarmupReplicas);\n+        for (final TaskMovement movement : taskMovements) {\n+            final UUID sourceClient = clientsByTaskLoad.poll(movement.task);\n+            if (sourceClient == null) {\n+                throw new IllegalStateException(\"Tried to move task to caught-up client but none exist\");\n+            }\n \n-            final Iterator<TaskId> sourceClientTasksIterator = sourceClientEntry.getValue().iterator();\n-            while (sourceClientTasksIterator.hasNext()) {\n-                final TaskId task = sourceClientTasksIterator.next();\n-                final UUID destination = taskToDestinationClient.get(task);\n-                if (destination == null) {\n-                    log.error(\"Task {} is assigned to client {} in initial assignment but has no owner in the final \" +\n-                                  \"balanced assignment.\", task, source);\n-                    throw new IllegalStateException(\"Found task in initial assignment that was not assigned in the final.\");\n-                } else if (!source.equals(destination)) {\n-                    if (destinationClientIsCaughtUp(task, destination, tasksToCaughtUpClients)) {\n-                        sourceClientTasksIterator.remove();\n-                        statefulActiveTaskAssignment.get(destination).add(task);\n-                    } else {\n-                        if (clientStates.get(destination).prevStandbyTasks().contains(task)\n-                                && tasksToRemainingStandbys.get(task) > 0\n-                        ) {\n-                            decrementRemainingStandbys(task, tasksToRemainingStandbys);\n-                        } else {\n-                            --remainingAllowedWarmupReplicas;\n-                        }\n+            final ClientState sourceClientState = clientStates.get(sourceClient);\n+            sourceClientState.assignActive(movement.task);\n+            clientsByTaskLoad.offer(sourceClient);\n \n-                        movements.add(new TaskMovement(task, source, destination));\n-                        if (remainingAllowedWarmupReplicas == 0) {\n-                            return movements;\n-                        }\n-                    }\n-                }\n+            final ClientState destinationClientState = clientStates.get(movement.destination);\n+            if (shouldAssignWarmupReplica(movement.task, destinationClientState, remainingWarmupReplicas, tasksToRemainingStandbys)) {\n+                destinationClientState.assignStandby(movement.task);\n+                clientsByTaskLoad.offer(movement.destination);\n+                warmupReplicasAssigned = true;\n             }\n         }\n-        return movements;\n+        return warmupReplicasAssigned;\n     }\n \n-    private static boolean destinationClientIsCaughtUp(final TaskId task,\n-                                                       final UUID destination,\n-                                                       final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients) {\n-        final Set<UUID> caughtUpClients = tasksToCaughtUpClients.get(task);\n-        return caughtUpClients != null && caughtUpClients.contains(destination);\n+    private static boolean shouldAssignWarmupReplica(final TaskId task,\n+                                                     final ClientState destinationClientState,\n+                                                     final AtomicInteger remainingWarmupReplicas,\n+                                                     final Map<TaskId, Integer> tasksToRemainingStandbys) {\n+        if (destinationClientState.previousAssignedTasks().contains(task) && tasksToRemainingStandbys.get(task) > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67d20fdc83eb780157be6f1aecd20932b94c916b"}, "originalPosition": 189}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ab532fa1c932b177bc82a08c75374228dabae77", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/2ab532fa1c932b177bc82a08c75374228dabae77", "committedDate": "2020-04-21T19:14:24Z", "message": "github review prop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7500412b14201520525b5027849cdd79585c1751", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/7500412b14201520525b5027849cdd79585c1751", "committedDate": "2020-04-21T19:19:13Z", "message": "queue fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a6dc0b002bf6e6f46d9a910d0358cbcf81dd1f7", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/2a6dc0b002bf6e6f46d9a910d0358cbcf81dd1f7", "committedDate": "2020-04-21T19:20:43Z", "message": "wrap in method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NjA0NDgx", "url": "https://github.com/apache/kafka/pull/8497#pullrequestreview-397604481", "createdAt": "2020-04-21T19:20:50Z", "commit": {"oid": "7500412b14201520525b5027849cdd79585c1751"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1539, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}