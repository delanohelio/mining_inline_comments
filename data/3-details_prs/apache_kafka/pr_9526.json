{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTExOTg2NDM2", "number": 9526, "title": "KAFKA-10525: Emit JSONs with new auto-generated schema", "bodyText": "Kafka\u2019s request and response traces currently output in a format that is JSON-like and are not easily parsable. There is a new auto-generated schema for each request type that supports outputting JSON payloads for request and response payloads. These can be adapted to provide structured request tracing.\nIncludes tests that iterate through all the request types and ensure we handle all of them in RequestConvertToJson.\nKIP-673", "createdAt": "2020-10-29T03:33:59Z", "url": "https://github.com/apache/kafka/pull/9526", "merged": true, "mergeCommit": {"oid": "1a10c3445e157da1d2fd670c043f19c385465eb0"}, "closed": true, "closedAt": "2020-12-15T13:33:37Z", "author": {"login": "anatasiavela"}, "timelineItems": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdXPgsngFqTUxOTQ0NDk5Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdmaTV8gFqTU1MjQ0NDQ3Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5NDQ0OTky", "url": "https://github.com/apache/kafka/pull/9526#pullrequestreview-519444992", "createdAt": "2020-10-29T08:50:36Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwODo1MDozNlrOHqRyOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMDoyMTowNlrOHqVOow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA5MzYyNg==", "bodyText": "This is not entirely related to your PR but it seems that we are little inconsistent wrt. how we expose/access data in the code base. As an example, here we add an accessor to access data but we keep data field public and keep accessing it directly from various places.\nI think that we should do one the following:\n\nAdd an accessor and make data final private everywhere; or\nMake data final public everywhere.\n\nIt seems that you suggest to go with 1) in the PR. Personally, I don't have a strong preference for any of them but I would like us to be consistent across the board.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514093626", "createdAt": "2020-10-29T08:50:36Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/AddOffsetsToTxnRequest.java", "diffHunk": "@@ -57,6 +57,10 @@ public AddOffsetsToTxnRequest(Struct struct, short version) {\n         this.data = new AddOffsetsToTxnRequestData(struct, version);\n     }\n \n+    public AddOffsetsToTxnRequestData data() {\n+        return data;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA5OTAxNg==", "bodyText": "We may want to gate this by isTraceEnabled in order to not compute it necessarily.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514099016", "createdAt": "2020-10-29T08:59:31Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestChannel.scala", "diffHunk": "@@ -162,7 +161,7 @@ object RequestChannel extends Logging {\n       }\n     }\n \n-    trace(s\"Processor $processor received request: ${requestDesc(true)}\")\n+    trace(s\"Processor $processor received request: ${RequestConvertToJson.requestDesc(header, loggableRequest, true).toString}\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEwMDY5MA==", "bodyText": "This is one case where we still access data without an accessor.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514100690", "createdAt": "2020-10-29T09:02:14Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDExMTU0MQ==", "bodyText": "It is a little frustrating to have to maintain this mapping for each request. I wonder if we could auto-generate such helper based on the protocol description. We already generate DataJsonConverter helpers so it should be feasible to also generate an overall helper.\nHave you already considered this? I am fine with keep it as-is for now though and to investigate this in the future.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514111541", "createdAt": "2020-10-29T09:19:58Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDExMzI3OA==", "bodyText": "Should we handle the unknown cases explicitly and throw an exception with an meaningful message instead of relying on MatchError? What do you think?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514113278", "createdAt": "2020-10-29T09:22:34Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDExNTk3Mw==", "bodyText": "nit: Could we add a comment here to explain why we overwrite the requestApiKey?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514115973", "createdAt": "2020-10-29T09:26:34Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDExODYwMw==", "bodyText": "nit: Could we align them with header?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514118603", "createdAt": "2020-10-29T09:30:29Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                  context: RequestContext, session: Session, verbose: Boolean,\n+                  totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                  apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                  responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                  messageConversionsTimeMs: Double): JsonNode = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDExOTU3MA==", "bodyText": "I wonder if we should also structure the client information in JSON instead of relying on the string representation of the object. That would make the information more accessible.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514119570", "createdAt": "2020-10-29T09:31:57Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                  context: RequestContext, session: Session, verbose: Boolean,\n+                  totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                  apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                  responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                  messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTime\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTime\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTime\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTime\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTime\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTime\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTime\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", new TextNode(context.clientInformation.toString))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEyMTI2Ng==", "bodyText": "Should we add unit tests for these helper methods? I mean that it would be great to ensure that the format of the JSON is equivalent to the JSON what will be generated by the auto-generated protocol.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514121266", "createdAt": "2020-10-29T09:34:42Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                  context: RequestContext, session: Session, verbose: Boolean,\n+                  totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                  apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                  responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                  messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTime\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTime\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTime\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTime\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTime\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTime\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTime\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", new TextNode(context.clientInformation.toString))\n+    if (temporaryMemoryBytes > 0)\n+      node.set(\"temporaryMemoryBytes\", new LongNode(temporaryMemoryBytes))\n+    if (messageConversionsTimeMs > 0)\n+      node.set(\"messageConversionsTime\", new DoubleNode(messageConversionsTimeMs))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, req: AbstractRequest, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def offsetsForLeaderEpochRequestNode(request: OffsetsForLeaderEpochRequest, version: Short): JsonNode = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEyMTM3OQ==", "bodyText": "I am working on this one :)", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514121379", "createdAt": "2020-10-29T09:34:54Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                  context: RequestContext, session: Session, verbose: Boolean,\n+                  totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                  apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                  responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                  messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTime\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTime\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTime\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTime\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTime\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTime\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTime\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", new TextNode(context.clientInformation.toString))\n+    if (temporaryMemoryBytes > 0)\n+      node.set(\"temporaryMemoryBytes\", new LongNode(temporaryMemoryBytes))\n+    if (messageConversionsTimeMs > 0)\n+      node.set(\"messageConversionsTime\", new DoubleNode(messageConversionsTimeMs))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, req: AbstractRequest, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEyNzgyNg==", "bodyText": "nit: We may be able to use request.partitionSizes().forEach directly.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514127826", "createdAt": "2020-10-29T09:45:04Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                  context: RequestContext, session: Session, verbose: Boolean,\n+                  totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                  apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                  responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                  messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTime\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTime\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTime\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTime\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTime\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTime\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTime\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", new TextNode(context.clientInformation.toString))\n+    if (temporaryMemoryBytes > 0)\n+      node.set(\"temporaryMemoryBytes\", new LongNode(temporaryMemoryBytes))\n+    if (messageConversionsTimeMs > 0)\n+      node.set(\"messageConversionsTime\", new DoubleNode(messageConversionsTimeMs))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, req: AbstractRequest, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def offsetsForLeaderEpochRequestNode(request: OffsetsForLeaderEpochRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      node.set(\"replicaId\", new IntNode(request.replicaId))\n+    }\n+    val topicsToPartitionEpochs = CollectionUtils.groupPartitionDataByTopic(request.epochsByTopicPartition)\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    for (topicToEpochs <- topicsToPartitionEpochs.entrySet.asScala) {\n+      val topicsData = new ObjectNode(JsonNodeFactory.instance)\n+      topicsData.set(\"name\", new TextNode(topicToEpochs.getKey))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      for (partitionEpoch <- topicToEpochs.getValue.entrySet.asScala) {\n+        val partitionData = partitionEpoch.getValue\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionEpoch.getKey))\n+        partitionNode.set(\"leaderEpoch\", new IntNode(partitionData.leaderEpoch))\n+        if (version >= 2) {\n+          val leaderEpoch = partitionData.currentLeaderEpoch\n+          partitionNode.set(\"currentLeaderEpoch\", new IntNode(leaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH)))\n+        }\n+        partitionsArray.add(partitionNode)\n+      }\n+      topicsData.set(\"partitions\", partitionsArray)\n+      topicsArray.add(topicsData)\n+    }\n+    node.set(\"topics\", topicsArray)\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def produceRequestNode(request: ProduceRequest, version: Short, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      if (request.transactionalId == null) {\n+        node.set(\"transactionalId\", NullNode.instance)\n+      } else {\n+        node.set(\"transactionalId\", new TextNode(request.transactionalId))\n+      }\n+    }\n+    node.set(\"acks\", new ShortNode(request.acks))\n+    node.set(\"timeoutMs\", new IntNode(request.timeout))\n+    if (verbose) {\n+      val partSizes = new ArrayNode(JsonNodeFactory.instance)\n+      for (partSize <- request.partitionSizes().entrySet.asScala) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEyOTMxMA==", "bodyText": "We are using the topic for the partition here. I suppose that we need both, isn't it?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514129310", "createdAt": "2020-10-29T09:47:24Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                  context: RequestContext, session: Session, verbose: Boolean,\n+                  totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                  apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                  responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                  messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTime\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTime\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTime\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTime\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTime\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTime\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTime\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", new TextNode(context.clientInformation.toString))\n+    if (temporaryMemoryBytes > 0)\n+      node.set(\"temporaryMemoryBytes\", new LongNode(temporaryMemoryBytes))\n+    if (messageConversionsTimeMs > 0)\n+      node.set(\"messageConversionsTime\", new DoubleNode(messageConversionsTimeMs))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, req: AbstractRequest, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def offsetsForLeaderEpochRequestNode(request: OffsetsForLeaderEpochRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      node.set(\"replicaId\", new IntNode(request.replicaId))\n+    }\n+    val topicsToPartitionEpochs = CollectionUtils.groupPartitionDataByTopic(request.epochsByTopicPartition)\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    for (topicToEpochs <- topicsToPartitionEpochs.entrySet.asScala) {\n+      val topicsData = new ObjectNode(JsonNodeFactory.instance)\n+      topicsData.set(\"name\", new TextNode(topicToEpochs.getKey))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      for (partitionEpoch <- topicToEpochs.getValue.entrySet.asScala) {\n+        val partitionData = partitionEpoch.getValue\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionEpoch.getKey))\n+        partitionNode.set(\"leaderEpoch\", new IntNode(partitionData.leaderEpoch))\n+        if (version >= 2) {\n+          val leaderEpoch = partitionData.currentLeaderEpoch\n+          partitionNode.set(\"currentLeaderEpoch\", new IntNode(leaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH)))\n+        }\n+        partitionsArray.add(partitionNode)\n+      }\n+      topicsData.set(\"partitions\", partitionsArray)\n+      topicsArray.add(topicsData)\n+    }\n+    node.set(\"topics\", topicsArray)\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def produceRequestNode(request: ProduceRequest, version: Short, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      if (request.transactionalId == null) {\n+        node.set(\"transactionalId\", NullNode.instance)\n+      } else {\n+        node.set(\"transactionalId\", new TextNode(request.transactionalId))\n+      }\n+    }\n+    node.set(\"acks\", new ShortNode(request.acks))\n+    node.set(\"timeoutMs\", new IntNode(request.timeout))\n+    if (verbose) {\n+      val partSizes = new ArrayNode(JsonNodeFactory.instance)\n+      for (partSize <- request.partitionSizes().entrySet.asScala) {\n+        val part = new ObjectNode(JsonNodeFactory.instance)\n+        val topic = partSize.getKey\n+        part.set(\"partition\", new TextNode(topic.toString))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEzMDEzMQ==", "bodyText": "It is a bit weird to have partitionSizes used with two different type of value. It seems that we were previously using numPartitions for this case.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514130131", "createdAt": "2020-10-29T09:48:46Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                  context: RequestContext, session: Session, verbose: Boolean,\n+                  totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                  apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                  responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                  messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTime\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTime\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTime\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTime\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTime\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTime\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTime\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", new TextNode(context.clientInformation.toString))\n+    if (temporaryMemoryBytes > 0)\n+      node.set(\"temporaryMemoryBytes\", new LongNode(temporaryMemoryBytes))\n+    if (messageConversionsTimeMs > 0)\n+      node.set(\"messageConversionsTime\", new DoubleNode(messageConversionsTimeMs))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, req: AbstractRequest, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def offsetsForLeaderEpochRequestNode(request: OffsetsForLeaderEpochRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      node.set(\"replicaId\", new IntNode(request.replicaId))\n+    }\n+    val topicsToPartitionEpochs = CollectionUtils.groupPartitionDataByTopic(request.epochsByTopicPartition)\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    for (topicToEpochs <- topicsToPartitionEpochs.entrySet.asScala) {\n+      val topicsData = new ObjectNode(JsonNodeFactory.instance)\n+      topicsData.set(\"name\", new TextNode(topicToEpochs.getKey))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      for (partitionEpoch <- topicToEpochs.getValue.entrySet.asScala) {\n+        val partitionData = partitionEpoch.getValue\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionEpoch.getKey))\n+        partitionNode.set(\"leaderEpoch\", new IntNode(partitionData.leaderEpoch))\n+        if (version >= 2) {\n+          val leaderEpoch = partitionData.currentLeaderEpoch\n+          partitionNode.set(\"currentLeaderEpoch\", new IntNode(leaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH)))\n+        }\n+        partitionsArray.add(partitionNode)\n+      }\n+      topicsData.set(\"partitions\", partitionsArray)\n+      topicsArray.add(topicsData)\n+    }\n+    node.set(\"topics\", topicsArray)\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def produceRequestNode(request: ProduceRequest, version: Short, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      if (request.transactionalId == null) {\n+        node.set(\"transactionalId\", NullNode.instance)\n+      } else {\n+        node.set(\"transactionalId\", new TextNode(request.transactionalId))\n+      }\n+    }\n+    node.set(\"acks\", new ShortNode(request.acks))\n+    node.set(\"timeoutMs\", new IntNode(request.timeout))\n+    if (verbose) {\n+      val partSizes = new ArrayNode(JsonNodeFactory.instance)\n+      for (partSize <- request.partitionSizes().entrySet.asScala) {\n+        val part = new ObjectNode(JsonNodeFactory.instance)\n+        val topic = partSize.getKey\n+        part.set(\"partition\", new TextNode(topic.toString))\n+        part.set(\"size\", new IntNode(partSize.getValue))\n+        partSizes.add(part)\n+      }\n+      node.set(\"partitionSizes\", partSizes)\n+    } else {\n+      node.set(\"partitionSizes\", new IntNode(request.partitionSizes.size))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEzMjI3OA==", "bodyText": "It is important to note that the format of the JSON will change when we move to the generated schema. partitionSizes does not exist in the schema. Thus, I wonder if we should better align directly; or keep this exception forever. Have we thought about this?\nSimilarly in the FetchResponse, we were outputting recordsSizeInBytes per partition and it seems that now we put an empty recordSet field. cc @lbradstreet", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514132278", "createdAt": "2020-10-29T09:52:12Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                  context: RequestContext, session: Session, verbose: Boolean,\n+                  totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                  apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                  responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                  messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTime\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTime\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTime\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTime\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTime\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTime\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTime\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", new TextNode(context.clientInformation.toString))\n+    if (temporaryMemoryBytes > 0)\n+      node.set(\"temporaryMemoryBytes\", new LongNode(temporaryMemoryBytes))\n+    if (messageConversionsTimeMs > 0)\n+      node.set(\"messageConversionsTime\", new DoubleNode(messageConversionsTimeMs))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, req: AbstractRequest, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def offsetsForLeaderEpochRequestNode(request: OffsetsForLeaderEpochRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      node.set(\"replicaId\", new IntNode(request.replicaId))\n+    }\n+    val topicsToPartitionEpochs = CollectionUtils.groupPartitionDataByTopic(request.epochsByTopicPartition)\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    for (topicToEpochs <- topicsToPartitionEpochs.entrySet.asScala) {\n+      val topicsData = new ObjectNode(JsonNodeFactory.instance)\n+      topicsData.set(\"name\", new TextNode(topicToEpochs.getKey))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      for (partitionEpoch <- topicToEpochs.getValue.entrySet.asScala) {\n+        val partitionData = partitionEpoch.getValue\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionEpoch.getKey))\n+        partitionNode.set(\"leaderEpoch\", new IntNode(partitionData.leaderEpoch))\n+        if (version >= 2) {\n+          val leaderEpoch = partitionData.currentLeaderEpoch\n+          partitionNode.set(\"currentLeaderEpoch\", new IntNode(leaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH)))\n+        }\n+        partitionsArray.add(partitionNode)\n+      }\n+      topicsData.set(\"partitions\", partitionsArray)\n+      topicsArray.add(topicsData)\n+    }\n+    node.set(\"topics\", topicsArray)\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE0MDMxNQ==", "bodyText": "Shouldn't we only catch AssertionError here and below?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514140315", "createdAt": "2020-10-29T10:05:04Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,188 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util.HashMap\n+\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.record.MemoryRecords\n+import org.apache.kafka.common.requests._\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  def createRequestsFromApiKey(apiKey: ApiKeys, version: Short): AbstractRequest = apiKey match {\n+    case ApiKeys.PRODUCE => ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new HashMap[TopicPartition, MemoryRecords]()).build()\n+    case ApiKeys.FETCH => new FetchRequest(new FetchRequestData(), version)\n+    case ApiKeys.LIST_OFFSETS => new ListOffsetRequest(new ListOffsetRequestData().toStruct(version), version)\n+    case ApiKeys.METADATA => new MetadataRequest(new MetadataRequestData(), version)\n+    case ApiKeys.OFFSET_COMMIT => new OffsetCommitRequest(new OffsetCommitRequestData(), version)\n+    case ApiKeys.OFFSET_FETCH => new OffsetFetchRequest(new OffsetFetchRequestData().toStruct(version), version)\n+    case ApiKeys.FIND_COORDINATOR => new FindCoordinatorRequest(new FindCoordinatorRequestData().toStruct(version), version)\n+    case ApiKeys.JOIN_GROUP => new JoinGroupRequest(new JoinGroupRequestData(), version)\n+    case ApiKeys.HEARTBEAT => new HeartbeatRequest(new HeartbeatRequestData().toStruct(version), version)\n+    case ApiKeys.LEAVE_GROUP => new LeaveGroupRequest(new LeaveGroupRequestData().toStruct(version), version)\n+    case ApiKeys.SYNC_GROUP => new SyncGroupRequest(new SyncGroupRequestData(), version)\n+    case ApiKeys.STOP_REPLICA => new StopReplicaRequest(new StopReplicaRequestData().toStruct(version), version)\n+    case ApiKeys.CONTROLLED_SHUTDOWN => new ControlledShutdownRequest(new ControlledShutdownRequestData().toStruct(version), version)\n+    case ApiKeys.UPDATE_METADATA => new UpdateMetadataRequest(new UpdateMetadataRequestData().toStruct(version), version)\n+    case ApiKeys.LEADER_AND_ISR => new LeaderAndIsrRequest(new LeaderAndIsrRequestData().toStruct(version), version)\n+    case ApiKeys.DESCRIBE_GROUPS => new DescribeGroupsRequest(new DescribeGroupsRequestData().toStruct(version), version)\n+    case ApiKeys.LIST_GROUPS => new ListGroupsRequest(new ListGroupsRequestData(), version)\n+    case ApiKeys.SASL_HANDSHAKE => new SaslHandshakeRequest(new SaslHandshakeRequestData())\n+    case ApiKeys.API_VERSIONS => new ApiVersionsRequest(new ApiVersionsRequestData(), version)\n+    case ApiKeys.CREATE_TOPICS => new CreateTopicsRequest(new CreateTopicsRequestData().toStruct(version), version)\n+    case ApiKeys.DELETE_TOPICS => new DeleteTopicsRequest(new DeleteTopicsRequestData().toStruct(version), version)\n+    case ApiKeys.DELETE_RECORDS => new DeleteRecordsRequest(new DeleteRecordsRequestData().toStruct(version), version)\n+    case ApiKeys.INIT_PRODUCER_ID => new InitProducerIdRequest(new InitProducerIdRequestData().toStruct(version), version)\n+    case ApiKeys.OFFSET_FOR_LEADER_EPOCH => new OffsetsForLeaderEpochRequest(new OffsetForLeaderEpochResponseData().toStruct(version), version)\n+    case ApiKeys.ADD_PARTITIONS_TO_TXN => new AddPartitionsToTxnRequest(new AddPartitionsToTxnRequestData(), version)\n+    case ApiKeys.ADD_OFFSETS_TO_TXN => new AddOffsetsToTxnRequest(new AddOffsetsToTxnRequestData(), version)\n+    case ApiKeys.END_TXN =>  new EndTxnRequest(new EndTxnRequestData().toStruct(version), version)\n+    case ApiKeys.WRITE_TXN_MARKERS =>  new WriteTxnMarkersRequest(new WriteTxnMarkersRequestData().toStruct(version), version)\n+    case ApiKeys.TXN_OFFSET_COMMIT => new TxnOffsetCommitRequest(new TxnOffsetCommitRequestData(), version)\n+    case ApiKeys.DESCRIBE_ACLS =>\n+      val data = new DescribeAclsRequestData().setResourceTypeFilter(1).setOperation(2).setPermissionType(2)\n+      new DescribeAclsRequest(data.toStruct(version), version)\n+    case ApiKeys.CREATE_ACLS =>  new CreateAclsRequest(new CreateAclsRequestData().toStruct(version), version)\n+    case ApiKeys.DELETE_ACLS => new DeleteAclsRequest(new DeleteAclsRequestData().toStruct(version), version)\n+    case ApiKeys.DESCRIBE_CONFIGS => new DescribeConfigsRequest(new DescribeConfigsRequestData(), version)\n+    case ApiKeys.ALTER_CONFIGS => new AlterConfigsRequest(new AlterConfigsRequestData(), version)\n+    case ApiKeys.ALTER_REPLICA_LOG_DIRS =>  new AlterReplicaLogDirsRequest(new AlterReplicaLogDirsRequestData(), version)\n+    case ApiKeys.DESCRIBE_LOG_DIRS => new DescribeLogDirsRequest(new DescribeLogDirsRequestData(), version)\n+    case ApiKeys.SASL_AUTHENTICATE => new SaslAuthenticateRequest(new SaslAuthenticateRequestData(), version)\n+    case ApiKeys.CREATE_PARTITIONS => new CreatePartitionsRequest(new CreatePartitionsRequestData().toStruct(version), version)\n+    case ApiKeys.CREATE_DELEGATION_TOKEN => new CreateDelegationTokenRequest(new CreateDelegationTokenRequestData().toStruct(version), version)\n+    case ApiKeys.RENEW_DELEGATION_TOKEN => new RenewDelegationTokenRequest(new RenewDelegationTokenRequestData(), version)\n+    case ApiKeys.EXPIRE_DELEGATION_TOKEN => new ExpireDelegationTokenRequest(new ExpireDelegationTokenRequestData().toStruct(version), version)\n+    case ApiKeys.DESCRIBE_DELEGATION_TOKEN => new DescribeDelegationTokenRequest(new DescribeDelegationTokenRequestData(), version)\n+    case ApiKeys.DELETE_GROUPS => new DeleteGroupsRequest(new DeleteGroupsRequestData(), version)\n+    case ApiKeys.ELECT_LEADERS => new ElectLeadersRequest(new ElectLeadersRequestData().toStruct(version), version)\n+    case ApiKeys.INCREMENTAL_ALTER_CONFIGS => new IncrementalAlterConfigsRequest.Builder(new IncrementalAlterConfigsRequestData()).build(version)\n+    case ApiKeys.ALTER_PARTITION_REASSIGNMENTS => new AlterPartitionReassignmentsRequest.Builder(new AlterPartitionReassignmentsRequestData()).build(version)\n+    case ApiKeys.LIST_PARTITION_REASSIGNMENTS => new ListPartitionReassignmentsRequest.Builder(new ListPartitionReassignmentsRequestData()).build(version)\n+    case ApiKeys.OFFSET_DELETE => new OffsetDeleteRequest(new OffsetDeleteRequestData(), version)\n+    case ApiKeys.DESCRIBE_CLIENT_QUOTAS => new DescribeClientQuotasRequest(new DescribeClientQuotasRequestData(), version)\n+    case ApiKeys.ALTER_CLIENT_QUOTAS => new AlterClientQuotasRequest(new AlterClientQuotasRequestData(), version)\n+    case ApiKeys.DESCRIBE_USER_SCRAM_CREDENTIALS => new DescribeUserScramCredentialsRequest.Builder(new DescribeUserScramCredentialsRequestData()).build(version)\n+    case ApiKeys.ALTER_USER_SCRAM_CREDENTIALS => new AlterUserScramCredentialsRequest.Builder(new AlterUserScramCredentialsRequestData()).build(version)\n+    case ApiKeys.VOTE => new VoteRequest.Builder(new VoteRequestData()).build(version)\n+    case ApiKeys.BEGIN_QUORUM_EPOCH => new BeginQuorumEpochRequest.Builder(new BeginQuorumEpochRequestData()).build(version)\n+    case ApiKeys.END_QUORUM_EPOCH => new EndQuorumEpochRequest.Builder(new EndQuorumEpochRequestData()).build(version)\n+    case ApiKeys.DESCRIBE_QUORUM => new DescribeQuorumRequest.Builder(new DescribeQuorumRequestData()).build(version)\n+    case ApiKeys.ALTER_ISR => new AlterIsrRequest.Builder(new AlterIsrRequestData()).build(version)\n+    case ApiKeys.UPDATE_FEATURES => new UpdateFeaturesRequest.Builder(new UpdateFeaturesRequestData()).build(version)\n+    case _ => throw new AssertionError(String.format(\"Request type %s is not tested in `RequestConvertToJsonTest`\", apiKey))\n+  }\n+\n+  def createResponseFromApiKey(apiKey: ApiKeys, version: Short): AbstractResponse = apiKey match {\n+    case ApiKeys.PRODUCE => new ProduceResponse(new ProduceResponseData().toStruct(version))\n+    case ApiKeys.FETCH => new FetchResponse(new FetchResponseData())\n+    case ApiKeys.LIST_OFFSETS => new ListOffsetResponse(new ListOffsetResponseData())\n+    case ApiKeys.METADATA => new MetadataResponse(new MetadataResponseData())\n+    case ApiKeys.OFFSET_COMMIT => new OffsetCommitResponse(new OffsetCommitResponseData())\n+    case ApiKeys.OFFSET_FETCH => new OffsetFetchResponse(new OffsetFetchResponseData().toStruct(version), version)\n+    case ApiKeys.FIND_COORDINATOR => new FindCoordinatorResponse(new FindCoordinatorResponseData())\n+    case ApiKeys.JOIN_GROUP => new JoinGroupResponse(new JoinGroupResponseData())\n+    case ApiKeys.HEARTBEAT => new HeartbeatResponse(new HeartbeatResponseData())\n+    case ApiKeys.LEAVE_GROUP => new LeaveGroupResponse(new LeaveGroupResponseData())\n+    case ApiKeys.SYNC_GROUP => new SyncGroupResponse(new SyncGroupResponseData())\n+    case ApiKeys.STOP_REPLICA => new StopReplicaResponse(new StopReplicaResponseData())\n+    case ApiKeys.CONTROLLED_SHUTDOWN => new ControlledShutdownResponse(new ControlledShutdownResponseData())\n+    case ApiKeys.UPDATE_METADATA => new UpdateMetadataResponse(new UpdateMetadataResponseData())\n+    case ApiKeys.LEADER_AND_ISR => new LeaderAndIsrResponse(new LeaderAndIsrResponseData())\n+    case ApiKeys.DESCRIBE_GROUPS => new DescribeGroupsResponse(new DescribeGroupsResponseData())\n+    case ApiKeys.LIST_GROUPS => new ListGroupsResponse(new ListGroupsResponseData())\n+    case ApiKeys.SASL_HANDSHAKE => new SaslHandshakeResponse(new SaslHandshakeResponseData())\n+    case ApiKeys.API_VERSIONS => new ApiVersionsResponse(new ApiVersionsResponseData())\n+    case ApiKeys.CREATE_TOPICS => new CreateTopicsResponse(new CreateTopicsResponseData())\n+    case ApiKeys.DELETE_TOPICS => new DeleteTopicsResponse(new DeleteTopicsResponseData())\n+    case ApiKeys.DELETE_RECORDS => new DeleteRecordsResponse(new DeleteRecordsResponseData())\n+    case ApiKeys.INIT_PRODUCER_ID => new InitProducerIdResponse(new InitProducerIdResponseData())\n+    case ApiKeys.OFFSET_FOR_LEADER_EPOCH => new OffsetsForLeaderEpochResponse(new OffsetForLeaderEpochResponseData().toStruct(version))\n+    case ApiKeys.ADD_PARTITIONS_TO_TXN => new AddPartitionsToTxnResponse(new AddPartitionsToTxnResponseData().toStruct(version), version)\n+    case ApiKeys.ADD_OFFSETS_TO_TXN => new AddOffsetsToTxnResponse(new AddOffsetsToTxnResponseData())\n+    case ApiKeys.END_TXN => new EndTxnResponse(new EndTxnResponseData())\n+    case ApiKeys.WRITE_TXN_MARKERS => new WriteTxnMarkersResponse(new WriteTxnMarkersResponseData().toStruct(version), version)\n+    case ApiKeys.TXN_OFFSET_COMMIT => new TxnOffsetCommitResponse(new TxnOffsetCommitResponseData())\n+    case ApiKeys.DESCRIBE_ACLS => new DescribeAclsResponse(new DescribeAclsResponseData())\n+    case ApiKeys.CREATE_ACLS => new CreateAclsResponse(new CreateAclsResponseData())\n+    case ApiKeys.DELETE_ACLS => new DeleteAclsResponse(new DeleteAclsResponseData())\n+    case ApiKeys.DESCRIBE_CONFIGS => new DescribeConfigsResponse(new DescribeConfigsResponseData())\n+    case ApiKeys.ALTER_CONFIGS => new AlterConfigsResponse(new AlterConfigsResponseData())\n+    case ApiKeys.ALTER_REPLICA_LOG_DIRS => new AlterReplicaLogDirsResponse(new AlterReplicaLogDirsResponseData())\n+    case ApiKeys.DESCRIBE_LOG_DIRS => new DescribeLogDirsResponse(new DescribeLogDirsResponseData())\n+    case ApiKeys.SASL_AUTHENTICATE => new SaslAuthenticateResponse(new SaslAuthenticateResponseData())\n+    case ApiKeys.CREATE_PARTITIONS => new CreatePartitionsResponse(new CreatePartitionsResponseData())\n+    case ApiKeys.CREATE_DELEGATION_TOKEN => new CreateDelegationTokenResponse(new CreateDelegationTokenResponseData())\n+    case ApiKeys.RENEW_DELEGATION_TOKEN => new RenewDelegationTokenResponse(new RenewDelegationTokenResponseData())\n+    case ApiKeys.EXPIRE_DELEGATION_TOKEN => new ExpireDelegationTokenResponse(new ExpireDelegationTokenResponseData())\n+    case ApiKeys.DESCRIBE_DELEGATION_TOKEN => new DescribeDelegationTokenResponse(new DescribeDelegationTokenResponseData().toStruct(version), version)\n+    case ApiKeys.DELETE_GROUPS => new DeleteGroupsResponse(new DeleteGroupsResponseData())\n+    case ApiKeys.ELECT_LEADERS => new ElectLeadersResponse(new ElectLeadersResponseData().toStruct(version), version)\n+    case ApiKeys.INCREMENTAL_ALTER_CONFIGS => new IncrementalAlterConfigsResponse(new IncrementalAlterConfigsResponseData())\n+    case ApiKeys.ALTER_PARTITION_REASSIGNMENTS => new AlterPartitionReassignmentsResponse(new AlterPartitionReassignmentsResponseData())\n+    case ApiKeys.LIST_PARTITION_REASSIGNMENTS => new ListPartitionReassignmentsResponse(new ListPartitionReassignmentsResponseData())\n+    case ApiKeys.OFFSET_DELETE => new OffsetDeleteResponse(new OffsetDeleteResponseData())\n+    case ApiKeys.DESCRIBE_CLIENT_QUOTAS => new DescribeClientQuotasResponse(new DescribeClientQuotasResponseData().toStruct(version), version)\n+    case ApiKeys.ALTER_CLIENT_QUOTAS => new AlterClientQuotasResponse(new AlterClientQuotasResponseData().toStruct(version), version)\n+    case ApiKeys.DESCRIBE_USER_SCRAM_CREDENTIALS => new DescribeUserScramCredentialsResponse(new DescribeUserScramCredentialsResponseData())\n+    case ApiKeys.ALTER_USER_SCRAM_CREDENTIALS => new AlterUserScramCredentialsResponse(new AlterUserScramCredentialsResponseData())\n+    case ApiKeys.VOTE => new VoteResponse(new VoteResponseData())\n+    case ApiKeys.BEGIN_QUORUM_EPOCH => new BeginQuorumEpochResponse(new BeginQuorumEpochResponseData())\n+    case ApiKeys.END_QUORUM_EPOCH => new EndQuorumEpochResponse(new EndQuorumEpochResponseData())\n+    case ApiKeys.DESCRIBE_QUORUM => new DescribeQuorumResponse(new DescribeQuorumResponseData())\n+    case ApiKeys.ALTER_ISR => new AlterIsrResponse(new AlterIsrResponseData())\n+    case ApiKeys.UPDATE_FEATURES => new UpdateFeaturesResponse(new UpdateFeaturesResponseData())\n+    case _ => throw new AssertionError(String.format(\"Response type %s not tested in `RequestConvertToJsonTest`\", apiKey))\n+  }\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = 0\n+      val req = createRequestsFromApiKey(key, version)\n+      try {\n+        RequestConvertToJson.request(req, false)\n+      } catch {\n+        case _ : Throwable => unhandledKeys += key.toString", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1MDA1MQ==", "bodyText": "Why are we using toStruct in some cases and passing the *Data object directly in others?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514150051", "createdAt": "2020-10-29T10:21:06Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,188 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util.HashMap\n+\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.record.MemoryRecords\n+import org.apache.kafka.common.requests._\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  def createRequestsFromApiKey(apiKey: ApiKeys, version: Short): AbstractRequest = apiKey match {\n+    case ApiKeys.PRODUCE => ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new HashMap[TopicPartition, MemoryRecords]()).build()\n+    case ApiKeys.FETCH => new FetchRequest(new FetchRequestData(), version)\n+    case ApiKeys.LIST_OFFSETS => new ListOffsetRequest(new ListOffsetRequestData().toStruct(version), version)\n+    case ApiKeys.METADATA => new MetadataRequest(new MetadataRequestData(), version)\n+    case ApiKeys.OFFSET_COMMIT => new OffsetCommitRequest(new OffsetCommitRequestData(), version)\n+    case ApiKeys.OFFSET_FETCH => new OffsetFetchRequest(new OffsetFetchRequestData().toStruct(version), version)\n+    case ApiKeys.FIND_COORDINATOR => new FindCoordinatorRequest(new FindCoordinatorRequestData().toStruct(version), version)\n+    case ApiKeys.JOIN_GROUP => new JoinGroupRequest(new JoinGroupRequestData(), version)\n+    case ApiKeys.HEARTBEAT => new HeartbeatRequest(new HeartbeatRequestData().toStruct(version), version)\n+    case ApiKeys.LEAVE_GROUP => new LeaveGroupRequest(new LeaveGroupRequestData().toStruct(version), version)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwMTAxMDIz", "url": "https://github.com/apache/kafka/pull/9526#pullrequestreview-520101023", "createdAt": "2020-10-29T21:26:50Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMToyNjo1MFrOHqvWSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQyMToyNjo1MFrOHqvWSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU3Nzk5Mg==", "bodyText": "I was thinking a bit more about the time fields, and I think we should add Ms to the end of all of them. What do you think?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r514577992", "createdAt": "2020-10-29T21:26:50Z", "author": {"login": "lbradstreet"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,343 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version())\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data(), request.version())\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version())\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version())\n+      case req: ProduceRequest => produceRequestNode(req, request.version(), verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data(), request.version())\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version())\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data(), request.version())\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data(), version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data(), version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data(), version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data(), version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data(), version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data(), version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data(), version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data(), version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data(), version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data(), version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data(), version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data(), version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data(), version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data(), version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data(), version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data(), version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKey\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                  context: RequestContext, session: Session, verbose: Boolean,\n+                  totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                  apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                  responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                  messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTime\", new DoubleNode(totalTimeMs))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 175}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwOTM3MzY4", "url": "https://github.com/apache/kafka/pull/9526#pullrequestreview-520937368", "createdAt": "2020-10-30T18:34:58Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODozNDo1OVrOHrbnig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxODozNDo1OVrOHrbnig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMwMzMwNg==", "bodyText": "nit: unnecessary call of toString.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r515303306", "createdAt": "2020-10-30T18:34:59Z", "author": {"login": "splett2"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -131,7 +131,7 @@ class KafkaApis(val requestChannel: RequestChannel,\n    */\n   override def handle(request: RequestChannel.Request): Unit = {\n     try {\n-      trace(s\"Handling request:${request.requestDesc(true)} from connection ${request.context.connectionId};\" +\n+      trace(s\"Handling request:${RequestConvertToJson.requestDesc(request.header, request.loggableRequest, true).toString} from connection ${request.context.connectionId};\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMTU4OTcx", "url": "https://github.com/apache/kafka/pull/9526#pullrequestreview-521158971", "createdAt": "2020-10-31T18:18:12Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQxODoxODoxMlrOHrpGSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQxODoxODoxMlrOHrpGSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTUyNDE3MQ==", "bodyText": "nit: we can use scala interpolated string instead of String.format, unnecessary semicolon.\nalso, our error message mentions ApiKey, but the templated argument is response.\nDitto for request.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r515524171", "createdAt": "2020-10-31T18:18:12Z", "author": {"login": "splett2"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version)\n+      case req: ProduceRequest => produceRequestNode(req, request.version)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new AssertionError(String.format(\"ApiKey %s is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\", request));\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+      case _ => throw new AssertionError(String.format(\"ApiKey %s is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\", response));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 162}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMTc3Njk0", "url": "https://github.com/apache/kafka/pull/9526#pullrequestreview-521177694", "createdAt": "2020-10-31T23:02:15Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQyMzowMjoxNlrOHrqsLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQyMzowMjoxNlrOHrqsLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU1MDI1Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assert(unhandledKeys.isEmpty, String.format(\"%s request keys not handled in RequestConvertToJson\", unhandledKeys))\n          \n          \n            \n                assertEquals(\"Unhandled request keys\", ArrayBuffer.empty, unhandledKeys))\n          \n      \n    \n    \n  \n\nnit: we should prefer to use junit assertions.\nditto for testAllResponseTypesHandled.\nThese cases are not too bad because the assertion has a failure message.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r515550252", "createdAt": "2020-10-31T23:02:16Z", "author": {"login": "splett2"}, "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.nio.ByteBuffer\n+import java.util\n+import java.util.{Collections, Optional}\n+\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, Errors}\n+import org.apache.kafka.common.record.{CompressionType, MemoryRecords, RecordBatch, TimestampType}\n+import org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest.PartitionData\n+import org.apache.kafka.common.requests._\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = 0\n+      var req: AbstractRequest = null\n+      if (key == ApiKeys.PRODUCE) {\n+        // There's inconsistency with the toStruct schema in ProduceRequest\n+        // and ProduceRequestDataJsonConverters where the field names don't\n+        // match so the struct does not have the correct field names. This is\n+        // a temporary workaround until ProduceRequest starts using ProduceRequestData\n+        req = ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new util.HashMap[TopicPartition, MemoryRecords]()).build()\n+      } else {\n+        val struct = ApiMessageType.fromApiKey(key.id).newRequest().toStruct(version)\n+        req = AbstractRequest.parseRequest(key, version, struct)\n+      }\n+      try {\n+        RequestConvertToJson.request(req, false)\n+      } catch {\n+        case _ : AssertionError => unhandledKeys += key.toString\n+      }\n+    })\n+    assert(unhandledKeys.isEmpty, String.format(\"%s request keys not handled in RequestConvertToJson\", unhandledKeys))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMTc3ODUy", "url": "https://github.com/apache/kafka/pull/9526#pullrequestreview-521177852", "createdAt": "2020-10-31T23:04:53Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQyMzowNDo1M1rOHrqtDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQyMzowNDo1M1rOHrqtDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTU1MDQ3OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assert(manualGenNode.equals(autoGenNode))\n          \n          \n            \n                assertEquals(autoGenNode, manualGenNode)\n          \n      \n    \n    \n  \n\nusing assertEquals instead of assert(boolean) makes this test easier to debug, since if it fails we get a helpful print out of the objects. ditto for other testFormat tests.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r515550479", "createdAt": "2020-10-31T23:04:53Z", "author": {"login": "splett2"}, "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,140 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.nio.ByteBuffer\n+import java.util\n+import java.util.{Collections, Optional}\n+\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, Errors}\n+import org.apache.kafka.common.record.{CompressionType, MemoryRecords, RecordBatch, TimestampType}\n+import org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest.PartitionData\n+import org.apache.kafka.common.requests._\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = 0\n+      var req: AbstractRequest = null\n+      if (key == ApiKeys.PRODUCE) {\n+        // There's inconsistency with the toStruct schema in ProduceRequest\n+        // and ProduceRequestDataJsonConverters where the field names don't\n+        // match so the struct does not have the correct field names. This is\n+        // a temporary workaround until ProduceRequest starts using ProduceRequestData\n+        req = ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new util.HashMap[TopicPartition, MemoryRecords]()).build()\n+      } else {\n+        val struct = ApiMessageType.fromApiKey(key.id).newRequest().toStruct(version)\n+        req = AbstractRequest.parseRequest(key, version, struct)\n+      }\n+      try {\n+        RequestConvertToJson.request(req, false)\n+      } catch {\n+        case _ : AssertionError => unhandledKeys += key.toString\n+      }\n+    })\n+    assert(unhandledKeys.isEmpty, String.format(\"%s request keys not handled in RequestConvertToJson\", unhandledKeys))\n+  }\n+\n+  @Test\n+  def testAllResponseTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = 0\n+      val struct = ApiMessageType.fromApiKey(key.id).newResponse().toStruct(version)\n+      val res = AbstractResponse.parseResponse(key, struct, version)\n+      try {\n+        RequestConvertToJson.response(res, version)\n+      } catch {\n+        case _ : AssertionError => unhandledKeys += key.toString\n+      }\n+    })\n+    assert(unhandledKeys.isEmpty, String.format(\"%s response keys not handled in RequestConvertToJson\", unhandledKeys))\n+  }\n+\n+  @Test\n+  def testFormatOfOffsetsForLeaderEpochRequestNode(): Unit = {\n+    val partitionDataMap = new util.HashMap[TopicPartition, PartitionData]\n+    partitionDataMap.put(new TopicPartition(\"topic1\", 0), new PartitionData(Optional.of(0),  1))\n+\n+    val version: Short = 3\n+    val request = OffsetsForLeaderEpochRequest.Builder.forConsumer(partitionDataMap).build(version)\n+    val manualGenNode = RequestConvertToJson.request(request, false)\n+\n+    val requestData = OffsetForLeaderEpochRequestDataJsonConverter.read(manualGenNode, version)\n+    val autoGenNode = OffsetForLeaderEpochRequestDataJsonConverter.write(requestData, version)\n+\n+    assert(manualGenNode.equals(autoGenNode))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIzMzI1MjMz", "url": "https://github.com/apache/kafka/pull/9526#pullrequestreview-523325233", "createdAt": "2020-11-04T12:44:14Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMjo0NDoxNFrOHtWfvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMzozMDo0MFrOHtYHFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxNjU0Mg==", "bodyText": "IllegaleStateException sounds more appropriate here and below.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r517316542", "createdAt": "2020-11-04T12:44:14Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version)\n+      case req: ProduceRequest => produceRequestNode(req, request.version)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new AssertionError(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxNzM1NA==", "bodyText": "It seems that verbose is not used anymore. I think that we were dumping the full Produce request and Fetch response when verbose was true. Should we just remove it?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r517317354", "createdAt": "2020-11-04T12:45:41Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxNzY1NA==", "bodyText": "softwareName -> softwareVersion?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r517317654", "createdAt": "2020-11-04T12:46:11Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version)\n+      case req: ProduceRequest => produceRequestNode(req, request.version)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new AssertionError(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+      case _ => throw new AssertionError(s\"ApiKey $response is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKeyName\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def clientInfoNode(clientInfo: ClientInformation): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareName()))\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareVersion()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxOTU1Mw==", "bodyText": "nit: Missing space before =>.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r517319553", "createdAt": "2020-11-04T12:49:48Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version)\n+      case req: ProduceRequest => produceRequestNode(req, request.version)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new AssertionError(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+      case _ => throw new AssertionError(s\"ApiKey $response is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKeyName\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def clientInfoNode(clientInfo: ClientInformation): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareName()))\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareVersion()))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                         context: RequestContext, session: Session, verbose: Boolean,\n+                         totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                         apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                         responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                         messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTimeMs\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTimeMs\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTimeMs\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTimeMs\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTimeMs\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTimeMs\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTimeMs\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", clientInfoNode(context.clientInformation))\n+    if (temporaryMemoryBytes > 0)\n+      node.set(\"temporaryMemoryBytes\", new LongNode(temporaryMemoryBytes))\n+    if (messageConversionsTimeMs > 0)\n+      node.set(\"messageConversionsTime\", new DoubleNode(messageConversionsTimeMs))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, req: AbstractRequest, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def offsetsForLeaderEpochRequestNode(request: OffsetsForLeaderEpochRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      node.set(\"replicaId\", new IntNode(request.replicaId))\n+    }\n+    val topics = CollectionUtils.groupPartitionDataByTopic(request.epochsByTopicPartition)\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    topics.forEach { (topicName, partitions) =>\n+      val topicNode = new ObjectNode(JsonNodeFactory.instance)\n+      topicNode.set(\"name\", new TextNode(topicName))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      partitions.forEach { (partitionIndex, partitionData) =>\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionIndex))\n+        if (version >= 2) {\n+          val leaderEpoch = partitionData.currentLeaderEpoch\n+          partitionNode.set(\"currentLeaderEpoch\", new IntNode(leaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH)))\n+        }\n+        partitionNode.set(\"leaderEpoch\", new IntNode(partitionData.leaderEpoch))\n+        partitionsArray.add(partitionNode)\n+      }\n+      topicNode.set(\"partitions\", partitionsArray)\n+      topicsArray.add(topicNode)\n+    }\n+    node.set(\"topics\", topicsArray)\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def produceRequestNode(request: ProduceRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      if (request.transactionalId == null) {\n+        node.set(\"transactionalId\", NullNode.instance)\n+      } else {\n+        node.set(\"transactionalId\", new TextNode(request.transactionalId))\n+      }\n+    }\n+    node.set(\"acks\", new ShortNode(request.acks))\n+    node.set(\"timeoutMs\", new IntNode(request.timeout))\n+    val topics = CollectionUtils.groupPartitionDataByTopic(request.partitionRecordsOrFail())\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    topics.forEach { (topicName, partitions) =>\n+      val topicNode = new ObjectNode(JsonNodeFactory.instance)\n+      topicNode.set(\"name\", new TextNode(topicName))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      partitions.forEach { (partitionIndex, partitionData)=>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxOTgxOQ==", "bodyText": "This is not consistent with the changes that have been made in the automated protocol.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r517319819", "createdAt": "2020-11-04T12:50:16Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version)\n+      case req: ProduceRequest => produceRequestNode(req, request.version)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new AssertionError(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+      case _ => throw new AssertionError(s\"ApiKey $response is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKeyName\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def clientInfoNode(clientInfo: ClientInformation): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareName()))\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareVersion()))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                         context: RequestContext, session: Session, verbose: Boolean,\n+                         totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                         apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                         responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                         messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTimeMs\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTimeMs\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTimeMs\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTimeMs\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTimeMs\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTimeMs\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTimeMs\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", clientInfoNode(context.clientInformation))\n+    if (temporaryMemoryBytes > 0)\n+      node.set(\"temporaryMemoryBytes\", new LongNode(temporaryMemoryBytes))\n+    if (messageConversionsTimeMs > 0)\n+      node.set(\"messageConversionsTime\", new DoubleNode(messageConversionsTimeMs))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, req: AbstractRequest, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def offsetsForLeaderEpochRequestNode(request: OffsetsForLeaderEpochRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      node.set(\"replicaId\", new IntNode(request.replicaId))\n+    }\n+    val topics = CollectionUtils.groupPartitionDataByTopic(request.epochsByTopicPartition)\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    topics.forEach { (topicName, partitions) =>\n+      val topicNode = new ObjectNode(JsonNodeFactory.instance)\n+      topicNode.set(\"name\", new TextNode(topicName))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      partitions.forEach { (partitionIndex, partitionData) =>\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionIndex))\n+        if (version >= 2) {\n+          val leaderEpoch = partitionData.currentLeaderEpoch\n+          partitionNode.set(\"currentLeaderEpoch\", new IntNode(leaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH)))\n+        }\n+        partitionNode.set(\"leaderEpoch\", new IntNode(partitionData.leaderEpoch))\n+        partitionsArray.add(partitionNode)\n+      }\n+      topicNode.set(\"partitions\", partitionsArray)\n+      topicsArray.add(topicNode)\n+    }\n+    node.set(\"topics\", topicsArray)\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def produceRequestNode(request: ProduceRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      if (request.transactionalId == null) {\n+        node.set(\"transactionalId\", NullNode.instance)\n+      } else {\n+        node.set(\"transactionalId\", new TextNode(request.transactionalId))\n+      }\n+    }\n+    node.set(\"acks\", new ShortNode(request.acks))\n+    node.set(\"timeoutMs\", new IntNode(request.timeout))\n+    val topics = CollectionUtils.groupPartitionDataByTopic(request.partitionRecordsOrFail())\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    topics.forEach { (topicName, partitions) =>\n+      val topicNode = new ObjectNode(JsonNodeFactory.instance)\n+      topicNode.set(\"name\", new TextNode(topicName))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      partitions.forEach { (partitionIndex, partitionData)=>\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionIndex))\n+        if (partitionData == null)\n+          partitionNode.set(\"records\", NullNode.instance)\n+        else\n+          partitionNode.set(\"records\", new BinaryNode(util.Arrays.copyOf(partitionData.buffer().array(), partitionData.validBytes())))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzM0Mjk5Nw==", "bodyText": "I am not entirely convinced by this change. The aim of the auto-generated protocol is to serialize/deserialise the requests/responses. Thus, it is a little weird that we only retain the size when serializing records to JSON and we actually expect bytes when deserializing from JSON. We are not consistent.\nI can think of the following alternatives:\n\nWe keep exceptions for both the produce request and the fetch response in RequestConvertToJson where we could add a recordsSizeInBytes field instead of the records field.\nWe could post-process the JSON tree where we could discard records and add recordsSizeInBytes.\nWe could extend the autogenerated protocol to do only retain the size based on a flag. I am thinking about a verbose flag like we had before.\n\nI lean towards 3) at the moment. By default, we should keep the current behavior and only retains the size when verbose is false. We may find a better name than verbose though.\n@anatasiavela @lbradstreet Would this make sense?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r517342997", "createdAt": "2020-11-04T13:30:40Z", "author": {"login": "dajac"}, "path": "generator/src/main/java/org/apache/kafka/message/JsonConverterGenerator.java", "diffHunk": "@@ -380,8 +380,9 @@ private void generateVariableLengthTargetToJson(Target target, Versions versions\n                         target.sourceVariable(), target.sourceVariable())));\n             }\n         } else if (target.field().type().isRecords()) {\n-            headerGenerator.addImport(MessageGenerator.BINARY_NODE_CLASS);\n-            buffer.printf(\"%s;%n\", target.assignmentStatement(\"new BinaryNode(new byte[]{})\"));\n+            headerGenerator.addImport(MessageGenerator.INT_NODE_CLASS);\n+            buffer.printf(\"%s;%n\", target.assignmentStatement(\n+                    String.format(\"new IntNode(%s.sizeInBytes())\", target.sourceVariable())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NDQzMTE3", "url": "https://github.com/apache/kafka/pull/9526#pullrequestreview-524443117", "createdAt": "2020-11-05T16:31:06Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNjozMTowN1rOHuLqoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQxNjo1NToyOVrOHuMvtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4NzY4MQ==", "bodyText": "Is this one still used? It seems that it is not the case.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518187681", "createdAt": "2020-11-05T16:31:07Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/ProduceRequest.java", "diffHunk": "@@ -346,6 +346,10 @@ public ProduceResponse getErrorResponse(int throttleTimeMs, Throwable e) {\n         return partitionSizes.keySet();\n     }\n \n+    public Map<TopicPartition, Integer> partitionSizes() {\n+        return partitionSizes;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4ODIwNw==", "bodyText": "Could we add a unit test for this method?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518188207", "createdAt": "2020-11-05T16:31:51Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version, verbose)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version, verbose)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version, verbose)\n+      case req: ProduceRequest => produceRequestNode(req, request.version, verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case _ => throw new IllegalStateException(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short, verbose: Boolean): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version, verbose)\n+      case res: ProduceResponse => produceResponseNode(res, version, verbose)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version, verbose)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version, verbose)\n+      case _ => throw new IllegalStateException(s\"ApiKey $response is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader, verbose: Boolean): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion(), verbose).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKeyName\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def clientInfoNode(clientInfo: ClientInformation): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareName()))\n+    node.set(\"softwareVersion\", new TextNode(clientInfo.softwareVersion()))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE4OTk4Nw==", "bodyText": "Right. I think that we will change it to records type when we will migrate the produce request. Anyway, we should not serialize the bytes to JSON here but rather put the size. We should retain the size of the records set for both the produce request and the fetch response.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518189987", "createdAt": "2020-11-05T16:34:18Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version)\n+      case req: ProduceRequest => produceRequestNode(req, request.version)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new AssertionError(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+      case _ => throw new AssertionError(s\"ApiKey $response is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion()).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKeyName\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def clientInfoNode(clientInfo: ClientInformation): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareName()))\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareVersion()))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                         context: RequestContext, session: Session, verbose: Boolean,\n+                         totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                         apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                         responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                         messageConversionsTimeMs: Double): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTimeMs\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTimeMs\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTimeMs\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTimeMs\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTimeMs\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTimeMs\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTimeMs\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", clientInfoNode(context.clientInformation))\n+    if (temporaryMemoryBytes > 0)\n+      node.set(\"temporaryMemoryBytes\", new LongNode(temporaryMemoryBytes))\n+    if (messageConversionsTimeMs > 0)\n+      node.set(\"messageConversionsTime\", new DoubleNode(messageConversionsTimeMs))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, req: AbstractRequest, verbose: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req, verbose))\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def offsetsForLeaderEpochRequestNode(request: OffsetsForLeaderEpochRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      node.set(\"replicaId\", new IntNode(request.replicaId))\n+    }\n+    val topics = CollectionUtils.groupPartitionDataByTopic(request.epochsByTopicPartition)\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    topics.forEach { (topicName, partitions) =>\n+      val topicNode = new ObjectNode(JsonNodeFactory.instance)\n+      topicNode.set(\"name\", new TextNode(topicName))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      partitions.forEach { (partitionIndex, partitionData) =>\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionIndex))\n+        if (version >= 2) {\n+          val leaderEpoch = partitionData.currentLeaderEpoch\n+          partitionNode.set(\"currentLeaderEpoch\", new IntNode(leaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH)))\n+        }\n+        partitionNode.set(\"leaderEpoch\", new IntNode(partitionData.leaderEpoch))\n+        partitionsArray.add(partitionNode)\n+      }\n+      topicNode.set(\"partitions\", partitionsArray)\n+      topicsArray.add(topicNode)\n+    }\n+    node.set(\"topics\", topicsArray)\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def produceRequestNode(request: ProduceRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      if (request.transactionalId == null) {\n+        node.set(\"transactionalId\", NullNode.instance)\n+      } else {\n+        node.set(\"transactionalId\", new TextNode(request.transactionalId))\n+      }\n+    }\n+    node.set(\"acks\", new ShortNode(request.acks))\n+    node.set(\"timeoutMs\", new IntNode(request.timeout))\n+    val topics = CollectionUtils.groupPartitionDataByTopic(request.partitionRecordsOrFail())\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    topics.forEach { (topicName, partitions) =>\n+      val topicNode = new ObjectNode(JsonNodeFactory.instance)\n+      topicNode.set(\"name\", new TextNode(topicName))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      partitions.forEach { (partitionIndex, partitionData)=>\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionIndex))\n+        if (partitionData == null)\n+          partitionNode.set(\"records\", NullNode.instance)\n+        else\n+          partitionNode.set(\"records\", new BinaryNode(util.Arrays.copyOf(partitionData.buffer().array(), partitionData.validBytes())))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxOTgxOQ=="}, "originalCommit": null, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5Mjg0NQ==", "bodyText": "I think that we can remove this verbose flag here and only set it to false for both the produce request and the fetch response. I don't think that we will ever want to print out the bytes in the request log. Previously, we were printing out different things based on the flag but we never printed out the bytes: https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/common/requests/ProduceRequest.java#L314.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518192845", "createdAt": "2020-11-05T16:38:16Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,360 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzMxNzM1NA=="}, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5MzQ2Ng==", "bodyText": "IllegalStateException?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518193466", "createdAt": "2020-11-05T16:39:10Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,141 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.nio.ByteBuffer\n+import java.util\n+import java.util.{Collections, Optional}\n+\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, Errors}\n+import org.apache.kafka.common.record.{CompressionType, MemoryRecords, RecordBatch, TimestampType}\n+import org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest.PartitionData\n+import org.apache.kafka.common.requests._\n+import org.junit.Assert.assertEquals\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = 0\n+      var req: AbstractRequest = null\n+      if (key == ApiKeys.PRODUCE) {\n+        // There's inconsistency with the toStruct schema in ProduceRequest\n+        // and ProduceRequestDataJsonConverters where the field names don't\n+        // match so the struct does not have the correct field names. This is\n+        // a temporary workaround until ProduceRequest starts using ProduceRequestData\n+        req = ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new util.HashMap[TopicPartition, MemoryRecords]()).build()\n+      } else {\n+        val struct = ApiMessageType.fromApiKey(key.id).newRequest().toStruct(version)\n+        req = AbstractRequest.parseRequest(key, version, struct)\n+      }\n+      try {\n+        RequestConvertToJson.request(req, false)\n+      } catch {\n+        case _ : AssertionError => unhandledKeys += key.toString", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5MzU1NA==", "bodyText": "IllegalStateException?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518193554", "createdAt": "2020-11-05T16:39:18Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,141 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.nio.ByteBuffer\n+import java.util\n+import java.util.{Collections, Optional}\n+\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, Errors}\n+import org.apache.kafka.common.record.{CompressionType, MemoryRecords, RecordBatch, TimestampType}\n+import org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest.PartitionData\n+import org.apache.kafka.common.requests._\n+import org.junit.Assert.assertEquals\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = 0\n+      var req: AbstractRequest = null\n+      if (key == ApiKeys.PRODUCE) {\n+        // There's inconsistency with the toStruct schema in ProduceRequest\n+        // and ProduceRequestDataJsonConverters where the field names don't\n+        // match so the struct does not have the correct field names. This is\n+        // a temporary workaround until ProduceRequest starts using ProduceRequestData\n+        req = ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new util.HashMap[TopicPartition, MemoryRecords]()).build()\n+      } else {\n+        val struct = ApiMessageType.fromApiKey(key.id).newRequest().toStruct(version)\n+        req = AbstractRequest.parseRequest(key, version, struct)\n+      }\n+      try {\n+        RequestConvertToJson.request(req, false)\n+      } catch {\n+        case _ : AssertionError => unhandledKeys += key.toString\n+      }\n+    })\n+    assertEquals(\"Unhandled request keys\", ArrayBuffer.empty, unhandledKeys)\n+  }\n+\n+  @Test\n+  def testAllResponseTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = 0\n+      val struct = ApiMessageType.fromApiKey(key.id).newResponse().toStruct(version)\n+      val res = AbstractResponse.parseResponse(key, struct, version)\n+      try {\n+        RequestConvertToJson.response(res, version, false)\n+      } catch {\n+        case _ : AssertionError => unhandledKeys += key.toString", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5NjIyMA==", "bodyText": "I think that we can safely assume that when a request/response is serialized with verbose equals to false, we are not going to deserialize it. Therefore, I suggest to drop the handling of verbose on the read path.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518196220", "createdAt": "2020-11-05T16:42:54Z", "author": {"login": "dajac"}, "path": "generator/src/main/java/org/apache/kafka/message/JsonConverterGenerator.java", "diffHunk": "@@ -227,9 +227,13 @@ private void generateVariableLengthTargetFromJson(Target target, Versions curVer\n             headerGenerator.addImport(MessageGenerator.MESSAGE_UTIL_CLASS);\n             headerGenerator.addImport(MessageGenerator.BYTE_BUFFER_CLASS);\n             headerGenerator.addImport(MessageGenerator.MEMORY_RECORDS_CLASS);\n+            buffer.printf(\"if (_verbose) {%n\");\n+            buffer.incrementIndent();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5NzYzMw==", "bodyText": "I wonder if we could find a better name than verbose. Perhaps, we could be more explicit and use something like serializeRecords as we actually only use it for this at the moment. What do you think?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518197633", "createdAt": "2020-11-05T16:44:50Z", "author": {"login": "dajac"}, "path": "generator/src/main/java/org/apache/kafka/message/JsonConverterGenerator.java", "diffHunk": "@@ -380,8 +384,18 @@ private void generateVariableLengthTargetToJson(Target target, Versions versions\n                         target.sourceVariable(), target.sourceVariable())));\n             }\n         } else if (target.field().type().isRecords()) {\n+            headerGenerator.addImport(MessageGenerator.INT_NODE_CLASS);\n             headerGenerator.addImport(MessageGenerator.BINARY_NODE_CLASS);\n+            buffer.printf(\"if (_verbose) {%n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5ODg2OQ==", "bodyText": "Instead of changing the usage of this method everywhere in the code base, how about generating an overloaded method which call this one with verbose=true? I only expect this one to be used by the request logger at the moment so it is also more convenient.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518198869", "createdAt": "2020-11-05T16:46:29Z", "author": {"login": "dajac"}, "path": "generator/src/main/java/org/apache/kafka/message/JsonConverterGenerator.java", "diffHunk": "@@ -261,7 +265,7 @@ private void generateWrite(String className,\n                                StructSpec struct,\n                                Versions parentVersions) {\n         headerGenerator.addImport(MessageGenerator.JSON_NODE_CLASS);\n-        buffer.printf(\"public static JsonNode write(%s _object, short _version) {%n\",\n+        buffer.printf(\"public static JsonNode write(%s _object, short _version, boolean _verbose) {%n\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwMjY3OQ==", "bodyText": "I think that we should set this to false.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518202679", "createdAt": "2020-11-05T16:51:51Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -3354,7 +3354,7 @@ class KafkaApis(val requestChannel: RequestChannel,\n       case Some(response) =>\n         val responseSend = request.context.buildResponse(response)\n         val responseString =\n-          if (RequestChannel.isRequestLoggingEnabled) Some(response.toString(request.context.apiVersion))\n+          if (RequestChannel.isRequestLoggingEnabled) Some(RequestConvertToJson.response(response, request.context.apiVersion, true))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwNDEyMg==", "bodyText": "verbose should be false here (if we keep it).", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518204122", "createdAt": "2020-11-05T16:53:49Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -131,7 +131,7 @@ class KafkaApis(val requestChannel: RequestChannel,\n    */\n   override def handle(request: RequestChannel.Request): Unit = {\n     try {\n-      trace(s\"Handling request:${request.requestDesc(true)} from connection ${request.context.connectionId};\" +\n+      trace(s\"Handling request:${RequestConvertToJson.requestDesc(request.header, request.loggableRequest, true).toString} from connection ${request.context.connectionId};\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwNDM5NA==", "bodyText": "verbose should be false here (if we keep it).", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518204394", "createdAt": "2020-11-05T16:54:11Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/tools/TestRaftRequestHandler.scala", "diffHunk": "@@ -39,7 +40,7 @@ class TestRaftRequestHandler(\n \n   override def handle(request: RequestChannel.Request): Unit = {\n     try {\n-      trace(s\"Handling request:${request.requestDesc(true)} from connection ${request.context.connectionId};\" +\n+      trace(s\"Handling request:${RequestConvertToJson.requestDesc(request.header, request.loggableRequest, true)} from connection ${request.context.connectionId};\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODIwNTM2Nw==", "bodyText": "Could we also add a comment here which explains why we are doing this? We can also add the KIP number.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r518205367", "createdAt": "2020-11-05T16:55:29Z", "author": {"login": "dajac"}, "path": "generator/src/main/java/org/apache/kafka/message/JsonConverterGenerator.java", "diffHunk": "@@ -380,8 +384,18 @@ private void generateVariableLengthTargetToJson(Target target, Versions versions\n                         target.sourceVariable(), target.sourceVariable())));\n             }\n         } else if (target.field().type().isRecords()) {\n+            headerGenerator.addImport(MessageGenerator.INT_NODE_CLASS);\n             headerGenerator.addImport(MessageGenerator.BINARY_NODE_CLASS);\n+            buffer.printf(\"if (_verbose) {%n\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE5NzYzMw=="}, "originalCommit": null, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2OTE2Mzg0", "url": "https://github.com/apache/kafka/pull/9526#pullrequestreview-526916384", "createdAt": "2020-11-10T07:21:06Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwNzoyMTowNlrOHwPFaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwODowODo1NlrOHwQdJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0MDg0Mw==", "bodyText": "It seems that we can revert this back as we have the overloaded method now.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520340843", "createdAt": "2020-11-10T07:21:06Z", "author": {"login": "dajac"}, "path": "clients/src/test/java/org/apache/kafka/common/message/SimpleExampleMessageTest.java", "diffHunk": "@@ -394,7 +394,7 @@ private void testRoundTrip(SimpleExampleMessageData message,\n         assertEquals(message.hashCode(), messageFromStruct.hashCode());\n \n         // Check JSON serialization\n-        JsonNode serializedJson = SimpleExampleMessageDataJsonConverter.write(message, version);\n+        JsonNode serializedJson = SimpleExampleMessageDataJsonConverter.write(message, version, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0MjExNA==", "bodyText": "It seems that we can remove verbose as we don't really use it anymore. Instead, we could set it to false for the produce request below.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520342114", "createdAt": "2020-11-10T07:24:19Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0MjM3MQ==", "bodyText": "Same here. We can remove verbose and set it to false for the fetch response.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520342371", "createdAt": "2020-11-10T07:24:53Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest, verbose: Boolean): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version, verbose)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version, verbose)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version, verbose)\n+      case req: ProduceRequest => produceRequestNode(req, request.version, verbose)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version, verbose)\n+      case _ => throw new IllegalStateException(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short, verbose: Boolean): JsonNode = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0ODQ3MQ==", "bodyText": "I suppose that we need to keep checking if (RequestChannel.isRequestLoggingEnabled) here.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520348471", "createdAt": "2020-11-10T07:39:03Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/tools/TestRaftRequestHandler.scala", "diffHunk": "@@ -93,10 +94,8 @@ class TestRaftRequestHandler(\n     val response = responseOpt match {\n       case Some(response) =>\n         val responseSend = request.context.buildResponse(response)\n-        val responseString =\n-          if (RequestChannel.isRequestLoggingEnabled) Some(response.toString(request.context.apiVersion))\n-          else None\n-        new RequestChannel.SendResponse(request, responseSend, responseString, None)\n+        val headerLog = RequestConvertToJson.requestHeaderNode(request.header)\n+        new RequestChannel.SendResponse(request, responseSend, Some(headerLog), None)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM0OTQyMQ==", "bodyText": "nit: Could we add a new line after @Test?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520349421", "createdAt": "2020-11-10T07:40:55Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.net.InetAddress\n+import java.nio.ByteBuffer\n+import java.util\n+import java.util.{Collections, Optional}\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.ObjectNode\n+import kafka.network\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.memory.MemoryPool\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.{ClientInformation, ListenerName, NetworkSend}\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, Errors}\n+import org.apache.kafka.common.record.{MemoryRecords, RecordBatch}\n+import org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest.PartitionData\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.security.auth.{KafkaPrincipal, SecurityProtocol}\n+import org.easymock.EasyMock.createNiceMock\n+import org.junit.Assert.assertEquals\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = key.latestVersion()\n+      var req: AbstractRequest = null\n+      if (key == ApiKeys.PRODUCE) {\n+        // There's inconsistency with the toStruct schema in ProduceRequest\n+        // and ProduceRequestDataJsonConverters where the field names don't\n+        // match so the struct does not have the correct field names. This is\n+        // a temporary workaround until ProduceRequest starts using ProduceRequestData\n+        req = ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new util.HashMap[TopicPartition, MemoryRecords]).build()\n+      } else {\n+        val struct = ApiMessageType.fromApiKey(key.id).newRequest().toStruct(version)\n+        req = AbstractRequest.parseRequest(key, version, struct)\n+      }\n+      try {\n+        RequestConvertToJson.request(req, false)\n+      } catch {\n+        case _ : IllegalStateException => unhandledKeys += key.toString\n+      }\n+    })\n+    assertEquals(\"Unhandled request keys\", ArrayBuffer.empty, unhandledKeys)\n+  }\n+\n+  @Test\n+  def testAllResponseTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = key.latestVersion()\n+      val struct = ApiMessageType.fromApiKey(key.id).newResponse().toStruct(version)\n+      val res = AbstractResponse.parseResponse(key, struct, version)\n+      try {\n+        RequestConvertToJson.response(res, version, false)\n+      } catch {\n+        case _ : IllegalStateException => unhandledKeys += key.toString\n+      }\n+    })\n+    assertEquals(\"Unhandled response keys\", ArrayBuffer.empty, unhandledKeys)\n+  }\n+\n+  @Test\n+  def testFormatOfOffsetsForLeaderEpochRequestNode(): Unit = {\n+    val partitionDataMap = new util.HashMap[TopicPartition, PartitionData]\n+    partitionDataMap.put(new TopicPartition(\"topic1\", 0), new PartitionData(Optional.of(0),  1))\n+\n+    val version: Short = ApiKeys.OFFSET_FOR_LEADER_EPOCH.latestVersion\n+    val request = OffsetsForLeaderEpochRequest.Builder.forConsumer(partitionDataMap).build(version)\n+    val actualNode = RequestConvertToJson.request(request, true)\n+\n+    val requestData = OffsetForLeaderEpochRequestDataJsonConverter.read(actualNode, version)\n+    val expectedNode = OffsetForLeaderEpochRequestDataJsonConverter.write(requestData, version, true)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test\n+  def testFormatOfProduceRequestNode(): Unit = {\n+    val produceDataMap = new util.HashMap[TopicPartition, MemoryRecords]\n+\n+    val version: Short = ApiKeys.PRODUCE.latestVersion\n+    val serializeRecords: Boolean = false;\n+    val request = ProduceRequest.Builder.forMagic(2, 0.toShort, 0, produceDataMap, \"\").build()\n+    val actualNode = RequestConvertToJson.request(request, serializeRecords)\n+\n+    val requestData = new ProduceRequestData()\n+    val expectedNode = ProduceRequestDataJsonConverter.write(requestData, version, serializeRecords)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test\n+  def testFormatOfOffsetsForLeaderEpochResponseNode(): Unit = {\n+    val endOffsetMap = new util.HashMap[TopicPartition, EpochEndOffset]\n+    endOffsetMap.put(new TopicPartition(\"topic1\", 0), new EpochEndOffset(1, 10L))\n+\n+    val version: Short = ApiKeys.OFFSET_FOR_LEADER_EPOCH.latestVersion\n+    val response = new OffsetsForLeaderEpochResponse(endOffsetMap)\n+    val actualNode = RequestConvertToJson.response(response, version, true)\n+\n+    val requestData = OffsetForLeaderEpochResponseDataJsonConverter.read(actualNode, version)\n+    val expectedNode = OffsetForLeaderEpochResponseDataJsonConverter.write(requestData, version, true)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test\n+  def testFormatOfProduceResponseNode(): Unit = {\n+    val responseData = new util.HashMap[TopicPartition, ProduceResponse.PartitionResponse]\n+    val partResponse = new ProduceResponse.PartitionResponse(Errors.NONE, 10000, RecordBatch.NO_TIMESTAMP, 100, Collections.singletonList(new ProduceResponse.RecordError(3, \"Record error\")), \"Produce failed\")\n+    responseData.put(new TopicPartition(\"topic1\", 0), partResponse)\n+\n+    val version: Short = ApiKeys.PRODUCE.latestVersion\n+    val response = new ProduceResponse(responseData)\n+    val actualNode = RequestConvertToJson.response(response, version, true)\n+\n+    val requestData = ProduceResponseDataJsonConverter.read(actualNode, version)\n+    val expectedNode = ProduceResponseDataJsonConverter.write(requestData, version, true)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test def testFieldsRequestDescMetrics(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM1MTkwMQ==", "bodyText": "Thinking a bit more about this. I think that it may be worth validating the values as well to ensure that the input maps to the output. If we use different values for each field, we could verify that the output JSON object is correct. JSONNode are comparable so we could construct the expected output and use it in assertEquals. What do you think?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520351901", "createdAt": "2020-11-10T07:46:24Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.net.InetAddress\n+import java.nio.ByteBuffer\n+import java.util\n+import java.util.{Collections, Optional}\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.ObjectNode\n+import kafka.network\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.memory.MemoryPool\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.{ClientInformation, ListenerName, NetworkSend}\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, Errors}\n+import org.apache.kafka.common.record.{MemoryRecords, RecordBatch}\n+import org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest.PartitionData\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.security.auth.{KafkaPrincipal, SecurityProtocol}\n+import org.easymock.EasyMock.createNiceMock\n+import org.junit.Assert.assertEquals\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = key.latestVersion()\n+      var req: AbstractRequest = null\n+      if (key == ApiKeys.PRODUCE) {\n+        // There's inconsistency with the toStruct schema in ProduceRequest\n+        // and ProduceRequestDataJsonConverters where the field names don't\n+        // match so the struct does not have the correct field names. This is\n+        // a temporary workaround until ProduceRequest starts using ProduceRequestData\n+        req = ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new util.HashMap[TopicPartition, MemoryRecords]).build()\n+      } else {\n+        val struct = ApiMessageType.fromApiKey(key.id).newRequest().toStruct(version)\n+        req = AbstractRequest.parseRequest(key, version, struct)\n+      }\n+      try {\n+        RequestConvertToJson.request(req, false)\n+      } catch {\n+        case _ : IllegalStateException => unhandledKeys += key.toString\n+      }\n+    })\n+    assertEquals(\"Unhandled request keys\", ArrayBuffer.empty, unhandledKeys)\n+  }\n+\n+  @Test\n+  def testAllResponseTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = key.latestVersion()\n+      val struct = ApiMessageType.fromApiKey(key.id).newResponse().toStruct(version)\n+      val res = AbstractResponse.parseResponse(key, struct, version)\n+      try {\n+        RequestConvertToJson.response(res, version, false)\n+      } catch {\n+        case _ : IllegalStateException => unhandledKeys += key.toString\n+      }\n+    })\n+    assertEquals(\"Unhandled response keys\", ArrayBuffer.empty, unhandledKeys)\n+  }\n+\n+  @Test\n+  def testFormatOfOffsetsForLeaderEpochRequestNode(): Unit = {\n+    val partitionDataMap = new util.HashMap[TopicPartition, PartitionData]\n+    partitionDataMap.put(new TopicPartition(\"topic1\", 0), new PartitionData(Optional.of(0),  1))\n+\n+    val version: Short = ApiKeys.OFFSET_FOR_LEADER_EPOCH.latestVersion\n+    val request = OffsetsForLeaderEpochRequest.Builder.forConsumer(partitionDataMap).build(version)\n+    val actualNode = RequestConvertToJson.request(request, true)\n+\n+    val requestData = OffsetForLeaderEpochRequestDataJsonConverter.read(actualNode, version)\n+    val expectedNode = OffsetForLeaderEpochRequestDataJsonConverter.write(requestData, version, true)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test\n+  def testFormatOfProduceRequestNode(): Unit = {\n+    val produceDataMap = new util.HashMap[TopicPartition, MemoryRecords]\n+\n+    val version: Short = ApiKeys.PRODUCE.latestVersion\n+    val serializeRecords: Boolean = false;\n+    val request = ProduceRequest.Builder.forMagic(2, 0.toShort, 0, produceDataMap, \"\").build()\n+    val actualNode = RequestConvertToJson.request(request, serializeRecords)\n+\n+    val requestData = new ProduceRequestData()\n+    val expectedNode = ProduceRequestDataJsonConverter.write(requestData, version, serializeRecords)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test\n+  def testFormatOfOffsetsForLeaderEpochResponseNode(): Unit = {\n+    val endOffsetMap = new util.HashMap[TopicPartition, EpochEndOffset]\n+    endOffsetMap.put(new TopicPartition(\"topic1\", 0), new EpochEndOffset(1, 10L))\n+\n+    val version: Short = ApiKeys.OFFSET_FOR_LEADER_EPOCH.latestVersion\n+    val response = new OffsetsForLeaderEpochResponse(endOffsetMap)\n+    val actualNode = RequestConvertToJson.response(response, version, true)\n+\n+    val requestData = OffsetForLeaderEpochResponseDataJsonConverter.read(actualNode, version)\n+    val expectedNode = OffsetForLeaderEpochResponseDataJsonConverter.write(requestData, version, true)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test\n+  def testFormatOfProduceResponseNode(): Unit = {\n+    val responseData = new util.HashMap[TopicPartition, ProduceResponse.PartitionResponse]\n+    val partResponse = new ProduceResponse.PartitionResponse(Errors.NONE, 10000, RecordBatch.NO_TIMESTAMP, 100, Collections.singletonList(new ProduceResponse.RecordError(3, \"Record error\")), \"Produce failed\")\n+    responseData.put(new TopicPartition(\"topic1\", 0), partResponse)\n+\n+    val version: Short = ApiKeys.PRODUCE.latestVersion\n+    val response = new ProduceResponse(responseData)\n+    val actualNode = RequestConvertToJson.response(response, version, true)\n+\n+    val requestData = ProduceResponseDataJsonConverter.read(actualNode, version)\n+    val expectedNode = ProduceResponseDataJsonConverter.write(requestData, version, true)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test def testFieldsRequestDescMetrics(): Unit = {\n+    val expectedFields = Set(\"requestHeader\", \"request\", \"response\", \"connection\",\n+      \"totalTimeMs\", \"requestQueueTimeMs\", \"localTimeMs\", \"remoteTimeMs\", \"throttleTimeMs\",\n+      \"responseQueueTimeMs\", \"sendTimeMs\", \"securityProtocol\", \"principal\", \"listener\",\n+      \"clientInformation\", \"softwareName\", \"softwareVersion\", \"temporaryMemoryBytes\", \"messageConversionsTime\")\n+\n+    val req = request(new AlterIsrRequest(new AlterIsrRequestData(), 0))\n+    val byteBuffer = req.body[AbstractRequest].serialize(req.header)\n+    val send = new NetworkSend(req.context.connectionId, byteBuffer)\n+    val headerLog = RequestConvertToJson.requestHeaderNode(req.header)\n+    val res = new RequestChannel.SendResponse(req, send, Some(headerLog), None)\n+\n+    val node = RequestConvertToJson.requestDescMetrics(req.header, res, req.loggableRequest, req.context, req.session,\n+      1, 1, 1, 1, 1, 1, 1, 1, 1).asInstanceOf[ObjectNode]\n+    val foundFields = getFieldNames(node)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM1NjEwNQ==", "bodyText": "nit: Could we make it private?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520356105", "createdAt": "2020-11-10T07:55:03Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.net.InetAddress\n+import java.nio.ByteBuffer\n+import java.util\n+import java.util.{Collections, Optional}\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.ObjectNode\n+import kafka.network\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.memory.MemoryPool\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.{ClientInformation, ListenerName, NetworkSend}\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, Errors}\n+import org.apache.kafka.common.record.{MemoryRecords, RecordBatch}\n+import org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest.PartitionData\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.security.auth.{KafkaPrincipal, SecurityProtocol}\n+import org.easymock.EasyMock.createNiceMock\n+import org.junit.Assert.assertEquals\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = key.latestVersion()\n+      var req: AbstractRequest = null\n+      if (key == ApiKeys.PRODUCE) {\n+        // There's inconsistency with the toStruct schema in ProduceRequest\n+        // and ProduceRequestDataJsonConverters where the field names don't\n+        // match so the struct does not have the correct field names. This is\n+        // a temporary workaround until ProduceRequest starts using ProduceRequestData\n+        req = ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new util.HashMap[TopicPartition, MemoryRecords]).build()\n+      } else {\n+        val struct = ApiMessageType.fromApiKey(key.id).newRequest().toStruct(version)\n+        req = AbstractRequest.parseRequest(key, version, struct)\n+      }\n+      try {\n+        RequestConvertToJson.request(req, false)\n+      } catch {\n+        case _ : IllegalStateException => unhandledKeys += key.toString\n+      }\n+    })\n+    assertEquals(\"Unhandled request keys\", ArrayBuffer.empty, unhandledKeys)\n+  }\n+\n+  @Test\n+  def testAllResponseTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = key.latestVersion()\n+      val struct = ApiMessageType.fromApiKey(key.id).newResponse().toStruct(version)\n+      val res = AbstractResponse.parseResponse(key, struct, version)\n+      try {\n+        RequestConvertToJson.response(res, version, false)\n+      } catch {\n+        case _ : IllegalStateException => unhandledKeys += key.toString\n+      }\n+    })\n+    assertEquals(\"Unhandled response keys\", ArrayBuffer.empty, unhandledKeys)\n+  }\n+\n+  @Test\n+  def testFormatOfOffsetsForLeaderEpochRequestNode(): Unit = {\n+    val partitionDataMap = new util.HashMap[TopicPartition, PartitionData]\n+    partitionDataMap.put(new TopicPartition(\"topic1\", 0), new PartitionData(Optional.of(0),  1))\n+\n+    val version: Short = ApiKeys.OFFSET_FOR_LEADER_EPOCH.latestVersion\n+    val request = OffsetsForLeaderEpochRequest.Builder.forConsumer(partitionDataMap).build(version)\n+    val actualNode = RequestConvertToJson.request(request, true)\n+\n+    val requestData = OffsetForLeaderEpochRequestDataJsonConverter.read(actualNode, version)\n+    val expectedNode = OffsetForLeaderEpochRequestDataJsonConverter.write(requestData, version, true)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test\n+  def testFormatOfProduceRequestNode(): Unit = {\n+    val produceDataMap = new util.HashMap[TopicPartition, MemoryRecords]\n+\n+    val version: Short = ApiKeys.PRODUCE.latestVersion\n+    val serializeRecords: Boolean = false;\n+    val request = ProduceRequest.Builder.forMagic(2, 0.toShort, 0, produceDataMap, \"\").build()\n+    val actualNode = RequestConvertToJson.request(request, serializeRecords)\n+\n+    val requestData = new ProduceRequestData()\n+    val expectedNode = ProduceRequestDataJsonConverter.write(requestData, version, serializeRecords)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test\n+  def testFormatOfOffsetsForLeaderEpochResponseNode(): Unit = {\n+    val endOffsetMap = new util.HashMap[TopicPartition, EpochEndOffset]\n+    endOffsetMap.put(new TopicPartition(\"topic1\", 0), new EpochEndOffset(1, 10L))\n+\n+    val version: Short = ApiKeys.OFFSET_FOR_LEADER_EPOCH.latestVersion\n+    val response = new OffsetsForLeaderEpochResponse(endOffsetMap)\n+    val actualNode = RequestConvertToJson.response(response, version, true)\n+\n+    val requestData = OffsetForLeaderEpochResponseDataJsonConverter.read(actualNode, version)\n+    val expectedNode = OffsetForLeaderEpochResponseDataJsonConverter.write(requestData, version, true)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test\n+  def testFormatOfProduceResponseNode(): Unit = {\n+    val responseData = new util.HashMap[TopicPartition, ProduceResponse.PartitionResponse]\n+    val partResponse = new ProduceResponse.PartitionResponse(Errors.NONE, 10000, RecordBatch.NO_TIMESTAMP, 100, Collections.singletonList(new ProduceResponse.RecordError(3, \"Record error\")), \"Produce failed\")\n+    responseData.put(new TopicPartition(\"topic1\", 0), partResponse)\n+\n+    val version: Short = ApiKeys.PRODUCE.latestVersion\n+    val response = new ProduceResponse(responseData)\n+    val actualNode = RequestConvertToJson.response(response, version, true)\n+\n+    val requestData = ProduceResponseDataJsonConverter.read(actualNode, version)\n+    val expectedNode = ProduceResponseDataJsonConverter.write(requestData, version, true)\n+\n+    assertEquals(expectedNode, actualNode)\n+  }\n+\n+  @Test def testFieldsRequestDescMetrics(): Unit = {\n+    val expectedFields = Set(\"requestHeader\", \"request\", \"response\", \"connection\",\n+      \"totalTimeMs\", \"requestQueueTimeMs\", \"localTimeMs\", \"remoteTimeMs\", \"throttleTimeMs\",\n+      \"responseQueueTimeMs\", \"sendTimeMs\", \"securityProtocol\", \"principal\", \"listener\",\n+      \"clientInformation\", \"softwareName\", \"softwareVersion\", \"temporaryMemoryBytes\", \"messageConversionsTime\")\n+\n+    val req = request(new AlterIsrRequest(new AlterIsrRequestData(), 0))\n+    val byteBuffer = req.body[AbstractRequest].serialize(req.header)\n+    val send = new NetworkSend(req.context.connectionId, byteBuffer)\n+    val headerLog = RequestConvertToJson.requestHeaderNode(req.header)\n+    val res = new RequestChannel.SendResponse(req, send, Some(headerLog), None)\n+\n+    val node = RequestConvertToJson.requestDescMetrics(req.header, res, req.loggableRequest, req.context, req.session,\n+      1, 1, 1, 1, 1, 1, 1, 1, 1).asInstanceOf[ObjectNode]\n+    val foundFields = getFieldNames(node)\n+\n+    assertEquals(expectedFields, foundFields)\n+  }\n+\n+  def request(req: AbstractRequest): RequestChannel.Request = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM1ODIxMw==", "bodyText": "I am not sure to understand why we are doing this change now. It was not there before. Could you elaborate?\nIs it because the produce request does use bytes as type? It seems bytes was used there by mistake. FYI, the PR which will migrate the produce request to the automated protocol will change it to records: https://github.com/apache/kafka/pull/9401/files#diff-e6dde0832c4873b546db2ad0d37be899855a436972b0a2c5008b100a0ffff64dR50.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520358213", "createdAt": "2020-11-10T07:59:13Z", "author": {"login": "dajac"}, "path": "generator/src/main/java/org/apache/kafka/message/JsonConverterGenerator.java", "diffHunk": "@@ -375,13 +385,36 @@ private void generateVariableLengthTargetToJson(Target target, Versions versions\n                         target.sourceVariable())));\n             } else {\n                 headerGenerator.addImport(MessageGenerator.ARRAYS_CLASS);\n+                headerGenerator.addImport(MessageGenerator.INT_NODE_CLASS);\n+                buffer.printf(\"if (_serializeRecords) {%n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM2MDU4MA==", "bodyText": "nit: We would usually use a val here and write the block as follow:\nval req = if (key == ApiKeys.PRODUCE) {\n  ...\n} else {\n  ...\n}", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520360580", "createdAt": "2020-11-10T08:03:43Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.net.InetAddress\n+import java.nio.ByteBuffer\n+import java.util\n+import java.util.{Collections, Optional}\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.ObjectNode\n+import kafka.network\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.memory.MemoryPool\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.{ClientInformation, ListenerName, NetworkSend}\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, Errors}\n+import org.apache.kafka.common.record.{MemoryRecords, RecordBatch}\n+import org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest.PartitionData\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.security.auth.{KafkaPrincipal, SecurityProtocol}\n+import org.easymock.EasyMock.createNiceMock\n+import org.junit.Assert.assertEquals\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {\n+      val version: Short = key.latestVersion()\n+      var req: AbstractRequest = null\n+      if (key == ApiKeys.PRODUCE) {\n+        // There's inconsistency with the toStruct schema in ProduceRequest\n+        // and ProduceRequestDataJsonConverters where the field names don't\n+        // match so the struct does not have the correct field names. This is\n+        // a temporary workaround until ProduceRequest starts using ProduceRequestData\n+        req = ProduceRequest.Builder.forCurrentMagic(0.toShort, 10000, new util.HashMap[TopicPartition, MemoryRecords]).build()\n+      } else {\n+        val struct = ApiMessageType.fromApiKey(key.id).newRequest().toStruct(version)\n+        req = AbstractRequest.parseRequest(key, version, struct)\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM2MzMwMg==", "bodyText": "nit: We tend to write this as follow:\nApiKeys.values().foreach { key => \n  ...\n}\n\nThis is another similar case in testAllResponseTypesHandled.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r520363302", "createdAt": "2020-11-10T08:08:56Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.net.InetAddress\n+import java.nio.ByteBuffer\n+import java.util\n+import java.util.{Collections, Optional}\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.ObjectNode\n+import kafka.network\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.memory.MemoryPool\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.{ClientInformation, ListenerName, NetworkSend}\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, Errors}\n+import org.apache.kafka.common.record.{MemoryRecords, RecordBatch}\n+import org.apache.kafka.common.requests.OffsetsForLeaderEpochRequest.PartitionData\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.security.auth.{KafkaPrincipal, SecurityProtocol}\n+import org.easymock.EasyMock.createNiceMock\n+import org.junit.Assert.assertEquals\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach(key => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMzNjY2MjE2", "url": "https://github.com/apache/kafka/pull/9526#pullrequestreview-533666216", "createdAt": "2020-11-18T17:05:40Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNzowNTo0MFrOH14FWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQxNzowNTo0MFrOH14FWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI1NTQ1MA==", "bodyText": "Seeing as #9401 is about to merge, maybe we can wait for that before merging this and drop our manual JSON generation code for produce request/response?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r526255450", "createdAt": "2020-11-18T17:05:40Z", "author": {"login": "lbradstreet"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.util\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{ArrayNode, BinaryNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, NullNode, ObjectNode, ShortNode, TextNode}\n+import kafka.network.RequestChannel.{Response, Session}\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.record.RecordBatch\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.utils.CollectionUtils\n+\n+import scala.jdk.CollectionConverters._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => offsetsForLeaderEpochRequestNode(req, request.version)\n+      case req: ProduceRequest => produceRequestNode(req, request.version, false)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new IllegalStateException(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version, false)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => offsetsForLeaderEpochResponseNode(res, version)\n+      case res: ProduceResponse => produceResponseNode(res, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+      case _ => throw new IllegalStateException(s\"ApiKey $response is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data(), header.headerVersion(), false).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKeyName\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, req: AbstractRequest): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", request(req))\n+    node\n+  }\n+\n+  def clientInfoNode(clientInfo: ClientInformation): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareName()))\n+    node.set(\"softwareVersion\", new TextNode(clientInfo.softwareVersion()))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, res: Response, req: AbstractRequest,\n+                         context: RequestContext, session: Session,\n+                         totalTimeMs: Double, requestQueueTimeMs: Double, apiLocalTimeMs: Double,\n+                         apiRemoteTimeMs: Double, apiThrottleTimeMs: Long, responseQueueTimeMs: Double,\n+                         responseSendTimeMs: Double, temporaryMemoryBytes: Long,\n+                         messageConversionsTimeMs: Double): JsonNode = {\n+    val node = requestDesc(header, req).asInstanceOf[ObjectNode]\n+    node.set(\"response\", res.responseLog.getOrElse(new TextNode(\"\")))\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"totalTimeMs\", new DoubleNode(totalTimeMs))\n+    node.set(\"requestQueueTimeMs\", new DoubleNode(requestQueueTimeMs))\n+    node.set(\"localTimeMs\", new DoubleNode(apiLocalTimeMs))\n+    node.set(\"remoteTimeMs\", new DoubleNode(apiRemoteTimeMs))\n+    node.set(\"throttleTimeMs\", new LongNode(apiThrottleTimeMs))\n+    node.set(\"responseQueueTimeMs\", new DoubleNode(responseQueueTimeMs))\n+    node.set(\"sendTimeMs\", new DoubleNode(responseSendTimeMs))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"principal\", new TextNode(session.principal.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", clientInfoNode(context.clientInformation))\n+    if (temporaryMemoryBytes > 0)\n+      node.set(\"temporaryMemoryBytes\", new LongNode(temporaryMemoryBytes))\n+    if (messageConversionsTimeMs > 0)\n+      node.set(\"messageConversionsTime\", new DoubleNode(messageConversionsTimeMs))\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def offsetsForLeaderEpochRequestNode(request: OffsetsForLeaderEpochRequest, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      node.set(\"replicaId\", new IntNode(request.replicaId))\n+    }\n+    val topics = CollectionUtils.groupPartitionDataByTopic(request.epochsByTopicPartition)\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    topics.forEach { (topicName, partitions) =>\n+      val topicNode = new ObjectNode(JsonNodeFactory.instance)\n+      topicNode.set(\"name\", new TextNode(topicName))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      partitions.forEach { (partitionIndex, partitionData) =>\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionIndex))\n+        if (version >= 2) {\n+          val leaderEpoch = partitionData.currentLeaderEpoch\n+          partitionNode.set(\"currentLeaderEpoch\", new IntNode(leaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH)))\n+        }\n+        partitionNode.set(\"leaderEpoch\", new IntNode(partitionData.leaderEpoch))\n+        partitionsArray.add(partitionNode)\n+      }\n+      topicNode.set(\"partitions\", partitionsArray)\n+      topicsArray.add(topicNode)\n+    }\n+    node.set(\"topics\", topicsArray)\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def produceRequestNode(request: ProduceRequest, version: Short, serializeRecords: Boolean): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 3) {\n+      if (request.transactionalId == null) {\n+        node.set(\"transactionalId\", NullNode.instance)\n+      } else {\n+        node.set(\"transactionalId\", new TextNode(request.transactionalId))\n+      }\n+    }\n+    node.set(\"acks\", new ShortNode(request.acks))\n+    node.set(\"timeoutMs\", new IntNode(request.timeout))\n+    val topics = CollectionUtils.groupPartitionDataByTopic(request.partitionRecordsOrFail())\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    topics.forEach { (topicName, partitions) =>\n+      val topicNode = new ObjectNode(JsonNodeFactory.instance)\n+      topicNode.set(\"name\", new TextNode(topicName))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      partitions.forEach { (partitionIndex, partitionData) =>\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionIndex))\n+        if (partitionData == null) {\n+          partitionNode.set(\"records\", NullNode.instance)\n+        } else {\n+          if (serializeRecords)\n+            partitionNode.set(\"records\", new BinaryNode(util.Arrays.copyOf(partitionData.buffer().array(), partitionData.validBytes())))\n+          else\n+            partitionNode.set(\"records\", new IntNode(partitionData.validBytes()))\n+        }\n+        partitionsArray.add(partitionNode)\n+      }\n+      topicNode.set(\"partitions\", partitionsArray)\n+      topicsArray.add(topicNode)\n+    }\n+    node.set(\"topics\", topicsArray)\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def offsetsForLeaderEpochResponseNode(response: OffsetsForLeaderEpochResponse, version: Short): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    if (version >= 2) {\n+      node.set(\"throttleTimeMs\", new IntNode(response.throttleTimeMs))\n+    }\n+    val topics = CollectionUtils.groupPartitionDataByTopic(response.responses)\n+    val topicsArray = new ArrayNode(JsonNodeFactory.instance)\n+    topics.forEach { (topicName, partitions) =>\n+      val topicNode = new ObjectNode(JsonNodeFactory.instance)\n+      topicNode.set(\"name\", new TextNode(topicName))\n+      val partitionsArray = new ArrayNode(JsonNodeFactory.instance)\n+      partitions.forEach { (partitionIndex, partitionData) =>\n+        val partitionNode = new ObjectNode(JsonNodeFactory.instance)\n+        partitionNode.set(\"errorCode\", new ShortNode(partitionData.error.code))\n+        partitionNode.set(\"partitionIndex\", new IntNode(partitionIndex))\n+        if (version >= 1) partitionNode.set(\"leaderEpoch\", new IntNode(partitionData.leaderEpoch))\n+        partitionNode.set(\"endOffset\", new LongNode(partitionData.endOffset))\n+        partitionsArray.add(partitionNode)\n+      }\n+      topicNode.set(\"partitions\", partitionsArray)\n+      topicsArray.add(topicNode)\n+    }\n+    node.set(\"topics\", topicsArray)\n+    node\n+  }\n+\n+  /**\n+   * Temporary until switch to use the generated schemas.\n+   */\n+  def produceResponseNode(response: ProduceResponse, version: Short): JsonNode = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 315}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "db4cbab3af02e58acf19fe446074857e4eaf44e4", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/db4cbab3af02e58acf19fe446074857e4eaf44e4", "committedDate": "2020-11-20T05:45:12Z", "message": "integrate with rebase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8a26b6fbaead74096fde0ea41ebe2d337c01bc7", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/d8a26b6fbaead74096fde0ea41ebe2d337c01bc7", "committedDate": "2020-12-11T02:53:13Z", "message": "KAFKA-10525: Emit JSONs with new auto-generated schema\n\nKafka\u2019s request and response traces currently output in a format that is JSON-like and are not easily parsable.\n\nThere is a new auto-generated schema for each request type that supports outputting JSON payloads for request and response payloads. These can be adapted to provide structured request tracing."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3e1e1f1aa7412b602917b7a8ed00dbb9f8f0cea", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/c3e1e1f1aa7412b602917b7a8ed00dbb9f8f0cea", "committedDate": "2020-12-11T02:54:08Z", "message": "add extra lines"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c7203b6296c0c18b5127726114657c6a3d967ac", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/0c7203b6296c0c18b5127726114657c6a3d967ac", "committedDate": "2020-12-11T02:54:08Z", "message": "remove extra spaces"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38747a5782951f6740a1e1cebf007c73a6884b7d", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/38747a5782951f6740a1e1cebf007c73a6884b7d", "committedDate": "2020-12-11T02:59:26Z", "message": "add data accessor and creat tests for manually created data"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29392c482c0c0b26b96fa023fec0cd507dcc0bb5", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/29392c482c0c0b26b96fa023fec0cd507dcc0bb5", "committedDate": "2020-12-11T02:59:30Z", "message": "access data from accessor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb0633cabbd0737ef685726560f05cb7a8711ef7", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/fb0633cabbd0737ef685726560f05cb7a8711ef7", "committedDate": "2020-12-11T02:59:31Z", "message": "remove DESCRIBE_QUORUM case and add better error msg"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32f1e9db525d50728f3e36d8c59aaec7d718f90c", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/32f1e9db525d50728f3e36d8c59aaec7d718f90c", "committedDate": "2020-12-11T02:59:31Z", "message": "change error messages and asserts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab50c8fe258959cd8366ca6dbf56994046ab6f76", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/ab50c8fe258959cd8366ca6dbf56994046ab6f76", "committedDate": "2020-12-11T02:59:54Z", "message": "swap expected and actual, change error msg, add accessor to private data field"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97237afbd72335b7617a500afebe5b894aa5bdbc", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/97237afbd72335b7617a500afebe5b894aa5bdbc", "committedDate": "2020-12-11T02:59:57Z", "message": "change to data accessor method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "32578e449bb3808f9d19ac8dd7a38e1d91e2fdba", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/32578e449bb3808f9d19ac8dd7a38e1d91e2fdba", "committedDate": "2020-12-11T02:59:57Z", "message": "change recordSet field to print sizeInBytes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab73c10d4246341a67af90f7bcdd6ab5500da5d5", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/ab73c10d4246341a67af90f7bcdd6ab5500da5d5", "committedDate": "2020-12-11T02:59:57Z", "message": "trigger build"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3b548799abe15655ee1fdafdab5712bc1ea6444", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/d3b548799abe15655ee1fdafdab5712bc1ea6444", "committedDate": "2020-12-11T03:01:50Z", "message": "add verbose flag to records in JsonConverter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd9a82bd642090a7efbf64ac429a43fa9a040264", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/bd9a82bd642090a7efbf64ac429a43fa9a040264", "committedDate": "2020-12-11T03:03:03Z", "message": "add overload method for verbose flag"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fa879aed005435b8f56534322123f639598296a", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/0fa879aed005435b8f56534322123f639598296a", "committedDate": "2020-12-11T03:03:07Z", "message": "add parentheses"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4dd1524301a9dda7dec710d59c9eae204df36a8c", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/4dd1524301a9dda7dec710d59c9eae204df36a8c", "committedDate": "2020-12-11T03:03:08Z", "message": "remove verbose tag in unnecessary places"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b102b67fd5c44cd2b01e2e11000176d87b786d8d", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/b102b67fd5c44cd2b01e2e11000176d87b786d8d", "committedDate": "2020-12-11T03:03:09Z", "message": "integrate with rebase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e439d5d81c9cbede152775385c046b6208a1c04", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/3e439d5d81c9cbede152775385c046b6208a1c04", "committedDate": "2020-12-11T03:03:10Z", "message": "handle null ProduceRequest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bca18e9b36a8597078f45b4b8eda15e645fecfd", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/4bca18e9b36a8597078f45b4b8eda15e645fecfd", "committedDate": "2020-12-11T03:03:10Z", "message": "add specific case for ProduceRequest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cc67279ff1b8ea4d0fe014dbaf4787a662b5155", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/9cc67279ff1b8ea4d0fe014dbaf4787a662b5155", "committedDate": "2020-12-11T03:03:11Z", "message": "make produce request consistent"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f91474f006841d679bbe63d64fcdf3cc93282bc", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/5f91474f006841d679bbe63d64fcdf3cc93282bc", "committedDate": "2020-12-11T03:03:11Z", "message": "remove special handling for ProduceRequest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5OTIwNjM0", "url": "https://github.com/apache/kafka/pull/9526#pullrequestreview-549920634", "createdAt": "2020-12-11T09:13:06Z", "commit": {"oid": "9f176ffc29ed0da839df70c80e70a8a58cf7c5cf"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwOToxMzowN1rOIDvtzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwOTo0NToxNVrOIDw-2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5ODQxMw==", "bodyText": "We must use a val to store the requestLog in order to guarantee that the JSON representation is computed before the request is processed by the api layer. Otherwise, we still have a ProduceRequest without the data. The val may be private as well and I would put it right below bodyAndSize with a comment which explains why we do this.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r540798413", "createdAt": "2020-12-11T09:13:07Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestChannel.scala", "diffHunk": "@@ -121,9 +122,16 @@ object RequestChannel extends Logging {\n       }\n     }\n \n-    def responseString(response: AbstractResponse): Option[String] = {\n+    def requestLog: Option[JsonNode] = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f176ffc29ed0da839df70c80e70a8a58cf7c5cf"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc5OTgxNA==", "bodyText": "It seems that this one is used from KafkaApis and others. It may be better to keep the original implementation for these cases.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r540799814", "createdAt": "2020-12-11T09:15:32Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestChannel.scala", "diffHunk": "@@ -137,11 +145,8 @@ object RequestChannel extends Logging {\n       }\n     }\n \n-    def requestDesc(details: Boolean): String = {\n-      val forwardDescription = envelope.map { request =>\n-        s\"Forwarded request: ${request.context} \"\n-      }.getOrElse(\"\")\n-      s\"$forwardDescription$header -- ${loggableRequest.toString(details)}\"\n+    def requestDesc: JsonNode = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f176ffc29ed0da839df70c80e70a8a58cf7c5cf"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgwMTI4MQ==", "bodyText": "Shouldn't we pass false here in order to not serialize the records?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r540801281", "createdAt": "2020-12-11T09:17:33Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{BooleanNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, ObjectNode, TextNode}\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.requests._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EnvelopeRequest => EnvelopeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => OffsetForLeaderEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ProduceRequest => ProduceRequestDataJsonConverter.write(req.data, request.version)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f176ffc29ed0da839df70c80e70a8a58cf7c5cf"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgwMjk3MA==", "bodyText": "It seems that we don't use this one any more.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r540802970", "createdAt": "2020-12-11T09:20:13Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{BooleanNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, ObjectNode, TextNode}\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.requests._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EnvelopeRequest => EnvelopeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => OffsetForLeaderEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ProduceRequest => ProduceRequestDataJsonConverter.write(req.data, request.version)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new IllegalStateException(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: EnvelopeResponse => EnvelopeResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version, false)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => OffsetForLeaderEpochResponseDataJsonConverter.write(res.data(), version)\n+      case res: ProduceResponse => ProduceResponseDataJsonConverter.write(res.data(), version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+      case _ => throw new IllegalStateException(s\"ApiKey $response is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data, header.headerVersion, false).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKeyName\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestContextNode(context: RequestContext): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", clientInfoNode(context.clientInformation))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, requestNode: Option[JsonNode], envelope: Option[RequestChannel.Request] = None): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"isForwarded\", if (envelope.isDefined) BooleanNode.TRUE else BooleanNode.FALSE)\n+    node.set(\"forwardedRequest\", envelope.map(request => requestContextNode(request.context)).getOrElse(new TextNode(\"\")))\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", requestNode.getOrElse(new TextNode(\"\")))\n+    node\n+  }\n+\n+  def clientInfoNode(clientInfo: ClientInformation): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareName))\n+    node.set(\"softwareVersion\", new TextNode(clientInfo.softwareVersion))\n+    node\n+  }\n+\n+  def topicPartitionNode(topicPartition: TopicPartition): JsonNode = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f176ffc29ed0da839df70c80e70a8a58cf7c5cf"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgwNDY3OA==", "bodyText": "I am not sure that this is necessary. Knowing that the request is forwarded is enough, I suppose.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r540804678", "createdAt": "2020-12-11T09:22:47Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{BooleanNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, ObjectNode, TextNode}\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.requests._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EnvelopeRequest => EnvelopeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => OffsetForLeaderEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ProduceRequest => ProduceRequestDataJsonConverter.write(req.data, request.version)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new IllegalStateException(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: EnvelopeResponse => EnvelopeResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version, false)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => OffsetForLeaderEpochResponseDataJsonConverter.write(res.data(), version)\n+      case res: ProduceResponse => ProduceResponseDataJsonConverter.write(res.data(), version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+      case _ => throw new IllegalStateException(s\"ApiKey $response is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data, header.headerVersion, false).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKeyName\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestContextNode(context: RequestContext): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", clientInfoNode(context.clientInformation))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, requestNode: Option[JsonNode], envelope: Option[RequestChannel.Request] = None): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"isForwarded\", if (envelope.isDefined) BooleanNode.TRUE else BooleanNode.FALSE)\n+    node.set(\"forwardedRequest\", envelope.map(request => requestContextNode(request.context)).getOrElse(new TextNode(\"\")))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f176ffc29ed0da839df70c80e70a8a58cf7c5cf"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgwNTQzMQ==", "bodyText": "We must pass either the envelope  or isForwarded here as well. This is the main request log and, as it is, it does not tell if the request is forwarded or not.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r540805431", "createdAt": "2020-12-11T09:24:09Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{BooleanNode, DoubleNode, IntNode, JsonNodeFactory, LongNode, ObjectNode, TextNode}\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.requests._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EnvelopeRequest => EnvelopeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => OffsetForLeaderEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ProduceRequest => ProduceRequestDataJsonConverter.write(req.data, request.version)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new IllegalStateException(s\"ApiKey ${request.api} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: EnvelopeResponse => EnvelopeResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version, false)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => OffsetForLeaderEpochResponseDataJsonConverter.write(res.data(), version)\n+      case res: ProduceResponse => ProduceResponseDataJsonConverter.write(res.data(), version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+      case _ => throw new IllegalStateException(s\"ApiKey $response is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data, header.headerVersion, false).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKeyName\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestContextNode(context: RequestContext): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"connection\", new TextNode(context.connectionId))\n+    node.set(\"securityProtocol\", new TextNode(context.securityProtocol.toString))\n+    node.set(\"listener\", new TextNode(context.listenerName.value))\n+    node.set(\"clientInformation\", clientInfoNode(context.clientInformation))\n+    node\n+  }\n+\n+  def requestDesc(header: RequestHeader, requestNode: Option[JsonNode], envelope: Option[RequestChannel.Request] = None): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"isForwarded\", if (envelope.isDefined) BooleanNode.TRUE else BooleanNode.FALSE)\n+    node.set(\"forwardedRequest\", envelope.map(request => requestContextNode(request.context)).getOrElse(new TextNode(\"\")))\n+    node.set(\"requestHeader\", requestHeaderNode(header))\n+    node.set(\"request\", requestNode.getOrElse(new TextNode(\"\")))\n+    node\n+  }\n+\n+  def clientInfoNode(clientInfo: ClientInformation): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"softwareName\", new TextNode(clientInfo.softwareName))\n+    node.set(\"softwareVersion\", new TextNode(clientInfo.softwareVersion))\n+    node\n+  }\n+\n+  def topicPartitionNode(topicPartition: TopicPartition): JsonNode = {\n+    val node = new ObjectNode(JsonNodeFactory.instance)\n+    node.set(\"topic\", new TextNode(topicPartition.topic))\n+    node.set(\"partition\", new IntNode(topicPartition.partition))\n+    node\n+  }\n+\n+  def requestDescMetrics(header: RequestHeader, requestNode: Option[JsonNode], responseNode: Option[JsonNode],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f176ffc29ed0da839df70c80e70a8a58cf7c5cf"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgxOTE2Mw==", "bodyText": "I wonder if we should name the field %sSizeInBytes. I just looked at the result and having \"records\":83 in the request log is not super clear to me.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r540819163", "createdAt": "2020-12-11T09:45:15Z", "author": {"login": "dajac"}, "path": "generator/src/main/java/org/apache/kafka/message/JsonConverterGenerator.java", "diffHunk": "@@ -377,11 +387,24 @@ private void generateVariableLengthTargetToJson(Target target, Versions versions\n                 headerGenerator.addImport(MessageGenerator.ARRAYS_CLASS);\n                 buffer.printf(\"%s;%n\", target.assignmentStatement(\n                     String.format(\"new BinaryNode(Arrays.copyOf(%s, %s.length))\",\n-                        target.sourceVariable(), target.sourceVariable())));\n+                            target.sourceVariable(), target.sourceVariable())));\n             }\n         } else if (target.field().type().isRecords()) {\n             headerGenerator.addImport(MessageGenerator.BINARY_NODE_CLASS);\n+            headerGenerator.addImport(MessageGenerator.INT_NODE_CLASS);\n+            // KIP-673: When logging requests/responses, we do not serialize the record, instead we\n+            // output its sizeInBytes, because outputting the bytes is not very useful and can be\n+            // quite expensive. Otherwise, we will serialize the record.\n+            buffer.printf(\"if (_serializeRecords) {%n\");\n+            buffer.incrementIndent();\n             buffer.printf(\"%s;%n\", target.assignmentStatement(\"new BinaryNode(new byte[]{})\"));\n+            buffer.decrementIndent();\n+            buffer.printf(\"} else {%n\");\n+            buffer.incrementIndent();\n+            buffer.printf(\"%s;%n\", target.assignmentStatement(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f176ffc29ed0da839df70c80e70a8a58cf7c5cf"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea", "committedDate": "2020-12-11T20:04:10Z", "message": "rebase and address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9f176ffc29ed0da839df70c80e70a8a58cf7c5cf", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/9f176ffc29ed0da839df70c80e70a8a58cf7c5cf", "committedDate": "2020-12-11T02:28:21Z", "message": "remove special handling for ProduceRequest"}, "afterCommit": {"oid": "97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea", "committedDate": "2020-12-11T20:04:10Z", "message": "rebase and address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUxMjcxMTQ5", "url": "https://github.com/apache/kafka/pull/9526#pullrequestreview-551271149", "createdAt": "2020-12-14T11:16:14Z", "commit": {"oid": "97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMToxNjoxNFrOIFLr4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMToyODowNFrOIFMHsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwNTI0OQ==", "bodyText": "Would something like the following work?\nbuffer.printf(\"_node.set(\\\"%sSizeInBytes\\\", new IntNode(%s.sizeInBytes()));%n\",\n  target.field().camelCaseName(),\n  target.sourceVariable());", "url": "https://github.com/apache/kafka/pull/9526#discussion_r542305249", "createdAt": "2020-12-14T11:16:14Z", "author": {"login": "dajac"}, "path": "generator/src/main/java/org/apache/kafka/message/JsonConverterGenerator.java", "diffHunk": "@@ -377,11 +387,24 @@ private void generateVariableLengthTargetToJson(Target target, Versions versions\n                 headerGenerator.addImport(MessageGenerator.ARRAYS_CLASS);\n                 buffer.printf(\"%s;%n\", target.assignmentStatement(\n                     String.format(\"new BinaryNode(Arrays.copyOf(%s, %s.length))\",\n-                        target.sourceVariable(), target.sourceVariable())));\n+                            target.sourceVariable(), target.sourceVariable())));\n             }\n         } else if (target.field().type().isRecords()) {\n             headerGenerator.addImport(MessageGenerator.BINARY_NODE_CLASS);\n+            headerGenerator.addImport(MessageGenerator.INT_NODE_CLASS);\n+            // KIP-673: When logging requests/responses, we do not serialize the record, instead we\n+            // output its sizeInBytes, because outputting the bytes is not very useful and can be\n+            // quite expensive. Otherwise, we will serialize the record.\n+            buffer.printf(\"if (_serializeRecords) {%n\");\n+            buffer.incrementIndent();\n             buffer.printf(\"%s;%n\", target.assignmentStatement(\"new BinaryNode(new byte[]{})\"));\n+            buffer.decrementIndent();\n+            buffer.printf(\"} else {%n\");\n+            buffer.incrementIndent();\n+            buffer.printf(\"%s;%n\", target.assignmentStatement(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDgxOTE2Mw=="}, "originalCommit": {"oid": "9f176ffc29ed0da839df70c80e70a8a58cf7c5cf"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwNTkxMg==", "bodyText": "This is likely a mistake.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r542305912", "createdAt": "2020-12-14T11:17:14Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -97,7 +98,8 @@ import scala.annotation.nowarn\n /**\n  * Logic to handle the various Kafka requests\n  */\n-class KafkaApis(val requestChannel: RequestChannel,\n+class\n+KafkaApis(val requestChannel: RequestChannel,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwODMwOA==", "bodyText": "nit: context.apiVersion() -> context.apiVersion", "url": "https://github.com/apache/kafka/pull/9526#discussion_r542308308", "createdAt": "2020-12-14T11:21:10Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestChannel.scala", "diffHunk": "@@ -123,9 +131,9 @@ object RequestChannel extends Logging {\n       }\n     }\n \n-    def responseString(response: AbstractResponse): Option[String] = {\n+    def responseNode(response: AbstractResponse): Option[JsonNode] = {\n       if (RequestChannel.isRequestLoggingEnabled)\n-        Some(response.toString)\n+        Some(RequestConvertToJson.response(response, context.apiVersion()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwOTA3Mg==", "bodyText": "As discussed offline, I think that we should revert this one. We want to use JSON in the request log (aka requestLogger), not as a replacement of all the toString usages.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r542309072", "createdAt": "2020-12-14T11:22:22Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestChannel.scala", "diffHunk": "@@ -200,7 +208,7 @@ object RequestChannel extends Logging {\n       }\n     }\n \n-    trace(s\"Processor $processor received request: ${requestDesc(true)}\")\n+    trace(s\"Processor $processor received request: ${RequestConvertToJson.requestDesc(header, requestLog, isForwarded)}\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMwOTYzMA==", "bodyText": "It seems that this one is not used anymore.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r542309630", "createdAt": "2020-12-14T11:23:18Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/RequestConvertToJson.scala", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import com.fasterxml.jackson.databind.JsonNode\n+import com.fasterxml.jackson.databind.node.{BooleanNode, DoubleNode, JsonNodeFactory, LongNode, ObjectNode, TextNode}\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.ClientInformation\n+import org.apache.kafka.common.requests._\n+\n+object RequestConvertToJson {\n+  def request(request: AbstractRequest): JsonNode = {\n+    request match {\n+      case req: AddOffsetsToTxnRequest => AddOffsetsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AddPartitionsToTxnRequest => AddPartitionsToTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterClientQuotasRequest => AlterClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterConfigsRequest => AlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterIsrRequest => AlterIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterPartitionReassignmentsRequest => AlterPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: AlterReplicaLogDirsRequest => AlterReplicaLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case res: AlterUserScramCredentialsRequest => AlterUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ApiVersionsRequest => ApiVersionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: BeginQuorumEpochRequest => BeginQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ControlledShutdownRequest => ControlledShutdownRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateAclsRequest => CreateAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateDelegationTokenRequest => CreateDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreatePartitionsRequest => CreatePartitionsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: CreateTopicsRequest => CreateTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteAclsRequest => DeleteAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteGroupsRequest => DeleteGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteRecordsRequest => DeleteRecordsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DeleteTopicsRequest => DeleteTopicsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeAclsRequest => DescribeAclsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeClientQuotasRequest => DescribeClientQuotasRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeConfigsRequest => DescribeConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeDelegationTokenRequest => DescribeDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeGroupsRequest => DescribeGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeLogDirsRequest => DescribeLogDirsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: DescribeQuorumRequest => DescribeQuorumRequestDataJsonConverter.write(req.data, request.version)\n+      case res: DescribeUserScramCredentialsRequest => DescribeUserScramCredentialsRequestDataJsonConverter.write(res.data, request.version)\n+      case req: ElectLeadersRequest => ElectLeadersRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndTxnRequest => EndTxnRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EndQuorumEpochRequest => EndQuorumEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: EnvelopeRequest => EnvelopeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ExpireDelegationTokenRequest => ExpireDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FetchRequest => FetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: FindCoordinatorRequest => FindCoordinatorRequestDataJsonConverter.write(req.data, request.version)\n+      case req: HeartbeatRequest => HeartbeatRequestDataJsonConverter.write(req.data, request.version)\n+      case req: IncrementalAlterConfigsRequest => IncrementalAlterConfigsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: InitProducerIdRequest => InitProducerIdRequestDataJsonConverter.write(req.data, request.version)\n+      case req: JoinGroupRequest => JoinGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaderAndIsrRequest => LeaderAndIsrRequestDataJsonConverter.write(req.data, request.version)\n+      case req: LeaveGroupRequest => LeaveGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListGroupsRequest => ListGroupsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListOffsetRequest => ListOffsetRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ListPartitionReassignmentsRequest => ListPartitionReassignmentsRequestDataJsonConverter.write(req.data, request.version)\n+      case req: MetadataRequest => MetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetCommitRequest => OffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetDeleteRequest => OffsetDeleteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetFetchRequest => OffsetFetchRequestDataJsonConverter.write(req.data, request.version)\n+      case req: OffsetsForLeaderEpochRequest => OffsetForLeaderEpochRequestDataJsonConverter.write(req.data, request.version)\n+      case req: ProduceRequest => ProduceRequestDataJsonConverter.write(req.data, request.version, false)\n+      case req: RenewDelegationTokenRequest => RenewDelegationTokenRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslAuthenticateRequest => SaslAuthenticateRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SaslHandshakeRequest => SaslHandshakeRequestDataJsonConverter.write(req.data, request.version)\n+      case req: StopReplicaRequest => StopReplicaRequestDataJsonConverter.write(req.data, request.version)\n+      case req: SyncGroupRequest => SyncGroupRequestDataJsonConverter.write(req.data, request.version)\n+      case req: TxnOffsetCommitRequest => TxnOffsetCommitRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateFeaturesRequest => UpdateFeaturesRequestDataJsonConverter.write(req.data, request.version)\n+      case req: UpdateMetadataRequest => UpdateMetadataRequestDataJsonConverter.write(req.data, request.version)\n+      case req: VoteRequest => VoteRequestDataJsonConverter.write(req.data, request.version)\n+      case req: WriteTxnMarkersRequest => WriteTxnMarkersRequestDataJsonConverter.write(req.data, request.version)\n+      case _ => throw new IllegalStateException(s\"ApiKey ${request.apiKey} is not currently handled in `request`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def response(response: AbstractResponse, version: Short): JsonNode = {\n+    response match {\n+      case res: AddOffsetsToTxnResponse => AddOffsetsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AddPartitionsToTxnResponse => AddPartitionsToTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterClientQuotasResponse => AlterClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterConfigsResponse => AlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterIsrResponse => AlterIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterPartitionReassignmentsResponse => AlterPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterReplicaLogDirsResponse => AlterReplicaLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: AlterUserScramCredentialsResponse => AlterUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ApiVersionsResponse => ApiVersionsResponseDataJsonConverter.write(res.data, version)\n+      case res: BeginQuorumEpochResponse => BeginQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ControlledShutdownResponse => ControlledShutdownResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateAclsResponse => CreateAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateDelegationTokenResponse => CreateDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: CreatePartitionsResponse => CreatePartitionsResponseDataJsonConverter.write(res.data, version)\n+      case res: CreateTopicsResponse => CreateTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteAclsResponse => DeleteAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteGroupsResponse => DeleteGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteRecordsResponse => DeleteRecordsResponseDataJsonConverter.write(res.data, version)\n+      case res: DeleteTopicsResponse => DeleteTopicsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeAclsResponse => DescribeAclsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeClientQuotasResponse => DescribeClientQuotasResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeConfigsResponse => DescribeConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeDelegationTokenResponse => DescribeDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeGroupsResponse => DescribeGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeLogDirsResponse => DescribeLogDirsResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeQuorumResponse => DescribeQuorumResponseDataJsonConverter.write(res.data, version)\n+      case res: DescribeUserScramCredentialsResponse => DescribeUserScramCredentialsResponseDataJsonConverter.write(res.data, version)\n+      case res: ElectLeadersResponse => ElectLeadersResponseDataJsonConverter.write(res.data, version)\n+      case res: EndTxnResponse => EndTxnResponseDataJsonConverter.write(res.data, version)\n+      case res: EndQuorumEpochResponse => EndQuorumEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: EnvelopeResponse => EnvelopeResponseDataJsonConverter.write(res.data, version)\n+      case res: ExpireDelegationTokenResponse => ExpireDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: FetchResponse[_] => FetchResponseDataJsonConverter.write(res.data, version, false)\n+      case res: FindCoordinatorResponse => FindCoordinatorResponseDataJsonConverter.write(res.data, version)\n+      case res: HeartbeatResponse => HeartbeatResponseDataJsonConverter.write(res.data, version)\n+      case res: IncrementalAlterConfigsResponse => IncrementalAlterConfigsResponseDataJsonConverter.write(res.data, version)\n+      case res: InitProducerIdResponse => InitProducerIdResponseDataJsonConverter.write(res.data, version)\n+      case res: JoinGroupResponse => JoinGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaderAndIsrResponse => LeaderAndIsrResponseDataJsonConverter.write(res.data, version)\n+      case res: LeaveGroupResponse => LeaveGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: ListGroupsResponse => ListGroupsResponseDataJsonConverter.write(res.data, version)\n+      case res: ListOffsetResponse => ListOffsetResponseDataJsonConverter.write(res.data, version)\n+      case res: ListPartitionReassignmentsResponse => ListPartitionReassignmentsResponseDataJsonConverter.write(res.data, version)\n+      case res: MetadataResponse => MetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetCommitResponse => OffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetDeleteResponse => OffsetDeleteResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetFetchResponse => OffsetFetchResponseDataJsonConverter.write(res.data, version)\n+      case res: OffsetsForLeaderEpochResponse => OffsetForLeaderEpochResponseDataJsonConverter.write(res.data, version)\n+      case res: ProduceResponse => ProduceResponseDataJsonConverter.write(res.data, version)\n+      case res: RenewDelegationTokenResponse => RenewDelegationTokenResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslAuthenticateResponse => SaslAuthenticateResponseDataJsonConverter.write(res.data, version)\n+      case res: SaslHandshakeResponse => SaslHandshakeResponseDataJsonConverter.write(res.data, version)\n+      case res: StopReplicaResponse => StopReplicaResponseDataJsonConverter.write(res.data, version)\n+      case res: SyncGroupResponse => SyncGroupResponseDataJsonConverter.write(res.data, version)\n+      case res: TxnOffsetCommitResponse => TxnOffsetCommitResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateFeaturesResponse => UpdateFeaturesResponseDataJsonConverter.write(res.data, version)\n+      case res: UpdateMetadataResponse => UpdateMetadataResponseDataJsonConverter.write(res.data, version)\n+      case res: WriteTxnMarkersResponse => WriteTxnMarkersResponseDataJsonConverter.write(res.data, version)\n+      case res: VoteResponse => VoteResponseDataJsonConverter.write(res.data, version)\n+      case _ => throw new IllegalStateException(s\"ApiKey ${response.apiKey} is not currently handled in `response`, the \" +\n+        \"code should be updated to do so.\");\n+    }\n+  }\n+\n+  def requestHeaderNode(header: RequestHeader): JsonNode = {\n+    val node = RequestHeaderDataJsonConverter.write(header.data, header.headerVersion, false).asInstanceOf[ObjectNode]\n+    node.set(\"requestApiKeyName\", new TextNode(header.apiKey.toString))\n+    node\n+  }\n+\n+  def requestContextNode(context: RequestContext): JsonNode = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMxMDM3MA==", "bodyText": "We should also revert this one.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r542310370", "createdAt": "2020-12-14T11:24:36Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -183,7 +185,8 @@ class KafkaApis(val requestChannel: RequestChannel,\n    */\n   override def handle(request: RequestChannel.Request): Unit = {\n     try {\n-      trace(s\"Handling request:${request.requestDesc(true)} from connection ${request.context.connectionId};\" +\n+      trace(s\"Handling request:${RequestConvertToJson.requestDesc(request.header, request.requestLog, request.isForwarded)} \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMxMDUxMw==", "bodyText": "We should also revert this one.", "url": "https://github.com/apache/kafka/pull/9526#discussion_r542310513", "createdAt": "2020-12-14T11:24:48Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/tools/TestRaftRequestHandler.scala", "diffHunk": "@@ -39,7 +40,8 @@ class TestRaftRequestHandler(\n \n   override def handle(request: RequestChannel.Request): Unit = {\n     try {\n-      trace(s\"Handling request:${request.requestDesc(true)} from connection ${request.context.connectionId};\" +\n+      trace(s\"Handling request:${RequestConvertToJson.requestDesc(request.header, request.requestLog, request.isForwarded)} \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMxMjM2OQ==", "bodyText": "Could we also add unit tests for RequestConvertToJson.requestDesc, RequestConvertToJson.requestHeaderNode and RequestConvertToJson.clientInfoNode?", "url": "https://github.com/apache/kafka/pull/9526#discussion_r542312369", "createdAt": "2020-12-14T11:28:04Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/network/RequestConvertToJsonTest.scala", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.network\n+\n+import java.net.InetAddress\n+import java.nio.ByteBuffer\n+\n+import com.fasterxml.jackson.databind.node.{DoubleNode, LongNode, ObjectNode, TextNode}\n+import kafka.network\n+import org.apache.kafka.common.memory.MemoryPool\n+import org.apache.kafka.common.message._\n+import org.apache.kafka.common.network.{ClientInformation, ListenerName, NetworkSend}\n+import org.junit.Test\n+import org.apache.kafka.common.protocol.{ApiKeys, ByteBufferAccessor, ObjectSerializationCache}\n+import org.apache.kafka.common.requests._\n+import org.apache.kafka.common.security.auth.{KafkaPrincipal, SecurityProtocol}\n+import org.easymock.EasyMock.createNiceMock\n+import org.junit.Assert.assertEquals\n+\n+import scala.collection.mutable.ArrayBuffer\n+\n+class RequestConvertToJsonTest {\n+\n+  @Test\n+  def testAllRequestTypesHandled(): Unit = {\n+    val unhandledKeys = ArrayBuffer[String]()\n+    ApiKeys.values().foreach { key => {\n+      val version: Short = key.latestVersion()\n+      val cache = new ObjectSerializationCache\n+      val message = key match {\n+        case ApiKeys.DESCRIBE_ACLS =>\n+          ApiMessageType.fromApiKey(key.id).newRequest().asInstanceOf[DescribeAclsRequestData]\n+            .setPatternTypeFilter(1).setResourceTypeFilter(1).setPermissionType(1).setOperation(1)\n+        case _ =>\n+          ApiMessageType.fromApiKey(key.id).newRequest()\n+      }\n+      val messageSize = message.size(cache, version)\n+      val bytes = new ByteBufferAccessor(ByteBuffer.allocate(messageSize))\n+      message.write(bytes, cache, version)\n+      bytes.flip()\n+\n+      val req = AbstractRequest.parseRequest(key, version, bytes.buffer).request\n+      try {\n+        RequestConvertToJson.request(req)\n+      } catch {\n+        case _ : IllegalStateException => unhandledKeys += key.toString\n+      }\n+    }}\n+    assertEquals(\"Unhandled request keys\", ArrayBuffer.empty, unhandledKeys)\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "97072bbaeba0b5dde308ac5dfb414ef7c2d1ddea"}, "originalPosition": 66}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fc3a11ca54b9958c1ef20fbca9abb4606ecbdd0", "author": {"user": {"login": "anatasiavela", "name": "Anastasia Vela"}}, "url": "https://github.com/apache/kafka/commit/1fc3a11ca54b9958c1ef20fbca9abb4606ecbdd0", "committedDate": "2020-12-14T17:59:50Z", "message": "address minor comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyNDQ0NDc3", "url": "https://github.com/apache/kafka/pull/9526#pullrequestreview-552444477", "createdAt": "2020-12-15T13:25:01Z", "commit": {"oid": "1fc3a11ca54b9958c1ef20fbca9abb4606ecbdd0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2629, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}