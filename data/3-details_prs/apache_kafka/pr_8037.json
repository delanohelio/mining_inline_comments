{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwNjY1NzEx", "number": 8037, "title": "KAFKA-9491; Increment high watermark after full log truncation", "bodyText": "When a follower's fetch offset is behind the leader's log start offset, the follower will do a full log truncation. When it does so, it must update both its log start offset and high watermark. The previous code did the former, but not the latter. Failure to update the high watermark in this case can lead to out of range errors if the follower becomes leader before getting the latest high watermark from the previous leader. The out of range errors occur when we attempt to resolve the log position of the high watermark in DelayedFetch in order to determine if a fetch is satisfied.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-02-04T06:19:51Z", "url": "https://github.com/apache/kafka/pull/8037", "merged": true, "mergeCommit": {"oid": "b029902b129333f0bafa2d0776cc827004e2532b"}, "closed": true, "closedAt": "2020-02-04T19:22:34Z", "author": {"login": "hachikuji"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcA7WtQgH2gAyMzcwNjY1NzExOjhjNWI5Nzc4MTMwODQ2NjFjMDcxYWQ4MjNlM2U3ZTU1NTVjMGNhNWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcBFMsmAFqTM1MzE3MzM1Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8c5b977813084661c071ad823e3e7e5555c0ca5a", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/8c5b977813084661c071ad823e3e7e5555c0ca5a", "committedDate": "2020-02-04T06:15:17Z", "message": "KAFKA-9491; Increment high watermark after full log truncation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNzg0MDkx", "url": "https://github.com/apache/kafka/pull/8037#pullrequestreview-352784091", "createdAt": "2020-02-04T08:10:07Z", "commit": {"oid": "8c5b977813084661c071ad823e3e7e5555c0ca5a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwODoxMDowN1rOFlLGIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwODoxMDowN1rOFlLGIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUyMzQyNA==", "bodyText": "Is there a case that recoveryPoint gets smaller than logStartOffset? If yes, is it ok to just move the recoveryPoint without flush? If not, is it worthy to throw exception or log this weird case?", "url": "https://github.com/apache/kafka/pull/8037#discussion_r374523424", "createdAt": "2020-02-04T08:10:07Z", "author": {"login": "chia7712"}, "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -721,14 +721,30 @@ class Log(@volatile var dir: File,\n     }\n   }\n \n-  private def updateLogEndOffset(messageOffset: Long): Unit = {\n-    nextOffsetMetadata = LogOffsetMetadata(messageOffset, activeSegment.baseOffset, activeSegment.size)\n+  private def updateLogEndOffset(offset: Long): Unit = {\n+    nextOffsetMetadata = LogOffsetMetadata(offset, activeSegment.baseOffset, activeSegment.size)\n \n     // Update the high watermark in case it has gotten ahead of the log end offset following a truncation\n     // or if a new segment has been rolled and the offset metadata needs to be updated.\n-    if (highWatermark >= messageOffset) {\n+    if (highWatermark >= offset) {\n       updateHighWatermarkMetadata(nextOffsetMetadata)\n     }\n+\n+    if (this.recoveryPoint > offset) {\n+      this.recoveryPoint = offset\n+    }\n+  }\n+\n+  private def updateLogStartOffset(offset: Long): Unit = {\n+    logStartOffset = offset\n+\n+    if (highWatermark < offset) {\n+      updateHighWatermark(offset)\n+    }\n+\n+    if (this.recoveryPoint < offset) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c5b977813084661c071ad823e3e7e5555c0ca5a"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyOTA2ODQx", "url": "https://github.com/apache/kafka/pull/8037#pullrequestreview-352906841", "createdAt": "2020-02-04T11:32:36Z", "commit": {"oid": "8c5b977813084661c071ad823e3e7e5555c0ca5a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMDMzMTY0", "url": "https://github.com/apache/kafka/pull/8037#pullrequestreview-353033164", "createdAt": "2020-02-04T14:48:36Z", "commit": {"oid": "8c5b977813084661c071ad823e3e7e5555c0ca5a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNDo0ODozNlrOFlWuYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNDo0ODozNlrOFlWuYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcxMzk1Mw==", "bodyText": "resetLastCaughtUpTime takes curLeaderLogEndOffset, but we are now passing leaderEpochStartOffset. Do we need to update the parameter name of that method?", "url": "https://github.com/apache/kafka/pull/8037#discussion_r374713953", "createdAt": "2020-02-04T14:48:36Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/cluster/Partition.scala", "diffHunk": "@@ -506,12 +507,11 @@ class Partition(val topicPartition: TopicPartition,\n       leaderLog.maybeAssignEpochStartOffset(leaderEpoch, leaderEpochStartOffset)\n \n       val isNewLeader = !isLeader\n-      val curLeaderLogEndOffset = leaderLog.logEndOffset\n       val curTimeMs = time.milliseconds\n       // initialize lastCaughtUpTime of replicas as well as their lastFetchTimeMs and lastFetchLeaderLogEndOffset.\n       remoteReplicas.foreach { replica =>\n         val lastCaughtUpTimeMs = if (inSyncReplicaIds.contains(replica.brokerId)) curTimeMs else 0L\n-        replica.resetLastCaughtUpTime(curLeaderLogEndOffset, curTimeMs, lastCaughtUpTimeMs)\n+        replica.resetLastCaughtUpTime(leaderEpochStartOffset, curTimeMs, lastCaughtUpTimeMs)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c5b977813084661c071ad823e3e7e5555c0ca5a"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMTczMzUy", "url": "https://github.com/apache/kafka/pull/8037#pullrequestreview-353173352", "createdAt": "2020-02-04T17:43:20Z", "commit": {"oid": "8c5b977813084661c071ad823e3e7e5555c0ca5a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNzo0MzoyMFrOFldVNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNzo0MzoyMFrOFldVNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgyMjE5OQ==", "bodyText": "Previous behavior is recoveryPoint = math.min(newOffset, recoveryPoint)) but this patch changes it to\nif (this.recoveryPoint < offset) {\n  this.recoveryPoint = offset\n}\n\nwhich is equal to recoveryPoint = math.max(newOffset, recoveryPoint)). Is it a bug?", "url": "https://github.com/apache/kafka/pull/8037#discussion_r374822199", "createdAt": "2020-02-04T17:43:20Z", "author": {"login": "chia7712"}, "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -2081,9 +2096,7 @@ class Log(@volatile var dir: File,\n         producerStateManager.truncate()\n         producerStateManager.updateMapEndOffset(newOffset)\n         maybeIncrementFirstUnstableOffset()\n-\n-        this.recoveryPoint = math.min(newOffset, this.recoveryPoint)\n-        this.logStartOffset = newOffset\n+        updateLogStartOffset(newOffset)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c5b977813084661c071ad823e3e7e5555c0ca5a"}, "originalPosition": 69}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1718, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}