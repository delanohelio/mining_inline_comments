{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNTU2MjQ5", "number": 9435, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNzozOToyM1rOEwHQBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToxNzo0NlrOFATctQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODg1ODkzOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNzozOToyM1rOHleSRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMTozNjo0MVrOHyPSaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1NTU1OQ==", "bodyText": "If we pass false to getTopicMetadata, it generates UNKNOWN_TOPIC_OR_PARTITION when the topic is removed, right? If so, does client-side need to handle such error? For example, KafkaAdminClient#listTopics should filter out those \"nonexistent\" topics (https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L1717). Otherwise, users want to get all \"existent\" topics but response say a_topic is \"nonexistent\".", "url": "https://github.com/apache/kafka/pull/9435#discussion_r509055559", "createdAt": "2020-10-21T07:39:23Z", "author": {"login": "chia7712"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1236,9 +1236,19 @@ class KafkaApis(val requestChannel: RequestChannel,\n     val topicMetadata =\n       if (authorizedTopics.isEmpty)\n         Seq.empty[MetadataResponseTopic]\n-      else\n-        getTopicMetadata(metadataRequest.allowAutoTopicCreation, authorizedTopics, request.context.listenerName,\n-          errorUnavailableEndpoints, errorUnavailableListeners)\n+      else {\n+        // KAFKA-10606: If this request is to get metadata for all topics, auto topic creation should not be allowed\n+        // The special handling is necessary on broker side because allowAutoTopicCreation is hard coded to true\n+        // for backward compatibility on client side.\n+        val allowAutoTopicCreation = (!metadataRequest.isAllTopics) && metadataRequest.allowAutoTopicCreation", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ0MTMyMQ==", "bodyText": "Hi @chia7712 , thank you for bringing up this issue and it's totally valid!\nIn order to preserve its behavior (not including UNKNOWN_TOPIC_OR_PARTITION  in the response to fetch all topic metadata request), we implemented the below logic which filters out all entries in the response with UNKNOWN_TOPIC_OR_PARTITION  if the metadata request is to get metadata for all topisc.\nval completeTopicMetadata = (if (metadataRequest.isAllTopics) {\n    opicMetadata.filter(_.errorCode() != Errors.UNKNOWN_TOPIC_OR_PARTITION.code())\n} else {\n    topicMetadata\n}) ++ unauthorizedForCreateTopicMetadata ++ unauthorizedForDescribeTopicMetadata\n\nWe have added a unit test as well. Hope to get some feedback from you soon!", "url": "https://github.com/apache/kafka/pull/9435#discussion_r522441321", "createdAt": "2020-11-12T21:36:41Z", "author": {"login": "Lincong"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1236,9 +1236,19 @@ class KafkaApis(val requestChannel: RequestChannel,\n     val topicMetadata =\n       if (authorizedTopics.isEmpty)\n         Seq.empty[MetadataResponseTopic]\n-      else\n-        getTopicMetadata(metadataRequest.allowAutoTopicCreation, authorizedTopics, request.context.listenerName,\n-          errorUnavailableEndpoints, errorUnavailableListeners)\n+      else {\n+        // KAFKA-10606: If this request is to get metadata for all topics, auto topic creation should not be allowed\n+        // The special handling is necessary on broker side because allowAutoTopicCreation is hard coded to true\n+        // for backward compatibility on client side.\n+        val allowAutoTopicCreation = (!metadataRequest.isAllTopics) && metadataRequest.allowAutoTopicCreation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA1NTU1OQ=="}, "originalCommit": null, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTg2NDg2OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNjoxMjoxOVrOH2OICA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMDozNDo0MFrOH5tGKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYxNjU4NA==", "bodyText": "Could we do this filter early? For example, how about filtering getTopicMetadata directly? That makes all fixes be in one place and following authorized ops can skip \"unknown partition/topic\" as well.", "url": "https://github.com/apache/kafka/pull/9435#discussion_r526616584", "createdAt": "2020-11-19T06:12:19Z", "author": {"login": "chia7712"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1333,7 +1343,17 @@ class KafkaApis(val requestChannel: RequestChannel,\n       }\n     }\n \n-    val completeTopicMetadata = topicMetadata ++ unauthorizedForCreateTopicMetadata ++ unauthorizedForDescribeTopicMetadata\n+    val completeTopicMetadata = (if (metadataRequest.isAllTopics) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjkxMTIwMA==", "bodyText": "This is a good point. We should pass a boolean to getTopicMetadata indicating that it's an \"allTopics\" request and have that method handle everything.", "url": "https://github.com/apache/kafka/pull/9435#discussion_r526911200", "createdAt": "2020-11-19T14:04:34Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1333,7 +1343,17 @@ class KafkaApis(val requestChannel: RequestChannel,\n       }\n     }\n \n-    val completeTopicMetadata = topicMetadata ++ unauthorizedForCreateTopicMetadata ++ unauthorizedForDescribeTopicMetadata\n+    val completeTopicMetadata = (if (metadataRequest.isAllTopics) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYxNjU4NA=="}, "originalCommit": null, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5MjgwMg==", "bodyText": "Hi @chia7712 @ijuma ,\nThis is Joseph and I'm @Lincong 's colleague working on this patch with him.  I think this is a good point and just updated the PR accordingly", "url": "https://github.com/apache/kafka/pull/9435#discussion_r527192802", "createdAt": "2020-11-19T20:56:27Z", "author": {"login": "lmr3796"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1333,7 +1343,17 @@ class KafkaApis(val requestChannel: RequestChannel,\n       }\n     }\n \n-    val completeTopicMetadata = topicMetadata ++ unauthorizedForCreateTopicMetadata ++ unauthorizedForDescribeTopicMetadata\n+    val completeTopicMetadata = (if (metadataRequest.isAllTopics) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYxNjU4NA=="}, "originalCommit": null, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI2OTczNw==", "bodyText": "@ijuma I will merge this PR tomorrow if there is no objection.", "url": "https://github.com/apache/kafka/pull/9435#discussion_r530269737", "createdAt": "2020-11-25T10:34:40Z", "author": {"login": "chia7712"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1333,7 +1343,17 @@ class KafkaApis(val requestChannel: RequestChannel,\n       }\n     }\n \n-    val completeTopicMetadata = topicMetadata ++ unauthorizedForCreateTopicMetadata ++ unauthorizedForDescribeTopicMetadata\n+    val completeTopicMetadata = (if (metadataRequest.isAllTopics) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYxNjU4NA=="}, "originalCommit": null, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxNTAwOTM1OnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yM1QxMDowMDoyOFrOH4GUKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNjo0NDoyNlrOH5lJHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU4NTc2OA==", "bodyText": "Could we remove this @Before code? Changing modifier of metadataCache from \"val\" to \"var\" is enough.", "url": "https://github.com/apache/kafka/pull/9435#discussion_r528585768", "createdAt": "2020-11-23T10:00:28Z", "author": {"login": "chia7712"}, "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -107,6 +108,11 @@ class KafkaApisTest {\n   private val time = new MockTime\n   private val clientId = \"\"\n \n+  @Before\n+  def setUp(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwMzY1Mg==", "bodyText": "hey @chia7712 ,\nI add this to let each test case to have a clean, uncorrupted MetadataCache.  Is there any historical context that we should avoid that cleanup?", "url": "https://github.com/apache/kafka/pull/9435#discussion_r529203652", "createdAt": "2020-11-24T04:59:33Z", "author": {"login": "lmr3796"}, "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -107,6 +108,11 @@ class KafkaApisTest {\n   private val time = new MockTime\n   private val clientId = \"\"\n \n+  @Before\n+  def setUp(): Unit = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU4NTc2OA=="}, "originalCommit": null, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI0MDcxMQ==", "bodyText": "It seems to me following code is able to generate a clean, uncorrupted MetadataCache for each test case.\nvar metadataCache = new MetadataCache(brokerId)\n\nAlso, it is simpler than @Before block.", "url": "https://github.com/apache/kafka/pull/9435#discussion_r529240711", "createdAt": "2020-11-24T06:57:27Z", "author": {"login": "chia7712"}, "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -107,6 +108,11 @@ class KafkaApisTest {\n   private val time = new MockTime\n   private val clientId = \"\"\n \n+  @Before\n+  def setUp(): Unit = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU4NTc2OA=="}, "originalCommit": null, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEzOTQyMA==", "bodyText": "Hey @chia7712 you're right.  I did some reading and found that I misunderstood JUnit's behavior.  Just updated that part and rebased latest trunk.", "url": "https://github.com/apache/kafka/pull/9435#discussion_r530139420", "createdAt": "2020-11-25T06:44:26Z", "author": {"login": "lmr3796"}, "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -107,6 +108,11 @@ class KafkaApisTest {\n   private val time = new MockTime\n   private val clientId = \"\"\n \n+  @Before\n+  def setUp(): Unit = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODU4NTc2OA=="}, "originalCommit": null, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNjg0MzExOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNToxMjoxMlrOH5329A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxODo1ODoyNlrOH87WXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ0NjA2OA==", "bodyText": "Could we not avoid this altogether instead of doing the filter later?", "url": "https://github.com/apache/kafka/pull/9435#discussion_r530446068", "createdAt": "2020-11-25T15:12:12Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1250,13 +1251,23 @@ class KafkaApis(val requestChannel: RequestChannel,\n             metadataResponseTopic(Errors.INVALID_REPLICATION_FACTOR, topic, true, util.Collections.emptyList())\n           else\n             topicMetadata\n-        } else if (allowAutoTopicCreation && config.autoCreateTopicsEnable) {\n+        } else if (!isFetchAllMetadata && allowAutoTopicCreation && config.autoCreateTopicsEnable) {\n+          // KAFKA-10606: If this request is to get metadata for all topics, auto topic creation should not be allowed\n+          // The special handling is necessary on broker side because allowAutoTopicCreation is hard coded to true\n+          // for backward compatibility on client side.\n           createTopic(topic, config.numPartitions, config.defaultReplicationFactor)\n         } else {\n           metadataResponseTopic(Errors.UNKNOWN_TOPIC_OR_PARTITION, topic, false, util.Collections.emptyList())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE1MzYzNA==", "bodyText": "@ijuma I slightly changed it (and rebased latest) so the processing is a branch in the middle about isFetchAllMetadata.\nIt's still a map and filter structure because I don't want to sacrifice the readability, but it's handled in the middle instead of at the returning statement, which I think is more elegant and readable than the original version.\nLet me know what you think!", "url": "https://github.com/apache/kafka/pull/9435#discussion_r533153634", "createdAt": "2020-12-01T08:31:34Z", "author": {"login": "lmr3796"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1250,13 +1251,23 @@ class KafkaApis(val requestChannel: RequestChannel,\n             metadataResponseTopic(Errors.INVALID_REPLICATION_FACTOR, topic, true, util.Collections.emptyList())\n           else\n             topicMetadata\n-        } else if (allowAutoTopicCreation && config.autoCreateTopicsEnable) {\n+        } else if (!isFetchAllMetadata && allowAutoTopicCreation && config.autoCreateTopicsEnable) {\n+          // KAFKA-10606: If this request is to get metadata for all topics, auto topic creation should not be allowed\n+          // The special handling is necessary on broker side because allowAutoTopicCreation is hard coded to true\n+          // for backward compatibility on client side.\n           createTopic(topic, config.numPartitions, config.defaultReplicationFactor)\n         } else {\n           metadataResponseTopic(Errors.UNKNOWN_TOPIC_OR_PARTITION, topic, false, util.Collections.emptyList())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ0NjA2OA=="}, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE1NDA2Nw==", "bodyText": "Also, I added the assertion of no UNKNOWN_TOPIC_OR_PARTITION into the unit test", "url": "https://github.com/apache/kafka/pull/9435#discussion_r533154067", "createdAt": "2020-12-01T08:32:20Z", "author": {"login": "lmr3796"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1250,13 +1251,23 @@ class KafkaApis(val requestChannel: RequestChannel,\n             metadataResponseTopic(Errors.INVALID_REPLICATION_FACTOR, topic, true, util.Collections.emptyList())\n           else\n             topicMetadata\n-        } else if (allowAutoTopicCreation && config.autoCreateTopicsEnable) {\n+        } else if (!isFetchAllMetadata && allowAutoTopicCreation && config.autoCreateTopicsEnable) {\n+          // KAFKA-10606: If this request is to get metadata for all topics, auto topic creation should not be allowed\n+          // The special handling is necessary on broker side because allowAutoTopicCreation is hard coded to true\n+          // for backward compatibility on client side.\n           createTopic(topic, config.numPartitions, config.defaultReplicationFactor)\n         } else {\n           metadataResponseTopic(Errors.UNKNOWN_TOPIC_OR_PARTITION, topic, false, util.Collections.emptyList())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ0NjA2OA=="}, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQwMjg1Mg==", "bodyText": "I think if you use flatMap, you don't need the filter and it's still readable. Thoughts?", "url": "https://github.com/apache/kafka/pull/9435#discussion_r533402852", "createdAt": "2020-12-01T13:23:37Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1250,13 +1251,23 @@ class KafkaApis(val requestChannel: RequestChannel,\n             metadataResponseTopic(Errors.INVALID_REPLICATION_FACTOR, topic, true, util.Collections.emptyList())\n           else\n             topicMetadata\n-        } else if (allowAutoTopicCreation && config.autoCreateTopicsEnable) {\n+        } else if (!isFetchAllMetadata && allowAutoTopicCreation && config.autoCreateTopicsEnable) {\n+          // KAFKA-10606: If this request is to get metadata for all topics, auto topic creation should not be allowed\n+          // The special handling is necessary on broker side because allowAutoTopicCreation is hard coded to true\n+          // for backward compatibility on client side.\n           createTopic(topic, config.numPartitions, config.defaultReplicationFactor)\n         } else {\n           metadataResponseTopic(Errors.UNKNOWN_TOPIC_OR_PARTITION, topic, false, util.Collections.emptyList())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ0NjA2OA=="}, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY0ODk4OA==", "bodyText": "@ijuma That's a good point.  I've updated it.", "url": "https://github.com/apache/kafka/pull/9435#discussion_r533648988", "createdAt": "2020-12-01T18:58:26Z", "author": {"login": "lmr3796"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1250,13 +1251,23 @@ class KafkaApis(val requestChannel: RequestChannel,\n             metadataResponseTopic(Errors.INVALID_REPLICATION_FACTOR, topic, true, util.Collections.emptyList())\n           else\n             topicMetadata\n-        } else if (allowAutoTopicCreation && config.autoCreateTopicsEnable) {\n+        } else if (!isFetchAllMetadata && allowAutoTopicCreation && config.autoCreateTopicsEnable) {\n+          // KAFKA-10606: If this request is to get metadata for all topics, auto topic creation should not be allowed\n+          // The special handling is necessary on broker side because allowAutoTopicCreation is hard coded to true\n+          // for backward compatibility on client side.\n           createTopic(topic, config.numPartitions, config.defaultReplicationFactor)\n         } else {\n           metadataResponseTopic(Errors.UNKNOWN_TOPIC_OR_PARTITION, topic, false, util.Collections.emptyList())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ0NjA2OA=="}, "originalCommit": null, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1NTE4OTY1OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwNjo1MjoxNFrOH9-sRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QwOTo0NDo1OFrOH-PBIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDc1MjMyNg==", "bodyText": "Is Some/None more readable than List/Nil?", "url": "https://github.com/apache/kafka/pull/9435#discussion_r534752326", "createdAt": "2020-12-03T06:52:14Z", "author": {"login": "chia7712"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1243,19 +1244,30 @@ class KafkaApis(val requestChannel: RequestChannel,\n       topicResponses\n     } else {\n       val nonExistentTopics = topics.diff(topicResponses.map(_.name).toSet)\n-      val responsesForNonExistentTopics = nonExistentTopics.map { topic =>\n+      val responsesForNonExistentTopics = nonExistentTopics.flatMap { topic =>\n         if (isInternal(topic)) {\n           val topicMetadata = createInternalTopic(topic)\n-          if (topicMetadata.errorCode == Errors.COORDINATOR_NOT_AVAILABLE.code)\n-            metadataResponseTopic(Errors.INVALID_REPLICATION_FACTOR, topic, true, util.Collections.emptyList())\n-          else\n-            topicMetadata\n+          List(\n+            if (topicMetadata.errorCode == Errors.COORDINATOR_NOT_AVAILABLE.code)\n+              metadataResponseTopic(Errors.INVALID_REPLICATION_FACTOR, topic, true, util.Collections.emptyList())\n+            else\n+              topicMetadata\n+          )\n+        } else if (isFetchAllMetadata) {\n+          // KAFKA-10606: If this request is to get metadata for all topics, auto topic creation should not be allowed\n+          // The special handling is necessary on broker side because allowAutoTopicCreation is hard coded to true\n+          // for backward compatibility on client side.\n+          //\n+          // However, in previous versions, UNKNOWN_TOPIC_OR_PARTITION won't happen on fetch all metadata,\n+          // so, for backward-compatibility, we need to skip these not founds during fetch all metadata here.\n+          Nil", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f9de2566e79a6967e2615f59ededa14e930557"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTAxOTgxMA==", "bodyText": "@chia7712 Thanks, you're right.  Just updated accordingly and rebased latest trunk", "url": "https://github.com/apache/kafka/pull/9435#discussion_r535019810", "createdAt": "2020-12-03T09:44:58Z", "author": {"login": "lmr3796"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1243,19 +1244,30 @@ class KafkaApis(val requestChannel: RequestChannel,\n       topicResponses\n     } else {\n       val nonExistentTopics = topics.diff(topicResponses.map(_.name).toSet)\n-      val responsesForNonExistentTopics = nonExistentTopics.map { topic =>\n+      val responsesForNonExistentTopics = nonExistentTopics.flatMap { topic =>\n         if (isInternal(topic)) {\n           val topicMetadata = createInternalTopic(topic)\n-          if (topicMetadata.errorCode == Errors.COORDINATOR_NOT_AVAILABLE.code)\n-            metadataResponseTopic(Errors.INVALID_REPLICATION_FACTOR, topic, true, util.Collections.emptyList())\n-          else\n-            topicMetadata\n+          List(\n+            if (topicMetadata.errorCode == Errors.COORDINATOR_NOT_AVAILABLE.code)\n+              metadataResponseTopic(Errors.INVALID_REPLICATION_FACTOR, topic, true, util.Collections.emptyList())\n+            else\n+              topicMetadata\n+          )\n+        } else if (isFetchAllMetadata) {\n+          // KAFKA-10606: If this request is to get metadata for all topics, auto topic creation should not be allowed\n+          // The special handling is necessary on broker side because allowAutoTopicCreation is hard coded to true\n+          // for backward compatibility on client side.\n+          //\n+          // However, in previous versions, UNKNOWN_TOPIC_OR_PARTITION won't happen on fetch all metadata,\n+          // so, for backward-compatibility, we need to skip these not founds during fetch all metadata here.\n+          Nil", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDc1MjMyNg=="}, "originalCommit": {"oid": "38f9de2566e79a6967e2615f59ededa14e930557"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1ODYyOTY1OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToxNzo0NlrOH-hdcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODo0NDoxN1rOH-rtXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyMTk3MQ==", "bodyText": "We don't usually include JIRA references in the code unless it's a very complex issue. I think the comment here could be something like:\n\"A metadata request for all topics should never result in topic auto creation. A topic may be deleted between the creation of topics and topicResponses, so we make sure to always return None for this case.\"", "url": "https://github.com/apache/kafka/pull/9435#discussion_r535321971", "createdAt": "2020-12-03T15:17:46Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1243,19 +1244,30 @@ class KafkaApis(val requestChannel: RequestChannel,\n       topicResponses\n     } else {\n       val nonExistentTopics = topics.diff(topicResponses.map(_.name).toSet)\n-      val responsesForNonExistentTopics = nonExistentTopics.map { topic =>\n+      val responsesForNonExistentTopics = nonExistentTopics.flatMap { topic =>\n         if (isInternal(topic)) {\n           val topicMetadata = createInternalTopic(topic)\n-          if (topicMetadata.errorCode == Errors.COORDINATOR_NOT_AVAILABLE.code)\n-            metadataResponseTopic(Errors.INVALID_REPLICATION_FACTOR, topic, true, util.Collections.emptyList())\n-          else\n-            topicMetadata\n+          Some(\n+            if (topicMetadata.errorCode == Errors.COORDINATOR_NOT_AVAILABLE.code)\n+              metadataResponseTopic(Errors.INVALID_REPLICATION_FACTOR, topic, true, util.Collections.emptyList())\n+            else\n+              topicMetadata\n+          )\n+        } else if (isFetchAllMetadata) {\n+          // KAFKA-10606: If this request is to get metadata for all topics, auto topic creation should not be allowed\n+          // The special handling is necessary on broker side because allowAutoTopicCreation is hard coded to true\n+          // for backward compatibility on client side.\n+          //\n+          // However, in previous versions, UNKNOWN_TOPIC_OR_PARTITION won't happen on fetch all metadata,\n+          // so, for backward-compatibility, we need to skip these not founds during fetch all metadata here.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "779f6f3274d4fdf38179ab87939bb3c8b71ba82e"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ4OTg4Nw==", "bodyText": "Thanks @ijuma ,\nTo follow the convention in Kafka, I just updated the comments.  Let me know if you have there are any other thoughts!", "url": "https://github.com/apache/kafka/pull/9435#discussion_r535489887", "createdAt": "2020-12-03T18:44:17Z", "author": {"login": "lmr3796"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1243,19 +1244,30 @@ class KafkaApis(val requestChannel: RequestChannel,\n       topicResponses\n     } else {\n       val nonExistentTopics = topics.diff(topicResponses.map(_.name).toSet)\n-      val responsesForNonExistentTopics = nonExistentTopics.map { topic =>\n+      val responsesForNonExistentTopics = nonExistentTopics.flatMap { topic =>\n         if (isInternal(topic)) {\n           val topicMetadata = createInternalTopic(topic)\n-          if (topicMetadata.errorCode == Errors.COORDINATOR_NOT_AVAILABLE.code)\n-            metadataResponseTopic(Errors.INVALID_REPLICATION_FACTOR, topic, true, util.Collections.emptyList())\n-          else\n-            topicMetadata\n+          Some(\n+            if (topicMetadata.errorCode == Errors.COORDINATOR_NOT_AVAILABLE.code)\n+              metadataResponseTopic(Errors.INVALID_REPLICATION_FACTOR, topic, true, util.Collections.emptyList())\n+            else\n+              topicMetadata\n+          )\n+        } else if (isFetchAllMetadata) {\n+          // KAFKA-10606: If this request is to get metadata for all topics, auto topic creation should not be allowed\n+          // The special handling is necessary on broker side because allowAutoTopicCreation is hard coded to true\n+          // for backward compatibility on client side.\n+          //\n+          // However, in previous versions, UNKNOWN_TOPIC_OR_PARTITION won't happen on fetch all metadata,\n+          // so, for backward-compatibility, we need to skip these not founds during fetch all metadata here.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyMTk3MQ=="}, "originalCommit": {"oid": "779f6f3274d4fdf38179ab87939bb3c8b71ba82e"}, "originalPosition": 34}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1784, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}