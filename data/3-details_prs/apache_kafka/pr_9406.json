{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwNTk4Mjc2", "number": 9406, "title": "KAFKA-10520; Ensure transactional producers poll if leastLoadedNode not available with max.in.flight=1", "bodyText": "We currently stop polling in Sender in a transactional producer if there is only one broker in the bootstrap server list and max.in.flight.requests.per.connection=1 and Metadata response is pending when InitProducerId request is ready to be sent. In this scenario, we attempt to send FindCoordinator to leastLoadedNode, but since that is blocked due to max.in.flight=1 as a result of the pending metadata response, we never unblock unless we poll. This PR ensures we poll in this case.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-10-09T13:42:23Z", "url": "https://github.com/apache/kafka/pull/9406", "merged": true, "mergeCommit": {"oid": "1d26391368d146fc0b7be9abfcf98d3475d7a834"}, "closed": true, "closedAt": "2020-10-21T19:07:27Z", "author": {"login": "rajinisivaram"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdUYQtzAFqTUxMjY3MTMwMQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdUxE4YAFqTUxNDAyMjY4Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyNjcxMzAx", "url": "https://github.com/apache/kafka/pull/9406#pullrequestreview-512671301", "createdAt": "2020-10-20T12:51:42Z", "commit": {"oid": "42097e99a84ecc4af8652562c521589679640415"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjo1MTo0MlrOHk6wwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMjo1MTo0MlrOHk6wwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ3MzUzNw==", "bodyText": "Don't we loose the current nextRequestHandler when we end up in this branch?\nFor instance, if nextRequestHandler is a FindCoordinatorHandler and there a no nodes available, targetNode is null and coordinatorType is null as well so we end up here and poll. We don't do anything with nextRequestHandler and return so it is gone. I suppose that it is not an issue for FindCoordinatorHandler as a new one will be enqueued automatically when another TxnRequestHandler handler is processed and the coordinator is unknown.\nWe may want to push back nextRequestHandler to the queue with transactionManager.retry(nextRequestHandler) in oder to handle all the cases.\nI am not sure if that could really happen with any other TxnRequestHandler type though. What do you think?", "url": "https://github.com/apache/kafka/pull/9406#discussion_r508473537", "createdAt": "2020-10-20T12:51:42Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java", "diffHunk": "@@ -444,10 +444,20 @@ private boolean maybeSendAndPollTransactionalRequest() {\n         AbstractRequest.Builder<?> requestBuilder = nextRequestHandler.requestBuilder();\n         Node targetNode = null;\n         try {\n-            targetNode = awaitNodeReady(nextRequestHandler.coordinatorType());\n-            if (targetNode == null) {\n+            FindCoordinatorRequest.CoordinatorType coordinatorType = nextRequestHandler.coordinatorType();\n+            targetNode = coordinatorType != null ?\n+                    transactionManager.coordinator(coordinatorType) :\n+                    client.leastLoadedNode(time.milliseconds());\n+            if (targetNode != null) {\n+                awaitNodeReady(targetNode, coordinatorType);\n+            } else if (coordinatorType != null) {\n+                log.trace(\"Coordinator not known for {}, will retry {} after finding coordinator.\", coordinatorType, requestBuilder.apiKey());\n                 maybeFindCoordinatorAndRetry(nextRequestHandler);\n                 return true;\n+            } else {\n+                log.trace(\"No nodes available to send requests, polling until a node is ready.\");\n+                client.poll(retryBackoffMs, time.milliseconds());\n+                return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "42097e99a84ecc4af8652562c521589679640415"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNDIyMTY2", "url": "https://github.com/apache/kafka/pull/9406#pullrequestreview-513422166", "createdAt": "2020-10-21T08:20:53Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwODoyMDo1M1rOHlf6gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwODoyMDo1M1rOHlf6gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA4MjI0Mw==", "bodyText": "node != null Is this check necessary?", "url": "https://github.com/apache/kafka/pull/9406#discussion_r509082243", "createdAt": "2020-10-21T08:20:53Z", "author": {"login": "chia7712"}, "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java", "diffHunk": "@@ -512,21 +523,15 @@ public boolean isRunning() {\n         return running;\n     }\n \n-    private Node awaitNodeReady(FindCoordinatorRequest.CoordinatorType coordinatorType) throws IOException {\n-        Node node = coordinatorType != null ?\n-                transactionManager.coordinator(coordinatorType) :\n-                client.leastLoadedNode(time.milliseconds());\n-\n+    private void awaitNodeReady(Node node, FindCoordinatorRequest.CoordinatorType coordinatorType) throws IOException {\n         if (node != null && NetworkClientUtils.awaitReady(client, node, time, requestTimeoutMs)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNDM4Nzg2", "url": "https://github.com/apache/kafka/pull/9406#pullrequestreview-513438786", "createdAt": "2020-10-21T08:39:31Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwODozOTozMVrOHlguFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwODozOTozMVrOHlguFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA5NTQ0NQ==", "bodyText": "How to deal with the non-ready targetNode after calling awaitNodeReady ?", "url": "https://github.com/apache/kafka/pull/9406#discussion_r509095445", "createdAt": "2020-10-21T08:39:31Z", "author": {"login": "chia7712"}, "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java", "diffHunk": "@@ -444,10 +444,21 @@ private boolean maybeSendAndPollTransactionalRequest() {\n         AbstractRequest.Builder<?> requestBuilder = nextRequestHandler.requestBuilder();\n         Node targetNode = null;\n         try {\n-            targetNode = awaitNodeReady(nextRequestHandler.coordinatorType());\n-            if (targetNode == null) {\n+            FindCoordinatorRequest.CoordinatorType coordinatorType = nextRequestHandler.coordinatorType();\n+            targetNode = coordinatorType != null ?\n+                    transactionManager.coordinator(coordinatorType) :\n+                    client.leastLoadedNode(time.milliseconds());\n+            if (targetNode != null) {\n+                awaitNodeReady(targetNode, coordinatorType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNDY1NzYw", "url": "https://github.com/apache/kafka/pull/9406#pullrequestreview-513465760", "createdAt": "2020-10-21T09:10:04Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwOToxMDowNVrOHliBtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwOToxMDowNVrOHliBtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTExNjg1Mw==", "bodyText": "this new test passes on my local even though I revert the change of Sender.", "url": "https://github.com/apache/kafka/pull/9406#discussion_r509116853", "createdAt": "2020-10-21T09:10:05Z", "author": {"login": "chia7712"}, "path": "core/src/test/scala/integration/kafka/api/TransactionsWithMaxInFlightOneTest.scala", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+  * Licensed to the Apache Software Foundation (ASF) under one or more\n+  * contributor license agreements.  See the NOTICE file distributed with\n+  * this work for additional information regarding copyright ownership.\n+  * The ASF licenses this file to You under the Apache License, Version 2.0\n+  * (the \"License\"); you may not use this file except in compliance with\n+  * the License.  You may obtain a copy of the License at\n+  *\n+  *    http://www.apache.org/licenses/LICENSE-2.0\n+  *\n+  * Unless required by applicable law or agreed to in writing, software\n+  * distributed under the License is distributed on an \"AS IS\" BASIS,\n+  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+  * See the License for the specific language governing permissions and\n+  * limitations under the License.\n+  */\n+\n+package integration.kafka.api\n+\n+import java.util.Properties\n+\n+import kafka.integration.KafkaServerTestHarness\n+import kafka.server.KafkaConfig\n+import kafka.utils.TestUtils\n+import kafka.utils.TestUtils.consumeRecords\n+import org.apache.kafka.clients.consumer.KafkaConsumer\n+import org.apache.kafka.clients.producer.KafkaProducer\n+import org.junit.{After, Before, Test}\n+import org.junit.Assert.assertEquals\n+\n+import scala.collection.Seq\n+import scala.collection.mutable.Buffer\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * This is used to test transactions with one broker and `max.in.flight.requests.per.connection=1`.\n+ * A single broker is used to verify edge cases where different requests are queued on the same connection.\n+ */\n+class TransactionsWithMaxInFlightOneTest extends KafkaServerTestHarness {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f68ac1adf1d5bc4b41e7c8fca41a700db9b1acc2", "author": {"user": {"login": "rajinisivaram", "name": "Rajini Sivaram"}}, "url": "https://github.com/apache/kafka/commit/f68ac1adf1d5bc4b41e7c8fca41a700db9b1acc2", "committedDate": "2020-10-21T11:07:31Z", "message": "KAFKA-10520; Ensure transactional producers poll if leastLoadedNode not available with max.in.flight=1"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e8b3446d1edb2eb4069a1dcf4142168d61b241b6", "author": {"user": {"login": "rajinisivaram", "name": "Rajini Sivaram"}}, "url": "https://github.com/apache/kafka/commit/e8b3446d1edb2eb4069a1dcf4142168d61b241b6", "committedDate": "2020-10-21T11:07:31Z", "message": "Address review comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e36ffe76440f978f99c2a44dd975f90546879f8", "author": {"user": {"login": "rajinisivaram", "name": "Rajini Sivaram"}}, "url": "https://github.com/apache/kafka/commit/3e36ffe76440f978f99c2a44dd975f90546879f8", "committedDate": "2020-10-21T11:07:32Z", "message": "Address review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "3e36ffe76440f978f99c2a44dd975f90546879f8", "author": {"user": {"login": "rajinisivaram", "name": "Rajini Sivaram"}}, "url": "https://github.com/apache/kafka/commit/3e36ffe76440f978f99c2a44dd975f90546879f8", "committedDate": "2020-10-21T11:07:32Z", "message": "Address review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzNjQ5Mzg5", "url": "https://github.com/apache/kafka/pull/9406#pullrequestreview-513649389", "createdAt": "2020-10-21T13:01:08Z", "commit": {"oid": "3e36ffe76440f978f99c2a44dd975f90546879f8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMzowMTowOFrOHlqmTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMzowMTowOFrOHlqmTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTI1NzI5Mw==", "bodyText": "Looking at this branch again, sorry :). I was comparing it with the previous behavior and I have noticed that we would request a refresh of the metadata when the same conditions were met. That happened here:\n    private void maybeFindCoordinatorAndRetry(TransactionManager.TxnRequestHandler nextRequestHandler) {\n        if (nextRequestHandler.needsCoordinator()) {\n            transactionManager.lookupCoordinator(nextRequestHandler);\n        } else {\n            // For non-coordinator requests, sleep here to prevent a tight loop when no node is available\n            time.sleep(retryBackoffMs);\n            metadata.requestUpdate();\n        }\n\n        transactionManager.retry(nextRequestHandler);\n    }\n\nWhen no node is available and coordinatorType != null, we ended up in the else branch here. I wonder if not doing metadata.requestUpdate() in our new implementation could be problematic and I also wonder if we could just swap that time.sleep(retryBackoffMs) by client.poll(retryBackoffMs, time.milliseconds()) to achieve the same goal. The difference is that another metadata request would be sent in our particular case.\nHave you noticed this small difference?", "url": "https://github.com/apache/kafka/pull/9406#discussion_r509257293", "createdAt": "2020-10-21T13:01:08Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java", "diffHunk": "@@ -444,10 +444,25 @@ private boolean maybeSendAndPollTransactionalRequest() {\n         AbstractRequest.Builder<?> requestBuilder = nextRequestHandler.requestBuilder();\n         Node targetNode = null;\n         try {\n-            targetNode = awaitNodeReady(nextRequestHandler.coordinatorType());\n-            if (targetNode == null) {\n+            FindCoordinatorRequest.CoordinatorType coordinatorType = nextRequestHandler.coordinatorType();\n+            targetNode = coordinatorType != null ?\n+                    transactionManager.coordinator(coordinatorType) :\n+                    client.leastLoadedNode(time.milliseconds());\n+            if (targetNode != null) {\n+                if (!awaitNodeReady(targetNode, coordinatorType)) {\n+                    log.trace(\"Target node {} not ready within request timeout, will retry when node is ready.\", targetNode);\n+                    maybeFindCoordinatorAndRetry(nextRequestHandler);\n+                    return true;\n+                }\n+            } else if (coordinatorType != null) {\n+                log.trace(\"Coordinator not known for {}, will retry {} after finding coordinator.\", coordinatorType, requestBuilder.apiKey());\n                 maybeFindCoordinatorAndRetry(nextRequestHandler);\n                 return true;\n+            } else {\n+                log.trace(\"No nodes available to send requests, will poll and retry when until a node is ready.\");\n+                transactionManager.retry(nextRequestHandler);\n+                client.poll(retryBackoffMs, time.milliseconds());\n+                return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e36ffe76440f978f99c2a44dd975f90546879f8"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzOTc0MDIx", "url": "https://github.com/apache/kafka/pull/9406#pullrequestreview-513974021", "createdAt": "2020-10-21T17:03:44Z", "commit": {"oid": "3e36ffe76440f978f99c2a44dd975f90546879f8"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzowMzo0NFrOHl2lkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzowODoxM1rOHl2wgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ1MzcxMg==", "bodyText": "I agree polling seems sufficient. We will still have an opportunity to refresh metadata if the current connection fails for some reason.", "url": "https://github.com/apache/kafka/pull/9406#discussion_r509453712", "createdAt": "2020-10-21T17:03:44Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java", "diffHunk": "@@ -444,10 +444,25 @@ private boolean maybeSendAndPollTransactionalRequest() {\n         AbstractRequest.Builder<?> requestBuilder = nextRequestHandler.requestBuilder();\n         Node targetNode = null;\n         try {\n-            targetNode = awaitNodeReady(nextRequestHandler.coordinatorType());\n-            if (targetNode == null) {\n+            FindCoordinatorRequest.CoordinatorType coordinatorType = nextRequestHandler.coordinatorType();\n+            targetNode = coordinatorType != null ?\n+                    transactionManager.coordinator(coordinatorType) :\n+                    client.leastLoadedNode(time.milliseconds());\n+            if (targetNode != null) {\n+                if (!awaitNodeReady(targetNode, coordinatorType)) {\n+                    log.trace(\"Target node {} not ready within request timeout, will retry when node is ready.\", targetNode);\n+                    maybeFindCoordinatorAndRetry(nextRequestHandler);\n+                    return true;\n+                }\n+            } else if (coordinatorType != null) {\n+                log.trace(\"Coordinator not known for {}, will retry {} after finding coordinator.\", coordinatorType, requestBuilder.apiKey());\n                 maybeFindCoordinatorAndRetry(nextRequestHandler);\n                 return true;\n+            } else {\n+                log.trace(\"No nodes available to send requests, will poll and retry when until a node is ready.\");\n+                transactionManager.retry(nextRequestHandler);\n+                client.poll(retryBackoffMs, time.milliseconds());\n+                return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTI1NzI5Mw=="}, "originalCommit": {"oid": "3e36ffe76440f978f99c2a44dd975f90546879f8"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ1NjUxNA==", "bodyText": "Wonder if we should consider adding max inflight behavior directly to MockClient. Seems like a notable difference from NetworkClient.", "url": "https://github.com/apache/kafka/pull/9406#discussion_r509456514", "createdAt": "2020-10-21T17:08:13Z", "author": {"login": "hachikuji"}, "path": "clients/src/test/java/org/apache/kafka/clients/producer/internals/SenderTest.java", "diffHunk": "@@ -2667,4 +2760,43 @@ private void assertFutureFailure(Future<?> future, Class<? extends Exception> ex\n         }\n     }\n \n+    private void createMockClientWithMaxFlightOneMetadataPending() {\n+        client = new MockClient(time, metadata) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e36ffe76440f978f99c2a44dd975f90546879f8"}, "originalPosition": 146}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MDIyNjgz", "url": "https://github.com/apache/kafka/pull/9406#pullrequestreview-514022683", "createdAt": "2020-10-21T17:46:24Z", "commit": {"oid": "3e36ffe76440f978f99c2a44dd975f90546879f8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 490, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}