{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyNjY1NjUw", "number": 9121, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOTowODoyOVrOEbE3rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOToxMTowN1rOEbE7iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2ODI2Nzk5OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImplTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOTowODoyOVrOHE4L7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMTo0MjoyOVrOHHexPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg3NjkxMA==", "bodyText": "Subjective: Might be \"better\" to do the assertion after the try-block.", "url": "https://github.com/apache/kafka/pull/9121#discussion_r474876910", "createdAt": "2020-08-21T19:08:29Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImplTest.java", "diffHunk": "@@ -180,6 +183,27 @@ public void shouldReadCheckpointOffsets() throws IOException {\n         assertEquals(expected, offsets);\n     }\n \n+    @Test\n+    public void shouldLogWarningMessageWhenIOExceptionInCheckPoint() throws IOException {\n+        final Map<TopicPartition, Long> offsets = Collections.singletonMap(t1, 25L);\n+        stateManager.initialize();\n+        stateManager.updateChangelogOffsets(offsets);\n+\n+        final File file = new File(stateDirectory.globalStateDir(), StateManagerUtil.CHECKPOINT_FILE_NAME + \".tmp\");\n+        file.createNewFile();\n+        // set the checkpoint tmp file to read-only to simulate the IOException situation\n+        file.setWritable(false);\n+\n+        try (final LogCaptureAppender appender =\n+                 LogCaptureAppender.createAndRegister(GlobalStateManagerImpl.class)) {\n+\n+            // checkpoint should fail due to the file is readonly\n+            stateManager.checkpoint();\n+            assertThat(appender.getMessages(), hasItem(containsString(\n+                \"Failed to write offset checkpoint file to \" + checkpointFile.getPath() + \" for global stores\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8466513f465fca0fcfa3e7e8899ba31cab6bb0a0"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MjMxNg==", "bodyText": "I agree it'll be better to do the assertion after the try-block. But no, we can't move the assert out of the try-block because the appender is declared within try block. We can move the assert out of try-block if we don't use the try resource auto-close pattern, but I don't think it would be better.\nAlso, we assert within try-block for the appender tests in other places. I think they are all for the same reason as I mentioned above.\nThanks.", "url": "https://github.com/apache/kafka/pull/9121#discussion_r475362316", "createdAt": "2020-08-24T06:09:57Z", "author": {"login": "showuon"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImplTest.java", "diffHunk": "@@ -180,6 +183,27 @@ public void shouldReadCheckpointOffsets() throws IOException {\n         assertEquals(expected, offsets);\n     }\n \n+    @Test\n+    public void shouldLogWarningMessageWhenIOExceptionInCheckPoint() throws IOException {\n+        final Map<TopicPartition, Long> offsets = Collections.singletonMap(t1, 25L);\n+        stateManager.initialize();\n+        stateManager.updateChangelogOffsets(offsets);\n+\n+        final File file = new File(stateDirectory.globalStateDir(), StateManagerUtil.CHECKPOINT_FILE_NAME + \".tmp\");\n+        file.createNewFile();\n+        // set the checkpoint tmp file to read-only to simulate the IOException situation\n+        file.setWritable(false);\n+\n+        try (final LogCaptureAppender appender =\n+                 LogCaptureAppender.createAndRegister(GlobalStateManagerImpl.class)) {\n+\n+            // checkpoint should fail due to the file is readonly\n+            stateManager.checkpoint();\n+            assertThat(appender.getMessages(), hasItem(containsString(\n+                \"Failed to write offset checkpoint file to \" + checkpointFile.getPath() + \" for global stores\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg3NjkxMA=="}, "originalCommit": {"oid": "8466513f465fca0fcfa3e7e8899ba31cab6bb0a0"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYwNjIwNw==", "bodyText": "Ah. Good point. We can leave as-is.", "url": "https://github.com/apache/kafka/pull/9121#discussion_r477606207", "createdAt": "2020-08-26T21:42:29Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImplTest.java", "diffHunk": "@@ -180,6 +183,27 @@ public void shouldReadCheckpointOffsets() throws IOException {\n         assertEquals(expected, offsets);\n     }\n \n+    @Test\n+    public void shouldLogWarningMessageWhenIOExceptionInCheckPoint() throws IOException {\n+        final Map<TopicPartition, Long> offsets = Collections.singletonMap(t1, 25L);\n+        stateManager.initialize();\n+        stateManager.updateChangelogOffsets(offsets);\n+\n+        final File file = new File(stateDirectory.globalStateDir(), StateManagerUtil.CHECKPOINT_FILE_NAME + \".tmp\");\n+        file.createNewFile();\n+        // set the checkpoint tmp file to read-only to simulate the IOException situation\n+        file.setWritable(false);\n+\n+        try (final LogCaptureAppender appender =\n+                 LogCaptureAppender.createAndRegister(GlobalStateManagerImpl.class)) {\n+\n+            // checkpoint should fail due to the file is readonly\n+            stateManager.checkpoint();\n+            assertThat(appender.getMessages(), hasItem(containsString(\n+                \"Failed to write offset checkpoint file to \" + checkpointFile.getPath() + \" for global stores\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg3NjkxMA=="}, "originalCommit": {"oid": "8466513f465fca0fcfa3e7e8899ba31cab6bb0a0"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2ODI2OTMwOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOTowODo1M1rOHE4MsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOTowODo1M1rOHE4MsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg3NzEwNQ==", "bodyText": "Nit: no need to line-break", "url": "https://github.com/apache/kafka/pull/9121#discussion_r474877105", "createdAt": "2020-08-21T19:08:53Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImplTest.java", "diffHunk": "@@ -180,6 +183,27 @@ public void shouldReadCheckpointOffsets() throws IOException {\n         assertEquals(expected, offsets);\n     }\n \n+    @Test\n+    public void shouldLogWarningMessageWhenIOExceptionInCheckPoint() throws IOException {\n+        final Map<TopicPartition, Long> offsets = Collections.singletonMap(t1, 25L);\n+        stateManager.initialize();\n+        stateManager.updateChangelogOffsets(offsets);\n+\n+        final File file = new File(stateDirectory.globalStateDir(), StateManagerUtil.CHECKPOINT_FILE_NAME + \".tmp\");\n+        file.createNewFile();\n+        // set the checkpoint tmp file to read-only to simulate the IOException situation\n+        file.setWritable(false);\n+\n+        try (final LogCaptureAppender appender =\n+                 LogCaptureAppender.createAndRegister(GlobalStateManagerImpl.class)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8466513f465fca0fcfa3e7e8899ba31cab6bb0a0"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2ODI3MDk0OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOTowOToyNVrOHE4NqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOTowOToyNVrOHE4NqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg3NzM1Mg==", "bodyText": "The test seems to be self-explaining and thus we don't really need this comment", "url": "https://github.com/apache/kafka/pull/9121#discussion_r474877352", "createdAt": "2020-08-21T19:09:25Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImplTest.java", "diffHunk": "@@ -180,6 +183,27 @@ public void shouldReadCheckpointOffsets() throws IOException {\n         assertEquals(expected, offsets);\n     }\n \n+    @Test\n+    public void shouldLogWarningMessageWhenIOExceptionInCheckPoint() throws IOException {\n+        final Map<TopicPartition, Long> offsets = Collections.singletonMap(t1, 25L);\n+        stateManager.initialize();\n+        stateManager.updateChangelogOffsets(offsets);\n+\n+        final File file = new File(stateDirectory.globalStateDir(), StateManagerUtil.CHECKPOINT_FILE_NAME + \".tmp\");\n+        file.createNewFile();\n+        // set the checkpoint tmp file to read-only to simulate the IOException situation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8466513f465fca0fcfa3e7e8899ba31cab6bb0a0"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2ODI3MTQ2OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImplTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOTowOTozNlrOHE4N9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQyMjowNjo0NFrOHHfYcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg3NzQyOA==", "bodyText": "Why do we need to add .tmp ?", "url": "https://github.com/apache/kafka/pull/9121#discussion_r474877428", "createdAt": "2020-08-21T19:09:36Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImplTest.java", "diffHunk": "@@ -180,6 +183,27 @@ public void shouldReadCheckpointOffsets() throws IOException {\n         assertEquals(expected, offsets);\n     }\n \n+    @Test\n+    public void shouldLogWarningMessageWhenIOExceptionInCheckPoint() throws IOException {\n+        final Map<TopicPartition, Long> offsets = Collections.singletonMap(t1, 25L);\n+        stateManager.initialize();\n+        stateManager.updateChangelogOffsets(offsets);\n+\n+        final File file = new File(stateDirectory.globalStateDir(), StateManagerUtil.CHECKPOINT_FILE_NAME + \".tmp\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8466513f465fca0fcfa3e7e8899ba31cab6bb0a0"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM5Mzc0Nw==", "bodyText": "It's because we we will write data to the .tmp file first and then swap to the CHECKPOINT_FILE. And in the swap action, we use Files.move with ATOMIC_MOVE option, which will try to replace the target file if exists. I cannot create IOException with this case. I added comments for this line to explain the reason. Thank you.\nref: https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#move-java.nio.file.Path-java.nio.file.Path-java.nio.file.CopyOption...-", "url": "https://github.com/apache/kafka/pull/9121#discussion_r475393747", "createdAt": "2020-08-24T07:28:28Z", "author": {"login": "showuon"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImplTest.java", "diffHunk": "@@ -180,6 +183,27 @@ public void shouldReadCheckpointOffsets() throws IOException {\n         assertEquals(expected, offsets);\n     }\n \n+    @Test\n+    public void shouldLogWarningMessageWhenIOExceptionInCheckPoint() throws IOException {\n+        final Map<TopicPartition, Long> offsets = Collections.singletonMap(t1, 25L);\n+        stateManager.initialize();\n+        stateManager.updateChangelogOffsets(offsets);\n+\n+        final File file = new File(stateDirectory.globalStateDir(), StateManagerUtil.CHECKPOINT_FILE_NAME + \".tmp\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg3NzQyOA=="}, "originalCommit": {"oid": "8466513f465fca0fcfa3e7e8899ba31cab6bb0a0"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYxNjI0MQ==", "bodyText": "Interesting... Thanks for clarification.", "url": "https://github.com/apache/kafka/pull/9121#discussion_r477616241", "createdAt": "2020-08-26T22:06:44Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImplTest.java", "diffHunk": "@@ -180,6 +183,27 @@ public void shouldReadCheckpointOffsets() throws IOException {\n         assertEquals(expected, offsets);\n     }\n \n+    @Test\n+    public void shouldLogWarningMessageWhenIOExceptionInCheckPoint() throws IOException {\n+        final Map<TopicPartition, Long> offsets = Collections.singletonMap(t1, 25L);\n+        stateManager.initialize();\n+        stateManager.updateChangelogOffsets(offsets);\n+\n+        final File file = new File(stateDirectory.globalStateDir(), StateManagerUtil.CHECKPOINT_FILE_NAME + \".tmp\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg3NzQyOA=="}, "originalCommit": {"oid": "8466513f465fca0fcfa3e7e8899ba31cab6bb0a0"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2ODI3MjA1OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOTowOTo1MVrOHE4OVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOTowOTo1MVrOHE4OVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg3NzUyNg==", "bodyText": "as above; comment is not really needed", "url": "https://github.com/apache/kafka/pull/9121#discussion_r474877526", "createdAt": "2020-08-21T19:09:51Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/GlobalStateManagerImplTest.java", "diffHunk": "@@ -180,6 +183,27 @@ public void shouldReadCheckpointOffsets() throws IOException {\n         assertEquals(expected, offsets);\n     }\n \n+    @Test\n+    public void shouldLogWarningMessageWhenIOExceptionInCheckPoint() throws IOException {\n+        final Map<TopicPartition, Long> offsets = Collections.singletonMap(t1, 25L);\n+        stateManager.initialize();\n+        stateManager.updateChangelogOffsets(offsets);\n+\n+        final File file = new File(stateDirectory.globalStateDir(), StateManagerUtil.CHECKPOINT_FILE_NAME + \".tmp\");\n+        file.createNewFile();\n+        // set the checkpoint tmp file to read-only to simulate the IOException situation\n+        file.setWritable(false);\n+\n+        try (final LogCaptureAppender appender =\n+                 LogCaptureAppender.createAndRegister(GlobalStateManagerImpl.class)) {\n+\n+            // checkpoint should fail due to the file is readonly", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8466513f465fca0fcfa3e7e8899ba31cab6bb0a0"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2ODI3MzEzOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/OffsetCheckpointTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOToxMDoxMVrOHE4O-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOToxMDoxMVrOHE4O-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg3NzY4OQ==", "bodyText": "nit: no need to line break", "url": "https://github.com/apache/kafka/pull/9121#discussion_r474877689", "createdAt": "2020-08-21T19:10:11Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/OffsetCheckpointTest.java", "diffHunk": "@@ -135,6 +136,20 @@ public void shouldThrowOnInvalidOffsetInWrite() throws IOException {\n         }\n     }\n \n+    @Test\n+    public void shouldThrowIOExceptionWhenWritingToNotExistedFile() {\n+        final Map<TopicPartition, Long> offsetsToWrite = Collections.singletonMap(\n+            new TopicPartition(topic, 0), 0L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8466513f465fca0fcfa3e7e8899ba31cab6bb0a0"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2ODI3Nzg0OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/OffsetCheckpointTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOToxMTowN1rOHE4Rpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwNTo1ODoxM1rOHFVl5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg3ODM3NA==", "bodyText": "that the pass is \"not existing\" is already clear from File(\"not_existing_dir/not_existing_file\") and thus not necessary", "url": "https://github.com/apache/kafka/pull/9121#discussion_r474878374", "createdAt": "2020-08-21T19:11:07Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/OffsetCheckpointTest.java", "diffHunk": "@@ -135,6 +136,20 @@ public void shouldThrowOnInvalidOffsetInWrite() throws IOException {\n         }\n     }\n \n+    @Test\n+    public void shouldThrowIOExceptionWhenWritingToNotExistedFile() {\n+        final Map<TopicPartition, Long> offsetsToWrite = Collections.singletonMap(\n+            new TopicPartition(topic, 0), 0L);\n+\n+        // create a file with not existed path, and feed into OffsetCheckpoint", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8466513f465fca0fcfa3e7e8899ba31cab6bb0a0"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM1ODY5Mg==", "bodyText": "agree!", "url": "https://github.com/apache/kafka/pull/9121#discussion_r475358692", "createdAt": "2020-08-24T05:58:13Z", "author": {"login": "showuon"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/OffsetCheckpointTest.java", "diffHunk": "@@ -135,6 +136,20 @@ public void shouldThrowOnInvalidOffsetInWrite() throws IOException {\n         }\n     }\n \n+    @Test\n+    public void shouldThrowIOExceptionWhenWritingToNotExistedFile() {\n+        final Map<TopicPartition, Long> offsetsToWrite = Collections.singletonMap(\n+            new TopicPartition(topic, 0), 0L);\n+\n+        // create a file with not existed path, and feed into OffsetCheckpoint", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg3ODM3NA=="}, "originalCommit": {"oid": "8466513f465fca0fcfa3e7e8899ba31cab6bb0a0"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2097, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}