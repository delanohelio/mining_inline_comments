{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg0OTA4MTUy", "number": 9280, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMzo1MDowOVrOEiuJmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwMDoxNjo0NlrOEqhhtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODQzMTYyOnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMzo1MDowOVrOHQwosw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxMDoyMzo0MlrOHQ0OBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMzNjExNQ==", "bodyText": "This comment might be unnecessary, the code is pretty self-explanatory in this case \ud83d\ude42", "url": "https://github.com/apache/kafka/pull/9280#discussion_r487336115", "createdAt": "2020-09-11T23:50:09Z", "author": {"login": "ableegoldman"}, "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java", "diffHunk": "@@ -418,10 +419,14 @@ private boolean maybeSendAndPollTransactionalRequest() {\n \n         if (transactionManager.hasAbortableError() || transactionManager.isAborting()) {\n             if (accumulator.hasIncomplete()) {\n+                // Attempt to get the last error that caused this abort.\n                 RuntimeException exception = transactionManager.lastError();\n+                // If there was no error, but we are still aborting,\n+                // then this is most likely a case where there was no fatal error.\n                 if (exception == null) {\n-                    exception = new KafkaException(\"Failing batch since transaction was aborted\");\n+                    exception = new TransactionAbortedException();\n                 }\n+                // Since the transaction is aborted / being aborted, abort all the undrained batches.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5NDgyMQ==", "bodyText": "Aah. Sorry - I'll take that away.", "url": "https://github.com/apache/kafka/pull/9280#discussion_r487394821", "createdAt": "2020-09-12T10:23:42Z", "author": {"login": "nym3r0s"}, "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java", "diffHunk": "@@ -418,10 +419,14 @@ private boolean maybeSendAndPollTransactionalRequest() {\n \n         if (transactionManager.hasAbortableError() || transactionManager.isAborting()) {\n             if (accumulator.hasIncomplete()) {\n+                // Attempt to get the last error that caused this abort.\n                 RuntimeException exception = transactionManager.lastError();\n+                // If there was no error, but we are still aborting,\n+                // then this is most likely a case where there was no fatal error.\n                 if (exception == null) {\n-                    exception = new KafkaException(\"Failing batch since transaction was aborted\");\n+                    exception = new TransactionAbortedException();\n                 }\n+                // Since the transaction is aborted / being aborted, abort all the undrained batches.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMzNjExNQ=="}, "originalCommit": null, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMDI0OTQ4OnYy", "diffSide": "RIGHT", "path": "clients/src/test/java/org/apache/kafka/clients/producer/internals/SenderTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQwMDoxNjo0NlrOHcx4-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMDoyMzoyOVrOHc_vdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkzOTU3Ng==", "bodyText": "We have a helper for this pattern. See TestUtils.assertFutureThrows", "url": "https://github.com/apache/kafka/pull/9280#discussion_r499939576", "createdAt": "2020-10-06T00:16:46Z", "author": {"login": "hachikuji"}, "path": "clients/src/test/java/org/apache/kafka/clients/producer/internals/SenderTest.java", "diffHunk": "@@ -2358,6 +2359,41 @@ public void testForceShutdownWithIncompleteTransaction() {\n         }\n     }\n \n+    @Test\n+    public void testTransactionAbortedExceptionOnAbortWithoutError() throws InterruptedException, ExecutionException {\n+        ProducerIdAndEpoch producerIdAndEpoch = new ProducerIdAndEpoch(123456L, (short) 0);\n+        TransactionManager txnManager = new TransactionManager(logContext, \"testTransactionAbortedExceptionOnAbortWithoutError\", 60000, 100, apiVersions, false);\n+\n+        setupWithTransactionState(txnManager, false, null);\n+        doInitTransactions(txnManager, producerIdAndEpoch);\n+        // Begin the transaction\n+        txnManager.beginTransaction();\n+        txnManager.maybeAddPartitionToTransaction(tp0);\n+        client.prepareResponse(new AddPartitionsToTxnResponse(0, Collections.singletonMap(tp0, Errors.NONE)));\n+        // Run it once so that the partition is added to the transaction.\n+        sender.runOnce();\n+        // Append a record to the accumulator.\n+        FutureRecordMetadata metadata1 = appendToAccumulator(tp0, time.milliseconds(), \"key1\", \"value1\");\n+        // Now abort the transaction manually.\n+        txnManager.beginAbort();\n+        // Try to send.\n+        // This should abort the existing transaction and\n+        // drain all the unsent batches with a TransactionAbortedException.\n+        sender.runOnce();\n+        // Now attempt to fetch the result for the record.\n+        try {\n+            // This should fail since we aborted the transaction.\n+            metadata1.get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDE2NjUxNw==", "bodyText": "@hachikuji - Thank you - I've updated the test \ud83d\udc4d", "url": "https://github.com/apache/kafka/pull/9280#discussion_r500166517", "createdAt": "2020-10-06T10:23:29Z", "author": {"login": "nym3r0s"}, "path": "clients/src/test/java/org/apache/kafka/clients/producer/internals/SenderTest.java", "diffHunk": "@@ -2358,6 +2359,41 @@ public void testForceShutdownWithIncompleteTransaction() {\n         }\n     }\n \n+    @Test\n+    public void testTransactionAbortedExceptionOnAbortWithoutError() throws InterruptedException, ExecutionException {\n+        ProducerIdAndEpoch producerIdAndEpoch = new ProducerIdAndEpoch(123456L, (short) 0);\n+        TransactionManager txnManager = new TransactionManager(logContext, \"testTransactionAbortedExceptionOnAbortWithoutError\", 60000, 100, apiVersions, false);\n+\n+        setupWithTransactionState(txnManager, false, null);\n+        doInitTransactions(txnManager, producerIdAndEpoch);\n+        // Begin the transaction\n+        txnManager.beginTransaction();\n+        txnManager.maybeAddPartitionToTransaction(tp0);\n+        client.prepareResponse(new AddPartitionsToTxnResponse(0, Collections.singletonMap(tp0, Errors.NONE)));\n+        // Run it once so that the partition is added to the transaction.\n+        sender.runOnce();\n+        // Append a record to the accumulator.\n+        FutureRecordMetadata metadata1 = appendToAccumulator(tp0, time.milliseconds(), \"key1\", \"value1\");\n+        // Now abort the transaction manually.\n+        txnManager.beginAbort();\n+        // Try to send.\n+        // This should abort the existing transaction and\n+        // drain all the unsent batches with a TransactionAbortedException.\n+        sender.runOnce();\n+        // Now attempt to fetch the result for the record.\n+        try {\n+            // This should fail since we aborted the transaction.\n+            metadata1.get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkzOTU3Ng=="}, "originalCommit": null, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1824, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}