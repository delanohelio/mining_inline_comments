{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1NjkwNTYx", "number": 8768, "title": "KAFKA-10023: Enforce broker-wide and per-listener connection creation\u2026", "bodyText": "This PR implements the part of KIP-612 that adds broker configurations for broker-wide and per-listener connection creation rate limits and enforces these limits.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-06-01T00:02:20Z", "url": "https://github.com/apache/kafka/pull/8768", "merged": true, "mergeCommit": {"oid": "e8b2dcdee6f25e9344d52b84e86328ec616bf819"}, "closed": true, "closedAt": "2020-08-17T13:35:28Z", "author": {"login": "apovzner"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnQ0FbAFqTQyMjQxNTMyNA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc_p-orAH2gAyNDI1NjkwNTYxOjUwOGE3NTRmMzk3YjVhMTkzOWM0NGRmY2JhNzJiYTk5NmJjOTEyYzU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNDE1MzI0", "url": "https://github.com/apache/kafka/pull/8768#pullrequestreview-422415324", "createdAt": "2020-06-02T07:36:05Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNzozNjowNVrOGdlmBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwODo0MTo1MVrOGdn4YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3NzgyOQ==", "bodyText": "I am not convinced by this. The main issue being that other reporters will report the metric. If we really want to not report a metric, I think that we need a solution which works for all reporters. Could you perhaps elaborate more on the need here?\nI can think of the following alternatives:\n\nadd a flag to the sensor to indicate if it must be reported or not.\ndon't rely on metrics to create/store the sensor but have a local reference.", "url": "https://github.com/apache/kafka/pull/8768#discussion_r433677829", "createdAt": "2020-06-02T07:36:05Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/common/metrics/JmxReporter.java", "diffHunk": "@@ -161,6 +162,9 @@ private KafkaMbean removeAttribute(KafkaMetric metric, String mBeanName) {\n     private String addAttribute(KafkaMetric metric) {\n         try {\n             MetricName metricName = metric.metricName();\n+            if (metricName.tags().containsKey(DO_NOT_REPORT_TAG)) {\n+                return null;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5MjgyOQ==", "bodyText": "nit: extra space after the ..", "url": "https://github.com/apache/kafka/pull/8768#discussion_r433692829", "createdAt": "2020-06-02T08:03:24Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/KafkaConfig.scala", "diffHunk": "@@ -689,6 +691,11 @@ object KafkaConfig {\n     \"should be configured based on broker capacity while listener limits should be configured based on application requirements. \" +\n     \"New connections are blocked if either the listener or broker limit is reached. Connections on the inter-broker listener are \" +\n     \"permitted even if broker-wide limit is reached. The least recently used connection on another listener will be closed in this case.\"\n+  val MaxConnectionCreationRateDoc = \"The maximum connection creation rate we allow in the broker at any time. Listener-level limits \" +\n+    s\"may also be configured by prefixing the config name with the listener prefix, for example, <code>listener.name.internal.$MaxConnectionCreationRateProp</code>.\" +\n+    \"Broker-wide connection rate limit should be configured based on broker capacity while listener limits should be configured based on \" +\n+    \"application requirements. New connections will be throttled if either the listener or the broker limit is reached, with the exception \" +\n+    \" of inter-broker listener. Connections on the inter-broker listener will be throttled only when the listener-level rate limit is reached. \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5NTg2OA==", "bodyText": "A thread waiting here will be notified when a connection is closed (when dec is called). As connections in AK are long lived, couldn't we end up in a case where a connection is throttled for a longer period than the computed trottleTimeMs if no connection is closed in between?", "url": "https://github.com/apache/kafka/pull/8768#discussion_r433695868", "createdAt": "2020-06-02T08:08:56Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1256,11 +1272,17 @@ class ConnectionQuotas(config: KafkaConfig, time: Time) extends Logging {\n   private def waitForConnectionSlot(listenerName: ListenerName,\n                                     acceptorBlockedPercentMeter: com.yammer.metrics.core.Meter): Unit = {\n     counts.synchronized {\n-      if (!connectionSlotAvailable(listenerName)) {\n+      val startTimeMs = time.milliseconds()\n+      val throttleTimeMs = math.max(recordConnectionAndGetThrottleTimeMs(listenerName, startTimeMs), 0)\n+\n+      if (throttleTimeMs > 0 || !connectionSlotAvailable(listenerName)) {\n         val startNs = time.nanoseconds\n+        val endThrottleTimeMs = startTimeMs + throttleTimeMs\n+        var remainingThrottleTimeMs = throttleTimeMs\n         do {\n-          counts.wait()\n-        } while (!connectionSlotAvailable(listenerName))\n+          counts.wait(remainingThrottleTimeMs)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5NjM3NA==", "bodyText": "nit: This variable is not really needed.", "url": "https://github.com/apache/kafka/pull/8768#discussion_r433696374", "createdAt": "2020-06-02T08:09:50Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1287,15 +1309,97 @@ class ConnectionQuotas(config: KafkaConfig, time: Time) extends Logging {\n   private def maxListenerConnections(listenerName: ListenerName): Int =\n     maxConnectionsPerListener.get(listenerName).map(_.maxConnections).getOrElse(Int.MaxValue)\n \n+  /**\n+   * Calculates the delay needed to bring the observed connection creation rate to listener-level limit or to broker-wide\n+   * limit, whichever the longest. The delay is capped to the quota window size defined by QuotaWindowSizeSecondsProp\n+   *\n+   * @param listenerName listener for which calculate the delay\n+   * @param timeMs current time in milliseconds\n+   * @return delay in milliseconds\n+   */\n+  private def recordConnectionAndGetThrottleTimeMs(listenerName: ListenerName, timeMs: Long): Long = {\n+    val listenerThrottleTimeMs = maxConnectionsPerListener\n+      .get(listenerName)\n+      .map(listenerQuota => recordAndGetThrottleTimeMs(listenerQuota.connectionRateSensor, timeMs))\n+      .getOrElse(0)\n+\n+    if (protectedListener(listenerName)) {\n+      listenerThrottleTimeMs\n+    } else {\n+      val brokerThrottleTimeMs = recordAndGetThrottleTimeMs(brokerConnectionRateSensor, timeMs)\n+      val throttleTimeMs = math.max(brokerThrottleTimeMs, listenerThrottleTimeMs)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcwMDgxOQ==", "bodyText": "nit: () can be removed after value.", "url": "https://github.com/apache/kafka/pull/8768#discussion_r433700819", "createdAt": "2020-06-02T08:17:24Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1306,18 +1410,26 @@ class ConnectionQuotas(config: KafkaConfig, time: Time) extends Logging {\n       val value = maxConnections(configs)\n       if (value <= 0)\n         throw new ConfigException(\"Invalid max.connections $listenerMax\")\n+\n+      val rate = maxConnectionCreationRate(configs)\n+      if (rate <= 0)\n+        throw new ConfigException(s\"Invalid ${KafkaConfig.MaxConnectionCreationRateProp} $rate\")\n     }\n \n     override def reconfigure(configs: util.Map[String, _]): Unit = {\n       lock.synchronized {\n         _maxConnections = maxConnections(configs)\n+        updateConnectionRateQuota(maxConnectionCreationRate(configs), Some(listener.value()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcwMTAxOA==", "bodyText": "nit: I would put an empty line before declaring the method.", "url": "https://github.com/apache/kafka/pull/8768#discussion_r433701018", "createdAt": "2020-06-02T08:17:46Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1306,18 +1410,26 @@ class ConnectionQuotas(config: KafkaConfig, time: Time) extends Logging {\n       val value = maxConnections(configs)\n       if (value <= 0)\n         throw new ConfigException(\"Invalid max.connections $listenerMax\")\n+\n+      val rate = maxConnectionCreationRate(configs)\n+      if (rate <= 0)\n+        throw new ConfigException(s\"Invalid ${KafkaConfig.MaxConnectionCreationRateProp} $rate\")\n     }\n \n     override def reconfigure(configs: util.Map[String, _]): Unit = {\n       lock.synchronized {\n         _maxConnections = maxConnections(configs)\n+        updateConnectionRateQuota(maxConnectionCreationRate(configs), Some(listener.value()))\n         lock.notifyAll()\n       }\n     }\n \n     private def maxConnections(configs: util.Map[String, _]): Int = {\n       Option(configs.get(KafkaConfig.MaxConnectionsProp)).map(_.toString.toInt).getOrElse(Int.MaxValue)\n     }\n+    private def maxConnectionCreationRate(configs: util.Map[String, _]): Int = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcwNTA3Nw==", "bodyText": "Wouldn't it make sense to expose the metrics? I think that they could be useful to know if connections are throttled at the broker or at the listener level, no? Moreover, the number of metrics is small so it should not hurt.", "url": "https://github.com/apache/kafka/pull/8768#discussion_r433705077", "createdAt": "2020-06-02T08:24:47Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1287,15 +1309,97 @@ class ConnectionQuotas(config: KafkaConfig, time: Time) extends Logging {\n   private def maxListenerConnections(listenerName: ListenerName): Int =\n     maxConnectionsPerListener.get(listenerName).map(_.maxConnections).getOrElse(Int.MaxValue)\n \n+  /**\n+   * Calculates the delay needed to bring the observed connection creation rate to listener-level limit or to broker-wide\n+   * limit, whichever the longest. The delay is capped to the quota window size defined by QuotaWindowSizeSecondsProp\n+   *\n+   * @param listenerName listener for which calculate the delay\n+   * @param timeMs current time in milliseconds\n+   * @return delay in milliseconds\n+   */\n+  private def recordConnectionAndGetThrottleTimeMs(listenerName: ListenerName, timeMs: Long): Long = {\n+    val listenerThrottleTimeMs = maxConnectionsPerListener\n+      .get(listenerName)\n+      .map(listenerQuota => recordAndGetThrottleTimeMs(listenerQuota.connectionRateSensor, timeMs))\n+      .getOrElse(0)\n+\n+    if (protectedListener(listenerName)) {\n+      listenerThrottleTimeMs\n+    } else {\n+      val brokerThrottleTimeMs = recordAndGetThrottleTimeMs(brokerConnectionRateSensor, timeMs)\n+      val throttleTimeMs = math.max(brokerThrottleTimeMs, listenerThrottleTimeMs)\n+      throttleTimeMs\n+    }\n+  }\n+\n+  private def recordAndGetThrottleTimeMs(sensor: Sensor, timeMs: Long): Int = {\n+    try {\n+      sensor.record(1.0, timeMs)\n+      0\n+    } catch {\n+      case e: QuotaViolationException =>\n+        val throttleTimeMs = QuotaUtils.boundedThrottleTime(\n+          e.value, e.bound, QuotaUtils.rateMetricWindowSize(e.metric, timeMs), maxThrottleTimeMs).toInt\n+        debug(s\"Quota violated for sensor (${sensor.name}). Delay time: $throttleTimeMs ms\")\n+        throttleTimeMs\n+    }\n+  }\n+\n+  /**\n+   * Creates sensor for tracking the connection creation rate and corresponding connection rate quota for a given\n+   * listener or broker-wide, if listener is not provided.\n+   * @param quotaLimit connection creation rate quota\n+   * @param listenerOpt listener name if sensor is for a listener\n+   */\n+  private def createConnectionRateQuotaSensor(quotaLimit: Int, listenerOpt: Option[String] = None): Sensor = {\n+    val quotaEntity = listenerOpt.getOrElse(\"broker\")\n+    val sensor = metrics.sensor(s\"ConnectionCreationRate-$quotaEntity\", rateQuotaMetricConfig(quotaLimit))\n+    sensor.add(connectionRateMetricName(listenerOpt), new Rate)\n+    info(s\"Created ConnectionCreationRate-$quotaEntity sensor, quotaLimit=$quotaLimit\")\n+    sensor\n+  }\n+\n+  private def updateConnectionRateQuota(quotaLimit: Int, listenerOpt: Option[String] = None): Unit = {\n+    val metric = metrics.metric(connectionRateMetricName((listenerOpt)))\n+    metric.config(rateQuotaMetricConfig(quotaLimit))\n+    info(s\"Updated ${listenerOpt.getOrElse(\"broker\")} max connection creation rate to $quotaLimit\")\n+  }\n+\n+  private def connectionRateMetricName(listenerOpt: Option[String]): MetricName = {\n+    val quotaEntity = listenerOpt.getOrElse(\"broker\")\n+    metrics.metricName(\n+      s\"connection-creation-rate-$quotaEntity\",\n+      \"connection-quota-no-jmx\",\n+      s\"Tracking $quotaEntity connection creation rate\",\n+      rateQuotaMetricTags(listenerOpt))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcxNTI5Nw==", "bodyText": "nit: Could we define a val for 7 and reuse it bellow as well?", "url": "https://github.com/apache/kafka/pull/8768#discussion_r433715297", "createdAt": "2020-06-02T08:41:51Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/integration/kafka/network/DynamicConnectionQuotaTest.scala", "diffHunk": "@@ -163,13 +167,65 @@ class DynamicConnectionQuotaTest extends BaseRequestTest {\n     TestUtils.waitUntilTrue(() => initialConnectionCount == connectionCount, \"Connections not closed\")\n   }\n \n+  @Test\n+  def testDynamicListenerConnectionCreationRateQuota(): Unit = {\n+    // Create another listener. PLAINTEXT is an inter-broker listener\n+    // keep default limits\n+    val newListenerNames = Seq(\"PLAINTEXT\", \"EXTERNAL\")\n+    val newListeners = \"PLAINTEXT://localhost:0,EXTERNAL://localhost:0\"\n+    val props = new Properties\n+    props.put(KafkaConfig.ListenersProp, newListeners)\n+    props.put(KafkaConfig.ListenerSecurityProtocolMapProp, \"PLAINTEXT:PLAINTEXT,EXTERNAL:PLAINTEXT\")\n+    reconfigureServers(props, perBrokerConfig = true, (KafkaConfig.ListenersProp, newListeners))\n+    waitForListener(\"EXTERNAL\")\n+\n+    // new broker-wide connection rate limit\n+    val connRateLimit = 18\n+\n+    // before setting connection rate to 10, verify we can do at least double that by default (no limit)\n+    verifyConnectionRate(2 * connRateLimit, Int.MaxValue, \"PLAINTEXT\")\n+\n+    // Reduce total broker connection rate limit to 10 at the cluster level and verify the limit is enforced\n+    props.clear()  // so that we do not pass security protocol map which cannot be set at the cluster level\n+    props.put(KafkaConfig.MaxConnectionCreationRateProp, connRateLimit.toString)\n+    reconfigureServers(props, perBrokerConfig = false, (KafkaConfig.MaxConnectionCreationRateProp, connRateLimit.toString))\n+    verifyConnectionRate(10, connRateLimit, \"PLAINTEXT\")\n+\n+    // Set 7 conn/sec rate limit for each listener and verify it gets enforced\n+    val plaintextListenerProp = s\"${listener.configPrefix}${KafkaConfig.MaxConnectionCreationRateProp}\"\n+    props.put(s\"listener.name.external.${KafkaConfig.MaxConnectionCreationRateProp}\", \"7\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 41}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNDQ4NzM4", "url": "https://github.com/apache/kafka/pull/8768#pullrequestreview-430448738", "createdAt": "2020-06-15T08:57:24Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwODo1NzoyNFrOGjpNDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMjozMzozMVrOGjwLBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyODQyOQ==", "bodyText": "Thinking a bit more about this, did you consider adding the flag to MetricConfig? It may be a bit simpler and cleaner as it avoids having to add the flag to all the methods. What do you think?", "url": "https://github.com/apache/kafka/pull/8768#discussion_r440028429", "createdAt": "2020-06-15T08:57:24Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/common/metrics/Metrics.java", "diffHunk": "@@ -572,16 +572,18 @@ public synchronized void removeReporter(MetricsReporter reporter) {\n         }\n     }\n \n-    synchronized void registerMetric(KafkaMetric metric) {\n+    synchronized void registerMetric(KafkaMetric metric, boolean report) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyOTQxMw==", "bodyText": "Thanks for the clarification. I am sorry but I misread the code the first time.", "url": "https://github.com/apache/kafka/pull/8768#discussion_r440029413", "createdAt": "2020-06-15T08:58:57Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1256,11 +1272,17 @@ class ConnectionQuotas(config: KafkaConfig, time: Time) extends Logging {\n   private def waitForConnectionSlot(listenerName: ListenerName,\n                                     acceptorBlockedPercentMeter: com.yammer.metrics.core.Meter): Unit = {\n     counts.synchronized {\n-      if (!connectionSlotAvailable(listenerName)) {\n+      val startTimeMs = time.milliseconds()\n+      val throttleTimeMs = math.max(recordConnectionAndGetThrottleTimeMs(listenerName, startTimeMs), 0)\n+\n+      if (throttleTimeMs > 0 || !connectionSlotAvailable(listenerName)) {\n         val startNs = time.nanoseconds\n+        val endThrottleTimeMs = startTimeMs + throttleTimeMs\n+        var remainingThrottleTimeMs = throttleTimeMs\n         do {\n-          counts.wait()\n-        } while (!connectionSlotAvailable(listenerName))\n+          counts.wait(remainingThrottleTimeMs)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY5NTg2OA=="}, "originalCommit": null, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAzMjk0Mw==", "bodyText": "nit: () can be omitted here.", "url": "https://github.com/apache/kafka/pull/8768#discussion_r440032943", "createdAt": "2020-06-15T09:04:53Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1258,11 +1274,17 @@ class ConnectionQuotas(config: KafkaConfig, time: Time) extends Logging {\n   private def waitForConnectionSlot(listenerName: ListenerName,\n                                     acceptorBlockedPercentMeter: com.yammer.metrics.core.Meter): Unit = {\n     counts.synchronized {\n-      if (!connectionSlotAvailable(listenerName)) {\n+      val startTimeMs = time.milliseconds()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAzNjg2MA==", "bodyText": "It is a bit confusing to have startTimeMs and startNs defined few lines apart. Is it worth renaming startTimeMs to startThrottleTimeMs to clearly state that this is used as part of the throttle time computing. It would also be consistent with endThrottleTimeMs.", "url": "https://github.com/apache/kafka/pull/8768#discussion_r440036860", "createdAt": "2020-06-15T09:11:39Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1258,11 +1274,17 @@ class ConnectionQuotas(config: KafkaConfig, time: Time) extends Logging {\n   private def waitForConnectionSlot(listenerName: ListenerName,\n                                     acceptorBlockedPercentMeter: com.yammer.metrics.core.Meter): Unit = {\n     counts.synchronized {\n-      if (!connectionSlotAvailable(listenerName)) {\n+      val startTimeMs = time.milliseconds()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAzMjk0Mw=="}, "originalCommit": null, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA0NjUxNg==", "bodyText": "What about returning Collections.emptyMap when listenerOpt is not defined and using Collections.singletonMap when it is?", "url": "https://github.com/apache/kafka/pull/8768#discussion_r440046516", "createdAt": "2020-06-15T09:27:49Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1289,15 +1311,95 @@ class ConnectionQuotas(config: KafkaConfig, time: Time) extends Logging {\n   private def maxListenerConnections(listenerName: ListenerName): Int =\n     maxConnectionsPerListener.get(listenerName).map(_.maxConnections).getOrElse(Int.MaxValue)\n \n+  /**\n+   * Calculates the delay needed to bring the observed connection creation rate to listener-level limit or to broker-wide\n+   * limit, whichever the longest. The delay is capped to the quota window size defined by QuotaWindowSizeSecondsProp\n+   *\n+   * @param listenerName listener for which calculate the delay\n+   * @param timeMs current time in milliseconds\n+   * @return delay in milliseconds\n+   */\n+  private def recordConnectionAndGetThrottleTimeMs(listenerName: ListenerName, timeMs: Long): Long = {\n+    val listenerThrottleTimeMs = maxConnectionsPerListener\n+      .get(listenerName)\n+      .map(listenerQuota => recordAndGetThrottleTimeMs(listenerQuota.connectionRateSensor, timeMs))\n+      .getOrElse(0)\n+\n+    if (protectedListener(listenerName)) {\n+      listenerThrottleTimeMs\n+    } else {\n+      val brokerThrottleTimeMs = recordAndGetThrottleTimeMs(brokerConnectionRateSensor, timeMs)\n+      math.max(brokerThrottleTimeMs, listenerThrottleTimeMs)\n+    }\n+  }\n+\n+  private def recordAndGetThrottleTimeMs(sensor: Sensor, timeMs: Long): Int = {\n+    try {\n+      sensor.record(1.0, timeMs)\n+      0\n+    } catch {\n+      case e: QuotaViolationException =>\n+        val throttleTimeMs = QuotaUtils.boundedThrottleTime(\n+          e.value, e.bound, QuotaUtils.rateMetricWindowSize(e.metric, timeMs), maxThrottleTimeMs).toInt\n+        debug(s\"Quota violated for sensor (${sensor.name}). Delay time: $throttleTimeMs ms\")\n+        throttleTimeMs\n+    }\n+  }\n+\n+  /**\n+   * Creates sensor for tracking the connection creation rate and corresponding connection rate quota for a given\n+   * listener or broker-wide, if listener is not provided.\n+   * @param quotaLimit connection creation rate quota\n+   * @param listenerOpt listener name if sensor is for a listener\n+   */\n+  private def createConnectionRateQuotaSensor(quotaLimit: Int, listenerOpt: Option[String] = None): Sensor = {\n+    val quotaEntity = listenerOpt.getOrElse(\"broker\")\n+    val sensor = metrics.sensor(s\"ConnectionCreationRate-$quotaEntity\", rateQuotaMetricConfig(quotaLimit))\n+    sensor.add(connectionRateMetricName(listenerOpt), new Rate, null, false)\n+    info(s\"Created ConnectionCreationRate-$quotaEntity sensor, quotaLimit=$quotaLimit\")\n+    sensor\n+  }\n+\n+  private def updateConnectionRateQuota(quotaLimit: Int, listenerOpt: Option[String] = None): Unit = {\n+    val metric = metrics.metric(connectionRateMetricName((listenerOpt)))\n+    metric.config(rateQuotaMetricConfig(quotaLimit))\n+    info(s\"Updated ${listenerOpt.getOrElse(\"broker\")} max connection creation rate to $quotaLimit\")\n+  }\n+\n+  private def connectionRateMetricName(listenerOpt: Option[String]): MetricName = {\n+    val quotaEntity = listenerOpt.getOrElse(\"broker\")\n+    metrics.metricName(\n+      s\"connection-creation-rate-$quotaEntity\",\n+      \"connection-quota-no-jmx\",\n+      s\"Tracking $quotaEntity connection creation rate\",\n+      rateQuotaMetricTags(listenerOpt))\n+  }\n+\n+  private def rateQuotaMetricConfig(quotaLimit: Int): MetricConfig = {\n+    new MetricConfig()\n+      .timeWindow(config.quotaWindowSizeSeconds.toLong, TimeUnit.SECONDS)\n+      .samples(config.numQuotaSamples)\n+      .quota(new Quota(quotaLimit, true))\n+  }\n+\n+  private def rateQuotaMetricTags(listenerOpt: Option[String]): util.Map[String, String] = {\n+    val tags = new util.LinkedHashMap[String, String]\n+    listenerOpt.foreach(listener => tags.put(\"listener\", listener))\n+    tags", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA0Njc2MQ==", "bodyText": "nit: I would rename this one now.", "url": "https://github.com/apache/kafka/pull/8768#discussion_r440046761", "createdAt": "2020-06-15T09:28:16Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1289,15 +1311,95 @@ class ConnectionQuotas(config: KafkaConfig, time: Time) extends Logging {\n   private def maxListenerConnections(listenerName: ListenerName): Int =\n     maxConnectionsPerListener.get(listenerName).map(_.maxConnections).getOrElse(Int.MaxValue)\n \n+  /**\n+   * Calculates the delay needed to bring the observed connection creation rate to listener-level limit or to broker-wide\n+   * limit, whichever the longest. The delay is capped to the quota window size defined by QuotaWindowSizeSecondsProp\n+   *\n+   * @param listenerName listener for which calculate the delay\n+   * @param timeMs current time in milliseconds\n+   * @return delay in milliseconds\n+   */\n+  private def recordConnectionAndGetThrottleTimeMs(listenerName: ListenerName, timeMs: Long): Long = {\n+    val listenerThrottleTimeMs = maxConnectionsPerListener\n+      .get(listenerName)\n+      .map(listenerQuota => recordAndGetThrottleTimeMs(listenerQuota.connectionRateSensor, timeMs))\n+      .getOrElse(0)\n+\n+    if (protectedListener(listenerName)) {\n+      listenerThrottleTimeMs\n+    } else {\n+      val brokerThrottleTimeMs = recordAndGetThrottleTimeMs(brokerConnectionRateSensor, timeMs)\n+      math.max(brokerThrottleTimeMs, listenerThrottleTimeMs)\n+    }\n+  }\n+\n+  private def recordAndGetThrottleTimeMs(sensor: Sensor, timeMs: Long): Int = {\n+    try {\n+      sensor.record(1.0, timeMs)\n+      0\n+    } catch {\n+      case e: QuotaViolationException =>\n+        val throttleTimeMs = QuotaUtils.boundedThrottleTime(\n+          e.value, e.bound, QuotaUtils.rateMetricWindowSize(e.metric, timeMs), maxThrottleTimeMs).toInt\n+        debug(s\"Quota violated for sensor (${sensor.name}). Delay time: $throttleTimeMs ms\")\n+        throttleTimeMs\n+    }\n+  }\n+\n+  /**\n+   * Creates sensor for tracking the connection creation rate and corresponding connection rate quota for a given\n+   * listener or broker-wide, if listener is not provided.\n+   * @param quotaLimit connection creation rate quota\n+   * @param listenerOpt listener name if sensor is for a listener\n+   */\n+  private def createConnectionRateQuotaSensor(quotaLimit: Int, listenerOpt: Option[String] = None): Sensor = {\n+    val quotaEntity = listenerOpt.getOrElse(\"broker\")\n+    val sensor = metrics.sensor(s\"ConnectionCreationRate-$quotaEntity\", rateQuotaMetricConfig(quotaLimit))\n+    sensor.add(connectionRateMetricName(listenerOpt), new Rate, null, false)\n+    info(s\"Created ConnectionCreationRate-$quotaEntity sensor, quotaLimit=$quotaLimit\")\n+    sensor\n+  }\n+\n+  private def updateConnectionRateQuota(quotaLimit: Int, listenerOpt: Option[String] = None): Unit = {\n+    val metric = metrics.metric(connectionRateMetricName((listenerOpt)))\n+    metric.config(rateQuotaMetricConfig(quotaLimit))\n+    info(s\"Updated ${listenerOpt.getOrElse(\"broker\")} max connection creation rate to $quotaLimit\")\n+  }\n+\n+  private def connectionRateMetricName(listenerOpt: Option[String]): MetricName = {\n+    val quotaEntity = listenerOpt.getOrElse(\"broker\")\n+    metrics.metricName(\n+      s\"connection-creation-rate-$quotaEntity\",\n+      \"connection-quota-no-jmx\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA0Njg4NQ==", "bodyText": "Ack. I did not know this.", "url": "https://github.com/apache/kafka/pull/8768#discussion_r440046885", "createdAt": "2020-06-15T09:28:30Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1287,15 +1309,97 @@ class ConnectionQuotas(config: KafkaConfig, time: Time) extends Logging {\n   private def maxListenerConnections(listenerName: ListenerName): Int =\n     maxConnectionsPerListener.get(listenerName).map(_.maxConnections).getOrElse(Int.MaxValue)\n \n+  /**\n+   * Calculates the delay needed to bring the observed connection creation rate to listener-level limit or to broker-wide\n+   * limit, whichever the longest. The delay is capped to the quota window size defined by QuotaWindowSizeSecondsProp\n+   *\n+   * @param listenerName listener for which calculate the delay\n+   * @param timeMs current time in milliseconds\n+   * @return delay in milliseconds\n+   */\n+  private def recordConnectionAndGetThrottleTimeMs(listenerName: ListenerName, timeMs: Long): Long = {\n+    val listenerThrottleTimeMs = maxConnectionsPerListener\n+      .get(listenerName)\n+      .map(listenerQuota => recordAndGetThrottleTimeMs(listenerQuota.connectionRateSensor, timeMs))\n+      .getOrElse(0)\n+\n+    if (protectedListener(listenerName)) {\n+      listenerThrottleTimeMs\n+    } else {\n+      val brokerThrottleTimeMs = recordAndGetThrottleTimeMs(brokerConnectionRateSensor, timeMs)\n+      val throttleTimeMs = math.max(brokerThrottleTimeMs, listenerThrottleTimeMs)\n+      throttleTimeMs\n+    }\n+  }\n+\n+  private def recordAndGetThrottleTimeMs(sensor: Sensor, timeMs: Long): Int = {\n+    try {\n+      sensor.record(1.0, timeMs)\n+      0\n+    } catch {\n+      case e: QuotaViolationException =>\n+        val throttleTimeMs = QuotaUtils.boundedThrottleTime(\n+          e.value, e.bound, QuotaUtils.rateMetricWindowSize(e.metric, timeMs), maxThrottleTimeMs).toInt\n+        debug(s\"Quota violated for sensor (${sensor.name}). Delay time: $throttleTimeMs ms\")\n+        throttleTimeMs\n+    }\n+  }\n+\n+  /**\n+   * Creates sensor for tracking the connection creation rate and corresponding connection rate quota for a given\n+   * listener or broker-wide, if listener is not provided.\n+   * @param quotaLimit connection creation rate quota\n+   * @param listenerOpt listener name if sensor is for a listener\n+   */\n+  private def createConnectionRateQuotaSensor(quotaLimit: Int, listenerOpt: Option[String] = None): Sensor = {\n+    val quotaEntity = listenerOpt.getOrElse(\"broker\")\n+    val sensor = metrics.sensor(s\"ConnectionCreationRate-$quotaEntity\", rateQuotaMetricConfig(quotaLimit))\n+    sensor.add(connectionRateMetricName(listenerOpt), new Rate)\n+    info(s\"Created ConnectionCreationRate-$quotaEntity sensor, quotaLimit=$quotaLimit\")\n+    sensor\n+  }\n+\n+  private def updateConnectionRateQuota(quotaLimit: Int, listenerOpt: Option[String] = None): Unit = {\n+    val metric = metrics.metric(connectionRateMetricName((listenerOpt)))\n+    metric.config(rateQuotaMetricConfig(quotaLimit))\n+    info(s\"Updated ${listenerOpt.getOrElse(\"broker\")} max connection creation rate to $quotaLimit\")\n+  }\n+\n+  private def connectionRateMetricName(listenerOpt: Option[String]): MetricName = {\n+    val quotaEntity = listenerOpt.getOrElse(\"broker\")\n+    metrics.metricName(\n+      s\"connection-creation-rate-$quotaEntity\",\n+      \"connection-quota-no-jmx\",\n+      s\"Tracking $quotaEntity connection creation rate\",\n+      rateQuotaMetricTags(listenerOpt))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcwNTA3Nw=="}, "originalCommit": null, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA1MTU5Ng==", "bodyText": "nit: Are the parenthesis around listenerOpt really necessary?", "url": "https://github.com/apache/kafka/pull/8768#discussion_r440051596", "createdAt": "2020-06-15T09:36:47Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1289,15 +1311,95 @@ class ConnectionQuotas(config: KafkaConfig, time: Time) extends Logging {\n   private def maxListenerConnections(listenerName: ListenerName): Int =\n     maxConnectionsPerListener.get(listenerName).map(_.maxConnections).getOrElse(Int.MaxValue)\n \n+  /**\n+   * Calculates the delay needed to bring the observed connection creation rate to listener-level limit or to broker-wide\n+   * limit, whichever the longest. The delay is capped to the quota window size defined by QuotaWindowSizeSecondsProp\n+   *\n+   * @param listenerName listener for which calculate the delay\n+   * @param timeMs current time in milliseconds\n+   * @return delay in milliseconds\n+   */\n+  private def recordConnectionAndGetThrottleTimeMs(listenerName: ListenerName, timeMs: Long): Long = {\n+    val listenerThrottleTimeMs = maxConnectionsPerListener\n+      .get(listenerName)\n+      .map(listenerQuota => recordAndGetThrottleTimeMs(listenerQuota.connectionRateSensor, timeMs))\n+      .getOrElse(0)\n+\n+    if (protectedListener(listenerName)) {\n+      listenerThrottleTimeMs\n+    } else {\n+      val brokerThrottleTimeMs = recordAndGetThrottleTimeMs(brokerConnectionRateSensor, timeMs)\n+      math.max(brokerThrottleTimeMs, listenerThrottleTimeMs)\n+    }\n+  }\n+\n+  private def recordAndGetThrottleTimeMs(sensor: Sensor, timeMs: Long): Int = {\n+    try {\n+      sensor.record(1.0, timeMs)\n+      0\n+    } catch {\n+      case e: QuotaViolationException =>\n+        val throttleTimeMs = QuotaUtils.boundedThrottleTime(\n+          e.value, e.bound, QuotaUtils.rateMetricWindowSize(e.metric, timeMs), maxThrottleTimeMs).toInt\n+        debug(s\"Quota violated for sensor (${sensor.name}). Delay time: $throttleTimeMs ms\")\n+        throttleTimeMs\n+    }\n+  }\n+\n+  /**\n+   * Creates sensor for tracking the connection creation rate and corresponding connection rate quota for a given\n+   * listener or broker-wide, if listener is not provided.\n+   * @param quotaLimit connection creation rate quota\n+   * @param listenerOpt listener name if sensor is for a listener\n+   */\n+  private def createConnectionRateQuotaSensor(quotaLimit: Int, listenerOpt: Option[String] = None): Sensor = {\n+    val quotaEntity = listenerOpt.getOrElse(\"broker\")\n+    val sensor = metrics.sensor(s\"ConnectionCreationRate-$quotaEntity\", rateQuotaMetricConfig(quotaLimit))\n+    sensor.add(connectionRateMetricName(listenerOpt), new Rate, null, false)\n+    info(s\"Created ConnectionCreationRate-$quotaEntity sensor, quotaLimit=$quotaLimit\")\n+    sensor\n+  }\n+\n+  private def updateConnectionRateQuota(quotaLimit: Int, listenerOpt: Option[String] = None): Unit = {\n+    val metric = metrics.metric(connectionRateMetricName((listenerOpt)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA1MjUwNA==", "bodyText": "nit: As the quotaEntity is also computed by the caller methods, would it make sense to pass it as an argument to connectionRateMetricName?", "url": "https://github.com/apache/kafka/pull/8768#discussion_r440052504", "createdAt": "2020-06-15T09:38:22Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1289,15 +1311,95 @@ class ConnectionQuotas(config: KafkaConfig, time: Time) extends Logging {\n   private def maxListenerConnections(listenerName: ListenerName): Int =\n     maxConnectionsPerListener.get(listenerName).map(_.maxConnections).getOrElse(Int.MaxValue)\n \n+  /**\n+   * Calculates the delay needed to bring the observed connection creation rate to listener-level limit or to broker-wide\n+   * limit, whichever the longest. The delay is capped to the quota window size defined by QuotaWindowSizeSecondsProp\n+   *\n+   * @param listenerName listener for which calculate the delay\n+   * @param timeMs current time in milliseconds\n+   * @return delay in milliseconds\n+   */\n+  private def recordConnectionAndGetThrottleTimeMs(listenerName: ListenerName, timeMs: Long): Long = {\n+    val listenerThrottleTimeMs = maxConnectionsPerListener\n+      .get(listenerName)\n+      .map(listenerQuota => recordAndGetThrottleTimeMs(listenerQuota.connectionRateSensor, timeMs))\n+      .getOrElse(0)\n+\n+    if (protectedListener(listenerName)) {\n+      listenerThrottleTimeMs\n+    } else {\n+      val brokerThrottleTimeMs = recordAndGetThrottleTimeMs(brokerConnectionRateSensor, timeMs)\n+      math.max(brokerThrottleTimeMs, listenerThrottleTimeMs)\n+    }\n+  }\n+\n+  private def recordAndGetThrottleTimeMs(sensor: Sensor, timeMs: Long): Int = {\n+    try {\n+      sensor.record(1.0, timeMs)\n+      0\n+    } catch {\n+      case e: QuotaViolationException =>\n+        val throttleTimeMs = QuotaUtils.boundedThrottleTime(\n+          e.value, e.bound, QuotaUtils.rateMetricWindowSize(e.metric, timeMs), maxThrottleTimeMs).toInt\n+        debug(s\"Quota violated for sensor (${sensor.name}). Delay time: $throttleTimeMs ms\")\n+        throttleTimeMs\n+    }\n+  }\n+\n+  /**\n+   * Creates sensor for tracking the connection creation rate and corresponding connection rate quota for a given\n+   * listener or broker-wide, if listener is not provided.\n+   * @param quotaLimit connection creation rate quota\n+   * @param listenerOpt listener name if sensor is for a listener\n+   */\n+  private def createConnectionRateQuotaSensor(quotaLimit: Int, listenerOpt: Option[String] = None): Sensor = {\n+    val quotaEntity = listenerOpt.getOrElse(\"broker\")\n+    val sensor = metrics.sensor(s\"ConnectionCreationRate-$quotaEntity\", rateQuotaMetricConfig(quotaLimit))\n+    sensor.add(connectionRateMetricName(listenerOpt), new Rate, null, false)\n+    info(s\"Created ConnectionCreationRate-$quotaEntity sensor, quotaLimit=$quotaLimit\")\n+    sensor\n+  }\n+\n+  private def updateConnectionRateQuota(quotaLimit: Int, listenerOpt: Option[String] = None): Unit = {\n+    val metric = metrics.metric(connectionRateMetricName((listenerOpt)))\n+    metric.config(rateQuotaMetricConfig(quotaLimit))\n+    info(s\"Updated ${listenerOpt.getOrElse(\"broker\")} max connection creation rate to $quotaLimit\")\n+  }\n+\n+  private def connectionRateMetricName(listenerOpt: Option[String]): MetricName = {\n+    val quotaEntity = listenerOpt.getOrElse(\"broker\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA1NTk5Mg==", "bodyText": "Not related to your PR but it seems that listenerMax is never defined. I think that value should be used instead here. Could you fix this? Could you also use MaxConnectionsProp instead of max.connections as you did for the other already?", "url": "https://github.com/apache/kafka/pull/8768#discussion_r440055992", "createdAt": "2020-06-15T09:44:10Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1308,18 +1410,27 @@ class ConnectionQuotas(config: KafkaConfig, time: Time) extends Logging {\n       val value = maxConnections(configs)\n       if (value <= 0)\n         throw new ConfigException(\"Invalid max.connections $listenerMax\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExNjE4Mw==", "bodyText": "to 18?", "url": "https://github.com/apache/kafka/pull/8768#discussion_r440116183", "createdAt": "2020-06-15T11:42:32Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/integration/kafka/network/DynamicConnectionQuotaTest.scala", "diffHunk": "@@ -163,13 +167,66 @@ class DynamicConnectionQuotaTest extends BaseRequestTest {\n     TestUtils.waitUntilTrue(() => initialConnectionCount == connectionCount, \"Connections not closed\")\n   }\n \n+  @Test\n+  def testDynamicListenerConnectionCreationRateQuota(): Unit = {\n+    // Create another listener. PLAINTEXT is an inter-broker listener\n+    // keep default limits\n+    val newListenerNames = Seq(\"PLAINTEXT\", \"EXTERNAL\")\n+    val newListeners = \"PLAINTEXT://localhost:0,EXTERNAL://localhost:0\"\n+    val props = new Properties\n+    props.put(KafkaConfig.ListenersProp, newListeners)\n+    props.put(KafkaConfig.ListenerSecurityProtocolMapProp, \"PLAINTEXT:PLAINTEXT,EXTERNAL:PLAINTEXT\")\n+    reconfigureServers(props, perBrokerConfig = true, (KafkaConfig.ListenersProp, newListeners))\n+    waitForListener(\"EXTERNAL\")\n+\n+    // new broker-wide connection rate limit\n+    val connRateLimit = 18\n+\n+    // before setting connection rate to 10, verify we can do at least double that by default (no limit)\n+    verifyConnectionRate(2 * connRateLimit, Int.MaxValue, \"PLAINTEXT\")\n+\n+    // Reduce total broker connection rate limit to 10 at the cluster level and verify the limit is enforced", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEyOTgyOQ==", "bodyText": "Can't we use assertTrue here to simplify?", "url": "https://github.com/apache/kafka/pull/8768#discussion_r440129829", "createdAt": "2020-06-15T12:09:34Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/network/ConnectionQuotasTest.scala", "diffHunk": "@@ -329,15 +613,46 @@ class ConnectionQuotasTest {\n   }\n \n   // this method must be called on a separate thread, because connectionQuotas.inc() may block\n+  private def acceptConnectionsAndVerifyRate(connectionQuotas: ConnectionQuotas,\n+                                             listenerDesc: ListenerDesc,\n+                                             numConnections: Long,\n+                                             timeIntervalMs: Long,\n+                                             expectedRate: Int,\n+                                             epsilon: Int) : Unit = {\n+    val startTimeMs = System.currentTimeMillis\n+    acceptConnections(connectionQuotas, listenerDesc.listenerName, listenerDesc.defaultIp, numConnections, timeIntervalMs)\n+    val elapsedSeconds = TimeUnit.MILLISECONDS.toSeconds(System.currentTimeMillis - startTimeMs)\n+    val actualRate = (numConnections.toDouble / elapsedSeconds).toInt\n+    if (actualRate - epsilon > expectedRate || actualRate + epsilon < expectedRate)\n+      throw new TestFailedException(\n+        (e: StackDepthException) =>\n+          Some(s\"Expected rate $expectedRate, but got $actualRate ($numConnections connections / $elapsedSeconds sec)\"),\n+        None,\n+        Position.here)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 473}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEzNDM5Mw==", "bodyText": "I wonder if we could just check that the metric's config is correctly re-configured instead of testing the number of connections accepted. The goal of the test is not really to verify that the quota works but rather to ensure that metric is correctly re-configured. Have you considered this? The same would apply to testMaxBrokerConnectionRateReconfiguration.", "url": "https://github.com/apache/kafka/pull/8768#discussion_r440134393", "createdAt": "2020-06-15T12:18:08Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/network/ConnectionQuotasTest.scala", "diffHunk": "@@ -302,21 +312,295 @@ class ConnectionQuotasTest {\n       }\n       // all connections should get added\n       overLimitFutures.foreach(_.get(5, TimeUnit.SECONDS))\n-      listeners.values.foreach { listener =>\n-        assertEquals(s\"Number of connections on $listener:\",\n-          listenerMaxConnections, connectionQuotas.get(listener.defaultIp))\n+      verifyConnectionCountOnEveryListener(connectionQuotas, listenerMaxConnections)\n+    } finally {\n+      executor.shutdownNow()\n+    }\n+  }\n+\n+  @Test\n+  def testBrokerConnectionRateLimitWhenActualRateBelowLimit(): Unit = {\n+    val brokerRateLimit = 125\n+    val props = brokerPropsWithDefaultConnectionLimits\n+    props.put(KafkaConfig.MaxConnectionCreationRateProp, brokerRateLimit.toString)\n+    val config = KafkaConfig.fromProps(props)\n+    val connectionQuotas = new ConnectionQuotas(config, Time.SYSTEM, metrics)\n+\n+    addListenersAndVerify(config, connectionQuotas)\n+\n+    val executor = Executors.newFixedThreadPool(listeners.size)\n+    try {\n+      // create connections with the total rate < broker-wide quota, and verify there is no throttling\n+      val connCreateIntervalMs = 25 // connection creation rate = 40/sec per listener (3 * 40 = 120/sec total)\n+      val connectionsPerListener = 200 // should take 5 seconds to create 200 connections with rate = 40/sec\n+      val futures = listeners.values.map { listener =>\n+        executor.submit((() => acceptConnections(connectionQuotas, listener, connectionsPerListener, connCreateIntervalMs)): Runnable)\n       }\n+      futures.foreach(_.get(10, TimeUnit.SECONDS))\n+\n+      // the blocked percent should still be 0, because no limits were reached\n+      verifyNoBlockedPercentRecordedOnAllListeners()\n+      verifyConnectionCountOnEveryListener(connectionQuotas, connectionsPerListener)\n+    } finally {\n+      executor.shutdownNow()\n+    }\n+  }\n+\n+  @Test\n+  def testBrokerConnectionRateLimitWhenActualRateAboveLimit(): Unit = {\n+    val brokerRateLimit = 90\n+    val props = brokerPropsWithDefaultConnectionLimits\n+    props.put(KafkaConfig.MaxConnectionCreationRateProp, brokerRateLimit.toString)\n+    val config = KafkaConfig.fromProps(props)\n+    val connectionQuotas = new ConnectionQuotas(config, Time.SYSTEM, metrics)\n+\n+    addListenersAndVerify(config, connectionQuotas)\n+\n+    val executor = Executors.newFixedThreadPool(listeners.size)\n+    try {\n+      // each listener creates connections such that the total connection rate > broker-wide quota\n+      val connCreateIntervalMs = 10      // connection creation rate = 100\n+      val connectionsPerListener = 400\n+      val futures = listeners.values.map { listener =>\n+        executor.submit((() => acceptConnections(connectionQuotas, listener, connectionsPerListener, connCreateIntervalMs)): Runnable)\n+      }\n+      futures.foreach(_.get(20, TimeUnit.SECONDS))\n+\n+      // verify that connections on non-inter-broker listener are throttled\n+      verifyOnlyNonInterBrokerListenersBlockedPercentRecorded()\n+\n+      // expect all connections to be created (no limit on the number of connections)\n+      verifyConnectionCountOnEveryListener(connectionQuotas, connectionsPerListener)\n+    } finally {\n+      executor.shutdownNow()\n+    }\n+  }\n+\n+  @Test\n+  def testListenerConnectionRateLimitWhenActualRateBelowLimit(): Unit = {\n+    val brokerRateLimit = 125\n+    val listenerRateLimit = 50\n+    val connCreateIntervalMs = 25 // connection creation rate = 40/sec per listener (3 * 40 = 120/sec total)\n+    val props = brokerPropsWithDefaultConnectionLimits\n+    props.put(KafkaConfig.MaxConnectionCreationRateProp, brokerRateLimit.toString)\n+    val config = KafkaConfig.fromProps(props)\n+    val connectionQuotas = new ConnectionQuotas(config, Time.SYSTEM, metrics)\n+\n+    val listenerConfig = Map(KafkaConfig.MaxConnectionCreationRateProp -> listenerRateLimit.toString).asJava\n+    addListenersAndVerify(config, listenerConfig, connectionQuotas)\n+\n+    val executor = Executors.newFixedThreadPool(listeners.size)\n+    try {\n+      // create connections with the rate < listener quota on every listener, and verify there is no throttling\n+      val connectionsPerListener = 200 // should take 5 seconds to create 200 connections with rate = 40/sec\n+      val futures = listeners.values.map { listener =>\n+        executor.submit((() => acceptConnections(connectionQuotas, listener, connectionsPerListener, connCreateIntervalMs)): Runnable)\n+      }\n+      futures.foreach(_.get(10, TimeUnit.SECONDS))\n+\n+      // the blocked percent should still be 0, because no limits were reached\n+      verifyNoBlockedPercentRecordedOnAllListeners()\n+\n+      verifyConnectionCountOnEveryListener(connectionQuotas, connectionsPerListener)\n+    } finally {\n+      executor.shutdownNow()\n+    }\n+  }\n+\n+  @Test\n+  def testListenerConnectionRateLimitWhenActualRateAboveLimit(): Unit = {\n+    val brokerRateLimit = 125\n+    val listenerRateLimit = 30\n+    val connCreateIntervalMs = 25 // connection creation rate = 40/sec per listener (3 * 40 = 120/sec total)\n+    val props = brokerPropsWithDefaultConnectionLimits\n+    props.put(KafkaConfig.MaxConnectionCreationRateProp, brokerRateLimit.toString)\n+    val config = KafkaConfig.fromProps(props)\n+    val connectionQuotas = new ConnectionQuotas(config, Time.SYSTEM, metrics)\n+\n+    val listenerConfig = Map(KafkaConfig.MaxConnectionCreationRateProp -> listenerRateLimit.toString).asJava\n+    addListenersAndVerify(config, listenerConfig, connectionQuotas)\n+\n+    val executor = Executors.newFixedThreadPool(listeners.size)\n+    try {\n+      // create connections with the rate > listener quota on every listener\n+      // run a bit longer (20 seconds) to also verify the throttle rate\n+      val connectionsPerListener = 600 // should take 20 seconds to create 600 connections with rate = 30/sec\n+      val futures = listeners.values.map { listener =>\n+        executor.submit((() =>\n+          // epsilon is set to account for the worst-case where the measurement is taken just before or after the quota window\n+          acceptConnectionsAndVerifyRate(connectionQuotas, listener, connectionsPerListener, connCreateIntervalMs, listenerRateLimit, 5)): Runnable)\n+      }\n+      futures.foreach(_.get(30, TimeUnit.SECONDS))\n+\n+      // verify that every listener was throttled\n+      blockedPercentMeters.foreach { case (name, meter) =>\n+        assertTrue(s\"Expected BlockedPercentMeter metric for $name listener to be recorded\", meter.count() > 0)\n+      }\n+\n+      // while the connection creation rate was throttled,\n+      // expect all connections got created (not limit on the number of connections)\n+      verifyConnectionCountOnEveryListener(connectionQuotas, connectionsPerListener)\n+    } finally {\n+      executor.shutdownNow()\n+    }\n+  }\n+\n+  @Test\n+  def testMaxListenerConnectionListenerMustBeAboveZero(): Unit = {\n+    val config = KafkaConfig.fromProps(brokerPropsWithDefaultConnectionLimits)\n+    val connectionQuotas = new ConnectionQuotas(config, Time.SYSTEM, metrics)\n+\n+    connectionQuotas.addListener(config, listeners(\"EXTERNAL\").listenerName)\n+\n+    val maxListenerConnectionRate = 0\n+    val listenerConfig = Map(KafkaConfig.MaxConnectionCreationRateProp -> maxListenerConnectionRate.toString).asJava\n+    assertThrows[ConfigException] {\n+      connectionQuotas.maxConnectionsPerListener(listeners(\"EXTERNAL\").listenerName).validateReconfiguration(listenerConfig)\n+    }\n+  }\n+\n+  @Test\n+  def testMaxListenerConnectionRateReconfiguration(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 310}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEzNTU2Mw==", "bodyText": "I really like the explanation next to the constants! I would recommend to group all the constants in the beginning of the test case. That would help to get a quick overview of the test case.", "url": "https://github.com/apache/kafka/pull/8768#discussion_r440135563", "createdAt": "2020-06-15T12:20:25Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/network/ConnectionQuotasTest.scala", "diffHunk": "@@ -302,21 +312,295 @@ class ConnectionQuotasTest {\n       }\n       // all connections should get added\n       overLimitFutures.foreach(_.get(5, TimeUnit.SECONDS))\n-      listeners.values.foreach { listener =>\n-        assertEquals(s\"Number of connections on $listener:\",\n-          listenerMaxConnections, connectionQuotas.get(listener.defaultIp))\n+      verifyConnectionCountOnEveryListener(connectionQuotas, listenerMaxConnections)\n+    } finally {\n+      executor.shutdownNow()\n+    }\n+  }\n+\n+  @Test\n+  def testBrokerConnectionRateLimitWhenActualRateBelowLimit(): Unit = {\n+    val brokerRateLimit = 125\n+    val props = brokerPropsWithDefaultConnectionLimits\n+    props.put(KafkaConfig.MaxConnectionCreationRateProp, brokerRateLimit.toString)\n+    val config = KafkaConfig.fromProps(props)\n+    val connectionQuotas = new ConnectionQuotas(config, Time.SYSTEM, metrics)\n+\n+    addListenersAndVerify(config, connectionQuotas)\n+\n+    val executor = Executors.newFixedThreadPool(listeners.size)\n+    try {\n+      // create connections with the total rate < broker-wide quota, and verify there is no throttling\n+      val connCreateIntervalMs = 25 // connection creation rate = 40/sec per listener (3 * 40 = 120/sec total)\n+      val connectionsPerListener = 200 // should take 5 seconds to create 200 connections with rate = 40/sec", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE0MDE4Mw==", "bodyText": "nit: We could perhaps create a small help method like brokerProps that accepts a Map of customer configuration pairs and returns a KafkaConfig. That would reduce the boilerplate code.", "url": "https://github.com/apache/kafka/pull/8768#discussion_r440140183", "createdAt": "2020-06-15T12:28:59Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/network/ConnectionQuotasTest.scala", "diffHunk": "@@ -302,21 +312,295 @@ class ConnectionQuotasTest {\n       }\n       // all connections should get added\n       overLimitFutures.foreach(_.get(5, TimeUnit.SECONDS))\n-      listeners.values.foreach { listener =>\n-        assertEquals(s\"Number of connections on $listener:\",\n-          listenerMaxConnections, connectionQuotas.get(listener.defaultIp))\n+      verifyConnectionCountOnEveryListener(connectionQuotas, listenerMaxConnections)\n+    } finally {\n+      executor.shutdownNow()\n+    }\n+  }\n+\n+  @Test\n+  def testBrokerConnectionRateLimitWhenActualRateBelowLimit(): Unit = {\n+    val brokerRateLimit = 125\n+    val props = brokerPropsWithDefaultConnectionLimits\n+    props.put(KafkaConfig.MaxConnectionCreationRateProp, brokerRateLimit.toString)\n+    val config = KafkaConfig.fromProps(props)\n+    val connectionQuotas = new ConnectionQuotas(config, Time.SYSTEM, metrics)\n+\n+    addListenersAndVerify(config, connectionQuotas)\n+\n+    val executor = Executors.newFixedThreadPool(listeners.size)\n+    try {\n+      // create connections with the total rate < broker-wide quota, and verify there is no throttling\n+      val connCreateIntervalMs = 25 // connection creation rate = 40/sec per listener (3 * 40 = 120/sec total)\n+      val connectionsPerListener = 200 // should take 5 seconds to create 200 connections with rate = 40/sec\n+      val futures = listeners.values.map { listener =>\n+        executor.submit((() => acceptConnections(connectionQuotas, listener, connectionsPerListener, connCreateIntervalMs)): Runnable)\n       }\n+      futures.foreach(_.get(10, TimeUnit.SECONDS))\n+\n+      // the blocked percent should still be 0, because no limits were reached\n+      verifyNoBlockedPercentRecordedOnAllListeners()\n+      verifyConnectionCountOnEveryListener(connectionQuotas, connectionsPerListener)\n+    } finally {\n+      executor.shutdownNow()\n+    }\n+  }\n+\n+  @Test\n+  def testBrokerConnectionRateLimitWhenActualRateAboveLimit(): Unit = {\n+    val brokerRateLimit = 90\n+    val props = brokerPropsWithDefaultConnectionLimits\n+    props.put(KafkaConfig.MaxConnectionCreationRateProp, brokerRateLimit.toString)\n+    val config = KafkaConfig.fromProps(props)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE0MTA1NA==", "bodyText": "It seems that almost all the test cases instantiate an executor with listeners.size. Have you considered moving this to the setUp method and moving the shutdownNow to the tearDown?", "url": "https://github.com/apache/kafka/pull/8768#discussion_r440141054", "createdAt": "2020-06-15T12:30:39Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/network/ConnectionQuotasTest.scala", "diffHunk": "@@ -302,21 +312,295 @@ class ConnectionQuotasTest {\n       }\n       // all connections should get added\n       overLimitFutures.foreach(_.get(5, TimeUnit.SECONDS))\n-      listeners.values.foreach { listener =>\n-        assertEquals(s\"Number of connections on $listener:\",\n-          listenerMaxConnections, connectionQuotas.get(listener.defaultIp))\n+      verifyConnectionCountOnEveryListener(connectionQuotas, listenerMaxConnections)\n+    } finally {\n+      executor.shutdownNow()\n+    }\n+  }\n+\n+  @Test\n+  def testBrokerConnectionRateLimitWhenActualRateBelowLimit(): Unit = {\n+    val brokerRateLimit = 125\n+    val props = brokerPropsWithDefaultConnectionLimits\n+    props.put(KafkaConfig.MaxConnectionCreationRateProp, brokerRateLimit.toString)\n+    val config = KafkaConfig.fromProps(props)\n+    val connectionQuotas = new ConnectionQuotas(config, Time.SYSTEM, metrics)\n+\n+    addListenersAndVerify(config, connectionQuotas)\n+\n+    val executor = Executors.newFixedThreadPool(listeners.size)\n+    try {\n+      // create connections with the total rate < broker-wide quota, and verify there is no throttling\n+      val connCreateIntervalMs = 25 // connection creation rate = 40/sec per listener (3 * 40 = 120/sec total)\n+      val connectionsPerListener = 200 // should take 5 seconds to create 200 connections with rate = 40/sec\n+      val futures = listeners.values.map { listener =>\n+        executor.submit((() => acceptConnections(connectionQuotas, listener, connectionsPerListener, connCreateIntervalMs)): Runnable)\n       }\n+      futures.foreach(_.get(10, TimeUnit.SECONDS))\n+\n+      // the blocked percent should still be 0, because no limits were reached\n+      verifyNoBlockedPercentRecordedOnAllListeners()\n+      verifyConnectionCountOnEveryListener(connectionQuotas, connectionsPerListener)\n+    } finally {\n+      executor.shutdownNow()\n+    }\n+  }\n+\n+  @Test\n+  def testBrokerConnectionRateLimitWhenActualRateAboveLimit(): Unit = {\n+    val brokerRateLimit = 90\n+    val props = brokerPropsWithDefaultConnectionLimits\n+    props.put(KafkaConfig.MaxConnectionCreationRateProp, brokerRateLimit.toString)\n+    val config = KafkaConfig.fromProps(props)\n+    val connectionQuotas = new ConnectionQuotas(config, Time.SYSTEM, metrics)\n+\n+    addListenersAndVerify(config, connectionQuotas)\n+\n+    val executor = Executors.newFixedThreadPool(listeners.size)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE0MjU5Nw==", "bodyText": "nit: Would it make sense to add the pendant of verifyNoBlockedPercentRecordedOnAllListeners for this block? Something like verifyNonZeroBlockedPercentRecordedOnAllListeners?", "url": "https://github.com/apache/kafka/pull/8768#discussion_r440142597", "createdAt": "2020-06-15T12:33:31Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/network/ConnectionQuotasTest.scala", "diffHunk": "@@ -302,21 +312,295 @@ class ConnectionQuotasTest {\n       }\n       // all connections should get added\n       overLimitFutures.foreach(_.get(5, TimeUnit.SECONDS))\n-      listeners.values.foreach { listener =>\n-        assertEquals(s\"Number of connections on $listener:\",\n-          listenerMaxConnections, connectionQuotas.get(listener.defaultIp))\n+      verifyConnectionCountOnEveryListener(connectionQuotas, listenerMaxConnections)\n+    } finally {\n+      executor.shutdownNow()\n+    }\n+  }\n+\n+  @Test\n+  def testBrokerConnectionRateLimitWhenActualRateBelowLimit(): Unit = {\n+    val brokerRateLimit = 125\n+    val props = brokerPropsWithDefaultConnectionLimits\n+    props.put(KafkaConfig.MaxConnectionCreationRateProp, brokerRateLimit.toString)\n+    val config = KafkaConfig.fromProps(props)\n+    val connectionQuotas = new ConnectionQuotas(config, Time.SYSTEM, metrics)\n+\n+    addListenersAndVerify(config, connectionQuotas)\n+\n+    val executor = Executors.newFixedThreadPool(listeners.size)\n+    try {\n+      // create connections with the total rate < broker-wide quota, and verify there is no throttling\n+      val connCreateIntervalMs = 25 // connection creation rate = 40/sec per listener (3 * 40 = 120/sec total)\n+      val connectionsPerListener = 200 // should take 5 seconds to create 200 connections with rate = 40/sec\n+      val futures = listeners.values.map { listener =>\n+        executor.submit((() => acceptConnections(connectionQuotas, listener, connectionsPerListener, connCreateIntervalMs)): Runnable)\n       }\n+      futures.foreach(_.get(10, TimeUnit.SECONDS))\n+\n+      // the blocked percent should still be 0, because no limits were reached\n+      verifyNoBlockedPercentRecordedOnAllListeners()\n+      verifyConnectionCountOnEveryListener(connectionQuotas, connectionsPerListener)\n+    } finally {\n+      executor.shutdownNow()\n+    }\n+  }\n+\n+  @Test\n+  def testBrokerConnectionRateLimitWhenActualRateAboveLimit(): Unit = {\n+    val brokerRateLimit = 90\n+    val props = brokerPropsWithDefaultConnectionLimits\n+    props.put(KafkaConfig.MaxConnectionCreationRateProp, brokerRateLimit.toString)\n+    val config = KafkaConfig.fromProps(props)\n+    val connectionQuotas = new ConnectionQuotas(config, Time.SYSTEM, metrics)\n+\n+    addListenersAndVerify(config, connectionQuotas)\n+\n+    val executor = Executors.newFixedThreadPool(listeners.size)\n+    try {\n+      // each listener creates connections such that the total connection rate > broker-wide quota\n+      val connCreateIntervalMs = 10      // connection creation rate = 100\n+      val connectionsPerListener = 400\n+      val futures = listeners.values.map { listener =>\n+        executor.submit((() => acceptConnections(connectionQuotas, listener, connectionsPerListener, connCreateIntervalMs)): Runnable)\n+      }\n+      futures.foreach(_.get(20, TimeUnit.SECONDS))\n+\n+      // verify that connections on non-inter-broker listener are throttled\n+      verifyOnlyNonInterBrokerListenersBlockedPercentRecorded()\n+\n+      // expect all connections to be created (no limit on the number of connections)\n+      verifyConnectionCountOnEveryListener(connectionQuotas, connectionsPerListener)\n+    } finally {\n+      executor.shutdownNow()\n+    }\n+  }\n+\n+  @Test\n+  def testListenerConnectionRateLimitWhenActualRateBelowLimit(): Unit = {\n+    val brokerRateLimit = 125\n+    val listenerRateLimit = 50\n+    val connCreateIntervalMs = 25 // connection creation rate = 40/sec per listener (3 * 40 = 120/sec total)\n+    val props = brokerPropsWithDefaultConnectionLimits\n+    props.put(KafkaConfig.MaxConnectionCreationRateProp, brokerRateLimit.toString)\n+    val config = KafkaConfig.fromProps(props)\n+    val connectionQuotas = new ConnectionQuotas(config, Time.SYSTEM, metrics)\n+\n+    val listenerConfig = Map(KafkaConfig.MaxConnectionCreationRateProp -> listenerRateLimit.toString).asJava\n+    addListenersAndVerify(config, listenerConfig, connectionQuotas)\n+\n+    val executor = Executors.newFixedThreadPool(listeners.size)\n+    try {\n+      // create connections with the rate < listener quota on every listener, and verify there is no throttling\n+      val connectionsPerListener = 200 // should take 5 seconds to create 200 connections with rate = 40/sec\n+      val futures = listeners.values.map { listener =>\n+        executor.submit((() => acceptConnections(connectionQuotas, listener, connectionsPerListener, connCreateIntervalMs)): Runnable)\n+      }\n+      futures.foreach(_.get(10, TimeUnit.SECONDS))\n+\n+      // the blocked percent should still be 0, because no limits were reached\n+      verifyNoBlockedPercentRecordedOnAllListeners()\n+\n+      verifyConnectionCountOnEveryListener(connectionQuotas, connectionsPerListener)\n+    } finally {\n+      executor.shutdownNow()\n+    }\n+  }\n+\n+  @Test\n+  def testListenerConnectionRateLimitWhenActualRateAboveLimit(): Unit = {\n+    val brokerRateLimit = 125\n+    val listenerRateLimit = 30\n+    val connCreateIntervalMs = 25 // connection creation rate = 40/sec per listener (3 * 40 = 120/sec total)\n+    val props = brokerPropsWithDefaultConnectionLimits\n+    props.put(KafkaConfig.MaxConnectionCreationRateProp, brokerRateLimit.toString)\n+    val config = KafkaConfig.fromProps(props)\n+    val connectionQuotas = new ConnectionQuotas(config, Time.SYSTEM, metrics)\n+\n+    val listenerConfig = Map(KafkaConfig.MaxConnectionCreationRateProp -> listenerRateLimit.toString).asJava\n+    addListenersAndVerify(config, listenerConfig, connectionQuotas)\n+\n+    val executor = Executors.newFixedThreadPool(listeners.size)\n+    try {\n+      // create connections with the rate > listener quota on every listener\n+      // run a bit longer (20 seconds) to also verify the throttle rate\n+      val connectionsPerListener = 600 // should take 20 seconds to create 600 connections with rate = 30/sec\n+      val futures = listeners.values.map { listener =>\n+        executor.submit((() =>\n+          // epsilon is set to account for the worst-case where the measurement is taken just before or after the quota window\n+          acceptConnectionsAndVerifyRate(connectionQuotas, listener, connectionsPerListener, connCreateIntervalMs, listenerRateLimit, 5)): Runnable)\n+      }\n+      futures.foreach(_.get(30, TimeUnit.SECONDS))\n+\n+      // verify that every listener was throttled\n+      blockedPercentMeters.foreach { case (name, meter) =>\n+        assertTrue(s\"Expected BlockedPercentMeter metric for $name listener to be recorded\", meter.count() > 0)\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 285}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4NzQ4NjQ4", "url": "https://github.com/apache/kafka/pull/8768#pullrequestreview-448748648", "createdAt": "2020-07-15T08:42:48Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODo0Mjo0OFrOGx0SxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODo0ODo1N1rOGx0hpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg5MDE4MA==", "bodyText": "nit: Shall we add a javadoc to this one as well?", "url": "https://github.com/apache/kafka/pull/8768#discussion_r454890180", "createdAt": "2020-07-15T08:42:48Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1289,15 +1311,89 @@ class ConnectionQuotas(config: KafkaConfig, time: Time) extends Logging {\n   private def maxListenerConnections(listenerName: ListenerName): Int =\n     maxConnectionsPerListener.get(listenerName).map(_.maxConnections).getOrElse(Int.MaxValue)\n \n+  /**\n+   * Calculates the delay needed to bring the observed connection creation rate to listener-level limit or to broker-wide\n+   * limit, whichever the longest. The delay is capped to the quota window size defined by QuotaWindowSizeSecondsProp\n+   *\n+   * @param listenerName listener for which calculate the delay\n+   * @param timeMs current time in milliseconds\n+   * @return delay in milliseconds\n+   */\n+  private def recordConnectionAndGetThrottleTimeMs(listenerName: ListenerName, timeMs: Long): Long = {\n+    val listenerThrottleTimeMs = maxConnectionsPerListener\n+      .get(listenerName)\n+      .map(listenerQuota => recordAndGetThrottleTimeMs(listenerQuota.connectionRateSensor, timeMs))\n+      .getOrElse(0)\n+\n+    if (protectedListener(listenerName)) {\n+      listenerThrottleTimeMs\n+    } else {\n+      val brokerThrottleTimeMs = recordAndGetThrottleTimeMs(brokerConnectionRateSensor, timeMs)\n+      math.max(brokerThrottleTimeMs, listenerThrottleTimeMs)\n+    }\n+  }\n+\n+  private def recordAndGetThrottleTimeMs(sensor: Sensor, timeMs: Long): Int = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg5MDI4MQ==", "bodyText": "nit: Shall we add a javadoc to this one as well?", "url": "https://github.com/apache/kafka/pull/8768#discussion_r454890281", "createdAt": "2020-07-15T08:42:59Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1289,15 +1311,89 @@ class ConnectionQuotas(config: KafkaConfig, time: Time) extends Logging {\n   private def maxListenerConnections(listenerName: ListenerName): Int =\n     maxConnectionsPerListener.get(listenerName).map(_.maxConnections).getOrElse(Int.MaxValue)\n \n+  /**\n+   * Calculates the delay needed to bring the observed connection creation rate to listener-level limit or to broker-wide\n+   * limit, whichever the longest. The delay is capped to the quota window size defined by QuotaWindowSizeSecondsProp\n+   *\n+   * @param listenerName listener for which calculate the delay\n+   * @param timeMs current time in milliseconds\n+   * @return delay in milliseconds\n+   */\n+  private def recordConnectionAndGetThrottleTimeMs(listenerName: ListenerName, timeMs: Long): Long = {\n+    val listenerThrottleTimeMs = maxConnectionsPerListener\n+      .get(listenerName)\n+      .map(listenerQuota => recordAndGetThrottleTimeMs(listenerQuota.connectionRateSensor, timeMs))\n+      .getOrElse(0)\n+\n+    if (protectedListener(listenerName)) {\n+      listenerThrottleTimeMs\n+    } else {\n+      val brokerThrottleTimeMs = recordAndGetThrottleTimeMs(brokerConnectionRateSensor, timeMs)\n+      math.max(brokerThrottleTimeMs, listenerThrottleTimeMs)\n+    }\n+  }\n+\n+  private def recordAndGetThrottleTimeMs(sensor: Sensor, timeMs: Long): Int = {\n+    try {\n+      sensor.record(1.0, timeMs)\n+      0\n+    } catch {\n+      case e: QuotaViolationException =>\n+        val throttleTimeMs = QuotaUtils.boundedThrottleTime(\n+          e.value, e.bound, QuotaUtils.rateMetricWindowSize(e.metric, timeMs), maxThrottleTimeMs).toInt\n+        debug(s\"Quota violated for sensor (${sensor.name}). Delay time: $throttleTimeMs ms\")\n+        throttleTimeMs\n+    }\n+  }\n+\n+  /**\n+   * Creates sensor for tracking the connection creation rate and corresponding connection rate quota for a given\n+   * listener or broker-wide, if listener is not provided.\n+   * @param quotaLimit connection creation rate quota\n+   * @param listenerOpt listener name if sensor is for a listener\n+   */\n+  private def createConnectionRateQuotaSensor(quotaLimit: Int, listenerOpt: Option[String] = None): Sensor = {\n+    val quotaEntity = listenerOpt.getOrElse(\"broker\")\n+    val sensor = metrics.sensor(s\"ConnectionCreationRate-$quotaEntity\", rateQuotaMetricConfig(quotaLimit))\n+    sensor.add(connectionRateMetricName(quotaEntity), new Rate, null)\n+    info(s\"Created ConnectionCreationRate-$quotaEntity sensor, quotaLimit=$quotaLimit\")\n+    sensor\n+  }\n+\n+  private def updateConnectionRateQuota(quotaLimit: Int, listenerOpt: Option[String] = None): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg5Mzk4OQ==", "bodyText": "Fair enough.", "url": "https://github.com/apache/kafka/pull/8768#discussion_r454893989", "createdAt": "2020-07-15T08:48:57Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/network/ConnectionQuotasTest.scala", "diffHunk": "@@ -302,21 +312,295 @@ class ConnectionQuotasTest {\n       }\n       // all connections should get added\n       overLimitFutures.foreach(_.get(5, TimeUnit.SECONDS))\n-      listeners.values.foreach { listener =>\n-        assertEquals(s\"Number of connections on $listener:\",\n-          listenerMaxConnections, connectionQuotas.get(listener.defaultIp))\n+      verifyConnectionCountOnEveryListener(connectionQuotas, listenerMaxConnections)\n+    } finally {\n+      executor.shutdownNow()\n+    }\n+  }\n+\n+  @Test\n+  def testBrokerConnectionRateLimitWhenActualRateBelowLimit(): Unit = {\n+    val brokerRateLimit = 125\n+    val props = brokerPropsWithDefaultConnectionLimits\n+    props.put(KafkaConfig.MaxConnectionCreationRateProp, brokerRateLimit.toString)\n+    val config = KafkaConfig.fromProps(props)\n+    val connectionQuotas = new ConnectionQuotas(config, Time.SYSTEM, metrics)\n+\n+    addListenersAndVerify(config, connectionQuotas)\n+\n+    val executor = Executors.newFixedThreadPool(listeners.size)\n+    try {\n+      // create connections with the total rate < broker-wide quota, and verify there is no throttling\n+      val connCreateIntervalMs = 25 // connection creation rate = 40/sec per listener (3 * 40 = 120/sec total)\n+      val connectionsPerListener = 200 // should take 5 seconds to create 200 connections with rate = 40/sec\n+      val futures = listeners.values.map { listener =>\n+        executor.submit((() => acceptConnections(connectionQuotas, listener, connectionsPerListener, connCreateIntervalMs)): Runnable)\n       }\n+      futures.foreach(_.get(10, TimeUnit.SECONDS))\n+\n+      // the blocked percent should still be 0, because no limits were reached\n+      verifyNoBlockedPercentRecordedOnAllListeners()\n+      verifyConnectionCountOnEveryListener(connectionQuotas, connectionsPerListener)\n+    } finally {\n+      executor.shutdownNow()\n+    }\n+  }\n+\n+  @Test\n+  def testBrokerConnectionRateLimitWhenActualRateAboveLimit(): Unit = {\n+    val brokerRateLimit = 90\n+    val props = brokerPropsWithDefaultConnectionLimits\n+    props.put(KafkaConfig.MaxConnectionCreationRateProp, brokerRateLimit.toString)\n+    val config = KafkaConfig.fromProps(props)\n+    val connectionQuotas = new ConnectionQuotas(config, Time.SYSTEM, metrics)\n+\n+    addListenersAndVerify(config, connectionQuotas)\n+\n+    val executor = Executors.newFixedThreadPool(listeners.size)\n+    try {\n+      // each listener creates connections such that the total connection rate > broker-wide quota\n+      val connCreateIntervalMs = 10      // connection creation rate = 100\n+      val connectionsPerListener = 400\n+      val futures = listeners.values.map { listener =>\n+        executor.submit((() => acceptConnections(connectionQuotas, listener, connectionsPerListener, connCreateIntervalMs)): Runnable)\n+      }\n+      futures.foreach(_.get(20, TimeUnit.SECONDS))\n+\n+      // verify that connections on non-inter-broker listener are throttled\n+      verifyOnlyNonInterBrokerListenersBlockedPercentRecorded()\n+\n+      // expect all connections to be created (no limit on the number of connections)\n+      verifyConnectionCountOnEveryListener(connectionQuotas, connectionsPerListener)\n+    } finally {\n+      executor.shutdownNow()\n+    }\n+  }\n+\n+  @Test\n+  def testListenerConnectionRateLimitWhenActualRateBelowLimit(): Unit = {\n+    val brokerRateLimit = 125\n+    val listenerRateLimit = 50\n+    val connCreateIntervalMs = 25 // connection creation rate = 40/sec per listener (3 * 40 = 120/sec total)\n+    val props = brokerPropsWithDefaultConnectionLimits\n+    props.put(KafkaConfig.MaxConnectionCreationRateProp, brokerRateLimit.toString)\n+    val config = KafkaConfig.fromProps(props)\n+    val connectionQuotas = new ConnectionQuotas(config, Time.SYSTEM, metrics)\n+\n+    val listenerConfig = Map(KafkaConfig.MaxConnectionCreationRateProp -> listenerRateLimit.toString).asJava\n+    addListenersAndVerify(config, listenerConfig, connectionQuotas)\n+\n+    val executor = Executors.newFixedThreadPool(listeners.size)\n+    try {\n+      // create connections with the rate < listener quota on every listener, and verify there is no throttling\n+      val connectionsPerListener = 200 // should take 5 seconds to create 200 connections with rate = 40/sec\n+      val futures = listeners.values.map { listener =>\n+        executor.submit((() => acceptConnections(connectionQuotas, listener, connectionsPerListener, connCreateIntervalMs)): Runnable)\n+      }\n+      futures.foreach(_.get(10, TimeUnit.SECONDS))\n+\n+      // the blocked percent should still be 0, because no limits were reached\n+      verifyNoBlockedPercentRecordedOnAllListeners()\n+\n+      verifyConnectionCountOnEveryListener(connectionQuotas, connectionsPerListener)\n+    } finally {\n+      executor.shutdownNow()\n+    }\n+  }\n+\n+  @Test\n+  def testListenerConnectionRateLimitWhenActualRateAboveLimit(): Unit = {\n+    val brokerRateLimit = 125\n+    val listenerRateLimit = 30\n+    val connCreateIntervalMs = 25 // connection creation rate = 40/sec per listener (3 * 40 = 120/sec total)\n+    val props = brokerPropsWithDefaultConnectionLimits\n+    props.put(KafkaConfig.MaxConnectionCreationRateProp, brokerRateLimit.toString)\n+    val config = KafkaConfig.fromProps(props)\n+    val connectionQuotas = new ConnectionQuotas(config, Time.SYSTEM, metrics)\n+\n+    val listenerConfig = Map(KafkaConfig.MaxConnectionCreationRateProp -> listenerRateLimit.toString).asJava\n+    addListenersAndVerify(config, listenerConfig, connectionQuotas)\n+\n+    val executor = Executors.newFixedThreadPool(listeners.size)\n+    try {\n+      // create connections with the rate > listener quota on every listener\n+      // run a bit longer (20 seconds) to also verify the throttle rate\n+      val connectionsPerListener = 600 // should take 20 seconds to create 600 connections with rate = 30/sec\n+      val futures = listeners.values.map { listener =>\n+        executor.submit((() =>\n+          // epsilon is set to account for the worst-case where the measurement is taken just before or after the quota window\n+          acceptConnectionsAndVerifyRate(connectionQuotas, listener, connectionsPerListener, connCreateIntervalMs, listenerRateLimit, 5)): Runnable)\n+      }\n+      futures.foreach(_.get(30, TimeUnit.SECONDS))\n+\n+      // verify that every listener was throttled\n+      blockedPercentMeters.foreach { case (name, meter) =>\n+        assertTrue(s\"Expected BlockedPercentMeter metric for $name listener to be recorded\", meter.count() > 0)\n+      }\n+\n+      // while the connection creation rate was throttled,\n+      // expect all connections got created (not limit on the number of connections)\n+      verifyConnectionCountOnEveryListener(connectionQuotas, connectionsPerListener)\n+    } finally {\n+      executor.shutdownNow()\n+    }\n+  }\n+\n+  @Test\n+  def testMaxListenerConnectionListenerMustBeAboveZero(): Unit = {\n+    val config = KafkaConfig.fromProps(brokerPropsWithDefaultConnectionLimits)\n+    val connectionQuotas = new ConnectionQuotas(config, Time.SYSTEM, metrics)\n+\n+    connectionQuotas.addListener(config, listeners(\"EXTERNAL\").listenerName)\n+\n+    val maxListenerConnectionRate = 0\n+    val listenerConfig = Map(KafkaConfig.MaxConnectionCreationRateProp -> maxListenerConnectionRate.toString).asJava\n+    assertThrows[ConfigException] {\n+      connectionQuotas.maxConnectionsPerListener(listeners(\"EXTERNAL\").listenerName).validateReconfiguration(listenerConfig)\n+    }\n+  }\n+\n+  @Test\n+  def testMaxListenerConnectionRateReconfiguration(): Unit = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEzNDM5Mw=="}, "originalCommit": null, "originalPosition": 310}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNTE5MTM3", "url": "https://github.com/apache/kafka/pull/8768#pullrequestreview-451519137", "createdAt": "2020-07-20T11:25:10Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMToyNToxMVrOG0HG3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMTo0NTo0NlrOG0H5qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzI5NTU4Mg==", "bodyText": "We don't talk about this in the KIP and this is a public class. Why are we skipping reporting anyway?", "url": "https://github.com/apache/kafka/pull/8768#discussion_r457295582", "createdAt": "2020-07-20T11:25:11Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/common/metrics/MetricConfig.java", "diffHunk": "@@ -97,5 +99,13 @@ public MetricConfig recordLevel(Sensor.RecordingLevel recordingLevel) {\n         return this;\n     }\n \n+    public boolean skipReporting() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMwMjY0Nw==", "bodyText": "broker is a valid listener name, perhaps a reasonable name for inter-broker listener.", "url": "https://github.com/apache/kafka/pull/8768#discussion_r457302647", "createdAt": "2020-07-20T11:36:42Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1289,15 +1311,89 @@ class ConnectionQuotas(config: KafkaConfig, time: Time) extends Logging {\n   private def maxListenerConnections(listenerName: ListenerName): Int =\n     maxConnectionsPerListener.get(listenerName).map(_.maxConnections).getOrElse(Int.MaxValue)\n \n+  /**\n+   * Calculates the delay needed to bring the observed connection creation rate to listener-level limit or to broker-wide\n+   * limit, whichever the longest. The delay is capped to the quota window size defined by QuotaWindowSizeSecondsProp\n+   *\n+   * @param listenerName listener for which calculate the delay\n+   * @param timeMs current time in milliseconds\n+   * @return delay in milliseconds\n+   */\n+  private def recordConnectionAndGetThrottleTimeMs(listenerName: ListenerName, timeMs: Long): Long = {\n+    val listenerThrottleTimeMs = maxConnectionsPerListener\n+      .get(listenerName)\n+      .map(listenerQuota => recordAndGetThrottleTimeMs(listenerQuota.connectionRateSensor, timeMs))\n+      .getOrElse(0)\n+\n+    if (protectedListener(listenerName)) {\n+      listenerThrottleTimeMs\n+    } else {\n+      val brokerThrottleTimeMs = recordAndGetThrottleTimeMs(brokerConnectionRateSensor, timeMs)\n+      math.max(brokerThrottleTimeMs, listenerThrottleTimeMs)\n+    }\n+  }\n+\n+  private def recordAndGetThrottleTimeMs(sensor: Sensor, timeMs: Long): Int = {\n+    try {\n+      sensor.record(1.0, timeMs)\n+      0\n+    } catch {\n+      case e: QuotaViolationException =>\n+        val throttleTimeMs = QuotaUtils.boundedThrottleTime(\n+          e.value, e.bound, QuotaUtils.rateMetricWindowSize(e.metric, timeMs), maxThrottleTimeMs).toInt\n+        debug(s\"Quota violated for sensor (${sensor.name}). Delay time: $throttleTimeMs ms\")\n+        throttleTimeMs\n+    }\n+  }\n+\n+  /**\n+   * Creates sensor for tracking the connection creation rate and corresponding connection rate quota for a given\n+   * listener or broker-wide, if listener is not provided.\n+   * @param quotaLimit connection creation rate quota\n+   * @param listenerOpt listener name if sensor is for a listener\n+   */\n+  private def createConnectionRateQuotaSensor(quotaLimit: Int, listenerOpt: Option[String] = None): Sensor = {\n+    val quotaEntity = listenerOpt.getOrElse(\"broker\")\n+    val sensor = metrics.sensor(s\"ConnectionCreationRate-$quotaEntity\", rateQuotaMetricConfig(quotaLimit))\n+    sensor.add(connectionRateMetricName(quotaEntity), new Rate, null)\n+    info(s\"Created ConnectionCreationRate-$quotaEntity sensor, quotaLimit=$quotaLimit\")\n+    sensor\n+  }\n+\n+  private def updateConnectionRateQuota(quotaLimit: Int, listenerOpt: Option[String] = None): Unit = {\n+    val quotaEntity = listenerOpt.getOrElse(\"broker\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMwMzg1OQ==", "bodyText": "We could just make connectionRateSensor a val", "url": "https://github.com/apache/kafka/pull/8768#discussion_r457303859", "createdAt": "2020-07-20T11:38:36Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1289,15 +1311,89 @@ class ConnectionQuotas(config: KafkaConfig, time: Time) extends Logging {\n   private def maxListenerConnections(listenerName: ListenerName): Int =\n     maxConnectionsPerListener.get(listenerName).map(_.maxConnections).getOrElse(Int.MaxValue)\n \n+  /**\n+   * Calculates the delay needed to bring the observed connection creation rate to listener-level limit or to broker-wide\n+   * limit, whichever the longest. The delay is capped to the quota window size defined by QuotaWindowSizeSecondsProp\n+   *\n+   * @param listenerName listener for which calculate the delay\n+   * @param timeMs current time in milliseconds\n+   * @return delay in milliseconds\n+   */\n+  private def recordConnectionAndGetThrottleTimeMs(listenerName: ListenerName, timeMs: Long): Long = {\n+    val listenerThrottleTimeMs = maxConnectionsPerListener\n+      .get(listenerName)\n+      .map(listenerQuota => recordAndGetThrottleTimeMs(listenerQuota.connectionRateSensor, timeMs))\n+      .getOrElse(0)\n+\n+    if (protectedListener(listenerName)) {\n+      listenerThrottleTimeMs\n+    } else {\n+      val brokerThrottleTimeMs = recordAndGetThrottleTimeMs(brokerConnectionRateSensor, timeMs)\n+      math.max(brokerThrottleTimeMs, listenerThrottleTimeMs)\n+    }\n+  }\n+\n+  private def recordAndGetThrottleTimeMs(sensor: Sensor, timeMs: Long): Int = {\n+    try {\n+      sensor.record(1.0, timeMs)\n+      0\n+    } catch {\n+      case e: QuotaViolationException =>\n+        val throttleTimeMs = QuotaUtils.boundedThrottleTime(\n+          e.value, e.bound, QuotaUtils.rateMetricWindowSize(e.metric, timeMs), maxThrottleTimeMs).toInt\n+        debug(s\"Quota violated for sensor (${sensor.name}). Delay time: $throttleTimeMs ms\")\n+        throttleTimeMs\n+    }\n+  }\n+\n+  /**\n+   * Creates sensor for tracking the connection creation rate and corresponding connection rate quota for a given\n+   * listener or broker-wide, if listener is not provided.\n+   * @param quotaLimit connection creation rate quota\n+   * @param listenerOpt listener name if sensor is for a listener\n+   */\n+  private def createConnectionRateQuotaSensor(quotaLimit: Int, listenerOpt: Option[String] = None): Sensor = {\n+    val quotaEntity = listenerOpt.getOrElse(\"broker\")\n+    val sensor = metrics.sensor(s\"ConnectionCreationRate-$quotaEntity\", rateQuotaMetricConfig(quotaLimit))\n+    sensor.add(connectionRateMetricName(quotaEntity), new Rate, null)\n+    info(s\"Created ConnectionCreationRate-$quotaEntity sensor, quotaLimit=$quotaLimit\")\n+    sensor\n+  }\n+\n+  private def updateConnectionRateQuota(quotaLimit: Int, listenerOpt: Option[String] = None): Unit = {\n+    val quotaEntity = listenerOpt.getOrElse(\"broker\")\n+    val metric = metrics.metric(connectionRateMetricName(quotaEntity))\n+    metric.config(rateQuotaMetricConfig(quotaLimit))\n+    info(s\"Updated $quotaEntity max connection creation rate to $quotaLimit\")\n+  }\n+\n+  private def connectionRateMetricName(quotaEntity: String): MetricName = {\n+    metrics.metricName(\n+      s\"connection-creation-rate-$quotaEntity\",\n+      \"connection-quota\",\n+      s\"Tracking $quotaEntity connection creation rate\")\n+  }\n+\n+  private def rateQuotaMetricConfig(quotaLimit: Int): MetricConfig = {\n+    new MetricConfig()\n+      .timeWindow(config.quotaWindowSizeSeconds.toLong, TimeUnit.SECONDS)\n+      .samples(config.numQuotaSamples)\n+      .quota(new Quota(quotaLimit, true))\n+      .skipReporting(true)\n+  }\n+\n   class ListenerConnectionQuota(lock: Object, listener: ListenerName) extends ListenerReconfigurable {\n     @volatile private var _maxConnections = Int.MaxValue\n+    private val _connectionRateSensor = createConnectionRateQuotaSensor(Int.MaxValue, Some(listener.value))\n \n     def maxConnections: Int = _maxConnections\n+    def connectionRateSensor: Sensor = _connectionRateSensor", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzMwODU4NQ==", "bodyText": "Is this required for all tests or only the new connection rate tests?", "url": "https://github.com/apache/kafka/pull/8768#discussion_r457308585", "createdAt": "2020-07-20T11:45:46Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/network/ConnectionQuotasTest.scala", "diffHunk": "@@ -70,37 +80,38 @@ class ConnectionQuotasTest {\n         blockedPercentMeters.put(name, KafkaMetricsGroup.newMeter(\n           s\"${name}BlockedPercent\", \"blocked time\", TimeUnit.NANOSECONDS, Map(ListenerMetricTag -> name)))\n     }\n+    // use system time, because ConnectionQuota causes the current thread to wait with timeout, which waits based on\n+    // system time; so using mock time will likely result in test flakiness due to a mixed use of mock and system time\n+    metrics = new Metrics(new MetricConfig(), Collections.emptyList(), Time.SYSTEM)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 62}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a57b5b4a119a28fb6cf92fe55236515ddce08f23", "author": {"user": {"login": "apovzner", "name": "Anna Povzner"}}, "url": "https://github.com/apache/kafka/commit/a57b5b4a119a28fb6cf92fe55236515ddce08f23", "committedDate": "2020-08-06T23:01:01Z", "message": "KAFKA-10023: Enforce broker-wide and per-listener connection creation rate"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aae01fabcb35cb170572a50a58af9ffc817169e0", "author": {"user": {"login": "apovzner", "name": "Anna Povzner"}}, "url": "https://github.com/apache/kafka/commit/aae01fabcb35cb170572a50a58af9ffc817169e0", "committedDate": "2020-08-06T23:01:01Z", "message": "fixed bad merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7476516c596b08f0532929880fc9a3fae534f2d", "author": {"user": {"login": "apovzner", "name": "Anna Povzner"}}, "url": "https://github.com/apache/kafka/commit/c7476516c596b08f0532929880fc9a3fae534f2d", "committedDate": "2020-08-06T23:01:02Z", "message": "addressed initial review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45f62a9775b6a72bd8548985f52877251778da0e", "author": {"user": {"login": "apovzner", "name": "Anna Povzner"}}, "url": "https://github.com/apache/kafka/commit/45f62a9775b6a72bd8548985f52877251778da0e", "committedDate": "2020-08-06T23:01:02Z", "message": "moved no reporting flag to MetricConfig and addressed other comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61fff7cc8d5611ba8c3bc20311bf993a57a99d38", "author": {"user": {"login": "apovzner", "name": "Anna Povzner"}}, "url": "https://github.com/apache/kafka/commit/61fff7cc8d5611ba8c3bc20311bf993a57a99d38", "committedDate": "2020-08-06T23:01:02Z", "message": "reverted unintended changes (removed spaces in a comment)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13acc153ac32258ad64b7971a363e70a8eeccfac", "author": {"user": {"login": "apovzner", "name": "Anna Povzner"}}, "url": "https://github.com/apache/kafka/commit/13acc153ac32258ad64b7971a363e70a8eeccfac", "committedDate": "2020-08-06T23:01:02Z", "message": "one more revert"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c7d9ce557373b44c16a945587c0b6d045491ae2", "author": {"user": {"login": "apovzner", "name": "Anna Povzner"}}, "url": "https://github.com/apache/kafka/commit/0c7d9ce557373b44c16a945587c0b6d045491ae2", "committedDate": "2020-08-11T01:29:42Z", "message": "Fixed merge issue, reporting connection-accept-rate metrics"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "0c7d9ce557373b44c16a945587c0b6d045491ae2", "author": {"user": {"login": "apovzner", "name": "Anna Povzner"}}, "url": "https://github.com/apache/kafka/commit/0c7d9ce557373b44c16a945587c0b6d045491ae2", "committedDate": "2020-08-11T01:29:42Z", "message": "Fixed merge issue, reporting connection-accept-rate metrics"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MDY5MDEx", "url": "https://github.com/apache/kafka/pull/8768#pullrequestreview-468069011", "createdAt": "2020-08-16T14:30:14Z", "commit": {"oid": "0c7d9ce557373b44c16a945587c0b6d045491ae2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "508a754f397b5a1939c44dfcba72ba996bc912c5", "author": {"user": {"login": "apovzner", "name": "Anna Povzner"}}, "url": "https://github.com/apache/kafka/commit/508a754f397b5a1939c44dfcba72ba996bc912c5", "committedDate": "2020-08-17T03:37:50Z", "message": "clean up connection rate sensors"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 805, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}