{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyNzU5OTEz", "number": 9695, "title": "KAFKA-10500: Remove thread", "bodyText": "Add the ability to remove running threads\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including uprade notes)", "createdAt": "2020-12-04T20:08:09Z", "url": "https://github.com/apache/kafka/pull/9695", "merged": true, "mergeCommit": {"oid": "aedb53a4e6313398ed9626fbd2fbd7106e2ce94e"}, "closed": true, "closedAt": "2021-01-11T20:38:03Z", "author": {"login": "wcarlson5"}, "timelineItems": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdi-AzTgFqTU0NTI2NjQ5Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdvMqZrgFqTU2NTcxNzIwNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MjY2NDkz", "url": "https://github.com/apache/kafka/pull/9695#pullrequestreview-545266493", "createdAt": "2020-12-04T20:14:27Z", "commit": {"oid": "d6a8cbd4435e1b0b55d7cc3922226fcff60676d5"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDoxNDoyN1rOH_gecg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMDo0MTo1OFrOH_hSZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NDQxOA==", "bodyText": "I moved the changeThreadCount lock to be more specific so we will not hold a lock while acquiring a new one.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r536354418", "createdAt": "2020-12-04T20:14:27Z", "author": {"login": "wcarlson5"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,28 +924,69 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6a8cbd4435e1b0b55d7cc3922226fcff60676d5"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NzI2OA==", "bodyText": "removeStreamThread is supposed to be a blocking call until the shutdown is complete", "url": "https://github.com/apache/kafka/pull/9695#discussion_r536367268", "createdAt": "2020-12-04T20:41:02Z", "author": {"login": "wcarlson5"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,28 +924,69 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     *\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     *\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@code cache.max.bytes.buffering}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {\n+                if (streamThread.isAlive()) {\n+                    streamThread.shutdown();\n+                    while (streamThread.state() != StreamThread.State.DEAD && !streamThread.getName().equals(Thread.currentThread().getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2eb7beca2f0589ca9d6aa39a0bc2d72c6a9b954"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NzcxOQ==", "bodyText": "This makes sure that the names are reused correctly and that adding add removing continuously do not cause problems", "url": "https://github.com/apache/kafka/pull/9695#discussion_r536367719", "createdAt": "2020-12-04T20:41:58Z", "author": {"login": "wcarlson5"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,55 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7028ab1bbff7066da158be31ec268c3c1b1ea050"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NjY4MDUz", "url": "https://github.com/apache/kafka/pull/9695#pullrequestreview-546668053", "createdAt": "2020-12-08T01:09:36Z", "commit": {"oid": "b329214d7db48ce993ac253a64133f60d65f848d"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMTowOTozN1rOIBCJqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMTo0ODoxNFrOIBDC4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk1NDcyOQ==", "bodyText": "Nice. One minor suggestion, log a warning if the client isn't running (or rebalancing) and print the current state", "url": "https://github.com/apache/kafka/pull/9695#discussion_r537954729", "createdAt": "2020-12-08T01:09:37Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,28 +924,69 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM1NDQxOA=="}, "originalCommit": {"oid": "d6a8cbd4435e1b0b55d7cc3922226fcff60676d5"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk1NTM5Mg==", "bodyText": "Same here, let's log a warning", "url": "https://github.com/apache/kafka/pull/9695#discussion_r537955392", "createdAt": "2020-12-08T01:11:24Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,22 +924,64 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b329214d7db48ce993ac253a64133f60d65f848d"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk1NzgzMw==", "bodyText": "We need to protect this with a lock or use a thread-safe data structure for threads, otherwise we can get a ConcurrentModificationException if the user calls addThread and/or removeThread at the same time (on that note let's add test coverage for this)", "url": "https://github.com/apache/kafka/pull/9695#discussion_r537957833", "createdAt": "2020-12-08T01:17:48Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,22 +924,64 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b329214d7db48ce993ac253a64133f60d65f848d"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2NDMxNg==", "bodyText": "Be careful about swallowing the InterruptedException completely. Getting this exception means the user wants the thread to stop, not just this specific method. And we don't know what the caller of removeThread looks like, it might just be an infinite loop that checks on some metric and adjusts the thread count if necessary. We should make sure to propagate the interrupt once we finish cleaning up after the thread", "url": "https://github.com/apache/kafka/pull/9695#discussion_r537964316", "createdAt": "2020-12-08T01:35:03Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,22 +924,64 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {\n+                if (streamThread.isAlive()) {\n+                    streamThread.shutdown();\n+                    while (streamThread.state() != StreamThread.State.DEAD && !streamThread.getName().equals(Thread.currentThread().getName())) {\n+                        try {\n+                            synchronized (streamThread.state()) {\n+                                streamThread.state().wait(100);\n+                            }\n+                        } catch (final InterruptedException e) {\n+                            e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b329214d7db48ce993ac253a64133f60d65f848d"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk2OTM3OQ==", "bodyText": "I take it the !streamThread.getName().equals(Thread.currentThread().getName()) is in preparation for adding the REPLACE_THREAD enum -- if so, can you just leave a //TODO here for now and add this in the followup PR so we have relevant changes reviewed together?", "url": "https://github.com/apache/kafka/pull/9695#discussion_r537969379", "createdAt": "2020-12-08T01:48:14Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,28 +924,69 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     *\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     *\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@code cache.max.bytes.buffering}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {\n+                if (streamThread.isAlive()) {\n+                    streamThread.shutdown();\n+                    while (streamThread.state() != StreamThread.State.DEAD && !streamThread.getName().equals(Thread.currentThread().getName())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjM2NzI2OA=="}, "originalCommit": {"oid": "a2eb7beca2f0589ca9d6aa39a0bc2d72c6a9b954"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2Njg3MzM4", "url": "https://github.com/apache/kafka/pull/9695#pullrequestreview-546687338", "createdAt": "2020-12-08T01:59:52Z", "commit": {"oid": "b329214d7db48ce993ac253a64133f60d65f848d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMTo1OTo1MlrOIBDXMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMTo1OTo1MlrOIBDXMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk3NDU3OA==", "bodyText": "Maybe we could follow a similar pattern as to KafkaStreams#waitOnState and use notify instead of waking up every 100ms", "url": "https://github.com/apache/kafka/pull/9695#discussion_r537974578", "createdAt": "2020-12-08T01:59:52Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,22 +924,64 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {\n+                if (streamThread.isAlive()) {\n+                    streamThread.shutdown();\n+                    while (streamThread.state() != StreamThread.State.DEAD && !streamThread.getName().equals(Thread.currentThread().getName())) {\n+                        try {\n+                            synchronized (streamThread.state()) {\n+                                streamThread.state().wait(100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b329214d7db48ce993ac253a64133f60d65f848d"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5MTcwNzY4", "url": "https://github.com/apache/kafka/pull/9695#pullrequestreview-549170768", "createdAt": "2020-12-10T12:59:38Z", "commit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "state": "COMMENTED", "comments": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMjo1OTozOFrOIDIErw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNDo0MTozM1rOIDMjlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE0ODkxMQ==", "bodyText": "Looking at these lines, I have two questions:\n\nWhy do we not also resize the cache of the global stream thread?\nWhy do we not do all computations regarding the cache size in getCacheSizePerThread()?\n\nRegarding 1, I think we need to resize also the cache of the global stream thread, because otherwise the global stream thread may get over proportionally much cache when new stream threads are added beyond the initial number of steam threads and -- which I think is worse -- if all stream threads are removed, we would not use all cache for the global stream thread.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540148911", "createdAt": "2020-12-10T12:59:38Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,25 +924,64 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        log.warn(\"Cannot add a stream thread in state \" + state());\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {\n+                if (streamThread.isAlive()) {\n+                    streamThread.shutdown();\n+                    if (!streamThread.getName().equals(Thread.currentThread().getName())) {\n+                        streamThread.waitOnThreadState(StreamThread.State.DEAD);\n+                    }\n+                    synchronized (changeThreadCount) {\n+                        final long cacheSizePerThread = threads.size() == 1 ? 0 : getCacheSizePerThread(threads.size() - 1);\n+                        resizeThreadCache(cacheSizePerThread);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE2NzY3Mg==", "bodyText": "Is there a reason why we want to support that a stream thread can remove itself? If not I would simply not allow it and check on line 970 if the stream thread is alive and not the calling thread. Not allowing a stream thread removing itself would also ensure that we do not exceed the total cache size when we resize the cache.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540167672", "createdAt": "2020-12-10T13:28:07Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,25 +924,64 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        log.warn(\"Cannot add a stream thread in state \" + state());\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {\n+                if (streamThread.isAlive()) {\n+                    streamThread.shutdown();\n+                    if (!streamThread.getName().equals(Thread.currentThread().getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE3NTkwMA==", "bodyText": "Independently on how we decide about cleanup here, we should not print the stack trace. Please remove.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540175900", "createdAt": "2020-12-10T13:40:02Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -597,6 +598,18 @@ public void setStreamsUncaughtExceptionHandler(final java.util.function.Consumer\n         this.streamsUncaughtExceptionHandler = streamsUncaughtExceptionHandler;\n     }\n \n+    public void waitOnThreadState(final StreamThread.State targetState) {\n+        synchronized (stateLock) {\n+            while (state != targetState) {\n+                try {\n+                    stateLock.wait();\n+                } catch (final InterruptedException e) {\n+                    e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE3OTQzNg==", "bodyText": "This might be a nit, but if we wait on the stream thread state below, why do we not check the stream thread state being not DEAD here? Would be easier to understand when reading the code, IMO.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540179436", "createdAt": "2020-12-10T13:45:02Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,25 +924,64 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        log.warn(\"Cannot add a stream thread in state \" + state());\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {\n+                if (streamThread.isAlive()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE4MjY2Nw==", "bodyText": "Some more information about why we cannot remove a stream thread would be useful.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540182667", "createdAt": "2020-12-10T13:49:30Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,25 +924,64 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        log.warn(\"Cannot add a stream thread in state \" + state());\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {\n+                if (streamThread.isAlive()) {\n+                    streamThread.shutdown();\n+                    if (!streamThread.getName().equals(Thread.currentThread().getName())) {\n+                        streamThread.waitOnThreadState(StreamThread.State.DEAD);\n+                    }\n+                    synchronized (changeThreadCount) {\n+                        final long cacheSizePerThread = threads.size() == 1 ? 0 : getCacheSizePerThread(threads.size() - 1);\n+                        resizeThreadCache(cacheSizePerThread);\n                         threads.remove(streamThread);\n-                        resizeThreadCache(getCacheSizePerThread(threads.size()));\n-                        return Optional.empty();\n                     }\n+                    return Optional.of(streamThread.getName());\n                 }\n             }\n         }\n+        log.warn(\"Cannot remove a stream thread in state \" + state());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE4NzU4MA==", "bodyText": "I think it would be better to use something like Kafka Streams client did not reach state RUNNING as condition details instead of wait until running. BTW, the line is too long. \ud83d\ude01", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540187580", "createdAt": "2020-12-10T13:56:05Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/KafkaStreamsTest.java", "diffHunk": "@@ -631,6 +634,23 @@ public void shouldNotAddThreadWhenError() {\n         assertThat(streams.threads.size(), equalTo(oldSize));\n     }\n \n+    @Test\n+    public void shouldRemoveThread() throws InterruptedException {\n+        props.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG, 2);\n+        final KafkaStreams streams = new KafkaStreams(getBuilderWithSource().build(), props, supplier, time);\n+        streams.start();\n+        final int oldSize = streams.threads.size();\n+        TestUtils.waitForCondition(() -> streams.state() == KafkaStreams.State.RUNNING, 15L, \"wait until running\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE5MDM1OQ==", "bodyText": "Why do you not verify the number of the stream threads also here?", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540190359", "createdAt": "2020-12-10T13:59:45Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/KafkaStreamsTest.java", "diffHunk": "@@ -631,6 +634,23 @@ public void shouldNotAddThreadWhenError() {\n         assertThat(streams.threads.size(), equalTo(oldSize));\n     }\n \n+    @Test\n+    public void shouldRemoveThread() throws InterruptedException {\n+        props.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG, 2);\n+        final KafkaStreams streams = new KafkaStreams(getBuilderWithSource().build(), props, supplier, time);\n+        streams.start();\n+        final int oldSize = streams.threads.size();\n+        TestUtils.waitForCondition(() -> streams.state() == KafkaStreams.State.RUNNING, 15L, \"wait until running\");\n+        assertThat(streams.removeStreamThread(), equalTo(Optional.of(\"newThread\")));\n+        assertThat(streams.threads.size(), equalTo(oldSize - 1));\n+    }\n+\n+    @Test\n+    public void shouldNotRemoveThreadWhenNotRunning() {\n+        props.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1);\n+        final KafkaStreams streams = new KafkaStreams(getBuilderWithSource().build(), props, supplier, time);\n+        assertThat(streams.removeStreamThread(), equalTo(Optional.empty()));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE5MTI4Ng==", "bodyText": "You should also verify the return value of removeStreamThread() here.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540191286", "createdAt": "2020-12-10T14:00:58Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE5Mzg1Mg==", "bodyText": "A test is missing that verifies the behavior when a stream thread in state DEAD is in the list of stream threads.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540193852", "createdAt": "2020-12-10T14:04:30Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/KafkaStreamsTest.java", "diffHunk": "@@ -631,6 +634,23 @@ public void shouldNotAddThreadWhenError() {\n         assertThat(streams.threads.size(), equalTo(oldSize));\n     }\n \n+    @Test\n+    public void shouldRemoveThread() throws InterruptedException {\n+        props.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG, 2);\n+        final KafkaStreams streams = new KafkaStreams(getBuilderWithSource().build(), props, supplier, time);\n+        streams.start();\n+        final int oldSize = streams.threads.size();\n+        TestUtils.waitForCondition(() -> streams.state() == KafkaStreams.State.RUNNING, 15L, \"wait until running\");\n+        assertThat(streams.removeStreamThread(), equalTo(Optional.of(\"newThread\")));\n+        assertThat(streams.threads.size(), equalTo(oldSize - 1));\n+    }\n+\n+    @Test\n+    public void shouldNotRemoveThreadWhenNotRunning() {\n+        props.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1);\n+        final KafkaStreams streams = new KafkaStreams(getBuilderWithSource().build(), props, supplier, time);\n+        assertThat(streams.removeStreamThread(), equalTo(Optional.empty()));\n+    }\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIwNDU4MQ==", "bodyText": "Could you please add some line breaks? This and some of the other verifications are too long.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540204581", "createdAt": "2020-12-10T14:19:03Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIwNTc0MA==", "bodyText": "nit: Since you imported statically also the other matchers, you could also statically import this one to be consistent.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540205740", "createdAt": "2020-12-10T14:20:34Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIwOTI3Ng==", "bodyText": "nit: wrong indentation", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540209276", "createdAt": "2020-12-10T14:24:52Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxMTMzMQ==", "bodyText": "IMO, this string should give details when the condition is not met, like stream thread has not been added. Same applies to the other wait conditions.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540211331", "createdAt": "2020-12-10T14:27:26Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n+                \"Wait for the thread to be added\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxMzAwMA==", "bodyText": "This is not a guarantee that we give in the KIP. Assuming that always the first stream thread is removed is too strict for this test.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540213000", "createdAt": "2020-12-10T14:29:36Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n+            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+\n+\n+            oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"2\", \"3\"}));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxNDU2OA==", "bodyText": "Here you should test if the stream thread has the name of the stream thread that was removed before.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540214568", "createdAt": "2020-12-10T14:31:37Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n+            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+\n+\n+            oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"2\", \"3\"}));\n+\n+            final Optional<String> name2 = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name2.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxNjE0OQ==", "bodyText": "You verify the wrong name here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        assertThat(name, CoreMatchers.not(Optional.empty()));\n          \n          \n            \n                        assertThat(name2, CoreMatchers.not(Optional.empty()));", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540216149", "createdAt": "2020-12-10T14:33:37Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n+            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+\n+\n+            oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"2\", \"3\"}));\n+\n+            final Optional<String> name2 = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxODYyMg==", "bodyText": "Why not name.get() instead of name.orElse(\"\")?", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540218622", "createdAt": "2020-12-10T14:36:46Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyMDE0Nw==", "bodyText": "Could surround this call with new lines as you did for the others? Makes the calls under test more visible.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540220147", "createdAt": "2020-12-10T14:38:45Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n+            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+\n+\n+            oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyMDI1Mg==", "bodyText": "Please remove empty line.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540220252", "createdAt": "2020-12-10T14:38:55Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n+            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyMTM3MQ==", "bodyText": "Why do you not verify the actual name since it is well defined in the KIP which name should be returned given that we know that the other two stream thread are named 1 and 2?", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540221371", "createdAt": "2020-12-10T14:40:17Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyMjM1OA==", "bodyText": "Could you add a verification that the returned name is not empty?", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540222358", "createdAt": "2020-12-10T14:41:33Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n+            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+\n+\n+            oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ5NDI2ODQ3", "url": "https://github.com/apache/kafka/pull/9695#pullrequestreview-549426847", "createdAt": "2020-12-10T17:18:44Z", "commit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNzoxODo0NFrOIDUcbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxODowMjoyOVrOIDWXyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1MTU5Ng==", "bodyText": "Maybe there is a global thread and a stream thread and the user only wants a global thread now?", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540351596", "createdAt": "2020-12-10T17:18:44Z", "author": {"login": "wcarlson5"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,25 +924,64 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        log.warn(\"Cannot add a stream thread in state \" + state());\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {\n+                if (streamThread.isAlive()) {\n+                    streamThread.shutdown();\n+                    if (!streamThread.getName().equals(Thread.currentThread().getName())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE2NzY3Mg=="}, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1ODUwMw==", "bodyText": "we also want to avoid removing threads in PENDING_SHUTDOWN. There should not be any dead threads, this check is to make sure another call the removeThread is not removing the same thread.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540358503", "createdAt": "2020-12-10T17:28:25Z", "author": {"login": "wcarlson5"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,25 +924,64 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        log.warn(\"Cannot add a stream thread in state \" + state());\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {\n+                if (streamThread.isAlive()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE3OTQzNg=="}, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM2MzQzNg==", "bodyText": "There are two cases. Either there is no threads that can be removed of the client is in the wrong state", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540363436", "createdAt": "2020-12-10T17:35:35Z", "author": {"login": "wcarlson5"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -924,25 +924,64 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n-                        streamThread.shutdown();\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        log.warn(\"Cannot add a stream thread in state \" + state());\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            for (final StreamThread streamThread : threads) {\n+                if (streamThread.isAlive()) {\n+                    streamThread.shutdown();\n+                    if (!streamThread.getName().equals(Thread.currentThread().getName())) {\n+                        streamThread.waitOnThreadState(StreamThread.State.DEAD);\n+                    }\n+                    synchronized (changeThreadCount) {\n+                        final long cacheSizePerThread = threads.size() == 1 ? 0 : getCacheSizePerThread(threads.size() - 1);\n+                        resizeThreadCache(cacheSizePerThread);\n                         threads.remove(streamThread);\n-                        resizeThreadCache(getCacheSizePerThread(threads.size()));\n-                        return Optional.empty();\n                     }\n+                    return Optional.of(streamThread.getName());\n                 }\n             }\n         }\n+        log.warn(\"Cannot remove a stream thread in state \" + state());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE4MjY2Nw=="}, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM2NDEyNg==", "bodyText": "I will do what the wait on state method in KafkaStreams does", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540364126", "createdAt": "2020-12-10T17:36:29Z", "author": {"login": "wcarlson5"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -597,6 +598,18 @@ public void setStreamsUncaughtExceptionHandler(final java.util.function.Consumer\n         this.streamsUncaughtExceptionHandler = streamsUncaughtExceptionHandler;\n     }\n \n+    public void waitOnThreadState(final StreamThread.State targetState) {\n+        synchronized (stateLock) {\n+            while (state != targetState) {\n+                try {\n+                    stateLock.wait();\n+                } catch (final InterruptedException e) {\n+                    e.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE3NTkwMA=="}, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM2NjM1Mg==", "bodyText": "There is no case where a streamThread should be dead in the thread list", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540366352", "createdAt": "2020-12-10T17:39:13Z", "author": {"login": "wcarlson5"}, "path": "streams/src/test/java/org/apache/kafka/streams/KafkaStreamsTest.java", "diffHunk": "@@ -631,6 +634,23 @@ public void shouldNotAddThreadWhenError() {\n         assertThat(streams.threads.size(), equalTo(oldSize));\n     }\n \n+    @Test\n+    public void shouldRemoveThread() throws InterruptedException {\n+        props.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG, 2);\n+        final KafkaStreams streams = new KafkaStreams(getBuilderWithSource().build(), props, supplier, time);\n+        streams.start();\n+        final int oldSize = streams.threads.size();\n+        TestUtils.waitForCondition(() -> streams.state() == KafkaStreams.State.RUNNING, 15L, \"wait until running\");\n+        assertThat(streams.removeStreamThread(), equalTo(Optional.of(\"newThread\")));\n+        assertThat(streams.threads.size(), equalTo(oldSize - 1));\n+    }\n+\n+    @Test\n+    public void shouldNotRemoveThreadWhenNotRunning() {\n+        props.put(StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1);\n+        final KafkaStreams streams = new KafkaStreams(getBuilderWithSource().build(), props, supplier, time);\n+        assertThat(streams.removeStreamThread(), equalTo(Optional.empty()));\n+    }\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE5Mzg1Mg=="}, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM3NzgwNA==", "bodyText": "we can verify here, we verify the names in a few lines as well", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540377804", "createdAt": "2020-12-10T17:54:37Z", "author": {"login": "wcarlson5"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyMTM3MQ=="}, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM3ODM1NA==", "bodyText": "it can be either", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540378354", "createdAt": "2020-12-10T17:55:23Z", "author": {"login": "wcarlson5"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxODYyMg=="}, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM3OTUyMA==", "bodyText": "yes", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540379520", "createdAt": "2020-12-10T17:57:04Z", "author": {"login": "wcarlson5"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n+            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+\n+\n+            oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyMDE0Nw=="}, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM3OTU3Ng==", "bodyText": "yes", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540379576", "createdAt": "2020-12-10T17:57:09Z", "author": {"login": "wcarlson5"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n+            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+\n+\n+            oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyMjM1OA=="}, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM4MTQwNA==", "bodyText": "That is true, Will remove", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540381404", "createdAt": "2020-12-10T17:59:55Z", "author": {"login": "wcarlson5"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n+            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+\n+\n+            oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"2\", \"3\"}));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxMzAwMA=="}, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM4MTYyMw==", "bodyText": "good catch", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540381623", "createdAt": "2020-12-10T18:00:12Z", "author": {"login": "wcarlson5"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n+            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+\n+\n+            oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"2\", \"3\"}));\n+\n+            final Optional<String> name2 = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxNjE0OQ=="}, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM4MzE3OA==", "bodyText": "will do", "url": "https://github.com/apache/kafka/pull/9695#discussion_r540383178", "createdAt": "2020-12-10T18:02:29Z", "author": {"login": "wcarlson5"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -108,4 +108,53 @@ public void shouldAddStreamThread() throws Exception {\n             TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n         }\n     }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveStreamThreadsWhileKeepingNamesCorrect() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\"}));\n+\n+            final Optional<String> name = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n+            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+\n+\n+            oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            kafkaStreams.removeStreamThread();\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"2\", \"3\"}));\n+\n+            final Optional<String> name2 = kafkaStreams.addStreamThread();\n+\n+            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n+                        .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name2.orElse(\"\"))),\n+                \"Wait for the thread to be added\"\n+            );\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount));\n+            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxNDU2OA=="}, "originalCommit": {"oid": "338045c9b62c3b6154789d9cfa9a1cf104188e16"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2eb05bc3ff6aedc326cc61f57e138b6cee869509", "author": {"user": {"login": "wcarlson5", "name": "Walker Carlson"}}, "url": "https://github.com/apache/kafka/commit/2eb05bc3ff6aedc326cc61f57e138b6cee869509", "committedDate": "2020-12-11T21:33:50Z", "message": "init commit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5c74960741998bd4867eaaecce4fff77716a31a", "author": {"user": {"login": "wcarlson5", "name": "Walker Carlson"}}, "url": "https://github.com/apache/kafka/commit/c5c74960741998bd4867eaaecce4fff77716a31a", "committedDate": "2020-12-11T21:33:50Z", "message": "fix wait"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b22a31b4ff70b9e5e9ccb2b0673106499c648ffd", "author": {"user": {"login": "wcarlson5", "name": "Walker Carlson"}}, "url": "https://github.com/apache/kafka/commit/b22a31b4ff70b9e5e9ccb2b0673106499c648ffd", "committedDate": "2020-12-11T21:33:50Z", "message": "fix wait + add name tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f9d9e94fbba6ac2b022e9d7e1670cfd3d3db708", "author": {"user": {"login": "wcarlson5", "name": "Walker Carlson"}}, "url": "https://github.com/apache/kafka/commit/9f9d9e94fbba6ac2b022e9d7e1670cfd3d3db708", "committedDate": "2020-12-11T21:33:50Z", "message": "remove extra lines"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27a9361d35a7bbe0a532607e4ef5f7a7d1eb9f06", "author": {"user": {"login": "wcarlson5", "name": "Walker Carlson"}}, "url": "https://github.com/apache/kafka/commit/27a9361d35a7bbe0a532607e4ef5f7a7d1eb9f06", "committedDate": "2020-12-11T21:33:50Z", "message": "javadoc fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0c589c5b7bc3431d0611dd1a05840003d01c2ca", "author": {"user": {"login": "wcarlson5", "name": "Walker Carlson"}}, "url": "https://github.com/apache/kafka/commit/d0c589c5b7bc3431d0611dd1a05840003d01c2ca", "committedDate": "2020-12-11T21:33:50Z", "message": "respond to Sophie's comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68b9da5f45dc46d93d5646417961229f5a5d976d", "author": {"user": {"login": "wcarlson5", "name": "Walker Carlson"}}, "url": "https://github.com/apache/kafka/commit/68b9da5f45dc46d93d5646417961229f5a5d976d", "committedDate": "2020-12-11T21:33:50Z", "message": "Bruno's comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9eaf17d325e4428ba70e39ebe96be75b0724b46d", "author": {"user": {"login": "wcarlson5", "name": "Walker Carlson"}}, "url": "https://github.com/apache/kafka/commit/9eaf17d325e4428ba70e39ebe96be75b0724b46d", "committedDate": "2020-12-11T21:33:50Z", "message": "cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a7e48b66770a8a506a3a2e7c45a3e58aa5357ac", "author": {"user": {"login": "wcarlson5", "name": "Walker Carlson"}}, "url": "https://github.com/apache/kafka/commit/1a7e48b66770a8a506a3a2e7c45a3e58aa5357ac", "committedDate": "2020-12-11T21:33:50Z", "message": "cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "181f25835076b897aa13a7626c0d1590b7fd6043", "author": {"user": {"login": "wcarlson5", "name": "Walker Carlson"}}, "url": "https://github.com/apache/kafka/commit/181f25835076b897aa13a7626c0d1590b7fd6043", "committedDate": "2021-01-04T22:04:27Z", "message": "address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzMDg3OTg2", "url": "https://github.com/apache/kafka/pull/9695#pullrequestreview-563087986", "createdAt": "2021-01-06T22:44:36Z", "commit": {"oid": "181f25835076b897aa13a7626c0d1590b7fd6043"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMjo0NDozNlrOIPYkOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMjo0NDozNlrOIPYkOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwMjA0Mw==", "bodyText": "I know Bruno brought this up already and maybe I just missed the resolution in the previous comments, but: should we allow a StreamThread to remove itself? Originally I was thinking \"no\" but I was just thinking about what be the expected behavior from this method when called from a StreamThread, and I actually think we should consider ONLY removing the calling thread.\nI get the sense that users will interpret removeStreamThread() when called from a Thread as essentially saying \"shutdown this thread\", not \"remove some random thread\". WDYT?", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553002043", "createdAt": "2021-01-06T22:44:36Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -947,24 +948,65 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        log.warn(\"Cannot add a stream thread in state \" + state());\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            synchronized (changeThreadCount) {\n+                for (final StreamThread streamThread : threads) {\n+                    if (streamThread.isAlive()) {\n                         streamThread.shutdown();\n+                        if (!streamThread.getName().equals(Thread.currentThread().getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "181f25835076b897aa13a7626c0d1590b7fd6043"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzMDkxODM3", "url": "https://github.com/apache/kafka/pull/9695#pullrequestreview-563091837", "createdAt": "2021-01-06T22:53:55Z", "commit": {"oid": "181f25835076b897aa13a7626c0d1590b7fd6043"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMjo1Mzo1NVrOIPYwgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMjo1Mzo1NVrOIPYwgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNTE4Ng==", "bodyText": "Awesome, thanks for adding this test. One small suggestion would be to wait for the client to get back to RUNNING at the end, so we can verify that everything did go smoothly with the add/remove. I think this would be good to do in all of these tests, actually", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553005186", "createdAt": "2021-01-06T22:53:55Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -97,15 +99,132 @@ public void shouldAddStreamThread() throws Exception {\n \n             final Optional<String> name = kafkaStreams.addStreamThread();\n \n-            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            assertThat(name, not(Optional.empty()));\n             TestUtils.waitForCondition(\n                 () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n                         .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n                 \"Wait for the thread to be added\"\n             );\n             assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n-            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n-            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+            assertThat(\n+                kafkaStreams\n+                    .localThreadsMetadata()\n+                    .stream()\n+                    .map(t -> t.threadName().split(\"-StreamThread-\")[1])\n+                    .sorted().toArray(),\n+                equalTo(new String[] {\"1\", \"2\", \"3\"})\n+            );\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.state() == KafkaStreams.State.RUNNING,\n+                \"Kafka Streams client did not reach state RUNNING\"\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            assertThat(kafkaStreams.removeStreamThread().get().split(\"-\")[0], equalTo(appId));\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldAddAndRemoveThreads() throws InterruptedException {\n+        try (final KafkaStreams kafkaStreams = new KafkaStreams(builder.build(), properties)) {\n+            StreamsTestUtils.startKafkaStreamsAndWaitForRunningState(kafkaStreams);\n+            final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n+            final CountDownLatch latch = new CountDownLatch(2);\n+            final Thread one = adjustCountHelperThread(kafkaStreams, 4, latch);\n+            final Thread two = adjustCountHelperThread(kafkaStreams, 6, latch);\n+            two.start();\n+            one.start();\n+            latch.await(30, TimeUnit.SECONDS);\n+            assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "181f25835076b897aa13a7626c0d1590b7fd6043"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzMDkzMDQz", "url": "https://github.com/apache/kafka/pull/9695#pullrequestreview-563093043", "createdAt": "2021-01-06T22:56:55Z", "commit": {"oid": "181f25835076b897aa13a7626c0d1590b7fd6043"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMjo1Njo1NVrOIPY0bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMjo1Njo1NVrOIPY0bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAwNjE5MQ==", "bodyText": "One more corner case we should add test coverage for is what happens when we get down to 0 threads. Two things to verify  that I can think of are: (1) that the client stays in RUNNING, and (2) that we can add more threads again after we've been idling with zero threads for a short while (and as always, that it goes into REBALANCING --> RUNNING after adding the threads)", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553006191", "createdAt": "2021-01-06T22:56:55Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -97,15 +99,132 @@ public void shouldAddStreamThread() throws Exception {\n \n             final Optional<String> name = kafkaStreams.addStreamThread();\n \n-            assertThat(name, CoreMatchers.not(Optional.empty()));\n+            assertThat(name, not(Optional.empty()));\n             TestUtils.waitForCondition(\n                 () -> kafkaStreams.localThreadsMetadata().stream().sequential()\n                         .map(ThreadMetadata::threadName).anyMatch(t -> t.equals(name.orElse(\"\"))),\n                 \"Wait for the thread to be added\"\n             );\n             assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount + 1));\n-            assertThat(kafkaStreams.localThreadsMetadata().stream().map(t -> t.threadName().split(\"-StreamThread-\")[1]).sorted().toArray(), equalTo(new String[] {\"1\", \"2\", \"3\"}));\n-            TestUtils.waitForCondition(() -> kafkaStreams.state() == KafkaStreams.State.RUNNING, \"wait for running\");\n+            assertThat(\n+                kafkaStreams\n+                    .localThreadsMetadata()\n+                    .stream()\n+                    .map(t -> t.threadName().split(\"-StreamThread-\")[1])\n+                    .sorted().toArray(),\n+                equalTo(new String[] {\"1\", \"2\", \"3\"})\n+            );\n+            TestUtils.waitForCondition(\n+                () -> kafkaStreams.state() == KafkaStreams.State.RUNNING,\n+                \"Kafka Streams client did not reach state RUNNING\"\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldRemoveStreamThread() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "181f25835076b897aa13a7626c0d1590b7fd6043"}, "originalPosition": 55}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e85b199a73557d3e6dcf4f2c8d26cc0b3bb04ae", "author": {"user": {"login": "wcarlson5", "name": "Walker Carlson"}}, "url": "https://github.com/apache/kafka/commit/8e85b199a73557d3e6dcf4f2c8d26cc0b3bb04ae", "committedDate": "2021-01-06T23:42:58Z", "message": "added wait for running in tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzMTEzNDQ3", "url": "https://github.com/apache/kafka/pull/9695#pullrequestreview-563113447", "createdAt": "2021-01-06T23:54:06Z", "commit": {"oid": "8e85b199a73557d3e6dcf4f2c8d26cc0b3bb04ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMzo1NDowNlrOIPZ4uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMzo1NDowNlrOIPZ4uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyMzY3NQ==", "bodyText": "I guess technically this might not work if we have only one live thread left, but other dead threads still in the list -- in that case we might skip over the live thread when we really should have removed it. I'm not sure how much of a problem this would really be, just wanted to point it out.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553023675", "createdAt": "2021-01-06T23:54:06Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -992,7 +992,7 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n         if (isRunningOrRebalancing()) {\n             synchronized (changeThreadCount) {\n                 for (final StreamThread streamThread : threads) {\n-                    if (streamThread.isAlive()) {\n+                    if (streamThread.isAlive() && (!streamThread.getName().equals(Thread.currentThread().getName()) || threads.size() == 1)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e85b199a73557d3e6dcf4f2c8d26cc0b3bb04ae"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzMTE0MjYy", "url": "https://github.com/apache/kafka/pull/9695#pullrequestreview-563114262", "createdAt": "2021-01-06T23:56:52Z", "commit": {"oid": "8e85b199a73557d3e6dcf4f2c8d26cc0b3bb04ae"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMzo1Njo1MlrOIPZ7uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMzo1Njo1MlrOIPZ7uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzAyNDQ0Mw==", "bodyText": "Ah, sorry I didn't think of this/mention it before, but I think we actually need to wait for a transition to RUNNING, and not just for it to be in the state itself. It probably takes a little while after removing a thread for the rebalance to occur, so it's probably already in RUNNING. Pretty sure there's some other integration test util that watches for the REBALANCING -> RUNNING transition, though", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553024443", "createdAt": "2021-01-06T23:56:52Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/AdjustStreamThreadCountTest.java", "diffHunk": "@@ -128,6 +133,7 @@ public void shouldRemoveStreamThread() throws Exception {\n             final int oldThreadCount = kafkaStreams.localThreadsMetadata().size();\n             assertThat(kafkaStreams.removeStreamThread().get().split(\"-\")[0], equalTo(appId));\n             assertThat(kafkaStreams.localThreadsMetadata().size(), equalTo(oldThreadCount - 1));\n+            waitForApplicationState(Collections.singletonList(kafkaStreams), KafkaStreams.State.RUNNING, DEFAULT_DURATION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e85b199a73557d3e6dcf4f2c8d26cc0b3bb04ae"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "306a139fd0670f6f5fff7c225fc87a9c1063a29b", "author": {"user": {"login": "wcarlson5", "name": "Walker Carlson"}}, "url": "https://github.com/apache/kafka/commit/306a139fd0670f6f5fff7c225fc87a9c1063a29b", "committedDate": "2021-01-07T00:48:16Z", "message": "ensure at least one rebalance occures"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzNTU0OTQ2", "url": "https://github.com/apache/kafka/pull/9695#pullrequestreview-563554946", "createdAt": "2021-01-07T14:59:28Z", "commit": {"oid": "306a139fd0670f6f5fff7c225fc87a9c1063a29b"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNDo1OToyOFrOIPvqoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNTo0OTowMVrOIPxoSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM4MDUxMg==", "bodyText": "nit: Could you please rename the createStreamThread() to createAndAddStreamThread(). It is a bit weird that we have threads.remove() in this method but no threads.add(). The renaming would make it clearer.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553380512", "createdAt": "2021-01-07T14:59:28Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -947,24 +948,65 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "306a139fd0670f6f5fff7c225fc87a9c1063a29b"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM4NDA0OQ==", "bodyText": "nit: To deduplicate code, you could also remove these two lines, because they are the same as the last two lines of the method.\nnit: Could you change Cannot add a stream thread in state \" + state() to Cannot add a stream thread when Kafka Streams client is in state \" + state(), or similar. Currently, it is not completely clear if the state belongs to the stream thread or to the client.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553384049", "createdAt": "2021-01-07T15:05:03Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -947,24 +948,65 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "306a139fd0670f6f5fff7c225fc87a9c1063a29b"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM4NjI5Mw==", "bodyText": "See my nit comment above.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553386293", "createdAt": "2021-01-07T15:08:39Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -947,24 +948,65 @@ private StreamThread createStreamThread(final long cacheSizePerThread, final int\n      * @return name of the added stream thread or empty if a new stream thread could not be added\n      */\n     public Optional<String> addStreamThread() {\n-        synchronized (changeThreadCount) {\n-            if (isRunningOrRebalancing()) {\n-                final int threadIdx = getNextThreadIndex();\n-                final long cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n+        if (isRunningOrRebalancing()) {\n+            final int threadIdx;\n+            final long cacheSizePerThread;\n+            synchronized (changeThreadCount) {\n+                threadIdx = getNextThreadIndex();\n+                cacheSizePerThread = getCacheSizePerThread(threads.size() + 1);\n                 resizeThreadCache(cacheSizePerThread);\n-                final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n-                synchronized (stateLock) {\n-                    if (isRunningOrRebalancing()) {\n-                        streamThread.start();\n-                        return Optional.of(streamThread.getName());\n-                    } else {\n+            }\n+            final StreamThread streamThread = createStreamThread(cacheSizePerThread, threadIdx);\n+\n+            synchronized (stateLock) {\n+                if (isRunningOrRebalancing()) {\n+                    streamThread.start();\n+                    return Optional.of(streamThread.getName());\n+                } else {\n+                    streamThread.shutdown();\n+                    threads.remove(streamThread);\n+                    resizeThreadCache(getCacheSizePerThread(threads.size()));\n+                    log.warn(\"Cannot add a stream thread in state \" + state());\n+                    return Optional.empty();\n+                }\n+            }\n+        }\n+        log.warn(\"Cannot add a stream thread in state \" + state());\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Removes one stream thread out of the running stream threads from this Kafka Streams client.\n+     * <p>\n+     * The removed stream thread is gracefully shut down. This method does not specify which stream\n+     * thread is shut down.\n+     * <p>\n+     * Since the number of stream threads decreases, the sizes of the caches in the remaining stream\n+     * threads are adapted so that the sum of the cache sizes over all stream threads equals the total\n+     * cache size specified in configuration {@link StreamsConfig#CACHE_MAX_BYTES_BUFFERING_CONFIG}.\n+     *\n+     * @return name of the removed stream thread or empty if a stream thread could not be removed because\n+     *         no stream threads are alive\n+     */\n+    public Optional<String> removeStreamThread() {\n+        if (isRunningOrRebalancing()) {\n+            synchronized (changeThreadCount) {\n+                for (final StreamThread streamThread : threads) {\n+                    if (streamThread.isAlive() && (!streamThread.getName().equals(Thread.currentThread().getName()) || threads.size() == 1)) {\n                         streamThread.shutdown();\n+                        if (!streamThread.getName().equals(Thread.currentThread().getName())) {\n+                            streamThread.waitOnThreadState(StreamThread.State.DEAD);\n+                        }\n                         threads.remove(streamThread);\n-                        resizeThreadCache(getCacheSizePerThread(threads.size()));\n-                        return Optional.empty();\n+                        final long cacheSizePerThread = getCacheSizePerThread(threads.size());\n+                        resizeThreadCache(cacheSizePerThread);\n+                        return Optional.of(streamThread.getName());\n                     }\n                 }\n             }\n+            log.warn(\"There are no threads eligible for removal\");\n+        } else {\n+            log.warn(\"Cannot remove a stream thread in state \" + state());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "306a139fd0670f6f5fff7c225fc87a9c1063a29b"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM5ODIwOQ==", "bodyText": "Do we not need to synchronize this block on the changeThreadCount to at least guarantee that the state is correct when the method returns? Otherwise between the if and threadMetadata.add(thread.threadMetadata()) the stream thread might transit to DEAD.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553398209", "createdAt": "2021-01-07T15:27:33Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -1432,7 +1480,9 @@ public void cleanUp() {\n         validateIsRunningOrRebalancing();\n         final Set<ThreadMetadata> threadMetadata = new HashSet<>();\n         for (final StreamThread thread : threads) {\n-            threadMetadata.add(thread.threadMetadata());\n+            if (thread.state() != StreamThread.State.DEAD) {\n+                threadMetadata.add(thread.threadMetadata());\n+            }\n         }\n         return threadMetadata;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "306a139fd0670f6f5fff7c225fc87a9c1063a29b"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQxMjY4MQ==", "bodyText": "nit: My IDE says that the cast is not needed.", "url": "https://github.com/apache/kafka/pull/9695#discussion_r553412681", "createdAt": "2021-01-07T15:49:01Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/KafkaStreams.java", "diffHunk": "@@ -424,6 +424,7 @@ public void setUncaughtExceptionHandler(final StreamsUncaughtExceptionHandler st\n \n     private void defaultStreamsUncaughtExceptionHandler(final Throwable throwable) {\n         if (oldHandler) {\n+            threads.remove((StreamThread) Thread.currentThread());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "306a139fd0670f6f5fff7c225fc87a9c1063a29b"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dab30d6e6d79c49ee9274730788cb8ba0a668fbc", "author": {"user": {"login": "wcarlson5", "name": "Walker Carlson"}}, "url": "https://github.com/apache/kafka/commit/dab30d6e6d79c49ee9274730788cb8ba0a668fbc", "committedDate": "2021-01-07T18:25:02Z", "message": "comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0ebbdbc44ffe154d5bff5ef93ec3d16748b380c", "author": {"user": {"login": "wcarlson5", "name": "Walker Carlson"}}, "url": "https://github.com/apache/kafka/commit/d0ebbdbc44ffe154d5bff5ef93ec3d16748b380c", "committedDate": "2021-01-07T20:08:26Z", "message": "comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NzE2OTYz", "url": "https://github.com/apache/kafka/pull/9695#pullrequestreview-565716963", "createdAt": "2021-01-11T20:36:28Z", "commit": {"oid": "d0ebbdbc44ffe154d5bff5ef93ec3d16748b380c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1NzE3MjA1", "url": "https://github.com/apache/kafka/pull/9695#pullrequestreview-565717205", "createdAt": "2021-01-11T20:36:52Z", "commit": {"oid": "d0ebbdbc44ffe154d5bff5ef93ec3d16748b380c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2560, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}