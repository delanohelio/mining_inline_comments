{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxMDc1OTI5", "number": 7920, "title": "KAFKA-7737; Use single path in producer for initializing the producerId", "bodyText": "Previously the idempotent producer and transactional producer use separate logic when initializing the producerId. This patch consolidates the two paths. We also do some cleanup in TransactionManagerTest to eliminate brittle expectations on Sender.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-01-09T17:31:35Z", "url": "https://github.com/apache/kafka/pull/7920", "merged": true, "mergeCommit": {"oid": "df13fc93d0aebfe0ecc40dd4af3c5fb19b35f710"}, "closed": true, "closedAt": "2020-01-23T16:14:32Z", "author": {"login": "hachikuji"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb4wqRNABqjI5MzY0ODg3MTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb8_Ft9gBqjI5NzIwNjk1Mjk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMTgwNDAw", "url": "https://github.com/apache/kafka/pull/7920#pullrequestreview-343180400", "createdAt": "2020-01-15T12:21:22Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxMjoyMToyMlrOFd2jBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxNjoyNjoyOVrOFd-WFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg0NjcyNg==", "bodyText": "Just sanity checking: do I understand correctly that this became the part of resetProducerIdIfNeeded so at the first time this code path runs the producer id gets placed in the transactional request queue? Is this also the reason for removing 'maybeWaitForProducerId`?", "url": "https://github.com/apache/kafka/pull/7920#discussion_r366846726", "createdAt": "2020-01-15T12:21:22Z", "author": {"login": "viktorsomogyi"}, "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java", "diffHunk": "@@ -517,16 +512,6 @@ public boolean isRunning() {\n         return running;\n     }\n \n-    private ClientResponse sendAndAwaitInitProducerIdRequest(Node node) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk3NDQ4Ng==", "bodyText": "Would you consider using a long timeout instead and move this to TestUtils? Perhaps we need this somewhere else too.", "url": "https://github.com/apache/kafka/pull/7920#discussion_r366974486", "createdAt": "2020-01-15T16:26:29Z", "author": {"login": "viktorsomogyi"}, "path": "clients/src/test/java/org/apache/kafka/clients/producer/internals/TransactionManagerTest.java", "diffHunk": "@@ -2925,4 +2766,14 @@ private void assertFutureFailed(Future<RecordMetadata> future) throws Interrupte\n         }\n     }\n \n+    private void runUntil(Supplier<Boolean> condition) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1382}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTI2MzM3", "url": "https://github.com/apache/kafka/pull/7920#pullrequestreview-343526337", "createdAt": "2020-01-15T21:16:08Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMToxNjowOVrOFeGq_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMToxNjowOVrOFeGq_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExMDkwOQ==", "bodyText": "The only other caller of InitProducerIdRequest.Builder is in TransactionManager#initializeTransactions which is only called in producer#iniTxns. For idempotent producer how that initPid request would be sent? Did I miss anything?", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367110909", "createdAt": "2020-01-15T21:16:09Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java", "diffHunk": "@@ -538,41 +523,6 @@ private Node awaitNodeReady(FindCoordinatorRequest.CoordinatorType coordinatorTy\n         return null;\n     }\n \n-    private void maybeWaitForProducerId() {\n-        while (!forceClose && !transactionManager.hasProducerId() && !transactionManager.hasError()) {\n-            Node node = null;\n-            try {\n-                node = awaitNodeReady(null);\n-                if (node != null) {\n-                    ClientResponse response = sendAndAwaitInitProducerIdRequest(node);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 142}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTUxMzk4", "url": "https://github.com/apache/kafka/pull/7920#pullrequestreview-343551398", "createdAt": "2020-01-15T22:00:53Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMjowMDo1M1rOFeH12g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMjo1OTo0OVrOFeJMoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzMDA3NA==", "bodyText": "Ack, thanks!", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367130074", "createdAt": "2020-01-15T22:00:53Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java", "diffHunk": "@@ -538,41 +523,6 @@ private Node awaitNodeReady(FindCoordinatorRequest.CoordinatorType coordinatorTy\n         return null;\n     }\n \n-    private void maybeWaitForProducerId() {\n-        while (!forceClose && !transactionManager.hasProducerId() && !transactionManager.hasError()) {\n-            Node node = null;\n-            try {\n-                node = awaitNodeReady(null);\n-                if (node != null) {\n-                    ClientResponse response = sendAndAwaitInitProducerIdRequest(node);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExMDkwOQ=="}, "originalCommit": null, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzNjczMw==", "bodyText": "qq: is the second condition necessary given the first one? If we are not in transactional, then right now the only place to transit to INITIALIZING is line 496 below. I'm actually fine to leave it here to be less bug-vulnerable, but just to clarify my understanding.", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367136733", "createdAt": "2020-01-15T22:17:24Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java", "diffHunk": "@@ -481,6 +489,17 @@ synchronized void resetProducerIdIfNeeded() {\n         if (shouldResetProducerStateAfterResolvingSequences())\n             // Check if the previous run expired batches which requires a reset of the producer state.\n             resetProducerId();\n+\n+        if (!isTransactional()\n+                && currentState != State.INITIALIZING", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzODkxMA==", "bodyText": "qq: could you add a comment explaining why we need to call client.poll before exiting under this condition?", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367138910", "createdAt": "2020-01-15T22:22:43Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java", "diffHunk": "@@ -300,28 +295,27 @@ public void run() {\n     void runOnce() {\n         if (transactionManager != null) {\n             try {\n-                transactionManager.resetProducerIdIfNeeded();\n-\n-                if (!transactionManager.isTransactional()) {\n-                    // this is an idempotent producer, so make sure we have a producer id\n-                    maybeWaitForProducerId();\n-                } else if (transactionManager.hasUnresolvedSequences() && !transactionManager.hasFatalError()) {\n+                if (transactionManager.isTransactional()\n+                        && transactionManager.hasUnresolvedSequences()\n+                        && !transactionManager.hasFatalError()) {\n                     transactionManager.transitionToFatalError(\n-                        new KafkaException(\"The client hasn't received acknowledgment for \" +\n-                            \"some previously sent messages and can no longer retry them. It isn't safe to continue.\"));\n-                } else if (maybeSendAndPollTransactionalRequest()) {\n-                    return;\n+                            new KafkaException(\"The client hasn't received acknowledgment for \" +\n+                                    \"some previously sent messages and can no longer retry them. It isn't safe to continue.\"));\n                 }\n \n-                // do not continue sending if the transaction manager is in a failed state or if there\n-                // is no producer id (for the idempotent case).\n-                if (transactionManager.hasFatalError() || !transactionManager.hasProducerId()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0MDIwNQ==", "bodyText": "We can let this to return a boolean on whether a request is enqueued, and then in Sender we could:\nif (transactionManager.resetProducerIdIfNeeded() && maybeSendAndPollTransactionalRequest()) ..\n\nalso nit: Add a comment on top indicating that we will send out a new initPid request if producer is not transactional.", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367140205", "createdAt": "2020-01-15T22:25:58Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java", "diffHunk": "@@ -481,6 +489,17 @@ synchronized void resetProducerIdIfNeeded() {\n         if (shouldResetProducerStateAfterResolvingSequences())\n             // Check if the previous run expired batches which requires a reset of the producer state.\n             resetProducerId();\n+\n+        if (!isTransactional()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0MTU5OA==", "bodyText": "qq: is that a piggy-backed fix, or is it necessary for the refactoring?", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367141598", "createdAt": "2020-01-15T22:29:34Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java", "diffHunk": "@@ -412,6 +416,10 @@ synchronized void transitionToAbortableError(RuntimeException exception) {\n \n     synchronized void transitionToFatalError(RuntimeException exception) {\n         transitionTo(State.FATAL_ERROR, exception);\n+\n+        if (pendingResult != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE0MjExNg==", "bodyText": "How about: letting the state to transit to UNINITIALIZED inside resetProducerId (since it will only execute successfully if not transactional). By doing this we still have a single transition path to INITIALIZING?", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367142116", "createdAt": "2020-01-15T22:30:59Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java", "diffHunk": "@@ -216,7 +216,7 @@ public void resetSequenceNumbers(Consumer<ProducerBatch> resetSequence) {\n         private boolean isTransitionValid(State source, State target) {\n             switch (target) {\n                 case INITIALIZING:\n-                    return source == UNINITIALIZED;\n+                    return source == UNINITIALIZED || source == READY;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1MjI4OQ==", "bodyText": "qq: Why is this necessary?", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367152289", "createdAt": "2020-01-15T22:59:49Z", "author": {"login": "guozhangwang"}, "path": "clients/src/test/java/org/apache/kafka/clients/producer/internals/SenderTest.java", "diffHunk": "@@ -1154,7 +1154,9 @@ public void testExpiryOfAllSentBatchesShouldCauseUnresolvedSequences() throws Ex\n         Deque<ProducerBatch> batches = accumulator.batches().get(tp0);\n         assertEquals(0, batches.size());\n         assertTrue(transactionManager.hasProducerId(producerId));\n+\n         // We should now clear the old producerId and get a new one in a single run loop.\n+        time.sleep(10);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNjM2MTI3", "url": "https://github.com/apache/kafka/pull/7920#pullrequestreview-343636127", "createdAt": "2020-01-16T02:04:48Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwMjowNDo0OVrOFeMDtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwMjowNDo0OVrOFeMDtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE5OTE1Ng==", "bodyText": "Reducing visibility here to make sure that test cases are forced through the proper state transitions.", "url": "https://github.com/apache/kafka/pull/7920#discussion_r367199156", "createdAt": "2020-01-16T02:04:49Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java", "diffHunk": "@@ -451,7 +453,7 @@ boolean hasProducerIdAndEpoch(long producerId, short producerEpoch) {\n     /**\n      * Set the producer id and epoch atomically.\n      */\n-    void setProducerIdAndEpoch(ProducerIdAndEpoch producerIdAndEpoch) {\n+    private void setProducerIdAndEpoch(ProducerIdAndEpoch producerIdAndEpoch) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0OTc1Mjkw", "url": "https://github.com/apache/kafka/pull/7920#pullrequestreview-344975290", "createdAt": "2020-01-19T03:53:21Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDcyNzQx", "url": "https://github.com/apache/kafka/pull/7920#pullrequestreview-346472741", "createdAt": "2020-01-22T10:11:32Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMDoxMTozMlrOFgWu5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMDoxMTozMlrOFgWu5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3MTIwNQ==", "bodyText": "Just FYI, for KIP-360 I'm doing this check for both idempotent and transactional, since it triggers an epoch bump instead of a producerId reset. I'll just pull this call out to a shared code path, the rest of this method shouldn't need to change.", "url": "https://github.com/apache/kafka/pull/7920#discussion_r369471205", "createdAt": "2020-01-22T10:11:32Z", "author": {"login": "bob-barrett"}, "path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java", "diffHunk": "@@ -473,19 +475,32 @@ void setProducerIdAndEpoch(ProducerIdAndEpoch producerIdAndEpoch) {\n      * would not have any way of knowing this happened. So for the transactional producer, it's best to return the\n      * produce error to the user and let them abort the transaction and close the producer explicitly.\n      */\n-    synchronized void resetProducerId() {\n+    synchronized void resetIdempotentProducerId() {\n         if (isTransactional())\n             throw new IllegalStateException(\"Cannot reset producer state for a transactional producer. \" +\n                     \"You must either abort the ongoing transaction or reinitialize the transactional producer instead\");\n         setProducerIdAndEpoch(ProducerIdAndEpoch.NONE);\n         topicPartitionBookkeeper.reset();\n         this.partitionsWithUnresolvedSequences.clear();\n+        transitionTo(State.UNINITIALIZED);\n     }\n \n-    synchronized void resetProducerIdIfNeeded() {\n-        if (shouldResetProducerStateAfterResolvingSequences())\n-            // Check if the previous run expired batches which requires a reset of the producer state.\n-            resetProducerId();\n+    synchronized void resetIdempotentProducerIdIfNeeded() {\n+        if (!isTransactional()) {\n+            if (shouldResetProducerStateAfterResolvingSequences()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 93}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "724117119041ad85d7106c83721d7ba8c9b64800", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/724117119041ad85d7106c83721d7ba8c9b64800", "committedDate": "2020-01-23T00:14:11Z", "message": "KAFKA-7737; Use single path in producer for initializing the producerId"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94df3123c55b956ded078ce81528db9d2f2a94a8", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/94df3123c55b956ded078ce81528db9d2f2a94a8", "committedDate": "2020-01-23T00:14:11Z", "message": "A second call to initTransactions should fail"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e45a5aec8150398eaec3a4aefaa37a07c65239f", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/3e45a5aec8150398eaec3a4aefaa37a07c65239f", "committedDate": "2020-01-23T00:17:30Z", "message": "ProducerId reset transitions to UNINITIALIZED"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "3e45a5aec8150398eaec3a4aefaa37a07c65239f", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/3e45a5aec8150398eaec3a4aefaa37a07c65239f", "committedDate": "2020-01-23T00:17:30Z", "message": "ProducerId reset transitions to UNINITIALIZED"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1913, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}