{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5MzQ0NTU1", "number": 8685, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTozNDo1NVrOD9huzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTozNDo1NVrOD9huzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODQyMzgwOnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/common/network/Selector.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxOTozNDo1NVrOGXE3uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzo1MjowN1rOGgOf2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1MDIzMg==", "bodyText": "Have we considered using Utils.closeAll instead of multiple closeQuietly?", "url": "https://github.com/apache/kafka/pull/8685#discussion_r426850232", "createdAt": "2020-05-18T19:34:55Z", "author": {"login": "ijuma"}, "path": "clients/src/main/java/org/apache/kafka/common/network/Selector.java", "diffHunk": "@@ -363,23 +363,14 @@ public void wakeup() {\n     @Override\n     public void close() {\n         List<String> connections = new ArrayList<>(channels.keySet());\n-        try {\n-            for (String id : connections)\n-                close(id);\n-        } finally {\n-            // If there is any exception thrown in close(id), we should still be able\n-            // to close the remaining objects, especially the sensors because keeping\n-            // the sensors may lead to failure to start up the ReplicaFetcherThread if\n-            // the old sensors with the same names has not yet been cleaned up.\n-            AtomicReference<Throwable> firstException = new AtomicReference<>();\n-            Utils.closeQuietly(nioSelector, \"nioSelector\", firstException);\n-            Utils.closeQuietly(sensors, \"sensors\", firstException);\n-            Utils.closeQuietly(channelBuilder, \"channelBuilder\", firstException);\n-            Throwable exception = firstException.get();\n-            if (exception instanceof RuntimeException && !(exception instanceof SecurityException)) {\n-                throw (RuntimeException) exception;\n-            }\n-\n+        AtomicReference<Throwable> firstException = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA5MTkzMg==", "bodyText": "Utils.closeAll handle only IOException and it throws exception instead of keeping exception. Hence, it is not suitable to this case.", "url": "https://github.com/apache/kafka/pull/8685#discussion_r427091932", "createdAt": "2020-05-19T07:39:07Z", "author": {"login": "chia7712"}, "path": "clients/src/main/java/org/apache/kafka/common/network/Selector.java", "diffHunk": "@@ -363,23 +363,14 @@ public void wakeup() {\n     @Override\n     public void close() {\n         List<String> connections = new ArrayList<>(channels.keySet());\n-        try {\n-            for (String id : connections)\n-                close(id);\n-        } finally {\n-            // If there is any exception thrown in close(id), we should still be able\n-            // to close the remaining objects, especially the sensors because keeping\n-            // the sensors may lead to failure to start up the ReplicaFetcherThread if\n-            // the old sensors with the same names has not yet been cleaned up.\n-            AtomicReference<Throwable> firstException = new AtomicReference<>();\n-            Utils.closeQuietly(nioSelector, \"nioSelector\", firstException);\n-            Utils.closeQuietly(sensors, \"sensors\", firstException);\n-            Utils.closeQuietly(channelBuilder, \"channelBuilder\", firstException);\n-            Throwable exception = firstException.get();\n-            if (exception instanceof RuntimeException && !(exception instanceof SecurityException)) {\n-                throw (RuntimeException) exception;\n-            }\n-\n+        AtomicReference<Throwable> firstException = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1MDIzMg=="}, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMzM1NQ==", "bodyText": "Would it make sense to have a closeAllQuietly?", "url": "https://github.com/apache/kafka/pull/8685#discussion_r436403355", "createdAt": "2020-06-07T21:25:38Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/common/network/Selector.java", "diffHunk": "@@ -363,23 +363,14 @@ public void wakeup() {\n     @Override\n     public void close() {\n         List<String> connections = new ArrayList<>(channels.keySet());\n-        try {\n-            for (String id : connections)\n-                close(id);\n-        } finally {\n-            // If there is any exception thrown in close(id), we should still be able\n-            // to close the remaining objects, especially the sensors because keeping\n-            // the sensors may lead to failure to start up the ReplicaFetcherThread if\n-            // the old sensors with the same names has not yet been cleaned up.\n-            AtomicReference<Throwable> firstException = new AtomicReference<>();\n-            Utils.closeQuietly(nioSelector, \"nioSelector\", firstException);\n-            Utils.closeQuietly(sensors, \"sensors\", firstException);\n-            Utils.closeQuietly(channelBuilder, \"channelBuilder\", firstException);\n-            Throwable exception = firstException.get();\n-            if (exception instanceof RuntimeException && !(exception instanceof SecurityException)) {\n-                throw (RuntimeException) exception;\n-            }\n-\n+        AtomicReference<Throwable> firstException = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1MDIzMg=="}, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTE0Ng==", "bodyText": "Would it make sense to have a closeAllQuietly?\n\ncopy that", "url": "https://github.com/apache/kafka/pull/8685#discussion_r436445146", "createdAt": "2020-06-08T03:52:07Z", "author": {"login": "chia7712"}, "path": "clients/src/main/java/org/apache/kafka/common/network/Selector.java", "diffHunk": "@@ -363,23 +363,14 @@ public void wakeup() {\n     @Override\n     public void close() {\n         List<String> connections = new ArrayList<>(channels.keySet());\n-        try {\n-            for (String id : connections)\n-                close(id);\n-        } finally {\n-            // If there is any exception thrown in close(id), we should still be able\n-            // to close the remaining objects, especially the sensors because keeping\n-            // the sensors may lead to failure to start up the ReplicaFetcherThread if\n-            // the old sensors with the same names has not yet been cleaned up.\n-            AtomicReference<Throwable> firstException = new AtomicReference<>();\n-            Utils.closeQuietly(nioSelector, \"nioSelector\", firstException);\n-            Utils.closeQuietly(sensors, \"sensors\", firstException);\n-            Utils.closeQuietly(channelBuilder, \"channelBuilder\", firstException);\n-            Throwable exception = firstException.get();\n-            if (exception instanceof RuntimeException && !(exception instanceof SecurityException)) {\n-                throw (RuntimeException) exception;\n-            }\n-\n+        AtomicReference<Throwable> firstException = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1MDIzMg=="}, "originalCommit": null, "originalPosition": 21}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2661, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}