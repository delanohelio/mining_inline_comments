{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1MDI1NDY2", "number": 9352, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjozNTo1N1rOEszQeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjo1MDo0M1rOEszdeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NDEyNjAxOnYy", "diffSide": "RIGHT", "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjozNTo1N1rOHgPU6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMzowODozM1rOHgP-Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU2NzU5Mw==", "bodyText": "Just to clarify this is not a correctness bugfix, but just to optimize away unnecessary purgatory access right?", "url": "https://github.com/apache/kafka/pull/9352#discussion_r503567593", "createdAt": "2020-10-12T22:35:57Z", "author": {"login": "guozhangwang"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -193,8 +193,9 @@ private void updateFollowerHighWatermark(\n     ) {\n         highWatermarkOpt.ifPresent(highWatermark -> {\n             long newHighWatermark = Math.min(endOffset().offset, highWatermark);\n-            state.updateHighWatermark(OptionalLong.of(newHighWatermark));\n-            updateHighWatermark(state, currentTimeMs);\n+            if (state.updateHighWatermark(OptionalLong.of(newHighWatermark))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "944673b8f7d8b8deb07c2632c789647cfa5c4548"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3ODExNA==", "bodyText": "Yeah, right. Also to avoid the log spam when the high watermark doesn't actually increment.", "url": "https://github.com/apache/kafka/pull/9352#discussion_r503578114", "createdAt": "2020-10-12T23:08:33Z", "author": {"login": "hachikuji"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -193,8 +193,9 @@ private void updateFollowerHighWatermark(\n     ) {\n         highWatermarkOpt.ifPresent(highWatermark -> {\n             long newHighWatermark = Math.min(endOffset().offset, highWatermark);\n-            state.updateHighWatermark(OptionalLong.of(newHighWatermark));\n-            updateHighWatermark(state, currentTimeMs);\n+            if (state.updateHighWatermark(OptionalLong.of(newHighWatermark))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU2NzU5Mw=="}, "originalCommit": {"oid": "944673b8f7d8b8deb07c2632c789647cfa5c4548"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NDE0MjgxOnYy", "diffSide": "LEFT", "path": "raft/src/main/java/org/apache/kafka/raft/LeaderState.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjo0Mzo0N1rOHgPefA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjo0Mzo0N1rOHgPefA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MDA0NA==", "bodyText": "Good catch.", "url": "https://github.com/apache/kafka/pull/9352#discussion_r503570044", "createdAt": "2020-10-12T22:43:47Z", "author": {"login": "guozhangwang"}, "path": "raft/src/main/java/org/apache/kafka/raft/LeaderState.java", "diffHunk": "@@ -114,14 +113,6 @@ private boolean updateHighWatermark() {\n         return false;\n     }\n \n-    private OptionalLong quorumMajorityFetchTimestamp() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "944673b8f7d8b8deb07c2632c789647cfa5c4548"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NDE0NDIxOnYy", "diffSide": "RIGHT", "path": "raft/src/main/java/org/apache/kafka/raft/ReplicatedLog.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjo0NDoyOVrOHgPfWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMzozNDo0N1rOHgQZzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MDI2NA==", "bodyText": "Is this function going to be used for non-testing code in the future?", "url": "https://github.com/apache/kafka/pull/9352#discussion_r503570264", "createdAt": "2020-10-12T22:44:29Z", "author": {"login": "guozhangwang"}, "path": "raft/src/main/java/org/apache/kafka/raft/ReplicatedLog.java", "diffHunk": "@@ -103,6 +103,16 @@\n      */\n     void updateHighWatermark(LogOffsetMetadata offsetMetadata);\n \n+    /**\n+     * Flush the current log to disk.\n+     */\n+    void flush();\n+\n+    /**\n+     * Get the last offset which has been flushed to disk.\n+     */\n+    long lastFlushedOffset();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "944673b8f7d8b8deb07c2632c789647cfa5c4548"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3ODcxMA==", "bodyText": "I think we will need it to implement the leader deferred fsync or any other optimization which allows the followers to read unflushed data from the leader. I decided to add it to the interface since we have a trivial implementation for it in KafkaMetadataLog already. We can save it for later if you prefer.", "url": "https://github.com/apache/kafka/pull/9352#discussion_r503578710", "createdAt": "2020-10-12T23:10:33Z", "author": {"login": "hachikuji"}, "path": "raft/src/main/java/org/apache/kafka/raft/ReplicatedLog.java", "diffHunk": "@@ -103,6 +103,16 @@\n      */\n     void updateHighWatermark(LogOffsetMetadata offsetMetadata);\n \n+    /**\n+     * Flush the current log to disk.\n+     */\n+    void flush();\n+\n+    /**\n+     * Get the last offset which has been flushed to disk.\n+     */\n+    long lastFlushedOffset();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MDI2NA=="}, "originalCommit": {"oid": "944673b8f7d8b8deb07c2632c789647cfa5c4548"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU4NTIyOA==", "bodyText": "nah, I'm just curious to see what's in your future plan. Let's just keep it.", "url": "https://github.com/apache/kafka/pull/9352#discussion_r503585228", "createdAt": "2020-10-12T23:34:47Z", "author": {"login": "guozhangwang"}, "path": "raft/src/main/java/org/apache/kafka/raft/ReplicatedLog.java", "diffHunk": "@@ -103,6 +103,16 @@\n      */\n     void updateHighWatermark(LogOffsetMetadata offsetMetadata);\n \n+    /**\n+     * Flush the current log to disk.\n+     */\n+    void flush();\n+\n+    /**\n+     * Get the last offset which has been flushed to disk.\n+     */\n+    long lastFlushedOffset();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MDI2NA=="}, "originalCommit": {"oid": "944673b8f7d8b8deb07c2632c789647cfa5c4548"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NDE1OTMwOnYy", "diffSide": "RIGHT", "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjo1MDo0M1rOHgPnrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwMDozOTowMlrOHgRnXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MjM5Ng==", "bodyText": "nit: maybe we can wrap the flushing and hwm updating logic in a flushFollowerLog as well.", "url": "https://github.com/apache/kafka/pull/9352#discussion_r503572396", "createdAt": "2020-10-12T22:50:43Z", "author": {"login": "guozhangwang"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -985,6 +986,8 @@ private boolean handleFetchResponse(\n                 Records records = (Records) partitionResponse.recordSet();\n                 if (records.sizeInBytes() > 0) {\n                     LogAppendInfo info = log.appendAsFollower(records);\n+                    log.flush();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "944673b8f7d8b8deb07c2632c789647cfa5c4548"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3ODgxNg==", "bodyText": "Makes sense.", "url": "https://github.com/apache/kafka/pull/9352#discussion_r503578816", "createdAt": "2020-10-12T23:10:57Z", "author": {"login": "hachikuji"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -985,6 +986,8 @@ private boolean handleFetchResponse(\n                 Records records = (Records) partitionResponse.recordSet();\n                 if (records.sizeInBytes() > 0) {\n                     LogAppendInfo info = log.appendAsFollower(records);\n+                    log.flush();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MjM5Ng=="}, "originalCommit": {"oid": "944673b8f7d8b8deb07c2632c789647cfa5c4548"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzYwNTA4Nw==", "bodyText": "I considered this, but it's a little more awkward since the high watermark is coming from the request. However, I pushed an update which factors out an appendAsFollower call which is nearly symmetric with the existing appendAsLeader.", "url": "https://github.com/apache/kafka/pull/9352#discussion_r503605087", "createdAt": "2020-10-13T00:39:02Z", "author": {"login": "hachikuji"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -985,6 +986,8 @@ private boolean handleFetchResponse(\n                 Records records = (Records) partitionResponse.recordSet();\n                 if (records.sizeInBytes() > 0) {\n                     LogAppendInfo info = log.appendAsFollower(records);\n+                    log.flush();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MjM5Ng=="}, "originalCommit": {"oid": "944673b8f7d8b8deb07c2632c789647cfa5c4548"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1880, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}