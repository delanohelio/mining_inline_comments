{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyOTI4Nzk5", "number": 8478, "title": "HOTFIX: don't close or wipe out someone else's state", "bodyText": "When it comes to actually closing a task we now treat all states exactly the same, and call StateManagerUtil#closeStateManager regardless of whether it's in CREATED or RESTORING or RUNNING\nUnfortunately StateManagerUtil doesn't actually check to make sure that we actually own the lock for this task's state. During a dirty close with eos enabled, we wipe the state -- but in some cases, this means deleting the state out from under another StreamThread who is still in the process of revoking this task", "createdAt": "2020-04-14T02:06:20Z", "url": "https://github.com/apache/kafka/pull/8478", "merged": true, "mergeCommit": {"oid": "640be46ef5555d6e957589ab8cb67cc31fb5a4b9"}, "closed": true, "closedAt": "2020-04-15T21:17:47Z", "author": {"login": "ableegoldman"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcXnNtqgFqTM5MzE0ODkyMA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcX8ZaUAH2gAyNDAyOTI4Nzk5OjFhZDgyODJkZDA3ZDJkNGI5MTY0N2Y3Zjk0ZmUyMzU1MzYxMzkyMjc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMTQ4OTIw", "url": "https://github.com/apache/kafka/pull/8478#pullrequestreview-393148920", "createdAt": "2020-04-14T17:35:10Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzozNToxMFrOGFZkQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzozNToyNFrOGFZk7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxNDk0NQ==", "bodyText": "Not clear to me why we need a nested try-catch IOException here?", "url": "https://github.com/apache/kafka/pull/8478#discussion_r408314945", "createdAt": "2020-04-14T17:35:10Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateManagerUtil.java", "diffHunk": "@@ -100,41 +100,44 @@ static void closeStateManager(final Logger log,\n             throw new IllegalArgumentException(\"State store could not be wiped out during clean close\");\n         }\n \n-        ProcessorStateException exception = null;\n-\n         final TaskId id = stateMgr.taskId();\n-        log.trace(\"Closing state manager for {}\", id);\n+        log.trace(\"Closing state manager for {} task {}\", taskType, id);\n \n+        ProcessorStateException exception = null;\n         try {\n-            stateMgr.close();\n-\n-            if (wipeStateStore) {\n-                // we can just delete the whole dir of the task, including the state store images and the checkpoint files,\n-                // and then we write an empty checkpoint file indicating that the previous close is graceful and we just\n-                // need to re-bootstrap the restoration from the beginning\n-                Utils.delete(stateMgr.baseDir());\n-            }\n-        } catch (final ProcessorStateException e) {\n-            exception = e;\n-        } catch (final IOException e) {\n-            throw new ProcessorStateException(\"Failed to wiping state stores for task \" + id, e);\n-        } finally {\n-            try {\n-                stateDirectory.unlock(id);\n-            } catch (final IOException e) {\n-                if (exception == null) {\n-                    exception = new ProcessorStateException(\n-                        String.format(\"%sFailed to release state dir lock\", logPrefix), e);\n+            if (stateDirectory.lock(id)) {\n+                try {\n+                    stateMgr.close();\n+\n+                    if (wipeStateStore) {\n+                        // we can just delete the whole dir of the task, including the state store images and the checkpoint files,\n+                        // and then we write an empty checkpoint file indicating that the previous close is graceful and we just\n+                        // need to re-bootstrap the restoration from the beginning\n+                        Utils.delete(stateMgr.baseDir());\n+                    }\n+                } catch (final ProcessorStateException e) {\n+                    exception = e;\n+                } catch (final IOException e) {\n+                    throw new ProcessorStateException(\"Failed to wiping state stores for task \" + id, e);\n+                } finally {\n+                    try {\n+                        stateDirectory.unlock(id);\n+                    } catch (final IOException e) {\n+                        if (exception == null) {\n+                            exception = new ProcessorStateException(String.format(\"%sFailed to release state dir lock\", logPrefix), e);\n+                        }\n+                    }\n                 }\n             }\n+        } catch (final IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxNTExNg==", "bodyText": "Is this change intentional?", "url": "https://github.com/apache/kafka/pull/8478#discussion_r408315116", "createdAt": "2020-04-14T17:35:24Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -459,7 +459,6 @@ void handleLostAll() {\n         final Iterator<Task> iterator = tasks.values().iterator();\n         while (iterator.hasNext()) {\n             final Task task = iterator.next();\n-            final Set<TopicPartition> inputPartitions = task.inputPartitions();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "682c27f08da915b620743125e6d3e9ba9fddba7c", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/682c27f08da915b620743125e6d3e9ba9fddba7c", "committedDate": "2020-04-14T22:35:53Z", "message": "need to ensure lock"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dad39b7e03f0098a4f4e4620b388e87770452bed", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/dad39b7e03f0098a4f4e4620b388e87770452bed", "committedDate": "2020-04-14T23:06:56Z", "message": "fix up tests, add new ones"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "dad39b7e03f0098a4f4e4620b388e87770452bed", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/dad39b7e03f0098a4f4e4620b388e87770452bed", "committedDate": "2020-04-14T23:06:56Z", "message": "fix up tests, add new ones"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzU3MTcw", "url": "https://github.com/apache/kafka/pull/8478#pullrequestreview-393357170", "createdAt": "2020-04-14T23:14:13Z", "commit": {"oid": "dad39b7e03f0098a4f4e4620b388e87770452bed"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzoxNDoxM1rOGFkNIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzoxNDoxM1rOGFkNIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4OTI0OA==", "bodyText": "We actually were already throwing some ProcessorStateExceptions up through  close even when unclean, which I think was the cause of a bug we resolved a few weeks ago. Now we just make no assumptions about whether this will throw or not, and catch any exceptions in StreamTask / StandbyTask if it's a dirty close.", "url": "https://github.com/apache/kafka/pull/8478#discussion_r408489248", "createdAt": "2020-04-14T23:14:13Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java", "diffHunk": "@@ -249,32 +247,35 @@ public void testCloseStateManagerOnlyThrowsFirstExceptionWhenClean() throws IOEx\n     }\n \n     @Test\n-    public void testCloseStateManagerDirtyShallSwallowException() throws IOException {\n-        final LogCaptureAppender appender = LogCaptureAppender.createAndRegister();\n-\n+    public void testCloseStateManagerThrowsExceptionWhenDirty() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dad39b7e03f0098a4f4e4620b388e87770452bed"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzOTk3OTE0", "url": "https://github.com/apache/kafka/pull/8478#pullrequestreview-393997914", "createdAt": "2020-04-15T17:45:45Z", "commit": {"oid": "dad39b7e03f0098a4f4e4620b388e87770452bed"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzo0NTo0NVrOGGEwUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxODowMDozNFrOGGFSzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyMjU0Nw==", "bodyText": "Nice clean, now we catch the exception in the caller.", "url": "https://github.com/apache/kafka/pull/8478#discussion_r409022547", "createdAt": "2020-04-15T17:45:45Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateManagerUtil.java", "diffHunk": "@@ -92,49 +93,46 @@ static void registerStateStores(final Logger log,\n     static void closeStateManager(final Logger log,\n                                   final String logPrefix,\n                                   final boolean closeClean,\n-                                  final boolean wipeStateStore,\n+                                  final boolean eosEnabled,\n                                   final ProcessorStateManager stateMgr,\n                                   final StateDirectory stateDirectory,\n                                   final TaskType taskType) {\n-        if (closeClean && wipeStateStore) {\n-            throw new IllegalArgumentException(\"State store could not be wiped out during clean close\");\n-        }\n-\n-        ProcessorStateException exception = null;\n+        // if EOS is enabled, wipe out the whole state store for unclean close since it is now invalid\n+        final boolean wipeStateStore = !closeClean && eosEnabled;\n \n         final TaskId id = stateMgr.taskId();\n-        log.trace(\"Closing state manager for {}\", id);\n+        log.trace(\"Closing state manager for {} task {}\", taskType, id);\n \n+        final AtomicReference<ProcessorStateException> firstException = new AtomicReference<>(null);\n         try {\n-            stateMgr.close();\n-\n-            if (wipeStateStore) {\n-                // we can just delete the whole dir of the task, including the state store images and the checkpoint files,\n-                // and then we write an empty checkpoint file indicating that the previous close is graceful and we just\n-                // need to re-bootstrap the restoration from the beginning\n-                Utils.delete(stateMgr.baseDir());\n-            }\n-        } catch (final ProcessorStateException e) {\n-            exception = e;\n-        } catch (final IOException e) {\n-            throw new ProcessorStateException(\"Failed to wiping state stores for task \" + id, e);\n-        } finally {\n-            try {\n-                stateDirectory.unlock(id);\n-            } catch (final IOException e) {\n-                if (exception == null) {\n-                    exception = new ProcessorStateException(\n-                        String.format(\"%sFailed to release state dir lock\", logPrefix), e);\n+            if (stateDirectory.lock(id)) {\n+                try {\n+                    stateMgr.close();\n+\n+                    if (wipeStateStore) {\n+                        log.debug(\"Wiping state stores for {} task {}\", taskType, id);\n+                        // we can just delete the whole dir of the task, including the state store images and the checkpoint files,\n+                        // and then we write an empty checkpoint file indicating that the previous close is graceful and we just\n+                        // need to re-bootstrap the restoration from the beginning\n+                        Utils.delete(stateMgr.baseDir());\n+                    }\n+                } catch (final ProcessorStateException e) {\n+                    firstException.compareAndSet(null, e);\n+                } finally {\n+                    stateDirectory.unlock(id);\n                 }\n             }\n+        } catch (final IOException e) {\n+            final ProcessorStateException exception = new ProcessorStateException(\n+                String.format(\"%sFatal error while trying to close the state manager for task %s\", logPrefix, id), e\n+            );\n+            firstException.compareAndSet(null, exception);\n+\n         }\n \n+        final ProcessorStateException exception = firstException.get();\n         if (exception != null) {\n-            if (closeClean) {\n-                throw exception;\n-            } else {\n-                log.warn(\"Closing {} task {} uncleanly and swallows an exception\", taskType, id, exception);\n-            }\n+            throw exception;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dad39b7e03f0098a4f4e4620b388e87770452bed"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNTA1NQ==", "bodyText": "Thanks! SG.", "url": "https://github.com/apache/kafka/pull/8478#discussion_r409025055", "createdAt": "2020-04-15T17:49:56Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -459,7 +459,6 @@ void handleLostAll() {\n         final Iterator<Task> iterator = tasks.values().iterator();\n         while (iterator.hasNext()) {\n             final Task task = iterator.next();\n-            final Set<TopicPartition> inputPartitions = task.inputPartitions();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxNTExNg=="}, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyODA3OA==", "bodyText": "nit: we can throw AssertionError here to indicate this should not happen.", "url": "https://github.com/apache/kafka/pull/8478#discussion_r409028078", "createdAt": "2020-04-15T17:54:59Z", "author": {"login": "guozhangwang"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java", "diffHunk": "@@ -319,9 +322,47 @@ public void testCloseStateManagerWithStateStoreWipeOutRethrowWrappedIOException(\n             ProcessorStateException.class, () -> StateManagerUtil.closeStateManager(logger,\n                 \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE));\n \n-        assertEquals(\"Failed to wiping state stores for task 0_0\", thrown.getMessage());\n         assertEquals(IOException.class, thrown.getCause().getClass());\n \n         ctrl.verify();\n     }\n+\n+    @Test\n+    public void shouldNotStateManagerIfUnableToLockTaskDirectory() throws IOException {\n+        expect(stateManager.taskId()).andReturn(taskId);\n+\n+        expect(stateDirectory.lock(taskId)).andReturn(false);\n+\n+        stateManager.close();\n+        expectLastCall().andThrow(new StreamsException(\"Should not be trying to close state you don't own!\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dad39b7e03f0098a4f4e4620b388e87770452bed"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyODE4Nw==", "bodyText": "nit: shouldNotClose...?", "url": "https://github.com/apache/kafka/pull/8478#discussion_r409028187", "createdAt": "2020-04-15T17:55:09Z", "author": {"login": "guozhangwang"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java", "diffHunk": "@@ -319,9 +322,47 @@ public void testCloseStateManagerWithStateStoreWipeOutRethrowWrappedIOException(\n             ProcessorStateException.class, () -> StateManagerUtil.closeStateManager(logger,\n                 \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE));\n \n-        assertEquals(\"Failed to wiping state stores for task 0_0\", thrown.getMessage());\n         assertEquals(IOException.class, thrown.getCause().getClass());\n \n         ctrl.verify();\n     }\n+\n+    @Test\n+    public void shouldNotStateManagerIfUnableToLockTaskDirectory() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dad39b7e03f0098a4f4e4620b388e87770452bed"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAzMDk3Mg==", "bodyText": "nit: we can set eosEnabled to false since we set it to true in the next test?", "url": "https://github.com/apache/kafka/pull/8478#discussion_r409030972", "createdAt": "2020-04-15T17:59:52Z", "author": {"login": "guozhangwang"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java", "diffHunk": "@@ -319,9 +322,47 @@ public void testCloseStateManagerWithStateStoreWipeOutRethrowWrappedIOException(\n             ProcessorStateException.class, () -> StateManagerUtil.closeStateManager(logger,\n                 \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE));\n \n-        assertEquals(\"Failed to wiping state stores for task 0_0\", thrown.getMessage());\n         assertEquals(IOException.class, thrown.getCause().getClass());\n \n         ctrl.verify();\n     }\n+\n+    @Test\n+    public void shouldNotStateManagerIfUnableToLockTaskDirectory() throws IOException {\n+        expect(stateManager.taskId()).andReturn(taskId);\n+\n+        expect(stateDirectory.lock(taskId)).andReturn(false);\n+\n+        stateManager.close();\n+        expectLastCall().andThrow(new StreamsException(\"Should not be trying to close state you don't own!\"));\n+\n+        ctrl.checkOrder(true);\n+        ctrl.replay();\n+\n+        replayAll();\n+\n+        StateManagerUtil.closeStateManager(\n+            logger, \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dad39b7e03f0098a4f4e4620b388e87770452bed"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAzMTM3Mw==", "bodyText": "Ditto here, we can use AssertionError", "url": "https://github.com/apache/kafka/pull/8478#discussion_r409031373", "createdAt": "2020-04-15T18:00:34Z", "author": {"login": "guozhangwang"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java", "diffHunk": "@@ -319,9 +322,47 @@ public void testCloseStateManagerWithStateStoreWipeOutRethrowWrappedIOException(\n             ProcessorStateException.class, () -> StateManagerUtil.closeStateManager(logger,\n                 \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE));\n \n-        assertEquals(\"Failed to wiping state stores for task 0_0\", thrown.getMessage());\n         assertEquals(IOException.class, thrown.getCause().getClass());\n \n         ctrl.verify();\n     }\n+\n+    @Test\n+    public void shouldNotStateManagerIfUnableToLockTaskDirectory() throws IOException {\n+        expect(stateManager.taskId()).andReturn(taskId);\n+\n+        expect(stateDirectory.lock(taskId)).andReturn(false);\n+\n+        stateManager.close();\n+        expectLastCall().andThrow(new StreamsException(\"Should not be trying to close state you don't own!\"));\n+\n+        ctrl.checkOrder(true);\n+        ctrl.replay();\n+\n+        replayAll();\n+\n+        StateManagerUtil.closeStateManager(\n+            logger, \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE);\n+    }\n+\n+    @Test\n+    public void shouldNotWipeStateStoresIfUnableToLockTaskDirectory() throws IOException {\n+        final File unknownFile = new File(\"/unknown/path\");\n+        expect(stateManager.taskId()).andReturn(taskId);\n+\n+        expect(stateDirectory.lock(taskId)).andReturn(false);\n+\n+        expect(stateManager.baseDir()).andReturn(unknownFile);\n+\n+        Utils.delete(unknownFile);\n+        expectLastCall().andThrow(new StreamsException(\"Should not be trying to wipe state you don't own!\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dad39b7e03f0098a4f4e4620b388e87770452bed"}, "originalPosition": 165}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ad8282dd07d2d4b91647f7f94fe235536139227", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/1ad8282dd07d2d4b91647f7f94fe235536139227", "committedDate": "2020-04-15T18:28:24Z", "message": "github review"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1494, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}