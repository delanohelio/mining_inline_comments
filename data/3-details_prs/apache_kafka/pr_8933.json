{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwNTY0NTQ3", "number": 8933, "title": "KAFKA-10163; Throttle Create Topic, Create Partition and Delete Topic Operations (KIP-599, Part I, Broker Changes)", "bodyText": "This PR implements the broker side changes of KIP-599, except the changes of the Rate implementation which will be addressed separately.\nThe PR changes/introduces the following:\n\nIt introduces the protocol changes.\nIt introduces a new quota manager ControllerMutationQuotaManager which is another specialization of the ClientQuotaManager.\nIt enforces the quota in the KafkaApis and in the AdminManager. This part handles new and old clients as described in the KIP.\n\nThe PR is a good shape. The tests coverage is good. I will add few more unit tests for the api layer later one.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-06-26T12:43:58Z", "url": "https://github.com/apache/kafka/pull/8933", "merged": true, "mergeCommit": {"oid": "a5ffd1ca44caf4e4117c09cb99acd42084ea0fa8"}, "closed": true, "closedAt": "2020-07-22T15:38:56Z", "author": {"login": "dajac"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcvC3ONgFqTQzODI3NDQ0Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc3atNpAH2gAyNDQwNTY0NTQ3OmU3MDEzZTk1MDQ2MWI2YTA1YTI0NmI3OTAzYjRkODE3ZGQzYzVlZDM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4Mjc0NDQy", "url": "https://github.com/apache/kafka/pull/8933#pullrequestreview-438274442", "createdAt": "2020-06-26T13:00:39Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzowMDozOVrOGpf_cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzowMDozOVrOGpf_cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE2ODk0NA==", "bodyText": "The various quota enforcement types that can be used with a Sensor.", "url": "https://github.com/apache/kafka/pull/8933#discussion_r446168944", "createdAt": "2020-06-26T13:00:39Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/common/metrics/Sensor.java", "diffHunk": "@@ -97,7 +97,25 @@ public static RecordingLevel forName(String name) {\n         public boolean shouldRecord(final int configId) {\n             return configId == DEBUG.id || configId == this.id;\n         }\n+    }\n \n+    public enum QuotaEnforcementType {\n+        /**\n+         * The quota is not enforced.\n+         */\n+        NONE,\n+\n+        /**\n+         * The quota is enforced before updating the sensor. An update\n+         * is rejected if the quota is already exhausted.\n+         */\n+        STRICT,\n+\n+        /**\n+         * The quota is enforced after updating the sensor. An update\n+         * is always accepted even if the quota is already exhausted.\n+         */\n+        PERMISSIVE", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4Mjc1NjQx", "url": "https://github.com/apache/kafka/pull/8933#pullrequestreview-438275641", "createdAt": "2020-06-26T13:02:22Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzowMjoyM1rOGpgC0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzowMjoyM1rOGpgC0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE2OTgwOQ==", "bodyText": "I have refactored the ClientQuotaManager to be a bit more generic and to accept a quota enforcement type.", "url": "https://github.com/apache/kafka/pull/8933#discussion_r446169809", "createdAt": "2020-06-26T13:02:23Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/ClientQuotaManager.scala", "diffHunk": "@@ -154,32 +180,40 @@ object ClientQuotaManager {\n  * @param config @ClientQuotaManagerConfig quota configs\n  * @param metrics @Metrics Metrics instance\n  * @param quotaType Quota type of this quota manager\n+ * @param quotaEnforcementType Quota enforcement type of this quota manager. Refers to the\n+ *                             documentation of {recordAndGetThrottleTimeMs} for details\n  * @param time @Time object to use\n+ * @param threadNamePrefix The thread prefix to use\n+ * @param clientQuotaCallback An optional @ClientQuotaCallback\n  */\n class ClientQuotaManager(private val config: ClientQuotaManagerConfig,\n                          private val metrics: Metrics,\n                          private val quotaType: QuotaType,\n+                         private val quotaEnforcementType: QuotaEnforcementType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 112}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4Mjg1NTc4", "url": "https://github.com/apache/kafka/pull/8933#pullrequestreview-438285578", "createdAt": "2020-06-26T13:16:10Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzoxNjoxMVrOGpgeUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMzoxNjoxMVrOGpgeUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE3Njg1MA==", "bodyText": "I have introduced a new construct here in order to make the integration as lightweight as possible: ControllerMutationQuota. It is a small wrapper around the Sensor of a given user/clientId which wraps the quota enforcement and the computation of the throttle time. Three implementations are available: StrictControllerMutationQuota that is used for new clients, PermissiveControllerMutationQuota that is used for old clients, and UnboundedControllerMutationQuota that is used when no quota is set.\nThe ControllerMutationQuota object is then passed to the AdminManager to enforce the quota and later used to compute the final throttle time before sending the response. At this point, the request quota is also computed and the highest one is used.", "url": "https://github.com/apache/kafka/pull/8933#discussion_r446176850", "createdAt": "2020-06-26T13:16:11Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1684,25 +1685,29 @@ class KafkaApis(val requestChannel: RequestChannel,\n   }\n \n   def handleCreateTopicsRequest(request: RequestChannel.Request): Unit = {\n+    // Since version 6 of the API, the quota is strictly enforced. Any topic creation\n+    // above the quota is not allowed and rejected with a THROTTLING_QUOTA_EXCEEDED error.\n+    val controllerMutationQuota = quotas.controllerMutation.newQuotaFor(request, 6)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5ODYwNzAz", "url": "https://github.com/apache/kafka/pull/8933#pullrequestreview-449860703", "createdAt": "2020-07-16T13:43:50Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxMzo0Mzo1MVrOGyrlQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNTozMTozNVrOGywgkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTc5NjAzNQ==", "bodyText": "Do we really need this? I didn't find the naming of the types very intuitive. We have different variations on the usage of the APIs. But given that we have a public API that enables us to check quotas and another to record with or without the check, we could just use the existing APIs? For example, we already have record without checking quota, we have record with check quota, we have record followed by unrecord. And now we want to check without recording. It seems simpler to leave it to the quota manager to record zero with  checkQuotas first and then record the value without checkQuotas if the first one succeeds.", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455796035", "createdAt": "2020-07-16T13:43:51Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/common/metrics/Sensor.java", "diffHunk": "@@ -97,7 +97,25 @@ public static RecordingLevel forName(String name) {\n         public boolean shouldRecord(final int configId) {\n             return configId == DEBUG.id || configId == this.id;\n         }\n+    }\n \n+    public enum QuotaEnforcementType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgyNjc4MA==", "bodyText": "Where is this validation done now?", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455826780", "createdAt": "2020-07-16T14:25:03Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -101,12 +148,6 @@ class AdminManager(val config: KafkaConfig,\n         if (nullConfigs.nonEmpty)\n           throw new InvalidRequestException(s\"Null value not supported for topic configs : ${nullConfigs.mkString(\",\")}\")\n \n-        val configs = new Properties()\n-        topic.configs.forEach { entry =>\n-          configs.setProperty(entry.name, entry.value)\n-        }\n-        LogConfig.validate(configs)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgzMjcwNg==", "bodyText": "Shouldn't validateOnly tell you know much you would have been throttled?", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455832706", "createdAt": "2020-07-16T14:32:14Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -295,34 +312,44 @@ class AdminManager(val config: KafkaConfig,\n           throw new InvalidPartitionsException(s\"Topic already has $oldNumPartitions partitions.\")\n         }\n \n-        val newPartitionsAssignment = Option(newPartition.assignments)\n-          .map { assignmentMap =>\n-            val assignments = assignmentMap.asScala.map {\n-              createPartitionAssignment => createPartitionAssignment.brokerIds.asScala.map(_.toInt)\n-            }\n-            val unknownBrokers = assignments.flatten.toSet -- allBrokerIds\n-            if (unknownBrokers.nonEmpty)\n-              throw new InvalidReplicaAssignmentException(\n-                s\"Unknown broker(s) in replica assignment: ${unknownBrokers.mkString(\", \")}.\")\n-\n-            if (assignments.size != numPartitionsIncrement)\n-              throw new InvalidReplicaAssignmentException(\n-                s\"Increasing the number of partitions by $numPartitionsIncrement \" +\n-                  s\"but ${assignments.size} assignments provided.\")\n-\n-            assignments.zipWithIndex.map { case (replicas, index) =>\n-              existingAssignment.size + index -> replicas\n-            }.toMap\n+        val newPartitionsAssignment = Option(newPartition.assignments).map { assignmentMap =>\n+          val assignments = assignmentMap.asScala.map {\n+            createPartitionAssignment => createPartitionAssignment.brokerIds.asScala.map(_.toInt)\n+          }\n+          val unknownBrokers = assignments.flatten.toSet -- allBrokerIds\n+          if (unknownBrokers.nonEmpty)\n+            throw new InvalidReplicaAssignmentException(\n+              s\"Unknown broker(s) in replica assignment: ${unknownBrokers.mkString(\", \")}.\")\n+\n+          if (assignments.size != numPartitionsIncrement)\n+            throw new InvalidReplicaAssignmentException(\n+              s\"Increasing the number of partitions by $numPartitionsIncrement \" +\n+                s\"but ${assignments.size} assignments provided.\")\n+\n+          assignments.zipWithIndex.map { case (replicas, index) =>\n+            existingAssignment.size + index -> replicas\n+          }.toMap\n         }\n \n-        val updatedReplicaAssignment = adminZkClient.addPartitions(topic, existingAssignment, allBrokers,\n-          newPartition.count, newPartitionsAssignment, validateOnly = validateOnly)\n-        CreatePartitionsMetadata(topic, updatedReplicaAssignment.keySet, ApiError.NONE)\n+        val assignmentForNewPartitions = adminZkClient.createNewPartitionsAssignment(\n+          topic, existingAssignment, allBrokers, newPartition.count, newPartitionsAssignment)\n+\n+        if (validateOnly) {\n+          CreatePartitionsMetadata(topic, (existingAssignment ++ assignmentForNewPartitions).keySet)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 314}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgzNzk4Ng==", "bodyText": "Doesn't return anything?", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455837986", "createdAt": "2020-07-16T14:38:59Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/ClientQuotaManager.scala", "diffHunk": "@@ -234,55 +266,85 @@ class ClientQuotaManager(private val config: ClientQuotaManagerConfig,\n   }\n \n   /**\n-   * Returns maximum value (produced/consume bytes or request processing time) that could be recorded without guaranteed throttling.\n-   * Recording any larger value will always be throttled, even if no other values were recorded in the quota window.\n-   * This is used for deciding the maximum bytes that can be fetched at once\n+   * Records that a user/clientId accumulated or would like to accumulate the provided amount at the\n+   * the specified time, returns throttle time in milliseconds. Depending on the {QuotaEnforcementType}\n+   * used, the behavior of this method changes:\n+   * - QuotaEnforcementType.Strict verifies the quota is not violated before accumulating the\n+   *   provided value. If it is, the value is not accumulated and the throttle time represents\n+   *   the time to wait before the quota comes back to the defined limit.\n+   * - QuotaEnforcementType.PERMISSIVE verifies the quota is not violated after accumulating the\n+   *   provided value. If it is, the value is still accumulated and the throttle time represents\n+   *   the time to wait before the quota comes back to the defined limit.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @param value The value to accumulate\n+   * @param timeMs The time at which to accumulate the value\n+   * @return The throttle time in milliseconds defines as the time to wait until the average\n+   *         rate gets back to the defined quota\n    */\n-  def getMaxValueInQuotaWindow(session: Session, clientId: String): Double = {\n-    if (quotasEnabled) {\n-      val clientSensors = getOrCreateQuotaSensors(session, clientId)\n-      Option(quotaCallback.quotaLimit(clientQuotaType, clientSensors.metricTags.asJava))\n-        .map(_.toDouble * (config.numQuotaSamples - 1) * config.quotaWindowSizeSeconds)\n-        .getOrElse(Double.MaxValue)\n-    } else {\n-      Double.MaxValue\n-    }\n-  }\n-\n   def recordAndGetThrottleTimeMs(session: Session, clientId: String, value: Double, timeMs: Long): Int = {\n     val clientSensors = getOrCreateQuotaSensors(session, clientId)\n     try {\n-      clientSensors.quotaSensor.record(value, timeMs)\n+      clientSensors.quotaSensor.record(value, timeMs, quotaEnforcementType)\n       0\n     } catch {\n       case e: QuotaViolationException =>\n-        val throttleTimeMs = throttleTime(e.value, e.bound, windowSize(e.metric, timeMs)).toInt\n+        val throttleTimeMs = throttleTime(e, timeMs).toInt\n         debug(s\"Quota violated for sensor (${clientSensors.quotaSensor.name}). Delay time: ($throttleTimeMs)\")\n         throttleTimeMs\n     }\n   }\n \n-  /** \"Unrecord\" the given value that has already been recorded for the given user/client by recording a negative value\n-    * of the same quantity.\n-    *\n-    * For a throttled fetch, the broker should return an empty response and thus should not record the value. Ideally,\n-    * we would like to compute the throttle time before actually recording the value, but the current Sensor code\n-    * couples value recording and quota checking very tightly. As a workaround, we will unrecord the value for the fetch\n-    * in case of throttling. Rate keeps the sum of values that fall in each time window, so this should bring the\n-    * overall sum back to the previous value.\n-    */\n+  /**\n+   * Records that a user/clientId changed some metric being throttled without checking for\n+   * quota violation. The aggregate value will subsequently be used for throttling when the\n+   * next request is processed.\n+   */\n+  def recordNoThrottle(session: Session, clientId: String, value: Double): Unit = {\n+    val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+    clientSensors.quotaSensor.record(value, time.milliseconds(), QuotaEnforcementType.NONE)\n+  }\n+\n+  /**\n+   * \"Unrecord\" the given value that has already been recorded for the given user/client by recording a negative value\n+   * of the same quantity.\n+   *\n+   * For a throttled fetch, the broker should return an empty response and thus should not record the value. Ideally,\n+   * we would like to compute the throttle time before actually recording the value, but the current Sensor code\n+   * couples value recording and quota checking very tightly. As a workaround, we will unrecord the value for the fetch\n+   * in case of throttling. Rate keeps the sum of values that fall in each time window, so this should bring the\n+   * overall sum back to the previous value.\n+   */\n   def unrecordQuotaSensor(request: RequestChannel.Request, value: Double, timeMs: Long): Unit = {\n     val clientSensors = getOrCreateQuotaSensors(request.session, request.header.clientId)\n-    clientSensors.quotaSensor.record(value * (-1), timeMs, false)\n+    clientSensors.quotaSensor.record(value * (-1), timeMs, QuotaEnforcementType.NONE)\n   }\n \n   /**\n-    * Throttle a client by muting the associated channel for the given throttle time.\n-    * @param request client request\n-    * @param throttleTimeMs Duration in milliseconds for which the channel is to be muted.\n-    * @param channelThrottlingCallback Callback for channel throttling\n-    * @return ThrottledChannel object\n-    */\n+   * Returns maximum value that could be recorded without guaranteed throttling.\n+   * Recording any larger value will always be throttled, even if no other values were recorded in the quota window.\n+   * This is used for deciding the maximum bytes that can be fetched at once\n+   */\n+  def getMaxValueInQuotaWindow(session: Session, clientId: String): Double = {\n+    if (quotasEnabled) {\n+      val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+      Option(quotaCallback.quotaLimit(clientQuotaType, clientSensors.metricTags.asJava))\n+        .map(_.toDouble * (config.numQuotaSamples - 1) * config.quotaWindowSizeSeconds)\n+        .getOrElse(Double.MaxValue)\n+    } else {\n+      Double.MaxValue\n+    }\n+  }\n+\n+  /**\n+   * Throttle a client by muting the associated channel for the given throttle time.\n+   *\n+   * @param request client request\n+   * @param throttleTimeMs Duration in milliseconds for which the channel is to be muted.\n+   * @param channelThrottlingCallback Callback for channel throttling\n+   * @return ThrottledChannel object", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0MTAzMA==", "bodyText": "We might as well move the name to the companion object above since it is a constant?", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455841030", "createdAt": "2020-07-16T14:43:05Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/ClientRequestQuotaManager.scala", "diffHunk": "@@ -20,21 +20,32 @@ import java.util.concurrent.TimeUnit\n \n import kafka.network.RequestChannel\n import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.metrics.Sensor.QuotaEnforcementType\n import org.apache.kafka.common.metrics._\n import org.apache.kafka.common.utils.Time\n import org.apache.kafka.server.quota.ClientQuotaCallback\n \n import scala.jdk.CollectionConverters._\n \n+object ClientRequestQuotaManager {\n+  val QuotaRequestPercentDefault = Int.MaxValue.toDouble\n+  val NanosToPercentagePerSecond = 100.0 / TimeUnit.SECONDS.toNanos(1)\n+}\n \n class ClientRequestQuotaManager(private val config: ClientQuotaManagerConfig,\n                                 private val metrics: Metrics,\n                                 private val time: Time,\n-                                threadNamePrefix: String,\n-                                quotaCallback: Option[ClientQuotaCallback])\n-                                extends ClientQuotaManager(config, metrics, QuotaType.Request, time, threadNamePrefix, quotaCallback) {\n-  val maxThrottleTimeMs = TimeUnit.SECONDS.toMillis(this.config.quotaWindowSizeSeconds)\n-  def exemptSensor = getOrCreateSensor(exemptSensorName, exemptMetricName)\n+                                private val threadNamePrefix: String,\n+                                private val quotaCallback: Option[ClientQuotaCallback])\n+    extends ClientQuotaManager(config, metrics, QuotaType.Request, QuotaEnforcementType.PERMISSIVE,\n+      time, threadNamePrefix, quotaCallback) {\n+\n+  private val maxThrottleTimeMs = TimeUnit.SECONDS.toMillis(this.config.quotaWindowSizeSeconds)\n+  private val exemptMetricName = metrics.metricName(\"exempt-request-time\",\n+    QuotaType.Request.toString, \"Tracking exempt-request-time utilization percentage\")\n+  private val exemptSensorName = \"exempt-\" + QuotaType.Request", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0NDQ0Nw==", "bodyText": "nit: maybe use the same record terminology we use elsewhere?", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455844447", "createdAt": "2020-07-16T14:47:43Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.metrics.Sensor.QuotaEnforcementType\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {\n+  def isExceeded: Boolean\n+  def accept(permits: Double): Unit", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0OTQ0MQ==", "bodyText": "We should include Request in the names of these traits and associated classes since these are per-request.", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455849441", "createdAt": "2020-07-16T14:54:18Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.metrics.Sensor.QuotaEnforcementType\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1MTQ2MA==", "bodyText": "Are these called lastXXX because we can record multiple times and we are interested in the last value?", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455851460", "createdAt": "2020-07-16T14:56:58Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.metrics.Sensor.QuotaEnforcementType\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {\n+  def isExceeded: Boolean\n+  def accept(permits: Double): Unit\n+  def throttleTime: Int\n+}\n+\n+/**\n+ * Default quota used when quota is disabled.\n+ */\n+object UnboundedControllerMutationQuota extends ControllerMutationQuota {\n+  override def isExceeded: Boolean = false\n+  override def accept(permits: Double): Unit = ()\n+  override def throttleTime: Int = 0\n+}\n+\n+/**\n+ * The StrictControllerMutationQuota defines a strict quota for a given user/clientId pair. The\n+ * quota is strict meaning that it does not accept any mutations once the quota is exhausted until\n+ * it gets back to the defined rate.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class StrictControllerMutationQuota(private val time: Time,\n+                                    private val quotaSensor: Sensor) extends ControllerMutationQuota {\n+\n+  private var lastThrottleTimeMs = 0L\n+  private var lastRecordedTimeMs = 0L", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1NDgwMA==", "bodyText": "Not sure how this works. We calculated throtle time before creating a topic. Then spent some time using up CPU to create the topic. Are we saying that we should throttle less because the request used up time?", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455854800", "createdAt": "2020-07-16T15:01:23Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.metrics.Sensor.QuotaEnforcementType\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {\n+  def isExceeded: Boolean\n+  def accept(permits: Double): Unit\n+  def throttleTime: Int\n+}\n+\n+/**\n+ * Default quota used when quota is disabled.\n+ */\n+object UnboundedControllerMutationQuota extends ControllerMutationQuota {\n+  override def isExceeded: Boolean = false\n+  override def accept(permits: Double): Unit = ()\n+  override def throttleTime: Int = 0\n+}\n+\n+/**\n+ * The StrictControllerMutationQuota defines a strict quota for a given user/clientId pair. The\n+ * quota is strict meaning that it does not accept any mutations once the quota is exhausted until\n+ * it gets back to the defined rate.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class StrictControllerMutationQuota(private val time: Time,\n+                                    private val quotaSensor: Sensor) extends ControllerMutationQuota {\n+\n+  private var lastThrottleTimeMs = 0L\n+  private var lastRecordedTimeMs = 0L\n+\n+  override def isExceeded: Boolean = lastThrottleTimeMs > 0\n+\n+  override def accept(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor.record(permits, timeMs, QuotaEnforcementType.STRICT)\n+    } catch {\n+      case e: QuotaViolationException =>\n+        lastThrottleTimeMs = ClientQuotaManager.throttleTime(e, timeMs)\n+        lastRecordedTimeMs = timeMs\n+        throw new ThrottlingQuotaExceededException(lastThrottleTimeMs.toInt,\n+          Errors.THROTTLING_QUOTA_EXCEEDED.message)\n+    }\n+  }\n+\n+  override def throttleTime: Int = {\n+    // If a throttle time has been recorded, we adjust it by deducting the time elapsed\n+    // between the recording and now. We do this because `throttleTime` may be called\n+    // long after having recorded it (e.g. when creating topics).\n+    val deltaTimeMs = time.milliseconds - lastRecordedTimeMs\n+    Math.max(0, lastThrottleTimeMs - deltaTimeMs).toInt", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg1NTg2Mw==", "bodyText": "Looks pretty identical to StrictControllerMutationQuota apart from the enforcement type, can we reuse code?", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455855863", "createdAt": "2020-07-16T15:02:55Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,205 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.metrics.Sensor.QuotaEnforcementType\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {\n+  def isExceeded: Boolean\n+  def accept(permits: Double): Unit\n+  def throttleTime: Int\n+}\n+\n+/**\n+ * Default quota used when quota is disabled.\n+ */\n+object UnboundedControllerMutationQuota extends ControllerMutationQuota {\n+  override def isExceeded: Boolean = false\n+  override def accept(permits: Double): Unit = ()\n+  override def throttleTime: Int = 0\n+}\n+\n+/**\n+ * The StrictControllerMutationQuota defines a strict quota for a given user/clientId pair. The\n+ * quota is strict meaning that it does not accept any mutations once the quota is exhausted until\n+ * it gets back to the defined rate.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class StrictControllerMutationQuota(private val time: Time,\n+                                    private val quotaSensor: Sensor) extends ControllerMutationQuota {\n+\n+  private var lastThrottleTimeMs = 0L\n+  private var lastRecordedTimeMs = 0L\n+\n+  override def isExceeded: Boolean = lastThrottleTimeMs > 0\n+\n+  override def accept(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor.record(permits, timeMs, QuotaEnforcementType.STRICT)\n+    } catch {\n+      case e: QuotaViolationException =>\n+        lastThrottleTimeMs = ClientQuotaManager.throttleTime(e, timeMs)\n+        lastRecordedTimeMs = timeMs\n+        throw new ThrottlingQuotaExceededException(lastThrottleTimeMs.toInt,\n+          Errors.THROTTLING_QUOTA_EXCEEDED.message)\n+    }\n+  }\n+\n+  override def throttleTime: Int = {\n+    // If a throttle time has been recorded, we adjust it by deducting the time elapsed\n+    // between the recording and now. We do this because `throttleTime` may be called\n+    // long after having recorded it (e.g. when creating topics).\n+    val deltaTimeMs = time.milliseconds - lastRecordedTimeMs\n+    Math.max(0, lastThrottleTimeMs - deltaTimeMs).toInt\n+  }\n+}\n+\n+/**\n+ * The PermissiveControllerMutationQuota defines a permissive quota for a given user/clientId pair.\n+ * The quota is permissive meaning that it does accept any mutations even if the quota is exhausted.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class PermissiveControllerMutationQuota(private val time: Time,\n+                                        private val quotaSensor: Sensor) extends ControllerMutationQuota {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2Nzk0MA==", "bodyText": "nit: quotas.controllerMutation.newQuotaFor(request, strictSinceVersion=6). Then we can move the comment to the method.", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455867940", "createdAt": "2020-07-16T15:19:28Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1684,25 +1685,29 @@ class KafkaApis(val requestChannel: RequestChannel,\n   }\n \n   def handleCreateTopicsRequest(request: RequestChannel.Request): Unit = {\n+    // Since version 6 of the API, the quota is strictly enforced. Any topic creation\n+    // above the quota is not allowed and rejected with a THROTTLING_QUOTA_EXCEEDED error.\n+    val controllerMutationQuota = quotas.controllerMutation.newQuotaFor(request, 6)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE3Njg1MA=="}, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2ODM5MQ==", "bodyText": "As before, use named argument for strictSinceVersion and comment not necessary here?", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455868391", "createdAt": "2020-07-16T15:20:05Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1746,21 +1751,26 @@ class KafkaApis(val requestChannel: RequestChannel,\n             result.setConfigs(List.empty.asJava)\n               .setNumPartitions(-1)\n               .setReplicationFactor(-1)\n-              .setTopicConfigErrorCode(0.toShort)\n+              .setTopicConfigErrorCode(Errors.NONE.code)\n           }\n         }\n         sendResponseCallback(results)\n       }\n-      adminManager.createTopics(createTopicsRequest.data.timeoutMs,\n-          createTopicsRequest.data.validateOnly,\n-          toCreate,\n-          authorizedForDescribeConfigs,\n-          handleCreateTopicsResults)\n+      adminManager.createTopics(\n+        createTopicsRequest.data.timeoutMs,\n+        createTopicsRequest.data.validateOnly,\n+        toCreate,\n+        authorizedForDescribeConfigs,\n+        controllerMutationQuota,\n+        handleCreateTopicsResults)\n     }\n   }\n \n   def handleCreatePartitionsRequest(request: RequestChannel.Request): Unit = {\n     val createPartitionsRequest = request.body[CreatePartitionsRequest]\n+    // Since version 3 of the API, the quota is strictly enforced. Any partition creation\n+    // above the quota is not allowed and rejected with a THROTTLING_QUOTA_EXCEEDED error.\n+    val controllerMutationQuota = quotas.controllerMutation.newQuotaFor(request, 3)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2ODk0OA==", "bodyText": "Named argument for strictSinceVersion", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455868948", "createdAt": "2020-07-16T15:20:50Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1803,14 +1813,20 @@ class KafkaApis(val requestChannel: RequestChannel,\n         unauthorized.map(_.name -> new ApiError(Errors.TOPIC_AUTHORIZATION_FAILED, \"The topic authorization is failed.\")) ++\n         queuedForDeletion.map(_.name -> new ApiError(Errors.INVALID_TOPIC_EXCEPTION, \"The topic is queued for deletion.\"))\n \n-      adminManager.createPartitions(createPartitionsRequest.data.timeoutMs,\n+      adminManager.createPartitions(\n+        createPartitionsRequest.data.timeoutMs,\n         valid,\n         createPartitionsRequest.data.validateOnly,\n-        request.context.listenerName, result => sendResponseCallback(result ++ errors))\n+        controllerMutationQuota,\n+        result => sendResponseCallback(result ++ errors))\n     }\n   }\n \n   def handleDeleteTopicsRequest(request: RequestChannel.Request): Unit = {\n+    // Since version 5 of the API, the quota is strictly enforced. Any topic deletion\n+    // above the quota is not allowed and rejected with a THROTTLING_QUOTA_EXCEEDED error.\n+    val controllerMutationQuota = quotas.controllerMutation.newQuotaFor(request, 5)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2OTg2OQ==", "bodyText": "nit: Make the last argument a default arg or use named argument since it is not clear what None is.", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455869869", "createdAt": "2020-07-16T15:22:08Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1777,7 +1787,7 @@ class KafkaApis(val requestChannel: RequestChannel,\n           s\"client ${request.header.clientId}.\")\n         responseBody\n       }\n-      sendResponseMaybeThrottle(request, createResponse)\n+      sendResponseMaybeThrottle(controllerMutationQuota, request, createResponse, None)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2OTg3MQ==", "bodyText": "nit: Make the last argument a default arg or use named argument since it is not clear what None is.", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455869871", "createdAt": "2020-07-16T15:22:09Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1777,7 +1787,7 @@ class KafkaApis(val requestChannel: RequestChannel,\n           s\"client ${request.header.clientId}.\")\n         responseBody\n       }\n-      sendResponseMaybeThrottle(request, createResponse)\n+      sendResponseMaybeThrottle(controllerMutationQuota, request, createResponse, None)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg3Njc1NA==", "bodyText": "Can we test using mock time or a different approach that doesn't need these long sleeps?", "url": "https://github.com/apache/kafka/pull/8933#discussion_r455876754", "createdAt": "2020-07-16T15:31:35Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/server/ControllerMutationQuotaTest.scala", "diffHunk": "@@ -0,0 +1,361 @@\n+/**\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ **/\n+package kafka.server\n+\n+import java.util.Properties\n+import java.util.concurrent.ExecutionException\n+import java.util.concurrent.TimeUnit\n+\n+import kafka.utils.TestUtils\n+import org.apache.kafka.common.internals.KafkaFutureImpl\n+import org.apache.kafka.common.message.CreatePartitionsRequestData\n+import org.apache.kafka.common.message.CreatePartitionsRequestData.CreatePartitionsTopic\n+import org.apache.kafka.common.message.CreateTopicsRequestData\n+import org.apache.kafka.common.message.CreateTopicsRequestData.CreatableTopic\n+import org.apache.kafka.common.message.DeleteTopicsRequestData\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.quota.ClientQuotaAlteration\n+import org.apache.kafka.common.quota.ClientQuotaEntity\n+import org.apache.kafka.common.requests.AlterClientQuotasRequest\n+import org.apache.kafka.common.requests.AlterClientQuotasResponse\n+import org.apache.kafka.common.requests.CreatePartitionsRequest\n+import org.apache.kafka.common.requests.CreatePartitionsResponse\n+import org.apache.kafka.common.requests.CreateTopicsRequest\n+import org.apache.kafka.common.requests.CreateTopicsResponse\n+import org.apache.kafka.common.requests.DeleteTopicsRequest\n+import org.apache.kafka.common.requests.DeleteTopicsResponse\n+import org.apache.kafka.common.security.auth.AuthenticationContext\n+import org.apache.kafka.common.security.auth.KafkaPrincipal\n+import org.apache.kafka.common.security.auth.KafkaPrincipalBuilder\n+import org.junit.Assert.assertEquals\n+import org.junit.Assert.assertTrue\n+import org.junit.Before\n+import org.junit.Test\n+\n+import scala.jdk.CollectionConverters._\n+\n+object ControllerMutationQuotaTest {\n+  // Principal used for all client connections. This is updated by each test.\n+  var principal = KafkaPrincipal.ANONYMOUS\n+  class TestPrincipalBuilder extends KafkaPrincipalBuilder {\n+    override def build(context: AuthenticationContext): KafkaPrincipal = {\n+      principal\n+    }\n+  }\n+\n+  def asPrincipal(newPrincipal: KafkaPrincipal)(f: => Unit): Unit = {\n+    val currentPrincipal = principal\n+    principal = newPrincipal\n+    try f\n+    finally principal = currentPrincipal\n+  }\n+\n+  val ThrottledPrincipal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"ThrottledPrincipal\")\n+  val UnboundedPrincipal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"UnboundedPrincipal\")\n+\n+  val StrictCreateTopicsRequestVersion = ApiKeys.CREATE_TOPICS.latestVersion\n+  val PermissiveCreateTopicsRequestVersion = 5.toShort\n+\n+  val StrictDeleteTopicsRequestVersion = ApiKeys.DELETE_TOPICS.latestVersion\n+  val PermissiveDeleteTopicsRequestVersion = 4.toShort\n+\n+  val StrictCreatePartitionsRequestVersion = ApiKeys.CREATE_PARTITIONS.latestVersion\n+  val PermissiveCreatePartitionsRequestVersion = 2.toShort\n+\n+  val TopicsWithOnePartition = Seq(\"topic-1\" ->  1, \"topic-2\" ->  1)\n+  val TopicsWith30Partitions = Seq(\"topic-1\" -> 30, \"topic-2\" -> 30)\n+  val TopicsWith31Partitions = Seq(\"topic-1\" -> 31, \"topic-2\" -> 31)\n+\n+  val ControllerMutationRate = 2.0\n+}\n+\n+class ControllerMutationQuotaTest extends BaseRequestTest {\n+  import ControllerMutationQuotaTest._\n+\n+  override def brokerCount: Int = 1\n+\n+  override def brokerPropertyOverrides(properties: Properties): Unit = {\n+    properties.put(KafkaConfig.ControlledShutdownEnableProp, \"false\")\n+    properties.put(KafkaConfig.OffsetsTopicReplicationFactorProp, \"1\")\n+    properties.put(KafkaConfig.OffsetsTopicPartitionsProp, \"1\")\n+    properties.put(KafkaConfig.PrincipalBuilderClassProp,\n+      classOf[ControllerMutationQuotaTest.TestPrincipalBuilder].getName)\n+    // We use the default number of samples and window size.\n+    properties.put(KafkaConfig.NumControllerQuotaSamplesProp, \"11\")\n+    properties.put(KafkaConfig.ControllerQuotaWindowSizeSecondsProp, \"1\")\n+  }\n+\n+  @Before\n+  override def setUp(): Unit = {\n+    super.setUp()\n+\n+    // Define a quota for ThrottledPrincipal\n+    defineUserQuota(ThrottledPrincipal.getName, Some(ControllerMutationRate))\n+    waitUserQuota(ThrottledPrincipal.getName, ControllerMutationRate)\n+  }\n+\n+  @Test\n+  def testSetUnsetQuota(): Unit = {\n+    val principal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"User\")\n+    // Default Value\n+    waitUserQuota(principal.getName, Long.MaxValue)\n+    // Define a new quota\n+    defineUserQuota(principal.getName, Some(ControllerMutationRate))\n+    // Check it\n+    waitUserQuota(principal.getName, ControllerMutationRate)\n+    // Remove it\n+    defineUserQuota(principal.getName, None)\n+    // Back to the default\n+    waitUserQuota(principal.getName, Long.MaxValue)\n+  }\n+\n+  @Test\n+  def testStrictCreateTopicsRequest(): Unit = {\n+    asPrincipal(ThrottledPrincipal) {\n+      // Create two topics worth of 30 partitions each. As we use a strict quota, we\n+      // expect the first topic to be created and the second to be rejected.\n+      // Theoretically, the throttle time should be bellow or equal to:\n+      // ((30 / 10) - 2) / 2 * 10 = 5s\n+      val (throttleTimeMs1, errors1) = createTopics(TopicsWith30Partitions, StrictCreateTopicsRequestVersion)\n+      assertTrue((5000 - throttleTimeMs1) < 1000)\n+      assertEquals(Seq(Errors.NONE, Errors.THROTTLING_QUOTA_EXCEEDED), errors1)\n+\n+      // The implementation of the Rate has NOT been changed yet so we have to wait past\n+      // the window in order to get the avg rate bellow the quota.\n+      Thread.sleep(11000) // Thread.sleep(throttleTimeMs1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 137}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "edaff3d2b32a683b5a9889cd6c595c1ab7c5e2cd", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/edaff3d2b32a683b5a9889cd6c595c1ab7c5e2cd", "committedDate": "2020-07-17T12:26:50Z", "message": "Protocol"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "125443cd72f7837e96698b8d05d5277eef5395dd", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/125443cd72f7837e96698b8d05d5277eef5395dd", "committedDate": "2020-07-17T12:26:50Z", "message": "Sensor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59fb24c4c055469dc01cf687928ddfb025b07822", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/59fb24c4c055469dc01cf687928ddfb025b07822", "committedDate": "2020-07-17T12:28:26Z", "message": "Quota Manager in Core"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8ba4edeaaee172bc13f2acd22a1d4ed09e9bff9", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/c8ba4edeaaee172bc13f2acd22a1d4ed09e9bff9", "committedDate": "2020-07-17T12:28:26Z", "message": "cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bba2c399c804f349d5c4b8fb4e9db863b9bc484a", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/bba2c399c804f349d5c4b8fb4e9db863b9bc484a", "committedDate": "2020-07-17T12:28:26Z", "message": "Address review"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "bba2c399c804f349d5c4b8fb4e9db863b9bc484a", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/bba2c399c804f349d5c4b8fb4e9db863b9bc484a", "committedDate": "2020-07-17T12:28:26Z", "message": "Address review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9da0bdbcf31d2d2dc6c933c0adddae72a258cb5", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/d9da0bdbcf31d2d2dc6c933c0adddae72a258cb5", "committedDate": "2020-07-17T12:35:21Z", "message": "Address Anna's comment in #8977."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e99fb72236527c04dfaecca52708fa7f209c7e88", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/e99fb72236527c04dfaecca52708fa7f209c7e88", "committedDate": "2020-07-17T13:21:58Z", "message": "address review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc58743728ea9801feed128adce287087b67c918", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/cc58743728ea9801feed128adce287087b67c918", "committedDate": "2020-07-20T08:17:51Z", "message": "Remove QuotaEnforcementType"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3a2968dcb31aa75285c0f20a8fb0492346295e3", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/f3a2968dcb31aa75285c0f20a8fb0492346295e3", "committedDate": "2020-07-20T08:49:01Z", "message": "fix checkstyle errors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNDEwNTQ1", "url": "https://github.com/apache/kafka/pull/8933#pullrequestreview-451410545", "createdAt": "2020-07-20T08:45:10Z", "commit": {"oid": "cc58743728ea9801feed128adce287087b67c918"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwODo0NToxMFrOG0AYow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwOToyODo1NlrOG0CY0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE4NTQ0Mw==", "bodyText": "There are two differences between Strict and Permissive quotas:\n\nAs described above, it does not accept any mutations if quota is already exhausted\nIt does not throttle for any number of mutations if quota is not already exhausted. This is different from the other one which throttles if quota will be exceeded due to the current request.\n\nShould we document the second behaviour as well? I am guessing 2) will be limited by the burst value. Where would that be checked?", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457185443", "createdAt": "2020-07-20T08:45:10Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,240 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {\n+  def isExceeded: Boolean\n+  def record(permits: Double): Unit\n+  def throttleTime: Int\n+}\n+\n+/**\n+ * Default quota used when quota is disabled.\n+ */\n+object UnboundedControllerMutationQuota extends ControllerMutationQuota {\n+  override def isExceeded: Boolean = false\n+  override def record(permits: Double): Unit = ()\n+  override def throttleTime: Int = 0\n+}\n+\n+/**\n+ * The AbstractControllerMutationQuota is the base class of StrictControllerMutationQuota and\n+ * PermissiveControllerMutationQuota.\n+ *\n+ * @param time @Time object to use\n+ */\n+abstract class AbstractControllerMutationQuota(private val time: Time) extends ControllerMutationQuota {\n+  protected var lastThrottleTimeMs = 0L\n+  protected var lastRecordedTimeMs = 0L\n+\n+  protected def updateThrottleTime(e: QuotaViolationException, timeMs: Long): Unit = {\n+    lastThrottleTimeMs = ClientQuotaManager.throttleTime(e, timeMs)\n+    lastRecordedTimeMs = timeMs\n+  }\n+\n+  override def throttleTime: Int = {\n+    // If a throttle time has been recorded, we adjust it by deducting the time elapsed\n+    // between the recording and now. We do this because `throttleTime` may be called\n+    // long after having recorded it, especially when a request waits in the purgatory.\n+    val deltaTimeMs = time.milliseconds - lastRecordedTimeMs\n+    Math.max(0, lastThrottleTimeMs - deltaTimeMs).toInt\n+  }\n+}\n+\n+/**\n+ * The StrictControllerMutationQuota defines a strict quota for a given user/clientId pair. The\n+ * quota is strict meaning that it does not accept any mutations once the quota is exhausted until\n+ * it gets back to the defined rate.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc58743728ea9801feed128adce287087b67c918"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE4NzU0MA==", "bodyText": "typo: below", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457187540", "createdAt": "2020-07-20T08:47:59Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,240 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {\n+  def isExceeded: Boolean\n+  def record(permits: Double): Unit\n+  def throttleTime: Int\n+}\n+\n+/**\n+ * Default quota used when quota is disabled.\n+ */\n+object UnboundedControllerMutationQuota extends ControllerMutationQuota {\n+  override def isExceeded: Boolean = false\n+  override def record(permits: Double): Unit = ()\n+  override def throttleTime: Int = 0\n+}\n+\n+/**\n+ * The AbstractControllerMutationQuota is the base class of StrictControllerMutationQuota and\n+ * PermissiveControllerMutationQuota.\n+ *\n+ * @param time @Time object to use\n+ */\n+abstract class AbstractControllerMutationQuota(private val time: Time) extends ControllerMutationQuota {\n+  protected var lastThrottleTimeMs = 0L\n+  protected var lastRecordedTimeMs = 0L\n+\n+  protected def updateThrottleTime(e: QuotaViolationException, timeMs: Long): Unit = {\n+    lastThrottleTimeMs = ClientQuotaManager.throttleTime(e, timeMs)\n+    lastRecordedTimeMs = timeMs\n+  }\n+\n+  override def throttleTime: Int = {\n+    // If a throttle time has been recorded, we adjust it by deducting the time elapsed\n+    // between the recording and now. We do this because `throttleTime` may be called\n+    // long after having recorded it, especially when a request waits in the purgatory.\n+    val deltaTimeMs = time.milliseconds - lastRecordedTimeMs\n+    Math.max(0, lastThrottleTimeMs - deltaTimeMs).toInt\n+  }\n+}\n+\n+/**\n+ * The StrictControllerMutationQuota defines a strict quota for a given user/clientId pair. The\n+ * quota is strict meaning that it does not accept any mutations once the quota is exhausted until\n+ * it gets back to the defined rate.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class StrictControllerMutationQuota(private val time: Time,\n+                                    private val quotaSensor: Sensor)\n+    extends AbstractControllerMutationQuota(time) {\n+\n+  override def isExceeded: Boolean = lastThrottleTimeMs > 0\n+\n+  override def record(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor synchronized {\n+        quotaSensor.checkQuotas(timeMs)\n+        quotaSensor.record(permits, timeMs, false)\n+      }\n+    } catch {\n+      case e: QuotaViolationException =>\n+        updateThrottleTime(e, timeMs)\n+        throw new ThrottlingQuotaExceededException(lastThrottleTimeMs.toInt,\n+          Errors.THROTTLING_QUOTA_EXCEEDED.message)\n+    }\n+  }\n+}\n+\n+/**\n+ * The PermissiveControllerMutationQuota defines a permissive quota for a given user/clientId pair.\n+ * The quota is permissive meaning that it does accept any mutations even if the quota is exhausted.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class PermissiveControllerMutationQuota(private val time: Time,\n+                                        private val quotaSensor: Sensor)\n+    extends AbstractControllerMutationQuota(time) {\n+\n+  override def isExceeded: Boolean = false\n+\n+  override def record(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor.record(permits, timeMs, true)\n+    } catch {\n+      case e: QuotaViolationException =>\n+        updateThrottleTime(e, timeMs)\n+    }\n+  }\n+}\n+\n+/**\n+ * The ControllerMutationQuotaManager is a specialized ClientQuotaManager used in the context\n+ * of throttling controller's operations/mutations.\n+ *\n+ * @param config @ClientQuotaManagerConfig quota configs\n+ * @param metrics @Metrics Metrics instance\n+ * @param time @Time object to use\n+ * @param threadNamePrefix The thread prefix to use\n+ * @param quotaCallback @ClientQuotaCallback ClientQuotaCallback to use\n+ */\n+class ControllerMutationQuotaManager(private val config: ClientQuotaManagerConfig,\n+                                     private val metrics: Metrics,\n+                                     private val time: Time,\n+                                     private val threadNamePrefix: String,\n+                                     private val quotaCallback: Option[ClientQuotaCallback])\n+    extends ClientQuotaManager(config, metrics, QuotaType.ControllerMutation, time, threadNamePrefix, quotaCallback) {\n+\n+  override protected def clientRateMetricName(quotaMetricTags: Map[String, String]): MetricName = {\n+    metrics.metricName(\"mutation-rate\", QuotaType.ControllerMutation.toString,\n+      \"Tracking mutation-rate per user/client-id\",\n+      quotaMetricTags.asJava)\n+  }\n+\n+  /**\n+   * Records that a user/clientId accumulated or would like to accumulate the provided amount at the\n+   * the specified time, returns throttle time in milliseconds. The quota is strict meaning that it\n+   * does not accept any mutations once the quota is exhausted until it gets back to the defined rate.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @param value The value to accumulate\n+   * @param timeMs The time at which to accumulate the value\n+   * @return The throttle time in milliseconds defines as the time to wait until the average\n+   *         rate gets back to the defined quota\n+   */\n+  override def recordAndGetThrottleTimeMs(session: Session, clientId: String, value: Double, timeMs: Long): Int = {\n+    val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+    val quotaSensor = clientSensors.quotaSensor\n+    try {\n+      quotaSensor synchronized {\n+        quotaSensor.checkQuotas(timeMs)\n+        quotaSensor.record(value, timeMs, false)\n+      }\n+      0\n+    } catch {\n+      case e: QuotaViolationException =>\n+        val throttleTimeMs = throttleTime(e, timeMs).toInt\n+        debug(s\"Quota violated for sensor (${quotaSensor.name}). Delay time: ($throttleTimeMs)\")\n+        throttleTimeMs\n+    }\n+  }\n+\n+  /**\n+   * Returns a StrictControllerMutationQuota for the given session/clientId pair or\n+   * a UnboundedControllerMutationQuota$ if the quota is disabled.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @return ControllerMutationQuota\n+   */\n+  def newStrictQuotaFor(session: Session, clientId: String): ControllerMutationQuota = {\n+    if (quotasEnabled) {\n+      val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+      new StrictControllerMutationQuota(time, clientSensors.quotaSensor)\n+    } else {\n+      UnboundedControllerMutationQuota\n+    }\n+  }\n+\n+  def newStrictQuotaFor(request: RequestChannel.Request): ControllerMutationQuota =\n+    newStrictQuotaFor(request.session, request.header.clientId)\n+\n+  /**\n+   * Returns a PermissiveControllerMutationQuota for the given session/clientId pair or\n+   * a UnboundedControllerMutationQuota$ if the quota is disabled.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @return ControllerMutationQuota\n+   */\n+  def newPermissiveQuotaFor(session: Session, clientId: String): ControllerMutationQuota = {\n+    if (quotasEnabled) {\n+      val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+      new PermissiveControllerMutationQuota(time, clientSensors.quotaSensor)\n+    } else {\n+      UnboundedControllerMutationQuota\n+    }\n+  }\n+\n+  def newPermissiveQuotaFor(request: RequestChannel.Request): ControllerMutationQuota =\n+    newPermissiveQuotaFor(request.session, request.header.clientId)\n+\n+  /**\n+   * Returns a ControllerMutationQuota based on `strictSinceVersion`. It returns a strict\n+   * quota if the version is equal to or above of the `strictSinceVersion`, a permissive\n+   * quota if the version is bellow, and a unbounded quota if the quota is disabled.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc58743728ea9801feed128adce287087b67c918"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5MTg4OQ==", "bodyText": "nit: user/clientId pair?", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457191889", "createdAt": "2020-07-20T08:53:44Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,240 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {\n+  def isExceeded: Boolean\n+  def record(permits: Double): Unit\n+  def throttleTime: Int\n+}\n+\n+/**\n+ * Default quota used when quota is disabled.\n+ */\n+object UnboundedControllerMutationQuota extends ControllerMutationQuota {\n+  override def isExceeded: Boolean = false\n+  override def record(permits: Double): Unit = ()\n+  override def throttleTime: Int = 0\n+}\n+\n+/**\n+ * The AbstractControllerMutationQuota is the base class of StrictControllerMutationQuota and\n+ * PermissiveControllerMutationQuota.\n+ *\n+ * @param time @Time object to use\n+ */\n+abstract class AbstractControllerMutationQuota(private val time: Time) extends ControllerMutationQuota {\n+  protected var lastThrottleTimeMs = 0L\n+  protected var lastRecordedTimeMs = 0L\n+\n+  protected def updateThrottleTime(e: QuotaViolationException, timeMs: Long): Unit = {\n+    lastThrottleTimeMs = ClientQuotaManager.throttleTime(e, timeMs)\n+    lastRecordedTimeMs = timeMs\n+  }\n+\n+  override def throttleTime: Int = {\n+    // If a throttle time has been recorded, we adjust it by deducting the time elapsed\n+    // between the recording and now. We do this because `throttleTime` may be called\n+    // long after having recorded it, especially when a request waits in the purgatory.\n+    val deltaTimeMs = time.milliseconds - lastRecordedTimeMs\n+    Math.max(0, lastThrottleTimeMs - deltaTimeMs).toInt\n+  }\n+}\n+\n+/**\n+ * The StrictControllerMutationQuota defines a strict quota for a given user/clientId pair. The\n+ * quota is strict meaning that it does not accept any mutations once the quota is exhausted until\n+ * it gets back to the defined rate.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class StrictControllerMutationQuota(private val time: Time,\n+                                    private val quotaSensor: Sensor)\n+    extends AbstractControllerMutationQuota(time) {\n+\n+  override def isExceeded: Boolean = lastThrottleTimeMs > 0\n+\n+  override def record(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor synchronized {\n+        quotaSensor.checkQuotas(timeMs)\n+        quotaSensor.record(permits, timeMs, false)\n+      }\n+    } catch {\n+      case e: QuotaViolationException =>\n+        updateThrottleTime(e, timeMs)\n+        throw new ThrottlingQuotaExceededException(lastThrottleTimeMs.toInt,\n+          Errors.THROTTLING_QUOTA_EXCEEDED.message)\n+    }\n+  }\n+}\n+\n+/**\n+ * The PermissiveControllerMutationQuota defines a permissive quota for a given user/clientId pair.\n+ * The quota is permissive meaning that it does accept any mutations even if the quota is exhausted.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class PermissiveControllerMutationQuota(private val time: Time,\n+                                        private val quotaSensor: Sensor)\n+    extends AbstractControllerMutationQuota(time) {\n+\n+  override def isExceeded: Boolean = false\n+\n+  override def record(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor.record(permits, timeMs, true)\n+    } catch {\n+      case e: QuotaViolationException =>\n+        updateThrottleTime(e, timeMs)\n+    }\n+  }\n+}\n+\n+/**\n+ * The ControllerMutationQuotaManager is a specialized ClientQuotaManager used in the context\n+ * of throttling controller's operations/mutations.\n+ *\n+ * @param config @ClientQuotaManagerConfig quota configs\n+ * @param metrics @Metrics Metrics instance\n+ * @param time @Time object to use\n+ * @param threadNamePrefix The thread prefix to use\n+ * @param quotaCallback @ClientQuotaCallback ClientQuotaCallback to use\n+ */\n+class ControllerMutationQuotaManager(private val config: ClientQuotaManagerConfig,\n+                                     private val metrics: Metrics,\n+                                     private val time: Time,\n+                                     private val threadNamePrefix: String,\n+                                     private val quotaCallback: Option[ClientQuotaCallback])\n+    extends ClientQuotaManager(config, metrics, QuotaType.ControllerMutation, time, threadNamePrefix, quotaCallback) {\n+\n+  override protected def clientRateMetricName(quotaMetricTags: Map[String, String]): MetricName = {\n+    metrics.metricName(\"mutation-rate\", QuotaType.ControllerMutation.toString,\n+      \"Tracking mutation-rate per user/client-id\",\n+      quotaMetricTags.asJava)\n+  }\n+\n+  /**\n+   * Records that a user/clientId accumulated or would like to accumulate the provided amount at the\n+   * the specified time, returns throttle time in milliseconds. The quota is strict meaning that it\n+   * does not accept any mutations once the quota is exhausted until it gets back to the defined rate.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @param value The value to accumulate\n+   * @param timeMs The time at which to accumulate the value\n+   * @return The throttle time in milliseconds defines as the time to wait until the average\n+   *         rate gets back to the defined quota\n+   */\n+  override def recordAndGetThrottleTimeMs(session: Session, clientId: String, value: Double, timeMs: Long): Int = {\n+    val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+    val quotaSensor = clientSensors.quotaSensor\n+    try {\n+      quotaSensor synchronized {\n+        quotaSensor.checkQuotas(timeMs)\n+        quotaSensor.record(value, timeMs, false)\n+      }\n+      0\n+    } catch {\n+      case e: QuotaViolationException =>\n+        val throttleTimeMs = throttleTime(e, timeMs).toInt\n+        debug(s\"Quota violated for sensor (${quotaSensor.name}). Delay time: ($throttleTimeMs)\")\n+        throttleTimeMs\n+    }\n+  }\n+\n+  /**\n+   * Returns a StrictControllerMutationQuota for the given session/clientId pair or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc58743728ea9801feed128adce287087b67c918"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5MjIyMA==", "bodyText": "nit: user/clientId pair?", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457192220", "createdAt": "2020-07-20T08:54:09Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,240 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {\n+  def isExceeded: Boolean\n+  def record(permits: Double): Unit\n+  def throttleTime: Int\n+}\n+\n+/**\n+ * Default quota used when quota is disabled.\n+ */\n+object UnboundedControllerMutationQuota extends ControllerMutationQuota {\n+  override def isExceeded: Boolean = false\n+  override def record(permits: Double): Unit = ()\n+  override def throttleTime: Int = 0\n+}\n+\n+/**\n+ * The AbstractControllerMutationQuota is the base class of StrictControllerMutationQuota and\n+ * PermissiveControllerMutationQuota.\n+ *\n+ * @param time @Time object to use\n+ */\n+abstract class AbstractControllerMutationQuota(private val time: Time) extends ControllerMutationQuota {\n+  protected var lastThrottleTimeMs = 0L\n+  protected var lastRecordedTimeMs = 0L\n+\n+  protected def updateThrottleTime(e: QuotaViolationException, timeMs: Long): Unit = {\n+    lastThrottleTimeMs = ClientQuotaManager.throttleTime(e, timeMs)\n+    lastRecordedTimeMs = timeMs\n+  }\n+\n+  override def throttleTime: Int = {\n+    // If a throttle time has been recorded, we adjust it by deducting the time elapsed\n+    // between the recording and now. We do this because `throttleTime` may be called\n+    // long after having recorded it, especially when a request waits in the purgatory.\n+    val deltaTimeMs = time.milliseconds - lastRecordedTimeMs\n+    Math.max(0, lastThrottleTimeMs - deltaTimeMs).toInt\n+  }\n+}\n+\n+/**\n+ * The StrictControllerMutationQuota defines a strict quota for a given user/clientId pair. The\n+ * quota is strict meaning that it does not accept any mutations once the quota is exhausted until\n+ * it gets back to the defined rate.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class StrictControllerMutationQuota(private val time: Time,\n+                                    private val quotaSensor: Sensor)\n+    extends AbstractControllerMutationQuota(time) {\n+\n+  override def isExceeded: Boolean = lastThrottleTimeMs > 0\n+\n+  override def record(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor synchronized {\n+        quotaSensor.checkQuotas(timeMs)\n+        quotaSensor.record(permits, timeMs, false)\n+      }\n+    } catch {\n+      case e: QuotaViolationException =>\n+        updateThrottleTime(e, timeMs)\n+        throw new ThrottlingQuotaExceededException(lastThrottleTimeMs.toInt,\n+          Errors.THROTTLING_QUOTA_EXCEEDED.message)\n+    }\n+  }\n+}\n+\n+/**\n+ * The PermissiveControllerMutationQuota defines a permissive quota for a given user/clientId pair.\n+ * The quota is permissive meaning that it does accept any mutations even if the quota is exhausted.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class PermissiveControllerMutationQuota(private val time: Time,\n+                                        private val quotaSensor: Sensor)\n+    extends AbstractControllerMutationQuota(time) {\n+\n+  override def isExceeded: Boolean = false\n+\n+  override def record(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor.record(permits, timeMs, true)\n+    } catch {\n+      case e: QuotaViolationException =>\n+        updateThrottleTime(e, timeMs)\n+    }\n+  }\n+}\n+\n+/**\n+ * The ControllerMutationQuotaManager is a specialized ClientQuotaManager used in the context\n+ * of throttling controller's operations/mutations.\n+ *\n+ * @param config @ClientQuotaManagerConfig quota configs\n+ * @param metrics @Metrics Metrics instance\n+ * @param time @Time object to use\n+ * @param threadNamePrefix The thread prefix to use\n+ * @param quotaCallback @ClientQuotaCallback ClientQuotaCallback to use\n+ */\n+class ControllerMutationQuotaManager(private val config: ClientQuotaManagerConfig,\n+                                     private val metrics: Metrics,\n+                                     private val time: Time,\n+                                     private val threadNamePrefix: String,\n+                                     private val quotaCallback: Option[ClientQuotaCallback])\n+    extends ClientQuotaManager(config, metrics, QuotaType.ControllerMutation, time, threadNamePrefix, quotaCallback) {\n+\n+  override protected def clientRateMetricName(quotaMetricTags: Map[String, String]): MetricName = {\n+    metrics.metricName(\"mutation-rate\", QuotaType.ControllerMutation.toString,\n+      \"Tracking mutation-rate per user/client-id\",\n+      quotaMetricTags.asJava)\n+  }\n+\n+  /**\n+   * Records that a user/clientId accumulated or would like to accumulate the provided amount at the\n+   * the specified time, returns throttle time in milliseconds. The quota is strict meaning that it\n+   * does not accept any mutations once the quota is exhausted until it gets back to the defined rate.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @param value The value to accumulate\n+   * @param timeMs The time at which to accumulate the value\n+   * @return The throttle time in milliseconds defines as the time to wait until the average\n+   *         rate gets back to the defined quota\n+   */\n+  override def recordAndGetThrottleTimeMs(session: Session, clientId: String, value: Double, timeMs: Long): Int = {\n+    val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+    val quotaSensor = clientSensors.quotaSensor\n+    try {\n+      quotaSensor synchronized {\n+        quotaSensor.checkQuotas(timeMs)\n+        quotaSensor.record(value, timeMs, false)\n+      }\n+      0\n+    } catch {\n+      case e: QuotaViolationException =>\n+        val throttleTimeMs = throttleTime(e, timeMs).toInt\n+        debug(s\"Quota violated for sensor (${quotaSensor.name}). Delay time: ($throttleTimeMs)\")\n+        throttleTimeMs\n+    }\n+  }\n+\n+  /**\n+   * Returns a StrictControllerMutationQuota for the given session/clientId pair or\n+   * a UnboundedControllerMutationQuota$ if the quota is disabled.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @return ControllerMutationQuota\n+   */\n+  def newStrictQuotaFor(session: Session, clientId: String): ControllerMutationQuota = {\n+    if (quotasEnabled) {\n+      val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+      new StrictControllerMutationQuota(time, clientSensors.quotaSensor)\n+    } else {\n+      UnboundedControllerMutationQuota\n+    }\n+  }\n+\n+  def newStrictQuotaFor(request: RequestChannel.Request): ControllerMutationQuota =\n+    newStrictQuotaFor(request.session, request.header.clientId)\n+\n+  /**\n+   * Returns a PermissiveControllerMutationQuota for the given session/clientId pair or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc58743728ea9801feed128adce287087b67c918"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5MzE5Nw==", "bodyText": "nit: user and clientId of the session", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457193197", "createdAt": "2020-07-20T08:55:24Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -0,0 +1,240 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.network.RequestChannel\n+import kafka.network.RequestChannel.Session\n+import org.apache.kafka.common.MetricName\n+import org.apache.kafka.common.errors.ThrottlingQuotaExceededException\n+import org.apache.kafka.common.metrics.Metrics\n+import org.apache.kafka.common.metrics.QuotaViolationException\n+import org.apache.kafka.common.metrics.Sensor\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+import org.apache.kafka.server.quota.ClientQuotaCallback\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * The ControllerMutationQuota trait defines a quota for a given user/clientId pair. Such\n+ * quota is not meant to be cached forever but rather during the lifetime of processing\n+ * a request.\n+ */\n+trait ControllerMutationQuota {\n+  def isExceeded: Boolean\n+  def record(permits: Double): Unit\n+  def throttleTime: Int\n+}\n+\n+/**\n+ * Default quota used when quota is disabled.\n+ */\n+object UnboundedControllerMutationQuota extends ControllerMutationQuota {\n+  override def isExceeded: Boolean = false\n+  override def record(permits: Double): Unit = ()\n+  override def throttleTime: Int = 0\n+}\n+\n+/**\n+ * The AbstractControllerMutationQuota is the base class of StrictControllerMutationQuota and\n+ * PermissiveControllerMutationQuota.\n+ *\n+ * @param time @Time object to use\n+ */\n+abstract class AbstractControllerMutationQuota(private val time: Time) extends ControllerMutationQuota {\n+  protected var lastThrottleTimeMs = 0L\n+  protected var lastRecordedTimeMs = 0L\n+\n+  protected def updateThrottleTime(e: QuotaViolationException, timeMs: Long): Unit = {\n+    lastThrottleTimeMs = ClientQuotaManager.throttleTime(e, timeMs)\n+    lastRecordedTimeMs = timeMs\n+  }\n+\n+  override def throttleTime: Int = {\n+    // If a throttle time has been recorded, we adjust it by deducting the time elapsed\n+    // between the recording and now. We do this because `throttleTime` may be called\n+    // long after having recorded it, especially when a request waits in the purgatory.\n+    val deltaTimeMs = time.milliseconds - lastRecordedTimeMs\n+    Math.max(0, lastThrottleTimeMs - deltaTimeMs).toInt\n+  }\n+}\n+\n+/**\n+ * The StrictControllerMutationQuota defines a strict quota for a given user/clientId pair. The\n+ * quota is strict meaning that it does not accept any mutations once the quota is exhausted until\n+ * it gets back to the defined rate.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class StrictControllerMutationQuota(private val time: Time,\n+                                    private val quotaSensor: Sensor)\n+    extends AbstractControllerMutationQuota(time) {\n+\n+  override def isExceeded: Boolean = lastThrottleTimeMs > 0\n+\n+  override def record(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor synchronized {\n+        quotaSensor.checkQuotas(timeMs)\n+        quotaSensor.record(permits, timeMs, false)\n+      }\n+    } catch {\n+      case e: QuotaViolationException =>\n+        updateThrottleTime(e, timeMs)\n+        throw new ThrottlingQuotaExceededException(lastThrottleTimeMs.toInt,\n+          Errors.THROTTLING_QUOTA_EXCEEDED.message)\n+    }\n+  }\n+}\n+\n+/**\n+ * The PermissiveControllerMutationQuota defines a permissive quota for a given user/clientId pair.\n+ * The quota is permissive meaning that it does accept any mutations even if the quota is exhausted.\n+ *\n+ * @param time @Time object to use\n+ * @param quotaSensor @Sensor object with a defined quota for a given user/clientId pair\n+ */\n+class PermissiveControllerMutationQuota(private val time: Time,\n+                                        private val quotaSensor: Sensor)\n+    extends AbstractControllerMutationQuota(time) {\n+\n+  override def isExceeded: Boolean = false\n+\n+  override def record(permits: Double): Unit = {\n+    val timeMs = time.milliseconds\n+    try {\n+      quotaSensor.record(permits, timeMs, true)\n+    } catch {\n+      case e: QuotaViolationException =>\n+        updateThrottleTime(e, timeMs)\n+    }\n+  }\n+}\n+\n+/**\n+ * The ControllerMutationQuotaManager is a specialized ClientQuotaManager used in the context\n+ * of throttling controller's operations/mutations.\n+ *\n+ * @param config @ClientQuotaManagerConfig quota configs\n+ * @param metrics @Metrics Metrics instance\n+ * @param time @Time object to use\n+ * @param threadNamePrefix The thread prefix to use\n+ * @param quotaCallback @ClientQuotaCallback ClientQuotaCallback to use\n+ */\n+class ControllerMutationQuotaManager(private val config: ClientQuotaManagerConfig,\n+                                     private val metrics: Metrics,\n+                                     private val time: Time,\n+                                     private val threadNamePrefix: String,\n+                                     private val quotaCallback: Option[ClientQuotaCallback])\n+    extends ClientQuotaManager(config, metrics, QuotaType.ControllerMutation, time, threadNamePrefix, quotaCallback) {\n+\n+  override protected def clientRateMetricName(quotaMetricTags: Map[String, String]): MetricName = {\n+    metrics.metricName(\"mutation-rate\", QuotaType.ControllerMutation.toString,\n+      \"Tracking mutation-rate per user/client-id\",\n+      quotaMetricTags.asJava)\n+  }\n+\n+  /**\n+   * Records that a user/clientId accumulated or would like to accumulate the provided amount at the\n+   * the specified time, returns throttle time in milliseconds. The quota is strict meaning that it\n+   * does not accept any mutations once the quota is exhausted until it gets back to the defined rate.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @param value The value to accumulate\n+   * @param timeMs The time at which to accumulate the value\n+   * @return The throttle time in milliseconds defines as the time to wait until the average\n+   *         rate gets back to the defined quota\n+   */\n+  override def recordAndGetThrottleTimeMs(session: Session, clientId: String, value: Double, timeMs: Long): Int = {\n+    val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+    val quotaSensor = clientSensors.quotaSensor\n+    try {\n+      quotaSensor synchronized {\n+        quotaSensor.checkQuotas(timeMs)\n+        quotaSensor.record(value, timeMs, false)\n+      }\n+      0\n+    } catch {\n+      case e: QuotaViolationException =>\n+        val throttleTimeMs = throttleTime(e, timeMs).toInt\n+        debug(s\"Quota violated for sensor (${quotaSensor.name}). Delay time: ($throttleTimeMs)\")\n+        throttleTimeMs\n+    }\n+  }\n+\n+  /**\n+   * Returns a StrictControllerMutationQuota for the given session/clientId pair or\n+   * a UnboundedControllerMutationQuota$ if the quota is disabled.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @return ControllerMutationQuota\n+   */\n+  def newStrictQuotaFor(session: Session, clientId: String): ControllerMutationQuota = {\n+    if (quotasEnabled) {\n+      val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+      new StrictControllerMutationQuota(time, clientSensors.quotaSensor)\n+    } else {\n+      UnboundedControllerMutationQuota\n+    }\n+  }\n+\n+  def newStrictQuotaFor(request: RequestChannel.Request): ControllerMutationQuota =\n+    newStrictQuotaFor(request.session, request.header.clientId)\n+\n+  /**\n+   * Returns a PermissiveControllerMutationQuota for the given session/clientId pair or\n+   * a UnboundedControllerMutationQuota$ if the quota is disabled.\n+   *\n+   * @param session The session from which the user is extracted\n+   * @param clientId The client id\n+   * @return ControllerMutationQuota\n+   */\n+  def newPermissiveQuotaFor(session: Session, clientId: String): ControllerMutationQuota = {\n+    if (quotasEnabled) {\n+      val clientSensors = getOrCreateQuotaSensors(session, clientId)\n+      new PermissiveControllerMutationQuota(time, clientSensors.quotaSensor)\n+    } else {\n+      UnboundedControllerMutationQuota\n+    }\n+  }\n+\n+  def newPermissiveQuotaFor(request: RequestChannel.Request): ControllerMutationQuota =\n+    newPermissiveQuotaFor(request.session, request.header.clientId)\n+\n+  /**\n+   * Returns a ControllerMutationQuota based on `strictSinceVersion`. It returns a strict\n+   * quota if the version is equal to or above of the `strictSinceVersion`, a permissive\n+   * quota if the version is bellow, and a unbounded quota if the quota is disabled.\n+   *\n+   * When the quota is strictly enforced. Any operation above the quota is not allowed\n+   * and rejected with a THROTTLING_QUOTA_EXCEEDED error.\n+   *\n+   * @param request The request to extract the session and the clientId from", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc58743728ea9801feed128adce287087b67c918"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5NTU2OA==", "bodyText": "nit: remove replication", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457195568", "createdAt": "2020-07-20T08:58:32Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/KafkaConfig.scala", "diffHunk": "@@ -864,9 +868,12 @@ object KafkaConfig {\n   val NumQuotaSamplesDoc = \"The number of samples to retain in memory for client quotas\"\n   val NumReplicationQuotaSamplesDoc = \"The number of samples to retain in memory for replication quotas\"\n   val NumAlterLogDirsReplicationQuotaSamplesDoc = \"The number of samples to retain in memory for alter log dirs replication quotas\"\n+  val NumControllerQuotaSamplesDoc = \"The number of samples to retain in memory for controller mutations replication quotas\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc58743728ea9801feed128adce287087b67c918"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE5NzQ1Nw==", "bodyText": "nit: return Option[Int] and the caller can do getOrElse(0)?", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457197457", "createdAt": "2020-07-20T09:00:55Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/MetadataCache.scala", "diffHunk": "@@ -222,6 +222,10 @@ class MetadataCache(brokerId: Int) extends Logging {\n     metadataSnapshot.partitionStates.get(topic).flatMap(_.get(partitionId))\n   }\n \n+  def numPartitions(topic: String): Int = {\n+    metadataSnapshot.partitionStates.get(topic).map(_.size).getOrElse(0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc58743728ea9801feed128adce287087b67c918"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIxMjMzNQ==", "bodyText": "We should log the throttle time in the assertion message. Not sure if < 1000 will result in flaky tests, will see how the PR builds in Jenkins do.", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457212335", "createdAt": "2020-07-20T09:21:09Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/server/ControllerMutationQuotaTest.scala", "diffHunk": "@@ -0,0 +1,352 @@\n+/**\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ **/\n+package kafka.server\n+\n+import java.util.Properties\n+import java.util.concurrent.ExecutionException\n+import java.util.concurrent.TimeUnit\n+\n+import kafka.utils.TestUtils\n+import org.apache.kafka.common.internals.KafkaFutureImpl\n+import org.apache.kafka.common.message.CreatePartitionsRequestData\n+import org.apache.kafka.common.message.CreatePartitionsRequestData.CreatePartitionsTopic\n+import org.apache.kafka.common.message.CreateTopicsRequestData\n+import org.apache.kafka.common.message.CreateTopicsRequestData.CreatableTopic\n+import org.apache.kafka.common.message.DeleteTopicsRequestData\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.quota.ClientQuotaAlteration\n+import org.apache.kafka.common.quota.ClientQuotaEntity\n+import org.apache.kafka.common.requests.AlterClientQuotasRequest\n+import org.apache.kafka.common.requests.AlterClientQuotasResponse\n+import org.apache.kafka.common.requests.CreatePartitionsRequest\n+import org.apache.kafka.common.requests.CreatePartitionsResponse\n+import org.apache.kafka.common.requests.CreateTopicsRequest\n+import org.apache.kafka.common.requests.CreateTopicsResponse\n+import org.apache.kafka.common.requests.DeleteTopicsRequest\n+import org.apache.kafka.common.requests.DeleteTopicsResponse\n+import org.apache.kafka.common.security.auth.AuthenticationContext\n+import org.apache.kafka.common.security.auth.KafkaPrincipal\n+import org.apache.kafka.common.security.auth.KafkaPrincipalBuilder\n+import org.junit.Assert.assertEquals\n+import org.junit.Assert.assertTrue\n+import org.junit.Before\n+import org.junit.Test\n+\n+import scala.jdk.CollectionConverters._\n+\n+object ControllerMutationQuotaTest {\n+  // Principal used for all client connections. This is updated by each test.\n+  var principal = KafkaPrincipal.ANONYMOUS\n+  class TestPrincipalBuilder extends KafkaPrincipalBuilder {\n+    override def build(context: AuthenticationContext): KafkaPrincipal = {\n+      principal\n+    }\n+  }\n+\n+  def asPrincipal(newPrincipal: KafkaPrincipal)(f: => Unit): Unit = {\n+    val currentPrincipal = principal\n+    principal = newPrincipal\n+    try f\n+    finally principal = currentPrincipal\n+  }\n+\n+  val ThrottledPrincipal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"ThrottledPrincipal\")\n+  val UnboundedPrincipal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"UnboundedPrincipal\")\n+\n+  val StrictCreateTopicsRequestVersion = ApiKeys.CREATE_TOPICS.latestVersion\n+  val PermissiveCreateTopicsRequestVersion = 5.toShort\n+\n+  val StrictDeleteTopicsRequestVersion = ApiKeys.DELETE_TOPICS.latestVersion\n+  val PermissiveDeleteTopicsRequestVersion = 4.toShort\n+\n+  val StrictCreatePartitionsRequestVersion = ApiKeys.CREATE_PARTITIONS.latestVersion\n+  val PermissiveCreatePartitionsRequestVersion = 2.toShort\n+\n+  val TopicsWithOnePartition = Seq(\"topic-1\" ->  1, \"topic-2\" ->  1)\n+  val TopicsWith30Partitions = Seq(\"topic-1\" -> 30, \"topic-2\" -> 30)\n+  val TopicsWith31Partitions = Seq(\"topic-1\" -> 31, \"topic-2\" -> 31)\n+\n+  val ControllerMutationRate = 2.0\n+}\n+\n+class ControllerMutationQuotaTest extends BaseRequestTest {\n+  import ControllerMutationQuotaTest._\n+\n+  override def brokerCount: Int = 1\n+\n+  override def brokerPropertyOverrides(properties: Properties): Unit = {\n+    properties.put(KafkaConfig.ControlledShutdownEnableProp, \"false\")\n+    properties.put(KafkaConfig.OffsetsTopicReplicationFactorProp, \"1\")\n+    properties.put(KafkaConfig.OffsetsTopicPartitionsProp, \"1\")\n+    properties.put(KafkaConfig.PrincipalBuilderClassProp,\n+      classOf[ControllerMutationQuotaTest.TestPrincipalBuilder].getName)\n+    // We use the default number of samples and window size.\n+    properties.put(KafkaConfig.NumControllerQuotaSamplesProp, \"11\")\n+    properties.put(KafkaConfig.ControllerQuotaWindowSizeSecondsProp, \"1\")\n+  }\n+\n+  @Before\n+  override def setUp(): Unit = {\n+    super.setUp()\n+\n+    // Define a quota for ThrottledPrincipal\n+    defineUserQuota(ThrottledPrincipal.getName, Some(ControllerMutationRate))\n+    waitUserQuota(ThrottledPrincipal.getName, ControllerMutationRate)\n+  }\n+\n+  @Test\n+  def testSetUnsetQuota(): Unit = {\n+    val principal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"User\")\n+    // Default Value\n+    waitUserQuota(principal.getName, Long.MaxValue)\n+    // Define a new quota\n+    defineUserQuota(principal.getName, Some(ControllerMutationRate))\n+    // Check it\n+    waitUserQuota(principal.getName, ControllerMutationRate)\n+    // Remove it\n+    defineUserQuota(principal.getName, None)\n+    // Back to the default\n+    waitUserQuota(principal.getName, Long.MaxValue)\n+  }\n+\n+  @Test\n+  def testStrictCreateTopicsRequest(): Unit = {\n+    asPrincipal(ThrottledPrincipal) {\n+      // Create two topics worth of 30 partitions each. As we use a strict quota, we\n+      // expect the first topic to be created and the second to be rejected.\n+      // Theoretically, the throttle time should be below or equal to:\n+      // ((30 / 10) - 2) / 2 * 10 = 5s\n+      val (throttleTimeMs1, errors1) = createTopics(TopicsWith30Partitions, StrictCreateTopicsRequestVersion)\n+      assertTrue((5000 - throttleTimeMs1) < 1000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc58743728ea9801feed128adce287087b67c918"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIxMjgxNg==", "bodyText": "nit: Include actual throttleTimeMs in assertion message (multiple places)", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457212816", "createdAt": "2020-07-20T09:21:46Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/server/ControllerMutationQuotaTest.scala", "diffHunk": "@@ -0,0 +1,352 @@\n+/**\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ **/\n+package kafka.server\n+\n+import java.util.Properties\n+import java.util.concurrent.ExecutionException\n+import java.util.concurrent.TimeUnit\n+\n+import kafka.utils.TestUtils\n+import org.apache.kafka.common.internals.KafkaFutureImpl\n+import org.apache.kafka.common.message.CreatePartitionsRequestData\n+import org.apache.kafka.common.message.CreatePartitionsRequestData.CreatePartitionsTopic\n+import org.apache.kafka.common.message.CreateTopicsRequestData\n+import org.apache.kafka.common.message.CreateTopicsRequestData.CreatableTopic\n+import org.apache.kafka.common.message.DeleteTopicsRequestData\n+import org.apache.kafka.common.protocol.ApiKeys\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.quota.ClientQuotaAlteration\n+import org.apache.kafka.common.quota.ClientQuotaEntity\n+import org.apache.kafka.common.requests.AlterClientQuotasRequest\n+import org.apache.kafka.common.requests.AlterClientQuotasResponse\n+import org.apache.kafka.common.requests.CreatePartitionsRequest\n+import org.apache.kafka.common.requests.CreatePartitionsResponse\n+import org.apache.kafka.common.requests.CreateTopicsRequest\n+import org.apache.kafka.common.requests.CreateTopicsResponse\n+import org.apache.kafka.common.requests.DeleteTopicsRequest\n+import org.apache.kafka.common.requests.DeleteTopicsResponse\n+import org.apache.kafka.common.security.auth.AuthenticationContext\n+import org.apache.kafka.common.security.auth.KafkaPrincipal\n+import org.apache.kafka.common.security.auth.KafkaPrincipalBuilder\n+import org.junit.Assert.assertEquals\n+import org.junit.Assert.assertTrue\n+import org.junit.Before\n+import org.junit.Test\n+\n+import scala.jdk.CollectionConverters._\n+\n+object ControllerMutationQuotaTest {\n+  // Principal used for all client connections. This is updated by each test.\n+  var principal = KafkaPrincipal.ANONYMOUS\n+  class TestPrincipalBuilder extends KafkaPrincipalBuilder {\n+    override def build(context: AuthenticationContext): KafkaPrincipal = {\n+      principal\n+    }\n+  }\n+\n+  def asPrincipal(newPrincipal: KafkaPrincipal)(f: => Unit): Unit = {\n+    val currentPrincipal = principal\n+    principal = newPrincipal\n+    try f\n+    finally principal = currentPrincipal\n+  }\n+\n+  val ThrottledPrincipal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"ThrottledPrincipal\")\n+  val UnboundedPrincipal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"UnboundedPrincipal\")\n+\n+  val StrictCreateTopicsRequestVersion = ApiKeys.CREATE_TOPICS.latestVersion\n+  val PermissiveCreateTopicsRequestVersion = 5.toShort\n+\n+  val StrictDeleteTopicsRequestVersion = ApiKeys.DELETE_TOPICS.latestVersion\n+  val PermissiveDeleteTopicsRequestVersion = 4.toShort\n+\n+  val StrictCreatePartitionsRequestVersion = ApiKeys.CREATE_PARTITIONS.latestVersion\n+  val PermissiveCreatePartitionsRequestVersion = 2.toShort\n+\n+  val TopicsWithOnePartition = Seq(\"topic-1\" ->  1, \"topic-2\" ->  1)\n+  val TopicsWith30Partitions = Seq(\"topic-1\" -> 30, \"topic-2\" -> 30)\n+  val TopicsWith31Partitions = Seq(\"topic-1\" -> 31, \"topic-2\" -> 31)\n+\n+  val ControllerMutationRate = 2.0\n+}\n+\n+class ControllerMutationQuotaTest extends BaseRequestTest {\n+  import ControllerMutationQuotaTest._\n+\n+  override def brokerCount: Int = 1\n+\n+  override def brokerPropertyOverrides(properties: Properties): Unit = {\n+    properties.put(KafkaConfig.ControlledShutdownEnableProp, \"false\")\n+    properties.put(KafkaConfig.OffsetsTopicReplicationFactorProp, \"1\")\n+    properties.put(KafkaConfig.OffsetsTopicPartitionsProp, \"1\")\n+    properties.put(KafkaConfig.PrincipalBuilderClassProp,\n+      classOf[ControllerMutationQuotaTest.TestPrincipalBuilder].getName)\n+    // We use the default number of samples and window size.\n+    properties.put(KafkaConfig.NumControllerQuotaSamplesProp, \"11\")\n+    properties.put(KafkaConfig.ControllerQuotaWindowSizeSecondsProp, \"1\")\n+  }\n+\n+  @Before\n+  override def setUp(): Unit = {\n+    super.setUp()\n+\n+    // Define a quota for ThrottledPrincipal\n+    defineUserQuota(ThrottledPrincipal.getName, Some(ControllerMutationRate))\n+    waitUserQuota(ThrottledPrincipal.getName, ControllerMutationRate)\n+  }\n+\n+  @Test\n+  def testSetUnsetQuota(): Unit = {\n+    val principal = new KafkaPrincipal(KafkaPrincipal.USER_TYPE, \"User\")\n+    // Default Value\n+    waitUserQuota(principal.getName, Long.MaxValue)\n+    // Define a new quota\n+    defineUserQuota(principal.getName, Some(ControllerMutationRate))\n+    // Check it\n+    waitUserQuota(principal.getName, ControllerMutationRate)\n+    // Remove it\n+    defineUserQuota(principal.getName, None)\n+    // Back to the default\n+    waitUserQuota(principal.getName, Long.MaxValue)\n+  }\n+\n+  @Test\n+  def testStrictCreateTopicsRequest(): Unit = {\n+    asPrincipal(ThrottledPrincipal) {\n+      // Create two topics worth of 30 partitions each. As we use a strict quota, we\n+      // expect the first topic to be created and the second to be rejected.\n+      // Theoretically, the throttle time should be below or equal to:\n+      // ((30 / 10) - 2) / 2 * 10 = 5s\n+      val (throttleTimeMs1, errors1) = createTopics(TopicsWith30Partitions, StrictCreateTopicsRequestVersion)\n+      assertTrue((5000 - throttleTimeMs1) < 1000)\n+      assertEquals(Seq(Errors.NONE, Errors.THROTTLING_QUOTA_EXCEEDED), errors1)\n+\n+      // Retry the second topic. It should succeed after the throttling delay is passed and the\n+      // throttle time should be zero.\n+      TestUtils.waitUntilTrue(() => {\n+        val (throttleTimeMs2, errors2) = createTopics(TopicsWith30Partitions.drop(1), StrictCreateTopicsRequestVersion)\n+        throttleTimeMs2 == 0 && errors2 == Seq(Errors.NONE)\n+      }, \"Failed to create topics after having been throttled\")\n+    }\n+  }\n+\n+  @Test\n+  def testPermissiveCreateTopicsRequest(): Unit = {\n+    asPrincipal(ThrottledPrincipal) {\n+      // Create two topics worth of 30 partitions each. As we use a permissive quota, we\n+      // expect both topics to be created.\n+      // Theoretically, the throttle time should be below or equal to:\n+      // ((60 / 10) - 2) / 2 * 10 = 20s\n+      val (throttleTimeMs, errors) = createTopics(TopicsWith30Partitions, PermissiveCreateTopicsRequestVersion)\n+      assertTrue((20000 - throttleTimeMs) < 1000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc58743728ea9801feed128adce287087b67c918"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIxNDU0Ng==", "bodyText": "Seems to be changing a file for no reason", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457214546", "createdAt": "2020-07-20T09:24:09Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/server/ThrottledChannelExpirationTest.scala", "diffHunk": "@@ -14,10 +14,8 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc58743728ea9801feed128adce287087b67c918"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzIxODI1Nw==", "bodyText": "Revert changes to file since nothing has actually changed?", "url": "https://github.com/apache/kafka/pull/8933#discussion_r457218257", "createdAt": "2020-07-20T09:28:56Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/ReplicationQuotaManager.scala", "diffHunk": "@@ -20,13 +20,11 @@ import java.util.concurrent.{ConcurrentHashMap, TimeUnit}\n import java.util.concurrent.locks.ReentrantReadWriteLock\n \n import scala.collection.Seq\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3a2968dcb31aa75285c0f20a8fb0492346295e3"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5363f22fceff60617ecf0092054509b1b09e8b32", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/5363f22fceff60617ecf0092054509b1b09e8b32", "committedDate": "2020-07-20T12:06:58Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b73026e92d723e765503d378b70916c80127da7", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/6b73026e92d723e765503d378b70916c80127da7", "committedDate": "2020-07-20T12:08:27Z", "message": "fixup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNTU3MjI4", "url": "https://github.com/apache/kafka/pull/8933#pullrequestreview-451557228", "createdAt": "2020-07-20T12:25:28Z", "commit": {"oid": "6b73026e92d723e765503d378b70916c80127da7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "227a3907e023a3d2b5193f72c2928ba563928919", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/227a3907e023a3d2b5193f72c2928ba563928919", "committedDate": "2020-07-20T15:04:37Z", "message": "fixup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19eceb5e543561e940d1371d4f4bc5ea81c316b9", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/19eceb5e543561e940d1371d4f4bc5ea81c316b9", "committedDate": "2020-07-21T17:04:00Z", "message": "fix flaky tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cddbeaa9b1d459a047f638811bad5be453fe9cc5", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/cddbeaa9b1d459a047f638811bad5be453fe9cc5", "committedDate": "2020-07-22T12:48:43Z", "message": "Enhance tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7013e950461b6a05a246b7903b4d817dd3c5ed3", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/e7013e950461b6a05a246b7903b4d817dd3c5ed3", "committedDate": "2020-07-22T13:18:50Z", "message": "fix flaky test"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 748, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}