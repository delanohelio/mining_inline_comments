{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1ODE1NDY4", "number": 8259, "title": "KAFKA-7421: Ensure Connect's PluginClassLoader is truly parallel capable and resolve deadlock occurrences", "bodyText": "This PR:\n\nAdds SynchronizationTest class for concurrency testing of the classloading isolation mechanism\nAdds a test which deterministically reproduced a deadlock between simultaneous upward (Plugin -> Delegating) & downward (Delegating -> Plugin) class loading operations.\nMakes PluginClassLoader parallel capable, resolving the above deadlock by allowing multiple threads to concurrently use the PluginClassLoader.\nMakes DelegatingClassLoader parallel capable to allow parallel loading of classes from the parent loader (usually the system class loader)\n\nSigned-off-by: Greg Harris gregh@confluent.io\nMore detailed description of your change,\nif necessary. The PR title and PR message become\nthe squashed commit message, so use a separate\ncomment to ping reviewers.\nSummary of testing strategy (including rationale)\nfor the feature or bug fix. Unit and/or integration\ntests are expected for any behaviour change and\nsystem tests should be considered for larger changes.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-03-09T20:58:21Z", "url": "https://github.com/apache/kafka/pull/8259", "merged": true, "mergeCommit": {"oid": "efd09c2dafb14ed8b0c93be3b35e0d4bd7a81dcb"}, "closed": true, "closedAt": "2021-07-14T17:38:15Z", "author": {"login": "gharris1727"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcMETHCAH2gAyMzg1ODE1NDY4Ojk5MDNiNzc5OGQ4NDJkM2YzNzM0NjhlMzljMmE5OTI0MjI0YTYxZTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABeqYJxQAFqTcwNjUzMjgwMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9903b7798d842d3f373468e39c2a9924224a61e5", "author": {"user": {"login": "gharris1727", "name": "Greg Harris"}}, "url": "https://github.com/apache/kafka/commit/9903b7798d842d3f373468e39c2a9924224a61e5", "committedDate": "2020-03-09T20:53:40Z", "message": "KAFKA-7421: Reproduce Plugin/Delegating ClassLoader deadlock\n\n* Adds SynchronizationTest with a single case\n* Simulates Worker::startConnector and Worker::startTask classloading difference\n\nSigned-off-by: Greg Harris <gregh@confluent.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2686516f494f52fe9089cdf760a3a858c0b50a40", "author": {"user": {"login": "gharris1727", "name": "Greg Harris"}}, "url": "https://github.com/apache/kafka/commit/2686516f494f52fe9089cdf760a3a858c0b50a40", "committedDate": "2020-03-10T01:08:54Z", "message": "Fix some comments and factor out the thread factory to a function\n\nSigned-off-by: Greg Harris <gregh@confluent.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f376a1799a021a02684714219b24e94bfbb208cf", "author": {"user": {"login": "gharris1727", "name": "Greg Harris"}}, "url": "https://github.com/apache/kafka/commit/f376a1799a021a02684714219b24e94bfbb208cf", "committedDate": "2020-03-10T01:09:47Z", "message": "Simplify test by removing second breakpoint\n\nSigned-off-by: Greg Harris <gregh@confluent.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2aadadd16a4c42f543ee61810b18c37f1084c94", "author": {"user": {"login": "gharris1727", "name": "Greg Harris"}}, "url": "https://github.com/apache/kafka/commit/f2aadadd16a4c42f543ee61810b18c37f1084c94", "committedDate": "2020-03-12T23:41:32Z", "message": "Refactor SynchronizationTest to support multiple test methods\n\n* Scope executor pool naming to per-method with TestName rule\n* Don't fail teardown if test contains a deadlock\n* Scope deadlock assertion to only test threads\n\nSigned-off-by: Greg Harris <gregh@confluent.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f499c794580782d73914114b05b778545e2b4e56", "author": {"user": {"login": "gharris1727", "name": "Greg Harris"}}, "url": "https://github.com/apache/kafka/commit/f499c794580782d73914114b05b778545e2b4e56", "committedDate": "2020-03-12T23:41:32Z", "message": "Add back double-breakpoint to SynchronizedDelegatingClassLoader\n\n* Ensures that threads make progress and hold locks before continuing\n* This prevents a race condition in the test where we depended on the debug sleeps\n\nSigned-off-by: Greg Harris <gregh@confluent.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03db64863f5fc22d34b91c2ec5f18abd494b4e88", "author": {"user": {"login": "gharris1727", "name": "Greg Harris"}}, "url": "https://github.com/apache/kafka/commit/03db64863f5fc22d34b91c2ec5f18abd494b4e88", "committedDate": "2020-03-12T23:41:32Z", "message": "Add informative test that isolates forName as the call locking the classloader\n\nSigned-off-by: Greg Harris <gregh@confluent.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "252af473c0b5aa1505a7eb90705063b82818e92a", "author": {"user": {"login": "kkonstantine", "name": "Konstantine Karantasis"}}, "url": "https://github.com/apache/kafka/commit/252af473c0b5aa1505a7eb90705063b82818e92a", "committedDate": "2021-02-25T07:42:33Z", "message": "KAFKA-7421: Remove method lock from PluginClassLoader loadClass"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43c856917efe49853625ca6d0b6512f6370e6736", "author": {"user": {"login": "kkonstantine", "name": "Konstantine Karantasis"}}, "url": "https://github.com/apache/kafka/commit/43c856917efe49853625ca6d0b6512f6370e6736", "committedDate": "2021-02-25T07:44:00Z", "message": "KAFKA-7421: Use concurrent maps in loadClass of DelegatingClassLoader"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "858a37a8bf88db23e5bdd93683c799b840fbf693", "author": {"user": {"login": "kkonstantine", "name": "Konstantine Karantasis"}}, "url": "https://github.com/apache/kafka/commit/858a37a8bf88db23e5bdd93683c799b840fbf693", "committedDate": "2021-02-25T07:44:52Z", "message": "KAFKA-7421: Make the test classloader a parallel classloader in tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk4MjgwMTM1", "url": "https://github.com/apache/kafka/pull/8259#pullrequestreview-598280135", "createdAt": "2021-02-25T07:56:02Z", "commit": {"oid": "858a37a8bf88db23e5bdd93683c799b840fbf693"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNVQwNzo1NjowMlrOIrn9qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNVQwNzo1NjowMlrOIrn9qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjYxNDQ0Mw==", "bodyText": "@gharris1727 I had to remove the expectation for an AssertionError because this test does not reproduce a deadlock anymore. Do we think this test case is still valuable?", "url": "https://github.com/apache/kafka/pull/8259#discussion_r582614443", "createdAt": "2021-02-25T07:56:02Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/SynchronizationTest.java", "diffHunk": "@@ -0,0 +1,468 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.connect.runtime.isolation;\n+\n+import static org.junit.Assert.fail;\n+\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MonitorInfo;\n+import java.lang.management.ThreadInfo;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.common.config.AbstractConfig;\n+import org.apache.kafka.common.config.ConfigDef;\n+import org.apache.kafka.common.config.ConfigDef.Importance;\n+import org.apache.kafka.common.config.ConfigDef.Type;\n+import org.apache.kafka.connect.runtime.WorkerConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SynchronizationTest {\n+\n+    public static final Logger log = LoggerFactory.getLogger(SynchronizationTest.class);\n+\n+    @Rule\n+    public final TestName testName = new TestName();\n+\n+    private String threadPrefix;\n+    private Plugins plugins;\n+    private ThreadPoolExecutor exec;\n+    private Breakpoint<String> dclBreakpoint;\n+    private Breakpoint<String> pclBreakpoint;\n+\n+    @Before\n+    public void setup() {\n+        TestPlugins.assertAvailable();\n+        Map<String, String> pluginProps = Collections.singletonMap(\n+            WorkerConfig.PLUGIN_PATH_CONFIG,\n+            String.join(\",\", TestPlugins.pluginPath())\n+        );\n+        threadPrefix = SynchronizationTest.class.getSimpleName()\n+            + \".\" + testName.getMethodName() + \"-\";\n+        dclBreakpoint = new Breakpoint<>();\n+        pclBreakpoint = new Breakpoint<>();\n+        plugins = new Plugins(pluginProps) {\n+            @Override\n+            protected DelegatingClassLoader newDelegatingClassLoader(List<String> paths) {\n+                return AccessController.doPrivileged(\n+                    (PrivilegedAction<DelegatingClassLoader>) () ->\n+                        new SynchronizedDelegatingClassLoader(paths)\n+                );\n+            }\n+        };\n+        exec = new ThreadPoolExecutor(\n+            2,\n+            2,\n+            1000L,\n+            TimeUnit.MILLISECONDS,\n+            new LinkedBlockingDeque<>(),\n+            threadFactoryWithNamedThreads(threadPrefix)\n+        );\n+\n+    }\n+\n+    @After\n+    public void tearDown() throws InterruptedException {\n+        dclBreakpoint.clear();\n+        pclBreakpoint.clear();\n+        exec.shutdown();\n+        exec.awaitTermination(1L, TimeUnit.SECONDS);\n+    }\n+\n+    private static class Breakpoint<T> {\n+\n+        private Predicate<T> predicate;\n+        private CyclicBarrier barrier;\n+\n+        public synchronized void clear() {\n+            if (barrier != null) {\n+                barrier.reset();\n+            }\n+            predicate = null;\n+            barrier = null;\n+        }\n+\n+        public synchronized void set(Predicate<T> predicate) {\n+            clear();\n+            this.predicate = predicate;\n+            // As soon as the barrier is tripped, the barrier will be reset for the next round.\n+            barrier = new CyclicBarrier(2);\n+        }\n+\n+        /**\n+         * From a thread under test, await for the test orchestrator to continue execution\n+         * @param obj Object to test with the breakpoint's current predicate\n+         */\n+        public void await(T obj) {\n+            Predicate<T> predicate;\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                predicate  = this.predicate;\n+                barrier = this.barrier;\n+            }\n+            if (predicate != null && !predicate.test(obj)) {\n+                return;\n+            }\n+            if (barrier != null) {\n+                try {\n+                    barrier.await();\n+                } catch (InterruptedException | BrokenBarrierException e) {\n+                    throw new RuntimeException(\"Interrupted while waiting for load gate\", e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * From the test orchestrating thread, await for the test thread to continue execution\n+         * @throws InterruptedException If the current thread is interrupted while waiting\n+         * @throws BrokenBarrierException If the test thread is interrupted while waiting\n+         * @throws TimeoutException If the barrier is not reached before 1s passes.\n+         */\n+        public void testAwait()\n+            throws InterruptedException, BrokenBarrierException, TimeoutException {\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                barrier = this.barrier;\n+            }\n+            Objects.requireNonNull(barrier, \"Barrier must be set up before awaiting\");\n+            barrier.await(1L, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private class SynchronizedDelegatingClassLoader extends DelegatingClassLoader {\n+\n+        public SynchronizedDelegatingClassLoader(List<String> pluginPaths) {\n+            super(pluginPaths);\n+        }\n+\n+        @Override\n+        protected PluginClassLoader newPluginClassLoader(\n+            URL pluginLocation,\n+            URL[] urls,\n+            ClassLoader parent\n+        ) {\n+            return AccessController.doPrivileged(\n+                (PrivilegedAction<PluginClassLoader>) () ->\n+                    new SynchronizedPluginClassLoader(pluginLocation, urls, parent)\n+            );\n+        }\n+\n+        @Override\n+        public PluginClassLoader pluginClassLoader(String name) {\n+            dclBreakpoint.await(name);\n+            dclBreakpoint.await(name);\n+            return super.pluginClassLoader(name);\n+        }\n+    }\n+\n+    private class SynchronizedPluginClassLoader extends PluginClassLoader {\n+        {\n+            ClassLoader.registerAsParallelCapable();\n+        }\n+\n+\n+        public SynchronizedPluginClassLoader(URL pluginLocation, URL[] urls, ClassLoader parent) {\n+            super(pluginLocation, urls, parent);\n+        }\n+\n+        @Override\n+        protected Object getClassLoadingLock(String className) {\n+            pclBreakpoint.await(className);\n+            return super.getClassLoadingLock(className);\n+        }\n+    }\n+\n+    @Test(timeout = 15000L)\n+    // If the test times out, then there's a deadlock in the test but not necessarily the code\n+    public void workerContextClassLoaderMismatch() throws Exception {\n+        // Grab a reference to the target PluginClassLoader before activating breakpoints\n+        ClassLoader connectorLoader = plugins.delegatingLoader()\n+            .connectorLoader(TestPlugins.SAMPLING_CONVERTER);\n+\n+        // Simulate Worker::startConnector that creates configs with the delegating classloader\n+        Runnable delegatingToPlugin = () -> {\n+            // Use the DelegatingClassLoader as the current context loader\n+            ClassLoader savedLoader = Plugins.compareAndSwapLoaders(plugins.delegatingLoader());\n+\n+            // Load an isolated plugin from the delegating classloader, which will\n+            // 1. Lock the DelegatingClassLoader (via Class.forName)\n+            // 2. Wait for test to continue\n+            // 3. Attempt to lock the PluginClassLoader (via PluginClassLoader::loadClass)\n+            // 4. Deadlock\n+            new AbstractConfig(\n+                new ConfigDef().define(\"a.class\", Type.CLASS, Importance.HIGH, \"\"),\n+                Collections.singletonMap(\"a.class\", TestPlugins.SAMPLING_CONVERTER));\n+            Plugins.compareAndSwapLoaders(savedLoader);\n+        };\n+        // DelegatingClassLoader breakpoint will only trigger on this thread\n+        dclBreakpoint.set(TestPlugins.SAMPLING_CONVERTER::equals);\n+\n+        // Simulate Worker::startTask that creates configs with the plugin classloader\n+        Runnable pluginToDelegating = () -> {\n+            // Use the PluginClassLoader as the current context loader\n+            ClassLoader savedLoader = Plugins.compareAndSwapLoaders(connectorLoader);\n+            // Load a non-isolated class from the plugin classloader, which will\n+            // 1. Lock the PluginClassLoader (via PluginClassLoader::loadClass)\n+            // 2. Wait for the test to continue\n+            // 3. Attempt to lock the DelegatingClassLoader (via ClassLoader::loadClass)\n+            // 4. Deadlock\n+            new AbstractConfig(new ConfigDef().define(\"a.class\", Type.CLASS, Importance.HIGH, \"\"),\n+                Collections.singletonMap(\"a.class\", \"org.apache.kafka.connect.storage.JsonConverter\"));\n+            Plugins.compareAndSwapLoaders(savedLoader);\n+        };\n+        // PluginClassLoader breakpoint will only trigger on this thread\n+        pclBreakpoint.set(\"org.apache.kafka.connect.storage.JsonConverter\"::equals);\n+\n+        // Step 1: Lock the delegating classloader and pause\n+        exec.submit(delegatingToPlugin);\n+        // d2p enters ConfigDef::parseType\n+        // d2p enters DelegatingClassLoader::loadClass\n+        dclBreakpoint.testAwait();\n+        dclBreakpoint.testAwait();\n+        // d2p exits DelegatingClassLoader::loadClass\n+        // d2p enters Class::forName\n+        // d2p LOCKS DelegatingClassLoader\n+        // d2p enters DelegatingClassLoader::loadClass\n+        dclBreakpoint.testAwait();\n+        // d2p waits in the delegating classloader while we set up the other thread\n+        dumpThreads(\"d2p waiting with DelegatingClassLoader locked\");\n+\n+        // Step 2: Lock the plugin classloader and then the delegating classloader\n+        exec.submit(pluginToDelegating);\n+        // p2d enters PluginClassLoader::loadClass\n+        // p2d LOCKS PluginClassLoader\n+        pclBreakpoint.testAwait();\n+        // p2d locks the class-specific classLoadingLock\n+        // p2d falls through to ClassLoader::loadClass\n+        pclBreakpoint.testAwait();\n+        // p2d locks the class-specific classLoadingLock\n+        // p2d delegates upwards to DelegatingClassLoader::loadClass\n+        // p2d enters ClassLoader::loadClass\n+        // p2d LOCKS DelegatingClassLoader (starting the deadlock)\n+        dumpThreads(\"p2d blocked trying to acquire the DelegatingClassLoader lock\");\n+\n+        // Step 3: Resume the first thread and try to lock the plugin classloader\n+        dclBreakpoint.testAwait();\n+        // d2p enters PluginClassLoader::loadClass\n+        // d2p LOCKS PluginClassLoader (completing the deadlock)\n+        dumpThreads(\"d2p blocked trying to acquire the PluginClassLoader lock\");\n+        assertNoDeadlocks();\n+    }\n+\n+    // This is an informative test that is supposed to fail, demonstrating that forName is\n+    // locking the connectorLoader in this JVM implementation, when initialize is true.\n+    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "858a37a8bf88db23e5bdd93683c799b840fbf693"}, "originalPosition": 291}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAxMjAwNzg4", "url": "https://github.com/apache/kafka/pull/8259#pullrequestreview-601200788", "createdAt": "2021-03-01T21:53:16Z", "commit": {"oid": "858a37a8bf88db23e5bdd93683c799b840fbf693"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMVQyMTo1MzoxNlrOIt-PPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wMVQyMTo1NjozOVrOIt-XLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTA3NjU0MA==", "bodyText": "Let's remove if this does not apply.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // This also becomes non-functional\n          \n          \n            \n                    //if (i < stackTrace.length) {\n          \n          \n            \n                    //sb.append(\"\\t...\");\n          \n          \n            \n                    //sb.append('\\n');\n          \n          \n            \n                    //}", "url": "https://github.com/apache/kafka/pull/8259#discussion_r585076540", "createdAt": "2021-03-01T21:53:16Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/SynchronizationTest.java", "diffHunk": "@@ -0,0 +1,468 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.connect.runtime.isolation;\n+\n+import static org.junit.Assert.fail;\n+\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MonitorInfo;\n+import java.lang.management.ThreadInfo;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.common.config.AbstractConfig;\n+import org.apache.kafka.common.config.ConfigDef;\n+import org.apache.kafka.common.config.ConfigDef.Importance;\n+import org.apache.kafka.common.config.ConfigDef.Type;\n+import org.apache.kafka.connect.runtime.WorkerConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SynchronizationTest {\n+\n+    public static final Logger log = LoggerFactory.getLogger(SynchronizationTest.class);\n+\n+    @Rule\n+    public final TestName testName = new TestName();\n+\n+    private String threadPrefix;\n+    private Plugins plugins;\n+    private ThreadPoolExecutor exec;\n+    private Breakpoint<String> dclBreakpoint;\n+    private Breakpoint<String> pclBreakpoint;\n+\n+    @Before\n+    public void setup() {\n+        TestPlugins.assertAvailable();\n+        Map<String, String> pluginProps = Collections.singletonMap(\n+            WorkerConfig.PLUGIN_PATH_CONFIG,\n+            String.join(\",\", TestPlugins.pluginPath())\n+        );\n+        threadPrefix = SynchronizationTest.class.getSimpleName()\n+            + \".\" + testName.getMethodName() + \"-\";\n+        dclBreakpoint = new Breakpoint<>();\n+        pclBreakpoint = new Breakpoint<>();\n+        plugins = new Plugins(pluginProps) {\n+            @Override\n+            protected DelegatingClassLoader newDelegatingClassLoader(List<String> paths) {\n+                return AccessController.doPrivileged(\n+                    (PrivilegedAction<DelegatingClassLoader>) () ->\n+                        new SynchronizedDelegatingClassLoader(paths)\n+                );\n+            }\n+        };\n+        exec = new ThreadPoolExecutor(\n+            2,\n+            2,\n+            1000L,\n+            TimeUnit.MILLISECONDS,\n+            new LinkedBlockingDeque<>(),\n+            threadFactoryWithNamedThreads(threadPrefix)\n+        );\n+\n+    }\n+\n+    @After\n+    public void tearDown() throws InterruptedException {\n+        dclBreakpoint.clear();\n+        pclBreakpoint.clear();\n+        exec.shutdown();\n+        exec.awaitTermination(1L, TimeUnit.SECONDS);\n+    }\n+\n+    private static class Breakpoint<T> {\n+\n+        private Predicate<T> predicate;\n+        private CyclicBarrier barrier;\n+\n+        public synchronized void clear() {\n+            if (barrier != null) {\n+                barrier.reset();\n+            }\n+            predicate = null;\n+            barrier = null;\n+        }\n+\n+        public synchronized void set(Predicate<T> predicate) {\n+            clear();\n+            this.predicate = predicate;\n+            // As soon as the barrier is tripped, the barrier will be reset for the next round.\n+            barrier = new CyclicBarrier(2);\n+        }\n+\n+        /**\n+         * From a thread under test, await for the test orchestrator to continue execution\n+         * @param obj Object to test with the breakpoint's current predicate\n+         */\n+        public void await(T obj) {\n+            Predicate<T> predicate;\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                predicate  = this.predicate;\n+                barrier = this.barrier;\n+            }\n+            if (predicate != null && !predicate.test(obj)) {\n+                return;\n+            }\n+            if (barrier != null) {\n+                try {\n+                    barrier.await();\n+                } catch (InterruptedException | BrokenBarrierException e) {\n+                    throw new RuntimeException(\"Interrupted while waiting for load gate\", e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * From the test orchestrating thread, await for the test thread to continue execution\n+         * @throws InterruptedException If the current thread is interrupted while waiting\n+         * @throws BrokenBarrierException If the test thread is interrupted while waiting\n+         * @throws TimeoutException If the barrier is not reached before 1s passes.\n+         */\n+        public void testAwait()\n+            throws InterruptedException, BrokenBarrierException, TimeoutException {\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                barrier = this.barrier;\n+            }\n+            Objects.requireNonNull(barrier, \"Barrier must be set up before awaiting\");\n+            barrier.await(1L, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private class SynchronizedDelegatingClassLoader extends DelegatingClassLoader {\n+\n+        public SynchronizedDelegatingClassLoader(List<String> pluginPaths) {\n+            super(pluginPaths);\n+        }\n+\n+        @Override\n+        protected PluginClassLoader newPluginClassLoader(\n+            URL pluginLocation,\n+            URL[] urls,\n+            ClassLoader parent\n+        ) {\n+            return AccessController.doPrivileged(\n+                (PrivilegedAction<PluginClassLoader>) () ->\n+                    new SynchronizedPluginClassLoader(pluginLocation, urls, parent)\n+            );\n+        }\n+\n+        @Override\n+        public PluginClassLoader pluginClassLoader(String name) {\n+            dclBreakpoint.await(name);\n+            dclBreakpoint.await(name);\n+            return super.pluginClassLoader(name);\n+        }\n+    }\n+\n+    private class SynchronizedPluginClassLoader extends PluginClassLoader {\n+        {\n+            ClassLoader.registerAsParallelCapable();\n+        }\n+\n+\n+        public SynchronizedPluginClassLoader(URL pluginLocation, URL[] urls, ClassLoader parent) {\n+            super(pluginLocation, urls, parent);\n+        }\n+\n+        @Override\n+        protected Object getClassLoadingLock(String className) {\n+            pclBreakpoint.await(className);\n+            return super.getClassLoadingLock(className);\n+        }\n+    }\n+\n+    @Test(timeout = 15000L)\n+    // If the test times out, then there's a deadlock in the test but not necessarily the code\n+    public void workerContextClassLoaderMismatch() throws Exception {\n+        // Grab a reference to the target PluginClassLoader before activating breakpoints\n+        ClassLoader connectorLoader = plugins.delegatingLoader()\n+            .connectorLoader(TestPlugins.SAMPLING_CONVERTER);\n+\n+        // Simulate Worker::startConnector that creates configs with the delegating classloader\n+        Runnable delegatingToPlugin = () -> {\n+            // Use the DelegatingClassLoader as the current context loader\n+            ClassLoader savedLoader = Plugins.compareAndSwapLoaders(plugins.delegatingLoader());\n+\n+            // Load an isolated plugin from the delegating classloader, which will\n+            // 1. Lock the DelegatingClassLoader (via Class.forName)\n+            // 2. Wait for test to continue\n+            // 3. Attempt to lock the PluginClassLoader (via PluginClassLoader::loadClass)\n+            // 4. Deadlock\n+            new AbstractConfig(\n+                new ConfigDef().define(\"a.class\", Type.CLASS, Importance.HIGH, \"\"),\n+                Collections.singletonMap(\"a.class\", TestPlugins.SAMPLING_CONVERTER));\n+            Plugins.compareAndSwapLoaders(savedLoader);\n+        };\n+        // DelegatingClassLoader breakpoint will only trigger on this thread\n+        dclBreakpoint.set(TestPlugins.SAMPLING_CONVERTER::equals);\n+\n+        // Simulate Worker::startTask that creates configs with the plugin classloader\n+        Runnable pluginToDelegating = () -> {\n+            // Use the PluginClassLoader as the current context loader\n+            ClassLoader savedLoader = Plugins.compareAndSwapLoaders(connectorLoader);\n+            // Load a non-isolated class from the plugin classloader, which will\n+            // 1. Lock the PluginClassLoader (via PluginClassLoader::loadClass)\n+            // 2. Wait for the test to continue\n+            // 3. Attempt to lock the DelegatingClassLoader (via ClassLoader::loadClass)\n+            // 4. Deadlock\n+            new AbstractConfig(new ConfigDef().define(\"a.class\", Type.CLASS, Importance.HIGH, \"\"),\n+                Collections.singletonMap(\"a.class\", \"org.apache.kafka.connect.storage.JsonConverter\"));\n+            Plugins.compareAndSwapLoaders(savedLoader);\n+        };\n+        // PluginClassLoader breakpoint will only trigger on this thread\n+        pclBreakpoint.set(\"org.apache.kafka.connect.storage.JsonConverter\"::equals);\n+\n+        // Step 1: Lock the delegating classloader and pause\n+        exec.submit(delegatingToPlugin);\n+        // d2p enters ConfigDef::parseType\n+        // d2p enters DelegatingClassLoader::loadClass\n+        dclBreakpoint.testAwait();\n+        dclBreakpoint.testAwait();\n+        // d2p exits DelegatingClassLoader::loadClass\n+        // d2p enters Class::forName\n+        // d2p LOCKS DelegatingClassLoader\n+        // d2p enters DelegatingClassLoader::loadClass\n+        dclBreakpoint.testAwait();\n+        // d2p waits in the delegating classloader while we set up the other thread\n+        dumpThreads(\"d2p waiting with DelegatingClassLoader locked\");\n+\n+        // Step 2: Lock the plugin classloader and then the delegating classloader\n+        exec.submit(pluginToDelegating);\n+        // p2d enters PluginClassLoader::loadClass\n+        // p2d LOCKS PluginClassLoader\n+        pclBreakpoint.testAwait();\n+        // p2d locks the class-specific classLoadingLock\n+        // p2d falls through to ClassLoader::loadClass\n+        pclBreakpoint.testAwait();\n+        // p2d locks the class-specific classLoadingLock\n+        // p2d delegates upwards to DelegatingClassLoader::loadClass\n+        // p2d enters ClassLoader::loadClass\n+        // p2d LOCKS DelegatingClassLoader (starting the deadlock)\n+        dumpThreads(\"p2d blocked trying to acquire the DelegatingClassLoader lock\");\n+\n+        // Step 3: Resume the first thread and try to lock the plugin classloader\n+        dclBreakpoint.testAwait();\n+        // d2p enters PluginClassLoader::loadClass\n+        // d2p LOCKS PluginClassLoader (completing the deadlock)\n+        dumpThreads(\"d2p blocked trying to acquire the PluginClassLoader lock\");\n+        assertNoDeadlocks();\n+    }\n+\n+    // This is an informative test that is supposed to fail, demonstrating that forName is\n+    // locking the connectorLoader in this JVM implementation, when initialize is true.\n+    @Test\n+    public void forNameLocksClassloader()\n+        throws InterruptedException, TimeoutException, BrokenBarrierException {\n+        // It is not important here that we're using the PluginClassLoader.\n+        // This behavior is specific to the JVM, not the classloader implementation\n+        // It is just a convenient classloader instance that we can throw away after the test\n+        ClassLoader connectorLoader = plugins.delegatingLoader()\n+            .connectorLoader(TestPlugins.SAMPLING_CONVERTER);\n+\n+        Object monitor = new Object();\n+        Breakpoint<Object> monitorBreakpoint = new Breakpoint<>();\n+        Breakpoint<Object> progress = new Breakpoint<>();\n+\n+        Runnable executeForName = () -> {\n+            synchronized (monitor) {\n+                try {\n+                    progress.await(null);\n+                    Class.forName(TestPlugins.SAMPLING_CONVERTER, true, connectorLoader);\n+                } catch (ClassNotFoundException e) {\n+                    throw new RuntimeException(\"Failed to load test plugin\", e);\n+                }\n+            }\n+        };\n+        progress.set(null);\n+\n+        Runnable holdsMonitorLock = () -> {\n+            synchronized (connectorLoader) {\n+                monitorBreakpoint.await(null);\n+                monitorBreakpoint.await(null);\n+                synchronized (monitor) {\n+                }\n+            }\n+        };\n+        monitorBreakpoint.set(null);\n+\n+        exec.submit(holdsMonitorLock);\n+        // LOCK the classloader\n+        // wait for test to progress\n+        dumpThreads(\"locked the classloader\");\n+        monitorBreakpoint.testAwait();\n+\n+        exec.submit(executeForName);\n+        progress.testAwait();\n+        // LOCK the monitor\n+        // LOCK the classloader (starting the deadlock)\n+        dumpThreads(\"half-deadlocked\");\n+        monitorBreakpoint.testAwait();\n+        // LOCK the monitor (completing the deadlock)\n+\n+        assertNoDeadlocks();\n+    }\n+\n+    private boolean threadFromCurrentTest(ThreadInfo threadInfo) {\n+        return threadInfo.getThreadName().startsWith(threadPrefix);\n+    }\n+\n+    private void assertNoDeadlocks() {\n+        long[] deadlockedThreads = ManagementFactory.getThreadMXBean().findDeadlockedThreads();\n+        if (deadlockedThreads != null && deadlockedThreads.length > 0) {\n+            final String threads = Arrays\n+                .stream(ManagementFactory.getThreadMXBean().getThreadInfo(deadlockedThreads))\n+                .filter(this::threadFromCurrentTest)\n+                .map(SynchronizationTest::threadInfoToString)\n+                .collect(Collectors.joining(\"\"));\n+            if (!threads.isEmpty()) {\n+                fail(\"Found deadlocked threads while classloading\\n\" + threads);\n+            }\n+        }\n+    }\n+\n+    private void dumpThreads(String msg) throws InterruptedException {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"{}:\\n{}\",\n+                msg,\n+                Arrays.stream(ManagementFactory.getThreadMXBean().dumpAllThreads(true, true))\n+                    .filter(this::threadFromCurrentTest)\n+                    .map(SynchronizationTest::threadInfoToString)\n+                    .collect(Collectors.joining(\"\\n\"))\n+            );\n+        }\n+    }\n+\n+    private static String threadInfoToString(ThreadInfo info) {\n+        StringBuilder sb = new StringBuilder(\"\\\"\" + info.getThreadName() + \"\\\"\" +\n+            \" Id=\" + info.getThreadId() + \" \" +\n+            info.getThreadState());\n+        if (info.getLockName() != null) {\n+            sb.append(\" on \" + info.getLockName());\n+        }\n+        if (info.getLockOwnerName() != null) {\n+            sb.append(\" owned by \\\"\" + info.getLockOwnerName() +\n+                \"\\\" Id=\" + info.getLockOwnerId());\n+        }\n+        if (info.isSuspended()) {\n+            sb.append(\" (suspended)\");\n+        }\n+        if (info.isInNative()) {\n+            sb.append(\" (in native)\");\n+        }\n+        sb.append('\\n');\n+        // this has been refactored for checkstyle\n+        printStacktrace(info, sb);\n+        LockInfo[] locks = info.getLockedSynchronizers();\n+        if (locks.length > 0) {\n+            sb.append(\"\\n\\tNumber of locked synchronizers = \" + locks.length);\n+            sb.append('\\n');\n+            for (LockInfo li : locks) {\n+                sb.append(\"\\t- \" + li);\n+                sb.append('\\n');\n+            }\n+        }\n+        sb.append('\\n');\n+        return sb.toString();\n+    }\n+\n+    private static void printStacktrace(ThreadInfo info, StringBuilder sb) {\n+        StackTraceElement[] stackTrace = info.getStackTrace();\n+        int i = 0;\n+        // This is a copy of ThreadInfo::toString but with an unlimited number of frames shown.\n+        //for (; i < stackTrace.length && i < MAX_FRAMES; i++) {\n+        for (; i < stackTrace.length; i++) {\n+            StackTraceElement ste = stackTrace[i];\n+            sb.append(\"\\tat \" + ste.toString());\n+            sb.append('\\n');\n+            if (i == 0 && info.getLockInfo() != null) {\n+                Thread.State ts = info.getThreadState();\n+                switch (ts) {\n+                    case BLOCKED:\n+                        sb.append(\"\\t-  blocked on \" + info.getLockInfo());\n+                        sb.append('\\n');\n+                        break;\n+                    case WAITING:\n+                        sb.append(\"\\t-  waiting on \" + info.getLockInfo());\n+                        sb.append('\\n');\n+                        break;\n+                    case TIMED_WAITING:\n+                        sb.append(\"\\t-  waiting on \" + info.getLockInfo());\n+                        sb.append('\\n');\n+                        break;\n+                    default:\n+                }\n+            }\n+\n+            for (MonitorInfo mi : info.getLockedMonitors()) {\n+                if (mi.getLockedStackDepth() == i) {\n+                    sb.append(\"\\t-  locked \" + mi);\n+                    sb.append('\\n');\n+                }\n+            }\n+        }\n+        // This also becomes non-functional\n+        //if (i < stackTrace.length) {\n+        //sb.append(\"\\t...\");\n+        //sb.append('\\n');\n+        //}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "858a37a8bf88db23e5bdd93683c799b840fbf693"}, "originalPosition": 445}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTA3ODI5Mg==", "bodyText": "Ok, great to hear. I'm all up for leaving a functional unit test in this topic where we were lacking good coverage.\nFeel free to update the comments to make them current.\nEven more importantly, maybe consider adding a high level description on every test to say what we expect to test and assert, because just following each expected call (with most sections having already good comments) does not make it too easy to understand the gist of each test.", "url": "https://github.com/apache/kafka/pull/8259#discussion_r585078292", "createdAt": "2021-03-01T21:56:04Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/SynchronizationTest.java", "diffHunk": "@@ -0,0 +1,468 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.connect.runtime.isolation;\n+\n+import static org.junit.Assert.fail;\n+\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MonitorInfo;\n+import java.lang.management.ThreadInfo;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.common.config.AbstractConfig;\n+import org.apache.kafka.common.config.ConfigDef;\n+import org.apache.kafka.common.config.ConfigDef.Importance;\n+import org.apache.kafka.common.config.ConfigDef.Type;\n+import org.apache.kafka.connect.runtime.WorkerConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SynchronizationTest {\n+\n+    public static final Logger log = LoggerFactory.getLogger(SynchronizationTest.class);\n+\n+    @Rule\n+    public final TestName testName = new TestName();\n+\n+    private String threadPrefix;\n+    private Plugins plugins;\n+    private ThreadPoolExecutor exec;\n+    private Breakpoint<String> dclBreakpoint;\n+    private Breakpoint<String> pclBreakpoint;\n+\n+    @Before\n+    public void setup() {\n+        TestPlugins.assertAvailable();\n+        Map<String, String> pluginProps = Collections.singletonMap(\n+            WorkerConfig.PLUGIN_PATH_CONFIG,\n+            String.join(\",\", TestPlugins.pluginPath())\n+        );\n+        threadPrefix = SynchronizationTest.class.getSimpleName()\n+            + \".\" + testName.getMethodName() + \"-\";\n+        dclBreakpoint = new Breakpoint<>();\n+        pclBreakpoint = new Breakpoint<>();\n+        plugins = new Plugins(pluginProps) {\n+            @Override\n+            protected DelegatingClassLoader newDelegatingClassLoader(List<String> paths) {\n+                return AccessController.doPrivileged(\n+                    (PrivilegedAction<DelegatingClassLoader>) () ->\n+                        new SynchronizedDelegatingClassLoader(paths)\n+                );\n+            }\n+        };\n+        exec = new ThreadPoolExecutor(\n+            2,\n+            2,\n+            1000L,\n+            TimeUnit.MILLISECONDS,\n+            new LinkedBlockingDeque<>(),\n+            threadFactoryWithNamedThreads(threadPrefix)\n+        );\n+\n+    }\n+\n+    @After\n+    public void tearDown() throws InterruptedException {\n+        dclBreakpoint.clear();\n+        pclBreakpoint.clear();\n+        exec.shutdown();\n+        exec.awaitTermination(1L, TimeUnit.SECONDS);\n+    }\n+\n+    private static class Breakpoint<T> {\n+\n+        private Predicate<T> predicate;\n+        private CyclicBarrier barrier;\n+\n+        public synchronized void clear() {\n+            if (barrier != null) {\n+                barrier.reset();\n+            }\n+            predicate = null;\n+            barrier = null;\n+        }\n+\n+        public synchronized void set(Predicate<T> predicate) {\n+            clear();\n+            this.predicate = predicate;\n+            // As soon as the barrier is tripped, the barrier will be reset for the next round.\n+            barrier = new CyclicBarrier(2);\n+        }\n+\n+        /**\n+         * From a thread under test, await for the test orchestrator to continue execution\n+         * @param obj Object to test with the breakpoint's current predicate\n+         */\n+        public void await(T obj) {\n+            Predicate<T> predicate;\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                predicate  = this.predicate;\n+                barrier = this.barrier;\n+            }\n+            if (predicate != null && !predicate.test(obj)) {\n+                return;\n+            }\n+            if (barrier != null) {\n+                try {\n+                    barrier.await();\n+                } catch (InterruptedException | BrokenBarrierException e) {\n+                    throw new RuntimeException(\"Interrupted while waiting for load gate\", e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * From the test orchestrating thread, await for the test thread to continue execution\n+         * @throws InterruptedException If the current thread is interrupted while waiting\n+         * @throws BrokenBarrierException If the test thread is interrupted while waiting\n+         * @throws TimeoutException If the barrier is not reached before 1s passes.\n+         */\n+        public void testAwait()\n+            throws InterruptedException, BrokenBarrierException, TimeoutException {\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                barrier = this.barrier;\n+            }\n+            Objects.requireNonNull(barrier, \"Barrier must be set up before awaiting\");\n+            barrier.await(1L, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private class SynchronizedDelegatingClassLoader extends DelegatingClassLoader {\n+\n+        public SynchronizedDelegatingClassLoader(List<String> pluginPaths) {\n+            super(pluginPaths);\n+        }\n+\n+        @Override\n+        protected PluginClassLoader newPluginClassLoader(\n+            URL pluginLocation,\n+            URL[] urls,\n+            ClassLoader parent\n+        ) {\n+            return AccessController.doPrivileged(\n+                (PrivilegedAction<PluginClassLoader>) () ->\n+                    new SynchronizedPluginClassLoader(pluginLocation, urls, parent)\n+            );\n+        }\n+\n+        @Override\n+        public PluginClassLoader pluginClassLoader(String name) {\n+            dclBreakpoint.await(name);\n+            dclBreakpoint.await(name);\n+            return super.pluginClassLoader(name);\n+        }\n+    }\n+\n+    private class SynchronizedPluginClassLoader extends PluginClassLoader {\n+        {\n+            ClassLoader.registerAsParallelCapable();\n+        }\n+\n+\n+        public SynchronizedPluginClassLoader(URL pluginLocation, URL[] urls, ClassLoader parent) {\n+            super(pluginLocation, urls, parent);\n+        }\n+\n+        @Override\n+        protected Object getClassLoadingLock(String className) {\n+            pclBreakpoint.await(className);\n+            return super.getClassLoadingLock(className);\n+        }\n+    }\n+\n+    @Test(timeout = 15000L)\n+    // If the test times out, then there's a deadlock in the test but not necessarily the code\n+    public void workerContextClassLoaderMismatch() throws Exception {\n+        // Grab a reference to the target PluginClassLoader before activating breakpoints\n+        ClassLoader connectorLoader = plugins.delegatingLoader()\n+            .connectorLoader(TestPlugins.SAMPLING_CONVERTER);\n+\n+        // Simulate Worker::startConnector that creates configs with the delegating classloader\n+        Runnable delegatingToPlugin = () -> {\n+            // Use the DelegatingClassLoader as the current context loader\n+            ClassLoader savedLoader = Plugins.compareAndSwapLoaders(plugins.delegatingLoader());\n+\n+            // Load an isolated plugin from the delegating classloader, which will\n+            // 1. Lock the DelegatingClassLoader (via Class.forName)\n+            // 2. Wait for test to continue\n+            // 3. Attempt to lock the PluginClassLoader (via PluginClassLoader::loadClass)\n+            // 4. Deadlock\n+            new AbstractConfig(\n+                new ConfigDef().define(\"a.class\", Type.CLASS, Importance.HIGH, \"\"),\n+                Collections.singletonMap(\"a.class\", TestPlugins.SAMPLING_CONVERTER));\n+            Plugins.compareAndSwapLoaders(savedLoader);\n+        };\n+        // DelegatingClassLoader breakpoint will only trigger on this thread\n+        dclBreakpoint.set(TestPlugins.SAMPLING_CONVERTER::equals);\n+\n+        // Simulate Worker::startTask that creates configs with the plugin classloader\n+        Runnable pluginToDelegating = () -> {\n+            // Use the PluginClassLoader as the current context loader\n+            ClassLoader savedLoader = Plugins.compareAndSwapLoaders(connectorLoader);\n+            // Load a non-isolated class from the plugin classloader, which will\n+            // 1. Lock the PluginClassLoader (via PluginClassLoader::loadClass)\n+            // 2. Wait for the test to continue\n+            // 3. Attempt to lock the DelegatingClassLoader (via ClassLoader::loadClass)\n+            // 4. Deadlock\n+            new AbstractConfig(new ConfigDef().define(\"a.class\", Type.CLASS, Importance.HIGH, \"\"),\n+                Collections.singletonMap(\"a.class\", \"org.apache.kafka.connect.storage.JsonConverter\"));\n+            Plugins.compareAndSwapLoaders(savedLoader);\n+        };\n+        // PluginClassLoader breakpoint will only trigger on this thread\n+        pclBreakpoint.set(\"org.apache.kafka.connect.storage.JsonConverter\"::equals);\n+\n+        // Step 1: Lock the delegating classloader and pause\n+        exec.submit(delegatingToPlugin);\n+        // d2p enters ConfigDef::parseType\n+        // d2p enters DelegatingClassLoader::loadClass\n+        dclBreakpoint.testAwait();\n+        dclBreakpoint.testAwait();\n+        // d2p exits DelegatingClassLoader::loadClass\n+        // d2p enters Class::forName\n+        // d2p LOCKS DelegatingClassLoader\n+        // d2p enters DelegatingClassLoader::loadClass\n+        dclBreakpoint.testAwait();\n+        // d2p waits in the delegating classloader while we set up the other thread\n+        dumpThreads(\"d2p waiting with DelegatingClassLoader locked\");\n+\n+        // Step 2: Lock the plugin classloader and then the delegating classloader\n+        exec.submit(pluginToDelegating);\n+        // p2d enters PluginClassLoader::loadClass\n+        // p2d LOCKS PluginClassLoader\n+        pclBreakpoint.testAwait();\n+        // p2d locks the class-specific classLoadingLock\n+        // p2d falls through to ClassLoader::loadClass\n+        pclBreakpoint.testAwait();\n+        // p2d locks the class-specific classLoadingLock\n+        // p2d delegates upwards to DelegatingClassLoader::loadClass\n+        // p2d enters ClassLoader::loadClass\n+        // p2d LOCKS DelegatingClassLoader (starting the deadlock)\n+        dumpThreads(\"p2d blocked trying to acquire the DelegatingClassLoader lock\");\n+\n+        // Step 3: Resume the first thread and try to lock the plugin classloader\n+        dclBreakpoint.testAwait();\n+        // d2p enters PluginClassLoader::loadClass\n+        // d2p LOCKS PluginClassLoader (completing the deadlock)\n+        dumpThreads(\"d2p blocked trying to acquire the PluginClassLoader lock\");\n+        assertNoDeadlocks();\n+    }\n+\n+    // This is an informative test that is supposed to fail, demonstrating that forName is\n+    // locking the connectorLoader in this JVM implementation, when initialize is true.\n+    @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjYxNDQ0Mw=="}, "originalCommit": {"oid": "858a37a8bf88db23e5bdd93683c799b840fbf693"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NTA3ODU3Mg==", "bodyText": "let's remove if we don't need it.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    //for (; i < stackTrace.length && i < MAX_FRAMES; i++) {", "url": "https://github.com/apache/kafka/pull/8259#discussion_r585078572", "createdAt": "2021-03-01T21:56:39Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/SynchronizationTest.java", "diffHunk": "@@ -0,0 +1,468 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.connect.runtime.isolation;\n+\n+import static org.junit.Assert.fail;\n+\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MonitorInfo;\n+import java.lang.management.ThreadInfo;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.common.config.AbstractConfig;\n+import org.apache.kafka.common.config.ConfigDef;\n+import org.apache.kafka.common.config.ConfigDef.Importance;\n+import org.apache.kafka.common.config.ConfigDef.Type;\n+import org.apache.kafka.connect.runtime.WorkerConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SynchronizationTest {\n+\n+    public static final Logger log = LoggerFactory.getLogger(SynchronizationTest.class);\n+\n+    @Rule\n+    public final TestName testName = new TestName();\n+\n+    private String threadPrefix;\n+    private Plugins plugins;\n+    private ThreadPoolExecutor exec;\n+    private Breakpoint<String> dclBreakpoint;\n+    private Breakpoint<String> pclBreakpoint;\n+\n+    @Before\n+    public void setup() {\n+        TestPlugins.assertAvailable();\n+        Map<String, String> pluginProps = Collections.singletonMap(\n+            WorkerConfig.PLUGIN_PATH_CONFIG,\n+            String.join(\",\", TestPlugins.pluginPath())\n+        );\n+        threadPrefix = SynchronizationTest.class.getSimpleName()\n+            + \".\" + testName.getMethodName() + \"-\";\n+        dclBreakpoint = new Breakpoint<>();\n+        pclBreakpoint = new Breakpoint<>();\n+        plugins = new Plugins(pluginProps) {\n+            @Override\n+            protected DelegatingClassLoader newDelegatingClassLoader(List<String> paths) {\n+                return AccessController.doPrivileged(\n+                    (PrivilegedAction<DelegatingClassLoader>) () ->\n+                        new SynchronizedDelegatingClassLoader(paths)\n+                );\n+            }\n+        };\n+        exec = new ThreadPoolExecutor(\n+            2,\n+            2,\n+            1000L,\n+            TimeUnit.MILLISECONDS,\n+            new LinkedBlockingDeque<>(),\n+            threadFactoryWithNamedThreads(threadPrefix)\n+        );\n+\n+    }\n+\n+    @After\n+    public void tearDown() throws InterruptedException {\n+        dclBreakpoint.clear();\n+        pclBreakpoint.clear();\n+        exec.shutdown();\n+        exec.awaitTermination(1L, TimeUnit.SECONDS);\n+    }\n+\n+    private static class Breakpoint<T> {\n+\n+        private Predicate<T> predicate;\n+        private CyclicBarrier barrier;\n+\n+        public synchronized void clear() {\n+            if (barrier != null) {\n+                barrier.reset();\n+            }\n+            predicate = null;\n+            barrier = null;\n+        }\n+\n+        public synchronized void set(Predicate<T> predicate) {\n+            clear();\n+            this.predicate = predicate;\n+            // As soon as the barrier is tripped, the barrier will be reset for the next round.\n+            barrier = new CyclicBarrier(2);\n+        }\n+\n+        /**\n+         * From a thread under test, await for the test orchestrator to continue execution\n+         * @param obj Object to test with the breakpoint's current predicate\n+         */\n+        public void await(T obj) {\n+            Predicate<T> predicate;\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                predicate  = this.predicate;\n+                barrier = this.barrier;\n+            }\n+            if (predicate != null && !predicate.test(obj)) {\n+                return;\n+            }\n+            if (barrier != null) {\n+                try {\n+                    barrier.await();\n+                } catch (InterruptedException | BrokenBarrierException e) {\n+                    throw new RuntimeException(\"Interrupted while waiting for load gate\", e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * From the test orchestrating thread, await for the test thread to continue execution\n+         * @throws InterruptedException If the current thread is interrupted while waiting\n+         * @throws BrokenBarrierException If the test thread is interrupted while waiting\n+         * @throws TimeoutException If the barrier is not reached before 1s passes.\n+         */\n+        public void testAwait()\n+            throws InterruptedException, BrokenBarrierException, TimeoutException {\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                barrier = this.barrier;\n+            }\n+            Objects.requireNonNull(barrier, \"Barrier must be set up before awaiting\");\n+            barrier.await(1L, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private class SynchronizedDelegatingClassLoader extends DelegatingClassLoader {\n+\n+        public SynchronizedDelegatingClassLoader(List<String> pluginPaths) {\n+            super(pluginPaths);\n+        }\n+\n+        @Override\n+        protected PluginClassLoader newPluginClassLoader(\n+            URL pluginLocation,\n+            URL[] urls,\n+            ClassLoader parent\n+        ) {\n+            return AccessController.doPrivileged(\n+                (PrivilegedAction<PluginClassLoader>) () ->\n+                    new SynchronizedPluginClassLoader(pluginLocation, urls, parent)\n+            );\n+        }\n+\n+        @Override\n+        public PluginClassLoader pluginClassLoader(String name) {\n+            dclBreakpoint.await(name);\n+            dclBreakpoint.await(name);\n+            return super.pluginClassLoader(name);\n+        }\n+    }\n+\n+    private class SynchronizedPluginClassLoader extends PluginClassLoader {\n+        {\n+            ClassLoader.registerAsParallelCapable();\n+        }\n+\n+\n+        public SynchronizedPluginClassLoader(URL pluginLocation, URL[] urls, ClassLoader parent) {\n+            super(pluginLocation, urls, parent);\n+        }\n+\n+        @Override\n+        protected Object getClassLoadingLock(String className) {\n+            pclBreakpoint.await(className);\n+            return super.getClassLoadingLock(className);\n+        }\n+    }\n+\n+    @Test(timeout = 15000L)\n+    // If the test times out, then there's a deadlock in the test but not necessarily the code\n+    public void workerContextClassLoaderMismatch() throws Exception {\n+        // Grab a reference to the target PluginClassLoader before activating breakpoints\n+        ClassLoader connectorLoader = plugins.delegatingLoader()\n+            .connectorLoader(TestPlugins.SAMPLING_CONVERTER);\n+\n+        // Simulate Worker::startConnector that creates configs with the delegating classloader\n+        Runnable delegatingToPlugin = () -> {\n+            // Use the DelegatingClassLoader as the current context loader\n+            ClassLoader savedLoader = Plugins.compareAndSwapLoaders(plugins.delegatingLoader());\n+\n+            // Load an isolated plugin from the delegating classloader, which will\n+            // 1. Lock the DelegatingClassLoader (via Class.forName)\n+            // 2. Wait for test to continue\n+            // 3. Attempt to lock the PluginClassLoader (via PluginClassLoader::loadClass)\n+            // 4. Deadlock\n+            new AbstractConfig(\n+                new ConfigDef().define(\"a.class\", Type.CLASS, Importance.HIGH, \"\"),\n+                Collections.singletonMap(\"a.class\", TestPlugins.SAMPLING_CONVERTER));\n+            Plugins.compareAndSwapLoaders(savedLoader);\n+        };\n+        // DelegatingClassLoader breakpoint will only trigger on this thread\n+        dclBreakpoint.set(TestPlugins.SAMPLING_CONVERTER::equals);\n+\n+        // Simulate Worker::startTask that creates configs with the plugin classloader\n+        Runnable pluginToDelegating = () -> {\n+            // Use the PluginClassLoader as the current context loader\n+            ClassLoader savedLoader = Plugins.compareAndSwapLoaders(connectorLoader);\n+            // Load a non-isolated class from the plugin classloader, which will\n+            // 1. Lock the PluginClassLoader (via PluginClassLoader::loadClass)\n+            // 2. Wait for the test to continue\n+            // 3. Attempt to lock the DelegatingClassLoader (via ClassLoader::loadClass)\n+            // 4. Deadlock\n+            new AbstractConfig(new ConfigDef().define(\"a.class\", Type.CLASS, Importance.HIGH, \"\"),\n+                Collections.singletonMap(\"a.class\", \"org.apache.kafka.connect.storage.JsonConverter\"));\n+            Plugins.compareAndSwapLoaders(savedLoader);\n+        };\n+        // PluginClassLoader breakpoint will only trigger on this thread\n+        pclBreakpoint.set(\"org.apache.kafka.connect.storage.JsonConverter\"::equals);\n+\n+        // Step 1: Lock the delegating classloader and pause\n+        exec.submit(delegatingToPlugin);\n+        // d2p enters ConfigDef::parseType\n+        // d2p enters DelegatingClassLoader::loadClass\n+        dclBreakpoint.testAwait();\n+        dclBreakpoint.testAwait();\n+        // d2p exits DelegatingClassLoader::loadClass\n+        // d2p enters Class::forName\n+        // d2p LOCKS DelegatingClassLoader\n+        // d2p enters DelegatingClassLoader::loadClass\n+        dclBreakpoint.testAwait();\n+        // d2p waits in the delegating classloader while we set up the other thread\n+        dumpThreads(\"d2p waiting with DelegatingClassLoader locked\");\n+\n+        // Step 2: Lock the plugin classloader and then the delegating classloader\n+        exec.submit(pluginToDelegating);\n+        // p2d enters PluginClassLoader::loadClass\n+        // p2d LOCKS PluginClassLoader\n+        pclBreakpoint.testAwait();\n+        // p2d locks the class-specific classLoadingLock\n+        // p2d falls through to ClassLoader::loadClass\n+        pclBreakpoint.testAwait();\n+        // p2d locks the class-specific classLoadingLock\n+        // p2d delegates upwards to DelegatingClassLoader::loadClass\n+        // p2d enters ClassLoader::loadClass\n+        // p2d LOCKS DelegatingClassLoader (starting the deadlock)\n+        dumpThreads(\"p2d blocked trying to acquire the DelegatingClassLoader lock\");\n+\n+        // Step 3: Resume the first thread and try to lock the plugin classloader\n+        dclBreakpoint.testAwait();\n+        // d2p enters PluginClassLoader::loadClass\n+        // d2p LOCKS PluginClassLoader (completing the deadlock)\n+        dumpThreads(\"d2p blocked trying to acquire the PluginClassLoader lock\");\n+        assertNoDeadlocks();\n+    }\n+\n+    // This is an informative test that is supposed to fail, demonstrating that forName is\n+    // locking the connectorLoader in this JVM implementation, when initialize is true.\n+    @Test\n+    public void forNameLocksClassloader()\n+        throws InterruptedException, TimeoutException, BrokenBarrierException {\n+        // It is not important here that we're using the PluginClassLoader.\n+        // This behavior is specific to the JVM, not the classloader implementation\n+        // It is just a convenient classloader instance that we can throw away after the test\n+        ClassLoader connectorLoader = plugins.delegatingLoader()\n+            .connectorLoader(TestPlugins.SAMPLING_CONVERTER);\n+\n+        Object monitor = new Object();\n+        Breakpoint<Object> monitorBreakpoint = new Breakpoint<>();\n+        Breakpoint<Object> progress = new Breakpoint<>();\n+\n+        Runnable executeForName = () -> {\n+            synchronized (monitor) {\n+                try {\n+                    progress.await(null);\n+                    Class.forName(TestPlugins.SAMPLING_CONVERTER, true, connectorLoader);\n+                } catch (ClassNotFoundException e) {\n+                    throw new RuntimeException(\"Failed to load test plugin\", e);\n+                }\n+            }\n+        };\n+        progress.set(null);\n+\n+        Runnable holdsMonitorLock = () -> {\n+            synchronized (connectorLoader) {\n+                monitorBreakpoint.await(null);\n+                monitorBreakpoint.await(null);\n+                synchronized (monitor) {\n+                }\n+            }\n+        };\n+        monitorBreakpoint.set(null);\n+\n+        exec.submit(holdsMonitorLock);\n+        // LOCK the classloader\n+        // wait for test to progress\n+        dumpThreads(\"locked the classloader\");\n+        monitorBreakpoint.testAwait();\n+\n+        exec.submit(executeForName);\n+        progress.testAwait();\n+        // LOCK the monitor\n+        // LOCK the classloader (starting the deadlock)\n+        dumpThreads(\"half-deadlocked\");\n+        monitorBreakpoint.testAwait();\n+        // LOCK the monitor (completing the deadlock)\n+\n+        assertNoDeadlocks();\n+    }\n+\n+    private boolean threadFromCurrentTest(ThreadInfo threadInfo) {\n+        return threadInfo.getThreadName().startsWith(threadPrefix);\n+    }\n+\n+    private void assertNoDeadlocks() {\n+        long[] deadlockedThreads = ManagementFactory.getThreadMXBean().findDeadlockedThreads();\n+        if (deadlockedThreads != null && deadlockedThreads.length > 0) {\n+            final String threads = Arrays\n+                .stream(ManagementFactory.getThreadMXBean().getThreadInfo(deadlockedThreads))\n+                .filter(this::threadFromCurrentTest)\n+                .map(SynchronizationTest::threadInfoToString)\n+                .collect(Collectors.joining(\"\"));\n+            if (!threads.isEmpty()) {\n+                fail(\"Found deadlocked threads while classloading\\n\" + threads);\n+            }\n+        }\n+    }\n+\n+    private void dumpThreads(String msg) throws InterruptedException {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"{}:\\n{}\",\n+                msg,\n+                Arrays.stream(ManagementFactory.getThreadMXBean().dumpAllThreads(true, true))\n+                    .filter(this::threadFromCurrentTest)\n+                    .map(SynchronizationTest::threadInfoToString)\n+                    .collect(Collectors.joining(\"\\n\"))\n+            );\n+        }\n+    }\n+\n+    private static String threadInfoToString(ThreadInfo info) {\n+        StringBuilder sb = new StringBuilder(\"\\\"\" + info.getThreadName() + \"\\\"\" +\n+            \" Id=\" + info.getThreadId() + \" \" +\n+            info.getThreadState());\n+        if (info.getLockName() != null) {\n+            sb.append(\" on \" + info.getLockName());\n+        }\n+        if (info.getLockOwnerName() != null) {\n+            sb.append(\" owned by \\\"\" + info.getLockOwnerName() +\n+                \"\\\" Id=\" + info.getLockOwnerId());\n+        }\n+        if (info.isSuspended()) {\n+            sb.append(\" (suspended)\");\n+        }\n+        if (info.isInNative()) {\n+            sb.append(\" (in native)\");\n+        }\n+        sb.append('\\n');\n+        // this has been refactored for checkstyle\n+        printStacktrace(info, sb);\n+        LockInfo[] locks = info.getLockedSynchronizers();\n+        if (locks.length > 0) {\n+            sb.append(\"\\n\\tNumber of locked synchronizers = \" + locks.length);\n+            sb.append('\\n');\n+            for (LockInfo li : locks) {\n+                sb.append(\"\\t- \" + li);\n+                sb.append('\\n');\n+            }\n+        }\n+        sb.append('\\n');\n+        return sb.toString();\n+    }\n+\n+    private static void printStacktrace(ThreadInfo info, StringBuilder sb) {\n+        StackTraceElement[] stackTrace = info.getStackTrace();\n+        int i = 0;\n+        // This is a copy of ThreadInfo::toString but with an unlimited number of frames shown.\n+        //for (; i < stackTrace.length && i < MAX_FRAMES; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "858a37a8bf88db23e5bdd93683c799b840fbf693"}, "originalPosition": 410}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA2NDY0MDgw", "url": "https://github.com/apache/kafka/pull/8259#pullrequestreview-606464080", "createdAt": "2021-03-08T16:20:04Z", "commit": {"oid": "858a37a8bf88db23e5bdd93683c799b840fbf693"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wOFQxNjoyMDowNVrOIyPfzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0wOFQxNjoyMDowNVrOIyPfzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4OTU1MzYxNQ==", "bodyText": "+1 for correcting the existing comments and adding more descriptive comments where there are none.\nAlso, in some other places (including ConnectWorkerIntegrationTest) we've used a \"When ...\" comment (sometimes followed by one or more \"And when ...\" comments) to describe the preconditions, followed by a \"Then ...\" comment (and maybe more \"And then ...\" comments) stating the expected behaviors. These can help make it easier to explain the purpose of the tests beyond a simple description.", "url": "https://github.com/apache/kafka/pull/8259#discussion_r589553615", "createdAt": "2021-03-08T16:20:05Z", "author": {"login": "rhauch"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/SynchronizationTest.java", "diffHunk": "@@ -0,0 +1,468 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.connect.runtime.isolation;\n+\n+import static org.junit.Assert.fail;\n+\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MonitorInfo;\n+import java.lang.management.ThreadInfo;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.common.config.AbstractConfig;\n+import org.apache.kafka.common.config.ConfigDef;\n+import org.apache.kafka.common.config.ConfigDef.Importance;\n+import org.apache.kafka.common.config.ConfigDef.Type;\n+import org.apache.kafka.connect.runtime.WorkerConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SynchronizationTest {\n+\n+    public static final Logger log = LoggerFactory.getLogger(SynchronizationTest.class);\n+\n+    @Rule\n+    public final TestName testName = new TestName();\n+\n+    private String threadPrefix;\n+    private Plugins plugins;\n+    private ThreadPoolExecutor exec;\n+    private Breakpoint<String> dclBreakpoint;\n+    private Breakpoint<String> pclBreakpoint;\n+\n+    @Before\n+    public void setup() {\n+        TestPlugins.assertAvailable();\n+        Map<String, String> pluginProps = Collections.singletonMap(\n+            WorkerConfig.PLUGIN_PATH_CONFIG,\n+            String.join(\",\", TestPlugins.pluginPath())\n+        );\n+        threadPrefix = SynchronizationTest.class.getSimpleName()\n+            + \".\" + testName.getMethodName() + \"-\";\n+        dclBreakpoint = new Breakpoint<>();\n+        pclBreakpoint = new Breakpoint<>();\n+        plugins = new Plugins(pluginProps) {\n+            @Override\n+            protected DelegatingClassLoader newDelegatingClassLoader(List<String> paths) {\n+                return AccessController.doPrivileged(\n+                    (PrivilegedAction<DelegatingClassLoader>) () ->\n+                        new SynchronizedDelegatingClassLoader(paths)\n+                );\n+            }\n+        };\n+        exec = new ThreadPoolExecutor(\n+            2,\n+            2,\n+            1000L,\n+            TimeUnit.MILLISECONDS,\n+            new LinkedBlockingDeque<>(),\n+            threadFactoryWithNamedThreads(threadPrefix)\n+        );\n+\n+    }\n+\n+    @After\n+    public void tearDown() throws InterruptedException {\n+        dclBreakpoint.clear();\n+        pclBreakpoint.clear();\n+        exec.shutdown();\n+        exec.awaitTermination(1L, TimeUnit.SECONDS);\n+    }\n+\n+    private static class Breakpoint<T> {\n+\n+        private Predicate<T> predicate;\n+        private CyclicBarrier barrier;\n+\n+        public synchronized void clear() {\n+            if (barrier != null) {\n+                barrier.reset();\n+            }\n+            predicate = null;\n+            barrier = null;\n+        }\n+\n+        public synchronized void set(Predicate<T> predicate) {\n+            clear();\n+            this.predicate = predicate;\n+            // As soon as the barrier is tripped, the barrier will be reset for the next round.\n+            barrier = new CyclicBarrier(2);\n+        }\n+\n+        /**\n+         * From a thread under test, await for the test orchestrator to continue execution\n+         * @param obj Object to test with the breakpoint's current predicate\n+         */\n+        public void await(T obj) {\n+            Predicate<T> predicate;\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                predicate  = this.predicate;\n+                barrier = this.barrier;\n+            }\n+            if (predicate != null && !predicate.test(obj)) {\n+                return;\n+            }\n+            if (barrier != null) {\n+                try {\n+                    barrier.await();\n+                } catch (InterruptedException | BrokenBarrierException e) {\n+                    throw new RuntimeException(\"Interrupted while waiting for load gate\", e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * From the test orchestrating thread, await for the test thread to continue execution\n+         * @throws InterruptedException If the current thread is interrupted while waiting\n+         * @throws BrokenBarrierException If the test thread is interrupted while waiting\n+         * @throws TimeoutException If the barrier is not reached before 1s passes.\n+         */\n+        public void testAwait()\n+            throws InterruptedException, BrokenBarrierException, TimeoutException {\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                barrier = this.barrier;\n+            }\n+            Objects.requireNonNull(barrier, \"Barrier must be set up before awaiting\");\n+            barrier.await(1L, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private class SynchronizedDelegatingClassLoader extends DelegatingClassLoader {\n+\n+        public SynchronizedDelegatingClassLoader(List<String> pluginPaths) {\n+            super(pluginPaths);\n+        }\n+\n+        @Override\n+        protected PluginClassLoader newPluginClassLoader(\n+            URL pluginLocation,\n+            URL[] urls,\n+            ClassLoader parent\n+        ) {\n+            return AccessController.doPrivileged(\n+                (PrivilegedAction<PluginClassLoader>) () ->\n+                    new SynchronizedPluginClassLoader(pluginLocation, urls, parent)\n+            );\n+        }\n+\n+        @Override\n+        public PluginClassLoader pluginClassLoader(String name) {\n+            dclBreakpoint.await(name);\n+            dclBreakpoint.await(name);\n+            return super.pluginClassLoader(name);\n+        }\n+    }\n+\n+    private class SynchronizedPluginClassLoader extends PluginClassLoader {\n+        {\n+            ClassLoader.registerAsParallelCapable();\n+        }\n+\n+\n+        public SynchronizedPluginClassLoader(URL pluginLocation, URL[] urls, ClassLoader parent) {\n+            super(pluginLocation, urls, parent);\n+        }\n+\n+        @Override\n+        protected Object getClassLoadingLock(String className) {\n+            pclBreakpoint.await(className);\n+            return super.getClassLoadingLock(className);\n+        }\n+    }\n+\n+    @Test(timeout = 15000L)\n+    // If the test times out, then there's a deadlock in the test but not necessarily the code\n+    public void workerContextClassLoaderMismatch() throws Exception {\n+        // Grab a reference to the target PluginClassLoader before activating breakpoints\n+        ClassLoader connectorLoader = plugins.delegatingLoader()\n+            .connectorLoader(TestPlugins.SAMPLING_CONVERTER);\n+\n+        // Simulate Worker::startConnector that creates configs with the delegating classloader\n+        Runnable delegatingToPlugin = () -> {\n+            // Use the DelegatingClassLoader as the current context loader\n+            ClassLoader savedLoader = Plugins.compareAndSwapLoaders(plugins.delegatingLoader());\n+\n+            // Load an isolated plugin from the delegating classloader, which will\n+            // 1. Lock the DelegatingClassLoader (via Class.forName)\n+            // 2. Wait for test to continue\n+            // 3. Attempt to lock the PluginClassLoader (via PluginClassLoader::loadClass)\n+            // 4. Deadlock\n+            new AbstractConfig(\n+                new ConfigDef().define(\"a.class\", Type.CLASS, Importance.HIGH, \"\"),\n+                Collections.singletonMap(\"a.class\", TestPlugins.SAMPLING_CONVERTER));\n+            Plugins.compareAndSwapLoaders(savedLoader);\n+        };\n+        // DelegatingClassLoader breakpoint will only trigger on this thread\n+        dclBreakpoint.set(TestPlugins.SAMPLING_CONVERTER::equals);\n+\n+        // Simulate Worker::startTask that creates configs with the plugin classloader\n+        Runnable pluginToDelegating = () -> {\n+            // Use the PluginClassLoader as the current context loader\n+            ClassLoader savedLoader = Plugins.compareAndSwapLoaders(connectorLoader);\n+            // Load a non-isolated class from the plugin classloader, which will\n+            // 1. Lock the PluginClassLoader (via PluginClassLoader::loadClass)\n+            // 2. Wait for the test to continue\n+            // 3. Attempt to lock the DelegatingClassLoader (via ClassLoader::loadClass)\n+            // 4. Deadlock\n+            new AbstractConfig(new ConfigDef().define(\"a.class\", Type.CLASS, Importance.HIGH, \"\"),\n+                Collections.singletonMap(\"a.class\", \"org.apache.kafka.connect.storage.JsonConverter\"));\n+            Plugins.compareAndSwapLoaders(savedLoader);\n+        };\n+        // PluginClassLoader breakpoint will only trigger on this thread\n+        pclBreakpoint.set(\"org.apache.kafka.connect.storage.JsonConverter\"::equals);\n+\n+        // Step 1: Lock the delegating classloader and pause\n+        exec.submit(delegatingToPlugin);\n+        // d2p enters ConfigDef::parseType\n+        // d2p enters DelegatingClassLoader::loadClass\n+        dclBreakpoint.testAwait();\n+        dclBreakpoint.testAwait();\n+        // d2p exits DelegatingClassLoader::loadClass\n+        // d2p enters Class::forName\n+        // d2p LOCKS DelegatingClassLoader\n+        // d2p enters DelegatingClassLoader::loadClass\n+        dclBreakpoint.testAwait();\n+        // d2p waits in the delegating classloader while we set up the other thread\n+        dumpThreads(\"d2p waiting with DelegatingClassLoader locked\");\n+\n+        // Step 2: Lock the plugin classloader and then the delegating classloader\n+        exec.submit(pluginToDelegating);\n+        // p2d enters PluginClassLoader::loadClass\n+        // p2d LOCKS PluginClassLoader\n+        pclBreakpoint.testAwait();\n+        // p2d locks the class-specific classLoadingLock\n+        // p2d falls through to ClassLoader::loadClass\n+        pclBreakpoint.testAwait();\n+        // p2d locks the class-specific classLoadingLock\n+        // p2d delegates upwards to DelegatingClassLoader::loadClass\n+        // p2d enters ClassLoader::loadClass\n+        // p2d LOCKS DelegatingClassLoader (starting the deadlock)\n+        dumpThreads(\"p2d blocked trying to acquire the DelegatingClassLoader lock\");\n+\n+        // Step 3: Resume the first thread and try to lock the plugin classloader\n+        dclBreakpoint.testAwait();\n+        // d2p enters PluginClassLoader::loadClass\n+        // d2p LOCKS PluginClassLoader (completing the deadlock)\n+        dumpThreads(\"d2p blocked trying to acquire the PluginClassLoader lock\");\n+        assertNoDeadlocks();\n+    }\n+\n+    // This is an informative test that is supposed to fail, demonstrating that forName is\n+    // locking the connectorLoader in this JVM implementation, when initialize is true.\n+    @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MjYxNDQ0Mw=="}, "originalCommit": {"oid": "858a37a8bf88db23e5bdd93683c799b840fbf693"}, "originalPosition": 291}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d20e98f2dc81347e05b6de4cc530437220bf2e85", "author": {"user": {"login": "gharris1727", "name": "Greg Harris"}}, "url": "https://github.com/apache/kafka/commit/d20e98f2dc81347e05b6de4cc530437220bf2e85", "committedDate": "2021-05-12T01:34:36Z", "message": "Update comments and test code for better readability, now that bug is fixed.\n\nSigned-off-by: Greg Harris <gregh@confluent.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2fdb7a14b7fe9e8bd9149bcf95d119e29fc10d19", "author": {"user": {"login": "gharris1727", "name": "Greg Harris"}}, "url": "https://github.com/apache/kafka/commit/2fdb7a14b7fe9e8bd9149bcf95d119e29fc10d19", "committedDate": "2021-05-17T17:40:38Z", "message": "Revert accidentally added generated files\n\nSigned-off-by: Greg Harris <gregh@confluent.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjYxMjMxNzE2", "url": "https://github.com/apache/kafka/pull/8259#pullrequestreview-661231716", "createdAt": "2021-05-17T17:35:13Z", "commit": {"oid": "d20e98f2dc81347e05b6de4cc530437220bf2e85"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xN1QxNzozNToxM1rOJcXlRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNS0xN1QxODo0NDo0OFrOJcaxXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMzcyNjI3Ng==", "bodyText": "I understand why the implementations need to be ConcurrentMap, but IIUC we're not using any of the methods specific to ConcurrentMap. Is there a reason we don't want to keep Map for the type of these fields?", "url": "https://github.com/apache/kafka/pull/8259#discussion_r633726276", "createdAt": "2021-05-17T17:35:13Z", "author": {"login": "rhauch"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/DelegatingClassLoader.java", "diffHunk": "@@ -48,25 +48,25 @@\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Enumeration;\n-import java.util.HashMap;\n import java.util.Iterator;\n import java.util.List;\n-import java.util.Map;\n import java.util.ServiceLoader;\n import java.util.Set;\n import java.util.SortedMap;\n import java.util.SortedSet;\n import java.util.TreeMap;\n import java.util.TreeSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n import java.util.stream.Collectors;\n \n public class DelegatingClassLoader extends URLClassLoader {\n     private static final Logger log = LoggerFactory.getLogger(DelegatingClassLoader.class);\n     private static final String CLASSPATH_NAME = \"classpath\";\n     private static final String UNDEFINED_VERSION = \"undefined\";\n \n-    private final Map<String, SortedMap<PluginDesc<?>, ClassLoader>> pluginLoaders;\n-    private final Map<String, String> aliases;\n+    private final ConcurrentMap<String, SortedMap<PluginDesc<?>, ClassLoader>> pluginLoaders;\n+    private final ConcurrentMap<String, String> aliases;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d20e98f2dc81347e05b6de4cc530437220bf2e85"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMzc3ODUyNA==", "bodyText": "IIUC, this PR changes the PluginClassLoader to be parallel-capable, but changes DelegatingClassLoader to only be thread safe and non parallel-capable. Is that right?\nCan we modify the JavaDoc in DelegatingClassLoader and PluginClassLoader to identify whether or not we intend for them to be parallel-capable, linking to the relevant portion of the language guide?", "url": "https://github.com/apache/kafka/pull/8259#discussion_r633778524", "createdAt": "2021-05-17T18:44:48Z", "author": {"login": "rhauch"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/isolation/SynchronizationTest.java", "diffHunk": "@@ -0,0 +1,469 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.connect.runtime.isolation;\n+\n+import static org.junit.Assert.fail;\n+\n+import java.lang.management.LockInfo;\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MonitorInfo;\n+import java.lang.management.ThreadInfo;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.common.config.AbstractConfig;\n+import org.apache.kafka.common.config.ConfigDef;\n+import org.apache.kafka.common.config.ConfigDef.Importance;\n+import org.apache.kafka.common.config.ConfigDef.Type;\n+import org.apache.kafka.connect.json.JsonConverter;\n+import org.apache.kafka.connect.runtime.WorkerConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TestName;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SynchronizationTest {\n+\n+    public static final Logger log = LoggerFactory.getLogger(SynchronizationTest.class);\n+\n+    @Rule\n+    public final TestName testName = new TestName();\n+\n+    private String threadPrefix;\n+    private Plugins plugins;\n+    private ThreadPoolExecutor exec;\n+    private Breakpoint<String> dclBreakpoint;\n+    private Breakpoint<String> pclBreakpoint;\n+\n+    @Before\n+    public void setup() {\n+        TestPlugins.assertAvailable();\n+        Map<String, String> pluginProps = Collections.singletonMap(\n+            WorkerConfig.PLUGIN_PATH_CONFIG,\n+            String.join(\",\", TestPlugins.pluginPath())\n+        );\n+        threadPrefix = SynchronizationTest.class.getSimpleName()\n+            + \".\" + testName.getMethodName() + \"-\";\n+        dclBreakpoint = new Breakpoint<>();\n+        pclBreakpoint = new Breakpoint<>();\n+        plugins = new Plugins(pluginProps) {\n+            @Override\n+            protected DelegatingClassLoader newDelegatingClassLoader(List<String> paths) {\n+                return AccessController.doPrivileged(\n+                    (PrivilegedAction<DelegatingClassLoader>) () ->\n+                        new SynchronizedDelegatingClassLoader(paths)\n+                );\n+            }\n+        };\n+        exec = new ThreadPoolExecutor(\n+            2,\n+            2,\n+            1000L,\n+            TimeUnit.MILLISECONDS,\n+            new LinkedBlockingDeque<>(),\n+            threadFactoryWithNamedThreads(threadPrefix)\n+        );\n+\n+    }\n+\n+    @After\n+    public void tearDown() throws InterruptedException {\n+        dclBreakpoint.clear();\n+        pclBreakpoint.clear();\n+        exec.shutdown();\n+        exec.awaitTermination(1L, TimeUnit.SECONDS);\n+    }\n+\n+    private static class Breakpoint<T> {\n+\n+        private Predicate<T> predicate;\n+        private CyclicBarrier barrier;\n+\n+        public synchronized void clear() {\n+            if (barrier != null) {\n+                barrier.reset();\n+            }\n+            predicate = null;\n+            barrier = null;\n+        }\n+\n+        public synchronized void set(Predicate<T> predicate) {\n+            clear();\n+            this.predicate = predicate;\n+            // As soon as the barrier is tripped, the barrier will be reset for the next round.\n+            barrier = new CyclicBarrier(2);\n+        }\n+\n+        /**\n+         * From a thread under test, await for the test orchestrator to continue execution\n+         * @param obj Object to test with the breakpoint's current predicate\n+         */\n+        public void await(T obj) {\n+            Predicate<T> predicate;\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                predicate  = this.predicate;\n+                barrier = this.barrier;\n+            }\n+            if (predicate != null && !predicate.test(obj)) {\n+                return;\n+            }\n+            if (barrier != null) {\n+                try {\n+                    barrier.await();\n+                } catch (InterruptedException | BrokenBarrierException e) {\n+                    throw new RuntimeException(\"Interrupted while waiting for load gate\", e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * From the test orchestrating thread, await for the test thread to continue execution\n+         * @throws InterruptedException If the current thread is interrupted while waiting\n+         * @throws BrokenBarrierException If the test thread is interrupted while waiting\n+         * @throws TimeoutException If the barrier is not reached before 1s passes.\n+         */\n+        public void testAwait()\n+            throws InterruptedException, BrokenBarrierException, TimeoutException {\n+            CyclicBarrier barrier;\n+            synchronized (this) {\n+                barrier = this.barrier;\n+            }\n+            Objects.requireNonNull(barrier, \"Barrier must be set up before awaiting\");\n+            barrier.await(1L, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private class SynchronizedDelegatingClassLoader extends DelegatingClassLoader {\n+        // NOTE: the DelegatingClassLoader is not parallel capable, and neither is this subclass.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d20e98f2dc81347e05b6de4cc530437220bf2e85"}, "originalPosition": 171}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d9030004a0ef61ef5d5a26e188cd26184ef5ab9", "author": {"user": {"login": "gharris1727", "name": "Greg Harris"}}, "url": "https://github.com/apache/kafka/commit/7d9030004a0ef61ef5d5a26e188cd26184ef5ab9", "committedDate": "2021-06-08T22:15:29Z", "message": "Change field types to Map, clarify javadocs on threadsafety+parallel capability\n\nSigned-off-by: Greg Harris <gregh@confluent.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52614025a0ba5384da806b8b5bb8e94e0645cb86", "author": {"user": {"login": "kkonstantine", "name": "Konstantine Karantasis"}}, "url": "https://github.com/apache/kafka/commit/52614025a0ba5384da806b8b5bb8e94e0645cb86", "committedDate": "2021-07-14T02:09:13Z", "message": "Declare DelegatingClassLoader parallel capable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09573d66695a4c663a04dec102ebb14bc372657e", "author": {"user": {"login": "kkonstantine", "name": "Konstantine Karantasis"}}, "url": "https://github.com/apache/kafka/commit/09573d66695a4c663a04dec102ebb14bc372657e", "committedDate": "2021-07-14T05:40:13Z", "message": "Maps are not ConcurrentMaps"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2MTE4MjA2", "url": "https://github.com/apache/kafka/pull/8259#pullrequestreview-706118206", "createdAt": "2021-07-14T10:41:17Z", "commit": {"oid": "09573d66695a4c663a04dec102ebb14bc372657e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxMDo0MToxN1rOJ-e0aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNy0xNFQxMDo0MToxN1rOJ-e0aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2OTQ5NjQyNw==", "bodyText": "I think it would be clearer to put this with the static fields rather than here after the member fields.\nAlso, is it worth mentioning that this CL is parallel-capable because it's superclass is, and we haven't overridden loadClass/defineClass, and so no additional sychronization is necessary?", "url": "https://github.com/apache/kafka/pull/8259#discussion_r669496427", "createdAt": "2021-07-14T10:41:17Z", "author": {"login": "tombentley"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/isolation/DelegatingClassLoader.java", "diffHunk": "@@ -82,11 +93,19 @@\n         Arrays.stream(SERVICE_LOADER_PLUGINS).map(serviceLoaderPlugin -> MANIFEST_PREFIX + serviceLoaderPlugin.getName())\n             .collect(Collectors.toSet());\n \n+    // Although this classloader does not load classes directly but rather delegates loading to a\n+    // PluginClassLoader or its parent through its base class, because of the use of inheritance in\n+    // in the latter case, this classloader needs to also be declared as parallel capable to use\n+    // fine-grain locking when loading classes.\n+    static {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09573d66695a4c663a04dec102ebb14bc372657e"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA2NTMyODAy", "url": "https://github.com/apache/kafka/pull/8259#pullrequestreview-706532802", "createdAt": "2021-07-14T17:21:36Z", "commit": {"oid": "09573d66695a4c663a04dec102ebb14bc372657e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 189, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}