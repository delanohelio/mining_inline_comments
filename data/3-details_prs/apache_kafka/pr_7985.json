{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0NTI1OTIz", "number": 7985, "title": "KAFKA-7658: Add KStream#toTable to the Streams DSL", "bodyText": "Add KStream#toTable to the Streams DSL\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-01-19T11:44:14Z", "url": "https://github.com/apache/kafka/pull/7985", "merged": true, "mergeCommit": {"oid": "6b86af3a2703dfbb9685b4440ba7538091ca3e73"}, "closed": true, "closedAt": "2020-01-30T07:57:11Z", "author": {"login": "highluck"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb7_zA2AFqTM0NTAyOTc3MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABb_V0DMgFqTM1MDYzMzUxOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MDI5Nzcw", "url": "https://github.com/apache/kafka/pull/7985#pullrequestreview-345029770", "createdAt": "2020-01-19T22:07:17Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQyMjowNzoxN1rOFfQ4TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQyMjoyODo0NlrOFfQ9vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMyNjczMw==", "bodyText": "no longer treated as an updated record -> c&p error; it was a \"fact/event\" and is re-interpreted as update now.", "url": "https://github.com/apache/kafka/pull/7985#discussion_r368326733", "createdAt": "2020-01-19T22:07:17Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -3447,4 +3449,51 @@ void process(final ProcessorSupplier<? super K, ? super V> processorSupplier,\n     void process(final ProcessorSupplier<? super K, ? super V> processorSupplier,\n                  final Named named,\n                  final String... stateStoreNames);\n+\n+    /**\n+     * Convert this stream to a {@link KTable}.\n+     * <p>\n+     * Note that this is a logical operation and only changes the \"interpretation\" of the stream, i.e., each record of\n+     * this stream is no longer treated as an updated record (cf. {@link KStream} vs {@code KTable}).", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMyNjk2NA==", "bodyText": "Nit: in KTableImpl the corresponding name is KTABLE-TOSTREAM- hence, we should use KSTREAM-TOTABLE- here", "url": "https://github.com/apache/kafka/pull/7985#discussion_r368326964", "createdAt": "2020-01-19T22:10:28Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -110,6 +116,8 @@\n \n     private static final String FOREACH_NAME = \"KSTREAM-FOREACH-\";\n \n+    private static final String TO_KTABLE_NAME = \"KSTREAM-TO-KTABLE-\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMyNzMxMQ==", "bodyText": "This null check is redundant as we check for null in toTable(Named, Materialized) anyway -- can be removed", "url": "https://github.com/apache/kafka/pull/7985#discussion_r368327311", "createdAt": "2020-01-19T22:16:05Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -1271,4 +1279,71 @@ public void process(final ProcessorSupplier<? super K, ? super V> processorSuppl\n \n         builder.addGraphNode(streamsGraphNode, processNode);\n     }\n+\n+    @Override\n+    public KTable<K, V> toTable() {\n+        return toTable(NamedInternal.empty());\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(Named named) {\n+        Objects.requireNonNull(named, \"named can't be null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMyNzM4MA==", "bodyText": "Add missing null check for materialized", "url": "https://github.com/apache/kafka/pull/7985#discussion_r368327380", "createdAt": "2020-01-19T22:17:11Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -1271,4 +1279,71 @@ public void process(final ProcessorSupplier<? super K, ? super V> processorSuppl\n \n         builder.addGraphNode(streamsGraphNode, processNode);\n     }\n+\n+    @Override\n+    public KTable<K, V> toTable() {\n+        return toTable(NamedInternal.empty());\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(Named named) {\n+        Objects.requireNonNull(named, \"named can't be null\");\n+        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(\n+                Materialized.with(keySerde, valSerde),\n+                builder,\n+                TO_KTABLE_NAME);\n+\n+        return toTable(named, materializedInternal);\n+    }\n+\n+    @Override\n+    public <VR> KTable<K, VR> toTable(Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n+        return toTable(NamedInternal.empty(), materialized);\n+    }\n+\n+    @Override\n+    public <VR> KTable<K, VR> toTable(Named named, Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n+        Objects.requireNonNull(named, \"named can't be null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMyNzcxMA==", "bodyText": "This seems to always enforce a materialization, but I think we should materialize only if we need to.", "url": "https://github.com/apache/kafka/pull/7985#discussion_r368327710", "createdAt": "2020-01-19T22:22:16Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -1271,4 +1279,71 @@ public void process(final ProcessorSupplier<? super K, ? super V> processorSuppl\n \n         builder.addGraphNode(streamsGraphNode, processNode);\n     }\n+\n+    @Override\n+    public KTable<K, V> toTable() {\n+        return toTable(NamedInternal.empty());\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(Named named) {\n+        Objects.requireNonNull(named, \"named can't be null\");\n+        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(\n+                Materialized.with(keySerde, valSerde),\n+                builder,\n+                TO_KTABLE_NAME);\n+\n+        return toTable(named, materializedInternal);\n+    }\n+\n+    @Override\n+    public <VR> KTable<K, VR> toTable(Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n+        return toTable(NamedInternal.empty(), materialized);\n+    }\n+\n+    @Override\n+    public <VR> KTable<K, VR> toTable(Named named, Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n+        Objects.requireNonNull(named, \"named can't be null\");\n+\n+        final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(materialized);\n+        return toTable(named, materializedInternal);\n+    }\n+\n+    private <VR> KTable<K, VR> toTable(Named named,\n+                                       MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n+        final String name = new NamedInternal(named).orElseGenerateWithPrefix(builder, TO_KTABLE_NAME);\n+\n+        final String storeName = materializedInternal.storeName() == null\n+            ? builder.newStoreName(TO_KTABLE_NAME)\n+            : materializedInternal.storeName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMyNzg1MQ==", "bodyText": "We should not use MockProcessorSupplier but write the result into an output topic and use a TestOutputTopic for verification of the result (the MockProcessorSupplier should be removed completely mid-term...)", "url": "https://github.com/apache/kafka/pull/7985#discussion_r368327851", "createdAt": "2020-01-19T22:24:29Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2333,101 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+        final Consumed<String, String> consumed2 = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"stream-table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String topic1 = \"topic1\";\n+\n+        final KTable<String, String> table1 = builder.table(topic1, consumed);\n+\n+        final MockProcessorSupplier<String, Object> supplier = new MockProcessorSupplier<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMyODAzNQ==", "bodyText": "This test seems to be unnecessarily complex. If we want to test the new toTable() operator, we should just do it directly and not by using an additions builder.table().toStream() construct...", "url": "https://github.com/apache/kafka/pull/7985#discussion_r368328035", "createdAt": "2020-01-19T22:27:27Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2333,101 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldKTableFromKStream() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMyODEyNg==", "bodyText": "It does not seem that this test verifies that the table is materialized or not?", "url": "https://github.com/apache/kafka/pull/7985#discussion_r368328126", "createdAt": "2020-01-19T22:28:46Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2333,101 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+        final Consumed<String, String> consumed2 = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"stream-table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String topic1 = \"topic1\";\n+\n+        final KTable<String, String> table1 = builder.table(topic1, consumed);\n+\n+        final MockProcessorSupplier<String, Object> supplier = new MockProcessorSupplier<>();\n+        table1.toStream().process(supplier);\n+\n+\n+        final String streamToTableTopic1 = \"streamToTableTopic1\";\n+\n+        final StreamsBuilder builder2 = new StreamsBuilder();\n+        final KStream<String, String> kStream = builder2.stream(streamToTableTopic1, consumed2);\n+        kStream.toTable().toStream().process(supplier);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(topic1, new StringSerializer(), new StringSerializer());\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+        }\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder2.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(streamToTableTopic1, new StringSerializer(), new StringSerializer());\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+        }\n+\n+        final List<MockProcessor<String, Object>> processors = supplier.capturedProcessors(2);\n+        assertEquals(processors.get(0).processed, processors.get(1).processed);\n+    }\n+\n+    @Test\n+    public void shouldKTableFromKStreamAndMaterialize() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 79}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2Mzg2NzMx", "url": "https://github.com/apache/kafka/pull/7985#pullrequestreview-346386731", "createdAt": "2020-01-22T07:29:45Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwNzoyOTo0NlrOFgSnBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwNzo1Mjo0OVrOFgTA8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMzY1NA==", "bodyText": "Just a personal request: we try to keep the method somewhat \"ordered\" base on their semantics (stateless: no-side effect, with side effect, othes; stateful: grouping/aggregating/join; last PAPI integration). Hence, I think it would be best to not add the methods at the end, but after the to() overloads and before groupBy(...) -- please use the same order in KStreamImpl to keep both classes aligned -- it make is easier to navigate through the code.", "url": "https://github.com/apache/kafka/pull/7985#discussion_r369403654", "createdAt": "2020-01-22T07:29:46Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -3447,4 +3449,51 @@ void process(final ProcessorSupplier<? super K, ? super V> processorSupplier,\n     void process(final ProcessorSupplier<? super K, ? super V> processorSupplier,\n                  final Named named,\n                  final String... stateStoreNames);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwNTgyMg==", "bodyText": "Why can't we use this.valueSerde if .valueSerde() == null similar to `keySerde?", "url": "https://github.com/apache/kafka/pull/7985#discussion_r369405822", "createdAt": "2020-01-22T07:37:50Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -1271,4 +1279,81 @@ public void process(final ProcessorSupplier<? super K, ? super V> processorSuppl\n \n         builder.addGraphNode(streamsGraphNode, processNode);\n     }\n+\n+    @Override\n+    public KTable<K, V> toTable() {\n+        return toTable(NamedInternal.empty());\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(Named named) {\n+        return doToTable(named, null);\n+    }\n+\n+    @Override\n+    public <VR> KTable<K, VR> toTable(Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n+        return toTable(NamedInternal.empty(), materialized);\n+    }\n+\n+    @Override\n+    public <VR> KTable<K, VR> toTable(Named named,\n+                                      Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n+        Objects.requireNonNull(materialized, \"materialized can't be null\");\n+\n+        final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(materialized);\n+        return doToTable(named, materializedInternal);\n+    }\n+\n+    private <VR> KTable<K, VR> doToTable(Named named,\n+                                         MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n+        Objects.requireNonNull(named, \"named can't be null\");\n+        final String name = new NamedInternal(named).orElseGenerateWithPrefix(builder, TO_KTABLE_NAME);\n+        final Serde<K> keySerde;\n+        final Serde<VR> valueSerde;\n+        final String queryableStoreName;\n+        final String storeName;\n+        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n+\n+        if (materializedInternal != null) {\n+            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n+            valueSerde = materializedInternal.valueSerde();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwODAxNw==", "bodyText": "Using TableProcessorNode implies that we make all decision about materialization in doToTable? -- However, I am wondering if this is correct. When we call StreamsBuilder.table(), we create a TableSourceNode (within InternalStreamsBuilder#table() that allows us to defer decision when we build the actual Topology. This has the advantage that we can take into account how the KTable is used downstream. For example, if we use it downstream in a stream-table join, we need to materialize the table -- but if we decide to non materialized here, we can't change this decision later on using TableProcessorNode? (Correct me if I am wrong.)", "url": "https://github.com/apache/kafka/pull/7985#discussion_r369408017", "createdAt": "2020-01-22T07:45:17Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -1271,4 +1279,81 @@ public void process(final ProcessorSupplier<? super K, ? super V> processorSuppl\n \n         builder.addGraphNode(streamsGraphNode, processNode);\n     }\n+\n+    @Override\n+    public KTable<K, V> toTable() {\n+        return toTable(NamedInternal.empty());\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(Named named) {\n+        return doToTable(named, null);\n+    }\n+\n+    @Override\n+    public <VR> KTable<K, VR> toTable(Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n+        return toTable(NamedInternal.empty(), materialized);\n+    }\n+\n+    @Override\n+    public <VR> KTable<K, VR> toTable(Named named,\n+                                      Materialized<K, VR, KeyValueStore<Bytes, byte[]>> materialized) {\n+        Objects.requireNonNull(materialized, \"materialized can't be null\");\n+\n+        final MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(materialized);\n+        return doToTable(named, materializedInternal);\n+    }\n+\n+    private <VR> KTable<K, VR> doToTable(Named named,\n+                                         MaterializedInternal<K, VR, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n+        Objects.requireNonNull(named, \"named can't be null\");\n+        final String name = new NamedInternal(named).orElseGenerateWithPrefix(builder, TO_KTABLE_NAME);\n+        final Serde<K> keySerde;\n+        final Serde<VR> valueSerde;\n+        final String queryableStoreName;\n+        final String storeName;\n+        final StoreBuilder<TimestampedKeyValueStore<K, VR>> storeBuilder;\n+\n+        if (materializedInternal != null) {\n+            keySerde = materializedInternal.keySerde() != null ? materializedInternal.keySerde() : this.keySerde;\n+            valueSerde = materializedInternal.valueSerde();\n+            queryableStoreName = materializedInternal.queryableStoreName();\n+            storeBuilder = materializedInternal.queryableStoreName() == null\n+                ? null\n+                : new TimestampedKeyValueStoreMaterializer<>(materializedInternal).materialize();\n+\n+            storeName = materializedInternal.storeName() == null\n+                ? builder.newStoreName(TO_KTABLE_NAME)\n+                : materializedInternal.storeName();\n+\n+        } else {\n+            keySerde = this.keySerde;\n+            storeName = builder.newStoreName(TO_KTABLE_NAME);\n+            valueSerde = null;\n+            queryableStoreName = null;\n+            storeBuilder = null;\n+        }\n+\n+        final KTableSource<K, VR> processorSupplier = new KTableSource<>(storeName, queryableStoreName);\n+        final ProcessorParameters<K, VR> processorParameters = new ProcessorParameters<>(processorSupplier, name);\n+\n+        final StreamsGraphNode tableNode = new TableProcessorNode<>(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwODcwMA==", "bodyText": "Why do we need to create this table in this test? It seems more \"straight-forward\" to verify the output from streamToTableOutput directly with a hard-coded list of expected values?", "url": "https://github.com/apache/kafka/pull/7985#discussion_r369408700", "createdAt": "2020-01-22T07:47:32Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2343,121 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+        final Consumed<String, String> consumed2 = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"stream-table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String streamToTable = \"streamToTableInput\";\n+        final String output = \"output\";\n+        final String streamToTableOutput = \"streamToTableOutput\";\n+\n+        builder.table(input, consumed).toStream().to(output);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQxMDI4OQ==", "bodyText": "This test should pass without the need to pass in Materialized object to force a materialization explicitly (ie, when we call join later (btw: we should also add tests for table-table and foreign-key-join; both with using the \"stream-table\" as left or right input).\nTo test a forces materialization, we should have a separate test:\nbuilder.stream(input1, consumed).toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\nThat verifies the result by querying the store only (no output topic would be required for this test).", "url": "https://github.com/apache/kafka/pull/7985#discussion_r369410289", "createdAt": "2020-01-22T07:52:49Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2343,121 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+        final Consumed<String, String> consumed2 = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"stream-table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String streamToTable = \"streamToTableInput\";\n+        final String output = \"output\";\n+        final String streamToTableOutput = \"streamToTableOutput\";\n+\n+        builder.table(input, consumed).toStream().to(output);\n+        builder.stream(streamToTable, consumed2).toTable().toStream().to(streamToTableOutput);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestInputTopic<String, String> streamToTableInputTopic1 =\n+                driver.createInputTopic(streamToTable, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+            final TestOutputTopic<String, String> streamToTableOutputTopic =\n+                driver.createOutputTopic(streamToTableOutput, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            streamToTableInputTopic1.pipeInput(\"A\", \"01\", 5L);\n+            streamToTableInputTopic1.pipeInput(\"B\", \"02\", 100L);\n+            streamToTableInputTopic1.pipeInput(\"C\", \"03\", 0L);\n+            streamToTableInputTopic1.pipeInput(\"D\", \"04\", 0L);\n+            streamToTableInputTopic1.pipeInput(\"A\", \"05\", 10L);\n+            streamToTableInputTopic1.pipeInput(\"A\", \"06\", 8L);\n+            assertEquals(outputTopic.readRecordsToList(), streamToTableOutputTopic.readRecordsToList());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldKStreamToKTableJoinAndMaterializedStore() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+        final String storeName = \"store\";\n+\n+        final KTable table1 = builder.stream(input1, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 111}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTIxMDUx", "url": "https://github.com/apache/kafka/pull/7985#pullrequestreview-347121051", "createdAt": "2020-01-23T08:23:53Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODoyMzo1NFrOFg12ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QwODoyMzo1NFrOFg12ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MTEyMw==", "bodyText": "We have to addStateStore to topology so we can join\nso we needs to be materialized\ninternalStreamBuilder is similarly materialized.\nKTableKTableJoinNode is process check\n->\nif (!stateFactories.containsKey(stateStoreName)) {\nthrow new TopologyException(\"StateStore \" + stateStoreName + \" is not added yet.\");\n}\ntopologyBuilder.addStateStore(storeBuilder, nodeName());", "url": "https://github.com/apache/kafka/pull/7985#discussion_r369981123", "createdAt": "2020-01-23T08:23:54Z", "author": {"login": "highluck"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -600,6 +609,75 @@ private void to(final TopicNameExtractor<K, V> topicExtractor,\n         builder.addGraphNode(streamsGraphNode, sinkNode);\n     }\n \n+    @Override\n+    public KTable<K, V> toTable() {\n+        return toTable(NamedInternal.empty());\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Named named) {\n+        final ConsumedInternal<K, V> consumedInternal = new ConsumedInternal<>(Consumed.with(keySerde, valSerde));\n+\n+        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(\n+                Materialized.with(consumedInternal.keySerde(), consumedInternal.valueSerde()),\n+                builder,\n+                TO_KTABLE_NAME);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MjU2Mzgz", "url": "https://github.com/apache/kafka/pull/7985#pullrequestreview-348256383", "createdAt": "2020-01-24T22:16:56Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQyMjoxNjo1NlrOFhr7Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQyMjozNDo1MFrOFhsPXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg2NzAzOA==", "bodyText": "Can we add one more check to this test, to verify that no state store is created for the KTable? Ie, we should get the TopologyDescription and verify that there is no state store attached. Example: https://github.com/apache/kafka/blob/trunk/streams/src/test/java/org/apache/kafka/streams/kstream/internals/CogroupedKStreamImplTest.java#L208-L243\nThis this case, I would recommend to rename this this to shouldNotMaterializedKTableFromKStream", "url": "https://github.com/apache/kafka/pull/7985#discussion_r370867038", "createdAt": "2020-01-24T22:16:56Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2348,266 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldKTableFromKStream() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg2ODUyMQ==", "bodyText": "nit (rename): shouldMaterializeKTableFromKStream\n(a good naming patter is \"should  <condition/operation>\"", "url": "https://github.com/apache/kafka/pull/7985#discussion_r370868521", "createdAt": "2020-01-24T22:22:06Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2348,266 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldKTableFromKStreamCheckMaterializedStore() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg2OTIyOA==", "bodyText": "nit: shouldSupportForeignKeyTableTableJoinWithKTableFromKStream", "url": "https://github.com/apache/kafka/pull/7985#discussion_r370869228", "createdAt": "2020-01-24T22:24:29Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2348,266 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldKTableFromKStreamCheckMaterializedStore() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldKStreamToKTableForeignLeftJoin() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg2OTk3Mg==", "bodyText": "We should create this table from a stream. Otherwise we don't verify that toTable() does materialize the table (as required if used in a foreign key join) automatically. (ie, toTable() should not take a Materialized parameter in this test, but the join must still work).", "url": "https://github.com/apache/kafka/pull/7985#discussion_r370869972", "createdAt": "2020-01-24T22:27:00Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2348,266 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldKTableFromKStreamCheckMaterializedStore() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldKStreamToKTableForeignLeftJoin() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.table(input1, consumed);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3MDM0NA==", "bodyText": "Same here. We should use builder.stream().toTable()", "url": "https://github.com/apache/kafka/pull/7985#discussion_r370870344", "createdAt": "2020-01-24T22:28:23Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2348,266 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldKTableFromKStreamCheckMaterializedStore() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldKStreamToKTableForeignLeftJoin() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.table(input1, consumed);\n+        final KTable<String, String> rightTable = builder.table(input2, consumed);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3MDU1Mg==", "bodyText": "nit: shouldSupportTableTableJoinWithKStreamToKTable", "url": "https://github.com/apache/kafka/pull/7985#discussion_r370870552", "createdAt": "2020-01-24T22:29:07Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2348,266 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldKTableFromKStreamCheckMaterializedStore() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldKStreamToKTableForeignLeftJoin() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.table(input1, consumed);\n+        final KTable<String, String> rightTable = builder.table(input2, consumed);\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldKStreamToKTableInnerJoin() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3MTE0MA==", "bodyText": "As above, I think we should create both tables using toTable() operator", "url": "https://github.com/apache/kafka/pull/7985#discussion_r370871140", "createdAt": "2020-01-24T22:31:12Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2348,266 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldKTableFromKStreamCheckMaterializedStore() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldKStreamToKTableForeignLeftJoin() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.table(input1, consumed);\n+        final KTable<String, String> rightTable = builder.table(input2, consumed);\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldKStreamToKTableInnerJoin() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> table1 = builder.stream(input1, consumed).toTable();\n+\n+        final KTable<String, String> table2 = builder.table(input2, consumed);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3MTYwNg==", "bodyText": "I am frankly not sure, if we need to test left-table-table join explicitly (the table-table join test from above should be sufficient)", "url": "https://github.com/apache/kafka/pull/7985#discussion_r370871606", "createdAt": "2020-01-24T22:32:49Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2348,266 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldKTableFromKStreamCheckMaterializedStore() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldKStreamToKTableForeignLeftJoin() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.table(input1, consumed);\n+        final KTable<String, String> rightTable = builder.table(input2, consumed);\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldKStreamToKTableInnerJoin() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> table1 = builder.stream(input1, consumed).toTable();\n+\n+        final KTable<String, String> table2 = builder.table(input2, consumed);\n+        table1.join(table2, MockValueJoiner.TOSTRING_JOINER).toStream().to(output);\n+\n+        final Collection<Set<String>> copartitionGroups =\n+            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n+\n+        assertEquals(1, copartitionGroups.size());\n+        assertEquals(new HashSet<>(Arrays.asList(input1, input2)), copartitionGroups.iterator().next());\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic1 =\n+                driver.createInputTopic(input1, Serdes.String().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n+            final TestInputTopic<String, String> inputTopic2 =\n+                driver.createInputTopic(input2, Serdes.String().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic2.pipeInput(\"1\", \"stream\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(emptyMap())\n+            );\n+\n+            inputTopic1.pipeInput(\"1\", \"table\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"1\", \"table+stream\")\n+            );\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(expected)\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldKStreamToKTableLeftJoin() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3MTc2Mg==", "bodyText": "nit: shouldSupportStreamTableJoinWithKStreamToKTable", "url": "https://github.com/apache/kafka/pull/7985#discussion_r370871762", "createdAt": "2020-01-24T22:33:22Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2348,266 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldKTableFromKStreamCheckMaterializedStore() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldKStreamToKTableForeignLeftJoin() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.table(input1, consumed);\n+        final KTable<String, String> rightTable = builder.table(input2, consumed);\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldKStreamToKTableInnerJoin() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> table1 = builder.stream(input1, consumed).toTable();\n+\n+        final KTable<String, String> table2 = builder.table(input2, consumed);\n+        table1.join(table2, MockValueJoiner.TOSTRING_JOINER).toStream().to(output);\n+\n+        final Collection<Set<String>> copartitionGroups =\n+            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n+\n+        assertEquals(1, copartitionGroups.size());\n+        assertEquals(new HashSet<>(Arrays.asList(input1, input2)), copartitionGroups.iterator().next());\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic1 =\n+                driver.createInputTopic(input1, Serdes.String().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n+            final TestInputTopic<String, String> inputTopic2 =\n+                driver.createInputTopic(input2, Serdes.String().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic2.pipeInput(\"1\", \"stream\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(emptyMap())\n+            );\n+\n+            inputTopic1.pipeInput(\"1\", \"table\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"1\", \"table+stream\")\n+            );\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(expected)\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldKStreamToKTableLeftJoin() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> rightTable = builder.table(input2, consumed);\n+        final KTable<String, String> joined = leftTable.leftJoin(rightTable, MockValueJoiner.TOSTRING_JOINER);\n+        joined.toStream().to(output);\n+        checkLeftJoin(builder.build(), input1, input2, output);\n+    }\n+\n+    @Test\n+    public void shouldKStreamToKTableStreamLeftJoin() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg3MjE1OA==", "bodyText": "Why do you use a leftJoin and not an join (guess it does not make much of a difference -- fels just more natural to use inner join in all test)?", "url": "https://github.com/apache/kafka/pull/7985#discussion_r370872158", "createdAt": "2020-01-24T22:34:50Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2348,266 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldKTableFromKStreamCheckMaterializedStore() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldKStreamToKTableForeignLeftJoin() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.table(input1, consumed);\n+        final KTable<String, String> rightTable = builder.table(input2, consumed);\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldKStreamToKTableInnerJoin() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> table1 = builder.stream(input1, consumed).toTable();\n+\n+        final KTable<String, String> table2 = builder.table(input2, consumed);\n+        table1.join(table2, MockValueJoiner.TOSTRING_JOINER).toStream().to(output);\n+\n+        final Collection<Set<String>> copartitionGroups =\n+            TopologyWrapper.getInternalTopologyBuilder(builder.build()).copartitionGroups();\n+\n+        assertEquals(1, copartitionGroups.size());\n+        assertEquals(new HashSet<>(Arrays.asList(input1, input2)), copartitionGroups.iterator().next());\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic1 =\n+                driver.createInputTopic(input1, Serdes.String().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n+            final TestInputTopic<String, String> inputTopic2 =\n+                driver.createInputTopic(input2, Serdes.String().serializer(), Serdes.String().serializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic2.pipeInput(\"1\", \"stream\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(emptyMap())\n+            );\n+\n+            inputTopic1.pipeInput(\"1\", \"table\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"1\", \"table+stream\")\n+            );\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(expected)\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldKStreamToKTableLeftJoin() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> rightTable = builder.table(input2, consumed);\n+        final KTable<String, String> joined = leftTable.leftJoin(rightTable, MockValueJoiner.TOSTRING_JOINER);\n+        joined.toStream().to(output);\n+        checkLeftJoin(builder.build(), input1, input2, output);\n+    }\n+\n+    @Test\n+    public void shouldKStreamToKTableStreamLeftJoin() {\n+        final String streamTopic = \"streamTopic\";\n+        final String tableTopic = \"tableTopic\";\n+        final String output = \"output\";\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final KStream<String, String> stream = builder.stream(streamTopic, consumed);\n+        final KTable<String, String> table =  builder.stream(tableTopic, consumed).toTable();\n+\n+        stream.leftJoin(table, MockValueJoiner.TOSTRING_JOINER).to(output);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 263}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5NzU3NDQ2", "url": "https://github.com/apache/kafka/pull/7985#pullrequestreview-349757446", "createdAt": "2020-01-28T22:42:46Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMjo0Mjo0NlrOFi3MyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMzoxNzo0NVrOFi39jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwMDI5Ng==", "bodyText": "For this case, the input KStream key was not changed, and thus no repartition topic should be created. We should only get a single sub-topology.", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372100296", "createdAt": "2020-01-28T22:42:46Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2331,484 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000004\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000004 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000003 (topic: KSTREAM-TOTABLE-0000000002-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000004\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000005 (topics: [KSTREAM-TOTABLE-0000000002-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000006\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000005\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000006 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000007\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000007 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000006\\n\\n\")\n+        );", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwMDk1Mw==", "bodyText": "For this case, we should not get a state store.", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372100953", "createdAt": "2020-01-28T22:44:23Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2331,484 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000004\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000004 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000003 (topic: KSTREAM-TOTABLE-0000000002-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000004\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000005 (topics: [KSTREAM-TOTABLE-0000000002-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwMTk0OA==", "bodyText": "Might be good, to add a verification step for the topologyDescription similar to above (base on past experience, I am a little paranoid to make sure we do the correct thing when building the topology).", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372101948", "createdAt": "2020-01-28T22:47:07Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2331,484 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000004\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000004 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000003 (topic: KSTREAM-TOTABLE-0000000002-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000004\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000005 (topics: [KSTREAM-TOTABLE-0000000002-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000006\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000005\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000006 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000007\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000007 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000006\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMaterializeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwNTI3Nw==", "bodyText": "As above: add a topologyDescription verification step -- we should see a repartition topic. We should also not get a state store when reading the data from the repartition topic into the KTable for this case.", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372105277", "createdAt": "2020-01-28T22:56:05Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2331,484 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000004\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000004 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000003 (topic: KSTREAM-TOTABLE-0000000002-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000004\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000005 (topics: [KSTREAM-TOTABLE-0000000002-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000006\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000005\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000006 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000007\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000007 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000006\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMaterializeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportKeyChangeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed)\n+            .map((key, value) -> new KeyValue<>(key + \"-\", value))\n+            .toTable()\n+            .toStream().to(output);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwNjA1NQ==", "bodyText": "Because the key was not changes, there should not be any repartition topics -- the test seems redundant to shouldNotMaterializedKTableFromKStream (or actually shouldSupportKeyChangeKTableFromKStream) ? Why do we need this test in addition to the above ones?", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372106055", "createdAt": "2020-01-28T22:58:09Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2331,484 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000004\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000004 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000003 (topic: KSTREAM-TOTABLE-0000000002-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000004\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000005 (topics: [KSTREAM-TOTABLE-0000000002-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000006\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000005\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000006 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000007\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000007 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000006\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMaterializeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportKeyChangeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed)\n+            .map((key, value) -> new KeyValue<>(key + \"-\", value))\n+            .toTable()\n+            .toStream().to(output);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B-\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C-\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D-\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldPropagateRepartitionFlagAfterKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        builder.stream(\"input\", consumed).toTable();\n+\n+        final Pattern repartitionTopicPattern = Pattern.compile(\"Sink: .*-repartition\");\n+        final String topology = builder.build().describe().toString();\n+        final Matcher matcher = repartitionTopicPattern.matcher(topology);\n+        assertTrue(matcher.find());\n+        final String match = matcher.group();\n+        assertThat(match, notNullValue());\n+        assertTrue(match.endsWith(\"repartition\"));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwNjI0Mg==", "bodyText": "As above: let's add a topologyDescription verification step (sam the the other tests below).", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372106242", "createdAt": "2020-01-28T22:58:44Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2331,484 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000004\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000004 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000003 (topic: KSTREAM-TOTABLE-0000000002-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000004\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000005 (topics: [KSTREAM-TOTABLE-0000000002-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000006\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000005\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000006 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000007\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000007 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000006\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMaterializeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportKeyChangeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed)\n+            .map((key, value) -> new KeyValue<>(key + \"-\", value))\n+            .toTable()\n+            .toStream().to(output);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B-\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C-\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D-\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldPropagateRepartitionFlagAfterKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        builder.stream(\"input\", consumed).toTable();\n+\n+        final Pattern repartitionTopicPattern = Pattern.compile(\"Sink: .*-repartition\");\n+        final String topology = builder.build().describe().toString();\n+        final Matcher matcher = repartitionTopicPattern.matcher(topology);\n+        assertTrue(matcher.find());\n+        final String match = matcher.group();\n+        assertThat(match, notNullValue());\n+        assertTrue(match.endsWith(\"repartition\"));\n+    }\n+\n+\n+    @Test\n+    public void shouldSupportForeignKeyTableTableJoinWithKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> rightTable = builder.stream(input2, consumed).toTable();\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 263}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwNjg4Mw==", "bodyText": "typo: KTStream", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372106883", "createdAt": "2020-01-28T23:00:34Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2331,484 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000004\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000004 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000003 (topic: KSTREAM-TOTABLE-0000000002-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000004\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000005 (topics: [KSTREAM-TOTABLE-0000000002-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000006\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000005\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000006 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000007\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000007 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000006\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMaterializeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportKeyChangeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed)\n+            .map((key, value) -> new KeyValue<>(key + \"-\", value))\n+            .toTable()\n+            .toStream().to(output);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B-\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C-\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D-\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldPropagateRepartitionFlagAfterKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        builder.stream(\"input\", consumed).toTable();\n+\n+        final Pattern repartitionTopicPattern = Pattern.compile(\"Sink: .*-repartition\");\n+        final String topology = builder.build().describe().toString();\n+        final Matcher matcher = repartitionTopicPattern.matcher(topology);\n+        assertTrue(matcher.find());\n+        final String match = matcher.group();\n+        assertThat(match, notNullValue());\n+        assertTrue(match.endsWith(\"repartition\"));\n+    }\n+\n+\n+    @Test\n+    public void shouldSupportForeignKeyTableTableJoinWithKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> rightTable = builder.stream(input2, consumed).toTable();\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportTableTableJoinWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> table1 = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> table2 = builder.stream(input2, consumed).toTable();\n+\n+        table1.join(table2, MockValueJoiner.TOSTRING_JOINER).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, input1, input2, output);\n+    }\n+\n+    @Test\n+    public void shouldSupportStreamTableJoinWithKStreamToKTable() {\n+        final String streamTopic = \"streamTopic\";\n+        final String tableTopic = \"tableTopic\";\n+        final String output = \"output\";\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final KStream<String, String> stream = builder.stream(streamTopic, consumed);\n+        final KTable<String, String> table =  builder.stream(tableTopic, consumed).toTable();\n+\n+        stream.join(table, MockValueJoiner.TOSTRING_JOINER).to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, streamTopic, tableTopic, output);\n+    }\n+\n+    private void checkJoin(final Topology topology,\n+                           final String leftTopic,\n+                           final String rightTopic,\n+                           final String outputTopic) {\n+        final Collection<Set<String>> copartitionGroups =\n+            TopologyWrapper.getInternalTopologyBuilder(topology).copartitionGroups();\n+\n+        assertEquals(1, copartitionGroups.size());\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(leftTopic, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(rightTopic, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> output = driver.createOutputTopic(outputTopic, new StringDeserializer(), new StringDeserializer());\n+\n+            right.pipeInput(\"lhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"lhs3\", \"rhsValue3\");\n+\n+            assertThat(output.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"lhsValue1+rhsValue1\")\n+            );\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(expected)\n+            );\n+\n+            left.pipeInput(\"lhs3\", \"lhsValue3\");\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"lhsValue3+rhsValue3\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue4\");\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", \"lhsValue4+rhsValue1\")\n+                ))\n+            );\n+\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportGroupByCountWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder\n+            .stream(input, consumed)\n+            .toTable()\n+            .groupBy(MockMapper.selectValueKeyValueMapper(), Grouped.with(Serdes.String(), Serdes.String()))\n+            .count(Materialized.as(\"count\"))\n+            .toStream()\n+            .to(output);\n+\n+        testCountHelper(builder, input, output);\n+    }\n+\n+    private static void testCountHelper(final StreamsBuilder builder,\n+                                        final String input,\n+                                        final String output) {\n+        try (\n+            final TopologyTestDriver driver = new TopologyTestDriver(\n+                builder.build(),\n+                mkProperties(mkMap(\n+                    mkEntry(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\"),\n+                    mkEntry(StreamsConfig.APPLICATION_ID_CONFIG, \"test\"),\n+                    mkEntry(StreamsConfig.STATE_DIR_CONFIG, TestUtils.tempDirectory(\"kafka-test\").getAbsolutePath())\n+                )),\n+                Instant.ofEpochMilli(0L))) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, new StringSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n+            final TestOutputTopic<String, Long> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.Long().deserializer());\n+\n+\n+            inputTopic.pipeInput(\"A\", \"green\", 10L);\n+            inputTopic.pipeInput(\"B\", \"green\", 9L);\n+            inputTopic.pipeInput(\"A\", \"blue\", 12L);\n+            inputTopic.pipeInput(\"C\", \"yellow\", 15L);\n+            inputTopic.pipeInput(\"D\", \"green\", 11L);\n+\n+            assertEquals(\n+                asList(\n+                    new TestRecord<>(\"green\", 1L, Instant.ofEpochMilli(10)),\n+                    new TestRecord<>(\"green\", 2L, Instant.ofEpochMilli(10)),\n+                    new TestRecord<>(\"green\", 1L, Instant.ofEpochMilli(12)),\n+                    new TestRecord<>(\"blue\", 1L, Instant.ofEpochMilli(12)),\n+                    new TestRecord<>(\"yellow\", 1L, Instant.ofEpochMilli(15)),\n+                    new TestRecord<>(\"green\", 2L, Instant.ofEpochMilli(12))),\n+                outputTopic.readRecordsToList());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportMapValueTriggerMaterializedWithKTableFromKTStream() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 447}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwODE3Mg==", "bodyText": "This is hard to read. I guess the 151 is the g from green as int value (that I don't know from the top of my head) plus 48?", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372108172", "createdAt": "2020-01-28T23:04:17Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2331,484 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000004\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000004 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000003 (topic: KSTREAM-TOTABLE-0000000002-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000004\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000005 (topics: [KSTREAM-TOTABLE-0000000002-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000006\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000005\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000006 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000007\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000007 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000006\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMaterializeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportKeyChangeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed)\n+            .map((key, value) -> new KeyValue<>(key + \"-\", value))\n+            .toTable()\n+            .toStream().to(output);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B-\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C-\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D-\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldPropagateRepartitionFlagAfterKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        builder.stream(\"input\", consumed).toTable();\n+\n+        final Pattern repartitionTopicPattern = Pattern.compile(\"Sink: .*-repartition\");\n+        final String topology = builder.build().describe().toString();\n+        final Matcher matcher = repartitionTopicPattern.matcher(topology);\n+        assertTrue(matcher.find());\n+        final String match = matcher.group();\n+        assertThat(match, notNullValue());\n+        assertTrue(match.endsWith(\"repartition\"));\n+    }\n+\n+\n+    @Test\n+    public void shouldSupportForeignKeyTableTableJoinWithKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> rightTable = builder.stream(input2, consumed).toTable();\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportTableTableJoinWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> table1 = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> table2 = builder.stream(input2, consumed).toTable();\n+\n+        table1.join(table2, MockValueJoiner.TOSTRING_JOINER).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, input1, input2, output);\n+    }\n+\n+    @Test\n+    public void shouldSupportStreamTableJoinWithKStreamToKTable() {\n+        final String streamTopic = \"streamTopic\";\n+        final String tableTopic = \"tableTopic\";\n+        final String output = \"output\";\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final KStream<String, String> stream = builder.stream(streamTopic, consumed);\n+        final KTable<String, String> table =  builder.stream(tableTopic, consumed).toTable();\n+\n+        stream.join(table, MockValueJoiner.TOSTRING_JOINER).to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, streamTopic, tableTopic, output);\n+    }\n+\n+    private void checkJoin(final Topology topology,\n+                           final String leftTopic,\n+                           final String rightTopic,\n+                           final String outputTopic) {\n+        final Collection<Set<String>> copartitionGroups =\n+            TopologyWrapper.getInternalTopologyBuilder(topology).copartitionGroups();\n+\n+        assertEquals(1, copartitionGroups.size());\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(leftTopic, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(rightTopic, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> output = driver.createOutputTopic(outputTopic, new StringDeserializer(), new StringDeserializer());\n+\n+            right.pipeInput(\"lhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"lhs3\", \"rhsValue3\");\n+\n+            assertThat(output.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"lhsValue1+rhsValue1\")\n+            );\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(expected)\n+            );\n+\n+            left.pipeInput(\"lhs3\", \"lhsValue3\");\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"lhsValue3+rhsValue3\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue4\");\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", \"lhsValue4+rhsValue1\")\n+                ))\n+            );\n+\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportGroupByCountWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder\n+            .stream(input, consumed)\n+            .toTable()\n+            .groupBy(MockMapper.selectValueKeyValueMapper(), Grouped.with(Serdes.String(), Serdes.String()))\n+            .count(Materialized.as(\"count\"))\n+            .toStream()\n+            .to(output);\n+\n+        testCountHelper(builder, input, output);\n+    }\n+\n+    private static void testCountHelper(final StreamsBuilder builder,\n+                                        final String input,\n+                                        final String output) {\n+        try (\n+            final TopologyTestDriver driver = new TopologyTestDriver(\n+                builder.build(),\n+                mkProperties(mkMap(\n+                    mkEntry(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\"),\n+                    mkEntry(StreamsConfig.APPLICATION_ID_CONFIG, \"test\"),\n+                    mkEntry(StreamsConfig.STATE_DIR_CONFIG, TestUtils.tempDirectory(\"kafka-test\").getAbsolutePath())\n+                )),\n+                Instant.ofEpochMilli(0L))) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, new StringSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n+            final TestOutputTopic<String, Long> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.Long().deserializer());\n+\n+\n+            inputTopic.pipeInput(\"A\", \"green\", 10L);\n+            inputTopic.pipeInput(\"B\", \"green\", 9L);\n+            inputTopic.pipeInput(\"A\", \"blue\", 12L);\n+            inputTopic.pipeInput(\"C\", \"yellow\", 15L);\n+            inputTopic.pipeInput(\"D\", \"green\", 11L);\n+\n+            assertEquals(\n+                asList(\n+                    new TestRecord<>(\"green\", 1L, Instant.ofEpochMilli(10)),\n+                    new TestRecord<>(\"green\", 2L, Instant.ofEpochMilli(10)),\n+                    new TestRecord<>(\"green\", 1L, Instant.ofEpochMilli(12)),\n+                    new TestRecord<>(\"blue\", 1L, Instant.ofEpochMilli(12)),\n+                    new TestRecord<>(\"yellow\", 1L, Instant.ofEpochMilli(15)),\n+                    new TestRecord<>(\"green\", 2L, Instant.ofEpochMilli(12))),\n+                outputTopic.readRecordsToList());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportMapValueTriggerMaterializedWithKTableFromKTStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final String input = \"input\";\n+        final String output = \"output\";\n+        final String storeName = \"store\";\n+\n+        builder.stream(input, consumed)\n+            .toTable()\n+            .mapValues(\n+                value -> value.charAt(0) + 48,\n+                Materialized.<String, Integer, KeyValueStore<Bytes, byte[]>>as(storeName)\n+                    .withKeySerde(Serdes.String())\n+                    .withValueSerde(Serdes.Integer()))\n+            .toStream()\n+            .to(output);\n+\n+        try (\n+            final TopologyTestDriver driver = new TopologyTestDriver(\n+                builder.build(),\n+                mkProperties(mkMap(\n+                    mkEntry(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\"),\n+                    mkEntry(StreamsConfig.APPLICATION_ID_CONFIG, \"test\"),\n+                    mkEntry(StreamsConfig.STATE_DIR_CONFIG, TestUtils.tempDirectory(\"kafka-test\").getAbsolutePath())\n+                )),\n+                Instant.ofEpochMilli(0L))) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, new StringSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n+            final TestOutputTopic<String, Integer> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.Integer().deserializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+            \n+            inputTopic.pipeInput(\"A\", \"green\", 10L);\n+            inputTopic.pipeInput(\"B\", \"green\", 9L);\n+            inputTopic.pipeInput(\"A\", \"blue\", 12L);\n+            inputTopic.pipeInput(\"C\", \"yellow\", 15L);\n+            inputTopic.pipeInput(\"D\", \"green\", 11L);\n+\n+            final Map<String, Integer> expectedStore = new HashMap<>();\n+            expectedStore.putIfAbsent(\"A\", 146);\n+            expectedStore.putIfAbsent(\"B\", 151);\n+            expectedStore.putIfAbsent(\"C\", 169);\n+            expectedStore.putIfAbsent(\"D\", 151);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 488}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwODYxMg==", "bodyText": "Maybe do value -> value.charAt(0) - (int)'a', to map a to zero, b to one etc (makes it easier to read the test IMHO -- compare my comment below)", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372108612", "createdAt": "2020-01-28T23:05:29Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2331,484 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000004\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000004 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000003 (topic: KSTREAM-TOTABLE-0000000002-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000004\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000005 (topics: [KSTREAM-TOTABLE-0000000002-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000006\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000005\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000006 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000007\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000007 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000006\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMaterializeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportKeyChangeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed)\n+            .map((key, value) -> new KeyValue<>(key + \"-\", value))\n+            .toTable()\n+            .toStream().to(output);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B-\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C-\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D-\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldPropagateRepartitionFlagAfterKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        builder.stream(\"input\", consumed).toTable();\n+\n+        final Pattern repartitionTopicPattern = Pattern.compile(\"Sink: .*-repartition\");\n+        final String topology = builder.build().describe().toString();\n+        final Matcher matcher = repartitionTopicPattern.matcher(topology);\n+        assertTrue(matcher.find());\n+        final String match = matcher.group();\n+        assertThat(match, notNullValue());\n+        assertTrue(match.endsWith(\"repartition\"));\n+    }\n+\n+\n+    @Test\n+    public void shouldSupportForeignKeyTableTableJoinWithKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> rightTable = builder.stream(input2, consumed).toTable();\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportTableTableJoinWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> table1 = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> table2 = builder.stream(input2, consumed).toTable();\n+\n+        table1.join(table2, MockValueJoiner.TOSTRING_JOINER).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, input1, input2, output);\n+    }\n+\n+    @Test\n+    public void shouldSupportStreamTableJoinWithKStreamToKTable() {\n+        final String streamTopic = \"streamTopic\";\n+        final String tableTopic = \"tableTopic\";\n+        final String output = \"output\";\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final KStream<String, String> stream = builder.stream(streamTopic, consumed);\n+        final KTable<String, String> table =  builder.stream(tableTopic, consumed).toTable();\n+\n+        stream.join(table, MockValueJoiner.TOSTRING_JOINER).to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, streamTopic, tableTopic, output);\n+    }\n+\n+    private void checkJoin(final Topology topology,\n+                           final String leftTopic,\n+                           final String rightTopic,\n+                           final String outputTopic) {\n+        final Collection<Set<String>> copartitionGroups =\n+            TopologyWrapper.getInternalTopologyBuilder(topology).copartitionGroups();\n+\n+        assertEquals(1, copartitionGroups.size());\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(leftTopic, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(rightTopic, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> output = driver.createOutputTopic(outputTopic, new StringDeserializer(), new StringDeserializer());\n+\n+            right.pipeInput(\"lhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"lhs3\", \"rhsValue3\");\n+\n+            assertThat(output.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"lhsValue1+rhsValue1\")\n+            );\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(expected)\n+            );\n+\n+            left.pipeInput(\"lhs3\", \"lhsValue3\");\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"lhsValue3+rhsValue3\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue4\");\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", \"lhsValue4+rhsValue1\")\n+                ))\n+            );\n+\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportGroupByCountWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder\n+            .stream(input, consumed)\n+            .toTable()\n+            .groupBy(MockMapper.selectValueKeyValueMapper(), Grouped.with(Serdes.String(), Serdes.String()))\n+            .count(Materialized.as(\"count\"))\n+            .toStream()\n+            .to(output);\n+\n+        testCountHelper(builder, input, output);\n+    }\n+\n+    private static void testCountHelper(final StreamsBuilder builder,\n+                                        final String input,\n+                                        final String output) {\n+        try (\n+            final TopologyTestDriver driver = new TopologyTestDriver(\n+                builder.build(),\n+                mkProperties(mkMap(\n+                    mkEntry(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\"),\n+                    mkEntry(StreamsConfig.APPLICATION_ID_CONFIG, \"test\"),\n+                    mkEntry(StreamsConfig.STATE_DIR_CONFIG, TestUtils.tempDirectory(\"kafka-test\").getAbsolutePath())\n+                )),\n+                Instant.ofEpochMilli(0L))) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, new StringSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n+            final TestOutputTopic<String, Long> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.Long().deserializer());\n+\n+\n+            inputTopic.pipeInput(\"A\", \"green\", 10L);\n+            inputTopic.pipeInput(\"B\", \"green\", 9L);\n+            inputTopic.pipeInput(\"A\", \"blue\", 12L);\n+            inputTopic.pipeInput(\"C\", \"yellow\", 15L);\n+            inputTopic.pipeInput(\"D\", \"green\", 11L);\n+\n+            assertEquals(\n+                asList(\n+                    new TestRecord<>(\"green\", 1L, Instant.ofEpochMilli(10)),\n+                    new TestRecord<>(\"green\", 2L, Instant.ofEpochMilli(10)),\n+                    new TestRecord<>(\"green\", 1L, Instant.ofEpochMilli(12)),\n+                    new TestRecord<>(\"blue\", 1L, Instant.ofEpochMilli(12)),\n+                    new TestRecord<>(\"yellow\", 1L, Instant.ofEpochMilli(15)),\n+                    new TestRecord<>(\"green\", 2L, Instant.ofEpochMilli(12))),\n+                outputTopic.readRecordsToList());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportMapValueTriggerMaterializedWithKTableFromKTStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final String input = \"input\";\n+        final String output = \"output\";\n+        final String storeName = \"store\";\n+\n+        builder.stream(input, consumed)\n+            .toTable()\n+            .mapValues(\n+                value -> value.charAt(0) + 48,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 456}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwOTQ1NQ==", "bodyText": "This last checks seem redundant to above assertThat(topologyDescription, equalTo(\"...\"))?", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372109455", "createdAt": "2020-01-28T23:07:55Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2331,484 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000004\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000004 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000003 (topic: KSTREAM-TOTABLE-0000000002-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000004\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000005 (topics: [KSTREAM-TOTABLE-0000000002-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000006\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000005\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000006 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000007\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000007 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000006\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMaterializeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportKeyChangeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed)\n+            .map((key, value) -> new KeyValue<>(key + \"-\", value))\n+            .toTable()\n+            .toStream().to(output);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B-\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C-\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D-\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldPropagateRepartitionFlagAfterKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        builder.stream(\"input\", consumed).toTable();\n+\n+        final Pattern repartitionTopicPattern = Pattern.compile(\"Sink: .*-repartition\");\n+        final String topology = builder.build().describe().toString();\n+        final Matcher matcher = repartitionTopicPattern.matcher(topology);\n+        assertTrue(matcher.find());\n+        final String match = matcher.group();\n+        assertThat(match, notNullValue());\n+        assertTrue(match.endsWith(\"repartition\"));\n+    }\n+\n+\n+    @Test\n+    public void shouldSupportForeignKeyTableTableJoinWithKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> rightTable = builder.stream(input2, consumed).toTable();\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportTableTableJoinWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> table1 = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> table2 = builder.stream(input2, consumed).toTable();\n+\n+        table1.join(table2, MockValueJoiner.TOSTRING_JOINER).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, input1, input2, output);\n+    }\n+\n+    @Test\n+    public void shouldSupportStreamTableJoinWithKStreamToKTable() {\n+        final String streamTopic = \"streamTopic\";\n+        final String tableTopic = \"tableTopic\";\n+        final String output = \"output\";\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final KStream<String, String> stream = builder.stream(streamTopic, consumed);\n+        final KTable<String, String> table =  builder.stream(tableTopic, consumed).toTable();\n+\n+        stream.join(table, MockValueJoiner.TOSTRING_JOINER).to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, streamTopic, tableTopic, output);\n+    }\n+\n+    private void checkJoin(final Topology topology,\n+                           final String leftTopic,\n+                           final String rightTopic,\n+                           final String outputTopic) {\n+        final Collection<Set<String>> copartitionGroups =\n+            TopologyWrapper.getInternalTopologyBuilder(topology).copartitionGroups();\n+\n+        assertEquals(1, copartitionGroups.size());\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(leftTopic, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(rightTopic, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> output = driver.createOutputTopic(outputTopic, new StringDeserializer(), new StringDeserializer());\n+\n+            right.pipeInput(\"lhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"lhs3\", \"rhsValue3\");\n+\n+            assertThat(output.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"lhsValue1+rhsValue1\")\n+            );\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(expected)\n+            );\n+\n+            left.pipeInput(\"lhs3\", \"lhsValue3\");\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"lhsValue3+rhsValue3\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue4\");\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", \"lhsValue4+rhsValue1\")\n+                ))\n+            );\n+\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportGroupByCountWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder\n+            .stream(input, consumed)\n+            .toTable()\n+            .groupBy(MockMapper.selectValueKeyValueMapper(), Grouped.with(Serdes.String(), Serdes.String()))\n+            .count(Materialized.as(\"count\"))\n+            .toStream()\n+            .to(output);\n+\n+        testCountHelper(builder, input, output);\n+    }\n+\n+    private static void testCountHelper(final StreamsBuilder builder,\n+                                        final String input,\n+                                        final String output) {\n+        try (\n+            final TopologyTestDriver driver = new TopologyTestDriver(\n+                builder.build(),\n+                mkProperties(mkMap(\n+                    mkEntry(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\"),\n+                    mkEntry(StreamsConfig.APPLICATION_ID_CONFIG, \"test\"),\n+                    mkEntry(StreamsConfig.STATE_DIR_CONFIG, TestUtils.tempDirectory(\"kafka-test\").getAbsolutePath())\n+                )),\n+                Instant.ofEpochMilli(0L))) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, new StringSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n+            final TestOutputTopic<String, Long> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.Long().deserializer());\n+\n+\n+            inputTopic.pipeInput(\"A\", \"green\", 10L);\n+            inputTopic.pipeInput(\"B\", \"green\", 9L);\n+            inputTopic.pipeInput(\"A\", \"blue\", 12L);\n+            inputTopic.pipeInput(\"C\", \"yellow\", 15L);\n+            inputTopic.pipeInput(\"D\", \"green\", 11L);\n+\n+            assertEquals(\n+                asList(\n+                    new TestRecord<>(\"green\", 1L, Instant.ofEpochMilli(10)),\n+                    new TestRecord<>(\"green\", 2L, Instant.ofEpochMilli(10)),\n+                    new TestRecord<>(\"green\", 1L, Instant.ofEpochMilli(12)),\n+                    new TestRecord<>(\"blue\", 1L, Instant.ofEpochMilli(12)),\n+                    new TestRecord<>(\"yellow\", 1L, Instant.ofEpochMilli(15)),\n+                    new TestRecord<>(\"green\", 2L, Instant.ofEpochMilli(12))),\n+                outputTopic.readRecordsToList());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportMapValueTriggerMaterializedWithKTableFromKTStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final String input = \"input\";\n+        final String output = \"output\";\n+        final String storeName = \"store\";\n+\n+        builder.stream(input, consumed)\n+            .toTable()\n+            .mapValues(\n+                value -> value.charAt(0) + 48,\n+                Materialized.<String, Integer, KeyValueStore<Bytes, byte[]>>as(storeName)\n+                    .withKeySerde(Serdes.String())\n+                    .withValueSerde(Serdes.Integer()))\n+            .toStream()\n+            .to(output);\n+\n+        try (\n+            final TopologyTestDriver driver = new TopologyTestDriver(\n+                builder.build(),\n+                mkProperties(mkMap(\n+                    mkEntry(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\"),\n+                    mkEntry(StreamsConfig.APPLICATION_ID_CONFIG, \"test\"),\n+                    mkEntry(StreamsConfig.STATE_DIR_CONFIG, TestUtils.tempDirectory(\"kafka-test\").getAbsolutePath())\n+                )),\n+                Instant.ofEpochMilli(0L))) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, new StringSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n+            final TestOutputTopic<String, Integer> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.Integer().deserializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+            \n+            inputTopic.pipeInput(\"A\", \"green\", 10L);\n+            inputTopic.pipeInput(\"B\", \"green\", 9L);\n+            inputTopic.pipeInput(\"A\", \"blue\", 12L);\n+            inputTopic.pipeInput(\"C\", \"yellow\", 15L);\n+            inputTopic.pipeInput(\"D\", \"green\", 11L);\n+\n+            final Map<String, Integer> expectedStore = new HashMap<>();\n+            expectedStore.putIfAbsent(\"A\", 146);\n+            expectedStore.putIfAbsent(\"B\", 151);\n+            expectedStore.putIfAbsent(\"C\", 169);\n+            expectedStore.putIfAbsent(\"D\", 151);\n+\n+            assertEquals(expectedStore, asMap(store));\n+\n+            assertEquals(\n+                asList(\n+                    new TestRecord<>(\"A\", 151, Instant.ofEpochMilli(10)),\n+                    new TestRecord<>(\"B\", 151, Instant.ofEpochMilli(9)),\n+                    new TestRecord<>(\"A\", 146, Instant.ofEpochMilli(12)),\n+                    new TestRecord<>(\"C\", 169, Instant.ofEpochMilli(15)),\n+                    new TestRecord<>(\"D\", 151, Instant.ofEpochMilli(11))),\n+                outputTopic.readRecordsToList());\n+\n+        }\n+    }\n+\n+    private static Map<String, String> asMap(final KeyValueStore<String, String> store) {\n+        final HashMap<String, String> result = new HashMap<>();\n+        store.all().forEachRemaining(kv -> result.put(kv.key, kv.value));\n+        return result;\n+    }\n+\n+    @Test\n+    public void shouldPropagateRepartitionFlagAfterGlobalKTableJoin() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final String input = \"input\";\n+        final String topic = \"topic\";\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final KTable<String, String> kTable = builder.stream(input, consumed)\n+            .map((k, v) -> KeyValue.pair(k + \"-\", v))\n+            .toTable();\n+        final ValueJoiner<String, String, String> valueJoiner = (v1, v2) -> v1 + v2;\n+        builder.<String, String>stream(topic).selectKey((k, v) -> v)\n+            .join(kTable, valueJoiner)\n+            .groupByKey()\n+            .count();\n+\n+        final Pattern repartitionTopicPattern = Pattern.compile(\"Sink: .*-repartition\");\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-MAP-0000000001\\n\" +\n+                \"    Processor: KSTREAM-MAP-0000000001 (stores: [])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000005\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000005 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-MAP-0000000001\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: KSTREAM-TOTABLE-0000000003-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000005\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000011 (topics: [KSTREAM-KEY-SELECT-0000000008-repartition])\\n\" +\n+                \"      --> KSTREAM-JOIN-0000000012\\n\" +\n+                \"    Processor: KSTREAM-JOIN-0000000012 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000002])\\n\" +\n+                \"      --> KSTREAM-AGGREGATE-0000000014\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000011\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000006 (topics: [KSTREAM-TOTABLE-0000000003-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Processor: KSTREAM-AGGREGATE-0000000014 (stores: [KSTREAM-AGGREGATE-STATE-STORE-0000000013])\\n\" +\n+                \"      --> none\\n\" +\n+                \"      <-- KSTREAM-JOIN-0000000012\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000003 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000002])\\n\" +\n+                \"      --> none\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000006\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 2\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000007 (topics: [topic])\\n\" +\n+                \"      --> KSTREAM-KEY-SELECT-0000000008\\n\" +\n+                \"    Processor: KSTREAM-KEY-SELECT-0000000008 (stores: [])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000010\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000007\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000010 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000009\\n\" +\n+                \"      <-- KSTREAM-KEY-SELECT-0000000008\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000009 (topic: KSTREAM-KEY-SELECT-0000000008-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000010\\n\\n\"));\n+\n+\n+        final Matcher matcher = repartitionTopicPattern.matcher(topologyDescription);\n+        assertTrue(matcher.find());\n+        final String match = matcher.group();\n+        assertThat(match, notNullValue());\n+        assertTrue(match.endsWith(\"repartition\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 577}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjExMjc4MQ==", "bodyText": "The test itself is great -- but the name does not really match -- there is no GlobalKTable in this test.\nMight also be good to pipe some data using the TTD in this test.", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372112781", "createdAt": "2020-01-28T23:17:45Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2331,484 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000004\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000004 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000003 (topic: KSTREAM-TOTABLE-0000000002-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000004\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000005 (topics: [KSTREAM-TOTABLE-0000000002-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000006\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000005\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000006 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000007\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000007 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000006\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMaterializeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String())\n+            .withName(\"table-process\");\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportKeyChangeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed)\n+            .map((key, value) -> new KeyValue<>(key + \"-\", value))\n+            .toTable()\n+            .toStream().to(output);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B-\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C-\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D-\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldPropagateRepartitionFlagAfterKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        builder.stream(\"input\", consumed).toTable();\n+\n+        final Pattern repartitionTopicPattern = Pattern.compile(\"Sink: .*-repartition\");\n+        final String topology = builder.build().describe().toString();\n+        final Matcher matcher = repartitionTopicPattern.matcher(topology);\n+        assertTrue(matcher.find());\n+        final String match = matcher.group();\n+        assertThat(match, notNullValue());\n+        assertTrue(match.endsWith(\"repartition\"));\n+    }\n+\n+\n+    @Test\n+    public void shouldSupportForeignKeyTableTableJoinWithKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> rightTable = builder.stream(input2, consumed).toTable();\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportTableTableJoinWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> table1 = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> table2 = builder.stream(input2, consumed).toTable();\n+\n+        table1.join(table2, MockValueJoiner.TOSTRING_JOINER).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, input1, input2, output);\n+    }\n+\n+    @Test\n+    public void shouldSupportStreamTableJoinWithKStreamToKTable() {\n+        final String streamTopic = \"streamTopic\";\n+        final String tableTopic = \"tableTopic\";\n+        final String output = \"output\";\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final KStream<String, String> stream = builder.stream(streamTopic, consumed);\n+        final KTable<String, String> table =  builder.stream(tableTopic, consumed).toTable();\n+\n+        stream.join(table, MockValueJoiner.TOSTRING_JOINER).to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, streamTopic, tableTopic, output);\n+    }\n+\n+    private void checkJoin(final Topology topology,\n+                           final String leftTopic,\n+                           final String rightTopic,\n+                           final String outputTopic) {\n+        final Collection<Set<String>> copartitionGroups =\n+            TopologyWrapper.getInternalTopologyBuilder(topology).copartitionGroups();\n+\n+        assertEquals(1, copartitionGroups.size());\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(leftTopic, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(rightTopic, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> output = driver.createOutputTopic(outputTopic, new StringDeserializer(), new StringDeserializer());\n+\n+            right.pipeInput(\"lhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"lhs3\", \"rhsValue3\");\n+\n+            assertThat(output.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"lhsValue1+rhsValue1\")\n+            );\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(expected)\n+            );\n+\n+            left.pipeInput(\"lhs3\", \"lhsValue3\");\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"lhsValue3+rhsValue3\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue4\");\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", \"lhsValue4+rhsValue1\")\n+                ))\n+            );\n+\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportGroupByCountWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder\n+            .stream(input, consumed)\n+            .toTable()\n+            .groupBy(MockMapper.selectValueKeyValueMapper(), Grouped.with(Serdes.String(), Serdes.String()))\n+            .count(Materialized.as(\"count\"))\n+            .toStream()\n+            .to(output);\n+\n+        testCountHelper(builder, input, output);\n+    }\n+\n+    private static void testCountHelper(final StreamsBuilder builder,\n+                                        final String input,\n+                                        final String output) {\n+        try (\n+            final TopologyTestDriver driver = new TopologyTestDriver(\n+                builder.build(),\n+                mkProperties(mkMap(\n+                    mkEntry(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\"),\n+                    mkEntry(StreamsConfig.APPLICATION_ID_CONFIG, \"test\"),\n+                    mkEntry(StreamsConfig.STATE_DIR_CONFIG, TestUtils.tempDirectory(\"kafka-test\").getAbsolutePath())\n+                )),\n+                Instant.ofEpochMilli(0L))) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, new StringSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n+            final TestOutputTopic<String, Long> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.Long().deserializer());\n+\n+\n+            inputTopic.pipeInput(\"A\", \"green\", 10L);\n+            inputTopic.pipeInput(\"B\", \"green\", 9L);\n+            inputTopic.pipeInput(\"A\", \"blue\", 12L);\n+            inputTopic.pipeInput(\"C\", \"yellow\", 15L);\n+            inputTopic.pipeInput(\"D\", \"green\", 11L);\n+\n+            assertEquals(\n+                asList(\n+                    new TestRecord<>(\"green\", 1L, Instant.ofEpochMilli(10)),\n+                    new TestRecord<>(\"green\", 2L, Instant.ofEpochMilli(10)),\n+                    new TestRecord<>(\"green\", 1L, Instant.ofEpochMilli(12)),\n+                    new TestRecord<>(\"blue\", 1L, Instant.ofEpochMilli(12)),\n+                    new TestRecord<>(\"yellow\", 1L, Instant.ofEpochMilli(15)),\n+                    new TestRecord<>(\"green\", 2L, Instant.ofEpochMilli(12))),\n+                outputTopic.readRecordsToList());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportMapValueTriggerMaterializedWithKTableFromKTStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final String input = \"input\";\n+        final String output = \"output\";\n+        final String storeName = \"store\";\n+\n+        builder.stream(input, consumed)\n+            .toTable()\n+            .mapValues(\n+                value -> value.charAt(0) + 48,\n+                Materialized.<String, Integer, KeyValueStore<Bytes, byte[]>>as(storeName)\n+                    .withKeySerde(Serdes.String())\n+                    .withValueSerde(Serdes.Integer()))\n+            .toStream()\n+            .to(output);\n+\n+        try (\n+            final TopologyTestDriver driver = new TopologyTestDriver(\n+                builder.build(),\n+                mkProperties(mkMap(\n+                    mkEntry(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\"),\n+                    mkEntry(StreamsConfig.APPLICATION_ID_CONFIG, \"test\"),\n+                    mkEntry(StreamsConfig.STATE_DIR_CONFIG, TestUtils.tempDirectory(\"kafka-test\").getAbsolutePath())\n+                )),\n+                Instant.ofEpochMilli(0L))) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, new StringSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n+            final TestOutputTopic<String, Integer> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.Integer().deserializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+            \n+            inputTopic.pipeInput(\"A\", \"green\", 10L);\n+            inputTopic.pipeInput(\"B\", \"green\", 9L);\n+            inputTopic.pipeInput(\"A\", \"blue\", 12L);\n+            inputTopic.pipeInput(\"C\", \"yellow\", 15L);\n+            inputTopic.pipeInput(\"D\", \"green\", 11L);\n+\n+            final Map<String, Integer> expectedStore = new HashMap<>();\n+            expectedStore.putIfAbsent(\"A\", 146);\n+            expectedStore.putIfAbsent(\"B\", 151);\n+            expectedStore.putIfAbsent(\"C\", 169);\n+            expectedStore.putIfAbsent(\"D\", 151);\n+\n+            assertEquals(expectedStore, asMap(store));\n+\n+            assertEquals(\n+                asList(\n+                    new TestRecord<>(\"A\", 151, Instant.ofEpochMilli(10)),\n+                    new TestRecord<>(\"B\", 151, Instant.ofEpochMilli(9)),\n+                    new TestRecord<>(\"A\", 146, Instant.ofEpochMilli(12)),\n+                    new TestRecord<>(\"C\", 169, Instant.ofEpochMilli(15)),\n+                    new TestRecord<>(\"D\", 151, Instant.ofEpochMilli(11))),\n+                outputTopic.readRecordsToList());\n+\n+        }\n+    }\n+\n+    private static Map<String, String> asMap(final KeyValueStore<String, String> store) {\n+        final HashMap<String, String> result = new HashMap<>();\n+        store.all().forEachRemaining(kv -> result.put(kv.key, kv.value));\n+        return result;\n+    }\n+\n+    @Test\n+    public void shouldPropagateRepartitionFlagAfterGlobalKTableJoin() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 511}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMzE3NjM1", "url": "https://github.com/apache/kafka/pull/7985#pullrequestreview-350317635", "createdAt": "2020-01-29T18:10:47Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODoxMDo0N1rOFjSZ3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMjozNzo0M1rOFjZ-xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NjAxNA==", "bodyText": "Why did you remove this test?", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372546014", "createdAt": "2020-01-29T18:10:47Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -1518,26 +1536,6 @@ public void shouldUseRecordMetadataTimestampExtractorWhenInternalRepartitioningT\n         }\n     }\n \n-    @Test\n-    public void shouldPropagateRepartitionFlagAfterGlobalKTableJoin() {\n-        final StreamsBuilder builder = new StreamsBuilder();\n-        final GlobalKTable<String, String> globalKTable = builder.globalTable(\"globalTopic\");\n-        final KeyValueMapper<String, String, String> kvMappper = (k, v) -> k + v;\n-        final ValueJoiner<String, String, String> valueJoiner = (v1, v2) -> v1 + v2;\n-        builder.<String, String>stream(\"topic\").selectKey((k, v) -> v)\n-            .join(globalKTable, kvMappper, valueJoiner)\n-            .groupByKey()\n-            .count();\n-\n-        final Pattern repartitionTopicPattern = Pattern.compile(\"Sink: .*-repartition\");\n-        final String topology = builder.build().describe().toString();\n-        final Matcher matcher = repartitionTopicPattern.matcher(topology);\n-        assertTrue(matcher.find());\n-        final String match = matcher.group();\n-        assertThat(match, notNullValue());\n-        assertTrue(match.endsWith(\"repartition\"));\n-    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU1ODYxMw==", "bodyText": "It would be better to verify the whole TopologyDescription -- as you reuse this method for two different test, you could pass the \"expectedTopology\" String as parameter into this method.\nHowever, reading the test code below, the case for table-table join, for which the right-hand table is updated to trigger a join result is missing (this case only makes sense for table-table join, as for stream-table join the right hand side table updates only update the rhs table, but never trigger a join result). Hence, I think it would be best to not share code but have two test and add the missing case for the table-table join.", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372558613", "createdAt": "2020-01-29T18:35:53Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2328,582 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000003 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000003\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMaterializeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000001\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000001 (stores: [store])\\n\" +\n+                \"      --> none\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportKeyChangeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed)\n+            .map((key, value) -> new KeyValue<>(key + \"-\", value))\n+            .toTable()\n+            .toStream().to(output);\n+\n+        final Topology topology = builder.build();\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-MAP-0000000001\\n\" +\n+                \"    Processor: KSTREAM-MAP-0000000001 (stores: [])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000005\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000005 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-MAP-0000000001\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: KSTREAM-TOTABLE-0000000003-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000005\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000006 (topics: [KSTREAM-TOTABLE-0000000003-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000003 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000006\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000007 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000008 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000007\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B-\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C-\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D-\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldSupportForeignKeyTableTableJoinWithKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> rightTable = builder.stream(input2, consumed).toTable();\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000016 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input1])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000016\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-OUTPUT-0000000018 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007 (stores: [])\\n\" +\n+                \"      --> KTABLE-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000020 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000021\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000021 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000008 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000003 (topics: [input2])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000009 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000005 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000003\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000009\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000015 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012, KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\\n\")\n+        );\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportTableTableJoinWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> table1 = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> table2 = builder.stream(input2, consumed).toTable();\n+\n+        table1.join(table2, MockValueJoiner.TOSTRING_JOINER).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, input1, input2, output);\n+    }\n+\n+    @Test\n+    public void shouldSupportStreamTableJoinWithKStreamToKTable() {\n+        final String streamTopic = \"streamTopic\";\n+        final String tableTopic = \"tableTopic\";\n+        final String output = \"output\";\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final KStream<String, String> stream = builder.stream(streamTopic, consumed);\n+        final KTable<String, String> table =  builder.stream(tableTopic, consumed).toTable();\n+\n+        stream.join(table, MockValueJoiner.TOSTRING_JOINER).to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, streamTopic, tableTopic, output);\n+    }\n+\n+    private void checkJoin(final Topology topology,\n+                           final String leftTopic,\n+                           final String rightTopic,\n+                           final String outputTopic) {\n+        final Collection<Set<String>> copartitionGroups =\n+            TopologyWrapper.getInternalTopologyBuilder(topology).copartitionGroups();\n+\n+        assertEquals(1, copartitionGroups.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 423}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MTQ3NQ==", "bodyText": "This method is only used once -- we should inline the code and remove the method.", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372561475", "createdAt": "2020-01-29T18:41:43Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2328,582 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000003 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000003\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMaterializeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000001\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000001 (stores: [store])\\n\" +\n+                \"      --> none\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportKeyChangeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed)\n+            .map((key, value) -> new KeyValue<>(key + \"-\", value))\n+            .toTable()\n+            .toStream().to(output);\n+\n+        final Topology topology = builder.build();\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-MAP-0000000001\\n\" +\n+                \"    Processor: KSTREAM-MAP-0000000001 (stores: [])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000005\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000005 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-MAP-0000000001\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: KSTREAM-TOTABLE-0000000003-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000005\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000006 (topics: [KSTREAM-TOTABLE-0000000003-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000003 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000006\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000007 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000008 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000007\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B-\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C-\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D-\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldSupportForeignKeyTableTableJoinWithKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> rightTable = builder.stream(input2, consumed).toTable();\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000016 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input1])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000016\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-OUTPUT-0000000018 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007 (stores: [])\\n\" +\n+                \"      --> KTABLE-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000020 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000021\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000021 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000008 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000003 (topics: [input2])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000009 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000005 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000003\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000009\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000015 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012, KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\\n\")\n+        );\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportTableTableJoinWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> table1 = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> table2 = builder.stream(input2, consumed).toTable();\n+\n+        table1.join(table2, MockValueJoiner.TOSTRING_JOINER).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, input1, input2, output);\n+    }\n+\n+    @Test\n+    public void shouldSupportStreamTableJoinWithKStreamToKTable() {\n+        final String streamTopic = \"streamTopic\";\n+        final String tableTopic = \"tableTopic\";\n+        final String output = \"output\";\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final KStream<String, String> stream = builder.stream(streamTopic, consumed);\n+        final KTable<String, String> table =  builder.stream(tableTopic, consumed).toTable();\n+\n+        stream.join(table, MockValueJoiner.TOSTRING_JOINER).to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, streamTopic, tableTopic, output);\n+    }\n+\n+    private void checkJoin(final Topology topology,\n+                           final String leftTopic,\n+                           final String rightTopic,\n+                           final String outputTopic) {\n+        final Collection<Set<String>> copartitionGroups =\n+            TopologyWrapper.getInternalTopologyBuilder(topology).copartitionGroups();\n+\n+        assertEquals(1, copartitionGroups.size());\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(leftTopic, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(rightTopic, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> output = driver.createOutputTopic(outputTopic, new StringDeserializer(), new StringDeserializer());\n+\n+            right.pipeInput(\"lhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"lhs3\", \"rhsValue3\");\n+\n+            assertThat(output.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"lhsValue1+rhsValue1\")\n+            );\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(expected)\n+            );\n+\n+            left.pipeInput(\"lhs3\", \"lhsValue3\");\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"lhsValue3+rhsValue3\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue4\");\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", \"lhsValue4+rhsValue1\")\n+                ))\n+            );\n+\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportGroupByCountWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder\n+            .stream(input, consumed)\n+            .toTable()\n+            .groupBy(MockMapper.selectValueKeyValueMapper(), Grouped.with(Serdes.String(), Serdes.String()))\n+            .count(Materialized.as(\"count\"))\n+            .toStream()\n+            .to(output);\n+\n+        testCountHelper(builder, input, output);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 483}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MzQ5Nw==", "bodyText": "Why do we need this and cannot pass props as in the other tests?", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372563497", "createdAt": "2020-01-29T18:45:36Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2328,582 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000003 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000003\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMaterializeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000001\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000001 (stores: [store])\\n\" +\n+                \"      --> none\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportKeyChangeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed)\n+            .map((key, value) -> new KeyValue<>(key + \"-\", value))\n+            .toTable()\n+            .toStream().to(output);\n+\n+        final Topology topology = builder.build();\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-MAP-0000000001\\n\" +\n+                \"    Processor: KSTREAM-MAP-0000000001 (stores: [])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000005\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000005 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-MAP-0000000001\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: KSTREAM-TOTABLE-0000000003-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000005\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000006 (topics: [KSTREAM-TOTABLE-0000000003-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000003 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000006\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000007 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000008 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000007\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B-\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C-\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D-\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldSupportForeignKeyTableTableJoinWithKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> rightTable = builder.stream(input2, consumed).toTable();\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000016 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input1])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000016\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-OUTPUT-0000000018 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007 (stores: [])\\n\" +\n+                \"      --> KTABLE-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000020 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000021\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000021 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000008 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000003 (topics: [input2])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000009 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000005 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000003\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000009\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000015 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012, KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\\n\")\n+        );\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportTableTableJoinWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> table1 = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> table2 = builder.stream(input2, consumed).toTable();\n+\n+        table1.join(table2, MockValueJoiner.TOSTRING_JOINER).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, input1, input2, output);\n+    }\n+\n+    @Test\n+    public void shouldSupportStreamTableJoinWithKStreamToKTable() {\n+        final String streamTopic = \"streamTopic\";\n+        final String tableTopic = \"tableTopic\";\n+        final String output = \"output\";\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final KStream<String, String> stream = builder.stream(streamTopic, consumed);\n+        final KTable<String, String> table =  builder.stream(tableTopic, consumed).toTable();\n+\n+        stream.join(table, MockValueJoiner.TOSTRING_JOINER).to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, streamTopic, tableTopic, output);\n+    }\n+\n+    private void checkJoin(final Topology topology,\n+                           final String leftTopic,\n+                           final String rightTopic,\n+                           final String outputTopic) {\n+        final Collection<Set<String>> copartitionGroups =\n+            TopologyWrapper.getInternalTopologyBuilder(topology).copartitionGroups();\n+\n+        assertEquals(1, copartitionGroups.size());\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(leftTopic, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(rightTopic, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> output = driver.createOutputTopic(outputTopic, new StringDeserializer(), new StringDeserializer());\n+\n+            right.pipeInput(\"lhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"lhs3\", \"rhsValue3\");\n+\n+            assertThat(output.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"lhsValue1+rhsValue1\")\n+            );\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(expected)\n+            );\n+\n+            left.pipeInput(\"lhs3\", \"lhsValue3\");\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"lhsValue3+rhsValue3\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue4\");\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", \"lhsValue4+rhsValue1\")\n+                ))\n+            );\n+\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportGroupByCountWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder\n+            .stream(input, consumed)\n+            .toTable()\n+            .groupBy(MockMapper.selectValueKeyValueMapper(), Grouped.with(Serdes.String(), Serdes.String()))\n+            .count(Materialized.as(\"count\"))\n+            .toStream()\n+            .to(output);\n+\n+        testCountHelper(builder, input, output);\n+    }\n+\n+    private static void testCountHelper(final StreamsBuilder builder,\n+                                        final String input,\n+                                        final String output) {\n+        try (\n+            final TopologyTestDriver driver = new TopologyTestDriver(\n+                builder.build(),\n+                mkProperties(mkMap(\n+                    mkEntry(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\"),\n+                    mkEntry(StreamsConfig.APPLICATION_ID_CONFIG, \"test\"),\n+                    mkEntry(StreamsConfig.STATE_DIR_CONFIG, TestUtils.tempDirectory(\"kafka-test\").getAbsolutePath())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 495}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2Mzg0OA==", "bodyText": "Why do we need to set wall-clock time?", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372563848", "createdAt": "2020-01-29T18:46:17Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2328,582 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000003 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000003\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMaterializeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000001\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000001 (stores: [store])\\n\" +\n+                \"      --> none\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportKeyChangeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed)\n+            .map((key, value) -> new KeyValue<>(key + \"-\", value))\n+            .toTable()\n+            .toStream().to(output);\n+\n+        final Topology topology = builder.build();\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-MAP-0000000001\\n\" +\n+                \"    Processor: KSTREAM-MAP-0000000001 (stores: [])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000005\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000005 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-MAP-0000000001\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: KSTREAM-TOTABLE-0000000003-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000005\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000006 (topics: [KSTREAM-TOTABLE-0000000003-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000003 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000006\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000007 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000008 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000007\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B-\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C-\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D-\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldSupportForeignKeyTableTableJoinWithKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> rightTable = builder.stream(input2, consumed).toTable();\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000016 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input1])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000016\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-OUTPUT-0000000018 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007 (stores: [])\\n\" +\n+                \"      --> KTABLE-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000020 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000021\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000021 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000008 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000003 (topics: [input2])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000009 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000005 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000003\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000009\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000015 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012, KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\\n\")\n+        );\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportTableTableJoinWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> table1 = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> table2 = builder.stream(input2, consumed).toTable();\n+\n+        table1.join(table2, MockValueJoiner.TOSTRING_JOINER).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, input1, input2, output);\n+    }\n+\n+    @Test\n+    public void shouldSupportStreamTableJoinWithKStreamToKTable() {\n+        final String streamTopic = \"streamTopic\";\n+        final String tableTopic = \"tableTopic\";\n+        final String output = \"output\";\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final KStream<String, String> stream = builder.stream(streamTopic, consumed);\n+        final KTable<String, String> table =  builder.stream(tableTopic, consumed).toTable();\n+\n+        stream.join(table, MockValueJoiner.TOSTRING_JOINER).to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, streamTopic, tableTopic, output);\n+    }\n+\n+    private void checkJoin(final Topology topology,\n+                           final String leftTopic,\n+                           final String rightTopic,\n+                           final String outputTopic) {\n+        final Collection<Set<String>> copartitionGroups =\n+            TopologyWrapper.getInternalTopologyBuilder(topology).copartitionGroups();\n+\n+        assertEquals(1, copartitionGroups.size());\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(leftTopic, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(rightTopic, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> output = driver.createOutputTopic(outputTopic, new StringDeserializer(), new StringDeserializer());\n+\n+            right.pipeInput(\"lhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"lhs3\", \"rhsValue3\");\n+\n+            assertThat(output.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"lhsValue1+rhsValue1\")\n+            );\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(expected)\n+            );\n+\n+            left.pipeInput(\"lhs3\", \"lhsValue3\");\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"lhsValue3+rhsValue3\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue4\");\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", \"lhsValue4+rhsValue1\")\n+                ))\n+            );\n+\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportGroupByCountWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder\n+            .stream(input, consumed)\n+            .toTable()\n+            .groupBy(MockMapper.selectValueKeyValueMapper(), Grouped.with(Serdes.String(), Serdes.String()))\n+            .count(Materialized.as(\"count\"))\n+            .toStream()\n+            .to(output);\n+\n+        testCountHelper(builder, input, output);\n+    }\n+\n+    private static void testCountHelper(final StreamsBuilder builder,\n+                                        final String input,\n+                                        final String output) {\n+        try (\n+            final TopologyTestDriver driver = new TopologyTestDriver(\n+                builder.build(),\n+                mkProperties(mkMap(\n+                    mkEntry(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\"),\n+                    mkEntry(StreamsConfig.APPLICATION_ID_CONFIG, \"test\"),\n+                    mkEntry(StreamsConfig.STATE_DIR_CONFIG, TestUtils.tempDirectory(\"kafka-test\").getAbsolutePath())\n+                )),\n+                Instant.ofEpochMilli(0L))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 497}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NDg2NA==", "bodyText": "If you use the default props instead of creating a custom one, we don't need to pass in string serdes here. (cf. my comment below)", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372564864", "createdAt": "2020-01-29T18:48:19Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2328,582 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000003 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000003\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMaterializeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000001\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000001 (stores: [store])\\n\" +\n+                \"      --> none\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportKeyChangeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed)\n+            .map((key, value) -> new KeyValue<>(key + \"-\", value))\n+            .toTable()\n+            .toStream().to(output);\n+\n+        final Topology topology = builder.build();\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-MAP-0000000001\\n\" +\n+                \"    Processor: KSTREAM-MAP-0000000001 (stores: [])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000005\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000005 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-MAP-0000000001\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: KSTREAM-TOTABLE-0000000003-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000005\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000006 (topics: [KSTREAM-TOTABLE-0000000003-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000003 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000006\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000007 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000008 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000007\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B-\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C-\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D-\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldSupportForeignKeyTableTableJoinWithKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> rightTable = builder.stream(input2, consumed).toTable();\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000016 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input1])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000016\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-OUTPUT-0000000018 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007 (stores: [])\\n\" +\n+                \"      --> KTABLE-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000020 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000021\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000021 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000008 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000003 (topics: [input2])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000009 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000005 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000003\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000009\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000015 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012, KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\\n\")\n+        );\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportTableTableJoinWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> table1 = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> table2 = builder.stream(input2, consumed).toTable();\n+\n+        table1.join(table2, MockValueJoiner.TOSTRING_JOINER).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, input1, input2, output);\n+    }\n+\n+    @Test\n+    public void shouldSupportStreamTableJoinWithKStreamToKTable() {\n+        final String streamTopic = \"streamTopic\";\n+        final String tableTopic = \"tableTopic\";\n+        final String output = \"output\";\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final KStream<String, String> stream = builder.stream(streamTopic, consumed);\n+        final KTable<String, String> table =  builder.stream(tableTopic, consumed).toTable();\n+\n+        stream.join(table, MockValueJoiner.TOSTRING_JOINER).to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, streamTopic, tableTopic, output);\n+    }\n+\n+    private void checkJoin(final Topology topology,\n+                           final String leftTopic,\n+                           final String rightTopic,\n+                           final String outputTopic) {\n+        final Collection<Set<String>> copartitionGroups =\n+            TopologyWrapper.getInternalTopologyBuilder(topology).copartitionGroups();\n+\n+        assertEquals(1, copartitionGroups.size());\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(leftTopic, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(rightTopic, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> output = driver.createOutputTopic(outputTopic, new StringDeserializer(), new StringDeserializer());\n+\n+            right.pipeInput(\"lhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"lhs3\", \"rhsValue3\");\n+\n+            assertThat(output.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"lhsValue1+rhsValue1\")\n+            );\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(expected)\n+            );\n+\n+            left.pipeInput(\"lhs3\", \"lhsValue3\");\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"lhsValue3+rhsValue3\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue4\");\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", \"lhsValue4+rhsValue1\")\n+                ))\n+            );\n+\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportGroupByCountWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder\n+            .stream(input, consumed)\n+            .toTable()\n+            .groupBy(MockMapper.selectValueKeyValueMapper(), Grouped.with(Serdes.String(), Serdes.String()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 478}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NTI2OQ==", "bodyText": "Why do we need to pass in the store name? -- Or to rephrase: does it make a difference if we pass in a store name or not? If yes, should we have a test for each case?", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372565269", "createdAt": "2020-01-29T18:49:08Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2328,582 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000003 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000003\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMaterializeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000001\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000001 (stores: [store])\\n\" +\n+                \"      --> none\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportKeyChangeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed)\n+            .map((key, value) -> new KeyValue<>(key + \"-\", value))\n+            .toTable()\n+            .toStream().to(output);\n+\n+        final Topology topology = builder.build();\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-MAP-0000000001\\n\" +\n+                \"    Processor: KSTREAM-MAP-0000000001 (stores: [])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000005\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000005 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-MAP-0000000001\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: KSTREAM-TOTABLE-0000000003-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000005\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000006 (topics: [KSTREAM-TOTABLE-0000000003-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000003 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000006\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000007 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000008 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000007\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B-\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C-\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D-\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldSupportForeignKeyTableTableJoinWithKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> rightTable = builder.stream(input2, consumed).toTable();\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000016 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input1])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000016\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-OUTPUT-0000000018 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007 (stores: [])\\n\" +\n+                \"      --> KTABLE-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000020 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000021\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000021 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000008 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000003 (topics: [input2])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000009 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000005 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000003\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000009\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000015 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012, KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\\n\")\n+        );\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportTableTableJoinWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> table1 = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> table2 = builder.stream(input2, consumed).toTable();\n+\n+        table1.join(table2, MockValueJoiner.TOSTRING_JOINER).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, input1, input2, output);\n+    }\n+\n+    @Test\n+    public void shouldSupportStreamTableJoinWithKStreamToKTable() {\n+        final String streamTopic = \"streamTopic\";\n+        final String tableTopic = \"tableTopic\";\n+        final String output = \"output\";\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final KStream<String, String> stream = builder.stream(streamTopic, consumed);\n+        final KTable<String, String> table =  builder.stream(tableTopic, consumed).toTable();\n+\n+        stream.join(table, MockValueJoiner.TOSTRING_JOINER).to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, streamTopic, tableTopic, output);\n+    }\n+\n+    private void checkJoin(final Topology topology,\n+                           final String leftTopic,\n+                           final String rightTopic,\n+                           final String outputTopic) {\n+        final Collection<Set<String>> copartitionGroups =\n+            TopologyWrapper.getInternalTopologyBuilder(topology).copartitionGroups();\n+\n+        assertEquals(1, copartitionGroups.size());\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(leftTopic, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(rightTopic, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> output = driver.createOutputTopic(outputTopic, new StringDeserializer(), new StringDeserializer());\n+\n+            right.pipeInput(\"lhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"lhs3\", \"rhsValue3\");\n+\n+            assertThat(output.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"lhsValue1+rhsValue1\")\n+            );\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(expected)\n+            );\n+\n+            left.pipeInput(\"lhs3\", \"lhsValue3\");\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"lhsValue3+rhsValue3\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue4\");\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", \"lhsValue4+rhsValue1\")\n+                ))\n+            );\n+\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportGroupByCountWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder\n+            .stream(input, consumed)\n+            .toTable()\n+            .groupBy(MockMapper.selectValueKeyValueMapper(), Grouped.with(Serdes.String(), Serdes.String()))\n+            .count(Materialized.as(\"count\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 479}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NTU5OA==", "bodyText": "As for all tests, we should verify topologyDescription", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372565598", "createdAt": "2020-01-29T18:49:45Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2328,582 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000003 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000003\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMaterializeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000001\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000001 (stores: [store])\\n\" +\n+                \"      --> none\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportKeyChangeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed)\n+            .map((key, value) -> new KeyValue<>(key + \"-\", value))\n+            .toTable()\n+            .toStream().to(output);\n+\n+        final Topology topology = builder.build();\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-MAP-0000000001\\n\" +\n+                \"    Processor: KSTREAM-MAP-0000000001 (stores: [])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000005\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000005 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-MAP-0000000001\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: KSTREAM-TOTABLE-0000000003-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000005\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000006 (topics: [KSTREAM-TOTABLE-0000000003-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000003 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000006\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000007 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000008 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000007\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B-\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C-\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D-\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldSupportForeignKeyTableTableJoinWithKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> rightTable = builder.stream(input2, consumed).toTable();\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000016 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input1])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000016\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-OUTPUT-0000000018 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007 (stores: [])\\n\" +\n+                \"      --> KTABLE-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000020 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000021\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000021 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000008 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000003 (topics: [input2])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000009 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000005 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000003\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000009\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000015 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012, KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\\n\")\n+        );\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportTableTableJoinWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> table1 = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> table2 = builder.stream(input2, consumed).toTable();\n+\n+        table1.join(table2, MockValueJoiner.TOSTRING_JOINER).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, input1, input2, output);\n+    }\n+\n+    @Test\n+    public void shouldSupportStreamTableJoinWithKStreamToKTable() {\n+        final String streamTopic = \"streamTopic\";\n+        final String tableTopic = \"tableTopic\";\n+        final String output = \"output\";\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final KStream<String, String> stream = builder.stream(streamTopic, consumed);\n+        final KTable<String, String> table =  builder.stream(tableTopic, consumed).toTable();\n+\n+        stream.join(table, MockValueJoiner.TOSTRING_JOINER).to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, streamTopic, tableTopic, output);\n+    }\n+\n+    private void checkJoin(final Topology topology,\n+                           final String leftTopic,\n+                           final String rightTopic,\n+                           final String outputTopic) {\n+        final Collection<Set<String>> copartitionGroups =\n+            TopologyWrapper.getInternalTopologyBuilder(topology).copartitionGroups();\n+\n+        assertEquals(1, copartitionGroups.size());\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(leftTopic, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(rightTopic, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> output = driver.createOutputTopic(outputTopic, new StringDeserializer(), new StringDeserializer());\n+\n+            right.pipeInput(\"lhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"lhs3\", \"rhsValue3\");\n+\n+            assertThat(output.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"lhsValue1+rhsValue1\")\n+            );\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(expected)\n+            );\n+\n+            left.pipeInput(\"lhs3\", \"lhsValue3\");\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"lhsValue3+rhsValue3\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue4\");\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", \"lhsValue4+rhsValue1\")\n+                ))\n+            );\n+\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportGroupByCountWithKStreamToKTable() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 469}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU3MDMwOQ==", "bodyText": "This first three sub-topologies are weird -- I guess it's because you don't create a new StreamsBuilder object but reuses the predefined one -- this make the test somewhat confusing. Would be better to create a new StreamsBuilder as in the other tests to get rid of them.", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372570309", "createdAt": "2020-01-29T18:58:40Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2328,582 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000003 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000003\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMaterializeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000001\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000001 (stores: [store])\\n\" +\n+                \"      --> none\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportKeyChangeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed)\n+            .map((key, value) -> new KeyValue<>(key + \"-\", value))\n+            .toTable()\n+            .toStream().to(output);\n+\n+        final Topology topology = builder.build();\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-MAP-0000000001\\n\" +\n+                \"    Processor: KSTREAM-MAP-0000000001 (stores: [])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000005\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000005 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-MAP-0000000001\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: KSTREAM-TOTABLE-0000000003-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000005\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000006 (topics: [KSTREAM-TOTABLE-0000000003-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000003 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000006\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000007 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000008 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000007\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B-\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C-\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D-\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldSupportForeignKeyTableTableJoinWithKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> rightTable = builder.stream(input2, consumed).toTable();\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000016 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input1])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000016\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-OUTPUT-0000000018 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007 (stores: [])\\n\" +\n+                \"      --> KTABLE-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000020 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000021\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000021 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000008 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000003 (topics: [input2])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000009 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000005 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000003\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000009\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000015 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012, KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\\n\")\n+        );\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportTableTableJoinWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> table1 = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> table2 = builder.stream(input2, consumed).toTable();\n+\n+        table1.join(table2, MockValueJoiner.TOSTRING_JOINER).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, input1, input2, output);\n+    }\n+\n+    @Test\n+    public void shouldSupportStreamTableJoinWithKStreamToKTable() {\n+        final String streamTopic = \"streamTopic\";\n+        final String tableTopic = \"tableTopic\";\n+        final String output = \"output\";\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final KStream<String, String> stream = builder.stream(streamTopic, consumed);\n+        final KTable<String, String> table =  builder.stream(tableTopic, consumed).toTable();\n+\n+        stream.join(table, MockValueJoiner.TOSTRING_JOINER).to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, streamTopic, tableTopic, output);\n+    }\n+\n+    private void checkJoin(final Topology topology,\n+                           final String leftTopic,\n+                           final String rightTopic,\n+                           final String outputTopic) {\n+        final Collection<Set<String>> copartitionGroups =\n+            TopologyWrapper.getInternalTopologyBuilder(topology).copartitionGroups();\n+\n+        assertEquals(1, copartitionGroups.size());\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(leftTopic, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(rightTopic, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> output = driver.createOutputTopic(outputTopic, new StringDeserializer(), new StringDeserializer());\n+\n+            right.pipeInput(\"lhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"lhs3\", \"rhsValue3\");\n+\n+            assertThat(output.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"lhsValue1+rhsValue1\")\n+            );\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(expected)\n+            );\n+\n+            left.pipeInput(\"lhs3\", \"lhsValue3\");\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"lhsValue3+rhsValue3\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue4\");\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", \"lhsValue4+rhsValue1\")\n+                ))\n+            );\n+\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportGroupByCountWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder\n+            .stream(input, consumed)\n+            .toTable()\n+            .groupBy(MockMapper.selectValueKeyValueMapper(), Grouped.with(Serdes.String(), Serdes.String()))\n+            .count(Materialized.as(\"count\"))\n+            .toStream()\n+            .to(output);\n+\n+        testCountHelper(builder, input, output);\n+    }\n+\n+    private static void testCountHelper(final StreamsBuilder builder,\n+                                        final String input,\n+                                        final String output) {\n+        try (\n+            final TopologyTestDriver driver = new TopologyTestDriver(\n+                builder.build(),\n+                mkProperties(mkMap(\n+                    mkEntry(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\"),\n+                    mkEntry(StreamsConfig.APPLICATION_ID_CONFIG, \"test\"),\n+                    mkEntry(StreamsConfig.STATE_DIR_CONFIG, TestUtils.tempDirectory(\"kafka-test\").getAbsolutePath())\n+                )),\n+                Instant.ofEpochMilli(0L))) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, new StringSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n+            final TestOutputTopic<String, Long> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.Long().deserializer());\n+\n+\n+            inputTopic.pipeInput(\"A\", \"green\", 10L);\n+            inputTopic.pipeInput(\"B\", \"green\", 9L);\n+            inputTopic.pipeInput(\"A\", \"blue\", 12L);\n+            inputTopic.pipeInput(\"C\", \"yellow\", 15L);\n+            inputTopic.pipeInput(\"D\", \"green\", 11L);\n+\n+            assertEquals(\n+                asList(\n+                    new TestRecord<>(\"green\", 1L, Instant.ofEpochMilli(10)),\n+                    new TestRecord<>(\"green\", 2L, Instant.ofEpochMilli(10)),\n+                    new TestRecord<>(\"green\", 1L, Instant.ofEpochMilli(12)),\n+                    new TestRecord<>(\"blue\", 1L, Instant.ofEpochMilli(12)),\n+                    new TestRecord<>(\"yellow\", 1L, Instant.ofEpochMilli(15)),\n+                    new TestRecord<>(\"green\", 2L, Instant.ofEpochMilli(12))),\n+                outputTopic.readRecordsToList());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportMapValueTriggerMaterializedWithKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final String input = \"input\";\n+        final String output = \"output\";\n+        final String storeName = \"store\";\n+\n+        builder.stream(input, consumed)\n+            .toTable()\n+            .mapValues(\n+                value -> value.charAt(0) - (int) 'a',\n+                Materialized.<String, Integer, KeyValueStore<Bytes, byte[]>>as(storeName)\n+                    .withKeySerde(Serdes.String())\n+                    .withValueSerde(Serdes.Integer()))\n+            .toStream()\n+            .to(output);\n+\n+        final Topology topology = builder.build(props);\n+        final String topologyDescription = topology.describe().toString();\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [source])\\n\" +\n+                \"      --> none\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000002 (topics: [topic])\\n\" +\n+                \"      --> KTABLE-SOURCE-0000000003\\n\" +\n+                \"    Processor: KTABLE-SOURCE-0000000003 (stores: [])\\n\" +\n+                \"      --> none\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000002\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 2 for global store (will not generate tasks)\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000005 (topics: [global])\\n\" +\n+                \"      --> KTABLE-SOURCE-0000000006\\n\" +\n+                \"    Processor: KTABLE-SOURCE-0000000006 (stores: [global-STATE-STORE-0000000004])\\n\" +\n+                \"      --> none\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000005\\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 560}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU3MTAwMQ==", "bodyText": "Should have add a test for which we don't force a materialization to verify that mapValues() itself does not trigger it?", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372571001", "createdAt": "2020-01-29T19:00:06Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2328,582 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000003 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000003\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMaterializeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000001\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000001 (stores: [store])\\n\" +\n+                \"      --> none\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportKeyChangeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed)\n+            .map((key, value) -> new KeyValue<>(key + \"-\", value))\n+            .toTable()\n+            .toStream().to(output);\n+\n+        final Topology topology = builder.build();\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-MAP-0000000001\\n\" +\n+                \"    Processor: KSTREAM-MAP-0000000001 (stores: [])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000005\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000005 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-MAP-0000000001\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: KSTREAM-TOTABLE-0000000003-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000005\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000006 (topics: [KSTREAM-TOTABLE-0000000003-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000003 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000006\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000007 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000008 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000007\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B-\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C-\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D-\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldSupportForeignKeyTableTableJoinWithKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> rightTable = builder.stream(input2, consumed).toTable();\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000016 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input1])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000016\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-OUTPUT-0000000018 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007 (stores: [])\\n\" +\n+                \"      --> KTABLE-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000020 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000021\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000021 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000008 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000003 (topics: [input2])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000009 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000005 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000003\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000009\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000015 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012, KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\\n\")\n+        );\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportTableTableJoinWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> table1 = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> table2 = builder.stream(input2, consumed).toTable();\n+\n+        table1.join(table2, MockValueJoiner.TOSTRING_JOINER).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, input1, input2, output);\n+    }\n+\n+    @Test\n+    public void shouldSupportStreamTableJoinWithKStreamToKTable() {\n+        final String streamTopic = \"streamTopic\";\n+        final String tableTopic = \"tableTopic\";\n+        final String output = \"output\";\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final KStream<String, String> stream = builder.stream(streamTopic, consumed);\n+        final KTable<String, String> table =  builder.stream(tableTopic, consumed).toTable();\n+\n+        stream.join(table, MockValueJoiner.TOSTRING_JOINER).to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, streamTopic, tableTopic, output);\n+    }\n+\n+    private void checkJoin(final Topology topology,\n+                           final String leftTopic,\n+                           final String rightTopic,\n+                           final String outputTopic) {\n+        final Collection<Set<String>> copartitionGroups =\n+            TopologyWrapper.getInternalTopologyBuilder(topology).copartitionGroups();\n+\n+        assertEquals(1, copartitionGroups.size());\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(leftTopic, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(rightTopic, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> output = driver.createOutputTopic(outputTopic, new StringDeserializer(), new StringDeserializer());\n+\n+            right.pipeInput(\"lhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"lhs3\", \"rhsValue3\");\n+\n+            assertThat(output.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"lhsValue1+rhsValue1\")\n+            );\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(expected)\n+            );\n+\n+            left.pipeInput(\"lhs3\", \"lhsValue3\");\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"lhsValue3+rhsValue3\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue4\");\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", \"lhsValue4+rhsValue1\")\n+                ))\n+            );\n+\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportGroupByCountWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder\n+            .stream(input, consumed)\n+            .toTable()\n+            .groupBy(MockMapper.selectValueKeyValueMapper(), Grouped.with(Serdes.String(), Serdes.String()))\n+            .count(Materialized.as(\"count\"))\n+            .toStream()\n+            .to(output);\n+\n+        testCountHelper(builder, input, output);\n+    }\n+\n+    private static void testCountHelper(final StreamsBuilder builder,\n+                                        final String input,\n+                                        final String output) {\n+        try (\n+            final TopologyTestDriver driver = new TopologyTestDriver(\n+                builder.build(),\n+                mkProperties(mkMap(\n+                    mkEntry(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\"),\n+                    mkEntry(StreamsConfig.APPLICATION_ID_CONFIG, \"test\"),\n+                    mkEntry(StreamsConfig.STATE_DIR_CONFIG, TestUtils.tempDirectory(\"kafka-test\").getAbsolutePath())\n+                )),\n+                Instant.ofEpochMilli(0L))) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, new StringSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n+            final TestOutputTopic<String, Long> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.Long().deserializer());\n+\n+\n+            inputTopic.pipeInput(\"A\", \"green\", 10L);\n+            inputTopic.pipeInput(\"B\", \"green\", 9L);\n+            inputTopic.pipeInput(\"A\", \"blue\", 12L);\n+            inputTopic.pipeInput(\"C\", \"yellow\", 15L);\n+            inputTopic.pipeInput(\"D\", \"green\", 11L);\n+\n+            assertEquals(\n+                asList(\n+                    new TestRecord<>(\"green\", 1L, Instant.ofEpochMilli(10)),\n+                    new TestRecord<>(\"green\", 2L, Instant.ofEpochMilli(10)),\n+                    new TestRecord<>(\"green\", 1L, Instant.ofEpochMilli(12)),\n+                    new TestRecord<>(\"blue\", 1L, Instant.ofEpochMilli(12)),\n+                    new TestRecord<>(\"yellow\", 1L, Instant.ofEpochMilli(15)),\n+                    new TestRecord<>(\"green\", 2L, Instant.ofEpochMilli(12))),\n+                outputTopic.readRecordsToList());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportMapValueTriggerMaterializedWithKTableFromKStream() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 523}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2MzI5MA==", "bodyText": "The name of this test does not match what we expect to happen. We have a map().toTable() that will repartition the data, and we have a selectKey().join() that will also repartition directly.\nNote that in the existing test (that you removed above) shouldPropagateRepartitionFlagAfterGlobalKTableJoin a global-ktable is used -- for that case, repartitioning should happen after the join -- however, when we use a regular KTable that is created via toTable() repartitioning must happen before the join (and the topology descriptions shows that both repartitionings happens correctly before the join).\nOverall, I have the impression that this test is redundant?", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372663290", "createdAt": "2020-01-29T22:20:46Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamImplTest.java", "diffHunk": "@@ -2330,4 +2328,582 @@ public void shouldNotAllowNullNamedOnProcessWithStores() {\n         assertThat(exception.getMessage(), equalTo(\"named can't be null\"));\n     }\n \n+\n+    @Test\n+    public void shouldNotMaterializedKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed).toTable().toStream().to(output);\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000003\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000003 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000003\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldMaterializeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String storeName = \"store\";\n+\n+        final String input = \"input\";\n+        builder.stream(input, consumed)\n+            .toTable(Materialized.as(Stores.inMemoryKeyValueStore(storeName)));\n+\n+        final String topologyDescription = builder.build().describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000001\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000001 (stores: [store])\\n\" +\n+                \"      --> none\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(builder.build(), props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+\n+            inputTopic.pipeInput(\"A\", \"01\");\n+            final Map<String, String> expectedStore = mkMap(mkEntry(\"A\", \"01\"));\n+\n+            assertThat(asMap(store), is(expectedStore));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportKeyChangeKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder.stream(input, consumed)\n+            .map((key, value) -> new KeyValue<>(key + \"-\", value))\n+            .toTable()\n+            .toStream().to(output);\n+\n+        final Topology topology = builder.build();\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-MAP-0000000001\\n\" +\n+                \"    Processor: KSTREAM-MAP-0000000001 (stores: [])\\n\" +\n+                \"      --> KSTREAM-FILTER-0000000005\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KSTREAM-FILTER-0000000005 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000004\\n\" +\n+                \"      <-- KSTREAM-MAP-0000000001\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000004 (topic: KSTREAM-TOTABLE-0000000003-repartition)\\n\" +\n+                \"      <-- KSTREAM-FILTER-0000000005\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000006 (topics: [KSTREAM-TOTABLE-0000000003-repartition])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000003 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000006\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000007 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000003\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000008 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000007\\n\\n\")\n+        );\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, Serdes.String().serializer(), Serdes.String().serializer());\n+            final TestOutputTopic<String, String> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.String().deserializer());\n+\n+            inputTopic.pipeInput(\"A\", \"01\", 5L);\n+            inputTopic.pipeInput(\"B\", \"02\", 100L);\n+            inputTopic.pipeInput(\"C\", \"03\", 0L);\n+            inputTopic.pipeInput(\"D\", \"04\", 0L);\n+            inputTopic.pipeInput(\"A\", \"05\", 10L);\n+            inputTopic.pipeInput(\"A\", \"06\", 8L);\n+\n+            final List<TestRecord<String, String>> outputExpectRecords = new ArrayList<>();\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"01\", Instant.ofEpochMilli(5L)));\n+            outputExpectRecords.add(new TestRecord<>(\"B-\", \"02\", Instant.ofEpochMilli(100L)));\n+            outputExpectRecords.add(new TestRecord<>(\"C-\", \"03\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"D-\", \"04\", Instant.ofEpochMilli(0L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"05\", Instant.ofEpochMilli(10L)));\n+            outputExpectRecords.add(new TestRecord<>(\"A-\", \"06\", Instant.ofEpochMilli(8L)));\n+\n+            assertEquals(outputTopic.readRecordsToList(), outputExpectRecords);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldSupportForeignKeyTableTableJoinWithKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> leftTable = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> rightTable = builder.stream(input2, consumed).toTable();\n+\n+        final Function<String, String> extractor = value -> value.split(\"\\\\|\")[1];\n+        final ValueJoiner<String, String, String> joiner = (value1, value2) -> \"(\" + value1 + \",\" + value2 + \")\";\n+\n+        leftTable.join(rightTable, extractor, joiner).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+\n+        final String topologyDescription = topology.describe().toString();\n+\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000016 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [input1])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000016\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000002 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000001])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000000\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-OUTPUT-0000000018 (stores: [])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-RESOLVER-PROCESSOR-0000000017\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007 (stores: [])\\n\" +\n+                \"      --> KTABLE-SINK-0000000008\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000002\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000020 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000021\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-OUTPUT-0000000018\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000021 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000020\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000008 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000007\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000003 (topics: [input2])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Source: KTABLE-SOURCE-0000000009 (topics: [KTABLE-FK-JOIN-SUBSCRIPTION-REGISTRATION-0000000006-topic])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000005 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000003\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012\\n\" +\n+                \"      <-- KTABLE-SOURCE-0000000009\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012 (stores: [KSTREAM-TOTABLE-STATE-STORE-0000000004])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000011\\n\" +\n+                \"    Processor: KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013 (stores: [KTABLE-FK-JOIN-SUBSCRIPTION-STATE-STORE-0000000010])\\n\" +\n+                \"      --> KTABLE-SINK-0000000015\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000005\\n\" +\n+                \"    Sink: KTABLE-SINK-0000000015 (topic: KTABLE-FK-JOIN-SUBSCRIPTION-RESPONSE-0000000014-topic)\\n\" +\n+                \"      <-- KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000012, KTABLE-FK-JOIN-SUBSCRIPTION-PROCESSOR-0000000013\\n\\n\")\n+        );\n+\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(input1, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(input2, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> outputTopic = driver.createOutputTopic(output, new StringDeserializer(), new StringDeserializer());\n+\n+            // Pre-populate the RHS records. This test is all about what happens when we add/remove LHS records\n+            right.pipeInput(\"rhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"rhs3\", \"rhsValue3\"); // this unreferenced FK won't show up in any results\n+\n+            assertThat(outputTopic.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1|rhs1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2|rhs2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"(lhsValue1|rhs1,rhsValue1)\"),\n+                mkEntry(\"lhs2\", \"(lhsValue2|rhs2,rhsValue2)\")\n+            );\n+            assertThat(outputTopic.readKeyValuesToMap(), is(expected));\n+\n+            // Add another reference to an existing FK\n+            left.pipeInput(\"lhs3\", \"lhsValue3|rhs1\");\n+\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"(lhsValue3|rhs1,rhsValue1)\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", (String) null);\n+            assertThat(\n+                outputTopic.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", null)\n+                ))\n+            );\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportTableTableJoinWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        final String input1 = \"input1\";\n+        final String input2 = \"input2\";\n+        final String output = \"output\";\n+\n+        final KTable<String, String> table1 = builder.stream(input1, consumed).toTable();\n+        final KTable<String, String> table2 = builder.stream(input2, consumed).toTable();\n+\n+        table1.join(table2, MockValueJoiner.TOSTRING_JOINER).toStream().to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, input1, input2, output);\n+    }\n+\n+    @Test\n+    public void shouldSupportStreamTableJoinWithKStreamToKTable() {\n+        final String streamTopic = \"streamTopic\";\n+        final String tableTopic = \"tableTopic\";\n+        final String output = \"output\";\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+\n+        final KStream<String, String> stream = builder.stream(streamTopic, consumed);\n+        final KTable<String, String> table =  builder.stream(tableTopic, consumed).toTable();\n+\n+        stream.join(table, MockValueJoiner.TOSTRING_JOINER).to(output);\n+\n+        final Topology topology = builder.build(props);\n+        checkJoin(topology, streamTopic, tableTopic, output);\n+    }\n+\n+    private void checkJoin(final Topology topology,\n+                           final String leftTopic,\n+                           final String rightTopic,\n+                           final String outputTopic) {\n+        final Collection<Set<String>> copartitionGroups =\n+            TopologyWrapper.getInternalTopologyBuilder(topology).copartitionGroups();\n+\n+        assertEquals(1, copartitionGroups.size());\n+\n+        try (final TopologyTestDriver driver = new TopologyTestDriver(topology, props)) {\n+            final TestInputTopic<String, String> left = driver.createInputTopic(leftTopic, new StringSerializer(), new StringSerializer());\n+            final TestInputTopic<String, String> right = driver.createInputTopic(rightTopic, new StringSerializer(), new StringSerializer());\n+            final TestOutputTopic<String, String> output = driver.createOutputTopic(outputTopic, new StringDeserializer(), new StringDeserializer());\n+\n+            right.pipeInput(\"lhs1\", \"rhsValue1\");\n+            right.pipeInput(\"rhs2\", \"rhsValue2\");\n+            right.pipeInput(\"lhs3\", \"rhsValue3\");\n+\n+            assertThat(output.readKeyValuesToMap(), is(emptyMap()));\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue1\");\n+            left.pipeInput(\"lhs2\", \"lhsValue2\");\n+\n+            final Map<String, String> expected = mkMap(\n+                mkEntry(\"lhs1\", \"lhsValue1+rhsValue1\")\n+            );\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(expected)\n+            );\n+\n+            left.pipeInput(\"lhs3\", \"lhsValue3\");\n+\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs3\", \"lhsValue3+rhsValue3\")\n+                ))\n+            );\n+\n+            left.pipeInput(\"lhs1\", \"lhsValue4\");\n+            assertThat(\n+                output.readKeyValuesToMap(),\n+                is(mkMap(\n+                    mkEntry(\"lhs1\", \"lhsValue4+rhsValue1\")\n+                ))\n+            );\n+\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportGroupByCountWithKStreamToKTable() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final StreamsBuilder builder = new StreamsBuilder();\n+        final String input = \"input\";\n+        final String output = \"output\";\n+\n+        builder\n+            .stream(input, consumed)\n+            .toTable()\n+            .groupBy(MockMapper.selectValueKeyValueMapper(), Grouped.with(Serdes.String(), Serdes.String()))\n+            .count(Materialized.as(\"count\"))\n+            .toStream()\n+            .to(output);\n+\n+        testCountHelper(builder, input, output);\n+    }\n+\n+    private static void testCountHelper(final StreamsBuilder builder,\n+                                        final String input,\n+                                        final String output) {\n+        try (\n+            final TopologyTestDriver driver = new TopologyTestDriver(\n+                builder.build(),\n+                mkProperties(mkMap(\n+                    mkEntry(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\"),\n+                    mkEntry(StreamsConfig.APPLICATION_ID_CONFIG, \"test\"),\n+                    mkEntry(StreamsConfig.STATE_DIR_CONFIG, TestUtils.tempDirectory(\"kafka-test\").getAbsolutePath())\n+                )),\n+                Instant.ofEpochMilli(0L))) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, new StringSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n+            final TestOutputTopic<String, Long> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.Long().deserializer());\n+\n+\n+            inputTopic.pipeInput(\"A\", \"green\", 10L);\n+            inputTopic.pipeInput(\"B\", \"green\", 9L);\n+            inputTopic.pipeInput(\"A\", \"blue\", 12L);\n+            inputTopic.pipeInput(\"C\", \"yellow\", 15L);\n+            inputTopic.pipeInput(\"D\", \"green\", 11L);\n+\n+            assertEquals(\n+                asList(\n+                    new TestRecord<>(\"green\", 1L, Instant.ofEpochMilli(10)),\n+                    new TestRecord<>(\"green\", 2L, Instant.ofEpochMilli(10)),\n+                    new TestRecord<>(\"green\", 1L, Instant.ofEpochMilli(12)),\n+                    new TestRecord<>(\"blue\", 1L, Instant.ofEpochMilli(12)),\n+                    new TestRecord<>(\"yellow\", 1L, Instant.ofEpochMilli(15)),\n+                    new TestRecord<>(\"green\", 2L, Instant.ofEpochMilli(12))),\n+                outputTopic.readRecordsToList());\n+        }\n+    }\n+\n+    @Test\n+    public void shouldSupportMapValueTriggerMaterializedWithKTableFromKStream() {\n+        final Consumed<String, String> consumed = Consumed.with(Serdes.String(), Serdes.String());\n+        final String input = \"input\";\n+        final String output = \"output\";\n+        final String storeName = \"store\";\n+\n+        builder.stream(input, consumed)\n+            .toTable()\n+            .mapValues(\n+                value -> value.charAt(0) - (int) 'a',\n+                Materialized.<String, Integer, KeyValueStore<Bytes, byte[]>>as(storeName)\n+                    .withKeySerde(Serdes.String())\n+                    .withValueSerde(Serdes.Integer()))\n+            .toStream()\n+            .to(output);\n+\n+        final Topology topology = builder.build(props);\n+        final String topologyDescription = topology.describe().toString();\n+        assertThat(\n+            topologyDescription,\n+            equalTo(\"Topologies:\\n\" +\n+                \"   Sub-topology: 0\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000000 (topics: [source])\\n\" +\n+                \"      --> none\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 1\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000002 (topics: [topic])\\n\" +\n+                \"      --> KTABLE-SOURCE-0000000003\\n\" +\n+                \"    Processor: KTABLE-SOURCE-0000000003 (stores: [])\\n\" +\n+                \"      --> none\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000002\\n\" +\n+                \"\\n\" +\n+                \"  Sub-topology: 2 for global store (will not generate tasks)\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000005 (topics: [global])\\n\" +\n+                \"      --> KTABLE-SOURCE-0000000006\\n\" +\n+                \"    Processor: KTABLE-SOURCE-0000000006 (stores: [global-STATE-STORE-0000000004])\\n\" +\n+                \"      --> none\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000005\\n\" +\n+                \"  Sub-topology: 3\\n\" +\n+                \"    Source: KSTREAM-SOURCE-0000000007 (topics: [input])\\n\" +\n+                \"      --> KSTREAM-TOTABLE-0000000009\\n\" +\n+                \"    Processor: KSTREAM-TOTABLE-0000000009 (stores: [])\\n\" +\n+                \"      --> KTABLE-MAPVALUES-0000000010\\n\" +\n+                \"      <-- KSTREAM-SOURCE-0000000007\\n\" +\n+                \"    Processor: KTABLE-MAPVALUES-0000000010 (stores: [store])\\n\" +\n+                \"      --> KTABLE-TOSTREAM-0000000011\\n\" +\n+                \"      <-- KSTREAM-TOTABLE-0000000009\\n\" +\n+                \"    Processor: KTABLE-TOSTREAM-0000000011 (stores: [])\\n\" +\n+                \"      --> KSTREAM-SINK-0000000012\\n\" +\n+                \"      <-- KTABLE-MAPVALUES-0000000010\\n\" +\n+                \"    Sink: KSTREAM-SINK-0000000012 (topic: output)\\n\" +\n+                \"      <-- KTABLE-TOSTREAM-0000000011\\n\\n\"));\n+\n+        try (\n+            final TopologyTestDriver driver = new TopologyTestDriver(\n+                topology,\n+                mkProperties(mkMap(\n+                    mkEntry(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, \"dummy\"),\n+                    mkEntry(StreamsConfig.APPLICATION_ID_CONFIG, \"test\"),\n+                    mkEntry(StreamsConfig.STATE_DIR_CONFIG, TestUtils.tempDirectory(\"kafka-test\").getAbsolutePath())\n+                )),\n+                Instant.ofEpochMilli(0L))) {\n+            final TestInputTopic<String, String> inputTopic =\n+                driver.createInputTopic(input, new StringSerializer(), new StringSerializer(), Instant.ofEpochMilli(0L), Duration.ZERO);\n+            final TestOutputTopic<String, Integer> outputTopic =\n+                driver.createOutputTopic(output, Serdes.String().deserializer(), Serdes.Integer().deserializer());\n+            final KeyValueStore<String, String> store = driver.getKeyValueStore(storeName);\n+            \n+            inputTopic.pipeInput(\"A\", \"green\", 10L);\n+            inputTopic.pipeInput(\"B\", \"green\", 9L);\n+            inputTopic.pipeInput(\"A\", \"blue\", 12L);\n+            inputTopic.pipeInput(\"C\", \"yellow\", 15L);\n+            inputTopic.pipeInput(\"D\", \"green\", 11L);\n+\n+            final Map<String, Integer> expectedStore = new HashMap<>();\n+            expectedStore.putIfAbsent(\"A\", 1);\n+            expectedStore.putIfAbsent(\"B\", 6);\n+            expectedStore.putIfAbsent(\"C\", 24);\n+            expectedStore.putIfAbsent(\"D\", 6);\n+\n+            assertEquals(expectedStore, asMap(store));\n+\n+            assertEquals(\n+                asList(\n+                    new TestRecord<>(\"A\", 6, Instant.ofEpochMilli(10)),\n+                    new TestRecord<>(\"B\", 6, Instant.ofEpochMilli(9)),\n+                    new TestRecord<>(\"A\", 1, Instant.ofEpochMilli(12)),\n+                    new TestRecord<>(\"C\", 24, Instant.ofEpochMilli(15)),\n+                    new TestRecord<>(\"D\", 6, Instant.ofEpochMilli(11))),\n+                outputTopic.readRecordsToList());\n+\n+        }\n+    }\n+\n+    private static Map<String, String> asMap(final KeyValueStore<String, String> store) {\n+        final HashMap<String, String> result = new HashMap<>();\n+        store.all().forEachRemaining(kv -> result.put(kv.key, kv.value));\n+        return result;\n+    }\n+\n+    @Test\n+    public void shouldPropagateRepartitionFlagAfterKTableJoin() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 624}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2NDM3NA==", "bodyText": "Given the change that we might insert a repartition topic in the key was change upstream, we should extend the JavaDocs accordingly. Compare the JavaDocs of groupByKey() that contain a paragraph about auto-repartitioning. We should add a similar (or maybe even the exact some if suitable) for all four overloads of toTable(), too.", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372664374", "createdAt": "2020-01-29T22:23:14Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/KStream.java", "diffHunk": "@@ -874,6 +876,53 @@ void to(final String topic,\n     void to(final TopicNameExtractor<K, V> topicExtractor,\n             final Produced<K, V> produced);\n \n+    /**\n+     * Convert this stream to a {@link KTable}.\n+     * <p>\n+     * Note that this is a logical operation and only changes the \"interpretation\" of the stream, i.e., each record of\n+     * it was a \"fact/event\" and is re-interpreted as update now (cf. {@link KStream} vs {@code KTable}).\n+     *\n+     * @return a {@link KTable} that contains the same records as this {@code KStream}\n+     */\n+    KTable<K, V> toTable();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2NjY2MA==", "bodyText": "This seems to only verify the direct parent -- however, we should rather use repartitionRequired flag to determine if we need to insert a repartition topic or not.", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372666660", "createdAt": "2020-01-29T22:28:55Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -600,6 +609,100 @@ private void to(final TopicNameExtractor<K, V> topicExtractor,\n         builder.addGraphNode(streamsGraphNode, sinkNode);\n     }\n \n+    @Override\n+    public KTable<K, V> toTable() {\n+        return toTable(NamedInternal.empty());\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Named named) {\n+        final ConsumedInternal<K, V> consumedInternal = new ConsumedInternal<>(Consumed.with(keySerde, valSerde));\n+\n+        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(\n+                Materialized.with(consumedInternal.keySerde(), consumedInternal.valueSerde()),\n+                builder,\n+                TO_KTABLE_NAME);\n+\n+        return doToTable(named, materializedInternal);\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n+        return toTable(NamedInternal.empty(), materialized);\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Named named,\n+                                final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n+        Objects.requireNonNull(materialized, \"materialized can't be null\");\n+\n+        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(materialized);\n+        return doToTable(\n+            named,\n+            materializedInternal);\n+    }\n+\n+    private KTable<K, V> doToTable(final Named named,\n+                                   final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n+        Objects.requireNonNull(named, \"named can't be null\");\n+\n+        final Serde<K> keySerde = materializedInternal.keySerde() == null\n+            ? this.keySerde\n+            : materializedInternal.keySerde();\n+        final Serde<V> valueSerde = materializedInternal.valueSerde() == null\n+            ? this.valSerde\n+            : materializedInternal.valueSerde();\n+\n+        final NamedInternal namedInternal = new NamedInternal(named);\n+        final String name = namedInternal.orElseGenerateWithPrefix(builder, TO_KTABLE_NAME);\n+        final Set<String> nodes;\n+        final StreamsGraphNode nextNode;\n+\n+        if (streamsGraphNode.isKeyChangingOperation()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2NzcxNw==", "bodyText": "nit: avoid unnecessary this. prefix", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372667717", "createdAt": "2020-01-29T22:31:31Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -600,6 +609,100 @@ private void to(final TopicNameExtractor<K, V> topicExtractor,\n         builder.addGraphNode(streamsGraphNode, sinkNode);\n     }\n \n+    @Override\n+    public KTable<K, V> toTable() {\n+        return toTable(NamedInternal.empty());\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Named named) {\n+        final ConsumedInternal<K, V> consumedInternal = new ConsumedInternal<>(Consumed.with(keySerde, valSerde));\n+\n+        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(\n+                Materialized.with(consumedInternal.keySerde(), consumedInternal.valueSerde()),\n+                builder,\n+                TO_KTABLE_NAME);\n+\n+        return doToTable(named, materializedInternal);\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n+        return toTable(NamedInternal.empty(), materialized);\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Named named,\n+                                final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n+        Objects.requireNonNull(materialized, \"materialized can't be null\");\n+\n+        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(materialized);\n+        return doToTable(\n+            named,\n+            materializedInternal);\n+    }\n+\n+    private KTable<K, V> doToTable(final Named named,\n+                                   final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n+        Objects.requireNonNull(named, \"named can't be null\");\n+\n+        final Serde<K> keySerde = materializedInternal.keySerde() == null\n+            ? this.keySerde", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2Nzc4OA==", "bodyText": "nit: avoid unnecessary this. prefix", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372667788", "createdAt": "2020-01-29T22:31:41Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -600,6 +609,100 @@ private void to(final TopicNameExtractor<K, V> topicExtractor,\n         builder.addGraphNode(streamsGraphNode, sinkNode);\n     }\n \n+    @Override\n+    public KTable<K, V> toTable() {\n+        return toTable(NamedInternal.empty());\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Named named) {\n+        final ConsumedInternal<K, V> consumedInternal = new ConsumedInternal<>(Consumed.with(keySerde, valSerde));\n+\n+        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(\n+                Materialized.with(consumedInternal.keySerde(), consumedInternal.valueSerde()),\n+                builder,\n+                TO_KTABLE_NAME);\n+\n+        return doToTable(named, materializedInternal);\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n+        return toTable(NamedInternal.empty(), materialized);\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Named named,\n+                                final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n+        Objects.requireNonNull(materialized, \"materialized can't be null\");\n+\n+        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(materialized);\n+        return doToTable(\n+            named,\n+            materializedInternal);\n+    }\n+\n+    private KTable<K, V> doToTable(final Named named,\n+                                   final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n+        Objects.requireNonNull(named, \"named can't be null\");\n+\n+        final Serde<K> keySerde = materializedInternal.keySerde() == null\n+            ? this.keySerde\n+            : materializedInternal.keySerde();\n+        final Serde<V> valueSerde = materializedInternal.valueSerde() == null\n+            ? this.valSerde", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2NzgyMg==", "bodyText": "nit: avoid unnecessary this. prefix", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372667822", "createdAt": "2020-01-29T22:31:46Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -600,6 +609,100 @@ private void to(final TopicNameExtractor<K, V> topicExtractor,\n         builder.addGraphNode(streamsGraphNode, sinkNode);\n     }\n \n+    @Override\n+    public KTable<K, V> toTable() {\n+        return toTable(NamedInternal.empty());\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Named named) {\n+        final ConsumedInternal<K, V> consumedInternal = new ConsumedInternal<>(Consumed.with(keySerde, valSerde));\n+\n+        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(\n+                Materialized.with(consumedInternal.keySerde(), consumedInternal.valueSerde()),\n+                builder,\n+                TO_KTABLE_NAME);\n+\n+        return doToTable(named, materializedInternal);\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n+        return toTable(NamedInternal.empty(), materialized);\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Named named,\n+                                final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n+        Objects.requireNonNull(materialized, \"materialized can't be null\");\n+\n+        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(materialized);\n+        return doToTable(\n+            named,\n+            materializedInternal);\n+    }\n+\n+    private KTable<K, V> doToTable(final Named named,\n+                                   final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n+        Objects.requireNonNull(named, \"named can't be null\");\n+\n+        final Serde<K> keySerde = materializedInternal.keySerde() == null\n+            ? this.keySerde\n+            : materializedInternal.keySerde();\n+        final Serde<V> valueSerde = materializedInternal.valueSerde() == null\n+            ? this.valSerde\n+            : materializedInternal.valueSerde();\n+\n+        final NamedInternal namedInternal = new NamedInternal(named);\n+        final String name = namedInternal.orElseGenerateWithPrefix(builder, TO_KTABLE_NAME);\n+        final Set<String> nodes;\n+        final StreamsGraphNode nextNode;\n+\n+        if (streamsGraphNode.isKeyChangingOperation()) {\n+            final OptimizableRepartitionNodeBuilder<K, V> repartitionNodeBuilder = optimizableRepartitionNodeBuilder();\n+            final String sourceName = createRepartitionedSource(\n+                builder,\n+                keySerde,\n+                valueSerde,\n+                name,\n+                repartitionNodeBuilder\n+            );\n+\n+            nextNode = repartitionNodeBuilder.build();\n+            builder.addGraphNode(this.streamsGraphNode, nextNode);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2Nzg3NA==", "bodyText": "nit: avoid unnecessary this. prefix", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372667874", "createdAt": "2020-01-29T22:31:52Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -600,6 +609,100 @@ private void to(final TopicNameExtractor<K, V> topicExtractor,\n         builder.addGraphNode(streamsGraphNode, sinkNode);\n     }\n \n+    @Override\n+    public KTable<K, V> toTable() {\n+        return toTable(NamedInternal.empty());\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Named named) {\n+        final ConsumedInternal<K, V> consumedInternal = new ConsumedInternal<>(Consumed.with(keySerde, valSerde));\n+\n+        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(\n+                Materialized.with(consumedInternal.keySerde(), consumedInternal.valueSerde()),\n+                builder,\n+                TO_KTABLE_NAME);\n+\n+        return doToTable(named, materializedInternal);\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n+        return toTable(NamedInternal.empty(), materialized);\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Named named,\n+                                final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n+        Objects.requireNonNull(materialized, \"materialized can't be null\");\n+\n+        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(materialized);\n+        return doToTable(\n+            named,\n+            materializedInternal);\n+    }\n+\n+    private KTable<K, V> doToTable(final Named named,\n+                                   final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n+        Objects.requireNonNull(named, \"named can't be null\");\n+\n+        final Serde<K> keySerde = materializedInternal.keySerde() == null\n+            ? this.keySerde\n+            : materializedInternal.keySerde();\n+        final Serde<V> valueSerde = materializedInternal.valueSerde() == null\n+            ? this.valSerde\n+            : materializedInternal.valueSerde();\n+\n+        final NamedInternal namedInternal = new NamedInternal(named);\n+        final String name = namedInternal.orElseGenerateWithPrefix(builder, TO_KTABLE_NAME);\n+        final Set<String> nodes;\n+        final StreamsGraphNode nextNode;\n+\n+        if (streamsGraphNode.isKeyChangingOperation()) {\n+            final OptimizableRepartitionNodeBuilder<K, V> repartitionNodeBuilder = optimizableRepartitionNodeBuilder();\n+            final String sourceName = createRepartitionedSource(\n+                builder,\n+                keySerde,\n+                valueSerde,\n+                name,\n+                repartitionNodeBuilder\n+            );\n+\n+            nextNode = repartitionNodeBuilder.build();\n+            builder.addGraphNode(this.streamsGraphNode, nextNode);\n+            nodes = Collections.singleton(sourceName);\n+        } else {\n+            nextNode = this.streamsGraphNode;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2Nzg5Ng==", "bodyText": "nit: avoid unnecessary this. prefix", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372667896", "createdAt": "2020-01-29T22:31:55Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -600,6 +609,100 @@ private void to(final TopicNameExtractor<K, V> topicExtractor,\n         builder.addGraphNode(streamsGraphNode, sinkNode);\n     }\n \n+    @Override\n+    public KTable<K, V> toTable() {\n+        return toTable(NamedInternal.empty());\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Named named) {\n+        final ConsumedInternal<K, V> consumedInternal = new ConsumedInternal<>(Consumed.with(keySerde, valSerde));\n+\n+        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(\n+                Materialized.with(consumedInternal.keySerde(), consumedInternal.valueSerde()),\n+                builder,\n+                TO_KTABLE_NAME);\n+\n+        return doToTable(named, materializedInternal);\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n+        return toTable(NamedInternal.empty(), materialized);\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Named named,\n+                                final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n+        Objects.requireNonNull(materialized, \"materialized can't be null\");\n+\n+        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(materialized);\n+        return doToTable(\n+            named,\n+            materializedInternal);\n+    }\n+\n+    private KTable<K, V> doToTable(final Named named,\n+                                   final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n+        Objects.requireNonNull(named, \"named can't be null\");\n+\n+        final Serde<K> keySerde = materializedInternal.keySerde() == null\n+            ? this.keySerde\n+            : materializedInternal.keySerde();\n+        final Serde<V> valueSerde = materializedInternal.valueSerde() == null\n+            ? this.valSerde\n+            : materializedInternal.valueSerde();\n+\n+        final NamedInternal namedInternal = new NamedInternal(named);\n+        final String name = namedInternal.orElseGenerateWithPrefix(builder, TO_KTABLE_NAME);\n+        final Set<String> nodes;\n+        final StreamsGraphNode nextNode;\n+\n+        if (streamsGraphNode.isKeyChangingOperation()) {\n+            final OptimizableRepartitionNodeBuilder<K, V> repartitionNodeBuilder = optimizableRepartitionNodeBuilder();\n+            final String sourceName = createRepartitionedSource(\n+                builder,\n+                keySerde,\n+                valueSerde,\n+                name,\n+                repartitionNodeBuilder\n+            );\n+\n+            nextNode = repartitionNodeBuilder.build();\n+            builder.addGraphNode(this.streamsGraphNode, nextNode);\n+            nodes = Collections.singleton(sourceName);\n+        } else {\n+            nextNode = this.streamsGraphNode;\n+            nodes = this.sourceNodes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY2OTY5Mw==", "bodyText": "I think nextNode is a confusion name; better tableParentNode?", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372669693", "createdAt": "2020-01-29T22:36:26Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -600,6 +609,100 @@ private void to(final TopicNameExtractor<K, V> topicExtractor,\n         builder.addGraphNode(streamsGraphNode, sinkNode);\n     }\n \n+    @Override\n+    public KTable<K, V> toTable() {\n+        return toTable(NamedInternal.empty());\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Named named) {\n+        final ConsumedInternal<K, V> consumedInternal = new ConsumedInternal<>(Consumed.with(keySerde, valSerde));\n+\n+        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(\n+                Materialized.with(consumedInternal.keySerde(), consumedInternal.valueSerde()),\n+                builder,\n+                TO_KTABLE_NAME);\n+\n+        return doToTable(named, materializedInternal);\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n+        return toTable(NamedInternal.empty(), materialized);\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Named named,\n+                                final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n+        Objects.requireNonNull(materialized, \"materialized can't be null\");\n+\n+        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(materialized);\n+        return doToTable(\n+            named,\n+            materializedInternal);\n+    }\n+\n+    private KTable<K, V> doToTable(final Named named,\n+                                   final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n+        Objects.requireNonNull(named, \"named can't be null\");\n+\n+        final Serde<K> keySerde = materializedInternal.keySerde() == null\n+            ? this.keySerde\n+            : materializedInternal.keySerde();\n+        final Serde<V> valueSerde = materializedInternal.valueSerde() == null\n+            ? this.valSerde\n+            : materializedInternal.valueSerde();\n+\n+        final NamedInternal namedInternal = new NamedInternal(named);\n+        final String name = namedInternal.orElseGenerateWithPrefix(builder, TO_KTABLE_NAME);\n+        final Set<String> nodes;\n+        final StreamsGraphNode nextNode;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY3MDE0OQ==", "bodyText": "nodes is not a good name -> subTopologySourceNodes is better.", "url": "https://github.com/apache/kafka/pull/7985#discussion_r372670149", "createdAt": "2020-01-29T22:37:43Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamImpl.java", "diffHunk": "@@ -600,6 +609,100 @@ private void to(final TopicNameExtractor<K, V> topicExtractor,\n         builder.addGraphNode(streamsGraphNode, sinkNode);\n     }\n \n+    @Override\n+    public KTable<K, V> toTable() {\n+        return toTable(NamedInternal.empty());\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Named named) {\n+        final ConsumedInternal<K, V> consumedInternal = new ConsumedInternal<>(Consumed.with(keySerde, valSerde));\n+\n+        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(\n+                Materialized.with(consumedInternal.keySerde(), consumedInternal.valueSerde()),\n+                builder,\n+                TO_KTABLE_NAME);\n+\n+        return doToTable(named, materializedInternal);\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n+        return toTable(NamedInternal.empty(), materialized);\n+    }\n+\n+    @Override\n+    public KTable<K, V> toTable(final Named named,\n+                                final Materialized<K, V, KeyValueStore<Bytes, byte[]>> materialized) {\n+        Objects.requireNonNull(materialized, \"materialized can't be null\");\n+\n+        final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal =\n+            new MaterializedInternal<>(materialized);\n+        return doToTable(\n+            named,\n+            materializedInternal);\n+    }\n+\n+    private KTable<K, V> doToTable(final Named named,\n+                                   final MaterializedInternal<K, V, KeyValueStore<Bytes, byte[]>> materializedInternal) {\n+        Objects.requireNonNull(named, \"named can't be null\");\n+\n+        final Serde<K> keySerde = materializedInternal.keySerde() == null\n+            ? this.keySerde\n+            : materializedInternal.keySerde();\n+        final Serde<V> valueSerde = materializedInternal.valueSerde() == null\n+            ? this.valSerde\n+            : materializedInternal.valueSerde();\n+\n+        final NamedInternal namedInternal = new NamedInternal(named);\n+        final String name = namedInternal.orElseGenerateWithPrefix(builder, TO_KTABLE_NAME);\n+        final Set<String> nodes;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 102}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "604a1821cede104e3db1e0d3f7ef7aa95fab00b1", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/604a1821cede104e3db1e0d3f7ef7aa95fab00b1", "committedDate": "2020-01-30T06:30:58Z", "message": "KAFKA-7658: Add KStream#toTable to the Streams DSL"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "604a1821cede104e3db1e0d3f7ef7aa95fab00b1", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/604a1821cede104e3db1e0d3f7ef7aa95fab00b1", "committedDate": "2020-01-30T06:30:58Z", "message": "KAFKA-7658: Add KStream#toTable to the Streams DSL"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwNjMzNTE4", "url": "https://github.com/apache/kafka/pull/7985#pullrequestreview-350633518", "createdAt": "2020-01-30T07:57:01Z", "commit": {"oid": "604a1821cede104e3db1e0d3f7ef7aa95fab00b1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2062, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}