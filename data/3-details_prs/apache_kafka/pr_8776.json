{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2Mzg4NDgw", "number": 8776, "title": "KAFKA-9441: Improve Kafka Streams task management", "bodyText": "make task manager agnostic to task state\nmake tasks state transitions idempotent", "createdAt": "2020-06-02T06:55:31Z", "url": "https://github.com/apache/kafka/pull/8776", "merged": true, "mergeCommit": {"oid": "9774c73e43dc2f628b9fb07a30ab4a595c0ee0a8"}, "closed": true, "closedAt": "2020-06-05T17:41:00Z", "author": {"login": "mjsax"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnPRYCgFqTQyMjM5MDYzNw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcoIHuiAFqTQyNDkzNDY1Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMzkwNjM3", "url": "https://github.com/apache/kafka/pull/8776#pullrequestreview-422390637", "createdAt": "2020-06-02T06:56:41Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjo1Njo0MVrOGdkcqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjo1Njo0MVrOGdkcqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1OTA1MA==", "bodyText": "Align code style to use switch if all states are used", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433659050", "createdAt": "2020-06-02T06:56:41Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -247,48 +251,75 @@ public void completeRestoration() {\n      */\n     @Override\n     public void prepareSuspend() {\n-        if (state() == State.CREATED || state() == State.SUSPENDED) {\n-            // do nothing\n-            log.trace(\"Skip prepare suspending since state is {}\", state());\n-        } else if (state() == State.RUNNING) {\n-            closeTopology(true);\n+        switch (state()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMzkwODAy", "url": "https://github.com/apache/kafka/pull/8776#pullrequestreview-422390802", "createdAt": "2020-06-02T06:56:59Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjo1Njo1OVrOGdkdJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjo1Njo1OVrOGdkdJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1OTE3NQ==", "bodyText": "Align code style to use switch if all states are used", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433659175", "createdAt": "2020-06-02T06:56:59Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -247,48 +251,75 @@ public void completeRestoration() {\n      */\n     @Override\n     public void prepareSuspend() {\n-        if (state() == State.CREATED || state() == State.SUSPENDED) {\n-            // do nothing\n-            log.trace(\"Skip prepare suspending since state is {}\", state());\n-        } else if (state() == State.RUNNING) {\n-            closeTopology(true);\n+        switch (state()) {\n+            case CREATED:\n+            case SUSPENDED:\n+                // do nothing\n+                log.trace(\"Skip prepare suspending since state is {}\", state());\n \n-            stateMgr.flush();\n-            recordCollector.flush();\n+                break;\n \n-            log.info(\"Prepare suspending running\");\n-        } else if (state() == State.RESTORING) {\n-            stateMgr.flush();\n+            case RESTORING:\n+                stateMgr.flush();\n+                log.info(\"Prepare suspending restoring\");\n \n-            log.info(\"Prepare suspending restoring\");\n-        } else {\n-            throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending active task \" + id);\n+                break;\n+\n+            case RUNNING:\n+                closeTopology(true);\n+\n+                stateMgr.flush();\n+                recordCollector.flush();\n+\n+                log.info(\"Prepare suspending running\");\n+\n+                break;\n+\n+            case CLOSED:\n+                throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending active task \" + id);\n+\n+            default:\n+                throw new IllegalStateException(\"Unknown state \" + state() + \" while suspending active task \" + id);\n         }\n     }\n \n     @Override\n     public void suspend() {\n-        if (state() == State.CREATED || state() == State.SUSPENDED) {\n-            // do nothing\n-            log.trace(\"Skip suspending since state is {}\", state());\n-        } else if (state() == State.RUNNING) {\n-            stateMgr.checkpoint(checkpointableOffsets());\n-            partitionGroup.clear();\n-\n-            transitionTo(State.SUSPENDED);\n-            log.info(\"Suspended running\");\n-        } else if (state() == State.RESTORING) {\n-            // we just checkpoint the position that we've restored up to without\n-            // going through the commit process\n-            stateMgr.checkpoint(emptyMap());\n-\n-            // we should also clear any buffered records of a task when suspending it\n-            partitionGroup.clear();\n-\n-            transitionTo(State.SUSPENDED);\n-            log.info(\"Suspended restoring\");\n-        } else {\n-            throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending active task \" + id);\n+        switch (state()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMzkwOTI0", "url": "https://github.com/apache/kafka/pull/8776#pullrequestreview-422390924", "createdAt": "2020-06-02T06:57:11Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjo1NzoxMVrOGdkdjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjo1NzoxMVrOGdkdjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1OTI3Nw==", "bodyText": "Minor: improve error message", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433659277", "createdAt": "2020-06-02T06:57:11Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -247,48 +251,75 @@ public void completeRestoration() {\n      */\n     @Override\n     public void prepareSuspend() {\n-        if (state() == State.CREATED || state() == State.SUSPENDED) {\n-            // do nothing\n-            log.trace(\"Skip prepare suspending since state is {}\", state());\n-        } else if (state() == State.RUNNING) {\n-            closeTopology(true);\n+        switch (state()) {\n+            case CREATED:\n+            case SUSPENDED:\n+                // do nothing\n+                log.trace(\"Skip prepare suspending since state is {}\", state());\n \n-            stateMgr.flush();\n-            recordCollector.flush();\n+                break;\n \n-            log.info(\"Prepare suspending running\");\n-        } else if (state() == State.RESTORING) {\n-            stateMgr.flush();\n+            case RESTORING:\n+                stateMgr.flush();\n+                log.info(\"Prepare suspending restoring\");\n \n-            log.info(\"Prepare suspending restoring\");\n-        } else {\n-            throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending active task \" + id);\n+                break;\n+\n+            case RUNNING:\n+                closeTopology(true);\n+\n+                stateMgr.flush();\n+                recordCollector.flush();\n+\n+                log.info(\"Prepare suspending running\");\n+\n+                break;\n+\n+            case CLOSED:\n+                throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending active task \" + id);\n+\n+            default:\n+                throw new IllegalStateException(\"Unknown state \" + state() + \" while suspending active task \" + id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMzkwOTg5", "url": "https://github.com/apache/kafka/pull/8776#pullrequestreview-422390989", "createdAt": "2020-06-02T06:57:16Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjo1NzoxN1rOGdkduA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjo1NzoxN1rOGdkduA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1OTMyMA==", "bodyText": "Minor: improve error message", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433659320", "createdAt": "2020-06-02T06:57:17Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -247,48 +251,75 @@ public void completeRestoration() {\n      */\n     @Override\n     public void prepareSuspend() {\n-        if (state() == State.CREATED || state() == State.SUSPENDED) {\n-            // do nothing\n-            log.trace(\"Skip prepare suspending since state is {}\", state());\n-        } else if (state() == State.RUNNING) {\n-            closeTopology(true);\n+        switch (state()) {\n+            case CREATED:\n+            case SUSPENDED:\n+                // do nothing\n+                log.trace(\"Skip prepare suspending since state is {}\", state());\n \n-            stateMgr.flush();\n-            recordCollector.flush();\n+                break;\n \n-            log.info(\"Prepare suspending running\");\n-        } else if (state() == State.RESTORING) {\n-            stateMgr.flush();\n+            case RESTORING:\n+                stateMgr.flush();\n+                log.info(\"Prepare suspending restoring\");\n \n-            log.info(\"Prepare suspending restoring\");\n-        } else {\n-            throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending active task \" + id);\n+                break;\n+\n+            case RUNNING:\n+                closeTopology(true);\n+\n+                stateMgr.flush();\n+                recordCollector.flush();\n+\n+                log.info(\"Prepare suspending running\");\n+\n+                break;\n+\n+            case CLOSED:\n+                throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending active task \" + id);\n+\n+            default:\n+                throw new IllegalStateException(\"Unknown state \" + state() + \" while suspending active task \" + id);\n         }\n     }\n \n     @Override\n     public void suspend() {\n-        if (state() == State.CREATED || state() == State.SUSPENDED) {\n-            // do nothing\n-            log.trace(\"Skip suspending since state is {}\", state());\n-        } else if (state() == State.RUNNING) {\n-            stateMgr.checkpoint(checkpointableOffsets());\n-            partitionGroup.clear();\n-\n-            transitionTo(State.SUSPENDED);\n-            log.info(\"Suspended running\");\n-        } else if (state() == State.RESTORING) {\n-            // we just checkpoint the position that we've restored up to without\n-            // going through the commit process\n-            stateMgr.checkpoint(emptyMap());\n-\n-            // we should also clear any buffered records of a task when suspending it\n-            partitionGroup.clear();\n-\n-            transitionTo(State.SUSPENDED);\n-            log.info(\"Suspended restoring\");\n-        } else {\n-            throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending active task \" + id);\n+        switch (state()) {\n+            case CREATED:\n+            case SUSPENDED:\n+                // do nothing\n+                log.trace(\"Skip suspending since state is {}\", state());\n+\n+                break;\n+\n+            case RUNNING:\n+                stateMgr.checkpoint(checkpointableOffsets());\n+                partitionGroup.clear();\n+\n+                transitionTo(State.SUSPENDED);\n+                log.info(\"Suspended running\");\n+\n+                break;\n+\n+            case RESTORING:\n+                // we just checkpoint the position that we've restored up to without\n+                // going through the commit process\n+                stateMgr.checkpoint(emptyMap());\n+\n+                // we should also clear any buffered records of a task when suspending it\n+                partitionGroup.clear();\n+\n+                transitionTo(State.SUSPENDED);\n+                log.info(\"Suspended restoring\");\n+\n+                break;\n+\n+            case CLOSED:\n+                throw new IllegalStateException(\"Illegal state \" + state() + \" while suspending active task \" + id);\n+\n+            default:\n+                throw new IllegalStateException(\"Unknown state \" + state() + \" while suspending active task \" + id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 117}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMzkxNDc0", "url": "https://github.com/apache/kafka/pull/8776#pullrequestreview-422391474", "createdAt": "2020-06-02T06:58:06Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjo1ODowN1rOGdkfPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjo1ODowN1rOGdkfPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1OTcxMQ==", "bodyText": "State \"closing\" was removed in a previous PR already; just updating the comment", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433659711", "createdAt": "2020-06-02T06:58:07Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/Task.java", "diffHunk": "@@ -59,14 +58,9 @@\n      *          |            |                      |         |\n      *          |            |                      |         |\n      *          |            v                      |         |\n-     *          |      +-----+-------+              |         |\n-     *          +----> | Closing (4) | <------------+         |\n-     *                 +-----+-------+                        |\n-     *                       |                                |\n-     *                       v                                |\n-     *                 +-----+-------+                        |\n-     *                 | Closed (5)  | -----------------------+\n-     *                 +-------------+\n+     *          |      +-----+-------+ <------------+         |\n+     *          +----> | Closed (4)  |                        |\n+     *                 +-------------+ <----------------------+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMzkxNzk4", "url": "https://github.com/apache/kafka/pull/8776#pullrequestreview-422391798", "createdAt": "2020-06-02T06:58:40Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjo1ODo0MVrOGdkgMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjo1ODo0MVrOGdkgMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1OTk1NQ==", "bodyText": "Making tasks idempotent; this check is not required any longer.", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433659955", "createdAt": "2020-06-02T06:58:41Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -390,19 +387,17 @@ boolean tryToCompleteRestoration() {\n \n         final List<Task> restoringTasks = new LinkedList<>();\n         for (final Task task : tasks.values()) {\n-            if (task.state() == CREATED) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMzkyMjIz", "url": "https://github.com/apache/kafka/pull/8776#pullrequestreview-422392223", "createdAt": "2020-06-02T06:59:23Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjo1OToyM1rOGdkhdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNjo1OToyM1rOGdkhdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MDI3Ng==", "bodyText": "StandbyTask are never in RESTORING state.", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433660276", "createdAt": "2020-06-02T06:59:23Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -390,19 +387,17 @@ boolean tryToCompleteRestoration() {\n \n         final List<Task> restoringTasks = new LinkedList<>();\n         for (final Task task : tasks.values()) {\n-            if (task.state() == CREATED) {\n-                try {\n-                    task.initializeIfNeeded();\n-                } catch (final LockException | TimeoutException e) {\n-                    // it is possible that if there are multiple threads within the instance that one thread\n-                    // trying to grab the task from the other, while the other has not released the lock since\n-                    // it did not participate in the rebalance. In this case we can just retry in the next iteration\n-                    log.debug(\"Could not initialize {} due to the following exception; will retry\", task.id(), e);\n-                    allRunning = false;\n-                }\n+            try {\n+                task.initializeIfNeeded();\n+            } catch (final LockException | TimeoutException e) {\n+                // it is possible that if there are multiple threads within the instance that one thread\n+                // trying to grab the task from the other, while the other has not released the lock since\n+                // it did not participate in the rebalance. In this case we can just retry in the next iteration\n+                log.debug(\"Could not initialize {} due to the following exception; will retry\", task.id(), e);\n+                allRunning = false;\n             }\n \n-            if (task.state() == RESTORING) {\n+            if (task.isActive()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMzkyNjU3", "url": "https://github.com/apache/kafka/pull/8776#pullrequestreview-422392657", "createdAt": "2020-06-02T07:00:08Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNzowMDowOFrOGdkirA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNzowMDowOFrOGdkirA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MDU4OA==", "bodyText": "Make TM agnostic to task state -- putting some more logic into sumOfChangelogOffsets to make this work -- note that task.changelogOffsets() set offsets to LATEST_OFFSET for StreamsTasks that are RUNNING.", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433660588", "createdAt": "2020-06-02T07:00:08Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -529,11 +524,7 @@ void handleLostAll() {\n         for (final TaskId id : lockedTaskDirectories) {\n             final Task task = tasks.get(id);\n             if (task != null) {\n-                if (task.isActive() && task.state() == RUNNING) {\n-                    taskOffsetSums.put(id, Task.LATEST_OFFSET);\n-                } else {\n-                    taskOffsetSums.put(id, sumOfChangelogOffsets(id, task.changelogOffsets()));\n-                }\n+                taskOffsetSums.put(id, sumOfChangelogOffsets(id, task.changelogOffsets()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMzk0NDg3", "url": "https://github.com/apache/kafka/pull/8776#pullrequestreview-422394487", "createdAt": "2020-06-02T07:03:19Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNzowMzoxOVrOGdkoFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNzowMzoxOVrOGdkoFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MTk3Mg==", "bodyText": "If an active tasks is RUNNING, the offsets are set to LATEST_OFFSET in task.changelogOffsets() that is passed as parameter.", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433661972", "createdAt": "2020-06-02T07:03:19Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -613,10 +604,14 @@ private long sumOfChangelogOffsets(final TaskId id, final Map<TopicPartition, Lo\n         for (final Map.Entry<TopicPartition, Long> changelogEntry : changelogOffsets.entrySet()) {\n             final long offset = changelogEntry.getValue();\n \n-            offsetSum += offset;\n-            if (offsetSum < 0) {\n-                log.warn(\"Sum of changelog offsets for task {} overflowed, pinning to Long.MAX_VALUE\", id);\n-                return Long.MAX_VALUE;\n+            if (offset == Task.LATEST_OFFSET) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMzk1MDM4", "url": "https://github.com/apache/kafka/pull/8776#pullrequestreview-422395038", "createdAt": "2020-06-02T07:04:15Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNzowNDoxNVrOGdkphg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNzowNDoxNVrOGdkphg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MjM0Mg==", "bodyText": "A \"standby\" must transit to RUNNING here (cf StandbyTask)", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433662342", "createdAt": "2020-06-02T07:04:15Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -2637,11 +2646,17 @@ private File getCheckpointFile(final TaskId task) {\n         public void initializeIfNeeded() {\n             if (state() == State.CREATED) {\n                 transitionTo(State.RESTORING);\n+                if (!active) {\n+                    transitionTo(State.RUNNING);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMzk1MTg5", "url": "https://github.com/apache/kafka/pull/8776#pullrequestreview-422395189", "createdAt": "2020-06-02T07:04:30Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNzowNDozMFrOGdkp2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQwNzowNDozMFrOGdkp2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MjQyNg==", "bodyText": "Must be idempotent.", "url": "https://github.com/apache/kafka/pull/8776#discussion_r433662426", "createdAt": "2020-06-02T07:04:30Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -2637,11 +2646,17 @@ private File getCheckpointFile(final TaskId task) {\n         public void initializeIfNeeded() {\n             if (state() == State.CREATED) {\n                 transitionTo(State.RESTORING);\n+                if (!active) {\n+                    transitionTo(State.RUNNING);\n+                }\n             }\n         }\n \n         @Override\n         public void completeRestoration() {\n+            if (state() == State.RUNNING) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyODgyMTYy", "url": "https://github.com/apache/kafka/pull/8776#pullrequestreview-422882162", "createdAt": "2020-06-02T17:03:52Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNzowMzo1MlrOGd7X5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNzozMTo0OVrOGd8Ydg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAzNDY2Mw==", "bodyText": "Can we use if/ else if here for consistency?", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434034663", "createdAt": "2020-06-02T17:03:52Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -218,6 +218,10 @@ public void initializeIfNeeded() {\n      */\n     @Override\n     public void completeRestoration() {\n+        if (state() == State.RUNNING) {\n+            return;\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAzNzM0NA==", "bodyText": "nice", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434037344", "createdAt": "2020-06-02T17:08:26Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -613,10 +604,14 @@ private long sumOfChangelogOffsets(final TaskId id, final Map<TopicPartition, Lo\n         for (final Map.Entry<TopicPartition, Long> changelogEntry : changelogOffsets.entrySet()) {\n             final long offset = changelogEntry.getValue();\n \n-            offsetSum += offset;\n-            if (offsetSum < 0) {\n-                log.warn(\"Sum of changelog offsets for task {} overflowed, pinning to Long.MAX_VALUE\", id);\n-                return Long.MAX_VALUE;\n+            if (offset == Task.LATEST_OFFSET) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MTk3Mg=="}, "originalCommit": null, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAzODQ5NQ==", "bodyText": "Can we add a comment or rename restoringTasks to clarify that it's ok to put an active-but-not-restoring task in here since Task#completeRestoration is idempotent/no-op for RUNNING tasks?", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434038495", "createdAt": "2020-06-02T17:10:30Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -390,19 +387,17 @@ boolean tryToCompleteRestoration() {\n \n         final List<Task> restoringTasks = new LinkedList<>();\n         for (final Task task : tasks.values()) {\n-            if (task.state() == CREATED) {\n-                try {\n-                    task.initializeIfNeeded();\n-                } catch (final LockException | TimeoutException e) {\n-                    // it is possible that if there are multiple threads within the instance that one thread\n-                    // trying to grab the task from the other, while the other has not released the lock since\n-                    // it did not participate in the rebalance. In this case we can just retry in the next iteration\n-                    log.debug(\"Could not initialize {} due to the following exception; will retry\", task.id(), e);\n-                    allRunning = false;\n-                }\n+            try {\n+                task.initializeIfNeeded();\n+            } catch (final LockException | TimeoutException e) {\n+                // it is possible that if there are multiple threads within the instance that one thread\n+                // trying to grab the task from the other, while the other has not released the lock since\n+                // it did not participate in the rebalance. In this case we can just retry in the next iteration\n+                log.debug(\"Could not initialize {} due to the following exception; will retry\", task.id(), e);\n+                allRunning = false;\n             }\n \n-            if (task.state() == RESTORING) {\n+            if (task.isActive()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MDI3Ng=="}, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0Nzc1OA==", "bodyText": "I think this might be one of those exceptions where we should still enforce that the state is not CLOSED (ie throw IllegalStateException) since there are related actions that occur outside of the Task implementation that will fail if we try to recycle a CLOSED task. Similar to prepare/post commit, resume, etc", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434047758", "createdAt": "2020-06-02T17:26:10Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -466,6 +510,11 @@ public void closeAndRecycleState() {\n                 stateMgr.recycle();\n                 recordCollector.close();\n                 break;\n+\n+            case CLOSED:\n+                log.trace(\"Skip close since state is {}\", state());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1MDQ0NQ==", "bodyText": "github won't let me leave a comment below this line, but can we use the \"Illegal state\"/\"Unknown state\" improvement in this method as well?", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434050445", "createdAt": "2020-06-02T17:30:35Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -218,6 +218,10 @@ public void initializeIfNeeded() {\n      */\n     @Override\n     public void completeRestoration() {\n+        if (state() == State.RUNNING) {\n+            return;\n+        }\n+\n         if (state() == State.RESTORING) {\n             initializeMetadata();\n             initializeTopology();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1MDgyNg==", "bodyText": "Illegal state -> Unknown state?", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434050826", "createdAt": "2020-06-02T17:31:12Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -247,6 +247,9 @@ private void close(final boolean clean) {\n                 \"state manager close\",\n                 log\n             );\n+        } else if (state() == State.CLOSED) {\n+            log.trace(\"Skip closing since state is {}\", state());\n+            return;\n         } else {\n             throw new IllegalStateException(\"Illegal state \" + state() + \" while closing standby task \" + id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1MTE5MA==", "bodyText": "Should we switch to switch here as well?", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434051190", "createdAt": "2020-06-02T17:31:49Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -247,6 +247,9 @@ private void close(final boolean clean) {\n                 \"state manager close\",\n                 log\n             );\n+        } else if (state() == State.CLOSED) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyOTY5MTcy", "url": "https://github.com/apache/kafka/pull/8776#pullrequestreview-422969172", "createdAt": "2020-06-02T18:55:35Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxODo1NTozNlrOGd_y9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxOTowNzo0NFrOGeAN7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEwNzEyNw==", "bodyText": "nit: call -> calls", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434107127", "createdAt": "2020-06-02T18:55:36Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "diffHunk": "@@ -1799,8 +1799,8 @@ public void shouldThrowIfClosingOnIllegalState() {\n         task.closeClean(checkpoint);\n \n         // close call are not idempotent since we are already in closed", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEwOTg2NA==", "bodyText": "We could just say Skip closing since state is closed here", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434109864", "createdAt": "2020-06-02T19:00:30Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -247,6 +247,9 @@ private void close(final boolean clean) {\n                 \"state manager close\",\n                 log\n             );\n+        } else if (state() == State.CLOSED) {\n+            log.trace(\"Skip closing since state is {}\", state());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExMjAxNA==", "bodyText": "Could we merge the case CLOSED and CREATED? Also could you elaborate why we do empty checkpoint map instead of null?", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434112014", "createdAt": "2020-06-02T19:04:20Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -493,28 +542,45 @@ public void closeAndRecycleState() {\n     private Map<TopicPartition, Long> prepareClose(final boolean clean) {\n         final Map<TopicPartition, Long> checkpoint;\n \n-        if (state() == State.CREATED) {\n-            // the task is created and not initialized, just re-write the checkpoint file\n-            checkpoint = Collections.emptyMap();\n-        } else if (state() == State.RUNNING) {\n-            closeTopology(clean);\n+        switch (state()) {\n+            case CREATED:\n+                // the task is created and not initialized, just re-write the checkpoint file\n+                checkpoint = Collections.emptyMap();\n \n-            if (clean) {\n-                stateMgr.flush();\n-                recordCollector.flush();\n-                checkpoint = checkpointableOffsets();\n-            } else {\n+                break;\n+\n+            case RUNNING:\n+                closeTopology(clean);\n+\n+                if (clean) {\n+                    stateMgr.flush();\n+                    recordCollector.flush();\n+                    checkpoint = checkpointableOffsets();\n+                } else {\n+                    checkpoint = null; // `null` indicates to not write a checkpoint\n+                    executeAndMaybeSwallow(false, stateMgr::flush, \"state manager flush\", log);\n+                }\n+\n+                break;\n+\n+            case RESTORING:\n+                executeAndMaybeSwallow(clean, stateMgr::flush, \"state manager flush\", log);\n+                checkpoint = Collections.emptyMap();\n+\n+                break;\n+\n+            case SUSPENDED:\n+                // if `SUSPENDED` do not need to checkpoint, since when suspending we've already committed the state\n                 checkpoint = null; // `null` indicates to not write a checkpoint\n-                executeAndMaybeSwallow(false, stateMgr::flush, \"state manager flush\", log);\n-            }\n-        } else if (state() == State.RESTORING) {\n-            executeAndMaybeSwallow(clean, stateMgr::flush, \"state manager flush\", log);\n-            checkpoint = Collections.emptyMap();\n-        } else if (state() == State.SUSPENDED) {\n-            // if `SUSPENDED` do not need to checkpoint, since when suspending we've already committed the state\n-            checkpoint = null; // `null` indicates to not write a checkpoint\n-        } else {\n-            throw new IllegalStateException(\"Illegal state \" + state() + \" while prepare closing active task \" + id);\n+\n+                break;\n+            case CLOSED:", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExNDAyOA==", "bodyText": "Should we also check task.isActive here?", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434114028", "createdAt": "2020-06-02T19:07:44Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -613,10 +604,14 @@ private long sumOfChangelogOffsets(final TaskId id, final Map<TopicPartition, Lo\n         for (final Map.Entry<TopicPartition, Long> changelogEntry : changelogOffsets.entrySet()) {\n             final long offset = changelogEntry.getValue();\n \n-            offsetSum += offset;\n-            if (offsetSum < 0) {\n-                log.warn(\"Sum of changelog offsets for task {} overflowed, pinning to Long.MAX_VALUE\", id);\n-                return Long.MAX_VALUE;\n+            if (offset == Task.LATEST_OFFSET) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MTk3Mg=="}, "originalCommit": null, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDM1NTc3", "url": "https://github.com/apache/kafka/pull/8776#pullrequestreview-423035577", "createdAt": "2020-06-02T20:32:17Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMDozMjoxN1rOGeC7Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMDo0Mzo0NFrOGeDR_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE1ODM5MA==", "bodyText": "Is this intentional to use switch and if/else in different functions?", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434158390", "createdAt": "2020-06-02T20:32:17Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -247,48 +251,75 @@ public void completeRestoration() {\n      */\n     @Override\n     public void prepareSuspend() {\n-        if (state() == State.CREATED || state() == State.SUSPENDED) {\n-            // do nothing\n-            log.trace(\"Skip prepare suspending since state is {}\", state());\n-        } else if (state() == State.RUNNING) {\n-            closeTopology(true);\n+        switch (state()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1OTA1MA=="}, "originalCommit": null, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2MDk5Ng==", "bodyText": "Out of the scope of this PR: why we need to return the checkpoint map to bookkeep at the task-manager? It seems we just re-distribute it in the close call.\nI think we do not need to expose the checkpoint map in task-manager eventually?", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434160996", "createdAt": "2020-06-02T20:37:33Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -493,28 +549,45 @@ public void closeAndRecycleState() {\n     private Map<TopicPartition, Long> prepareClose(final boolean clean) {\n         final Map<TopicPartition, Long> checkpoint;\n \n-        if (state() == State.CREATED) {\n-            // the task is created and not initialized, just re-write the checkpoint file\n-            checkpoint = Collections.emptyMap();\n-        } else if (state() == State.RUNNING) {\n-            closeTopology(clean);\n+        switch (state()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE2NDIyMw==", "bodyText": "I think we should use null to indicate no need to write new checkpoint?", "url": "https://github.com/apache/kafka/pull/8776#discussion_r434164223", "createdAt": "2020-06-02T20:43:44Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -493,28 +549,45 @@ public void closeAndRecycleState() {\n     private Map<TopicPartition, Long> prepareClose(final boolean clean) {\n         final Map<TopicPartition, Long> checkpoint;\n \n-        if (state() == State.CREATED) {\n-            // the task is created and not initialized, just re-write the checkpoint file\n-            checkpoint = Collections.emptyMap();\n-        } else if (state() == State.RUNNING) {\n-            closeTopology(clean);\n+        switch (state()) {\n+            case CREATED:\n+                // the task is created and not initialized, just re-write the checkpoint file\n+                checkpoint = Collections.emptyMap();\n \n-            if (clean) {\n-                stateMgr.flush();\n-                recordCollector.flush();\n-                checkpoint = checkpointableOffsets();\n-            } else {\n+                break;\n+\n+            case RUNNING:\n+                closeTopology(clean);\n+\n+                if (clean) {\n+                    stateMgr.flush();\n+                    recordCollector.flush();\n+                    checkpoint = checkpointableOffsets();\n+                } else {\n+                    checkpoint = null; // `null` indicates to not write a checkpoint\n+                    executeAndMaybeSwallow(false, stateMgr::flush, \"state manager flush\", log);\n+                }\n+\n+                break;\n+\n+            case RESTORING:\n+                executeAndMaybeSwallow(clean, stateMgr::flush, \"state manager flush\", log);\n+                checkpoint = Collections.emptyMap();\n+\n+                break;\n+\n+            case SUSPENDED:\n+                // if `SUSPENDED` do not need to checkpoint, since when suspending we've already committed the state\n                 checkpoint = null; // `null` indicates to not write a checkpoint\n-                executeAndMaybeSwallow(false, stateMgr::flush, \"state manager flush\", log);\n-            }\n-        } else if (state() == State.RESTORING) {\n-            executeAndMaybeSwallow(clean, stateMgr::flush, \"state manager flush\", log);\n-            checkpoint = Collections.emptyMap();\n-        } else if (state() == State.SUSPENDED) {\n-            // if `SUSPENDED` do not need to checkpoint, since when suspending we've already committed the state\n-            checkpoint = null; // `null` indicates to not write a checkpoint\n-        } else {\n-            throw new IllegalStateException(\"Illegal state \" + state() + \" while prepare closing active task \" + id);\n+\n+                break;\n+            case CLOSED:\n+                checkpoint = Collections.emptyMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 263}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ab1bc1dd035cbe1e25ebb4170b10456a420933b", "author": {"user": {"login": "mjsax", "name": "Matthias J. Sax"}}, "url": "https://github.com/apache/kafka/commit/9ab1bc1dd035cbe1e25ebb4170b10456a420933b", "committedDate": "2020-06-04T00:26:39Z", "message": "KAFKA-9441: Improve Kafka Streams task management\n - make task manager agnostic to task state\n - make tasks state transitions idempotent"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "9ab1bc1dd035cbe1e25ebb4170b10456a420933b", "author": {"user": {"login": "mjsax", "name": "Matthias J. Sax"}}, "url": "https://github.com/apache/kafka/commit/9ab1bc1dd035cbe1e25ebb4170b10456a420933b", "committedDate": "2020-06-04T00:26:39Z", "message": "KAFKA-9441: Improve Kafka Streams task management\n - make task manager agnostic to task state\n - make tasks state transitions idempotent"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MTA3MDUz", "url": "https://github.com/apache/kafka/pull/8776#pullrequestreview-424107053", "createdAt": "2020-06-04T05:13:07Z", "commit": {"oid": "9ab1bc1dd035cbe1e25ebb4170b10456a420933b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0Nzk0MTYx", "url": "https://github.com/apache/kafka/pull/8776#pullrequestreview-424794161", "createdAt": "2020-06-04T20:14:29Z", "commit": {"oid": "9ab1bc1dd035cbe1e25ebb4170b10456a420933b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxNDoyOVrOGfWNFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxNjozMFrOGfWQ9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMjgzNg==", "bodyText": "This seems pretty subtle, can you convert your GH explanation into a code comment?\nIt also seems mentioning that we assume that if any changelog offset in the task is \"latest\", then we assume the whole task is active and therefore return \"latest\". Took me a minute to work that out.", "url": "https://github.com/apache/kafka/pull/8776#discussion_r435522836", "createdAt": "2020-06-04T20:14:29Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -613,10 +604,14 @@ private long sumOfChangelogOffsets(final TaskId id, final Map<TopicPartition, Lo\n         for (final Map.Entry<TopicPartition, Long> changelogEntry : changelogOffsets.entrySet()) {\n             final long offset = changelogEntry.getValue();\n \n-            offsetSum += offset;\n-            if (offsetSum < 0) {\n-                log.warn(\"Sum of changelog offsets for task {} overflowed, pinning to Long.MAX_VALUE\", id);\n-                return Long.MAX_VALUE;\n+            if (offset == Task.LATEST_OFFSET) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MTk3Mg=="}, "originalCommit": null, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMzgyOQ==", "bodyText": "It might be nice to have a sanity check here that offset is non-negative, since that would indicate we've unexpectedly received a sentinel value. I thought we did that already, but it's obviously not here.", "url": "https://github.com/apache/kafka/pull/8776#discussion_r435523829", "createdAt": "2020-06-04T20:16:30Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -613,10 +604,14 @@ private long sumOfChangelogOffsets(final TaskId id, final Map<TopicPartition, Lo\n         for (final Map.Entry<TopicPartition, Long> changelogEntry : changelogOffsets.entrySet()) {\n             final long offset = changelogEntry.getValue();\n \n-            offsetSum += offset;\n-            if (offsetSum < 0) {\n-                log.warn(\"Sum of changelog offsets for task {} overflowed, pinning to Long.MAX_VALUE\", id);\n-                return Long.MAX_VALUE;\n+            if (offset == Task.LATEST_OFFSET) {\n+                return Task.LATEST_OFFSET;\n+            } else {\n+                offsetSum += offset;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ab1bc1dd035cbe1e25ebb4170b10456a420933b"}, "originalPosition": 78}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f98207900282ef4d7a27980a4cc018216098236c", "author": {"user": {"login": "mjsax", "name": "Matthias J. Sax"}}, "url": "https://github.com/apache/kafka/commit/f98207900282ef4d7a27980a4cc018216098236c", "committedDate": "2020-06-04T22:38:26Z", "message": "Github comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0OTM0NjUz", "url": "https://github.com/apache/kafka/pull/8776#pullrequestreview-424934653", "createdAt": "2020-06-05T01:10:44Z", "commit": {"oid": "f98207900282ef4d7a27980a4cc018216098236c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 822, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}