{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyODEyOTcy", "number": 8338, "title": "KAFKA-8890: KIP-519- Make SSL context/engine configuration extensible", "bodyText": "More detailed description of your change,\nif necessary. The PR title and PR message become\nthe squashed commit message, so use a separate\ncomment to ping reviewers.\nSummary of testing strategy (including rationale)\nfor the feature or bug fix. Unit and/or integration\ntests are expected for any behaviour change and\nsystem tests should be considered for larger changes.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-03-24T06:59:51Z", "url": "https://github.com/apache/kafka/pull/8338", "merged": true, "mergeCommit": {"oid": "9ba49b806ad0dcdb72a3a80393175a143f181382"}, "closed": true, "closedAt": "2020-04-08T14:20:32Z", "author": {"login": "maulin-vasavada"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcQs7dFAH2gAyMzkyODEyOTcyOjBlMjkwODhhZjJmNjFhNWFjOTFmY2VmYjE0NTc2OTI4NDA3YzJlNDU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcVcyBKAH2gAyMzkyODEyOTcyOjE1ZTZlYzU1NzViZjVmNTVkMWY4MWMyZWM3MzhmMjUyODJmMTUzYWQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0e29088af2f61a5ac91fcefb14576928407c2e45", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/0e29088af2f61a5ac91fcefb14576928407c2e45", "committedDate": "2020-03-24T06:29:38Z", "message": "KAFKA-8890: KIP-519- Make SSL context/engine configuration extensible"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c0f2174fdf2e2869a8323203db0f2b18f2726d3", "author": {"user": {"login": "maulin-vasavada", "name": null}}, "url": "https://github.com/apache/kafka/commit/0c0f2174fdf2e2869a8323203db0f2b18f2726d3", "committedDate": "2020-03-24T06:56:43Z", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into KAFKA-8890"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f709a4e3b6455c1f0028beb700994b5c62f3e0a0", "author": {"user": {"login": "maulin-vasavada", "name": null}}, "url": "https://github.com/apache/kafka/commit/f709a4e3b6455c1f0028beb700994b5c62f3e0a0", "committedDate": "2020-03-24T17:49:27Z", "message": "Removing older SslEngineBuilder class"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMDAwODAz", "url": "https://github.com/apache/kafka/pull/8338#pullrequestreview-383000803", "createdAt": "2020-03-27T16:11:35Z", "commit": {"oid": "f709a4e3b6455c1f0028beb700994b5c62f3e0a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjoxMTozNVrOF84GbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjoxMTozNVrOF84GbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3ODAyOA==", "bodyText": "Please make it possible to load the keystore not from a file but e.g. from a variable. This could be easily done by providing a protected method \"byte[] getKeyStoreContent\" (or similar). The default impl. would read the contents from the file. But I caould subclass the default impl. and just use a property set from outside.\nThe same applies for the truststore.", "url": "https://github.com/apache/kafka/pull/8338#discussion_r399378028", "createdAt": "2020-03-27T16:11:35Z", "author": {"login": "fml2"}, "path": "clients/src/main/java/org/apache/kafka/common/security/ssl/DefaultSslEngineFactory.java", "diffHunk": "@@ -281,7 +295,7 @@ public boolean shouldBeRebuilt(Map<String, Object> nextConfigs) {\n          * @throws KafkaException if the file could not be read or if the keystore could not be loaded\n          *   using the specified configs (e.g. if the password or keystore type is invalid)\n          */\n-        KeyStore load() {\n+        private KeyStore load() {\n             try (InputStream in = Files.newInputStream(Paths.get(path))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f709a4e3b6455c1f0028beb700994b5c62f3e0a0"}, "originalPosition": 284}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f24d1566636565c84c10246119f3f78678d77c61", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/f24d1566636565c84c10246119f3f78678d77c61", "committedDate": "2020-03-31T05:29:12Z", "message": "Adding documentation for SslEngineFactory#shouldBeRebuilt method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca", "committedDate": "2020-04-03T06:03:17Z", "message": "Update documentation on shouldBeRebuilt() to mention what happens to the existing SSL connections."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4MjQ1Mzcx", "url": "https://github.com/apache/kafka/pull/8338#pullrequestreview-388245371", "createdAt": "2020-04-06T13:25:50Z", "commit": {"oid": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxMzoyNTo1MVrOGBXlAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNDowMToxMFrOGBZLKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA4ODA2Nw==", "bodyText": "nit: We can use the class instead of hard-coding classname.", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404088067", "createdAt": "2020-04-06T13:25:51Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/common/config/SslConfigs.java", "diffHunk": "@@ -110,6 +110,10 @@\n     public static final String SSL_SECURE_RANDOM_IMPLEMENTATION_CONFIG = \"ssl.secure.random.implementation\";\n     public static final String SSL_SECURE_RANDOM_IMPLEMENTATION_DOC = \"The SecureRandom PRNG implementation to use for SSL cryptography operations. \";\n \n+    public static final String SSL_ENGINE_FACTORY_CLASS_CONFIG = \"ssl.engine.factory.class\";\n+    public static final String DEFAULT_SSL_ENGINE_FACTORY_CLASS = org.apache.kafka.common.security.ssl.DefaultSslEngineFactory.class.getCanonicalName();\n+    public static final String SSL_ENGINE_FACTORY_CLASS_DOC = \"The class of type org.apache.kafka.common.security.auth.SslEngineFactory to provide SSLEngine objects. Default value is \" + DEFAULT_SSL_ENGINE_FACTORY_CLASS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA5MTcyNQ==", "bodyText": "It says client mode, but this is the server engine.", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404091725", "createdAt": "2020-04-06T13:31:10Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/common/security/auth/SslEngineFactory.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.security.auth;\n+\n+import org.apache.kafka.common.Configurable;\n+\n+import javax.net.ssl.SSLEngine;\n+import java.io.Closeable;\n+import java.security.KeyStore;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Plugin interface for allowing creation of SSLEngine object in a custom way.\n+ * Example: You want to use custom way to load your key material and trust material needed for SSLContext.\n+ * However, keep in mind that this is complementary to the existing Java Security Provider's mechanism and not a competing\n+ * solution.\n+ */\n+public interface SslEngineFactory extends Configurable, Closeable {\n+\n+    /**\n+     * Create a new SSLEngine object to be used by the client.\n+     *\n+     * @param peerHost               The peer host to use. This is used in client mode if endpoint validation is enabled.\n+     * @param peerPort               The peer port to use. This is a hint and not used for validation.\n+     * @param endpointIdentification Endpoint identification algorithm for client mode.\n+     * @return The new SSLEngine.\n+     */\n+    SSLEngine createClientSslEngine(String peerHost, int peerPort, String endpointIdentification);\n+\n+    /**\n+     * Create a new SSLEngine object to be used by the server.\n+     *\n+     * @param peerHost               The peer host to use. This is used in client mode if endpoint validation is enabled.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA5MzIzNQ==", "bodyText": "nit: intendation", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404093235", "createdAt": "2020-04-06T13:33:20Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/common/security/ssl/DefaultSslEngineFactory.java", "diffHunk": "@@ -104,13 +148,51 @@\n         this.sslContext = createSSLContext();\n     }\n \n+    @Override\n+    public void close() throws IOException {\n+        this.sslContext = null;\n+    }\n+\n+    //For Test only\n+    public SSLContext sslContext() {\n+        return this.sslContext;\n+    }\n+\n+    private SSLEngine createSslEngine(Mode mode, String peerHost, int peerPort, String endpointIdentification) {\n+        SSLEngine sslEngine = sslContext.createSSLEngine(peerHost, peerPort);\n+        if (cipherSuites != null) sslEngine.setEnabledCipherSuites(cipherSuites);\n+        if (enabledProtocols != null) sslEngine.setEnabledProtocols(enabledProtocols);\n+\n+        if (mode == Mode.SERVER) {\n+            sslEngine.setUseClientMode(false);\n+            switch (sslClientAuth) {\n+                case REQUIRED:\n+                    sslEngine.setNeedClientAuth(true);\n+                    break;\n+                case REQUESTED:\n+                    sslEngine.setWantClientAuth(true);\n+                    break;\n+                case NONE:\n+                    break;\n+            }\n+            sslEngine.setUseClientMode(false);\n+        } else {\n+            sslEngine.setUseClientMode(true);\n+            SSLParameters sslParams = sslEngine.getSSLParameters();\n+            // SSLParameters#setEndpointIdentificationAlgorithm enables endpoint validation\n+            // only in client mode. Hence, validation is enabled only for clients.\n+            sslParams.setEndpointIdentificationAlgorithm(endpointIdentification);\n+            sslEngine.setSSLParameters(sslParams);\n+        }\n+        return sslEngine;\n+    }\n     private static SslClientAuth createSslClientAuth(String key) {\n         SslClientAuth auth = SslClientAuth.forConfig(key);\n         if (auth != null) {\n             return auth;\n         }\n         log.warn(\"Unrecognized client authentication configuration {}.  Falling \" +\n-                \"back to NONE.  Recognized client authentication configurations are {}.\",\n+                        \"back to NONE.  Recognized client authentication configurations are {}.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEwNzYwNA==", "bodyText": "Could just do  Map<String, Object> nextConfigs = new HashMap<>(configs);?", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404107604", "createdAt": "2020-04-06T13:52:59Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/common/security/ssl/SslFactory.java", "diffHunk": "@@ -80,19 +80,17 @@ public SslFactory(Mode mode,\n \n     @Override\n     public void configure(Map<String, ?> configs) throws KafkaException {\n-        if (sslEngineBuilder != null) {\n+        if (sslEngineFactory != null) {\n             throw new IllegalStateException(\"SslFactory was already configured.\");\n         }\n         this.endpointIdentification = (String) configs.get(SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG);\n \n         Map<String, Object> nextConfigs = new HashMap<>();\n-        copyMapEntries(nextConfigs, configs, SslConfigs.NON_RECONFIGURABLE_CONFIGS);\n-        copyMapEntries(nextConfigs, configs, SslConfigs.RECONFIGURABLE_CONFIGS);\n-        copyMapEntry(nextConfigs, configs, SecurityConfig.SECURITY_PROVIDERS_CONFIG);\n+        copyAllConfigs(nextConfigs, configs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEwODc3MQ==", "bodyText": "As mentioned earlier, this can be removed if we just create the map with existing values.", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404108771", "createdAt": "2020-04-06T13:54:28Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/common/security/ssl/SslFactory.java", "diffHunk": "@@ -101,88 +99,110 @@ public void configure(Map<String, ?> configs) throws KafkaException {\n                         \"can't connect to a server SSLEngine created with those settings.\", e);\n             }\n         }\n-        this.sslEngineBuilder = builder;\n+        this.sslEngineFactory = builder;\n     }\n \n     @Override\n     public Set<String> reconfigurableConfigs() {\n-        return SslConfigs.RECONFIGURABLE_CONFIGS;\n+        return sslEngineFactory.reconfigurableConfigs();\n     }\n \n     @Override\n     public void validateReconfiguration(Map<String, ?> newConfigs) {\n-        createNewSslEngineBuilder(newConfigs);\n+        createNewSslEngineFactory(newConfigs);\n     }\n \n     @Override\n     public void reconfigure(Map<String, ?> newConfigs) throws KafkaException {\n-        SslEngineBuilder newSslEngineBuilder = createNewSslEngineBuilder(newConfigs);\n-        if (newSslEngineBuilder != this.sslEngineBuilder) {\n-            this.sslEngineBuilder = newSslEngineBuilder;\n+        SslEngineFactory newSslEngineFactory = createNewSslEngineFactory(newConfigs);\n+        if (newSslEngineFactory != this.sslEngineFactory) {\n+            this.sslEngineFactory = newSslEngineFactory;\n             log.info(\"Created new {} SSL engine builder with keystore {} truststore {}\", mode,\n-                    newSslEngineBuilder.keystore(), newSslEngineBuilder.truststore());\n+                    newSslEngineFactory.keystore(), newSslEngineFactory.truststore());\n         }\n     }\n \n-    private SslEngineBuilder createNewSslEngineBuilder(Map<String, ?> newConfigs) {\n-        if (sslEngineBuilder == null) {\n+    private SslEngineFactory instantiateSslEngineFactory(Map<String, Object> configs) {\n+        @SuppressWarnings(\"unchecked\")\n+        Class<? extends SslEngineFactory> sslEngineFactoryClass =\n+                (Class<? extends SslEngineFactory>) configs.get(SslConfigs.SSL_ENGINE_FACTORY_CLASS_CONFIG);\n+        SslEngineFactory sslEngineFactory = Utils.newInstance(sslEngineFactoryClass);\n+        sslEngineFactory.configure(configs);\n+        this.sslEngineFactoryConfig = configs;\n+        return sslEngineFactory;\n+    }\n+\n+    private SslEngineFactory createNewSslEngineFactory(Map<String, ?> newConfigs) {\n+        if (sslEngineFactory == null) {\n             throw new IllegalStateException(\"SslFactory has not been configured.\");\n         }\n-        Map<String, Object> nextConfigs = new HashMap<>(sslEngineBuilder.configs());\n-        copyMapEntries(nextConfigs, newConfigs, SslConfigs.RECONFIGURABLE_CONFIGS);\n+        Map<String, Object> nextConfigs = new HashMap<>(sslEngineFactoryConfig);\n+        copyMapEntries(nextConfigs, newConfigs, reconfigurableConfigs());\n         if (clientAuthConfigOverride != null) {\n             nextConfigs.put(BrokerSecurityConfigs.SSL_CLIENT_AUTH_CONFIG, clientAuthConfigOverride);\n         }\n-        if (!sslEngineBuilder.shouldBeRebuilt(nextConfigs)) {\n-            return sslEngineBuilder;\n+        if (!sslEngineFactory.shouldBeRebuilt(nextConfigs)) {\n+            return sslEngineFactory;\n         }\n         try {\n-            SslEngineBuilder newSslEngineBuilder = new SslEngineBuilder(nextConfigs);\n-            if (sslEngineBuilder.keystore() == null) {\n-                if (newSslEngineBuilder.keystore() != null) {\n+            SslEngineFactory newSslEngineFactory = instantiateSslEngineFactory(nextConfigs);\n+            if (sslEngineFactory.keystore() == null) {\n+                if (newSslEngineFactory.keystore() != null) {\n                     throw new ConfigException(\"Cannot add SSL keystore to an existing listener for \" +\n                             \"which no keystore was configured.\");\n                 }\n             } else {\n-                if (newSslEngineBuilder.keystore() == null) {\n+                if (newSslEngineFactory.keystore() == null) {\n                     throw new ConfigException(\"Cannot remove the SSL keystore from an existing listener for \" +\n                             \"which a keystore was configured.\");\n                 }\n-                if (!CertificateEntries.create(sslEngineBuilder.keystore().load()).equals(\n-                        CertificateEntries.create(newSslEngineBuilder.keystore().load()))) {\n+                if (!CertificateEntries.create(sslEngineFactory.keystore()).equals(\n+                        CertificateEntries.create(newSslEngineFactory.keystore()))) {\n                     throw new ConfigException(\"Keystore DistinguishedName or SubjectAltNames do not match\");\n                 }\n             }\n-            if (sslEngineBuilder.truststore() == null && newSslEngineBuilder.truststore() != null) {\n+            if (sslEngineFactory.truststore() == null && newSslEngineFactory.truststore() != null) {\n                 throw new ConfigException(\"Cannot add SSL truststore to an existing listener for which no \" +\n                         \"truststore was configured.\");\n             }\n             if (keystoreVerifiableUsingTruststore) {\n-                if (sslEngineBuilder.truststore() != null || sslEngineBuilder.keystore() != null) {\n-                    SslEngineValidator.validate(sslEngineBuilder, newSslEngineBuilder);\n+                if (sslEngineFactory.truststore() != null || sslEngineFactory.keystore() != null) {\n+                    SslEngineValidator.validate(sslEngineFactory, newSslEngineFactory);\n                 }\n             }\n-            return newSslEngineBuilder;\n+            return newSslEngineFactory;\n         } catch (Exception e) {\n             log.debug(\"Validation of dynamic config update of SSLFactory failed.\", e);\n             throw new ConfigException(\"Validation of dynamic config update of SSLFactory failed: \" + e);\n         }\n     }\n \n     public SSLEngine createSslEngine(String peerHost, int peerPort) {\n-        if (sslEngineBuilder == null) {\n+        if (sslEngineFactory == null) {\n             throw new IllegalStateException(\"SslFactory has not been configured.\");\n         }\n-        return sslEngineBuilder.createSslEngine(mode, peerHost, peerPort, endpointIdentification);\n+        if (mode == Mode.SERVER) {\n+            return sslEngineFactory.createServerSslEngine(peerHost, peerPort);\n+        } else {\n+            return sslEngineFactory.createClientSslEngine(peerHost, peerPort, endpointIdentification);\n+        }\n     }\n \n-    @Deprecated\n-    public SSLContext sslContext() {\n-        return sslEngineBuilder.sslContext();\n+    public SslEngineFactory sslEngineFactory() {\n+        return sslEngineFactory;\n     }\n \n-    public SslEngineBuilder sslEngineBuilder() {\n-        return sslEngineBuilder;\n+    /**\n+     * Copy all entries from one map into another.\n+     *\n+     * @param destMap   The map to copy entries into.\n+     * @param srcMap    The map to copy entries from.\n+     */\n+    private static void copyAllConfigs(Map<String, Object> destMap,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDEwOTgyOA==", "bodyText": "Why have we removed this code?", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404109828", "createdAt": "2020-04-06T13:55:36Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/common/security/ssl/SslFactory.java", "diffHunk": "@@ -318,8 +342,6 @@ void handshake(SslEngineValidator peerValidator) throws SSLException {\n             while (true) {\n                 switch (handshakeStatus) {\n                     case NEED_WRAP:\n-                        if (netBuffer.position() != 0) // Wait for peer to consume previously wrapped data\n-                            return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDExMzI3Mg==", "bodyText": "Why do we need this change? AclAuthorizer doesn't care about the new config added in this PR.", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404113272", "createdAt": "2020-04-06T13:59:56Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -138,7 +139,14 @@ class AclAuthorizer extends Authorizer with Logging {\n   override def configure(javaConfigs: util.Map[String, _]): Unit = {\n     val configs = javaConfigs.asScala\n     val props = new java.util.Properties()\n-    configs.foreach { case (key, value) => props.put(key, value.toString) }\n+    configs.foreach { case (key, value) =>\n+      value match {\n+        case password: Password => props.put(key, password)\n+        case list: util.List[_] => props.put(key, list.asScala.map(_.toString).mkString(\",\"))\n+        case clazz: Class[_] => props.put(key, clazz.getName())\n+        case _ => props.put(key, value.toString)\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDExNDIxNw==", "bodyText": "We don't use star imports in Java classes", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404114217", "createdAt": "2020-04-06T14:01:10Z", "author": {"login": "rajinisivaram"}, "path": "log4j-appender/src/main/java/org/apache/kafka/log4jappender/KafkaLog4jAppender.java", "diffHunk": "@@ -43,12 +43,8 @@\n import static org.apache.kafka.clients.CommonClientConfigs.SECURITY_PROTOCOL_CONFIG;\n import static org.apache.kafka.common.config.SaslConfigs.SASL_JAAS_CONFIG;\n import static org.apache.kafka.common.config.SaslConfigs.SASL_MECHANISM;\n-import static org.apache.kafka.common.config.SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG;\n-import static org.apache.kafka.common.config.SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG;\n-import static org.apache.kafka.common.config.SslConfigs.SSL_KEYSTORE_TYPE_CONFIG;\n-import static org.apache.kafka.common.config.SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG;\n-import static org.apache.kafka.common.config.SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG;\n import static org.apache.kafka.common.config.SaslConfigs.SASL_KERBEROS_SERVICE_NAME;\n+import static org.apache.kafka.common.config.SslConfigs.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NjEzMzIz", "url": "https://github.com/apache/kafka/pull/8338#pullrequestreview-388613323", "createdAt": "2020-04-06T21:00:24Z", "commit": {"oid": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTowMDoyNFrOGBptPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTowMjozM1rOGBpxtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NTA4NA==", "bodyText": "For other class configs, we set null as the default and just use the default class the config is not overridden. I think we should do the same here and in KafkaConfig where this config is defined.", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404385084", "createdAt": "2020-04-06T21:00:24Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/common/config/SslConfigs.java", "diffHunk": "@@ -136,7 +140,8 @@ public static void addClientSslSupport(ConfigDef config) {\n                 .define(SslConfigs.SSL_KEYMANAGER_ALGORITHM_CONFIG, ConfigDef.Type.STRING, SslConfigs.DEFAULT_SSL_KEYMANGER_ALGORITHM, ConfigDef.Importance.LOW, SslConfigs.SSL_KEYMANAGER_ALGORITHM_DOC)\n                 .define(SslConfigs.SSL_TRUSTMANAGER_ALGORITHM_CONFIG, ConfigDef.Type.STRING, SslConfigs.DEFAULT_SSL_TRUSTMANAGER_ALGORITHM, ConfigDef.Importance.LOW, SslConfigs.SSL_TRUSTMANAGER_ALGORITHM_DOC)\n                 .define(SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_CONFIG, ConfigDef.Type.STRING, SslConfigs.DEFAULT_SSL_ENDPOINT_IDENTIFICATION_ALGORITHM, ConfigDef.Importance.LOW, SslConfigs.SSL_ENDPOINT_IDENTIFICATION_ALGORITHM_DOC)\n-                .define(SslConfigs.SSL_SECURE_RANDOM_IMPLEMENTATION_CONFIG, ConfigDef.Type.STRING, null, ConfigDef.Importance.LOW, SslConfigs.SSL_SECURE_RANDOM_IMPLEMENTATION_DOC);\n+                .define(SslConfigs.SSL_SECURE_RANDOM_IMPLEMENTATION_CONFIG, ConfigDef.Type.STRING, null, ConfigDef.Importance.LOW, SslConfigs.SSL_SECURE_RANDOM_IMPLEMENTATION_DOC)\n+                .define(SslConfigs.SSL_ENGINE_FACTORY_CLASS_CONFIG, ConfigDef.Type.CLASS, DEFAULT_SSL_ENGINE_FACTORY_CLASS, ConfigDef.Importance.LOW, SslConfigs.SSL_ENGINE_FACTORY_CLASS_DOC);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NjIyOA==", "bodyText": "We have other class configs like principal.builder.class which don't need this. Can you check without setting default value for the new config and see if it still causes tests to fail?", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404386228", "createdAt": "2020-04-06T21:02:33Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/security/authorizer/AclAuthorizer.scala", "diffHunk": "@@ -138,7 +139,14 @@ class AclAuthorizer extends Authorizer with Logging {\n   override def configure(javaConfigs: util.Map[String, _]): Unit = {\n     val configs = javaConfigs.asScala\n     val props = new java.util.Properties()\n-    configs.foreach { case (key, value) => props.put(key, value.toString) }\n+    configs.foreach { case (key, value) =>\n+      value match {\n+        case password: Password => props.put(key, password)\n+        case list: util.List[_] => props.put(key, list.asScala.map(_.toString).mkString(\",\"))\n+        case clazz: Class[_] => props.put(key, clazz.getName())\n+        case _ => props.put(key, value.toString)\n+      }\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDExMzI3Mg=="}, "originalCommit": {"oid": "7e47847cc0d4fd1ba2321a517ca26b1ef79d59ca"}, "originalPosition": 20}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35f77790963921929b3e2acc3b5a877af9cb846a", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/35f77790963921929b3e2acc3b5a877af9cb846a", "committedDate": "2020-04-06T22:01:47Z", "message": "Addressing most of the review comments so far except changing the default value for the ssl.engine.factory to be of Class type due to ~2000 test failures it results into"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf6aea4b2d941ca5cb4050eba4e28ddc1aaf0240", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/bf6aea4b2d941ca5cb4050eba4e28ddc1aaf0240", "committedDate": "2020-04-07T04:06:48Z", "message": "Moving default for ssl.engine.factory to code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abc889d82f3a2cee3a5596982a50adc1e753f75a", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/abc889d82f3a2cee3a5596982a50adc1e753f75a", "committedDate": "2020-04-07T04:09:40Z", "message": "Removing unused import in AclAuthorizer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf08ed8b8a508d28fbff97a74b5b6ac7e44b4a0d", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/bf08ed8b8a508d28fbff97a74b5b6ac7e44b4a0d", "committedDate": "2020-04-07T06:56:13Z", "message": "Adding tests for verifying custom ssl.engine.factory class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc498bb8bef9fe7857074a1f0258e3cb0b69fc83", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/cc498bb8bef9fe7857074a1f0258e3cb0b69fc83", "committedDate": "2020-04-07T07:53:54Z", "message": "Merge from trunk"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4OTUwNTY2", "url": "https://github.com/apache/kafka/pull/8338#pullrequestreview-388950566", "createdAt": "2020-04-07T09:39:17Z", "commit": {"oid": "cc498bb8bef9fe7857074a1f0258e3cb0b69fc83"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwOTozOToxN1rOGB7YYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwOTozOToxN1rOGB7YYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY3NDY1Ng==", "bodyText": "We could probably move this into TestSslUtils instead of duplicating in two tests.", "url": "https://github.com/apache/kafka/pull/8338#discussion_r404674656", "createdAt": "2020-04-07T09:39:17Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/test/java/org/apache/kafka/common/security/ssl/SslFactoryTest.java", "diffHunk": "@@ -379,4 +431,49 @@ public void testCertificateEntriesValidation() throws Exception {\n     private TestSslUtils.SslConfigsBuilder sslConfigsBuilder(Mode mode) {\n         return new TestSslUtils.SslConfigsBuilder(mode).tlsProtocol(tlsProtocol);\n     }\n+\n+    public static final class TestSslEngineFactory implements SslEngineFactory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc498bb8bef9fe7857074a1f0258e3cb0b69fc83"}, "originalPosition": 232}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e8dfd0438ac0cf0b655f665abb73938a5e8acfe", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/6e8dfd0438ac0cf0b655f665abb73938a5e8acfe", "committedDate": "2020-04-07T18:49:22Z", "message": "Moving TestSslEngineFactory to common TestSslUtils"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47dd951dfe7166a103c258958332238a5e7e0265", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/47dd951dfe7166a103c258958332238a5e7e0265", "committedDate": "2020-04-07T19:07:39Z", "message": "Removing unused imports from test class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15e6ec5575bf5f55d1f81c2ec738f25282f153ad", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/15e6ec5575bf5f55d1f81c2ec738f25282f153ad", "committedDate": "2020-04-08T00:30:28Z", "message": "Fixing checkstyle in KafkaLog4JAppender"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1636, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}