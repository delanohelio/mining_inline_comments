{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0NzA0NjY0", "number": 9714, "title": "MINOR: Remove connection id from Send and consolidate request/message utils", "bodyText": "Connection id is now only present in NetworkSend, which is now\nthe class used by Selector/NetworkClient/KafkaChannel (which\nworks well since NetworkReceive is the class used for\nreceived data).\nThe previous NetworkSend was also responsible for adding a size\nprefix. This logic is already present in SendBuilder, but for the\nminority of cases where SendBuilder is not used (including\na number of tests), we now have ByteBufferSend.sizePrefixed().\nWith regards to the request/message utilities:\n\nRenamed toByteBuffer/toBytes in MessageUtil to\ntoVersionPrefixedByteBuffer/toVersionPrefixedBytes for clarity.\nIntroduced new MessageUtil.toByteBuffer that does not include\nthe version as the prefix.\nRenamed serializeBody in AbstractRequest/Response to\nserialize for symmetry with parse.\nIntroduced RequestTestUtils and moved relevant methods from\nTestUtils.\nMoved serializeWithHeader methods that were only used in\ntests to RequestTestUtils.\nDeleted MessageTestUtil.\n\nFinally, a couple of changes to simplify coding patterns:\n\nAdded flip() and buffer() to ByteBufferAccessor.\nAdded MessageSizeAccumulator.sizeExcludingZeroCopy.\nUsed lambdas instead of TestCondition.\nUsed Arrays.copyOf instead of System.arraycopy in MessageUtil.\n\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-12-08T20:30:17Z", "url": "https://github.com/apache/kafka/pull/9714", "merged": true, "mergeCommit": {"oid": "1f98112e993bc4ae098936b1b0661fdb2c4b1880"}, "closed": true, "closedAt": "2020-12-09T19:15:59Z", "author": {"login": "ijuma"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdkQOdZgBqjQwODY2MzYyNDk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdkjZS-gFqTU0ODUwNDUxNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "23ebe94f61950394f474ed70e2c417ce34f60304", "author": {"user": {"login": "ijuma", "name": "Ismael Juma"}}, "url": "https://github.com/apache/kafka/commit/23ebe94f61950394f474ed70e2c417ce34f60304", "committedDate": "2020-12-08T20:29:40Z", "message": "MINOR: Remove connection id from Send and consolidate serialization utils"}, "afterCommit": {"oid": "87db298e186a9ec2e39acab57c0173982f8d5dc1", "author": {"user": {"login": "ijuma", "name": "Ismael Juma"}}, "url": "https://github.com/apache/kafka/commit/87db298e186a9ec2e39acab57c0173982f8d5dc1", "committedDate": "2020-12-08T20:32:30Z", "message": "MINOR: Remove connection id from Send and consolidate serialization utils"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b849c4cbb002801841b5c59c2cd67b2ffa78cee", "author": {"user": {"login": "ijuma", "name": "Ismael Juma"}}, "url": "https://github.com/apache/kafka/commit/9b849c4cbb002801841b5c59c2cd67b2ffa78cee", "committedDate": "2020-12-08T23:49:24Z", "message": "MINOR: Remove connection id from Send and consolidate serialization utils"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "87db298e186a9ec2e39acab57c0173982f8d5dc1", "author": {"user": {"login": "ijuma", "name": "Ismael Juma"}}, "url": "https://github.com/apache/kafka/commit/87db298e186a9ec2e39acab57c0173982f8d5dc1", "committedDate": "2020-12-08T20:32:30Z", "message": "MINOR: Remove connection id from Send and consolidate serialization utils"}, "afterCommit": {"oid": "9b849c4cbb002801841b5c59c2cd67b2ffa78cee", "author": {"user": {"login": "ijuma", "name": "Ismael Juma"}}, "url": "https://github.com/apache/kafka/commit/9b849c4cbb002801841b5c59c2cd67b2ffa78cee", "committedDate": "2020-12-08T23:49:24Z", "message": "MINOR: Remove connection id from Send and consolidate serialization utils"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59c1fffa25c461d20d03a65ad9eef6eaa3ab3d78", "author": {"user": {"login": "ijuma", "name": "Ismael Juma"}}, "url": "https://github.com/apache/kafka/commit/59c1fffa25c461d20d03a65ad9eef6eaa3ab3d78", "committedDate": "2020-12-09T03:50:15Z", "message": "Minor tweak"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3ODIwODA1", "url": "https://github.com/apache/kafka/pull/9714#pullrequestreview-547820805", "createdAt": "2020-12-09T04:09:07Z", "commit": {"oid": "59c1fffa25c461d20d03a65ad9eef6eaa3ab3d78"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNDowOTowN1rOICBZlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNDo1MTo0NFrOICCNew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk5MDk5OA==", "bodyText": "Why it need 4 byte if it exclude size prefix?", "url": "https://github.com/apache/kafka/pull/9714#discussion_r538990998", "createdAt": "2020-12-09T04:09:07Z", "author": {"login": "chia7712"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/RequestUtils.java", "diffHunk": "@@ -76,36 +75,22 @@ public static boolean hasTransactionalRecords(ProduceRequest request) {\n         return new AbstractMap.SimpleEntry<>(hasIdempotentRecords, hasTransactionalRecords);\n     }\n \n-    public static MessageSizeAccumulator size(\n-        ObjectSerializationCache serializationCache,\n-        Message header,\n-        short headerVersion,\n-        Message apiMessage,\n-        short apiVersion\n-    ) {\n-        MessageSizeAccumulator messageSize = new MessageSizeAccumulator();\n-        if (header != null)\n-            header.addSize(messageSize, serializationCache, headerVersion);\n-        apiMessage.addSize(messageSize, serializationCache, apiVersion);\n-        return messageSize;\n-    }\n-\n     public static ByteBuffer serialize(\n         Message header,\n         short headerVersion,\n         Message apiMessage,\n         short apiVersion\n     ) {\n-        ObjectSerializationCache serializationCache = new ObjectSerializationCache();\n-        MessageSizeAccumulator messageSize = RequestUtils.size(serializationCache, header, headerVersion, apiMessage, apiVersion);\n+        ObjectSerializationCache cache = new ObjectSerializationCache();\n+\n+        int headerSize = header.size(cache, headerVersion);\n+        int messageSize = apiMessage.size(cache, apiVersion);\n+        ByteBufferAccessor writable = new ByteBufferAccessor(ByteBuffer.allocate(4 + headerSize + messageSize));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59c1fffa25c461d20d03a65ad9eef6eaa3ab3d78"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk5NDA4OQ==", "bodyText": "This comment need to be updated.", "url": "https://github.com/apache/kafka/pull/9714#discussion_r538994089", "createdAt": "2020-12-09T04:18:45Z", "author": {"login": "chia7712"}, "path": "clients/src/main/java/org/apache/kafka/common/record/MultiRecordsSend.java", "diffHunk": "@@ -46,8 +45,7 @@\n      * Construct a MultiRecordsSend for the given destination from a queue of Send objects. The queue will be", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59c1fffa25c461d20d03a65ad9eef6eaa3ab3d78"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk5NDI4OQ==", "bodyText": "please remove \"destination\" from the docs", "url": "https://github.com/apache/kafka/pull/9714#discussion_r538994289", "createdAt": "2020-12-09T04:19:20Z", "author": {"login": "chia7712"}, "path": "clients/src/main/java/org/apache/kafka/common/network/Send.java", "diffHunk": "@@ -24,11 +24,6 @@\n  */\n public interface Send {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59c1fffa25c461d20d03a65ad9eef6eaa3ab3d78"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk5NjQwOA==", "bodyText": "line#955 already has connectionId.", "url": "https://github.com/apache/kafka/pull/9714#discussion_r538996408", "createdAt": "2020-12-09T04:26:20Z", "author": {"login": "chia7712"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -964,7 +963,7 @@ private[kafka] class Processor(val id: Int,\n     // removed from the Selector after discarding any pending staged receives.\n     // `openOrClosingChannel` can be None if the selector closed the connection because it was idle for too long\n     if (openOrClosingChannel(connectionId).isDefined) {\n-      selector.send(responseSend)\n+      selector.send(new NetworkSend(response.request.context.connectionId, responseSend))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59c1fffa25c461d20d03a65ad9eef6eaa3ab3d78"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk5NzUyOA==", "bodyText": "How about keeping \"parameterless\"? fewer changes and more clear.", "url": "https://github.com/apache/kafka/pull/9714#discussion_r538997528", "createdAt": "2020-12-09T04:30:04Z", "author": {"login": "chia7712"}, "path": "core/src/main/scala/kafka/network/SocketServer.scala", "diffHunk": "@@ -1134,11 +1133,11 @@ private[kafka] class Processor(val id: Int,\n         // Try unmuting the channel. If there was no quota violation and the channel has not been throttled,\n         // it will be unmuted immediately. If the channel has been throttled, it will unmuted only if the throttling\n         // delay has already passed by now.\n-        handleChannelMuteEvent(send.destination, ChannelMuteEvent.RESPONSE_SENT)\n-        tryUnmuteChannel(send.destination)\n+        handleChannelMuteEvent(send.destinationId(), ChannelMuteEvent.RESPONSE_SENT)\n+        tryUnmuteChannel(send.destinationId())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59c1fffa25c461d20d03a65ad9eef6eaa3ab3d78"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAwMjE4OQ==", "bodyText": "unused argument", "url": "https://github.com/apache/kafka/pull/9714#discussion_r539002189", "createdAt": "2020-12-09T04:44:58Z", "author": {"login": "chia7712"}, "path": "clients/src/test/java/org/apache/kafka/common/requests/RequestTestUtils.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.requests;\n+\n+import org.apache.kafka.common.Node;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.internals.Topic;\n+import org.apache.kafka.common.message.MetadataResponseData;\n+import org.apache.kafka.common.protocol.ApiKeys;\n+import org.apache.kafka.common.protocol.Errors;\n+import org.apache.kafka.common.protocol.ObjectSerializationCache;\n+import org.apache.kafka.common.record.RecordBatch;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+public class RequestTestUtils {\n+\n+    public static ByteBuffer serializeRequestHeader(RequestHeader header) {\n+        ObjectSerializationCache serializationCache = new ObjectSerializationCache();\n+        ByteBuffer buffer = ByteBuffer.allocate(header.size(serializationCache));\n+        header.write(buffer, serializationCache);\n+        buffer.flip();\n+        return buffer;\n+    }\n+\n+    public static ByteBuffer serializeRequestWithHeader(RequestHeader header, AbstractRequest request) {\n+        return RequestUtils.serialize(header.data(), header.headerVersion(), request.data(), request.version());\n+    }\n+\n+    public static ByteBuffer serializeResponseWithHeader(AbstractResponse response, short version, int correlationId) {\n+        return response.serializeWithHeader(new ResponseHeader(correlationId,\n+            response.apiKey().responseHeaderVersion(version)), version);\n+    }\n+\n+    public static MetadataResponse metadataResponse(Collection<Node> brokers,\n+                                                    String clusterId, int controllerId,\n+                                                    List<MetadataResponse.TopicMetadata> topicMetadataList) {\n+        return metadataResponse(MetadataResponse.DEFAULT_THROTTLE_TIME, brokers, clusterId, controllerId,\n+                topicMetadataList, MetadataResponse.AUTHORIZED_OPERATIONS_OMITTED);\n+    }\n+\n+    public static MetadataResponse metadataResponse(int throttleTimeMs, Collection<Node> brokers,\n+                                                    String clusterId, int controllerId,\n+                                                    List<MetadataResponse.TopicMetadata> topicMetadatas,\n+                                                    int clusterAuthorizedOperations) {\n+        List<MetadataResponseData.MetadataResponseTopic> topics = new ArrayList<>();\n+        topicMetadatas.forEach(topicMetadata -> {\n+            MetadataResponseData.MetadataResponseTopic metadataResponseTopic = new MetadataResponseData.MetadataResponseTopic();\n+            metadataResponseTopic\n+                    .setErrorCode(topicMetadata.error().code())\n+                    .setName(topicMetadata.topic())\n+                    .setIsInternal(topicMetadata.isInternal())\n+                    .setTopicAuthorizedOperations(topicMetadata.authorizedOperations());\n+\n+            for (MetadataResponse.PartitionMetadata partitionMetadata : topicMetadata.partitionMetadata()) {\n+                metadataResponseTopic.partitions().add(new MetadataResponseData.MetadataResponsePartition()\n+                        .setErrorCode(partitionMetadata.error.code())\n+                        .setPartitionIndex(partitionMetadata.partition())\n+                        .setLeaderId(partitionMetadata.leaderId.orElse(MetadataResponse.NO_LEADER_ID))\n+                        .setLeaderEpoch(partitionMetadata.leaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH))\n+                        .setReplicaNodes(partitionMetadata.replicaIds)\n+                        .setIsrNodes(partitionMetadata.inSyncReplicaIds)\n+                        .setOfflineReplicas(partitionMetadata.offlineReplicaIds));\n+            }\n+            topics.add(metadataResponseTopic);\n+        });\n+        return MetadataResponse.prepareResponse(true, throttleTimeMs, brokers, clusterId, controllerId,\n+                topics, clusterAuthorizedOperations); }\n+\n+    public static MetadataResponse metadataUpdateWith(final int numNodes,\n+                                                      final Map<String, Integer> topicPartitionCounts) {\n+        return metadataUpdateWith(\"kafka-cluster\", numNodes, topicPartitionCounts);\n+    }\n+\n+    public static MetadataResponse metadataUpdateWith(final int numNodes,\n+                                                      final Map<String, Integer> topicPartitionCounts,\n+                                                      final Function<TopicPartition, Integer> epochSupplier) {\n+        return metadataUpdateWith(\"kafka-cluster\", numNodes, Collections.emptyMap(),\n+                topicPartitionCounts, epochSupplier, MetadataResponse.PartitionMetadata::new, ApiKeys.METADATA.latestVersion());\n+    }\n+\n+    public static MetadataResponse metadataUpdateWith(final String clusterId,\n+                                                      final int numNodes,\n+                                                      final Map<String, Integer> topicPartitionCounts) {\n+        return metadataUpdateWith(clusterId, numNodes, Collections.emptyMap(),\n+                topicPartitionCounts, tp -> null, MetadataResponse.PartitionMetadata::new, ApiKeys.METADATA.latestVersion());\n+    }\n+\n+    public static MetadataResponse metadataUpdateWith(final String clusterId,\n+                                                      final int numNodes,\n+                                                      final Map<String, Errors> topicErrors,\n+                                                      final Map<String, Integer> topicPartitionCounts) {\n+        return metadataUpdateWith(clusterId, numNodes, topicErrors,\n+                topicPartitionCounts, tp -> null, MetadataResponse.PartitionMetadata::new, ApiKeys.METADATA.latestVersion());\n+    }\n+\n+    public static MetadataResponse metadataUpdateWith(final String clusterId,\n+                                                      final int numNodes,\n+                                                      final Map<String, Errors> topicErrors,\n+                                                      final Map<String, Integer> topicPartitionCounts,\n+                                                      final short responseVersion) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59c1fffa25c461d20d03a65ad9eef6eaa3ab3d78"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAwNDI4Mw==", "bodyText": "RequestHeader#write has only 2 usages and both of them are in test scope. It should be fine to remove RequestHeader#write from production.", "url": "https://github.com/apache/kafka/pull/9714#discussion_r539004283", "createdAt": "2020-12-09T04:51:44Z", "author": {"login": "chia7712"}, "path": "clients/src/test/java/org/apache/kafka/common/requests/RequestTestUtils.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.requests;\n+\n+import org.apache.kafka.common.Node;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.internals.Topic;\n+import org.apache.kafka.common.message.MetadataResponseData;\n+import org.apache.kafka.common.protocol.ApiKeys;\n+import org.apache.kafka.common.protocol.Errors;\n+import org.apache.kafka.common.protocol.ObjectSerializationCache;\n+import org.apache.kafka.common.record.RecordBatch;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+public class RequestTestUtils {\n+\n+    public static ByteBuffer serializeRequestHeader(RequestHeader header) {\n+        ObjectSerializationCache serializationCache = new ObjectSerializationCache();\n+        ByteBuffer buffer = ByteBuffer.allocate(header.size(serializationCache));\n+        header.write(buffer, serializationCache);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "59c1fffa25c461d20d03a65ad9eef6eaa3ab3d78"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13c7d5c2518d0d5e4272c23209f789ad0a383c95", "author": {"user": {"login": "ijuma", "name": "Ismael Juma"}}, "url": "https://github.com/apache/kafka/commit/13c7d5c2518d0d5e4272c23209f789ad0a383c95", "committedDate": "2020-12-09T05:38:05Z", "message": "Comment updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1db89cde51599d859d24483b9c0ce2a1690b008", "author": {"user": {"login": "ijuma", "name": "Ismael Juma"}}, "url": "https://github.com/apache/kafka/commit/c1db89cde51599d859d24483b9c0ce2a1690b008", "committedDate": "2020-12-09T05:38:39Z", "message": "Fix 4 bytes wasted in `RequestUtils.serialize`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b164ecab501fd4cbf051ad1492b7192bf6e92aca", "author": {"user": {"login": "ijuma", "name": "Ismael Juma"}}, "url": "https://github.com/apache/kafka/commit/b164ecab501fd4cbf051ad1492b7192bf6e92aca", "committedDate": "2020-12-09T05:39:04Z", "message": "Remove unnecessary `rewind` calls"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "742ea7dc11c33c00b74ca0b742e894a0de72f2bd", "author": {"user": {"login": "ijuma", "name": "Ismael Juma"}}, "url": "https://github.com/apache/kafka/commit/742ea7dc11c33c00b74ca0b742e894a0de72f2bd", "committedDate": "2020-12-09T05:39:42Z", "message": "Use responseVersion in RequestTestUtils.metadataResponse"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f00dbe332cc4ccacab55a5fd1804e22b0ec62722", "author": {"user": {"login": "ijuma", "name": "Ismael Juma"}}, "url": "https://github.com/apache/kafka/commit/f00dbe332cc4ccacab55a5fd1804e22b0ec62722", "committedDate": "2020-12-09T05:40:01Z", "message": "Style fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3ODk2NTAw", "url": "https://github.com/apache/kafka/pull/9714#pullrequestreview-547896500", "createdAt": "2020-12-09T07:16:49Z", "commit": {"oid": "f00dbe332cc4ccacab55a5fd1804e22b0ec62722"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNzoxNjo0OVrOICF0CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNzoxNjo0OVrOICF0CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA2MzMwNQ==", "bodyText": "How about making SizeDelimitedSend be a static method in ByteBufferSend? For example:\n    public static Send withSizeDelimited(ByteBuffer buffer) {\n        ByteBuffer sizeBuffer = ByteBuffer.allocate(4);\n        sizeBuffer.putInt(0, buffer.remaining());\n        return new ByteBufferSend(sizeBuffer, buffer);\n    }", "url": "https://github.com/apache/kafka/pull/9714#discussion_r539063305", "createdAt": "2020-12-09T07:16:49Z", "author": {"login": "chia7712"}, "path": "clients/src/main/java/org/apache/kafka/common/network/SizeDelimitedSend.java", "diffHunk": "@@ -14,18 +14,22 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-\n-package org.apache.kafka.common.protocol;\n+package org.apache.kafka.common.network;\n \n import java.nio.ByteBuffer;\n \n-public final class MessageTestUtil {\n-    public static ByteBuffer messageToByteBuffer(Message message, short version) {\n-        ObjectSerializationCache cache = new ObjectSerializationCache();\n-        int size = message.size(cache, version);\n-        ByteBuffer bytes = ByteBuffer.allocate(size);\n-        message.write(new ByteBufferAccessor(bytes), cache, version);\n-        bytes.rewind();\n-        return bytes;\n+/**\n+ * A size delimited Send that consists of a 4 byte network-ordered size N followed by N bytes of content.\n+ */\n+public class SizeDelimitedSend extends ByteBufferSend {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f00dbe332cc4ccacab55a5fd1804e22b0ec62722"}, "originalPosition": 21}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e86ed57b683688e56b031287b0588284935e78cc", "author": {"user": {"login": "ijuma", "name": "Ismael Juma"}}, "url": "https://github.com/apache/kafka/commit/e86ed57b683688e56b031287b0588284935e78cc", "committedDate": "2020-12-09T13:51:17Z", "message": "Replace SizeDelimitedSend with ByteBufferSend.sizePrefixed static factory method"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4NTA0NTE2", "url": "https://github.com/apache/kafka/pull/9714#pullrequestreview-548504516", "createdAt": "2020-12-09T18:52:49Z", "commit": {"oid": "e86ed57b683688e56b031287b0588284935e78cc"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2597, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}