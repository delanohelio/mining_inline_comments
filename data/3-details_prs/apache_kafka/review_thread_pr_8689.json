{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5NzcxNjc0", "number": 8689, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoyMzozMlrOD9kmGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNDo1Nzo1NVrOD91piQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1ODg5MzA3OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignorTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoyMzozMlrOGXJafQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNDo1MTo1NVrOGXkVxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyNDY2OQ==", "bodyText": "This name seemed not correct.", "url": "https://github.com/apache/kafka/pull/8689#discussion_r426924669", "createdAt": "2020-05-18T22:23:32Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignorTest.java", "diffHunk": "@@ -170,7 +171,7 @@ public void shouldAssignActiveStatefulTasksEvenlyOverUnevenlyDistributedStreamTh\n     }\n \n     @Test\n-    public void shouldAssignActiveStatefulTasksEvenlyOverClientsWithLessClientsThanTasks() {\n+    public void shouldAssignActiveStatefulTasksEvenlyOverClientsWithMoreClientsThanTasks() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58ac3c1eb20f867eb10e4b7a089f6ee026010e86"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM2NTgzMQ==", "bodyText": "Huh, good catch!", "url": "https://github.com/apache/kafka/pull/8689#discussion_r427365831", "createdAt": "2020-05-19T14:51:55Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignorTest.java", "diffHunk": "@@ -170,7 +171,7 @@ public void shouldAssignActiveStatefulTasksEvenlyOverUnevenlyDistributedStreamTh\n     }\n \n     @Test\n-    public void shouldAssignActiveStatefulTasksEvenlyOverClientsWithLessClientsThanTasks() {\n+    public void shouldAssignActiveStatefulTasksEvenlyOverClientsWithMoreClientsThanTasks() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyNDY2OQ=="}, "originalCommit": {"oid": "58ac3c1eb20f867eb10e4b7a089f6ee026010e86"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MTY4NzEzOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNDo1Nzo1NVrOGXkoww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNDo1Nzo1NVrOGXkoww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM3MDY5MQ==", "bodyText": "If we expect no warmups, we can assert it here with:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertValidAssignment(0, allTaskIds.size() / 3 + 1, allTaskIds, emptySet(), clientStates, new StringBuilder());\n          \n          \n            \n                    assertValidAssignment(0, allTaskIds, emptySet(), clientStates, new StringBuilder());", "url": "https://github.com/apache/kafka/pull/8689#discussion_r427370691", "createdAt": "2020-05-19T14:57:55Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignorTest.java", "diffHunk": "@@ -213,6 +214,61 @@ public void shouldAssignActiveStatefulTasksEvenlyOverClientsAndStreamThreadsWith\n         assertBalancedTasks(clientStates);\n     }\n \n+    @Test\n+    public void shouldAssignWarmUpTasksIfStatefulActiveTasksBalancedOverStreamThreadsButNotOverClients() {\n+        final Set<TaskId> allTaskIds = mkSet(TASK_0_0, TASK_0_1, TASK_1_0, TASK_1_1);\n+        final Map<TaskId, Long> lagsForCaughtUpClient = allTaskIds.stream().collect(Collectors.toMap(k -> k, k -> 0L));\n+        final Map<TaskId, Long> lagsForNotCaughtUpClient =\n+            allTaskIds.stream().collect(Collectors.toMap(k -> k, k -> Long.MAX_VALUE));\n+        final ClientState caughtUpClientState = new ClientState(allTaskIds, emptySet(), lagsForCaughtUpClient, 5);\n+        final ClientState notCaughtUpClientState1 = new ClientState(emptySet(), emptySet(), lagsForNotCaughtUpClient, 5);\n+        final ClientState notCaughtUpClientState2 = new ClientState(emptySet(), emptySet(), lagsForNotCaughtUpClient, 5);\n+        final Map<UUID, ClientState> clientStates =\n+            getClientStatesMap(caughtUpClientState, notCaughtUpClientState1, notCaughtUpClientState2);\n+        final boolean unstable = new HighAvailabilityTaskAssignor().assign(\n+            clientStates,\n+            allTaskIds,\n+            allTaskIds,\n+            new AssignmentConfigs(0L, allTaskIds.size() / 3 + 1, 0, 0L)\n+        );\n+\n+        assertThat(unstable, is(true));\n+        assertThat(notCaughtUpClientState1.standbyTaskCount(), greaterThanOrEqualTo(allTaskIds.size() / 3));\n+        assertThat(notCaughtUpClientState2.standbyTaskCount(), greaterThanOrEqualTo(allTaskIds.size() / 3));\n+        assertValidAssignment(0, allTaskIds.size() / 3 + 1, allTaskIds, emptySet(), clientStates, new StringBuilder());\n+    }\n+\n+    @Test\n+    public void shouldEvenlyAssignActiveStatefulTasksIfClientsAreWarmedUpToBalanceTaskOverClients() {\n+        final Set<TaskId> allTaskIds = mkSet(TASK_0_0, TASK_0_1, TASK_1_0, TASK_1_1);\n+        final Set<TaskId> warmedUpTaskIds1 = mkSet(TASK_0_1);\n+        final Set<TaskId> warmedUpTaskIds2 = mkSet(TASK_1_0);\n+        final Map<TaskId, Long> lagsForCaughtUpClient = allTaskIds.stream().collect(Collectors.toMap(k -> k, k -> 0L));\n+        final Map<TaskId, Long> lagsForWarmedUpClient1 =\n+            allTaskIds.stream().collect(Collectors.toMap(k -> k, k -> Long.MAX_VALUE));\n+        lagsForWarmedUpClient1.put(TASK_0_1, 0L);\n+        final Map<TaskId, Long> lagsForWarmedUpClient2 =\n+            allTaskIds.stream().collect(Collectors.toMap(k -> k, k -> Long.MAX_VALUE));\n+        lagsForWarmedUpClient2.put(TASK_1_0, 0L);\n+        final ClientState caughtUpClientState = new ClientState(allTaskIds, emptySet(), lagsForCaughtUpClient, 5);\n+        final ClientState warmedUpClientState1 = new ClientState(emptySet(), warmedUpTaskIds1, lagsForWarmedUpClient1, 5);\n+        final ClientState warmedUpClientState2 = new ClientState(emptySet(), warmedUpTaskIds2, lagsForWarmedUpClient2, 5);\n+        final Map<UUID, ClientState> clientStates =\n+            getClientStatesMap(caughtUpClientState, warmedUpClientState1, warmedUpClientState2);\n+        final boolean unstable = new HighAvailabilityTaskAssignor().assign(\n+            clientStates,\n+            allTaskIds,\n+            allTaskIds,\n+            new AssignmentConfigs(0L, allTaskIds.size() / 3 + 1, 0, 0L)\n+        );\n+\n+        assertThat(unstable, is(false));\n+        assertValidAssignment(0, allTaskIds.size() / 3 + 1, allTaskIds, emptySet(), clientStates, new StringBuilder());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58ac3c1eb20f867eb10e4b7a089f6ee026010e86"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2665, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}