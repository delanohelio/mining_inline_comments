{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5ODkyNzg2", "number": 8569, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwNzoyOTo1M1rOD3D5Pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQyMTozMzo0NVrOD8qE0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MDYyMDc4OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/metrics/LinuxIoMetricsCollector.scala", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwNzoyOTo1M1rOGNGiEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQwNDo1ODoxN1rOGTAiXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM5MTY5OQ==", "bodyText": "Nit: do you think the lock should be hold while reading /proc, or restricted to the update of lastUpdateMs, cachedReadBytes and cachedWriteBytes?", "url": "https://github.com/apache/kafka/pull/8569#discussion_r416391699", "createdAt": "2020-04-28T07:29:53Z", "author": {"login": "Hangleton"}, "path": "core/src/main/scala/kafka/metrics/LinuxIoMetricsCollector.scala", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.nio.file.{Files, Paths}\n+\n+import org.apache.kafka.common.utils.Time\n+import org.slf4j.Logger\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Retrieves Linux /proc/self/io metrics.\n+ */\n+class LinuxIoMetricsCollector(val procPath: String, val time: Time, val logger: Logger) {\n+  import LinuxIoMetricsCollector._\n+  var lastUpdateMs = -1L\n+  var cachedReadBytes = 0L\n+  var cachedWriteBytes = 0L\n+\n+  def readBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {\n+      updateValues(curMs)\n+    }\n+    cachedReadBytes\n+  }\n+\n+  def writeBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {\n+      updateValues(curMs)\n+    }\n+    cachedWriteBytes\n+  }\n+\n+  /**\n+   * Read /proc/self/io.\n+   *\n+   * Generally, each line in this file contains a prefix followed by a colon and a number.\n+   *\n+   * For example, it might contain this:\n+   * rchar: 4052\n+   * wchar: 0\n+   * syscr: 13\n+   * syscw: 0\n+   * read_bytes: 0\n+   * write_bytes: 0\n+   * cancelled_write_bytes: 0\n+   */\n+  def updateValues(now: Long): Boolean = this.synchronized {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MTUyMw==", "bodyText": "Unless we choose to read this file in a background thread, there isn't a reason to avoid using a lock here.", "url": "https://github.com/apache/kafka/pull/8569#discussion_r416961523", "createdAt": "2020-04-28T22:27:13Z", "author": {"login": "cmccabe"}, "path": "core/src/main/scala/kafka/metrics/LinuxIoMetricsCollector.scala", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.nio.file.{Files, Paths}\n+\n+import org.apache.kafka.common.utils.Time\n+import org.slf4j.Logger\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Retrieves Linux /proc/self/io metrics.\n+ */\n+class LinuxIoMetricsCollector(val procPath: String, val time: Time, val logger: Logger) {\n+  import LinuxIoMetricsCollector._\n+  var lastUpdateMs = -1L\n+  var cachedReadBytes = 0L\n+  var cachedWriteBytes = 0L\n+\n+  def readBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {\n+      updateValues(curMs)\n+    }\n+    cachedReadBytes\n+  }\n+\n+  def writeBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {\n+      updateValues(curMs)\n+    }\n+    cachedWriteBytes\n+  }\n+\n+  /**\n+   * Read /proc/self/io.\n+   *\n+   * Generally, each line in this file contains a prefix followed by a colon and a number.\n+   *\n+   * For example, it might contain this:\n+   * rchar: 4052\n+   * wchar: 0\n+   * syscr: 13\n+   * syscw: 0\n+   * read_bytes: 0\n+   * write_bytes: 0\n+   * cancelled_write_bytes: 0\n+   */\n+  def updateValues(now: Long): Boolean = this.synchronized {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM5MTY5OQ=="}, "originalCommit": null, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEwNzc3Nw==", "bodyText": "What I meant is not avoid the usage of a lock but restrict its scope to put it outside of the invocation of Files#readline.\nThe motivation for this is in case of I/O stall, that invocation may block for a long time (until the kernel times the operation out), with consequences for other pretendant to acquire the lock.\nThat said the invocation is on the readBytes/writeBytes metrics path, so in fine it doesn't matter.", "url": "https://github.com/apache/kafka/pull/8569#discussion_r417107777", "createdAt": "2020-04-29T07:08:09Z", "author": {"login": "Hangleton"}, "path": "core/src/main/scala/kafka/metrics/LinuxIoMetricsCollector.scala", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.nio.file.{Files, Paths}\n+\n+import org.apache.kafka.common.utils.Time\n+import org.slf4j.Logger\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Retrieves Linux /proc/self/io metrics.\n+ */\n+class LinuxIoMetricsCollector(val procPath: String, val time: Time, val logger: Logger) {\n+  import LinuxIoMetricsCollector._\n+  var lastUpdateMs = -1L\n+  var cachedReadBytes = 0L\n+  var cachedWriteBytes = 0L\n+\n+  def readBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {\n+      updateValues(curMs)\n+    }\n+    cachedReadBytes\n+  }\n+\n+  def writeBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {\n+      updateValues(curMs)\n+    }\n+    cachedWriteBytes\n+  }\n+\n+  /**\n+   * Read /proc/self/io.\n+   *\n+   * Generally, each line in this file contains a prefix followed by a colon and a number.\n+   *\n+   * For example, it might contain this:\n+   * rchar: 4052\n+   * wchar: 0\n+   * syscr: 13\n+   * syscw: 0\n+   * read_bytes: 0\n+   * write_bytes: 0\n+   * cancelled_write_bytes: 0\n+   */\n+  def updateValues(now: Long): Boolean = this.synchronized {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM5MTY5OQ=="}, "originalCommit": null, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4NDgyOQ==", "bodyText": "Assuming there's no background refresh thread, the only thread that is reading from /proc is the thread calling readBytes.  So you still have to wait for that read, whether or not you use a lock here.", "url": "https://github.com/apache/kafka/pull/8569#discussion_r422584829", "createdAt": "2020-05-10T04:57:19Z", "author": {"login": "cmccabe"}, "path": "core/src/main/scala/kafka/metrics/LinuxIoMetricsCollector.scala", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.nio.file.{Files, Paths}\n+\n+import org.apache.kafka.common.utils.Time\n+import org.slf4j.Logger\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Retrieves Linux /proc/self/io metrics.\n+ */\n+class LinuxIoMetricsCollector(val procPath: String, val time: Time, val logger: Logger) {\n+  import LinuxIoMetricsCollector._\n+  var lastUpdateMs = -1L\n+  var cachedReadBytes = 0L\n+  var cachedWriteBytes = 0L\n+\n+  def readBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {\n+      updateValues(curMs)\n+    }\n+    cachedReadBytes\n+  }\n+\n+  def writeBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {\n+      updateValues(curMs)\n+    }\n+    cachedWriteBytes\n+  }\n+\n+  /**\n+   * Read /proc/self/io.\n+   *\n+   * Generally, each line in this file contains a prefix followed by a colon and a number.\n+   *\n+   * For example, it might contain this:\n+   * rchar: 4052\n+   * wchar: 0\n+   * syscr: 13\n+   * syscw: 0\n+   * read_bytes: 0\n+   * write_bytes: 0\n+   * cancelled_write_bytes: 0\n+   */\n+  def updateValues(now: Long): Boolean = this.synchronized {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM5MTY5OQ=="}, "originalCommit": null, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4NDkyNA==", "bodyText": "Also there is not going to be an I/O stall reading from /proc since /proc is not a real disk.  I would still prefer to do fewer system calls rather than more, but I don't think that's worth adding a background thread for.", "url": "https://github.com/apache/kafka/pull/8569#discussion_r422584924", "createdAt": "2020-05-10T04:58:17Z", "author": {"login": "cmccabe"}, "path": "core/src/main/scala/kafka/metrics/LinuxIoMetricsCollector.scala", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.nio.file.{Files, Paths}\n+\n+import org.apache.kafka.common.utils.Time\n+import org.slf4j.Logger\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Retrieves Linux /proc/self/io metrics.\n+ */\n+class LinuxIoMetricsCollector(val procPath: String, val time: Time, val logger: Logger) {\n+  import LinuxIoMetricsCollector._\n+  var lastUpdateMs = -1L\n+  var cachedReadBytes = 0L\n+  var cachedWriteBytes = 0L\n+\n+  def readBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {\n+      updateValues(curMs)\n+    }\n+    cachedReadBytes\n+  }\n+\n+  def writeBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {\n+      updateValues(curMs)\n+    }\n+    cachedWriteBytes\n+  }\n+\n+  /**\n+   * Read /proc/self/io.\n+   *\n+   * Generally, each line in this file contains a prefix followed by a colon and a number.\n+   *\n+   * For example, it might contain this:\n+   * rchar: 4052\n+   * wchar: 0\n+   * syscr: 13\n+   * syscw: 0\n+   * read_bytes: 0\n+   * write_bytes: 0\n+   * cancelled_write_bytes: 0\n+   */\n+  def updateValues(now: Long): Boolean = this.synchronized {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM5MTY5OQ=="}, "originalCommit": null, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNDE2MDc1OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/metrics/LinuxIoMetricsCollector.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMzo1MzoxMlrOGR_pAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQwNTowNDo1MFrOGTAkQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUyMTY2Nw==", "bodyText": "This prints a stacktrace at startup when not on Linux. I wonder if we should check if /proc exists and only print a stacktrace if it exists and we can't read it. WDYT?", "url": "https://github.com/apache/kafka/pull/8569#discussion_r421521667", "createdAt": "2020-05-07T13:53:12Z", "author": {"login": "mimaison"}, "path": "core/src/main/scala/kafka/metrics/LinuxIoMetricsCollector.scala", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.nio.file.{Files, Paths}\n+\n+import org.apache.kafka.common.utils.Time\n+import org.slf4j.Logger\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Retrieves Linux /proc/self/io metrics.\n+ */\n+class LinuxIoMetricsCollector(val procPath: String, val time: Time, val logger: Logger) {\n+  import LinuxIoMetricsCollector._\n+  var lastUpdateMs = -1L\n+  var cachedReadBytes = 0L\n+  var cachedWriteBytes = 0L\n+\n+  def readBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {\n+      updateValues(curMs)\n+    }\n+    cachedReadBytes\n+  }\n+\n+  def writeBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {\n+      updateValues(curMs)\n+    }\n+    cachedWriteBytes\n+  }\n+\n+  /**\n+   * Read /proc/self/io.\n+   *\n+   * Generally, each line in this file contains a prefix followed by a colon and a number.\n+   *\n+   * For example, it might contain this:\n+   * rchar: 4052\n+   * wchar: 0\n+   * syscr: 13\n+   * syscw: 0\n+   * read_bytes: 0\n+   * write_bytes: 0\n+   * cancelled_write_bytes: 0\n+   */\n+  def updateValues(now: Long): Boolean = this.synchronized {\n+    try {\n+      cachedReadBytes = -1\n+      cachedWriteBytes = -1\n+      val lines = Files.readAllLines(Paths.get(procPath, \"self\", \"io\")).asScala\n+      lines.foreach(line => {\n+        if (line.startsWith(READ_BYTES_PREFIX)) {\n+          cachedReadBytes = line.substring(READ_BYTES_PREFIX.size).toLong\n+        } else if (line.startsWith(WRITE_BYTES_PREFIX)) {\n+          cachedWriteBytes = line.substring(WRITE_BYTES_PREFIX.size).toLong\n+        }\n+      })\n+      lastUpdateMs = now\n+      true\n+    } catch {\n+      case t: Throwable => {\n+        logger.warn(\"LinuxIoMetricsCollector: unable to update metrics\", t)\n+        false\n+      }\n+    }\n+  }\n+\n+  def usable(): Boolean = {\n+    updateValues(time.milliseconds())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4NTQwOA==", "bodyText": "Good point.  I will add a check.", "url": "https://github.com/apache/kafka/pull/8569#discussion_r422585408", "createdAt": "2020-05-10T05:04:50Z", "author": {"login": "cmccabe"}, "path": "core/src/main/scala/kafka/metrics/LinuxIoMetricsCollector.scala", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.nio.file.{Files, Paths}\n+\n+import org.apache.kafka.common.utils.Time\n+import org.slf4j.Logger\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Retrieves Linux /proc/self/io metrics.\n+ */\n+class LinuxIoMetricsCollector(val procPath: String, val time: Time, val logger: Logger) {\n+  import LinuxIoMetricsCollector._\n+  var lastUpdateMs = -1L\n+  var cachedReadBytes = 0L\n+  var cachedWriteBytes = 0L\n+\n+  def readBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {\n+      updateValues(curMs)\n+    }\n+    cachedReadBytes\n+  }\n+\n+  def writeBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {\n+      updateValues(curMs)\n+    }\n+    cachedWriteBytes\n+  }\n+\n+  /**\n+   * Read /proc/self/io.\n+   *\n+   * Generally, each line in this file contains a prefix followed by a colon and a number.\n+   *\n+   * For example, it might contain this:\n+   * rchar: 4052\n+   * wchar: 0\n+   * syscr: 13\n+   * syscw: 0\n+   * read_bytes: 0\n+   * write_bytes: 0\n+   * cancelled_write_bytes: 0\n+   */\n+  def updateValues(now: Long): Boolean = this.synchronized {\n+    try {\n+      cachedReadBytes = -1\n+      cachedWriteBytes = -1\n+      val lines = Files.readAllLines(Paths.get(procPath, \"self\", \"io\")).asScala\n+      lines.foreach(line => {\n+        if (line.startsWith(READ_BYTES_PREFIX)) {\n+          cachedReadBytes = line.substring(READ_BYTES_PREFIX.size).toLong\n+        } else if (line.startsWith(WRITE_BYTES_PREFIX)) {\n+          cachedWriteBytes = line.substring(WRITE_BYTES_PREFIX.size).toLong\n+        }\n+      })\n+      lastUpdateMs = now\n+      true\n+    } catch {\n+      case t: Throwable => {\n+        logger.warn(\"LinuxIoMetricsCollector: unable to update metrics\", t)\n+        false\n+      }\n+    }\n+  }\n+\n+  def usable(): Boolean = {\n+    updateValues(time.milliseconds())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUyMTY2Nw=="}, "originalCommit": null, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNDE4MzcxOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/metrics/LinuxIoMetricsCollector.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMzo1Nzo1N1rOGR_3TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQwNTowNjozMlrOGTAk1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUyNTMyNA==", "bodyText": "Should we have add small jitter to lastUpdateMs as both metrics should trigger around the same time, ie\nif (curMs > lastUpdateMs + 100) {", "url": "https://github.com/apache/kafka/pull/8569#discussion_r421525324", "createdAt": "2020-05-07T13:57:57Z", "author": {"login": "mimaison"}, "path": "core/src/main/scala/kafka/metrics/LinuxIoMetricsCollector.scala", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.nio.file.{Files, Paths}\n+\n+import org.apache.kafka.common.utils.Time\n+import org.slf4j.Logger\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Retrieves Linux /proc/self/io metrics.\n+ */\n+class LinuxIoMetricsCollector(val procPath: String, val time: Time, val logger: Logger) {\n+  import LinuxIoMetricsCollector._\n+  var lastUpdateMs = -1L\n+  var cachedReadBytes = 0L\n+  var cachedWriteBytes = 0L\n+\n+  def readBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4NTU1OQ==", "bodyText": "This code is just there to prevent reading from proc more than once a millisecond.  I expect in practice we will read fewer times since we only read when the metrics values are fetched.", "url": "https://github.com/apache/kafka/pull/8569#discussion_r422585559", "createdAt": "2020-05-10T05:06:32Z", "author": {"login": "cmccabe"}, "path": "core/src/main/scala/kafka/metrics/LinuxIoMetricsCollector.scala", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.nio.file.{Files, Paths}\n+\n+import org.apache.kafka.common.utils.Time\n+import org.slf4j.Logger\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Retrieves Linux /proc/self/io metrics.\n+ */\n+class LinuxIoMetricsCollector(val procPath: String, val time: Time, val logger: Logger) {\n+  import LinuxIoMetricsCollector._\n+  var lastUpdateMs = -1L\n+  var cachedReadBytes = 0L\n+  var cachedWriteBytes = 0L\n+\n+  def readBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()\n+    if (curMs != lastUpdateMs) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUyNTMyNA=="}, "originalCommit": null, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0OTMwNTE1OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/metrics/LinuxIoMetricsCollector.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQyMTozMzo0NVrOGVvCMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxODoxMjo1N1rOGXCVUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ0Mzg4OQ==", "bodyText": "minor nit: could move the time check to the updateValues method since that's where lastUpdateMs is set?", "url": "https://github.com/apache/kafka/pull/8569#discussion_r425443889", "createdAt": "2020-05-14T21:33:45Z", "author": {"login": "mumrah"}, "path": "core/src/main/scala/kafka/metrics/LinuxIoMetricsCollector.scala", "diffHunk": "@@ -0,0 +1,102 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.nio.file.{Files, Paths}\n+\n+import org.apache.kafka.common.utils.Time\n+import org.slf4j.Logger\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Retrieves Linux /proc/self/io metrics.\n+ */\n+class LinuxIoMetricsCollector(procRoot: String, val time: Time, val logger: Logger) {\n+  import LinuxIoMetricsCollector._\n+  var lastUpdateMs = -1L\n+  var cachedReadBytes = 0L\n+  var cachedWriteBytes = 0L\n+  val path = Paths.get(procRoot, \"self\", \"io\")\n+\n+  def readBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ff17cc0ab0961ff8eda2d75fb53faef7cfa4396"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwODY1Nw==", "bodyText": "Interesting idea, but that would complicate the usable function, right?  Probably better to leave it where it is.", "url": "https://github.com/apache/kafka/pull/8569#discussion_r426808657", "createdAt": "2020-05-18T18:12:57Z", "author": {"login": "cmccabe"}, "path": "core/src/main/scala/kafka/metrics/LinuxIoMetricsCollector.scala", "diffHunk": "@@ -0,0 +1,102 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.server\n+\n+import java.nio.file.{Files, Paths}\n+\n+import org.apache.kafka.common.utils.Time\n+import org.slf4j.Logger\n+\n+import scala.jdk.CollectionConverters._\n+\n+/**\n+ * Retrieves Linux /proc/self/io metrics.\n+ */\n+class LinuxIoMetricsCollector(procRoot: String, val time: Time, val logger: Logger) {\n+  import LinuxIoMetricsCollector._\n+  var lastUpdateMs = -1L\n+  var cachedReadBytes = 0L\n+  var cachedWriteBytes = 0L\n+  val path = Paths.get(procRoot, \"self\", \"io\")\n+\n+  def readBytes(): Long = this.synchronized {\n+    val curMs = time.milliseconds()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTQ0Mzg4OQ=="}, "originalCommit": {"oid": "8ff17cc0ab0961ff8eda2d75fb53faef7cfa4396"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2814, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}