{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIxOTA0OTQ2", "number": 9600, "title": "KAFKA-10674: Controller API version bond with forwardable APIs", "bodyText": "To make sure the forwarded request could be properly handled by the controller, when forwarding is enabled, we should acquire the controller API versions to enforce as joint constraints back to the client.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-11-16T19:50:48Z", "url": "https://github.com/apache/kafka/pull/9600", "merged": true, "mergeCommit": {"oid": "bfc96efa3a9a004f963cd4913fb2875c84bc9cb8"}, "closed": true, "closedAt": "2021-01-16T04:36:25Z", "author": {"login": "abbccdda"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABddKe7IABqjQwMDIwNjExNzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdwgJJOgH2gAyNTIxOTA0OTQ2OmFmMzIwOGExNjNmODQ5NzUyODNjODYwMzE0MjQ4MWRhOGVhYTYxM2E=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "a50ac280c6499495c864c4bcd8c833eafcfb1f0d", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/a50ac280c6499495c864c4bcd8c833eafcfb1f0d", "committedDate": "2020-11-17T17:25:36Z", "message": "add tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c93b40ef5389132aa99a4491a1ec7d91175af89f", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/c93b40ef5389132aa99a4491a1ec7d91175af89f", "committedDate": "2020-11-19T00:13:00Z", "message": "add exceptional api version case for Envelope"}, "afterCommit": {"oid": "3f5eaa12d39fcadbcba05de03aa9538d379a68e0", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/3f5eaa12d39fcadbcba05de03aa9538d379a68e0", "committedDate": "2021-01-04T21:16:08Z", "message": "get controller api version and add exceptional api version case for Envelope"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3f5eaa12d39fcadbcba05de03aa9538d379a68e0", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/3f5eaa12d39fcadbcba05de03aa9538d379a68e0", "committedDate": "2021-01-04T21:16:08Z", "message": "get controller api version and add exceptional api version case for Envelope"}, "afterCommit": {"oid": "8f9f580119e6a0adafa27b5f979aaa70046814be", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/8f9f580119e6a0adafa27b5f979aaa70046814be", "committedDate": "2021-01-05T01:43:43Z", "message": "get controller api version and add exceptional api version case for Envelope"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzOTU4MDM3", "url": "https://github.com/apache/kafka/pull/9600#pullrequestreview-563958037", "createdAt": "2021-01-08T02:12:39Z", "commit": {"oid": "8f9f580119e6a0adafa27b5f979aaa70046814be"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwMjoxMjozOVrOIQDPKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwMjoxMjozOVrOIQDPKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzcwMTE2MA==", "bodyText": "This seems a little severe. Not all apis need to be coordinated with the controller. We have to handle the case when we receive a version that the current controller cannot handle anyway, so I think it's ok to make this a best-effort intersection and return just the broker APIs if the controller APIs are not yet known.\nThe tricky case for this PR is when the controller changed or we learned about new API version support after a client had already connected to the broker and sent ApiVersions. In this case, we have to detect version incompatibility dynamically when we try to forward the request. I might be missing something, but the current patch doesn't seem to handle this. Maybe the simplest option is to let the controller return UNSUPPORTED_VERSION in the envelope response if the header indicates an api or version that it does not support. Then the question is whether this error should be sent back to the client, but that would be a little surprising.\nConsider this sequence:\n\nClient connects and sends ApiVersions request\nCurrent controller supports AlterConfig v0-4, so that is what the broker indicates in the ApiVersions response\nNew controller is elected and only supports AlterConfig v0-3\nClient sends AlterConfig v4\n\nNow what happens? An unsupported version error here would be treated as fatal by the client. I think we agreed that instead of sending back the error, the broker would just disconnect. This would force a reconnect and a refresh of the API versions.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r553701160", "createdAt": "2021-01-08T02:12:39Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1790,17 +1790,41 @@ class KafkaApis(val requestChannel: RequestChannel,\n       else {\n         val supportedFeatures = brokerFeatures.supportedFeatures\n         val finalizedFeaturesOpt = finalizedFeatureCache.get\n-        finalizedFeaturesOpt match {\n-          case Some(finalizedFeatures) => ApiVersion.apiVersionsResponse(\n-            requestThrottleMs,\n-            config.interBrokerProtocolVersion.recordVersion.value,\n-            supportedFeatures,\n-            finalizedFeatures.features,\n-            finalizedFeatures.epoch)\n-          case None => ApiVersion.apiVersionsResponse(\n-            requestThrottleMs,\n-            config.interBrokerProtocolVersion.recordVersion.value,\n-            supportedFeatures)\n+        val controllerApiVersions = if (isForwardingEnabled(request)) {\n+          forwardingManager.controllerApiVersions()\n+        } else\n+          None\n+\n+        if (isForwardingEnabled(request) && controllerApiVersions.isEmpty) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f9f580119e6a0adafa27b5f979aaa70046814be"}, "originalPosition": 45}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bfd4e4b0aa8f501946dd804189697de645bba92f", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/bfd4e4b0aa8f501946dd804189697de645bba92f", "committedDate": "2021-01-11T21:23:23Z", "message": "add close connection case for unsupported version"}, "afterCommit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237", "committedDate": "2021-01-11T21:24:46Z", "message": "add close connection case for unsupported version"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1ODMxNDQ4", "url": "https://github.com/apache/kafka/pull/9600#pullrequestreview-565831448", "createdAt": "2021-01-12T00:00:32Z", "commit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMDowMDozMlrOIRr5Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMDoyMzo1M1rOIRsmTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQxNTgyNw==", "bodyText": "Why move this class?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r555415827", "createdAt": "2021-01-12T00:00:32Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/common/protocol/ApiVersion.java", "diffHunk": "@@ -14,10 +14,10 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.kafka.clients;\n+package org.apache.kafka.common.protocol;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQxODUyNQ==", "bodyText": "nit: we could simplify this a little bit. I'd suggest a non-static method. Maybe something like this:\npublic ApiVersion intersect(ApiVersion other) {\n  // verify this.apiKey matches other.apiKey\n  // return intersection as implemented below\n}", "url": "https://github.com/apache/kafka/pull/9600#discussion_r555418525", "createdAt": "2021-01-12T00:08:43Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/common/protocol/ApiVersion.java", "diffHunk": "@@ -53,4 +53,18 @@ public String toString() {\n             \", maxVersion= \" + maxVersion +\n             \")\";\n     }\n+\n+    public static ApiVersion versionsInCommon(ApiKeys apiKey, ApiVersion supportedVersions,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQxOTI0NA==", "bodyText": "Not totally sure this gets thrown in the right place. If there are no overlapping versions, perhaps we should leave the api out of the result. Perhaps that suggests we should use this definition:\n// Return common api versions or empty if there are none\npublic Optional<ApiVersion> intersect(ApiVersion other);\nThen we can let the caller decide how to handle this case.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r555419244", "createdAt": "2021-01-12T00:11:00Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/common/protocol/ApiVersion.java", "diffHunk": "@@ -53,4 +53,18 @@ public String toString() {\n             \", maxVersion= \" + maxVersion +\n             \")\";\n     }\n+\n+    public static ApiVersion versionsInCommon(ApiKeys apiKey, ApiVersion supportedVersions,\n+                                              short minAllowedVersion, short maxAllowedVersion) {\n+        if (supportedVersions == null)\n+            throw new UnsupportedVersionException(\"The broker does not support \" + apiKey);\n+\n+        short minVersion = (short) Math.max(minAllowedVersion, supportedVersions.minVersion);\n+        short maxVersion = (short) Math.min(maxAllowedVersion, supportedVersions.maxVersion);\n+        if (minVersion > maxVersion)\n+            throw new UnsupportedVersionException(\"The broker does not support \" + apiKey +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQyMzA2Mw==", "bodyText": "This might be overkill. Perhaps we could make activeController volatile or an atomic reference?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r555423063", "createdAt": "2021-01-12T00:15:44Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManager.scala", "diffHunk": "@@ -171,6 +184,20 @@ class BrokerToControllerRequestThread(\n   private val requestQueue = new LinkedBlockingDeque[BrokerToControllerQueueItem]()\n   private var activeController: Option[Node] = None\n \n+  private val lock = new ReentrantReadWriteLock\n+\n+  def activeControllerAddress(): Option[Node] = {\n+    CoreUtils.inReadLock(lock) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQyNDczOA==", "bodyText": "Taking into account #9850, I think we should be checking envelopeError. If the broker could not parse the embedded request, then it would not be able to include an embedded response.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r555424738", "createdAt": "2021-01-12T00:17:38Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/ForwardingManager.scala", "diffHunk": "@@ -109,7 +113,14 @@ class ForwardingManagerImpl(\n         } else {\n           parseResponse(envelopeResponse.responseData, requestBody, request.header)\n         }\n-        responseCallback(response)\n+\n+        // Unsupported version indicates an incompatibility between controller and client API versions. The\n+        // forwarding broker should close the connection with the client and let it reinitialize the connection\n+        // and refresh the controller API versions.\n+        if (response.errorCounts().containsKey(Errors.UNSUPPORTED_VERSION)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQyNTkyMw==", "bodyText": "I think we could generalize the response callback and avoid the additional callback argument. Perhaps we could return Either[Response, Exception]. Then in KafkaApis, we can log an error in the exceptional case and close the connection.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r555425923", "createdAt": "2021-01-12T00:19:13Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/ForwardingManager.scala", "diffHunk": "@@ -77,7 +80,8 @@ class ForwardingManagerImpl(\n \n   override def forwardRequest(\n     request: RequestChannel.Request,\n-    responseCallback: AbstractResponse => Unit\n+    responseCallback: AbstractResponse => Unit,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQyNzQwNw==", "bodyText": "As mentioned previously, I think we want to relax this. It's fine to return the broker versions if the controller versions are unknown.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r555427407", "createdAt": "2021-01-12T00:23:53Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1790,17 +1790,41 @@ class KafkaApis(val requestChannel: RequestChannel,\n       else {\n         val supportedFeatures = brokerFeatures.supportedFeatures\n         val finalizedFeaturesOpt = finalizedFeatureCache.get\n-        finalizedFeaturesOpt match {\n-          case Some(finalizedFeatures) => ApiVersion.apiVersionsResponse(\n-            requestThrottleMs,\n-            config.interBrokerProtocolVersion.recordVersion.value,\n-            supportedFeatures,\n-            finalizedFeatures.features,\n-            finalizedFeatures.epoch)\n-          case None => ApiVersion.apiVersionsResponse(\n-            requestThrottleMs,\n-            config.interBrokerProtocolVersion.recordVersion.value,\n-            supportedFeatures)\n+        val controllerApiVersions = if (isForwardingEnabled(request)) {\n+          forwardingManager.controllerApiVersions()\n+        } else\n+          None\n+\n+        if (isForwardingEnabled(request) && controllerApiVersions.isEmpty) {\n+          // If the controller api version is missing and we already enabled feature support,\n+          // we need to let ApiVersion request retry by sending unsupported version.\n+          apiVersionRequest.getErrorResponse(requestThrottleMs, Errors.UNSUPPORTED_VERSION.exception)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237"}, "originalPosition": 57}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4d1a2ed533ef786445b8cc5d177f3ff070cbf5e1", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/4d1a2ed533ef786445b8cc5d177f3ff070cbf5e1", "committedDate": "2021-01-13T19:29:14Z", "message": "github comment"}, "afterCommit": {"oid": "ed59610e7696a24536eb448e1573d2f6c49572c9", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/ed59610e7696a24536eb448e1573d2f6c49572c9", "committedDate": "2021-01-13T19:34:58Z", "message": "github comment"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "47af77a2f5297c8a57a622f74855cb7361857111", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/47af77a2f5297c8a57a622f74855cb7361857111", "committedDate": "2021-01-13T20:31:31Z", "message": "fix test"}, "afterCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/669ad39b76d91aa64ed153672d4a8a7b7f8493c8", "committedDate": "2021-01-14T20:56:41Z", "message": "fix api tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4NzI5OTg2", "url": "https://github.com/apache/kafka/pull/9600#pullrequestreview-568729986", "createdAt": "2021-01-15T00:20:00Z", "commit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDoyMDowMFrOIT8ZXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDo0OTowMVrOIT9A6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4MzM5MQ==", "bodyText": "nit: since we moved the null check here, why don't we remove the parameter as well and call supportedVersions.get(apiKey) here?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557783391", "createdAt": "2021-01-15T00:20:00Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/NodeApiVersions.java", "diffHunk": "@@ -123,21 +125,25 @@ public short latestUsableVersion(ApiKeys apiKey) {\n      * Get the latest version supported by the broker within an allowed range of versions\n      */\n     public short latestUsableVersion(ApiKeys apiKey, short oldestAllowedVersion, short latestAllowedVersion) {\n-        ApiVersion usableVersion = supportedVersions.get(apiKey);\n-        if (usableVersion == null)\n-            throw new UnsupportedVersionException(\"The broker does not support \" + apiKey);\n-        return latestUsableVersion(apiKey, usableVersion, oldestAllowedVersion, latestAllowedVersion);\n+        return latestUsableVersion(apiKey, supportedVersions.get(apiKey), oldestAllowedVersion, latestAllowedVersion);\n     }\n \n-    private short latestUsableVersion(ApiKeys apiKey, ApiVersion supportedVersions,\n-                                      short minAllowedVersion, short maxAllowedVersion) {\n-        short minVersion = (short) Math.max(minAllowedVersion, supportedVersions.minVersion);\n-        short maxVersion = (short) Math.min(maxAllowedVersion, supportedVersions.maxVersion);\n-        if (minVersion > maxVersion)\n+    private short latestUsableVersion(ApiKeys apiKey,\n+                                      ApiVersion supportedVersions,\n+                                      short minAllowedVersion,\n+                                      short maxAllowedVersion) {\n+        if (supportedVersions == null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4Mzg4NQ==", "bodyText": "We could probably simplify this so that it takes a single ApiVersion parameter?\nBy the way, the implementation above latestUsableVersion(ApiKeys apiKey) since it basically does an intersection of the latest supported version with itself. A little helper (say latestSupportedOrThrow) might simplify this.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557783885", "createdAt": "2021-01-15T00:21:28Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/NodeApiVersions.java", "diffHunk": "@@ -123,21 +125,25 @@ public short latestUsableVersion(ApiKeys apiKey) {\n      * Get the latest version supported by the broker within an allowed range of versions\n      */\n     public short latestUsableVersion(ApiKeys apiKey, short oldestAllowedVersion, short latestAllowedVersion) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4NTEyMg==", "bodyText": "Ok. I don't have a strong argument to keep it where it is today I guess.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557785122", "createdAt": "2021-01-15T00:25:39Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/common/protocol/ApiVersion.java", "diffHunk": "@@ -14,10 +14,10 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.kafka.clients;\n+package org.apache.kafka.common.protocol;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQxNTgyNw=="}, "originalCommit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4NjUyMg==", "bodyText": "Maybe intersectControllerApiVersions?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557786522", "createdAt": "2021-01-15T00:27:27Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/ApiVersionsResponse.java", "diffHunk": "@@ -129,6 +131,40 @@ public static ApiVersionsResponseKeyCollection defaultApiKeys(final byte minMagi\n         return apiKeys;\n     }\n \n+    public static ApiVersionsResponseKeyCollection commonApiVersionsWithActiveController(final byte minMagic,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODA4Nw==", "bodyText": "nit: since this is a big block, could we add the braces?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557788087", "createdAt": "2021-01-15T00:32:01Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/api/ApiVersion.scala", "diffHunk": "@@ -148,42 +149,49 @@ object ApiVersion {\n \n   def apiVersionsResponse(throttleTimeMs: Int,\n                           maxMagic: Byte,\n-                          latestSupportedFeatures: Features[SupportedVersionRange]): ApiVersionsResponse = {\n+                          latestSupportedFeatures: Features[SupportedVersionRange],\n+                          controllerApiVersions: Option[NodeApiVersions]): ApiVersionsResponse = {\n     apiVersionsResponse(\n       throttleTimeMs,\n       maxMagic,\n       latestSupportedFeatures,\n       Features.emptyFinalizedFeatures,\n-      ApiVersionsResponse.UNKNOWN_FINALIZED_FEATURES_EPOCH\n+      ApiVersionsResponse.UNKNOWN_FINALIZED_FEATURES_EPOCH,\n+      controllerApiVersions\n     )\n   }\n \n   def apiVersionsResponse(throttleTimeMs: Int,\n                           maxMagic: Byte,\n                           latestSupportedFeatures: Features[SupportedVersionRange],\n                           finalizedFeatures: Features[FinalizedVersionRange],\n-                          finalizedFeaturesEpoch: Long): ApiVersionsResponse = {\n-    val apiKeys = ApiVersionsResponse.defaultApiKeys(maxMagic)\n+                          finalizedFeaturesEpoch: Long,\n+                          controllerApiVersions: Option[NodeApiVersions]): ApiVersionsResponse = {\n+    val apiKeys = controllerApiVersions match {\n+      case None => ApiVersionsResponse.defaultApiKeys(maxMagic)\n+      case Some(controllerApiVersion) => ApiVersionsResponse.commonApiVersionsWithActiveController(\n+        maxMagic, controllerApiVersion.fullApiVersions())\n+    }\n+\n     if (maxMagic == RecordBatch.CURRENT_MAGIC_VALUE &&\n       throttleTimeMs == AbstractResponse.DEFAULT_THROTTLE_TIME)\n-      return new ApiVersionsResponse(\n+      new ApiVersionsResponse(\n         ApiVersionsResponse.createApiVersionsResponseData(\n           DEFAULT_API_VERSIONS_RESPONSE.throttleTimeMs,\n           Errors.forCode(DEFAULT_API_VERSIONS_RESPONSE.data.errorCode),\n           apiKeys,\n           latestSupportedFeatures,\n           finalizedFeatures,\n+          finalizedFeaturesEpoch))\n+    else", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODQzNA==", "bodyText": "Seems like we can replace the match with a flatMap?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557788434", "createdAt": "2021-01-15T00:33:14Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManager.scala", "diffHunk": "@@ -140,6 +143,16 @@ class BrokerToControllerChannelManager(\n       callback\n     ))\n   }\n+\n+  def controllerApiVersions(): Option[NodeApiVersions] =\n+    requestThread.activeControllerAddress() match {\n+      case Some(activeController) =>\n+        if (activeController.id() == config.brokerId)\n+          Some(currentNodeApiVersions)\n+        else\n+          Option(apiVersions.get(activeController.idString()))\n+      case None => None", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODk3NA==", "bodyText": "nit: an atomic reference of Option is a little strange. Could we just use null and change the code to use Option(activeController.get())?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557788974", "createdAt": "2021-01-15T00:35:06Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManager.scala", "diffHunk": "@@ -169,11 +182,19 @@ class BrokerToControllerRequestThread(\n ) extends InterBrokerSendThread(threadName, networkClient, config.controllerSocketTimeoutMs, time, isInterruptible = false) {\n \n   private val requestQueue = new LinkedBlockingDeque[BrokerToControllerQueueItem]()\n-  private var activeController: Option[Node] = None\n+  private val activeController = new AtomicReference[Option[Node]](None)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MDU2Nw==", "bodyText": "This is another slippery looking case. Can we just rewrite this as a foreach so that we don't need to worry about it?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557790567", "createdAt": "2021-01-15T00:40:00Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManager.scala", "diffHunk": "@@ -205,20 +226,20 @@ class BrokerToControllerRequestThread(\n \n   private[server] def handleResponse(request: BrokerToControllerQueueItem)(response: ClientResponse): Unit = {\n     if (response.wasDisconnected()) {\n-      activeController = None\n+      updateControllerAddress(None)\n       requestQueue.putFirst(request)\n     } else if (response.responseBody().errorCounts().containsKey(Errors.NOT_CONTROLLER)) {\n       // just close the controller connection and wait for metadata cache update in doWork\n-      networkClient.disconnect(activeController.get.idString)\n-      activeController = None\n+      networkClient.disconnect(activeControllerAddress().get.idString)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MTAwMw==", "bodyText": "The usage is a tad suspicious because the atomic reference suggests that the value could change. I guess we are ok because the value will only be overwritten in the same thread that is calling generateRequests, but it might be worth rewriting this part anyway. For example:\n} else {\n  val controllerAddress = activeControllerAddress()\n  if (controllerAddress.isDefined) {\n...", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557791003", "createdAt": "2021-01-15T00:41:20Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManager.scala", "diffHunk": "@@ -190,11 +211,11 @@ class BrokerToControllerRequestThread(\n       if (currentTimeMs - request.createdTimeMs >= retryTimeoutMs) {\n         requestIter.remove()\n         request.callback.onTimeout()\n-      } else if (activeController.isDefined) {\n+      } else if (activeControllerAddress().isDefined) {\n         requestIter.remove()\n         return Some(RequestAndCompletionHandler(\n           time.milliseconds(),\n-          activeController.get,\n+          activeControllerAddress().get,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MTY2Ng==", "bodyText": "Since we are not using the Error from the result, maybe Option[AbstractResponse] would be a better type.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557791666", "createdAt": "2021-01-15T00:43:28Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/ForwardingManager.scala", "diffHunk": "@@ -77,7 +79,7 @@ class ForwardingManagerImpl(\n \n   override def forwardRequest(\n     request: RequestChannel.Request,\n-    responseCallback: AbstractResponse => Unit\n+    responseCallback: Either[AbstractResponse, Errors] => Unit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MTg3MQ==", "bodyText": "nit: add braces", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557791871", "createdAt": "2021-01-15T00:44:07Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1756,18 +1758,36 @@ class KafkaApis(val requestChannel: RequestChannel,\n       else {\n         val supportedFeatures = brokerFeatures.supportedFeatures\n         val finalizedFeaturesOpt = finalizedFeatureCache.get\n-        finalizedFeaturesOpt match {\n-          case Some(finalizedFeatures) => ApiVersion.apiVersionsResponse(\n-            requestThrottleMs,\n-            config.interBrokerProtocolVersion.recordVersion.value,\n-            supportedFeatures,\n-            finalizedFeatures.features,\n-            finalizedFeatures.epoch)\n-          case None => ApiVersion.apiVersionsResponse(\n-            requestThrottleMs,\n-            config.interBrokerProtocolVersion.recordVersion.value,\n-            supportedFeatures)\n+        val controllerApiVersions = if (isForwardingEnabled(request)) {\n+          forwardingManager.controllerApiVersions()\n+        } else", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MjMzNQ==", "bodyText": "nit: unneeded newline", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557792335", "createdAt": "2021-01-15T00:45:34Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1756,18 +1758,36 @@ class KafkaApis(val requestChannel: RequestChannel,\n       else {\n         val supportedFeatures = brokerFeatures.supportedFeatures\n         val finalizedFeaturesOpt = finalizedFeatureCache.get\n-        finalizedFeaturesOpt match {\n-          case Some(finalizedFeatures) => ApiVersion.apiVersionsResponse(\n-            requestThrottleMs,\n-            config.interBrokerProtocolVersion.recordVersion.value,\n-            supportedFeatures,\n-            finalizedFeatures.features,\n-            finalizedFeatures.epoch)\n-          case None => ApiVersion.apiVersionsResponse(\n-            requestThrottleMs,\n-            config.interBrokerProtocolVersion.recordVersion.value,\n-            supportedFeatures)\n+        val controllerApiVersions = if (isForwardingEnabled(request)) {\n+          forwardingManager.controllerApiVersions()\n+        } else\n+          None\n+\n+        val apiVersionsResponse =\n+          finalizedFeaturesOpt match {\n+            case Some(finalizedFeatures) => ApiVersion.apiVersionsResponse(\n+              requestThrottleMs,\n+              config.interBrokerProtocolVersion.recordVersion.value,\n+              supportedFeatures,\n+              finalizedFeatures.features,\n+              finalizedFeatures.epoch,\n+              controllerApiVersions)\n+            case None => ApiVersion.apiVersionsResponse(\n+              requestThrottleMs,\n+              config.interBrokerProtocolVersion.recordVersion.value,\n+              supportedFeatures,\n+              controllerApiVersions)\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5Mjc3MQ==", "bodyText": "It may be helpful to mention that this can happen because the controller changed after a connection was established.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557792771", "createdAt": "2021-01-15T00:46:50Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/ForwardingManager.scala", "diffHunk": "@@ -98,30 +100,40 @@ class ForwardingManagerImpl(\n         val envelopeError = envelopeResponse.error()\n         val requestBody = request.body[AbstractRequest]\n \n-        val response = if (envelopeError != Errors.NONE) {\n-          // An envelope error indicates broker misconfiguration (e.g. the principal serde\n-          // might not be defined on the receiving broker). In this case, we do not return\n-          // the error directly to the client since it would not be expected. Instead we\n-          // return `UNKNOWN_SERVER_ERROR` so that the user knows that there is a problem\n-          // on the broker.\n-          debug(s\"Forwarded request $request failed with an error in the envelope response $envelopeError\")\n-          requestBody.getErrorResponse(Errors.UNKNOWN_SERVER_ERROR.exception)\n+        // Unsupported version indicates an incompatibility between controller and client API versions. The", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MzUxNQ==", "bodyText": "A debug message would be helpful here so that we know why the connection was closed. I think we might actually prefer to use emptyMap() here since the unsupported version error would be misleading.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557793515", "createdAt": "2021-01-15T00:49:01Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -139,8 +138,11 @@ class KafkaApis(val requestChannel: RequestChannel,\n     request: RequestChannel.Request,\n     handler: RequestChannel.Request => Unit\n   ): Unit = {\n-    def responseCallback(response: AbstractResponse): Unit = {\n-      sendForwardedResponse(request, response)\n+    def responseCallback(responseEither: Either[AbstractResponse, Errors]): Unit = {\n+      responseEither match {\n+        case Left(response) => sendForwardedResponse(request, response)\n+        case Right(error) => closeConnection(request, Collections.singletonMap(error, 1))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5NDcyNjEx", "url": "https://github.com/apache/kafka/pull/9600#pullrequestreview-569472611", "createdAt": "2021-01-15T17:46:26Z", "commit": {"oid": "9a70335129ab52913eed37414f49cc0c00c727d5"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxNzo0NjoyN1rOIUmFTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxODowNDoxOFrOIUm5PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ2NjM4Mw==", "bodyText": "How about allSupportedApiVersions?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r558466383", "createdAt": "2021-01-15T17:46:27Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/NodeApiVersions.java", "diffHunk": "@@ -227,4 +230,7 @@ public ApiVersion apiVersion(ApiKeys apiKey) {\n         return supportedVersions.get(apiKey);\n     }\n \n+    public Map<ApiKeys, ApiVersion> fullApiVersions() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a70335129ab52913eed37414f49cc0c00c727d5"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ2OTg4OQ==", "bodyText": "Hmm.. I think my suggestion about latestUsableVersion(ApiKeys) was off if we had to remove this. I think I had failed to take into account that NodeApiVersions represented the versions supported by the remote node, so the intersection was in fact necessary. Sorry about that.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r558469889", "createdAt": "2021-01-15T17:50:32Z", "author": {"login": "hachikuji"}, "path": "clients/src/test/java/org/apache/kafka/clients/NodeApiVersionsTest.java", "diffHunk": "@@ -125,13 +126,6 @@ public void testUsableVersionCalculationNoKnownVersions() {\n             () -> versions.latestUsableVersion(ApiKeys.FETCH));\n     }\n \n-    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a70335129ab52913eed37414f49cc0c00c727d5"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ3MDgwMw==", "bodyText": "nit: maybe add a short javadoc?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r558470803", "createdAt": "2021-01-15T17:51:38Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/ApiVersionsResponse.java", "diffHunk": "@@ -129,6 +131,40 @@ public static ApiVersionsResponseKeyCollection defaultApiKeys(final byte minMagi\n         return apiKeys;\n     }\n \n+    public static ApiVersionsResponseKeyCollection intersectControllerApiVersions(final byte minMagic,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a70335129ab52913eed37414f49cc0c00c727d5"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ3MTk0OQ==", "bodyText": "nit: a little more idiomatic\nforeach { controllerAddress =>\n}", "url": "https://github.com/apache/kafka/pull/9600#discussion_r558471949", "createdAt": "2021-01-15T17:52:51Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManager.scala", "diffHunk": "@@ -190,35 +209,41 @@ class BrokerToControllerRequestThread(\n       if (currentTimeMs - request.createdTimeMs >= retryTimeoutMs) {\n         requestIter.remove()\n         request.callback.onTimeout()\n-      } else if (activeController.isDefined) {\n-        requestIter.remove()\n-        return Some(RequestAndCompletionHandler(\n-          time.milliseconds(),\n-          activeController.get,\n-          request.request,\n-          handleResponse(request)\n-        ))\n+      } else {\n+        val controllerAddress = activeControllerAddress()\n+        if (controllerAddress.isDefined) {\n+          requestIter.remove()\n+          return Some(RequestAndCompletionHandler(\n+            time.milliseconds(),\n+            controllerAddress.get,\n+            request.request,\n+            handleResponse(request)\n+          ))\n+        }\n       }\n     }\n     None\n   }\n \n   private[server] def handleResponse(request: BrokerToControllerQueueItem)(response: ClientResponse): Unit = {\n     if (response.wasDisconnected()) {\n-      activeController = None\n+      updateControllerAddress(null)\n       requestQueue.putFirst(request)\n     } else if (response.responseBody().errorCounts().containsKey(Errors.NOT_CONTROLLER)) {\n       // just close the controller connection and wait for metadata cache update in doWork\n-      networkClient.disconnect(activeController.get.idString)\n-      activeController = None\n+      activeControllerAddress().foreach(controllerAddress => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a70335129ab52913eed37414f49cc0c00c727d5"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ3NDY5Mg==", "bodyText": "It's a little odd to have the if check here since we will close the connection regardless of the error. That's one reason I thought Option[AbstractResponse] might be clearer. The None could be treated as implying an unsupported version.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r558474692", "createdAt": "2021-01-15T17:56:11Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -139,8 +138,16 @@ class KafkaApis(val requestChannel: RequestChannel,\n     request: RequestChannel.Request,\n     handler: RequestChannel.Request => Unit\n   ): Unit = {\n-    def responseCallback(response: AbstractResponse): Unit = {\n-      sendForwardedResponse(request, response)\n+    def responseCallback(responseEither: Either[AbstractResponse, Errors]): Unit = {\n+      responseEither match {\n+        case Left(response) => sendForwardedResponse(request, response)\n+        case Right(error) =>\n+          if (error == Errors.UNSUPPORTED_VERSION)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a70335129ab52913eed37414f49cc0c00c727d5"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ3OTY3Nw==", "bodyText": "Yeah, but that suggests a generality to the API that doesn't exist. There is only one error that is possible to be returned here.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r558479677", "createdAt": "2021-01-15T18:04:18Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/ForwardingManager.scala", "diffHunk": "@@ -77,7 +79,7 @@ class ForwardingManagerImpl(\n \n   override def forwardRequest(\n     request: RequestChannel.Request,\n-    responseCallback: AbstractResponse => Unit\n+    responseCallback: Either[AbstractResponse, Errors] => Unit", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MTY2Ng=="}, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5NTQ2NjQ0", "url": "https://github.com/apache/kafka/pull/9600#pullrequestreview-569546644", "createdAt": "2021-01-15T19:10:50Z", "commit": {"oid": "6e71efa2417e105846fbd10fb6daa13dcd8de162"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxOToxMDo1MFrOIUp6MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxOToxMDo1MFrOIUp6MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODUyOTA3Mw==", "bodyText": "It is a little strange for the test case to have a dependence on this. It seems we should be testing the inter-broker listener as well? I think I would instead try to modify failing assertions so that they assert the right thing depending on the listener config.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r558529073", "createdAt": "2021-01-15T19:10:50Z", "author": {"login": "hachikuji"}, "path": "core/src/test/scala/unit/kafka/server/AbstractApiVersionsRequestTest.scala", "diffHunk": "@@ -25,6 +27,15 @@ import scala.jdk.CollectionConverters._\n \n abstract class AbstractApiVersionsRequestTest extends BaseRequestTest {\n \n+  // Configure control plane listener to make sure we have separate listeners from client,\n+  // in order to avoid returning Envelope API version.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e71efa2417e105846fbd10fb6daa13dcd8de162"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce8d9a7329ede0e40f6bba01936e1522daeb07a6", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/ce8d9a7329ede0e40f6bba01936e1522daeb07a6", "committedDate": "2021-01-15T20:40:22Z", "message": "get controller api version and add exceptional api version case for Envelope"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4e6f8f4438facefed3921e783ecac0bac6623a0", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/c4e6f8f4438facefed3921e783ecac0bac6623a0", "committedDate": "2021-01-15T20:40:22Z", "message": "add close connection case for unsupported version"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d57e60724d99fa765621c36c9b1cb8671f9f190", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/8d57e60724d99fa765621c36c9b1cb8671f9f190", "committedDate": "2021-01-15T20:41:17Z", "message": "github comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5bd1d54e5de9c1d30f59157330ef7e77da9978ae", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/5bd1d54e5de9c1d30f59157330ef7e77da9978ae", "committedDate": "2021-01-15T20:41:18Z", "message": "fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fb7130bdce7194d019713bd3d13551e353956b6", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/8fb7130bdce7194d019713bd3d13551e353956b6", "committedDate": "2021-01-15T20:41:18Z", "message": "fix api tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54fccf1ac60b87323cfa08b585041da80bb52d3f", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/54fccf1ac60b87323cfa08b585041da80bb52d3f", "committedDate": "2021-01-15T20:41:36Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4edc091f3a0d737235cd2896aee25bb7d2de234", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/e4edc091f3a0d737235cd2896aee25bb7d2de234", "committedDate": "2021-01-15T20:41:36Z", "message": "reduce latestUsableVersion check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d1a54ef32dd8ae05f0d3e93f6e7d7878c06f990", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/9d1a54ef32dd8ae05f0d3e93f6e7d7878c06f990", "committedDate": "2021-01-15T20:41:36Z", "message": "fix test security protocol"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7ce6984f4329c1435b590ad8cb5df6f5f795de7", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/b7ce6984f4329c1435b590ad8cb5df6f5f795de7", "committedDate": "2021-01-15T20:42:16Z", "message": "revert usable version change and address more comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd531d0b485a8780458f02cb10227e89c7268a3d", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/cd531d0b485a8780458f02cb10227e89c7268a3d", "committedDate": "2021-01-15T20:42:16Z", "message": "test fix"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "34b872dbbadac4c6d42fe5cb6839475717c30b3e", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/34b872dbbadac4c6d42fe5cb6839475717c30b3e", "committedDate": "2021-01-15T20:27:12Z", "message": "test fix"}, "afterCommit": {"oid": "cd531d0b485a8780458f02cb10227e89c7268a3d", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/cd531d0b485a8780458f02cb10227e89c7268a3d", "committedDate": "2021-01-15T20:42:16Z", "message": "test fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY5NjM4MzM2", "url": "https://github.com/apache/kafka/pull/9600#pullrequestreview-569638336", "createdAt": "2021-01-15T21:42:17Z", "commit": {"oid": "cd531d0b485a8780458f02cb10227e89c7268a3d"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQyMTo0MjoxOFrOIUutVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQyMTo0MjoxOFrOIUutVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODYwNzcwMw==", "bodyText": "nit: can use == in scala", "url": "https://github.com/apache/kafka/pull/9600#discussion_r558607703", "createdAt": "2021-01-15T21:42:18Z", "author": {"login": "hachikuji"}, "path": "core/src/test/scala/unit/kafka/server/AbstractApiVersionsRequestTest.scala", "diffHunk": "@@ -45,10 +47,13 @@ abstract class AbstractApiVersionsRequestTest extends BaseRequestTest {\n     } finally socket.close()\n   }\n \n-  def validateApiVersionsResponse(apiVersionsResponse: ApiVersionsResponse): Unit = {\n-    val enabledPublicApis = ApiKeys.enabledApis()\n+  def validateApiVersionsResponse(apiVersionsResponse: ApiVersionsResponse, listenerName: ListenerName = interBrokerListenerName): Unit = {\n+    val expectedApis = ApiKeys.enabledApis()\n+    if (listenerName.equals(controlPlaneListenerName) ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd531d0b485a8780458f02cb10227e89c7268a3d"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af3208a163f84975283c8603142481da8eaa613a", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/af3208a163f84975283c8603142481da8eaa613a", "committedDate": "2021-01-15T21:52:33Z", "message": "fix nit"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2778, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}