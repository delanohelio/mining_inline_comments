{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0ODA3NDAz", "number": 9716, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNDozMDowOVrOFCuVzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNDo1MTo0N1rOFCupkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDAwNzE4OnYy", "diffSide": "RIGHT", "path": "raft/src/main/java/org/apache/kafka/raft/internals/BatchAccumulator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNDozMDowOVrOICBzLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNDozMDowOVrOICBzLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk5NzU0OQ==", "bodyText": "Nice one.", "url": "https://github.com/apache/kafka/pull/9716#discussion_r538997549", "createdAt": "2020-12-09T04:30:09Z", "author": {"login": "guozhangwang"}, "path": "raft/src/main/java/org/apache/kafka/raft/internals/BatchAccumulator.java", "diffHunk": "@@ -271,22 +272,19 @@ public int epoch() {\n         }\n     }\n \n+    public boolean isEmpty() {\n+        // The linger timer begins running when we have pending batches.\n+        // We use this to infer when the accumulator is empty to avoid the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3bfc8ce3fbc4d2cb3fab2f0c3f639f3b6d2d6c6"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDAyMjUyOnYy", "diffSide": "RIGHT", "path": "raft/src/main/java/org/apache/kafka/raft/internals/BatchAccumulator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNDozNjo0OVrOICB7OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNDozNjo0OVrOICB7OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk5OTYwOA==", "bodyText": "Does the javadoc above need updates?", "url": "https://github.com/apache/kafka/pull/9716#discussion_r538999608", "createdAt": "2020-12-09T04:36:49Z", "author": {"login": "guozhangwang"}, "path": "raft/src/main/java/org/apache/kafka/raft/internals/BatchAccumulator.java", "diffHunk": "@@ -271,22 +272,19 @@ public int epoch() {\n         }\n     }\n \n+    public boolean isEmpty() {\n+        // The linger timer begins running when we have pending batches.\n+        // We use this to infer when the accumulator is empty to avoid the\n+        // need to acquire the append lock.\n+        return !lingerTimer.isRunning();\n+    }\n+\n     /**\n      * Get the number of batches including the one that is currently being\n      * written to (if it exists).\n      */\n-    public int count() {\n-        appendLock.lock();\n-        try {\n-            int count = completed.size();\n-            if (currentBatch != null) {\n-                return count + 1;\n-            } else {\n-                return count;\n-            }\n-        } finally {\n-            appendLock.unlock();\n-        }\n+    public int numCompletedBatches() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3bfc8ce3fbc4d2cb3fab2f0c3f639f3b6d2d6c6"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDA1Nzc3OnYy", "diffSide": "RIGHT", "path": "raft/src/test/java/org/apache/kafka/raft/KafkaRaftClientTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNDo1MTo0N1rOICCNlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNDo1MTo0N1rOICCNlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAwNDMwOA==", "bodyText": "nit: maybe we split 50 to 20/30 to avoid some reading difficulty? :)", "url": "https://github.com/apache/kafka/pull/9716#discussion_r539004308", "createdAt": "2020-12-09T04:51:47Z", "author": {"login": "guozhangwang"}, "path": "raft/src/test/java/org/apache/kafka/raft/KafkaRaftClientTest.java", "diffHunk": "@@ -477,6 +477,74 @@ public void testAccumulatorClearedAfterBecomingUnattached() throws Exception {\n         Mockito.verify(memoryPool).release(buffer);\n     }\n \n+    @Test\n+    public void testChannelWokenUpIfLingerTimeoutReachedWithoutAppend() throws Exception {\n+        // This test verifies that the client will set its poll timeout accounting\n+        // for the lingerMs of a pending append\n+\n+        int localId = 0;\n+        int otherNodeId = 1;\n+        int lingerMs = 50;\n+        Set<Integer> voters = Utils.mkSet(localId, otherNodeId);\n+\n+        RaftClientTestContext context = new RaftClientTestContext.Builder(localId, voters)\n+            .withAppendLingerMs(lingerMs)\n+            .build();\n+\n+        context.becomeLeader();\n+        assertEquals(OptionalInt.of(localId), context.currentLeader());\n+        assertEquals(1L, context.log.endOffset().offset);\n+\n+        int epoch = context.currentEpoch();\n+        assertEquals(1L, context.client.scheduleAppend(epoch, singletonList(\"a\")));\n+        assertTrue(context.channel.wakeupRequested());\n+\n+        context.client.poll();\n+        assertEquals(OptionalLong.of(lingerMs), context.channel.lastReceiveTimeout());\n+\n+        context.time.sleep(25);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3bfc8ce3fbc4d2cb3fab2f0c3f639f3b6d2d6c6"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3724, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}