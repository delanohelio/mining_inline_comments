{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5NzcxNjc0", "number": 8689, "title": "KAFKA-6145: Add unit tests to verify fix of bug KAFKA-9173", "bodyText": "Unit tests\n\nshouldAssignActiveStatefulTasksEvenlyOverClientsAndStreamThreadsWithMoreStreamThreadsThanTasks()\nshouldAssignWarmUpTasksIfStatefulActiveTasksBalancedOverStreamThreadsButNotOverClients()\nshouldEvenlyAssignActiveStatefulTasksIfClientsAreWarmedUpToBalanceTaskOverClients()\nverify that bug KAFKA-9173 is fixed with the new HighAvailabilityTaskAssignor.\n\nshouldAssignActiveStatefulTasksEvenlyOverClientsAndStreamThreadsWithMoreStreamThreadsThanTasks()\nensures that tasks are evenly assigned over clients when all overprovisioned clients join\nsimultaneously.\nshouldAssignWarmUpTasksIfStatefulActiveTasksBalancedOverStreamThreadsButNotOverClients()\nensures that warm-up tasks are assigned to two new clients that join the group\nalthough the assignment is already balanced over stream threads.\nshouldEvenlyAssignActiveStatefulTasksIfClientsAreWarmedUpToBalanceTaskOverClients()\nensures that stateful active tasks are balanced over previous and warmed-up client\nalthough it the previous assignment is balanced over stream threads.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-05-18T22:22:12Z", "url": "https://github.com/apache/kafka/pull/8689", "merged": true, "mergeCommit": {"oid": "af02f76623b11a043b8e0f308bc6ba7e830b6a64"}, "closed": true, "closedAt": "2020-05-19T18:34:37Z", "author": {"login": "cadonna"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcingnnAH2gAyNDE5NzcxNjc0OjU4YWMzYzFlYjIwZjg2N2ViMTBlNGI3YTA4OWY2ZWUwMjYwMTBlODY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABci2i8egH2gAyNDE5NzcxNjc0OjEzNTU3ZmQzNzE1ODliOTdlZTQwZjhmOTU3ZjUxOTIwNTQ1NTk2NzE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "58ac3c1eb20f867eb10e4b7a089f6ee026010e86", "author": {"user": {"login": "cadonna", "name": "Bruno Cadonna"}}, "url": "https://github.com/apache/kafka/commit/58ac3c1eb20f867eb10e4b7a089f6ee026010e86", "committedDate": "2020-05-18T22:21:26Z", "message": "KAFKA-6145: Add unit tests to verify fix of bug KAFKA-9173\n\nUnit tests\n- shouldAssignActiveStatefulTasksEvenlyOverClientsAndStreamThreadsWithMoreStreamThreadsThanTasks()\n- shouldAssignWarmUpTasksIfStatefulActiveTasksBalancedOverStreamThreadsButNotOverClients()\n- shouldEvenlyAssignActiveStatefulTasksIfClientsAreWarmedUpToBalanceTaskOverClients()\nverify that bug KAFKA-9173 is fixed with the new HighAvailabilityTaskAssignor.\n\nshouldAssignActiveStatefulTasksEvenlyOverClientsAndStreamThreadsWithMoreStreamThreadsThanTasks()\nensures that tasks are evenly assigned over clients when all overprovisioned clients join\nsimultaneously.\n\nshouldAssignWarmUpTasksIfStatefulActiveTasksBalancedOverStreamThreadsButNotOverClients()\nensures that warm-up tasks are assigned to two new clients that join the group\nalthough the assignment is already balanced over stream threads.\n\nshouldEvenlyAssignActiveStatefulTasksIfClientsAreWarmedUpToBalanceTaskOverClients()\nensures that stateful active tasks are balanced over previous and warmed-up client\nalthough it the previous assignment is balanced over stream threads."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzOTc4MTY4", "url": "https://github.com/apache/kafka/pull/8689#pullrequestreview-413978168", "createdAt": "2020-05-18T22:23:32Z", "commit": {"oid": "58ac3c1eb20f867eb10e4b7a089f6ee026010e86"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoyMzozMlrOGXJafQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQyMjoyMzozMlrOGXJafQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyNDY2OQ==", "bodyText": "This name seemed not correct.", "url": "https://github.com/apache/kafka/pull/8689#discussion_r426924669", "createdAt": "2020-05-18T22:23:32Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignorTest.java", "diffHunk": "@@ -170,7 +171,7 @@ public void shouldAssignActiveStatefulTasksEvenlyOverUnevenlyDistributedStreamTh\n     }\n \n     @Test\n-    public void shouldAssignActiveStatefulTasksEvenlyOverClientsWithLessClientsThanTasks() {\n+    public void shouldAssignActiveStatefulTasksEvenlyOverClientsWithMoreClientsThanTasks() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58ac3c1eb20f867eb10e4b7a089f6ee026010e86"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0NTI5MjA0", "url": "https://github.com/apache/kafka/pull/8689#pullrequestreview-414529204", "createdAt": "2020-05-19T14:51:55Z", "commit": {"oid": "58ac3c1eb20f867eb10e4b7a089f6ee026010e86"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNDo1MTo1NVrOGXkVxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxNDo1Nzo1NVrOGXkoww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM2NTgzMQ==", "bodyText": "Huh, good catch!", "url": "https://github.com/apache/kafka/pull/8689#discussion_r427365831", "createdAt": "2020-05-19T14:51:55Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignorTest.java", "diffHunk": "@@ -170,7 +171,7 @@ public void shouldAssignActiveStatefulTasksEvenlyOverUnevenlyDistributedStreamTh\n     }\n \n     @Test\n-    public void shouldAssignActiveStatefulTasksEvenlyOverClientsWithLessClientsThanTasks() {\n+    public void shouldAssignActiveStatefulTasksEvenlyOverClientsWithMoreClientsThanTasks() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkyNDY2OQ=="}, "originalCommit": {"oid": "58ac3c1eb20f867eb10e4b7a089f6ee026010e86"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM3MDY5MQ==", "bodyText": "If we expect no warmups, we can assert it here with:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertValidAssignment(0, allTaskIds.size() / 3 + 1, allTaskIds, emptySet(), clientStates, new StringBuilder());\n          \n          \n            \n                    assertValidAssignment(0, allTaskIds, emptySet(), clientStates, new StringBuilder());", "url": "https://github.com/apache/kafka/pull/8689#discussion_r427370691", "createdAt": "2020-05-19T14:57:55Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/HighAvailabilityTaskAssignorTest.java", "diffHunk": "@@ -213,6 +214,61 @@ public void shouldAssignActiveStatefulTasksEvenlyOverClientsAndStreamThreadsWith\n         assertBalancedTasks(clientStates);\n     }\n \n+    @Test\n+    public void shouldAssignWarmUpTasksIfStatefulActiveTasksBalancedOverStreamThreadsButNotOverClients() {\n+        final Set<TaskId> allTaskIds = mkSet(TASK_0_0, TASK_0_1, TASK_1_0, TASK_1_1);\n+        final Map<TaskId, Long> lagsForCaughtUpClient = allTaskIds.stream().collect(Collectors.toMap(k -> k, k -> 0L));\n+        final Map<TaskId, Long> lagsForNotCaughtUpClient =\n+            allTaskIds.stream().collect(Collectors.toMap(k -> k, k -> Long.MAX_VALUE));\n+        final ClientState caughtUpClientState = new ClientState(allTaskIds, emptySet(), lagsForCaughtUpClient, 5);\n+        final ClientState notCaughtUpClientState1 = new ClientState(emptySet(), emptySet(), lagsForNotCaughtUpClient, 5);\n+        final ClientState notCaughtUpClientState2 = new ClientState(emptySet(), emptySet(), lagsForNotCaughtUpClient, 5);\n+        final Map<UUID, ClientState> clientStates =\n+            getClientStatesMap(caughtUpClientState, notCaughtUpClientState1, notCaughtUpClientState2);\n+        final boolean unstable = new HighAvailabilityTaskAssignor().assign(\n+            clientStates,\n+            allTaskIds,\n+            allTaskIds,\n+            new AssignmentConfigs(0L, allTaskIds.size() / 3 + 1, 0, 0L)\n+        );\n+\n+        assertThat(unstable, is(true));\n+        assertThat(notCaughtUpClientState1.standbyTaskCount(), greaterThanOrEqualTo(allTaskIds.size() / 3));\n+        assertThat(notCaughtUpClientState2.standbyTaskCount(), greaterThanOrEqualTo(allTaskIds.size() / 3));\n+        assertValidAssignment(0, allTaskIds.size() / 3 + 1, allTaskIds, emptySet(), clientStates, new StringBuilder());\n+    }\n+\n+    @Test\n+    public void shouldEvenlyAssignActiveStatefulTasksIfClientsAreWarmedUpToBalanceTaskOverClients() {\n+        final Set<TaskId> allTaskIds = mkSet(TASK_0_0, TASK_0_1, TASK_1_0, TASK_1_1);\n+        final Set<TaskId> warmedUpTaskIds1 = mkSet(TASK_0_1);\n+        final Set<TaskId> warmedUpTaskIds2 = mkSet(TASK_1_0);\n+        final Map<TaskId, Long> lagsForCaughtUpClient = allTaskIds.stream().collect(Collectors.toMap(k -> k, k -> 0L));\n+        final Map<TaskId, Long> lagsForWarmedUpClient1 =\n+            allTaskIds.stream().collect(Collectors.toMap(k -> k, k -> Long.MAX_VALUE));\n+        lagsForWarmedUpClient1.put(TASK_0_1, 0L);\n+        final Map<TaskId, Long> lagsForWarmedUpClient2 =\n+            allTaskIds.stream().collect(Collectors.toMap(k -> k, k -> Long.MAX_VALUE));\n+        lagsForWarmedUpClient2.put(TASK_1_0, 0L);\n+        final ClientState caughtUpClientState = new ClientState(allTaskIds, emptySet(), lagsForCaughtUpClient, 5);\n+        final ClientState warmedUpClientState1 = new ClientState(emptySet(), warmedUpTaskIds1, lagsForWarmedUpClient1, 5);\n+        final ClientState warmedUpClientState2 = new ClientState(emptySet(), warmedUpTaskIds2, lagsForWarmedUpClient2, 5);\n+        final Map<UUID, ClientState> clientStates =\n+            getClientStatesMap(caughtUpClientState, warmedUpClientState1, warmedUpClientState2);\n+        final boolean unstable = new HighAvailabilityTaskAssignor().assign(\n+            clientStates,\n+            allTaskIds,\n+            allTaskIds,\n+            new AssignmentConfigs(0L, allTaskIds.size() / 3 + 1, 0, 0L)\n+        );\n+\n+        assertThat(unstable, is(false));\n+        assertValidAssignment(0, allTaskIds.size() / 3 + 1, allTaskIds, emptySet(), clientStates, new StringBuilder());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58ac3c1eb20f867eb10e4b7a089f6ee026010e86"}, "originalPosition": 83}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13557fd371589b97ee40f8f957f5192054559671", "author": {"user": {"login": "cadonna", "name": "Bruno Cadonna"}}, "url": "https://github.com/apache/kafka/commit/13557fd371589b97ee40f8f957f5192054559671", "committedDate": "2020-05-19T15:52:33Z", "message": "Include feedback"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1079, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}