{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE1ODY3NTIx", "number": 9564, "title": "KAFKA-10667: add timeout for forwarding requests", "bodyText": "Right now the forwarding request will retry indefinitely, which is not the ideal behavior. We should timeout the enqueued request when it hits the request timeout.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-11-05T07:53:51Z", "url": "https://github.com/apache/kafka/pull/9564", "merged": true, "mergeCommit": {"oid": "41ea0775e0360eeb60376fb19bbd3941ed67676d"}, "closed": true, "closedAt": "2020-12-08T19:12:31Z", "author": {"login": "abbccdda"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdZeEuHgFqTUyNDAxOTk4Mw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdkOxE1gFqTU0NzUyODk3Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0MDE5OTgz", "url": "https://github.com/apache/kafka/pull/9564#pullrequestreview-524019983", "createdAt": "2020-11-05T08:27:28Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwODoyNzoyOFrOHt4L2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNVQwODoyNzoyOFrOHt4L2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg2ODUwNA==", "bodyText": "(The following question is not related to this PR. just curious)\nIs it possible to encounter authentication error when forwarding? If so, is it necessary to avoid retrying such (error) request?", "url": "https://github.com/apache/kafka/pull/9564#discussion_r517868504", "createdAt": "2020-11-05T08:27:28Z", "author": {"login": "chia7712"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -208,7 +209,9 @@ class BrokerToControllerRequestThread(networkClient: KafkaClient,\n   }\n \n   private[server] def handleResponse(request: BrokerToControllerQueueItem)(response: ClientResponse): Unit = {\n-    if (response.wasDisconnected()) {\n+    if (isTimedOut(response)) {\n+      debug(s\"The request failed to send to the controller after timeout ${clientRequestTimeout} ms: $response\")\n+    } else if (response.wasDisconnected()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMwMjU5NjQ2", "url": "https://github.com/apache/kafka/pull/9564#pullrequestreview-530259646", "createdAt": "2020-11-13T17:20:59Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNzoyMDo1OVrOHy3rCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNzozMToyM1rOHy4NiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEwMjk4NQ==", "bodyText": "So before, if the request timed out, it would be marked as \"disconnected\"?", "url": "https://github.com/apache/kafka/pull/9564#discussion_r523102985", "createdAt": "2020-11-13T17:20:59Z", "author": {"login": "mumrah"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -208,7 +209,9 @@ class BrokerToControllerRequestThread(networkClient: KafkaClient,\n   }\n \n   private[server] def handleResponse(request: BrokerToControllerQueueItem)(response: ClientResponse): Unit = {\n-    if (response.wasDisconnected()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzExMTgxNg==", "bodyText": "Do we need to call the request callback here so we can propagate the error up to the client?", "url": "https://github.com/apache/kafka/pull/9564#discussion_r523111816", "createdAt": "2020-11-13T17:31:23Z", "author": {"login": "mumrah"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -208,7 +209,9 @@ class BrokerToControllerRequestThread(networkClient: KafkaClient,\n   }\n \n   private[server] def handleResponse(request: BrokerToControllerQueueItem)(response: ClientResponse): Unit = {\n-    if (response.wasDisconnected()) {\n+    if (isTimedOut(response)) {\n+      debug(s\"The request failed to send to the controller after timeout ${clientRequestTimeout} ms: $response\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMyNzI2MTQ5", "url": "https://github.com/apache/kafka/pull/9564#pullrequestreview-532726149", "createdAt": "2020-11-17T19:25:39Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxOToyNTozOVrOH1Fl9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxOTozMDozNlrOH1FyAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQyODIxNA==", "bodyText": "I am not so sure about adding this to RequestCompletionHandler. This interface is mainly serving NetworkClient, but there are no changes to NetworkClient here.", "url": "https://github.com/apache/kafka/pull/9564#discussion_r525428214", "createdAt": "2020-11-17T19:25:39Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/RequestCompletionHandler.java", "diffHunk": "@@ -24,4 +24,11 @@\n \n     void onComplete(ClientResponse response);\n \n+    /**\n+     * Fire when the request transmission hits a fatal exception.\n+     *\n+     * @param exception the thrown exception\n+     */\n+    default void onFailure(RuntimeException exception) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQzMTI5OA==", "bodyText": "The time we need to track should begin when the request is submitted to the manager. This looks like it is just checking how long an individual request is taking, which the request timeout in NetworkClient already takes care of.", "url": "https://github.com/apache/kafka/pull/9564#discussion_r525431298", "createdAt": "2020-11-17T19:30:36Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -178,6 +183,11 @@ class BrokerToControllerRequestThread(networkClient: KafkaClient,\n     }\n   }\n \n+  private def isTimedOut(response: ClientResponse): Boolean = {\n+    val requestCreatedTime = response.receivedTimeMs() - response.requestLatencyMs()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0OTk2NzE4", "url": "https://github.com/apache/kafka/pull/9564#pullrequestreview-534996718", "createdAt": "2020-11-20T00:54:48Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwMDo1NDo0OFrOH25VzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwMDo1NzozN1rOH25cFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMyNDYyMA==", "bodyText": "There may be requests that never had a chance to be sent?", "url": "https://github.com/apache/kafka/pull/9564#discussion_r527324620", "createdAt": "2020-11-20T00:54:48Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -88,20 +88,33 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n     val message = buildRequest(inflightAlterIsrItems)\n-    def responseHandler(response: ClientResponse): Unit = {\n-      try {\n-        val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-        handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n-      } finally {\n-        // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-        if (!inflightRequest.compareAndSet(true, false)) {\n-          throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+\n+    def clearInflightRequests(): Unit = {\n+      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n+      if (!inflightRequest.compareAndSet(true, false)) {\n+        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+      }\n+    }\n+\n+    class AlterIsrResponseHandler extends BrokerToControllerRequestCompletionHandler {\n+      override def onComplete(response: ClientResponse): Unit = {\n+        try {\n+          val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n+          handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n+        } finally {\n+          clearInflightRequests()\n         }\n       }\n+\n+      override def onFailure(exception: RuntimeException): Unit = {\n+        error(s\"Encountered $exception when sending AlterIsr to the controller, clearing all pending states\")\n+        unsentIsrUpdates.clear()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMyNTY4Mg==", "bodyText": "Don't we need to invoke the callbacks?", "url": "https://github.com/apache/kafka/pull/9564#discussion_r527325682", "createdAt": "2020-11-20T00:55:57Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -88,20 +88,33 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n     val message = buildRequest(inflightAlterIsrItems)\n-    def responseHandler(response: ClientResponse): Unit = {\n-      try {\n-        val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-        handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n-      } finally {\n-        // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-        if (!inflightRequest.compareAndSet(true, false)) {\n-          throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+\n+    def clearInflightRequests(): Unit = {\n+      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n+      if (!inflightRequest.compareAndSet(true, false)) {\n+        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+      }\n+    }\n+\n+    class AlterIsrResponseHandler extends BrokerToControllerRequestCompletionHandler {\n+      override def onComplete(response: ClientResponse): Unit = {\n+        try {\n+          val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n+          handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n+        } finally {\n+          clearInflightRequests()\n         }\n       }\n+\n+      override def onFailure(exception: RuntimeException): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzMyNjIzMQ==", "bodyText": "We do not want to timeout requests from the broker such as AlterIsr. We only want this for client requests.", "url": "https://github.com/apache/kafka/pull/9564#discussion_r527326231", "createdAt": "2020-11-20T00:57:37Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -178,6 +194,10 @@ class BrokerToControllerRequestThread(networkClient: KafkaClient,\n     }\n   }\n \n+  private def isTimedOut(request: BrokerToControllerQueueItem): Boolean = {\n+    (time.milliseconds() - request.firstEnqueuedTimeMs) > clientRequestTimeout", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 72}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "c55f143e43a710db07d0f43211508692c4d46beb", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/c55f143e43a710db07d0f43211508692c4d46beb", "committedDate": "2020-11-23T18:24:53Z", "message": "add request timeout for forwarding"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "c55f143e43a710db07d0f43211508692c4d46beb", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/c55f143e43a710db07d0f43211508692c4d46beb", "committedDate": "2020-11-23T18:24:53Z", "message": "add request timeout for forwarding"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQxNDM0NzMw", "url": "https://github.com/apache/kafka/pull/9564#pullrequestreview-541434730", "createdAt": "2020-12-01T02:03:15Z", "commit": {"oid": "c55f143e43a710db07d0f43211508692c4d46beb"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMjowMzoxNVrOH8VNww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwMjoxNToyMlrOH8Vcaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNDE5NQ==", "bodyText": "We check for timeouts only after receiving a response. I guess this means that in the worst case, the total timeout would be request.timeout*2. This is probably not a big deal, but maybe worth documenting in a comment somewhere.", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533024195", "createdAt": "2020-12-01T02:03:15Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -165,7 +176,9 @@ class BrokerToControllerRequestThread(networkClient: KafkaClient,\n   }\n \n   private[server] def handleResponse(request: BrokerToControllerQueueItem)(response: ClientResponse): Unit = {\n-    if (response.wasDisconnected()) {\n+    if (isTimedOut(request)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c55f143e43a710db07d0f43211508692c4d46beb"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNDI3Ng==", "bodyText": "Perhaps we could use a name like retryTimeout to distinguish this from the request timeout which only applies to individual requests. Alternatively we could let the caller provide the retry deadline explicitly. This would save the need for the extra time.milliseconds call.", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533024276", "createdAt": "2020-12-01T02:03:38Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -35,7 +35,8 @@ import scala.jdk.CollectionConverters._\n \n trait BrokerToControllerChannelManager {\n   def sendRequest(request: AbstractRequest.Builder[_ <: AbstractRequest],\n-                  callback: RequestCompletionHandler): Unit\n+                  callback: BrokerToControllerRequestCompletionHandler,\n+                  requestTimeout: Long): Unit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c55f143e43a710db07d0f43211508692c4d46beb"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNDU3OQ==", "bodyText": "nit: hasTimedOut?", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533024579", "createdAt": "2020-12-01T02:04:38Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -178,6 +191,10 @@ class BrokerToControllerRequestThread(networkClient: KafkaClient,\n     }\n   }\n \n+  private def isTimedOut(request: BrokerToControllerQueueItem): Boolean = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c55f143e43a710db07d0f43211508692c4d46beb"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNDY4OQ==", "bodyText": "This comment needs to be updated.", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533024689", "createdAt": "2020-12-01T02:05:03Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -125,15 +126,25 @@ class BrokerToControllerChannelManagerImpl(metadataCache: kafka.server.MetadataC\n   }\n \n   override def sendRequest(request: AbstractRequest.Builder[_ <: AbstractRequest],\n-                           callback: RequestCompletionHandler): Unit = {\n-    requestQueue.put(BrokerToControllerQueueItem(request, callback))\n+                           callback: BrokerToControllerRequestCompletionHandler,\n+                           requestTimeout: Long): Unit = {\n+    requestQueue.put(BrokerToControllerQueueItem(request, callback, time.milliseconds() + requestTimeout))\n     requestThread.wakeup()\n   }\n \n }\n \n+abstract class BrokerToControllerRequestCompletionHandler extends RequestCompletionHandler {\n+\n+  /**\n+   * Fire when the request transmission hits a fatal exception.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c55f143e43a710db07d0f43211508692c4d46beb"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNTg4NA==", "bodyText": "Won't this overflow with requestTimeout set to Long.MaxValue. Do we have any test cases?", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533025884", "createdAt": "2020-12-01T02:09:02Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -125,15 +126,25 @@ class BrokerToControllerChannelManagerImpl(metadataCache: kafka.server.MetadataC\n   }\n \n   override def sendRequest(request: AbstractRequest.Builder[_ <: AbstractRequest],\n-                           callback: RequestCompletionHandler): Unit = {\n-    requestQueue.put(BrokerToControllerQueueItem(request, callback))\n+                           callback: BrokerToControllerRequestCompletionHandler,\n+                           requestTimeout: Long): Unit = {\n+    requestQueue.put(BrokerToControllerQueueItem(request, callback, time.milliseconds() + requestTimeout))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c55f143e43a710db07d0f43211508692c4d46beb"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNjA5MA==", "bodyText": "If we don't expect this, maybe we should just raise an exception. Alternatively if we are not going to fail, perhaps we should go ahead and invoke the callbacks.", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533026090", "createdAt": "2020-12-01T02:09:42Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -88,20 +88,33 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n     val message = buildRequest(inflightAlterIsrItems)\n-    def responseHandler(response: ClientResponse): Unit = {\n-      try {\n-        val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-        handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n-      } finally {\n-        // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-        if (!inflightRequest.compareAndSet(true, false)) {\n-          throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+\n+    def clearInflightRequests(): Unit = {\n+      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n+      if (!inflightRequest.compareAndSet(true, false)) {\n+        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+      }\n+    }\n+\n+    class AlterIsrResponseHandler extends BrokerToControllerRequestCompletionHandler {\n+      override def onComplete(response: ClientResponse): Unit = {\n+        try {\n+          val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n+          handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n+        } finally {\n+          clearInflightRequests()\n         }\n       }\n+\n+      override def onTimeout(): Unit = {\n+        warn(s\"Encountered request when sending AlterIsr to the controller\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c55f143e43a710db07d0f43211508692c4d46beb"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNjQ3NQ==", "bodyText": "Maybe we can avoid this call to time.milliseconds and use ClientResponse.receivedTimeMs?", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533026475", "createdAt": "2020-12-01T02:10:54Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -178,6 +191,10 @@ class BrokerToControllerRequestThread(networkClient: KafkaClient,\n     }\n   }\n \n+  private def isTimedOut(request: BrokerToControllerQueueItem): Boolean = {\n+    time.milliseconds() > request.deadlineMs", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c55f143e43a710db07d0f43211508692c4d46beb"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAyNzk0Nw==", "bodyText": "I think this should be debug. Users will already have visibility into the error through the request log and the error metrics. There's probably a stronger case to increase the level for the unknown error case in onComplete above, but I'm fine letting them both be debug.", "url": "https://github.com/apache/kafka/pull/9564#discussion_r533027947", "createdAt": "2020-12-01T02:15:22Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/ForwardingManager.scala", "diffHunk": "@@ -44,26 +46,34 @@ class ForwardingManager(channelManager: BrokerToControllerChannelManager) extend\n       request.context.clientAddress.getAddress\n     )\n \n-    def onClientResponse(clientResponse: ClientResponse): Unit = {\n-      val envelopeResponse = clientResponse.responseBody.asInstanceOf[EnvelopeResponse]\n-      val envelopeError = envelopeResponse.error()\n-      val requestBody = request.body[AbstractRequest]\n+    class ForwardingResponseHandler extends BrokerToControllerRequestCompletionHandler {\n+      override def onComplete(clientResponse: ClientResponse): Unit = {\n+        val envelopeResponse = clientResponse.responseBody.asInstanceOf[EnvelopeResponse]\n+        val envelopeError = envelopeResponse.error()\n+        val requestBody = request.body[AbstractRequest]\n \n-      val response = if (envelopeError != Errors.NONE) {\n-        // An envelope error indicates broker misconfiguration (e.g. the principal serde\n-        // might not be defined on the receiving broker). In this case, we do not return\n-        // the error directly to the client since it would not be expected. Instead we\n-        // return `UNKNOWN_SERVER_ERROR` so that the user knows that there is a problem\n-        // on the broker.\n-        debug(s\"Forwarded request $request failed with an error in the envelope response $envelopeError\")\n-        requestBody.getErrorResponse(Errors.UNKNOWN_SERVER_ERROR.exception)\n-      } else {\n-        parseResponse(envelopeResponse.responseData, requestBody, request.header)\n+        val response = if (envelopeError != Errors.NONE) {\n+          // An envelope error indicates broker misconfiguration (e.g. the principal serde\n+          // might not be defined on the receiving broker). In this case, we do not return\n+          // the error directly to the client since it would not be expected. Instead we\n+          // return `UNKNOWN_SERVER_ERROR` so that the user knows that there is a problem\n+          // on the broker.\n+          debug(s\"Forwarded request $request failed with an error in the envelope response $envelopeError\")\n+          requestBody.getErrorResponse(Errors.UNKNOWN_SERVER_ERROR.exception)\n+        } else {\n+          parseResponse(envelopeResponse.responseData, requestBody, request.header)\n+        }\n+        responseCallback(response)\n+      }\n+\n+      override def onTimeout(): Unit = {\n+        error(s\"Forwarding of the request $request failed due to timeout exception\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c55f143e43a710db07d0f43211508692c4d46beb"}, "originalPosition": 51}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1ce40e8c0141dedc016c638186c473ccbd52564", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/d1ce40e8c0141dedc016c638186c473ccbd52564", "committedDate": "2020-12-01T17:22:33Z", "message": "address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "d1ce40e8c0141dedc016c638186c473ccbd52564", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/d1ce40e8c0141dedc016c638186c473ccbd52564", "committedDate": "2020-12-01T17:22:33Z", "message": "address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyOTc1ODg3", "url": "https://github.com/apache/kafka/pull/9564#pullrequestreview-542975887", "createdAt": "2020-12-02T15:50:19Z", "commit": {"oid": "d1ce40e8c0141dedc016c638186c473ccbd52564"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNTo1MDoyMFrOH9hjZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxNTo1Nzo1NlrOH9h7Xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI3NDkxNw==", "bodyText": "Where will this exception get raised? I'm guessing the BrokerToControllerChannelManager thread?\nIf we timeout and give up on reading a response, I think we should still clear the inflightRequest flag. Otherwise AlterIsrManager will be stuck in-flight and be unable to send any more requests.", "url": "https://github.com/apache/kafka/pull/9564#discussion_r534274917", "createdAt": "2020-12-02T15:50:20Z", "author": {"login": "mumrah"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -88,20 +88,33 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n     val message = buildRequest(inflightAlterIsrItems)\n-    def responseHandler(response: ClientResponse): Unit = {\n-      try {\n-        val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-        handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n-      } finally {\n-        // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-        if (!inflightRequest.compareAndSet(true, false)) {\n-          throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+\n+    def clearInflightRequests(): Unit = {\n+      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n+      if (!inflightRequest.compareAndSet(true, false)) {\n+        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+      }\n+    }\n+\n+    class AlterIsrResponseHandler extends BrokerToControllerRequestCompletionHandler {\n+      override def onComplete(response: ClientResponse): Unit = {\n+        try {\n+          val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n+          handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n+        } finally {\n+          clearInflightRequests()\n         }\n       }\n+\n+      override def onTimeout(): Unit = {\n+        throw new IllegalStateException(\"Encountered unexpected timeout when sending AlterIsr to the controller\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1ce40e8c0141dedc016c638186c473ccbd52564"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI4MTA1NA==", "bodyText": "We also might want to iterate through the in-flight ISR (inflightAlterIsrItems) and complete their callbacks with an error. Otherwise, these partitions will not know to retry their ISR changes. They will eventually get new metadata via LeaderAndIsr, but it would be good to prevent them from getting into a bad state.\nSomething like\ninflightAlterIsrItems.foreach { item => item.callback.apply(Left(Errors.REQUEST_TIMED_OUT)) }\nI don't think we need this in the finally block at L104 since handleAlterIsrResponse should be pretty robust against raising an exception", "url": "https://github.com/apache/kafka/pull/9564#discussion_r534281054", "createdAt": "2020-12-02T15:57:56Z", "author": {"login": "mumrah"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -88,20 +88,33 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n     val message = buildRequest(inflightAlterIsrItems)\n-    def responseHandler(response: ClientResponse): Unit = {\n-      try {\n-        val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-        handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n-      } finally {\n-        // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-        if (!inflightRequest.compareAndSet(true, false)) {\n-          throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+\n+    def clearInflightRequests(): Unit = {\n+      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n+      if (!inflightRequest.compareAndSet(true, false)) {\n+        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+      }\n+    }\n+\n+    class AlterIsrResponseHandler extends BrokerToControllerRequestCompletionHandler {\n+      override def onComplete(response: ClientResponse): Unit = {\n+        try {\n+          val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n+          handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n+        } finally {\n+          clearInflightRequests()\n         }\n       }\n+\n+      override def onTimeout(): Unit = {\n+        throw new IllegalStateException(\"Encountered unexpected timeout when sending AlterIsr to the controller\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI3NDkxNw=="}, "originalCommit": {"oid": "d1ce40e8c0141dedc016c638186c473ccbd52564"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2Mzk1NzE0", "url": "https://github.com/apache/kafka/pull/9564#pullrequestreview-546395714", "createdAt": "2020-12-07T17:56:35Z", "commit": {"oid": "d1ce40e8c0141dedc016c638186c473ccbd52564"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxNzo1NjozNVrOIAzNLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODowMjoxM1rOIAzdHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcwOTg2OA==", "bodyText": "nit: drop parenthesis after brokerEpoch", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537709868", "createdAt": "2020-12-07T17:56:35Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -88,20 +88,33 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n     val message = buildRequest(inflightAlterIsrItems)\n-    def responseHandler(response: ClientResponse): Unit = {\n-      try {\n-        val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-        handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n-      } finally {\n-        // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-        if (!inflightRequest.compareAndSet(true, false)) {\n-          throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+\n+    def clearInflightRequests(): Unit = {\n+      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n+      if (!inflightRequest.compareAndSet(true, false)) {\n+        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+      }\n+    }\n+\n+    class AlterIsrResponseHandler extends BrokerToControllerRequestCompletionHandler {\n+      override def onComplete(response: ClientResponse): Unit = {\n+        try {\n+          val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n+          handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1ce40e8c0141dedc016c638186c473ccbd52564"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxMTgwMg==", "bodyText": "Perhaps add some more detail: \"... letting it retry indefinitely until a response is received or the request is cancelled after receiving new LeaderAndIsr state\".", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537711802", "createdAt": "2020-12-07T17:59:15Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -88,20 +88,33 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n     val message = buildRequest(inflightAlterIsrItems)\n-    def responseHandler(response: ClientResponse): Unit = {\n-      try {\n-        val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-        handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n-      } finally {\n-        // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-        if (!inflightRequest.compareAndSet(true, false)) {\n-          throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+\n+    def clearInflightRequests(): Unit = {\n+      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n+      if (!inflightRequest.compareAndSet(true, false)) {\n+        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+      }\n+    }\n+\n+    class AlterIsrResponseHandler extends BrokerToControllerRequestCompletionHandler {\n+      override def onComplete(response: ClientResponse): Unit = {\n+        try {\n+          val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n+          handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n+        } finally {\n+          clearInflightRequests()\n         }\n       }\n+\n+      override def onTimeout(): Unit = {\n+        throw new IllegalStateException(\"Encountered unexpected timeout when sending AlterIsr to the controller\")\n+      }\n     }\n \n     debug(s\"Sending AlterIsr to controller $message\")\n-    controllerChannelManager.sendRequest(new AlterIsrRequest.Builder(message), responseHandler)\n+    // We will not timeout AlterISR request, instead letting it retry indefinitely.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1ce40e8c0141dedc016c638186c473ccbd52564"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxMjM1NA==", "bodyText": "How about ControllerRequestCompletionHandler?", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537712354", "createdAt": "2020-12-07T17:59:56Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -125,15 +126,24 @@ class BrokerToControllerChannelManagerImpl(metadataCache: kafka.server.MetadataC\n   }\n \n   override def sendRequest(request: AbstractRequest.Builder[_ <: AbstractRequest],\n-                           callback: RequestCompletionHandler): Unit = {\n-    requestQueue.put(BrokerToControllerQueueItem(request, callback))\n+                           callback: BrokerToControllerRequestCompletionHandler,\n+                           retryDeadlineMs: Long): Unit = {\n+    requestQueue.put(BrokerToControllerQueueItem(request, callback, retryDeadlineMs))\n     requestThread.wakeup()\n   }\n+}\n+\n+abstract class BrokerToControllerRequestCompletionHandler extends RequestCompletionHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1ce40e8c0141dedc016c638186c473ccbd52564"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxMzIxMw==", "bodyText": "Can we document the difference between this and the request timeout?", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537713213", "createdAt": "2020-12-07T18:01:11Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -125,15 +126,24 @@ class BrokerToControllerChannelManagerImpl(metadataCache: kafka.server.MetadataC\n   }\n \n   override def sendRequest(request: AbstractRequest.Builder[_ <: AbstractRequest],\n-                           callback: RequestCompletionHandler): Unit = {\n-    requestQueue.put(BrokerToControllerQueueItem(request, callback))\n+                           callback: BrokerToControllerRequestCompletionHandler,\n+                           retryDeadlineMs: Long): Unit = {\n+    requestQueue.put(BrokerToControllerQueueItem(request, callback, retryDeadlineMs))\n     requestThread.wakeup()\n   }\n+}\n+\n+abstract class BrokerToControllerRequestCompletionHandler extends RequestCompletionHandler {\n \n+  /**\n+   * Fire when the request transmission hits timeout.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1ce40e8c0141dedc016c638186c473ccbd52564"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxMzk1MQ==", "bodyText": "Can we move this comment to the doc for sendRequest?", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537713951", "createdAt": "2020-12-07T18:02:13Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -178,6 +190,12 @@ class BrokerToControllerRequestThread(networkClient: KafkaClient,\n     }\n   }\n \n+  // The timeout will only be checked after receiving a response. This means that in the worst case,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1ce40e8c0141dedc016c638186c473ccbd52564"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b0077c37e9783dc3b7e91f16ff10306e30d1af5", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/1b0077c37e9783dc3b7e91f16ff10306e30d1af5", "committedDate": "2020-12-07T18:39:04Z", "message": "review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a78caeaaf36f019a630a2df129d857eea195adbb", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/a78caeaaf36f019a630a2df129d857eea195adbb", "committedDate": "2020-12-07T18:37:58Z", "message": "review comments"}, "afterCommit": {"oid": "1b0077c37e9783dc3b7e91f16ff10306e30d1af5", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/1b0077c37e9783dc3b7e91f16ff10306e30d1af5", "committedDate": "2020-12-07T18:39:04Z", "message": "review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NDg1Njk0", "url": "https://github.com/apache/kafka/pull/9564#pullrequestreview-546485694", "createdAt": "2020-12-07T19:54:13Z", "commit": {"oid": "1b0077c37e9783dc3b7e91f16ff10306e30d1af5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo1NDoxM1rOIA4Aeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo1NDoxM1rOIA4Aeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4ODUzOA==", "bodyText": "nit: turn into scaladoc", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537788538", "createdAt": "2020-12-07T19:54:13Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -34,8 +34,12 @@ import scala.collection.mutable\n import scala.jdk.CollectionConverters._\n \n trait BrokerToControllerChannelManager {\n+\n+  // The retry deadline will only be checked after receiving a response. This means that in the worst case,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b0077c37e9783dc3b7e91f16ff10306e30d1af5"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NDg2NDE2", "url": "https://github.com/apache/kafka/pull/9564#pullrequestreview-546486416", "createdAt": "2020-12-07T19:55:10Z", "commit": {"oid": "1b0077c37e9783dc3b7e91f16ff10306e30d1af5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo1NToxMFrOIA4C8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo1NToxMFrOIA4C8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4OTE2OA==", "bodyText": "Can we explain how it is different? We want to emphasize that it covers the total time including retries which might be the result of request timeouts.", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537789168", "createdAt": "2020-12-07T19:55:10Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManagerImpl.scala", "diffHunk": "@@ -125,15 +129,25 @@ class BrokerToControllerChannelManagerImpl(metadataCache: kafka.server.MetadataC\n   }\n \n   override def sendRequest(request: AbstractRequest.Builder[_ <: AbstractRequest],\n-                           callback: RequestCompletionHandler): Unit = {\n-    requestQueue.put(BrokerToControllerQueueItem(request, callback))\n+                           callback: ControllerRequestCompletionHandler,\n+                           retryDeadlineMs: Long): Unit = {\n+    requestQueue.put(BrokerToControllerQueueItem(request, callback, retryDeadlineMs))\n     requestThread.wakeup()\n   }\n+}\n+\n+abstract class ControllerRequestCompletionHandler extends RequestCompletionHandler {\n \n+  /**\n+   * Fire when the request transmission time passes the caller defined deadline on the channel queue.\n+   * This is different from the original request's timeout.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b0077c37e9783dc3b7e91f16ff10306e30d1af5"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c146b1398b0df9118d3f0d94745d6db72f653c0e", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/c146b1398b0df9118d3f0d94745d6db72f653c0e", "committedDate": "2020-12-08T00:42:58Z", "message": "additional comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NjUzNTc3", "url": "https://github.com/apache/kafka/pull/9564#pullrequestreview-546653577", "createdAt": "2020-12-08T00:32:16Z", "commit": {"oid": "1b0077c37e9783dc3b7e91f16ff10306e30d1af5"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMDozMjoxNlrOIBBQsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMDo1MjozNFrOIBBv7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk0MDE0NQ==", "bodyText": "Thanks, makes sense.", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537940145", "createdAt": "2020-12-08T00:32:16Z", "author": {"login": "mumrah"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -88,20 +88,33 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n     val message = buildRequest(inflightAlterIsrItems)\n-    def responseHandler(response: ClientResponse): Unit = {\n-      try {\n-        val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-        handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n-      } finally {\n-        // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-        if (!inflightRequest.compareAndSet(true, false)) {\n-          throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+\n+    def clearInflightRequests(): Unit = {\n+      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n+      if (!inflightRequest.compareAndSet(true, false)) {\n+        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+      }\n+    }\n+\n+    class AlterIsrResponseHandler extends BrokerToControllerRequestCompletionHandler {\n+      override def onComplete(response: ClientResponse): Unit = {\n+        try {\n+          val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n+          handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n+        } finally {\n+          clearInflightRequests()\n         }\n       }\n+\n+      override def onTimeout(): Unit = {\n+        throw new IllegalStateException(\"Encountered unexpected timeout when sending AlterIsr to the controller\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI3NDkxNw=="}, "originalCommit": {"oid": "d1ce40e8c0141dedc016c638186c473ccbd52564"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk0NTY4MQ==", "bodyText": "nit: could we inline this as an anonymous class down below rather than defining it here? Just seems a little odd to define it like this and then calling in to the containing class for inflightRequest.", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537945681", "createdAt": "2020-12-08T00:46:18Z", "author": {"login": "mumrah"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -88,20 +88,34 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n     val message = buildRequest(inflightAlterIsrItems)\n-    def responseHandler(response: ClientResponse): Unit = {\n-      try {\n-        val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-        handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n-      } finally {\n-        // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-        if (!inflightRequest.compareAndSet(true, false)) {\n-          throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+\n+    def clearInflightRequests(): Unit = {\n+      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n+      if (!inflightRequest.compareAndSet(true, false)) {\n+        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+      }\n+    }\n+\n+    class AlterIsrResponseHandler extends ControllerRequestCompletionHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b0077c37e9783dc3b7e91f16ff10306e30d1af5"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk0ODE0MQ==", "bodyText": "I don't think we actually have the ability to cancel in-flight requests. The problem is that many partitions can have ISR changes batched together in a single request. So we couldn't cancel one without cancelling them all.\nA new LeaderAndIsr arriving will just overwrite the existing isrState in Partition which will effectively cause any in-flight AlterIsr response to be ignored (for that partition)", "url": "https://github.com/apache/kafka/pull/9564#discussion_r537948141", "createdAt": "2020-12-08T00:52:34Z", "author": {"login": "mumrah"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -88,20 +88,34 @@ class AlterIsrManagerImpl(val controllerChannelManager: BrokerToControllerChanne\n \n   private def sendRequest(inflightAlterIsrItems: Seq[AlterIsrItem]): Unit = {\n     val message = buildRequest(inflightAlterIsrItems)\n-    def responseHandler(response: ClientResponse): Unit = {\n-      try {\n-        val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n-        handleAlterIsrResponse(body, message.brokerEpoch(), inflightAlterIsrItems)\n-      } finally {\n-        // Be sure to clear the in-flight flag to allow future AlterIsr requests\n-        if (!inflightRequest.compareAndSet(true, false)) {\n-          throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+\n+    def clearInflightRequests(): Unit = {\n+      // Be sure to clear the in-flight flag to allow future AlterIsr requests\n+      if (!inflightRequest.compareAndSet(true, false)) {\n+        throw new IllegalStateException(\"AlterIsr response callback called when no requests were in flight\")\n+      }\n+    }\n+\n+    class AlterIsrResponseHandler extends ControllerRequestCompletionHandler {\n+      override def onComplete(response: ClientResponse): Unit = {\n+        try {\n+          val body = response.responseBody().asInstanceOf[AlterIsrResponse]\n+          handleAlterIsrResponse(body, message.brokerEpoch, inflightAlterIsrItems)\n+        } finally {\n+          clearInflightRequests()\n         }\n       }\n+\n+      override def onTimeout(): Unit = {\n+        throw new IllegalStateException(\"Encountered unexpected timeout when sending AlterIsr to the controller\")\n+      }\n     }\n \n     debug(s\"Sending AlterIsr to controller $message\")\n-    controllerChannelManager.sendRequest(new AlterIsrRequest.Builder(message), responseHandler)\n+    // We will not timeout AlterISR request, instead letting it retry indefinitely\n+    // until a response is received or the request is cancelled after receiving new LeaderAndIsr state.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b0077c37e9783dc3b7e91f16ff10306e30d1af5"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8da21df56cb4bc9eab0e34d3cf70200cbc5eed5a", "author": {"user": {"login": "abbccdda", "name": "Boyang Chen"}}, "url": "https://github.com/apache/kafka/commit/8da21df56cb4bc9eab0e34d3cf70200cbc5eed5a", "committedDate": "2020-12-08T01:19:40Z", "message": "address David comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NTEzMjg4", "url": "https://github.com/apache/kafka/pull/9564#pullrequestreview-547513288", "createdAt": "2020-12-08T18:30:32Z", "commit": {"oid": "8da21df56cb4bc9eab0e34d3cf70200cbc5eed5a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NTI4OTcy", "url": "https://github.com/apache/kafka/pull/9564#pullrequestreview-547528972", "createdAt": "2020-12-08T18:50:47Z", "commit": {"oid": "8da21df56cb4bc9eab0e34d3cf70200cbc5eed5a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2701, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}