{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY5NDA2MTkw", "number": 8024, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNjowOTo0MFrODegzqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNjowOTo0MFrODegzqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzMzIxMzg2OnYy", "diffSide": "RIGHT", "path": "streams/streams-scala/src/test/scala/org/apache/kafka/streams/scala/kstream/KStreamTest.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNjowOTo0MFrOFnsAzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNjowOTo0MFrOFnsAzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE1OTg4NQ==", "bodyText": "Sorry to chime in so late on this. I looked at this test before and missed something, which I have just now noticed.\nThis test inserts an extra operation that defeats the purpose of the test. We should not do groupBy().count(), just the toTable on both streams, followed immediately by the join. The joiner can just concatenate both values and the verification should read the output as a map and ensure the final value is \"topic1value1topic2value1\".\nAdding the groupBy and count results in a repartition and stateful operation, potentially masking a failure to auto-materialize the toTable.\nIf you like, you can leave this test (there's nothing wrong with it per se) and just add a new test doing what I described.", "url": "https://github.com/apache/kafka/pull/8024#discussion_r377159885", "createdAt": "2020-02-10T16:09:40Z", "author": {"login": "vvcephei"}, "path": "streams/streams-scala/src/test/scala/org/apache/kafka/streams/scala/kstream/KStreamTest.scala", "diffHunk": "@@ -312,4 +312,28 @@ class KStreamTest extends FlatSpec with Matchers with TestDriver {\n \n     testDriver.close()\n   }\n+\n+  \"join 2 KStreamToTables\" should \"join correctly records\" in {\n+    val builder = new StreamsBuilder()\n+    val sourceTopic1 = \"source1\"\n+    val sourceTopic2 = \"source2\"\n+    val sinkTopic = \"sink\"\n+\n+    val table1 = builder.stream[String, String](sourceTopic1).toTable.groupBy((k, v) => (k, v)).count()\n+    val table2 = builder.stream[String, String](sourceTopic2).toTable.groupBy((k, v) => (k, v)).count()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4164, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}