{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgzMTQ3NDE5", "number": 9275, "title": "KAFKA-10435; Fetch protocol changes for KIP-595", "bodyText": "This patch bumps the Fetch protocol as specified by KIP-595: https://cwiki.apache.org/confluence/display/KAFKA/KIP-595%3A+A+Raft+Protocol+for+the+Metadata+Quorum. The main differences are the following:\n\nTruncation detection\nLeader discovery through the response\nFlexible version support\n\nThe most notable change is truncation detection. This patch adds logic in the request handling path to detect truncation, but it does not change the replica fetchers to make use of this capability. We are planning to do this separately.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-09-09T21:27:56Z", "url": "https://github.com/apache/kafka/pull/9275", "merged": true, "mergeCommit": {"oid": "634c9175054cc69d10b6da22ea1e95edff6a4747"}, "closed": true, "closedAt": "2020-09-15T20:38:17Z", "author": {"login": "hachikuji"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdHnJA_gH2gAyNDgzMTQ3NDE5OjBkZTZjYzVmN2IwNjJkZTk4ZmRlMDgwY2EwODAyZGM4YTMzN2IxYzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJgDS_gFqTQ4OTg1NDQ5OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0de6cc5f7b062de98fde080ca0802dc8a337b1c7", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/0de6cc5f7b062de98fde080ca0802dc8a337b1c7", "committedDate": "2020-09-10T20:50:51Z", "message": "KAFKA-10435; Fetch protocol changes for KIP-595"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "0de6cc5f7b062de98fde080ca0802dc8a337b1c7", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/0de6cc5f7b062de98fde080ca0802dc8a337b1c7", "committedDate": "2020-09-10T20:50:51Z", "message": "KAFKA-10435; Fetch protocol changes for KIP-595"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3ODI2MzQ1", "url": "https://github.com/apache/kafka/pull/9275#pullrequestreview-487826345", "createdAt": "2020-09-14T14:26:14Z", "commit": {"oid": "0de6cc5f7b062de98fde080ca0802dc8a337b1c7"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNDoyNjoxNVrOHRXmAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNTo1MzoyM1rOHRbvBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk3NDQwMQ==", "bodyText": "currentLeaderEpoch and lastFetchEpoch are both set to -1 by default, but they are set in different ways above, is that deliberate?", "url": "https://github.com/apache/kafka/pull/9275#discussion_r487974401", "createdAt": "2020-09-14T14:26:15Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/FetchRequest.java", "diffHunk": "@@ -232,19 +263,25 @@ public FetchRequest build(short version) {\n             // We collect the partitions in a single FetchTopic only if they appear sequentially in the fetchData\n             FetchRequestData.FetchTopic fetchTopic = null;\n             for (Map.Entry<TopicPartition, PartitionData> entry : fetchData.entrySet()) {\n-                if (fetchTopic == null || !entry.getKey().topic().equals(fetchTopic.topic())) {\n+                TopicPartition topicPartition = entry.getKey();\n+                PartitionData partitionData = entry.getValue();\n+\n+                if (fetchTopic == null || !topicPartition.topic().equals(fetchTopic.topic())) {\n                     fetchTopic = new FetchRequestData.FetchTopic()\n-                       .setTopic(entry.getKey().topic())\n+                       .setTopic(topicPartition.topic())\n                        .setPartitions(new ArrayList<>());\n                     fetchRequestData.topics().add(fetchTopic);\n                 }\n \n-                fetchTopic.partitions().add(\n-                    new FetchRequestData.FetchPartition().setPartition(entry.getKey().partition())\n-                        .setCurrentLeaderEpoch(entry.getValue().currentLeaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH))\n-                        .setFetchOffset(entry.getValue().fetchOffset)\n-                        .setLogStartOffset(entry.getValue().logStartOffset)\n-                        .setPartitionMaxBytes(entry.getValue().maxBytes));\n+                FetchRequestData.FetchPartition fetchPartition = new FetchRequestData.FetchPartition()\n+                    .setPartition(topicPartition.partition())\n+                    .setCurrentLeaderEpoch(partitionData.currentLeaderEpoch.orElse(RecordBatch.NO_PARTITION_LEADER_EPOCH))\n+                    .setFetchOffset(partitionData.fetchOffset)\n+                    .setLogStartOffset(partitionData.logStartOffset)\n+                    .setPartitionMaxBytes(partitionData.maxBytes);\n+                partitionData.lastFetchedEpoch.ifPresent(fetchPartition::setLastFetchedEpoch);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0de6cc5f7b062de98fde080ca0802dc8a337b1c7"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk4OTI3Ng==", "bodyText": "we could produce without retries, wait for completion and then check exact value?", "url": "https://github.com/apache/kafka/pull/9275#discussion_r487989276", "createdAt": "2020-09-14T14:45:15Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/server/FetchRequestTest.scala", "diffHunk": "@@ -212,6 +212,44 @@ class FetchRequestTest extends BaseRequestTest {\n     assertEquals(Errors.NOT_LEADER_OR_FOLLOWER, partitionData.error)\n   }\n \n+  @Test\n+  def testLastFetchedEpochValidation(): Unit = {\n+    val topic = \"topic\"\n+    val topicPartition = new TopicPartition(topic, 0)\n+    val partitionToLeader = TestUtils.createTopic(zkClient, topic, numPartitions = 1, replicationFactor = 3, servers)\n+    val firstLeaderId = partitionToLeader(topicPartition.partition)\n+    val firstLeaderEpoch = TestUtils.findLeaderEpoch(firstLeaderId, topicPartition, servers)\n+\n+    initProducer()\n+\n+    // Write some data in epoch 0\n+    produceData(Seq(topicPartition), 100)\n+    // Force a leader change\n+    killBroker(firstLeaderId)\n+    // Write some more data\n+    produceData(Seq(topicPartition), 100)\n+\n+    val secondLeaderId = TestUtils.awaitLeaderChange(servers, topicPartition, firstLeaderId)\n+    val secondLeaderEpoch = TestUtils.findLeaderEpoch(secondLeaderId, topicPartition, servers)\n+\n+    // Build a fetch request at offset 150 with last fetched epoch 0\n+    val fetchOffset = 150\n+    val partitionMap = new util.LinkedHashMap[TopicPartition, FetchRequest.PartitionData]\n+    partitionMap.put(topicPartition, new FetchRequest.PartitionData(fetchOffset, 0L, 1024,\n+      Optional.of(secondLeaderEpoch), Optional.of(firstLeaderEpoch)))\n+    val fetchRequest = FetchRequest.Builder.forConsumer(0, 1, partitionMap).build()\n+\n+    // Validate the expected truncation\n+    val fetchResponse = sendFetchRequest(secondLeaderId, fetchRequest)\n+    val partitionData = fetchResponse.responseData.get(topicPartition)\n+    assertEquals(Errors.NONE, partitionData.error)\n+    assertEquals(0L, partitionData.records.sizeInBytes())\n+    assertTrue(partitionData.truncationOffset.isPresent)\n+\n+    // Should be exactly 100, but use a fuzzy truncation estimate in case there were produce retries\n+    assertTrue(partitionData.truncationOffset.get < 150)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0de6cc5f7b062de98fde080ca0802dc8a337b1c7"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA0MjI0NQ==", "bodyText": "I guess we would always be removing a range from the start or end. Are we going through the whole map and checking each one because there is no suitable API to remove multiple entries from start or end?", "url": "https://github.com/apache/kafka/pull/9275#discussion_r488042245", "createdAt": "2020-09-14T15:53:23Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/epoch/LeaderEpochFileCache.scala", "diffHunk": "@@ -91,8 +95,23 @@ class LeaderEpochFileCache(topicPartition: TopicPartition,\n     }\n   }\n \n+  def removeEntries(predicate: EpochEntry => Boolean): Seq[EpochEntry] = {\n+    val removedEpochs = mutable.ListBuffer.empty[EpochEntry]\n+    val iterator = epochs.entrySet().iterator()\n+\n+    while (iterator.hasNext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0de6cc5f7b062de98fde080ca0802dc8a337b1c7"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3OTIyMjE4", "url": "https://github.com/apache/kafka/pull/9275#pullrequestreview-487922218", "createdAt": "2020-09-14T16:00:13Z", "commit": {"oid": "0de6cc5f7b062de98fde080ca0802dc8a337b1c7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb821421f3c5dbaccc58cb6f28b80eb3963af41b", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/eb821421f3c5dbaccc58cb6f28b80eb3963af41b", "committedDate": "2020-09-15T03:11:35Z", "message": "Improve efficiency of epoch cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4OTAxOTI5", "url": "https://github.com/apache/kafka/pull/9275#pullrequestreview-488901929", "createdAt": "2020-09-15T17:20:46Z", "commit": {"oid": "eb821421f3c5dbaccc58cb6f28b80eb3963af41b"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNzoyMDo0N1rOHSMBHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNzoyMDo0N1rOHSMBHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzMzMwOQ==", "bodyText": "Do we need to check again inside the lock before update because this is outside the lock?", "url": "https://github.com/apache/kafka/pull/9275#discussion_r488833309", "createdAt": "2020-09-15T17:20:47Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/server/epoch/LeaderEpochFileCache.scala", "diffHunk": "@@ -47,63 +47,81 @@ class LeaderEpochFileCache(topicPartition: TopicPartition,\n   private val epochs = new util.TreeMap[Int, EpochEntry]()\n \n   inWriteLock(lock) {\n-    checkpoint.read().foreach { entry =>\n-      epochs.put(entry.epoch, entry)\n-    }\n+    checkpoint.read().foreach(assign)\n   }\n \n   /**\n     * Assigns the supplied Leader Epoch to the supplied Offset\n     * Once the epoch is assigned it cannot be reassigned\n     */\n   def assign(epoch: Int, startOffset: Long): Unit = {\n-    inWriteLock(lock) {\n-      val updateNeeded = if (epochs.isEmpty) {\n-        true\n-      } else {\n-        val lastEntry = epochs.lastEntry.getValue\n-        lastEntry.epoch != epoch || startOffset < lastEntry.startOffset\n-      }\n+    val entry = EpochEntry(epoch, startOffset)\n+    if (assign(entry)) {\n+      debug(s\"Appended new epoch entry $entry. Cache now contains ${epochs.size} entries.\")\n+      flush()\n+    }\n+  }\n \n-      if (updateNeeded) {\n-        truncateAndAppend(EpochEntry(epoch, startOffset))\n-        flush()\n+  private def assign(entry: EpochEntry): Boolean = {\n+    if (entry.epoch < 0 || entry.startOffset < 0) {\n+      throw new IllegalArgumentException(s\"Received invalid partition leader epoch entry $entry\")\n+    }\n+\n+    // Check whether the append is needed before acquiring the write lock\n+    // in order to avoid contention with readers in the common case\n+    latestEntry.foreach { lastEntry =>\n+      if (entry.epoch == lastEntry.epoch && entry.startOffset >= lastEntry.startOffset) {\n+        return false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb821421f3c5dbaccc58cb6f28b80eb3963af41b"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00867faf4ec2ac8b520191320832e88eb8fd1e83", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/00867faf4ec2ac8b520191320832e88eb8fd1e83", "committedDate": "2020-09-15T17:45:46Z", "message": "Check whether update is needed in write lock"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4OTIzNjY0", "url": "https://github.com/apache/kafka/pull/9275#pullrequestreview-488923664", "createdAt": "2020-09-15T17:47:18Z", "commit": {"oid": "00867faf4ec2ac8b520191320832e88eb8fd1e83"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5ODU0NDk4", "url": "https://github.com/apache/kafka/pull/9275#pullrequestreview-489854498", "createdAt": "2020-09-16T17:43:06Z", "commit": {"oid": "00867faf4ec2ac8b520191320832e88eb8fd1e83"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNzo0MzowN1rOHS7jTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQxNzo0MzowN1rOHS7jTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTYxMjEwOQ==", "bodyText": "Maybe you can fix this typo in your next PR.", "url": "https://github.com/apache/kafka/pull/9275#discussion_r489612109", "createdAt": "2020-09-16T17:43:07Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/api/ApiVersion.scala", "diffHunk": "@@ -100,7 +100,9 @@ object ApiVersion {\n     // Introduced StopReplicaRequest V3 containing the leader epoch for each partition (KIP-570)\n     KAFKA_2_6_IV0,\n     // Introduced feature versioning support (KIP-584)\n-    KAFKA_2_7_IV0\n+    KAFKA_2_7_IV0,\n+    // Bup Fetch protocol for Raft protocol (KIP-595)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00867faf4ec2ac8b520191320832e88eb8fd1e83"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 596, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}