{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyMjcyNjc0", "number": 8469, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDozODo0NVrODxb7UA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMzo0ODoyN1rODxeAmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTY0MzY4OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/log/Log.scala", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDozODo0NVrOGE6C8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNTozNToxNlrOGFUnQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5ODUxNA==", "bodyText": "While you are here, it's probably better to consistently throw IllegalArgumentException if from > to. Currently, we only throw IllegalArgumentException if we get into this path.", "url": "https://github.com/apache/kafka/pull/8469#discussion_r407798514", "createdAt": "2020-04-14T00:38:45Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -2132,17 +2132,23 @@ class Log(@volatile private var _dir: File,\n \n   /**\n    * Get all segments beginning with the segment that includes \"from\" and ending with the segment\n-   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset)\n+   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset).\n+   *\n    */\n   def logSegments(from: Long, to: Long): Iterable[LogSegment] = {\n-    lock synchronized {\n-      val view = Option(segments.floorKey(from)).map { floor =>\n-        if (to < floor)\n-          throw new IllegalArgumentException(s\"Invalid log segment range: requested segments in $topicPartition \" +\n-            s\"from offset $from mapping to segment with base offset $floor, which is greater than limit offset $to\")\n-        segments.subMap(floor, to)\n-      }.getOrElse(segments.headMap(to))\n-      view.values.asScala\n+    if (from == to) {\n+      // Handle non-segment-aligned empty sets\n+      List.empty[LogSegment]\n+    } else {\n+      lock synchronized {\n+        val view = Option(segments.floorKey(from)).map { floor =>\n+          if (to < floor)\n+            throw new IllegalArgumentException(s\"Invalid log segment range: requested segments in $topicPartition \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9c1dc6495a6d5cbcc38cdb05b5cb8d86c48852f"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIzMzc5Mg==", "bodyText": "Done.", "url": "https://github.com/apache/kafka/pull/8469#discussion_r408233792", "createdAt": "2020-04-14T15:35:16Z", "author": {"login": "steverod"}, "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -2132,17 +2132,23 @@ class Log(@volatile private var _dir: File,\n \n   /**\n    * Get all segments beginning with the segment that includes \"from\" and ending with the segment\n-   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset)\n+   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset).\n+   *\n    */\n   def logSegments(from: Long, to: Long): Iterable[LogSegment] = {\n-    lock synchronized {\n-      val view = Option(segments.floorKey(from)).map { floor =>\n-        if (to < floor)\n-          throw new IllegalArgumentException(s\"Invalid log segment range: requested segments in $topicPartition \" +\n-            s\"from offset $from mapping to segment with base offset $floor, which is greater than limit offset $to\")\n-        segments.subMap(floor, to)\n-      }.getOrElse(segments.headMap(to))\n-      view.values.asScala\n+    if (from == to) {\n+      // Handle non-segment-aligned empty sets\n+      List.empty[LogSegment]\n+    } else {\n+      lock synchronized {\n+        val view = Option(segments.floorKey(from)).map { floor =>\n+          if (to < floor)\n+            throw new IllegalArgumentException(s\"Invalid log segment range: requested segments in $topicPartition \" +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5ODUxNA=="}, "originalCommit": {"oid": "c9c1dc6495a6d5cbcc38cdb05b5cb8d86c48852f"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTY0NDg3OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/log/Log.scala", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDozOToxNVrOGE6Dlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNTozNDo0OFrOGFUmCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5ODY3OQ==", "bodyText": "Do we need to add a new line?", "url": "https://github.com/apache/kafka/pull/8469#discussion_r407798679", "createdAt": "2020-04-14T00:39:15Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -2132,17 +2132,23 @@ class Log(@volatile private var _dir: File,\n \n   /**\n    * Get all segments beginning with the segment that includes \"from\" and ending with the segment\n-   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset)\n+   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset).\n+   *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9c1dc6495a6d5cbcc38cdb05b5cb8d86c48852f"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIzMzQ4Mw==", "bodyText": "Line removed.", "url": "https://github.com/apache/kafka/pull/8469#discussion_r408233483", "createdAt": "2020-04-14T15:34:48Z", "author": {"login": "steverod"}, "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -2132,17 +2132,23 @@ class Log(@volatile private var _dir: File,\n \n   /**\n    * Get all segments beginning with the segment that includes \"from\" and ending with the segment\n-   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset)\n+   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset).\n+   *", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5ODY3OQ=="}, "originalCommit": {"oid": "c9c1dc6495a6d5cbcc38cdb05b5cb8d86c48852f"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTk4NDg4OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/log/Log.scala", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMzo0ODoyN1rOGE9K7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDoyNTo0MlrOGFfkvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0OTcwOQ==", "bodyText": "Do we still need this given the test in line 2141?", "url": "https://github.com/apache/kafka/pull/8469#discussion_r407849709", "createdAt": "2020-04-14T03:48:27Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -2132,17 +2132,25 @@ class Log(@volatile private var _dir: File,\n \n   /**\n    * Get all segments beginning with the segment that includes \"from\" and ending with the segment\n-   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset)\n+   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset).\n    */\n   def logSegments(from: Long, to: Long): Iterable[LogSegment] = {\n-    lock synchronized {\n-      val view = Option(segments.floorKey(from)).map { floor =>\n-        if (to < floor)\n-          throw new IllegalArgumentException(s\"Invalid log segment range: requested segments in $topicPartition \" +\n-            s\"from offset $from mapping to segment with base offset $floor, which is greater than limit offset $to\")\n-        segments.subMap(floor, to)\n-      }.getOrElse(segments.headMap(to))\n-      view.values.asScala\n+    if (from == to) {\n+      // Handle non-segment-aligned empty sets\n+      List.empty[LogSegment]\n+    } else if (to < from) {\n+      throw new IllegalArgumentException(s\"Invalid log segment range: requested segments in $topicPartition \" +\n+        s\"from offset $from which is greater than limit offset $to\")\n+    } else {\n+      lock synchronized {\n+        val view = Option(segments.floorKey(from)).map { floor =>\n+          if (to < floor)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4d9456028c544c9a2e899f4d2ac10e2cc2b7d8c"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMzOTI5Mw==", "bodyText": "Was the change to this pushed?", "url": "https://github.com/apache/kafka/pull/8469#discussion_r408339293", "createdAt": "2020-04-14T18:14:44Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -2132,17 +2132,25 @@ class Log(@volatile private var _dir: File,\n \n   /**\n    * Get all segments beginning with the segment that includes \"from\" and ending with the segment\n-   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset)\n+   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset).\n    */\n   def logSegments(from: Long, to: Long): Iterable[LogSegment] = {\n-    lock synchronized {\n-      val view = Option(segments.floorKey(from)).map { floor =>\n-        if (to < floor)\n-          throw new IllegalArgumentException(s\"Invalid log segment range: requested segments in $topicPartition \" +\n-            s\"from offset $from mapping to segment with base offset $floor, which is greater than limit offset $to\")\n-        segments.subMap(floor, to)\n-      }.getOrElse(segments.headMap(to))\n-      view.values.asScala\n+    if (from == to) {\n+      // Handle non-segment-aligned empty sets\n+      List.empty[LogSegment]\n+    } else if (to < from) {\n+      throw new IllegalArgumentException(s\"Invalid log segment range: requested segments in $topicPartition \" +\n+        s\"from offset $from which is greater than limit offset $to\")\n+    } else {\n+      lock synchronized {\n+        val view = Option(segments.floorKey(from)).map { floor =>\n+          if (to < floor)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0OTcwOQ=="}, "originalCommit": {"oid": "b4d9456028c544c9a2e899f4d2ac10e2cc2b7d8c"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQxMzM3Mw==", "bodyText": "I mistakenly marked this as resolved (then unset it). Change was tested and just pushed, apologies for the unwanted notification!", "url": "https://github.com/apache/kafka/pull/8469#discussion_r408413373", "createdAt": "2020-04-14T20:25:42Z", "author": {"login": "steverod"}, "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -2132,17 +2132,25 @@ class Log(@volatile private var _dir: File,\n \n   /**\n    * Get all segments beginning with the segment that includes \"from\" and ending with the segment\n-   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset)\n+   * that includes up to \"to-1\" or the end of the log (if to > logEndOffset).\n    */\n   def logSegments(from: Long, to: Long): Iterable[LogSegment] = {\n-    lock synchronized {\n-      val view = Option(segments.floorKey(from)).map { floor =>\n-        if (to < floor)\n-          throw new IllegalArgumentException(s\"Invalid log segment range: requested segments in $topicPartition \" +\n-            s\"from offset $from mapping to segment with base offset $floor, which is greater than limit offset $to\")\n-        segments.subMap(floor, to)\n-      }.getOrElse(segments.headMap(to))\n-      view.values.asScala\n+    if (from == to) {\n+      // Handle non-segment-aligned empty sets\n+      List.empty[LogSegment]\n+    } else if (to < from) {\n+      throw new IllegalArgumentException(s\"Invalid log segment range: requested segments in $topicPartition \" +\n+        s\"from offset $from which is greater than limit offset $to\")\n+    } else {\n+      lock synchronized {\n+        val view = Option(segments.floorKey(from)).map { floor =>\n+          if (to < floor)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg0OTcwOQ=="}, "originalCommit": {"oid": "b4d9456028c544c9a2e899f4d2ac10e2cc2b7d8c"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2972, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}