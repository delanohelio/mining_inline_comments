{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczNDYwOTcx", "number": 8087, "title": "KAFKA-9525: add enforceRebalance method to Consumer API", "bodyText": "As described in KIP-568.\nWaiting on acceptance of the KIP to write the tests, on the off chance something changes. But rest assured unit tests are coming \u26a1\ufe0f\nWill also kick off existing Streams system tests which leverage this new API (eg version probing, sometimes broker bounce)", "createdAt": "2020-02-11T03:46:51Z", "url": "https://github.com/apache/kafka/pull/8087", "merged": true, "mergeCommit": {"oid": "a1f2ece323e59a751a55386bf06beb5724c56545"}, "closed": true, "closedAt": "2020-03-01T02:44:23Z", "author": {"login": "ableegoldman"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcDZuZ1ABqjMwMjg1MzYyNjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcJP6U0gFqTM2NjgzMTQ1NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzI4ODg1", "url": "https://github.com/apache/kafka/pull/8087#pullrequestreview-362328885", "createdAt": "2020-02-21T00:23:53Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMDoyMzo1NFrOFsn08A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMDozNDo1N1rOFsoBFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNDE5Mg==", "bodyText": "The kind of ... more than group membership and metadata is a bit unclear what it tries to convey. Or are you trying to say \"E.g. you want to trigger a rebalance with newly encoded subscription metadata, but none of the membership or subscription topics or patterns have changed so consumer group would not automatically rebalance, you can use this function\"?", "url": "https://github.com/apache/kafka/pull/8087#discussion_r382334192", "createdAt": "2020-02-21T00:23:54Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/KafkaConsumer.java", "diffHunk": "@@ -2245,6 +2245,44 @@ public ConsumerGroupMetadata groupMetadata() {\n         return coordinator.groupMetadata();\n     }\n \n+    /**\n+     * Alert the consumer to trigger a new rebalance by rejoining the group. This is a nonblocking call that forces\n+     * the consumer to trigger a new rebalance on the next {@link #poll(Duration)} call. Note that this API does not\n+     * itself initiate the rebalance, so you must still call {@link #poll(Duration)}. If a rebalance is already in\n+     * progress the method will return false to indicate that it was a no-op. You can use this to decide whether to\n+     * just complete the current rebalance or retry in case the current rebalance does not include the latest\n+     * subscription metadata; however, in most cases it is better to determine that based on the resulting assignment\n+     * of the current rebalance. Only when it is not possible to validate whether the latest metadata was used based\n+     * on the received assignment should you consider retrying based on the return value.\n+     * <p>\n+     * You should not need to call this during normal processing, as the consumer group will manage itself\n+     * automatically and rebalance when necessary. However there may be situations where the application wishes to\n+     * trigger a rebalance that would otherwise not occur. For example, if some condition external and invisible to\n+     * the Consumer and its group membership changes in a way that has implications for the partition assignment,\n+     * this method can be used to trigger a reassignment. The kind of system change that would merit calling this\n+     * method is one that would also be reflected in the {@link org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Subscription Subscription}\n+     * userdata that is passed to the assignor so it can make assignment decisions based on more than group membership\n+     * and metadata. If your assignor does not use this userdata, or you do not use a custom", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNzMwMg==", "bodyText": "Previously in unsubscribe we do make sure all tasks are closed before re-subscribing, now we are relying on the consumer's response to let us know which (subset of) tasks are to be closed -- so although the task-migrated is triggered by fenced, if the heartbeat thread has not got the error code and reset the group info we would not call onPartitionsLost before re-joining the group, in that case would we possibly have more than one instance claiming to own some same partitions? Worth checking the consumer.assign function to see if the code already handles this case.\nGenerally speaking I do not know if it would expose any edge cases or not. Better run our system tests a couple of times to make sure?", "url": "https://github.com/apache/kafka/pull/8087#discussion_r382337302", "createdAt": "2020-02-21T00:34:57Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -747,23 +747,18 @@ private void runLoop() {\n                 if (assignmentErrorCode.get() == AssignorError.VERSION_PROBING.code()) {\n                     log.info(\"Version probing detected. Triggering new rebalance.\");\n                     assignmentErrorCode.set(AssignorError.NONE.code());\n-                    enforceRebalance();\n+                    consumer.enforceRebalance();\n                 }\n             } catch (final TaskMigratedException ignoreAndRejoinGroup) {\n                 log.warn(\"Detected task {} that got migrated to another thread. \" +\n                              \"This implies that this thread missed a rebalance and dropped out of the consumer group. \" +\n                              \"Will try to rejoin the consumer group.\", ignoreAndRejoinGroup.migratedTaskId());\n \n-                enforceRebalance();\n+                consumer.enforceRebalance();\n             }\n         }\n     }\n \n-    private void enforceRebalance() {\n-        consumer.unsubscribe();\n-        subscribeConsumer();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyODMyNzE5", "url": "https://github.com/apache/kafka/pull/8087#pullrequestreview-362832719", "createdAt": "2020-02-21T18:35:22Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxODozNToyM1rOFtAm0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxODozNjoxMFrOFtAoLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc0MDE3Nw==", "bodyText": "s/should not need to/don't need to", "url": "https://github.com/apache/kafka/pull/8087#discussion_r382740177", "createdAt": "2020-02-21T18:35:23Z", "author": {"login": "abbccdda"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/KafkaConsumer.java", "diffHunk": "@@ -2247,6 +2247,44 @@ public ConsumerGroupMetadata groupMetadata() {\n         return coordinator.groupMetadata();\n     }\n \n+    /**\n+     * Alert the consumer to trigger a new rebalance by rejoining the group. This is a nonblocking call that forces\n+     * the consumer to trigger a new rebalance on the next {@link #poll(Duration)} call. Note that this API does not\n+     * itself initiate the rebalance, so you must still call {@link #poll(Duration)}. If a rebalance is already in\n+     * progress the method will return false to indicate that it was a no-op. You can use this to decide whether to\n+     * just complete the current rebalance or retry in case the current rebalance does not include the latest\n+     * subscription metadata; however, in most cases it is better to determine that based on the resulting assignment\n+     * of the current rebalance. Only when it is not possible to validate whether the latest metadata was used based\n+     * on the received assignment should you consider retrying based on the return value.\n+     * <p>\n+     * You should not need to call this during normal processing, as the consumer group will manage itself", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc0MDUyNg==", "bodyText": "I'm also a bit concerned with this change, as we are calling onJoinPrepare before onLeavePrepare which changes the existing sequence for no specific reason.", "url": "https://github.com/apache/kafka/pull/8087#discussion_r382740526", "createdAt": "2020-02-21T18:36:10Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -747,23 +747,18 @@ private void runLoop() {\n                 if (assignmentErrorCode.get() == AssignorError.VERSION_PROBING.code()) {\n                     log.info(\"Version probing detected. Triggering new rebalance.\");\n                     assignmentErrorCode.set(AssignorError.NONE.code());\n-                    enforceRebalance();\n+                    consumer.enforceRebalance();\n                 }\n             } catch (final TaskMigratedException ignoreAndRejoinGroup) {\n                 log.warn(\"Detected task {} that got migrated to another thread. \" +\n                              \"This implies that this thread missed a rebalance and dropped out of the consumer group. \" +\n                              \"Will try to rejoin the consumer group.\", ignoreAndRejoinGroup.migratedTaskId());\n \n-                enforceRebalance();\n+                consumer.enforceRebalance();\n             }\n         }\n     }\n \n-    private void enforceRebalance() {\n-        consumer.unsubscribe();\n-        subscribeConsumer();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNzMwMg=="}, "originalCommit": null, "originalPosition": 20}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzODM2MTQ1", "url": "https://github.com/apache/kafka/pull/8087#pullrequestreview-363836145", "createdAt": "2020-02-25T02:37:09Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwMjozNzowOVrOFt208Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwMjozNzowOVrOFt208Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyODUyOQ==", "bodyText": "@guozhangwang @abbccdda We are still at risk of the race condition on a TaskMigratedException where we call onRevoked instead of onLost -- when we directly call handleLostAll we'll remove all active tasks, then invoking handleRevocation will throw IllegalStateException below", "url": "https://github.com/apache/kafka/pull/8087#discussion_r383628529", "createdAt": "2020-02-25T02:37:09Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -293,6 +293,11 @@ boolean tryToCompleteRestoration() {\n      * @throws TaskMigratedException if the task producer got fenced (EOS only)\n      */\n     void handleRevocation(final Collection<TopicPartition> revokedPartitions) {\n+        if (activeTaskIds().isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTI3ODUy", "url": "https://github.com/apache/kafka/pull/8087#pullrequestreview-364527852", "createdAt": "2020-02-25T23:34:37Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzozNDozN1rOFuZO4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzozNDozN1rOFuZO4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MjIyNw==", "bodyText": "Yeah that makes sense :) I think we are on the same page, and I agree it's a bit hard to convey the message in a straight-forward phrasing. I do not have a strong suggestion here and I think your last sentence actually is good: \"E.g. if there is a change that affects the userdata encoded in the subscription\", consumers would not automatically rebalance and the user may want to use this.", "url": "https://github.com/apache/kafka/pull/8087#discussion_r384192227", "createdAt": "2020-02-25T23:34:37Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/KafkaConsumer.java", "diffHunk": "@@ -2245,6 +2245,44 @@ public ConsumerGroupMetadata groupMetadata() {\n         return coordinator.groupMetadata();\n     }\n \n+    /**\n+     * Alert the consumer to trigger a new rebalance by rejoining the group. This is a nonblocking call that forces\n+     * the consumer to trigger a new rebalance on the next {@link #poll(Duration)} call. Note that this API does not\n+     * itself initiate the rebalance, so you must still call {@link #poll(Duration)}. If a rebalance is already in\n+     * progress the method will return false to indicate that it was a no-op. You can use this to decide whether to\n+     * just complete the current rebalance or retry in case the current rebalance does not include the latest\n+     * subscription metadata; however, in most cases it is better to determine that based on the resulting assignment\n+     * of the current rebalance. Only when it is not possible to validate whether the latest metadata was used based\n+     * on the received assignment should you consider retrying based on the return value.\n+     * <p>\n+     * You should not need to call this during normal processing, as the consumer group will manage itself\n+     * automatically and rebalance when necessary. However there may be situations where the application wishes to\n+     * trigger a rebalance that would otherwise not occur. For example, if some condition external and invisible to\n+     * the Consumer and its group membership changes in a way that has implications for the partition assignment,\n+     * this method can be used to trigger a reassignment. The kind of system change that would merit calling this\n+     * method is one that would also be reflected in the {@link org.apache.kafka.clients.consumer.ConsumerPartitionAssignor.Subscription Subscription}\n+     * userdata that is passed to the assignor so it can make assignment decisions based on more than group membership\n+     * and metadata. If your assignor does not use this userdata, or you do not use a custom", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNDE5Mg=="}, "originalCommit": null, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzE0NTQ5", "url": "https://github.com/apache/kafka/pull/8087#pullrequestreview-365314549", "createdAt": "2020-02-26T23:16:48Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMzoxNjo0OFrOFu_54w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMzoxNjo0OFrOFu_54w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgyNTgyNw==", "bodyText": "nit: maybe extract out the MockRebalanceListener out of ConsumerCoordinatorTest to be shared by multiple test classes?", "url": "https://github.com/apache/kafka/pull/8087#discussion_r384825827", "createdAt": "2020-02-26T23:16:48Z", "author": {"login": "guozhangwang"}, "path": "clients/src/test/java/org/apache/kafka/clients/consumer/KafkaConsumerTest.java", "diffHunk": "@@ -1951,6 +1951,19 @@ public void onPartitionsAssigned(Collection<TopicPartition> partitions) {\n         };\n     }\n \n+    class CountingRebalanceListener implements ConsumerRebalanceListener {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ac705db210ae0a8069d07b6766a154f11ece0f6", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/7ac705db210ae0a8069d07b6766a154f11ece0f6", "committedDate": "2020-02-29T04:54:25Z", "message": "add API -- squashed for rebase"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "7ac705db210ae0a8069d07b6766a154f11ece0f6", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/7ac705db210ae0a8069d07b6766a154f11ece0f6", "committedDate": "2020-02-29T04:54:25Z", "message": "add API -- squashed for rebase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bdc7c3a0ca08b8aea1255f2776aedabad190c3b5", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/bdc7c3a0ca08b8aea1255f2776aedabad190c3b5", "committedDate": "2020-02-29T22:55:51Z", "message": "fix log message used in VP test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2ODMxNDU1", "url": "https://github.com/apache/kafka/pull/8087#pullrequestreview-366831455", "createdAt": "2020-03-01T02:43:41Z", "commit": {"oid": "bdc7c3a0ca08b8aea1255f2776aedabad190c3b5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1843, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}