{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2OTM2MjQy", "number": 8280, "title": "KAFKA-9707: Fix InsertField.Key should apply to keys of tombstone records", "bodyText": "Fix typo that hardcoded .value() instead of abstract operatingValue\nAdd test for Key transform that was previously not tested\n\nSigned-off-by: Greg Harris gregh@confluent.io\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-03-11T21:49:11Z", "url": "https://github.com/apache/kafka/pull/8280", "merged": true, "mergeCommit": {"oid": "008a3b21f6c3670f4030da2280596155e57241b0"}, "closed": true, "closedAt": "2020-03-26T17:21:12Z", "author": {"login": "gharris1727"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcMuQXegH2gAyMzg2OTM2MjQyOjI1Njk2YjMzZDZmYWE0ZTJiOTcxMTlhZDZmMThkM2RiZTVkY2NjZDk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcRfFz-AFqTM4MjIxMjA1MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "25696b33d6faa4e2b97119ad6f18d3dbe5dcccd9", "author": {"user": {"login": "gharris1727", "name": "Greg Harris"}}, "url": "https://github.com/apache/kafka/commit/25696b33d6faa4e2b97119ad6f18d3dbe5dcccd9", "committedDate": "2020-03-11T21:46:41Z", "message": "KAFKA-9707: Fix InsertField.Key not applying to tombstone events\n\n* Fix typo that hardcoded .value() instead of abstract operatingValue\n* Add test for Key transform that was previously not tested\n\nSigned-off-by: Greg Harris <gregh@confluent.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczMTc1NjMy", "url": "https://github.com/apache/kafka/pull/8280#pullrequestreview-373175632", "createdAt": "2020-03-11T22:42:29Z", "commit": {"oid": "25696b33d6faa4e2b97119ad6f18d3dbe5dcccd9"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo0MjoyOVrOF1Lwmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo0MjoyOVrOF1Lwmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMTUxNA==", "bodyText": "Maybe also assertNull the value just for completeness?", "url": "https://github.com/apache/kafka/pull/8280#discussion_r391311514", "createdAt": "2020-03-11T22:42:29Z", "author": {"login": "ncliang"}, "path": "connect/transforms/src/test/java/org/apache/kafka/connect/transforms/InsertFieldTest.java", "diffHunk": "@@ -141,16 +142,39 @@ public void insertConfiguredFieldsIntoTombstoneEventWithSchemaLeavesValueUnchang\n         props.put(\"static.field\", \"instance_id\");\n         props.put(\"static.value\", \"my-instance-id\");\n \n-        xform.configure(props);\n+        xformValue.configure(props);\n \n         final Schema simpleStructSchema = SchemaBuilder.struct().name(\"name\").version(1).doc(\"doc\").field(\"magic\", Schema.OPTIONAL_INT64_SCHEMA).build();\n \n         final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n                 simpleStructSchema, null);\n \n-        final SourceRecord transformedRecord = xform.apply(record);\n+        final SourceRecord transformedRecord = xformValue.apply(record);\n \n         assertEquals(null, transformedRecord.value());\n         assertEquals(simpleStructSchema, transformedRecord.valueSchema());\n     }\n+\n+    @Test\n+    public void insertkeyFieldsIntoTombstoneEvent() {\n+        final Map<String, Object> props = new HashMap<>();\n+        props.put(\"topic.field\", \"topic_field!\");\n+        props.put(\"partition.field\", \"partition_field\");\n+        props.put(\"timestamp.field\", \"timestamp_field?\");\n+        props.put(\"static.field\", \"instance_id\");\n+        props.put(\"static.value\", \"my-instance-id\");\n+\n+        xformKey.configure(props);\n+\n+        final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n+            null, Collections.singletonMap(\"magic\", 42L), null, null);\n+\n+        final SourceRecord transformedRecord = xformKey.apply(record);\n+\n+        assertEquals(42L, ((Map<?, ?>) transformedRecord.key()).get(\"magic\"));\n+        assertEquals(\"test\", ((Map<?, ?>) transformedRecord.key()).get(\"topic_field\"));\n+        assertEquals(0, ((Map<?, ?>) transformedRecord.key()).get(\"partition_field\"));\n+        assertEquals(null, ((Map<?, ?>) transformedRecord.key()).get(\"timestamp_field\"));\n+        assertEquals(\"my-instance-id\", ((Map<?, ?>) transformedRecord.key()).get(\"instance_id\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25696b33d6faa4e2b97119ad6f18d3dbe5dcccd9"}, "originalPosition": 117}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczMTc3OTI5", "url": "https://github.com/apache/kafka/pull/8280#pullrequestreview-373177929", "createdAt": "2020-03-11T22:48:19Z", "commit": {"oid": "25696b33d6faa4e2b97119ad6f18d3dbe5dcccd9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo0ODoxOVrOF1L4WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo0ODoxOVrOF1L4WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMzQ5Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertEquals(\"my-instance-id\", ((Map<?, ?>) transformedRecord.key()).get(\"instance_id\"));\n          \n          \n            \n                    assertEquals(\"my-instance-id\", ((Map<?, ?>) transformedRecord.key()).get(\"instance_id\"));\n          \n          \n            \n                    assertEquals(null, transformedRecord.value());", "url": "https://github.com/apache/kafka/pull/8280#discussion_r391313496", "createdAt": "2020-03-11T22:48:19Z", "author": {"login": "gharris1727"}, "path": "connect/transforms/src/test/java/org/apache/kafka/connect/transforms/InsertFieldTest.java", "diffHunk": "@@ -141,16 +142,39 @@ public void insertConfiguredFieldsIntoTombstoneEventWithSchemaLeavesValueUnchang\n         props.put(\"static.field\", \"instance_id\");\n         props.put(\"static.value\", \"my-instance-id\");\n \n-        xform.configure(props);\n+        xformValue.configure(props);\n \n         final Schema simpleStructSchema = SchemaBuilder.struct().name(\"name\").version(1).doc(\"doc\").field(\"magic\", Schema.OPTIONAL_INT64_SCHEMA).build();\n \n         final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n                 simpleStructSchema, null);\n \n-        final SourceRecord transformedRecord = xform.apply(record);\n+        final SourceRecord transformedRecord = xformValue.apply(record);\n \n         assertEquals(null, transformedRecord.value());\n         assertEquals(simpleStructSchema, transformedRecord.valueSchema());\n     }\n+\n+    @Test\n+    public void insertkeyFieldsIntoTombstoneEvent() {\n+        final Map<String, Object> props = new HashMap<>();\n+        props.put(\"topic.field\", \"topic_field!\");\n+        props.put(\"partition.field\", \"partition_field\");\n+        props.put(\"timestamp.field\", \"timestamp_field?\");\n+        props.put(\"static.field\", \"instance_id\");\n+        props.put(\"static.value\", \"my-instance-id\");\n+\n+        xformKey.configure(props);\n+\n+        final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n+            null, Collections.singletonMap(\"magic\", 42L), null, null);\n+\n+        final SourceRecord transformedRecord = xformKey.apply(record);\n+\n+        assertEquals(42L, ((Map<?, ?>) transformedRecord.key()).get(\"magic\"));\n+        assertEquals(\"test\", ((Map<?, ?>) transformedRecord.key()).get(\"topic_field\"));\n+        assertEquals(0, ((Map<?, ?>) transformedRecord.key()).get(\"partition_field\"));\n+        assertEquals(null, ((Map<?, ?>) transformedRecord.key()).get(\"timestamp_field\"));\n+        assertEquals(\"my-instance-id\", ((Map<?, ?>) transformedRecord.key()).get(\"instance_id\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25696b33d6faa4e2b97119ad6f18d3dbe5dcccd9"}, "originalPosition": 117}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af8eb9207b2fbadd6b9dd8b3157394607029dc63", "author": {"user": {"login": "gharris1727", "name": "Greg Harris"}}, "url": "https://github.com/apache/kafka/commit/af8eb9207b2fbadd6b9dd8b3157394607029dc63", "committedDate": "2020-03-11T22:48:41Z", "message": "Add null value assertion to tombstone test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MDcyODU3", "url": "https://github.com/apache/kafka/pull/8280#pullrequestreview-379072857", "createdAt": "2020-03-23T00:12:47Z", "commit": {"oid": "af8eb9207b2fbadd6b9dd8b3157394607029dc63"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNDYzNzk0", "url": "https://github.com/apache/kafka/pull/8280#pullrequestreview-381463794", "createdAt": "2020-03-25T19:20:38Z", "commit": {"oid": "af8eb9207b2fbadd6b9dd8b3157394607029dc63"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxOToyMDozOFrOF7qtDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxOToyMjozM1rOF7qxJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEwOTk2Nw==", "bodyText": "Can we please clean up the logic? This method no longer returns true if it's just a tombstone record; it also returns true if the key is null for InsertField$Key.\nI'd suggest removing this method altogether and just changing the point where this method is called to simply be:\n          if (operatingValue(record) == null) {", "url": "https://github.com/apache/kafka/pull/8280#discussion_r398109967", "createdAt": "2020-03-25T19:20:38Z", "author": {"login": "rhauch"}, "path": "connect/transforms/src/main/java/org/apache/kafka/connect/transforms/InsertField.java", "diffHunk": "@@ -137,7 +137,7 @@ public R apply(R record) {\n     }\n \n     private boolean isTombstoneRecord(R record) {\n-        return record.value() == null;\n+        return operatingValue(record) == null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af8eb9207b2fbadd6b9dd8b3157394607029dc63"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODExMTAxMg==", "bodyText": "This method is testing that the function works when applied to a tombstone record with a non-null key, but we should add a test that verifies the function skips a record that has a null key.", "url": "https://github.com/apache/kafka/pull/8280#discussion_r398111012", "createdAt": "2020-03-25T19:22:33Z", "author": {"login": "rhauch"}, "path": "connect/transforms/src/test/java/org/apache/kafka/connect/transforms/InsertFieldTest.java", "diffHunk": "@@ -141,16 +142,40 @@ public void insertConfiguredFieldsIntoTombstoneEventWithSchemaLeavesValueUnchang\n         props.put(\"static.field\", \"instance_id\");\n         props.put(\"static.value\", \"my-instance-id\");\n \n-        xform.configure(props);\n+        xformValue.configure(props);\n \n         final Schema simpleStructSchema = SchemaBuilder.struct().name(\"name\").version(1).doc(\"doc\").field(\"magic\", Schema.OPTIONAL_INT64_SCHEMA).build();\n \n         final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n                 simpleStructSchema, null);\n \n-        final SourceRecord transformedRecord = xform.apply(record);\n+        final SourceRecord transformedRecord = xformValue.apply(record);\n \n         assertEquals(null, transformedRecord.value());\n         assertEquals(simpleStructSchema, transformedRecord.valueSchema());\n     }\n+\n+    @Test\n+    public void insertkeyFieldsIntoTombstoneEvent() {\n+        final Map<String, Object> props = new HashMap<>();\n+        props.put(\"topic.field\", \"topic_field!\");\n+        props.put(\"partition.field\", \"partition_field\");\n+        props.put(\"timestamp.field\", \"timestamp_field?\");\n+        props.put(\"static.field\", \"instance_id\");\n+        props.put(\"static.value\", \"my-instance-id\");\n+\n+        xformKey.configure(props);\n+\n+        final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n+            null, Collections.singletonMap(\"magic\", 42L), null, null);\n+\n+        final SourceRecord transformedRecord = xformKey.apply(record);\n+\n+        assertEquals(42L, ((Map<?, ?>) transformedRecord.key()).get(\"magic\"));\n+        assertEquals(\"test\", ((Map<?, ?>) transformedRecord.key()).get(\"topic_field\"));\n+        assertEquals(0, ((Map<?, ?>) transformedRecord.key()).get(\"partition_field\"));\n+        assertEquals(null, ((Map<?, ?>) transformedRecord.key()).get(\"timestamp_field\"));\n+        assertEquals(\"my-instance-id\", ((Map<?, ?>) transformedRecord.key()).get(\"instance_id\"));\n+        assertEquals(null, transformedRecord.value());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af8eb9207b2fbadd6b9dd8b3157394607029dc63"}, "originalPosition": 118}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54ff2b3f12f886ebfbf7bb70ad6f94c832c5a21a", "author": {"user": {"login": "gharris1727", "name": "Greg Harris"}}, "url": "https://github.com/apache/kafka/commit/54ff2b3f12f886ebfbf7bb70ad6f94c832c5a21a", "committedDate": "2020-03-25T19:42:17Z", "message": "Remove mis-named function and add test for passing-through a null-keyed record.\n\nSigned-off-by: Greg Harris <gregh@confluent.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNDgyMTgx", "url": "https://github.com/apache/kafka/pull/8280#pullrequestreview-381482181", "createdAt": "2020-03-25T19:47:29Z", "commit": {"oid": "54ff2b3f12f886ebfbf7bb70ad6f94c832c5a21a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxOTo0NzoyOVrOF7roCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxOTo0NzoyOVrOF7roCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEyNTA2NQ==", "bodyText": "Wouldn't it be sufficient to replace these two asserts with the following?\n   assertSame(record, transformedRecord);\n\nThis is a bit more correct, since we want to assert that in this case the transform returns the original record. WDYT?", "url": "https://github.com/apache/kafka/pull/8280#discussion_r398125065", "createdAt": "2020-03-25T19:47:29Z", "author": {"login": "rhauch"}, "path": "connect/transforms/src/test/java/org/apache/kafka/connect/transforms/InsertFieldTest.java", "diffHunk": "@@ -141,16 +142,60 @@ public void insertConfiguredFieldsIntoTombstoneEventWithSchemaLeavesValueUnchang\n         props.put(\"static.field\", \"instance_id\");\n         props.put(\"static.value\", \"my-instance-id\");\n \n-        xform.configure(props);\n+        xformValue.configure(props);\n \n         final Schema simpleStructSchema = SchemaBuilder.struct().name(\"name\").version(1).doc(\"doc\").field(\"magic\", Schema.OPTIONAL_INT64_SCHEMA).build();\n \n         final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n                 simpleStructSchema, null);\n \n-        final SourceRecord transformedRecord = xform.apply(record);\n+        final SourceRecord transformedRecord = xformValue.apply(record);\n \n         assertEquals(null, transformedRecord.value());\n         assertEquals(simpleStructSchema, transformedRecord.valueSchema());\n     }\n+\n+    @Test\n+    public void insertKeyFieldsIntoTombstoneEvent() {\n+        final Map<String, Object> props = new HashMap<>();\n+        props.put(\"topic.field\", \"topic_field!\");\n+        props.put(\"partition.field\", \"partition_field\");\n+        props.put(\"timestamp.field\", \"timestamp_field?\");\n+        props.put(\"static.field\", \"instance_id\");\n+        props.put(\"static.value\", \"my-instance-id\");\n+\n+        xformKey.configure(props);\n+\n+        final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n+            null, Collections.singletonMap(\"magic\", 42L), null, null);\n+\n+        final SourceRecord transformedRecord = xformKey.apply(record);\n+\n+        assertEquals(42L, ((Map<?, ?>) transformedRecord.key()).get(\"magic\"));\n+        assertEquals(\"test\", ((Map<?, ?>) transformedRecord.key()).get(\"topic_field\"));\n+        assertEquals(0, ((Map<?, ?>) transformedRecord.key()).get(\"partition_field\"));\n+        assertEquals(null, ((Map<?, ?>) transformedRecord.key()).get(\"timestamp_field\"));\n+        assertEquals(\"my-instance-id\", ((Map<?, ?>) transformedRecord.key()).get(\"instance_id\"));\n+        assertEquals(null, transformedRecord.value());\n+    }\n+\n+    @Test\n+    public void insertIntoNullKeyLeavesKeyUnchanged() {\n+        final Map<String, Object> props = new HashMap<>();\n+        props.put(\"topic.field\", \"topic_field!\");\n+        props.put(\"partition.field\", \"partition_field\");\n+        props.put(\"timestamp.field\", \"timestamp_field?\");\n+        props.put(\"static.field\", \"instance_id\");\n+        props.put(\"static.value\", \"my-instance-id\");\n+\n+        xformKey.configure(props);\n+\n+        final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n+          null, null, null, Collections.singletonMap(\"magic\", 42L));\n+\n+        final SourceRecord transformedRecord = xformKey.apply(record);\n+\n+        assertEquals(null, transformedRecord.key());\n+        assertEquals(42L, ((Map<?, ?>) transformedRecord.value()).get(\"magic\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54ff2b3f12f886ebfbf7bb70ad6f94c832c5a21a"}, "originalPosition": 138}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d8105ef99160af136b86fd4fce2a9572c714ca3", "author": {"user": {"login": "gharris1727", "name": "Greg Harris"}}, "url": "https://github.com/apache/kafka/commit/5d8105ef99160af136b86fd4fce2a9572c714ca3", "committedDate": "2020-03-25T19:55:55Z", "message": "Simplify unchanged record assertion\n\nSigned-off-by: Greg Harris <gregh@confluent.io>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a75bcc27e9dc14123cb2ef1c1c651204918ef296", "author": {"user": {"login": "gharris1727", "name": "Greg Harris"}}, "url": "https://github.com/apache/kafka/commit/a75bcc27e9dc14123cb2ef1c1c651204918ef296", "committedDate": "2020-03-25T20:49:02Z", "message": "Replace assertEquals with assertSame\n\nSigned-off-by: Greg Harris <gregh@confluent.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNTI1Njcy", "url": "https://github.com/apache/kafka/pull/8280#pullrequestreview-381525672", "createdAt": "2020-03-25T20:50:28Z", "commit": {"oid": "a75bcc27e9dc14123cb2ef1c1c651204918ef296"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34eacf09195d560b288cafca4e4be036885b7f0a", "author": {"user": {"login": "gharris1727", "name": "Greg Harris"}}, "url": "https://github.com/apache/kafka/commit/34eacf09195d560b288cafca4e4be036885b7f0a", "committedDate": "2020-03-26T05:36:31Z", "message": "Fix checkstyleTest indent issue\n\nSigned-off-by: Greg Harris <gregh@confluent.io>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjEyMDUx", "url": "https://github.com/apache/kafka/pull/8280#pullrequestreview-382212051", "createdAt": "2020-03-26T16:56:12Z", "commit": {"oid": "34eacf09195d560b288cafca4e4be036885b7f0a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 241, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}