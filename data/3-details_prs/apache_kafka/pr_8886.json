{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1NTkzOTg0", "number": 8886, "title": "KAFKA-9891: fix corrupted StandbyTask state", "bodyText": "A StandbyTask must wipe its local state if EOS is enabled and no local\ncheckpoint file is found.\nI left debug statement in on purpose to people can verify the test locally if they want.\n\nwhen the first instance starts up, the store should be empty\nif should process key 0 and put into the store\nafter the second instance is running and has replicated the state, the first instance should process key 1 and crash\nafter fail-over to instance 2, the store should only contain key 0\ninstance 2 should reprocess key 1 (we skip it to avoid the crash for this case; note that the store content in not modified; we only need to do this to make sure instance 1 can be restarted and rebuild the standby store)\ninstance 1 is restarted and rebuild the standby store\nwe stop instance 2 an the store is migrated to instance 1: the store should only contain key 0 (if the fix in StandbyTask is remove, one can observe that the store content is 0 and 1)\nwe re-enable error injection and re-inject the poison pill: instance 1 should fail again (without the fix, no error occurs because key 1 is detected as duplicated)\n\nCall for review @abbccdda @guozhangwang", "createdAt": "2020-06-17T04:23:41Z", "url": "https://github.com/apache/kafka/pull/8886", "merged": true, "mergeCommit": {"oid": "b218dd9d6e287888f0ca65f8e43dd104d88e9a38"}, "closed": true, "closedAt": "2020-06-19T20:01:13Z", "author": {"login": "mjsax"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcsB8rgAH2gAyNDM1NTkzOTg0OjM4MGU0ZmNlM2ZlY2E5N2Q1MTQ0ZTVhNWQ0NDNhMmVhODYwYTE0ODg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcs3q_QgFqTQzNDI4MTE2Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "380e4fce3feca97d5144e5a5d443a2ea860a1488", "author": {"user": {"login": "mjsax", "name": "Matthias J. Sax"}}, "url": "https://github.com/apache/kafka/commit/380e4fce3feca97d5144e5a5d443a2ea860a1488", "committedDate": "2020-06-17T04:14:56Z", "message": "KAFKA-9891: fix corrupted StandbyTask state\n\nA StandbyTask must wipe its local state if EOS is enabled and no local\ncheckpoint file is found."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNTE5NTEz", "url": "https://github.com/apache/kafka/pull/8886#pullrequestreview-432519513", "createdAt": "2020-06-17T15:26:14Z", "commit": {"oid": "380e4fce3feca97d5144e5a5d443a2ea860a1488"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNToyNjoxNFrOGlLLVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTozMzoyMlrOGlLeHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzMzYyMg==", "bodyText": "I'm sure this works, but something seems odd about listing checkpointed partitions to find ones that are not checkpointed. Maybe we need to encapsulate this search, or provide a more semantically appropriate \"list all changelog partitions\" method?", "url": "https://github.com/apache/kafka/pull/8886#discussion_r441633622", "createdAt": "2020-06-17T15:26:14Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -85,6 +85,21 @@ public void initializeMetadata() {}\n     public boolean initializeStateStores() {\n         log.trace(\"Initializing state stores\");\n         registerStateStores();\n+\n+        if (eosEnabled) {\n+            final Set<TopicPartition> partitionsToReinitialize = new HashSet<>();\n+            for (final TopicPartition partition : stateMgr.checkpointed().keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "380e4fce3feca97d5144e5a5d443a2ea860a1488"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzNTM5OQ==", "bodyText": "should this be parameterized for both flavors of eos?", "url": "https://github.com/apache/kafka/pull/8886#discussion_r441635399", "createdAt": "2020-06-17T15:28:45Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.integration;\n+\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.integration.utils.EmbeddedKafkaCluster;\n+import org.apache.kafka.streams.integration.utils.IntegrationTestUtils;\n+import org.apache.kafka.streams.kstream.Transformer;\n+import org.apache.kafka.streams.processor.ProcessorContext;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.Stores;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.apache.kafka.streams.integration.utils.IntegrationTestUtils.startApplicationAndWaitUntilRunning;\n+import static org.apache.kafka.test.TestUtils.waitForCondition;\n+\n+/**\n+ * An integration test to verify the conversion of a dirty-closed EOS\n+ * task towards a standby task is safe across restarts of the application.\n+ */\n+public class StandbyTaskEOSIntegrationTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "380e4fce3feca97d5144e5a5d443a2ea860a1488"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYzODQyOA==", "bodyText": "I have always been, and continue to be, mystified about why we're 100% a-ok with having corrupted state stores in ALOS mode. I understand that there are some kinds of corruption that are unavoidable without some extra work in the stores, but this check is just explicitly ignoring detectable corruption, which seems a bit extreme. Can we remove this conditional? The rest of these checks seem to apply equally well under all execution semantic modes.", "url": "https://github.com/apache/kafka/pull/8886#discussion_r441638428", "createdAt": "2020-06-17T15:33:22Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -85,6 +85,21 @@ public void initializeMetadata() {}\n     public boolean initializeStateStores() {\n         log.trace(\"Initializing state stores\");\n         registerStateStores();\n+\n+        if (eosEnabled) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "380e4fce3feca97d5144e5a5d443a2ea860a1488"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODI4MTc2", "url": "https://github.com/apache/kafka/pull/8886#pullrequestreview-432828176", "createdAt": "2020-06-17T22:48:10Z", "commit": {"oid": "380e4fce3feca97d5144e5a5d443a2ea860a1488"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMjo0ODoxMFrOGlZ5tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDoxNjoyMFrOGlbecg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NDg2OA==", "bodyText": "Could we put key 0 and key 1 as variables?", "url": "https://github.com/apache/kafka/pull/8886#discussion_r441874868", "createdAt": "2020-06-17T22:48:10Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.integration;\n+\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.integration.utils.EmbeddedKafkaCluster;\n+import org.apache.kafka.streams.integration.utils.IntegrationTestUtils;\n+import org.apache.kafka.streams.kstream.Transformer;\n+import org.apache.kafka.streams.processor.ProcessorContext;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.Stores;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.apache.kafka.streams.integration.utils.IntegrationTestUtils.startApplicationAndWaitUntilRunning;\n+import static org.apache.kafka.test.TestUtils.waitForCondition;\n+\n+/**\n+ * An integration test to verify the conversion of a dirty-closed EOS\n+ * task towards a standby task is safe across restarts of the application.\n+ */\n+public class StandbyTaskEOSIntegrationTest {\n+\n+    private final AtomicBoolean skip = new AtomicBoolean(false);\n+\n+    private String appId;\n+    private String inputTopic;\n+    private String storeName;\n+    private String outputTopic;\n+\n+    @ClassRule\n+    public static final EmbeddedKafkaCluster CLUSTER = new EmbeddedKafkaCluster(3);\n+\n+    @Before\n+    public void createTopics() throws Exception {\n+        appId = \"standbyTest\";\n+        inputTopic = \"testInputTopic\";\n+        outputTopic = \"testOutputTopic\";\n+        storeName = \"dedupStore\";\n+        CLUSTER.deleteTopicsAndWait(inputTopic, outputTopic);\n+        CLUSTER.createTopic(inputTopic, 1, 3);\n+        CLUSTER.createTopic(outputTopic, 1, 3);\n+    }\n+\n+    @Test\n+    public void shouldWipeOutStandbyStateDirectoryIfCheckpointIsMissing() throws Exception {\n+        final String base = TestUtils.tempDirectory(appId).getPath();\n+\n+        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n+            inputTopic,\n+            Collections.singletonList(\n+                new KeyValue<>(0, 0)\n+            ),\n+            TestUtils.producerConfig(\n+                CLUSTER.bootstrapServers(),\n+                IntegerSerializer.class,\n+                IntegerSerializer.class,\n+                new Properties()\n+            ),\n+            10L\n+        );\n+\n+        try (\n+            final KafkaStreams streamInstanceOne = buildWithDeduplicationTopology(base + \"-1\");\n+            final KafkaStreams streamInstanceTwo = buildWithDeduplicationTopology(base + \"-2\");\n+            final KafkaStreams streamInstanceOneRecovery = buildWithDeduplicationTopology(base + \"-1\")\n+        ) {\n+            // start first instance and wait for processing\n+            startApplicationAndWaitUntilRunning(Collections.singletonList(streamInstanceOne), Duration.ofSeconds(30));\n+            IntegrationTestUtils.waitUntilMinRecordsReceived(\n+                TestUtils.consumerConfig(\n+                    CLUSTER.bootstrapServers(),\n+                    IntegerDeserializer.class,\n+                    IntegerDeserializer.class\n+                ),\n+                outputTopic,\n+                1\n+            );\n+\n+            // start second instance and wait for standby replication\n+            startApplicationAndWaitUntilRunning(Collections.singletonList(streamInstanceTwo), Duration.ofSeconds(30));\n+            waitForCondition(\n+                () -> streamInstanceTwo.store(\n+                    StoreQueryParameters.fromNameAndType(\n+                        storeName,\n+                        QueryableStoreTypes.<Integer, Integer>keyValueStore()\n+                    ).enableStaleStores()\n+                ).get(0) != null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "380e4fce3feca97d5144e5a5d443a2ea860a1488"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwMDY1OA==", "bodyText": "Remove the debug statements", "url": "https://github.com/apache/kafka/pull/8886#discussion_r441900658", "createdAt": "2020-06-18T00:16:20Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.integration;\n+\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.common.serialization.IntegerDeserializer;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.StoreQueryParameters;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.integration.utils.EmbeddedKafkaCluster;\n+import org.apache.kafka.streams.integration.utils.IntegrationTestUtils;\n+import org.apache.kafka.streams.kstream.Transformer;\n+import org.apache.kafka.streams.processor.ProcessorContext;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+import org.apache.kafka.streams.state.QueryableStoreTypes;\n+import org.apache.kafka.streams.state.Stores;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.apache.kafka.streams.integration.utils.IntegrationTestUtils.startApplicationAndWaitUntilRunning;\n+import static org.apache.kafka.test.TestUtils.waitForCondition;\n+\n+/**\n+ * An integration test to verify the conversion of a dirty-closed EOS\n+ * task towards a standby task is safe across restarts of the application.\n+ */\n+public class StandbyTaskEOSIntegrationTest {\n+\n+    private final AtomicBoolean skip = new AtomicBoolean(false);\n+\n+    private String appId;\n+    private String inputTopic;\n+    private String storeName;\n+    private String outputTopic;\n+\n+    @ClassRule\n+    public static final EmbeddedKafkaCluster CLUSTER = new EmbeddedKafkaCluster(3);\n+\n+    @Before\n+    public void createTopics() throws Exception {\n+        appId = \"standbyTest\";\n+        inputTopic = \"testInputTopic\";\n+        outputTopic = \"testOutputTopic\";\n+        storeName = \"dedupStore\";\n+        CLUSTER.deleteTopicsAndWait(inputTopic, outputTopic);\n+        CLUSTER.createTopic(inputTopic, 1, 3);\n+        CLUSTER.createTopic(outputTopic, 1, 3);\n+    }\n+\n+    @Test\n+    public void shouldWipeOutStandbyStateDirectoryIfCheckpointIsMissing() throws Exception {\n+        final String base = TestUtils.tempDirectory(appId).getPath();\n+\n+        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n+            inputTopic,\n+            Collections.singletonList(\n+                new KeyValue<>(0, 0)\n+            ),\n+            TestUtils.producerConfig(\n+                CLUSTER.bootstrapServers(),\n+                IntegerSerializer.class,\n+                IntegerSerializer.class,\n+                new Properties()\n+            ),\n+            10L\n+        );\n+\n+        try (\n+            final KafkaStreams streamInstanceOne = buildWithDeduplicationTopology(base + \"-1\");\n+            final KafkaStreams streamInstanceTwo = buildWithDeduplicationTopology(base + \"-2\");\n+            final KafkaStreams streamInstanceOneRecovery = buildWithDeduplicationTopology(base + \"-1\")\n+        ) {\n+            // start first instance and wait for processing\n+            startApplicationAndWaitUntilRunning(Collections.singletonList(streamInstanceOne), Duration.ofSeconds(30));\n+            IntegrationTestUtils.waitUntilMinRecordsReceived(\n+                TestUtils.consumerConfig(\n+                    CLUSTER.bootstrapServers(),\n+                    IntegerDeserializer.class,\n+                    IntegerDeserializer.class\n+                ),\n+                outputTopic,\n+                1\n+            );\n+\n+            // start second instance and wait for standby replication\n+            startApplicationAndWaitUntilRunning(Collections.singletonList(streamInstanceTwo), Duration.ofSeconds(30));\n+            waitForCondition(\n+                () -> streamInstanceTwo.store(\n+                    StoreQueryParameters.fromNameAndType(\n+                        storeName,\n+                        QueryableStoreTypes.<Integer, Integer>keyValueStore()\n+                    ).enableStaleStores()\n+                ).get(0) != null,\n+                120_000L, // use increased timeout to encounter for rebalancing time\n+                \"Could not get key from standby store\"\n+            );\n+            // sanity check that first instance is still active\n+            waitForCondition(\n+                () -> streamInstanceOne.store(\n+                    StoreQueryParameters.fromNameAndType(\n+                        storeName,\n+                        QueryableStoreTypes.<Integer, Integer>keyValueStore()\n+                    )\n+                ).get(0) != null,\n+                \"Could not get key from main store\"\n+            );\n+\n+            // inject poison pill and wait for crash of first instance and recovery on second instance\n+            IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n+                inputTopic,\n+                Collections.singletonList(\n+                    new KeyValue<>(1, 0)\n+                ),\n+                TestUtils.producerConfig(\n+                    CLUSTER.bootstrapServers(),\n+                    IntegerSerializer.class,\n+                    IntegerSerializer.class,\n+                    new Properties()\n+                ),\n+                10L\n+            );\n+            waitForCondition(\n+                () -> streamInstanceOne.state() == KafkaStreams.State.ERROR,\n+                \"Stream instance 1 did not go into error state\"\n+            );\n+            streamInstanceOne.close();\n+\n+            waitForCondition(\n+                () -> streamInstanceTwo.store(\n+                    StoreQueryParameters.fromNameAndType(\n+                        storeName,\n+                        QueryableStoreTypes.keyValueStore()\n+                    )\n+                ).get(0) != null,\n+                120_000L, // use increased timeout to encounter for rebalancing time\n+                \"Could not get key from recovered main store\"\n+            );\n+\n+            // \"restart\" first client and wait for standby recovery\n+            startApplicationAndWaitUntilRunning(\n+                Collections.singletonList(streamInstanceOneRecovery),\n+                Duration.ofSeconds(30)\n+            );\n+            waitForCondition(\n+                () -> streamInstanceOneRecovery.store(\n+                    StoreQueryParameters.fromNameAndType(\n+                        storeName,\n+                        QueryableStoreTypes.<Integer, Integer>keyValueStore()\n+                    ).enableStaleStores()\n+                ).get(0) != null,\n+                \"Could not get key from recovered standby store\"\n+            );\n+            // sanity check that second instance is still active\n+            waitForCondition(\n+                () -> streamInstanceTwo.store(\n+                    StoreQueryParameters.fromNameAndType(\n+                        storeName,\n+                        QueryableStoreTypes.keyValueStore()\n+                    )\n+                ).get(0) != null,\n+                \"Could not get key from recovered main store\"\n+            );\n+\n+            streamInstanceTwo.close();\n+            waitForCondition(\n+                () -> streamInstanceOneRecovery.store(\n+                    StoreQueryParameters.fromNameAndType(\n+                        storeName,\n+                        QueryableStoreTypes.<Integer, Integer>keyValueStore()\n+                    )\n+                ).get(0) != null,\n+                120_000L, // use increased timeout to encounter for rebalancing time\n+                \"Could not get key from recovered main store\"\n+            );\n+\n+            // re-inject poison pill and wait for crash of first instance\n+            skip.set(false);\n+            IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n+                inputTopic,\n+                Collections.singletonList(\n+                    new KeyValue<>(1, 0)\n+                ),\n+                TestUtils.producerConfig(\n+                    CLUSTER.bootstrapServers(),\n+                    IntegerSerializer.class,\n+                    IntegerSerializer.class,\n+                    new Properties()\n+                ),\n+                10L\n+            );\n+            waitForCondition(\n+                () -> streamInstanceOneRecovery.state() == KafkaStreams.State.ERROR,\n+                \"Stream instance 1 did not go into error state\"\n+            );\n+        }\n+    }\n+\n+    private KafkaStreams buildWithDeduplicationTopology(final String stateDirPath) {\n+        final StreamsBuilder builder = new StreamsBuilder();\n+\n+        builder.addStateStore(Stores.keyValueStoreBuilder(\n+            Stores.persistentKeyValueStore(storeName),\n+            Serdes.Integer(),\n+            Serdes.Integer())\n+        );\n+        builder.<Integer, Integer>stream(inputTopic)\n+            .transform(\n+                () -> new Transformer<Integer, Integer, KeyValue<Integer, Integer>>() {\n+                    private KeyValueStore<Integer, Integer> store;\n+\n+                    @SuppressWarnings(\"unchecked\")\n+                    @Override\n+                    public void init(final ProcessorContext context) {\n+                        store = (KeyValueStore<Integer, Integer>) context.getStateStore(storeName);\n+\n+                        final KeyValueIterator<Integer, Integer> it = store.all();\n+                        System.err.println(\"mjsax: store content begin\");\n+                        while (it.hasNext()) {\n+                            final KeyValue<Integer, Integer> next = it.next();\n+                            System.err.println(\"mjsax: key/value -> \" + next.key + \"/\" + next.value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "380e4fce3feca97d5144e5a5d443a2ea860a1488"}, "originalPosition": 246}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "555975b4992607c5a8ff1608fe4ce4ab2d39045e", "author": {"user": {"login": "mjsax", "name": "Matthias J. Sax"}}, "url": "https://github.com/apache/kafka/commit/555975b4992607c5a8ff1608fe4ce4ab2d39045e", "committedDate": "2020-06-18T01:29:16Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67974712873ebf4f20705043d3221a9545bb47be", "author": {"user": {"login": "mjsax", "name": "Matthias J. Sax"}}, "url": "https://github.com/apache/kafka/commit/67974712873ebf4f20705043d3221a9545bb47be", "committedDate": "2020-06-18T01:52:44Z", "message": "Github comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MjgxMTYz", "url": "https://github.com/apache/kafka/pull/8886#pullrequestreview-434281163", "createdAt": "2020-06-19T18:50:29Z", "commit": {"oid": "67974712873ebf4f20705043d3221a9545bb47be"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 645, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}