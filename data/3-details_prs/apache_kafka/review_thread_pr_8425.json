{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4NDY0NDUz", "number": 8425, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwNDowNjo1MVrODupwXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo1NzoyMFrODwCBZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMjQ1MjEyOnYy", "diffSide": "LEFT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamsPartitionAssignor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwNDowNjo1MVrOGAu5TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwNDowNjo1MVrOGAu5TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQyMTUxNg==", "bodyText": "This is just a side bug that StreamsPartitionAssignorTest caught, we need to pin the overflow here too", "url": "https://github.com/apache/kafka/pull/8425#discussion_r403421516", "createdAt": "2020-04-04T04:06:51Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamsPartitionAssignor.java", "diffHunk": "@@ -792,7 +792,13 @@ private boolean populateClientStatesMap(final Map<UUID, ClientState> clientState\n                     log.debug(\"Fetched end offsets did not contain the changelog {} of task {}\", changelog, task);\n                     throw new IllegalStateException(\"Could not get end offset for \" + changelog);\n                 }\n-                taskEndOffsetSums.computeIfPresent(task, (id, curOffsetSum) -> curOffsetSum + offsetResult.offset());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMjQ1MjQxOnYy", "diffSide": "LEFT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwNDowNzoxOFrOGAu5cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwNDowNzoxOFrOGAu5cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQyMTU1Mg==", "bodyText": "Since we now need this in getMovements as well, I moved this for reusability", "url": "https://github.com/apache/kafka/pull/8425#discussion_r403421552", "createdAt": "2020-04-04T04:07:18Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -101,28 +103,6 @@ private void checkClientsAndNumberOfStreamThreads(final Map<UUID, Integer> clien\n         return assignment;\n     }\n \n-    /**\n-     * Maps tasks to clients with caught-up states for the task.\n-     *\n-     * @param statefulTasksToRankedClients ranked clients map\n-     * @return map from tasks with caught-up clients to the list of client candidates\n-     */\n-    private Map<TaskId, List<UUID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<RankedClient>> statefulTasksToRankedClients) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMDAxMDY4OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMjoyMzozOFrOGBwo5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMjoyMzozOFrOGBwo5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ5ODY2Mw==", "bodyText": "There are no logical changes to this file, just factoring out the statefulTasksToRankedCandidates and supplying the tasksToCaughtUpClients as an additional input parameter", "url": "https://github.com/apache/kafka/pull/8425#discussion_r404498663", "createdAt": "2020-04-07T02:23:38Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignorTest.java", "diffHunk": "@@ -41,6 +41,7 @@\n import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.UUID_1;\n import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.UUID_2;\n import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.UUID_3;\n+import static org.apache.kafka.streams.processor.internals.assignment.RankedClient.tasksToCaughtUpClients;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMzU4NjgzOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxOTo0NToxOFrOGCTXkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxODo1MzozNlrOGC8k2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA2NzY2NA==", "bodyText": "Just out of curiosity, what is the motivation for adding this method and making a copy of the list?", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405067664", "createdAt": "2020-04-07T19:45:18Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java", "diffHunk": "@@ -96,34 +139,46 @@ public void shouldReturnEmptyMovementsWhenPassedEmptyTaskAssignments() {\n             mkEntry(UUID_1, emptyList()),\n             mkEntry(UUID_2, emptyList())\n         );\n-        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas).isEmpty());\n+        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas).isEmpty());\n     }\n \n     @Test\n     public void shouldReturnEmptyMovementsWhenPassedIdenticalTaskAssignments() {\n         final int maxWarmupReplicas = 2;\n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n-        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas).isEmpty());\n+        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas).isEmpty());\n     }\n \n     @Test\n     public void shouldThrowIllegalStateExceptionIfAssignmentsAreOfDifferentSize() {\n         final int maxWarmupReplicas = 2;\n \n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_0_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_0_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n-        assertThrows(IllegalStateException.class, () -> getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas));\n+        assertThrows(IllegalStateException.class, () -> getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas));\n+    }\n+\n+    private static List<TaskId> mkTaskList(final TaskId... tasks) {\n+        return new ArrayList<>(asList(tasks));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE1NDIyOQ==", "bodyText": "If we just use asList then shouldImmediatelyMoveTasksWithCaughtUpDestinationClients will throw UnsupportedOperationException on AbstractList.remove", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405154229", "createdAt": "2020-04-07T22:38:20Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java", "diffHunk": "@@ -96,34 +139,46 @@ public void shouldReturnEmptyMovementsWhenPassedEmptyTaskAssignments() {\n             mkEntry(UUID_1, emptyList()),\n             mkEntry(UUID_2, emptyList())\n         );\n-        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas).isEmpty());\n+        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas).isEmpty());\n     }\n \n     @Test\n     public void shouldReturnEmptyMovementsWhenPassedIdenticalTaskAssignments() {\n         final int maxWarmupReplicas = 2;\n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n-        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas).isEmpty());\n+        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas).isEmpty());\n     }\n \n     @Test\n     public void shouldThrowIllegalStateExceptionIfAssignmentsAreOfDifferentSize() {\n         final int maxWarmupReplicas = 2;\n \n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_0_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_0_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n-        assertThrows(IllegalStateException.class, () -> getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas));\n+        assertThrows(IllegalStateException.class, () -> getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas));\n+    }\n+\n+    private static List<TaskId> mkTaskList(final TaskId... tasks) {\n+        return new ArrayList<>(asList(tasks));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA2NzY2NA=="}, "originalCommit": null, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE1NDkwNw==", "bodyText": "(because we actually move the task in the state constrained assignment)", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405154907", "createdAt": "2020-04-07T22:39:55Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java", "diffHunk": "@@ -96,34 +139,46 @@ public void shouldReturnEmptyMovementsWhenPassedEmptyTaskAssignments() {\n             mkEntry(UUID_1, emptyList()),\n             mkEntry(UUID_2, emptyList())\n         );\n-        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas).isEmpty());\n+        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas).isEmpty());\n     }\n \n     @Test\n     public void shouldReturnEmptyMovementsWhenPassedIdenticalTaskAssignments() {\n         final int maxWarmupReplicas = 2;\n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n-        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas).isEmpty());\n+        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas).isEmpty());\n     }\n \n     @Test\n     public void shouldThrowIllegalStateExceptionIfAssignmentsAreOfDifferentSize() {\n         final int maxWarmupReplicas = 2;\n \n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_0_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_0_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n-        assertThrows(IllegalStateException.class, () -> getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas));\n+        assertThrows(IllegalStateException.class, () -> getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas));\n+    }\n+\n+    private static List<TaskId> mkTaskList(final TaskId... tasks) {\n+        return new ArrayList<>(asList(tasks));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA2NzY2NA=="}, "originalCommit": null, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0MjgwOQ==", "bodyText": "Thanks.", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405742809", "createdAt": "2020-04-08T18:53:36Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java", "diffHunk": "@@ -96,34 +139,46 @@ public void shouldReturnEmptyMovementsWhenPassedEmptyTaskAssignments() {\n             mkEntry(UUID_1, emptyList()),\n             mkEntry(UUID_2, emptyList())\n         );\n-        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas).isEmpty());\n+        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas).isEmpty());\n     }\n \n     @Test\n     public void shouldReturnEmptyMovementsWhenPassedIdenticalTaskAssignments() {\n         final int maxWarmupReplicas = 2;\n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n-        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas).isEmpty());\n+        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas).isEmpty());\n     }\n \n     @Test\n     public void shouldThrowIllegalStateExceptionIfAssignmentsAreOfDifferentSize() {\n         final int maxWarmupReplicas = 2;\n \n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_0_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_0_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n-        assertThrows(IllegalStateException.class, () -> getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas));\n+        assertThrows(IllegalStateException.class, () -> getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas));\n+    }\n+\n+    private static List<TaskId> mkTaskList(final TaskId... tasks) {\n+        return new ArrayList<>(asList(tasks));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA2NzY2NA=="}, "originalCommit": null, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjcyOTk0OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDoxNzoxM1rOGCxaMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxODoxMjoyNFrOGC7FhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1OTg1Nw==", "bodyText": "req: My IDE says that this import is not needed. Since the imported method is in the same package, I agree with my IDE. Could you please remove it? Isn't strange that checkstyle did not find this?", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405559857", "createdAt": "2020-04-08T14:17:13Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -16,6 +16,8 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n+import static org.apache.kafka.streams.processor.internals.assignment.RankedClient.tasksToCaughtUpClients;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTcxODQwNA==", "bodyText": "Good catch! It does seem weird that this slipped past checkstyle, although I've seen that happen before with an unused import I found on trunk. \ud83e\udd37\u200d\u2640", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405718404", "createdAt": "2020-04-08T18:12:24Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -16,6 +16,8 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n+import static org.apache.kafka.streams.processor.internals.assignment.RankedClient.tasksToCaughtUpClients;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1OTg1Nw=="}, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjc0NjMxOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/RankedClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDoyMDozOVrOGCxkXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDoyMDozOVrOGCxkXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MjQ2Mw==", "bodyText": "req: Now that we can test this method. Could you please add unit tests for this method in RankedClientTest?", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405562463", "createdAt": "2020-04-08T14:20:39Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/RankedClient.java", "diffHunk": "@@ -78,6 +79,28 @@ public int hashCode() {\n         return Objects.hash(clientId, rank);\n     }\n \n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    static Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<RankedClient>> statefulTasksToRankedClients) {\n+        final Map<TaskId, SortedSet<UUID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<RankedClient>> taskToRankedClients : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<RankedClient> rankedClients = taskToRankedClients.getValue();\n+            for (final RankedClient rankedClient : rankedClients) {\n+                if (rankedClient.rank() == Task.LATEST_OFFSET || rankedClient.rank() == 0) {\n+                    final TaskId taskId = taskToRankedClients.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new TreeSet<>()).add(rankedClient.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjgyMzM0OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDozNzoyOVrOGCyUCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDozNzoyOVrOGCyUCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU3NDY2Ng==", "bodyText": "req:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        rankForTask01OnClient1,\n          \n          \n            \n                        rankForTask01OnClient2,\n          \n          \n            \n                        rankForTask12OnClient1,\n          \n          \n            \n                        rankForTask12OnClient2\n          \n          \n            \n                    );\n          \n          \n            \n                            rankForTask01OnClient1,\n          \n          \n            \n                            rankForTask01OnClient2,\n          \n          \n            \n                            rankForTask12OnClient1,\n          \n          \n            \n                            rankForTask12OnClient2\n          \n          \n            \n                        );", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405574666", "createdAt": "2020-04-08T14:37:29Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignorTest.java", "diffHunk": "@@ -147,16 +153,19 @@ public void shouldEvenlyDistributeTasksToCaughtUpClientsThatAreNotPreviousHosts(\n         final long rankForTask12OnClient2 = 0;\n         final int balanceFactor = 1;\n \n-        final Map<UUID, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor().assign(\n+        final SortedMap<TaskId, SortedSet<RankedClient>> statefulTasksToRankedCandidates =\n             twoStatefulTasksToTwoRankedClients(\n-                rankForTask01OnClient1,\n-                rankForTask01OnClient2,\n-                rankForTask12OnClient1,\n-                rankForTask12OnClient2\n-            ),\n+            rankForTask01OnClient1,\n+            rankForTask01OnClient2,\n+            rankForTask12OnClient1,\n+            rankForTask12OnClient2\n+        );", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjg5MTYzOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo1MjozNlrOGCy_QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo1MjozNlrOGCy_QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4NTcyOA==", "bodyText": "prop:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(getMovements(stateConstrainedAssignment, balancedAssignment, tasksToCaughtUpClients, maxWarmupReplicas), equalTo(expectedMovements));\n          \n          \n            \n                    assertThat(\n          \n          \n            \n                        getMovements(stateConstrainedAssignment, balancedAssignment, tasksToCaughtUpClients, maxWarmupReplicas), \n          \n          \n            \n                        equalTo(expectedMovements)\n          \n          \n            \n                    );", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405585728", "createdAt": "2020-04-08T14:52:36Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java", "diffHunk": "@@ -49,40 +57,75 @@\n     public void shouldGetMovementsFromStateConstrainedToBalancedAssignment() {\n         final int maxWarmupReplicas = Integer.MAX_VALUE;\n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_2)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_0)),\n-            mkEntry(UUID_3, asList(TASK_0_2, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_2)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_0)),\n+            mkEntry(UUID_3, mkTaskList(TASK_0_2, TASK_1_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1)),\n-            mkEntry(UUID_3, asList(TASK_0_2, TASK_1_2))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1)),\n+            mkEntry(UUID_3, mkTaskList(TASK_0_2, TASK_1_2))\n         );\n+        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = getMapWithNoCaughtUpClients(\n+            mkSet(TASK_0_0, TASK_0_1, TASK_0_2, TASK_1_0, TASK_1_1, TASK_1_2)\n+        );\n+\n         final Queue<TaskMovement> expectedMovements = new LinkedList<>();\n         expectedMovements.add(new TaskMovement(TASK_1_2, UUID_1, UUID_3));\n         expectedMovements.add(new TaskMovement(TASK_1_0, UUID_2, UUID_1));\n         expectedMovements.add(new TaskMovement(TASK_1_1, UUID_3, UUID_2));\n \n-        assertThat(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas), equalTo(expectedMovements));\n+        assertThat(getMovements(stateConstrainedAssignment, balancedAssignment, tasksToCaughtUpClients, maxWarmupReplicas), equalTo(expectedMovements));\n+    }\n+\n+    @Test\n+    public void shouldImmediatelyMoveTasksWithCaughtUpDestinationClients() {\n+        final int maxWarmupReplicas = Integer.MAX_VALUE;\n+        final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_2)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_0)),\n+            mkEntry(UUID_3, mkTaskList(TASK_0_2, TASK_1_1))\n+        );\n+        final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1)),\n+            mkEntry(UUID_3, mkTaskList(TASK_0_2, TASK_1_2))\n+        );\n+        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = getMapWithNoCaughtUpClients(\n+            mkSet(TASK_0_0, TASK_0_1, TASK_0_2, TASK_1_0, TASK_1_1, TASK_1_2)\n+        );\n+        tasksToCaughtUpClients.get(TASK_1_0).add(UUID_1);\n+\n+        final Queue<TaskMovement> expectedMovements = new LinkedList<>();\n+        expectedMovements.add(new TaskMovement(TASK_1_2, UUID_1, UUID_3));\n+        expectedMovements.add(new TaskMovement(TASK_1_1, UUID_3, UUID_2));\n+\n+        assertThat(getMovements(stateConstrainedAssignment, balancedAssignment, tasksToCaughtUpClients, maxWarmupReplicas), equalTo(expectedMovements));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNjkxMzY1OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo1NzoyMVrOGCzNXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo1NzoyMVrOGCzNXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4OTM0Mw==", "bodyText": "req: Please add a test that verifies the IllegalStateException when a task does not have a destination.", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405589343", "createdAt": "2020-04-08T14:57:21Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java", "diffHunk": "@@ -96,34 +139,46 @@ public void shouldReturnEmptyMovementsWhenPassedEmptyTaskAssignments() {\n             mkEntry(UUID_1, emptyList()),\n             mkEntry(UUID_2, emptyList())\n         );\n-        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas).isEmpty());\n+        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas).isEmpty());\n     }\n \n     @Test\n     public void shouldReturnEmptyMovementsWhenPassedIdenticalTaskAssignments() {\n         final int maxWarmupReplicas = 2;\n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n-        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas).isEmpty());\n+        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas).isEmpty());\n     }\n \n     @Test\n     public void shouldThrowIllegalStateExceptionIfAssignmentsAreOfDifferentSize() {\n         final int maxWarmupReplicas = 2;\n \n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_0_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_0_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n-        assertThrows(IllegalStateException.class, () -> getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas));\n+        assertThrows(IllegalStateException.class, () -> getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas));\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 163}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3210, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}