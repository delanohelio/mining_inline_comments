{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2OTM2MjQy", "number": 8280, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo0MjoyOVrODnRzMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxOTo0NzoyOVrODrX0WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTEyNjg5OnYy", "diffSide": "RIGHT", "path": "connect/transforms/src/test/java/org/apache/kafka/connect/transforms/InsertFieldTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo0MjoyOVrOF1Lwmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo0MjoyOVrOF1Lwmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMTUxNA==", "bodyText": "Maybe also assertNull the value just for completeness?", "url": "https://github.com/apache/kafka/pull/8280#discussion_r391311514", "createdAt": "2020-03-11T22:42:29Z", "author": {"login": "ncliang"}, "path": "connect/transforms/src/test/java/org/apache/kafka/connect/transforms/InsertFieldTest.java", "diffHunk": "@@ -141,16 +142,39 @@ public void insertConfiguredFieldsIntoTombstoneEventWithSchemaLeavesValueUnchang\n         props.put(\"static.field\", \"instance_id\");\n         props.put(\"static.value\", \"my-instance-id\");\n \n-        xform.configure(props);\n+        xformValue.configure(props);\n \n         final Schema simpleStructSchema = SchemaBuilder.struct().name(\"name\").version(1).doc(\"doc\").field(\"magic\", Schema.OPTIONAL_INT64_SCHEMA).build();\n \n         final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n                 simpleStructSchema, null);\n \n-        final SourceRecord transformedRecord = xform.apply(record);\n+        final SourceRecord transformedRecord = xformValue.apply(record);\n \n         assertEquals(null, transformedRecord.value());\n         assertEquals(simpleStructSchema, transformedRecord.valueSchema());\n     }\n+\n+    @Test\n+    public void insertkeyFieldsIntoTombstoneEvent() {\n+        final Map<String, Object> props = new HashMap<>();\n+        props.put(\"topic.field\", \"topic_field!\");\n+        props.put(\"partition.field\", \"partition_field\");\n+        props.put(\"timestamp.field\", \"timestamp_field?\");\n+        props.put(\"static.field\", \"instance_id\");\n+        props.put(\"static.value\", \"my-instance-id\");\n+\n+        xformKey.configure(props);\n+\n+        final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n+            null, Collections.singletonMap(\"magic\", 42L), null, null);\n+\n+        final SourceRecord transformedRecord = xformKey.apply(record);\n+\n+        assertEquals(42L, ((Map<?, ?>) transformedRecord.key()).get(\"magic\"));\n+        assertEquals(\"test\", ((Map<?, ?>) transformedRecord.key()).get(\"topic_field\"));\n+        assertEquals(0, ((Map<?, ?>) transformedRecord.key()).get(\"partition_field\"));\n+        assertEquals(null, ((Map<?, ?>) transformedRecord.key()).get(\"timestamp_field\"));\n+        assertEquals(\"my-instance-id\", ((Map<?, ?>) transformedRecord.key()).get(\"instance_id\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25696b33d6faa4e2b97119ad6f18d3dbe5dcccd9"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTEzOTcyOnYy", "diffSide": "RIGHT", "path": "connect/transforms/src/test/java/org/apache/kafka/connect/transforms/InsertFieldTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo0ODoxOVrOF1L4WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo0ODoxOVrOF1L4WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMzQ5Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertEquals(\"my-instance-id\", ((Map<?, ?>) transformedRecord.key()).get(\"instance_id\"));\n          \n          \n            \n                    assertEquals(\"my-instance-id\", ((Map<?, ?>) transformedRecord.key()).get(\"instance_id\"));\n          \n          \n            \n                    assertEquals(null, transformedRecord.value());", "url": "https://github.com/apache/kafka/pull/8280#discussion_r391313496", "createdAt": "2020-03-11T22:48:19Z", "author": {"login": "gharris1727"}, "path": "connect/transforms/src/test/java/org/apache/kafka/connect/transforms/InsertFieldTest.java", "diffHunk": "@@ -141,16 +142,39 @@ public void insertConfiguredFieldsIntoTombstoneEventWithSchemaLeavesValueUnchang\n         props.put(\"static.field\", \"instance_id\");\n         props.put(\"static.value\", \"my-instance-id\");\n \n-        xform.configure(props);\n+        xformValue.configure(props);\n \n         final Schema simpleStructSchema = SchemaBuilder.struct().name(\"name\").version(1).doc(\"doc\").field(\"magic\", Schema.OPTIONAL_INT64_SCHEMA).build();\n \n         final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n                 simpleStructSchema, null);\n \n-        final SourceRecord transformedRecord = xform.apply(record);\n+        final SourceRecord transformedRecord = xformValue.apply(record);\n \n         assertEquals(null, transformedRecord.value());\n         assertEquals(simpleStructSchema, transformedRecord.valueSchema());\n     }\n+\n+    @Test\n+    public void insertkeyFieldsIntoTombstoneEvent() {\n+        final Map<String, Object> props = new HashMap<>();\n+        props.put(\"topic.field\", \"topic_field!\");\n+        props.put(\"partition.field\", \"partition_field\");\n+        props.put(\"timestamp.field\", \"timestamp_field?\");\n+        props.put(\"static.field\", \"instance_id\");\n+        props.put(\"static.value\", \"my-instance-id\");\n+\n+        xformKey.configure(props);\n+\n+        final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n+            null, Collections.singletonMap(\"magic\", 42L), null, null);\n+\n+        final SourceRecord transformedRecord = xformKey.apply(record);\n+\n+        assertEquals(42L, ((Map<?, ?>) transformedRecord.key()).get(\"magic\"));\n+        assertEquals(\"test\", ((Map<?, ?>) transformedRecord.key()).get(\"topic_field\"));\n+        assertEquals(0, ((Map<?, ?>) transformedRecord.key()).get(\"partition_field\"));\n+        assertEquals(null, ((Map<?, ?>) transformedRecord.key()).get(\"timestamp_field\"));\n+        assertEquals(\"my-instance-id\", ((Map<?, ?>) transformedRecord.key()).get(\"instance_id\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25696b33d6faa4e2b97119ad6f18d3dbe5dcccd9"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2Nzk2MDE2OnYy", "diffSide": "RIGHT", "path": "connect/transforms/src/main/java/org/apache/kafka/connect/transforms/InsertField.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxOToyMDozOFrOF7qtDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxOToyNzoyNVrOF7q8eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEwOTk2Nw==", "bodyText": "Can we please clean up the logic? This method no longer returns true if it's just a tombstone record; it also returns true if the key is null for InsertField$Key.\nI'd suggest removing this method altogether and just changing the point where this method is called to simply be:\n          if (operatingValue(record) == null) {", "url": "https://github.com/apache/kafka/pull/8280#discussion_r398109967", "createdAt": "2020-03-25T19:20:38Z", "author": {"login": "rhauch"}, "path": "connect/transforms/src/main/java/org/apache/kafka/connect/transforms/InsertField.java", "diffHunk": "@@ -137,7 +137,7 @@ public R apply(R record) {\n     }\n \n     private boolean isTombstoneRecord(R record) {\n-        return record.value() == null;\n+        return operatingValue(record) == null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af8eb9207b2fbadd6b9dd8b3157394607029dc63"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODExMzkxMg==", "bodyText": "Plus one for this; confusion around the term tombstone has already caused plenty of miscommunication around this issue and we should be careful to use it correctly.", "url": "https://github.com/apache/kafka/pull/8280#discussion_r398113912", "createdAt": "2020-03-25T19:27:25Z", "author": {"login": "C0urante"}, "path": "connect/transforms/src/main/java/org/apache/kafka/connect/transforms/InsertField.java", "diffHunk": "@@ -137,7 +137,7 @@ public R apply(R record) {\n     }\n \n     private boolean isTombstoneRecord(R record) {\n-        return record.value() == null;\n+        return operatingValue(record) == null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEwOTk2Nw=="}, "originalCommit": {"oid": "af8eb9207b2fbadd6b9dd8b3157394607029dc63"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2Nzk2NzA0OnYy", "diffSide": "RIGHT", "path": "connect/transforms/src/test/java/org/apache/kafka/connect/transforms/InsertFieldTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxOToyMjozM1rOF7qxJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxOToyMjozM1rOF7qxJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODExMTAxMg==", "bodyText": "This method is testing that the function works when applied to a tombstone record with a non-null key, but we should add a test that verifies the function skips a record that has a null key.", "url": "https://github.com/apache/kafka/pull/8280#discussion_r398111012", "createdAt": "2020-03-25T19:22:33Z", "author": {"login": "rhauch"}, "path": "connect/transforms/src/test/java/org/apache/kafka/connect/transforms/InsertFieldTest.java", "diffHunk": "@@ -141,16 +142,40 @@ public void insertConfiguredFieldsIntoTombstoneEventWithSchemaLeavesValueUnchang\n         props.put(\"static.field\", \"instance_id\");\n         props.put(\"static.value\", \"my-instance-id\");\n \n-        xform.configure(props);\n+        xformValue.configure(props);\n \n         final Schema simpleStructSchema = SchemaBuilder.struct().name(\"name\").version(1).doc(\"doc\").field(\"magic\", Schema.OPTIONAL_INT64_SCHEMA).build();\n \n         final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n                 simpleStructSchema, null);\n \n-        final SourceRecord transformedRecord = xform.apply(record);\n+        final SourceRecord transformedRecord = xformValue.apply(record);\n \n         assertEquals(null, transformedRecord.value());\n         assertEquals(simpleStructSchema, transformedRecord.valueSchema());\n     }\n+\n+    @Test\n+    public void insertkeyFieldsIntoTombstoneEvent() {\n+        final Map<String, Object> props = new HashMap<>();\n+        props.put(\"topic.field\", \"topic_field!\");\n+        props.put(\"partition.field\", \"partition_field\");\n+        props.put(\"timestamp.field\", \"timestamp_field?\");\n+        props.put(\"static.field\", \"instance_id\");\n+        props.put(\"static.value\", \"my-instance-id\");\n+\n+        xformKey.configure(props);\n+\n+        final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n+            null, Collections.singletonMap(\"magic\", 42L), null, null);\n+\n+        final SourceRecord transformedRecord = xformKey.apply(record);\n+\n+        assertEquals(42L, ((Map<?, ?>) transformedRecord.key()).get(\"magic\"));\n+        assertEquals(\"test\", ((Map<?, ?>) transformedRecord.key()).get(\"topic_field\"));\n+        assertEquals(0, ((Map<?, ?>) transformedRecord.key()).get(\"partition_field\"));\n+        assertEquals(null, ((Map<?, ?>) transformedRecord.key()).get(\"timestamp_field\"));\n+        assertEquals(\"my-instance-id\", ((Map<?, ?>) transformedRecord.key()).get(\"instance_id\"));\n+        assertEquals(null, transformedRecord.value());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af8eb9207b2fbadd6b9dd8b3157394607029dc63"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2ODA1NTkzOnYy", "diffSide": "RIGHT", "path": "connect/transforms/src/test/java/org/apache/kafka/connect/transforms/InsertFieldTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxOTo0NzoyOVrOF7roCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxOTo0NzoyOVrOF7roCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODEyNTA2NQ==", "bodyText": "Wouldn't it be sufficient to replace these two asserts with the following?\n   assertSame(record, transformedRecord);\n\nThis is a bit more correct, since we want to assert that in this case the transform returns the original record. WDYT?", "url": "https://github.com/apache/kafka/pull/8280#discussion_r398125065", "createdAt": "2020-03-25T19:47:29Z", "author": {"login": "rhauch"}, "path": "connect/transforms/src/test/java/org/apache/kafka/connect/transforms/InsertFieldTest.java", "diffHunk": "@@ -141,16 +142,60 @@ public void insertConfiguredFieldsIntoTombstoneEventWithSchemaLeavesValueUnchang\n         props.put(\"static.field\", \"instance_id\");\n         props.put(\"static.value\", \"my-instance-id\");\n \n-        xform.configure(props);\n+        xformValue.configure(props);\n \n         final Schema simpleStructSchema = SchemaBuilder.struct().name(\"name\").version(1).doc(\"doc\").field(\"magic\", Schema.OPTIONAL_INT64_SCHEMA).build();\n \n         final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n                 simpleStructSchema, null);\n \n-        final SourceRecord transformedRecord = xform.apply(record);\n+        final SourceRecord transformedRecord = xformValue.apply(record);\n \n         assertEquals(null, transformedRecord.value());\n         assertEquals(simpleStructSchema, transformedRecord.valueSchema());\n     }\n+\n+    @Test\n+    public void insertKeyFieldsIntoTombstoneEvent() {\n+        final Map<String, Object> props = new HashMap<>();\n+        props.put(\"topic.field\", \"topic_field!\");\n+        props.put(\"partition.field\", \"partition_field\");\n+        props.put(\"timestamp.field\", \"timestamp_field?\");\n+        props.put(\"static.field\", \"instance_id\");\n+        props.put(\"static.value\", \"my-instance-id\");\n+\n+        xformKey.configure(props);\n+\n+        final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n+            null, Collections.singletonMap(\"magic\", 42L), null, null);\n+\n+        final SourceRecord transformedRecord = xformKey.apply(record);\n+\n+        assertEquals(42L, ((Map<?, ?>) transformedRecord.key()).get(\"magic\"));\n+        assertEquals(\"test\", ((Map<?, ?>) transformedRecord.key()).get(\"topic_field\"));\n+        assertEquals(0, ((Map<?, ?>) transformedRecord.key()).get(\"partition_field\"));\n+        assertEquals(null, ((Map<?, ?>) transformedRecord.key()).get(\"timestamp_field\"));\n+        assertEquals(\"my-instance-id\", ((Map<?, ?>) transformedRecord.key()).get(\"instance_id\"));\n+        assertEquals(null, transformedRecord.value());\n+    }\n+\n+    @Test\n+    public void insertIntoNullKeyLeavesKeyUnchanged() {\n+        final Map<String, Object> props = new HashMap<>();\n+        props.put(\"topic.field\", \"topic_field!\");\n+        props.put(\"partition.field\", \"partition_field\");\n+        props.put(\"timestamp.field\", \"timestamp_field?\");\n+        props.put(\"static.field\", \"instance_id\");\n+        props.put(\"static.value\", \"my-instance-id\");\n+\n+        xformKey.configure(props);\n+\n+        final SourceRecord record = new SourceRecord(null, null, \"test\", 0,\n+          null, null, null, Collections.singletonMap(\"magic\", 42L));\n+\n+        final SourceRecord transformedRecord = xformKey.apply(record);\n+\n+        assertEquals(null, transformedRecord.key());\n+        assertEquals(42L, ((Map<?, ?>) transformedRecord.value()).get(\"magic\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "54ff2b3f12f886ebfbf7bb70ad6f94c832c5a21a"}, "originalPosition": 138}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3319, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}