{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxNzc5NDQ4", "number": 9680, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzo0NDozOVrOFDe_6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzo0NDozOVrOFDe_6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MTk3OTMwOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/log/LogManager.scala", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzo0NDozOVrOIDJ6tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMDozMToxOVrOIDcC_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE3OTEyNg==", "bodyText": "@chia7712 This changed behavior. Previously we would call get on every Future and now we don't. @kowshik @junrao Seems like we didn't add a test that verifies the recent fix in this area?", "url": "https://github.com/apache/kafka/pull/9680#discussion_r540179126", "createdAt": "2020-12-10T13:44:39Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/log/LogManager.scala", "diffHunk": "@@ -479,14 +479,14 @@ class LogManager(logDirs: Seq[File],\n \n     try {\n       for ((dir, dirJobs) <- jobs) {\n-        val hasErrors = dirJobs.map { future =>\n+        val hasErrors = dirJobs.exists  { future =>\n           Try(future.get) match {\n             case Success(_) => false\n             case Failure(e) =>\n               warn(s\"There was an error in one of the threads during LogManager shutdown: ${e.getCause}\")\n               true\n           }\n-        }.contains(true)\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed2f6d10c2b8e47bb2da31349565fb84e9e770af"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIzNzA5NQ==", "bodyText": "Oh, my bad. Will revert it with suitable test.", "url": "https://github.com/apache/kafka/pull/9680#discussion_r540237095", "createdAt": "2020-12-10T14:59:19Z", "author": {"login": "chia7712"}, "path": "core/src/main/scala/kafka/log/LogManager.scala", "diffHunk": "@@ -479,14 +479,14 @@ class LogManager(logDirs: Seq[File],\n \n     try {\n       for ((dir, dirJobs) <- jobs) {\n-        val hasErrors = dirJobs.map { future =>\n+        val hasErrors = dirJobs.exists  { future =>\n           Try(future.get) match {\n             case Success(_) => false\n             case Failure(e) =>\n               warn(s\"There was an error in one of the threads during LogManager shutdown: ${e.getCause}\")\n               true\n           }\n-        }.contains(true)\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE3OTEyNg=="}, "originalCommit": {"oid": "ed2f6d10c2b8e47bb2da31349565fb84e9e770af"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM1Njg4MQ==", "bodyText": "see #9728", "url": "https://github.com/apache/kafka/pull/9680#discussion_r540356881", "createdAt": "2020-12-10T17:26:09Z", "author": {"login": "chia7712"}, "path": "core/src/main/scala/kafka/log/LogManager.scala", "diffHunk": "@@ -479,14 +479,14 @@ class LogManager(logDirs: Seq[File],\n \n     try {\n       for ((dir, dirJobs) <- jobs) {\n-        val hasErrors = dirJobs.map { future =>\n+        val hasErrors = dirJobs.exists  { future =>\n           Try(future.get) match {\n             case Success(_) => false\n             case Failure(e) =>\n               warn(s\"There was an error in one of the threads during LogManager shutdown: ${e.getCause}\")\n               true\n           }\n-        }.contains(true)\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE3OTEyNg=="}, "originalCommit": {"oid": "ed2f6d10c2b8e47bb2da31349565fb84e9e770af"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3NjE1Nw==", "bodyText": "@chia7712 @ijuma I think you were referring to #9596 ?\nThe test added in #9596 to verify this was LogManagerTest.testHandlingExceptionsDuringShutdown (link). I agree that the test wasn't effective enough to catch the problem. The issue was that fundamentally this area of the code was a little bit difficult to test due to the asynchronous behavior.\nSo for example, although @chia7712 has a fix in #9728, I still think it is not easy to write a test that reliably fails if the bug is introduced again.\nBelow is my explanation on why it is difficult to improve the existing testHandlingExceptionsDuringShutdown to catch such issues. Let us imagine that the test setup introduced multiple logs for each log dir, and setup an expectation (in the test code) that if one of the logs failed during close(), then, the other logs under the same log directory should still be closed by the time LogManager.shutdown() returns. Such a kind of test expectation would have caught the problem introduced in this PR. Now, writing that kind of a test was not easy, because, even if one of the logs failed to close, the other futures can still be completed by the time LogManager.shutdown() returns (there is no strong need to call future.get for the future to pass). Thus, the test can pass despite the bug.\nOne potential solution (a bigger change) is to see if we can inject a different thread pool executor that only during test executes the threads lazily i.e. it executes the submitted threads only when future.get is called, otherwise it will never execute them. If we succeed in doing this, then, the test can be improved such that unless future.get is called on all logs, some of the log close() will never happen and will fail the test in the presence of the bug introduced by this PR.\ncc @junrao", "url": "https://github.com/apache/kafka/pull/9680#discussion_r540476157", "createdAt": "2020-12-10T20:31:19Z", "author": {"login": "kowshik"}, "path": "core/src/main/scala/kafka/log/LogManager.scala", "diffHunk": "@@ -479,14 +479,14 @@ class LogManager(logDirs: Seq[File],\n \n     try {\n       for ((dir, dirJobs) <- jobs) {\n-        val hasErrors = dirJobs.map { future =>\n+        val hasErrors = dirJobs.exists  { future =>\n           Try(future.get) match {\n             case Success(_) => false\n             case Failure(e) =>\n               warn(s\"There was an error in one of the threads during LogManager shutdown: ${e.getCause}\")\n               true\n           }\n-        }.contains(true)\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE3OTEyNg=="}, "originalCommit": {"oid": "ed2f6d10c2b8e47bb2da31349565fb84e9e770af"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3657, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}