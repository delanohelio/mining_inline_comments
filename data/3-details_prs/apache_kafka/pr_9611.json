{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzMDY1NzM3", "number": 9611, "title": "KAFKA-10736 Convert transaction coordinator metadata schemas to use g\u2026", "bodyText": "issue: https://issues.apache.org/jira/browse/KAFKA-10736\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-11-18T10:03:55Z", "url": "https://github.com/apache/kafka/pull/9611", "merged": true, "mergeCommit": {"oid": "0a74c7d935b004acfa2eba0fc199be3cabd857a4"}, "closed": true, "closedAt": "2020-11-30T09:43:42Z", "author": {"login": "chia7712"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdgVKHYAFqTUzOTQxNjYzMA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdhhi0VAFqTU0MDcwODQ5MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5NDE2NjMw", "url": "https://github.com/apache/kafka/pull/9611#pullrequestreview-539416630", "createdAt": "2020-11-26T15:40:39Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo0MDozOVrOH6gU0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo1NDo0NlrOH6gz1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEwOTA3Mw==", "bodyText": "nit: We usually capitalize the first letter. We should do it in both schemas.", "url": "https://github.com/apache/kafka/pull/9611#discussion_r531109073", "createdAt": "2020-11-26T15:40:39Z", "author": {"login": "dajac"}, "path": "core/src/main/resources/common/message/TransactionLogKey.json", "diffHunk": "@@ -0,0 +1,23 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+{\n+  \"type\": \"data\",\n+  \"name\": \"TransactionLogKey\",\n+  \"validVersions\": \"0\",\n+  \"fields\": [\n+    { \"name\": \"transactionalId\", \"type\": \"string\", \"versions\": \"0\"}", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExMjc0MA==", "bodyText": "nit: We usually have a space after case.", "url": "https://github.com/apache/kafka/pull/9611#discussion_r531112740", "createdAt": "2020-11-26T15:47:20Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionLog.scala", "diffHunk": "@@ -146,38 +70,27 @@ object TransactionLog {\n     * @return value payload bytes\n     */\n   private[transaction] def valueToBytes(txnMetadata: TxnTransitMetadata): Array[Byte] = {\n-    import ValueSchema._\n-    val value = new Struct(Current)\n-    value.set(ProducerIdField, txnMetadata.producerId)\n-    value.set(ProducerEpochField, txnMetadata.producerEpoch)\n-    value.set(TxnTimeoutField, txnMetadata.txnTimeoutMs)\n-    value.set(TxnStatusField, txnMetadata.txnState.byte)\n-    value.set(TxnEntryTimestampField, txnMetadata.txnLastUpdateTimestamp)\n-    value.set(TxnStartTimestampField, txnMetadata.txnStartTimestamp)\n-\n-    if (txnMetadata.txnState == Empty) {\n-      if (txnMetadata.topicPartitions.nonEmpty)\n+    if (txnMetadata.txnState == Empty && txnMetadata.topicPartitions.nonEmpty)\n         throw new IllegalStateException(s\"Transaction is not expected to have any partitions since its state is ${txnMetadata.txnState}: $txnMetadata\")\n \n-      value.set(TxnPartitionsField, null)\n-    } else {\n-      // first group the topic partitions by their topic names\n-      val topicAndPartitions = txnMetadata.topicPartitions.groupBy(_.topic())\n-\n-      val partitionArray = topicAndPartitions.map { case(topic, partitions) =>\n-        val topicPartitionsStruct = value.instance(TxnPartitionsField)\n-        val partitionIds: Array[Integer] = partitions.map(topicPartition => Integer.valueOf(topicPartition.partition())).toArray\n-        topicPartitionsStruct.set(PartitionsTopicField, topic)\n-        topicPartitionsStruct.set(PartitionIdsField, partitionIds)\n-        topicPartitionsStruct\n-      }\n-      value.set(TxnPartitionsField, partitionArray.toArray)\n-    }\n-\n-    val byteBuffer = ByteBuffer.allocate(2 /* version */ + value.sizeOf)\n-    byteBuffer.putShort(CurrentVersion)\n-    value.writeTo(byteBuffer)\n-    byteBuffer.array()\n+      val transactionPartition = if (txnMetadata.txnState == Empty) null\n+      else txnMetadata.topicPartitions\n+        .groupBy(_.topic())\n+        .map { case(topic, partitions) =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExMzQxOQ==", "bodyText": "nit: Parentheses are not required when accessing an accessor. We could remove them here and in few other places in this file.", "url": "https://github.com/apache/kafka/pull/9611#discussion_r531113419", "createdAt": "2020-11-26T15:48:33Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionLog.scala", "diffHunk": "@@ -146,38 +70,27 @@ object TransactionLog {\n     * @return value payload bytes\n     */\n   private[transaction] def valueToBytes(txnMetadata: TxnTransitMetadata): Array[Byte] = {\n-    import ValueSchema._\n-    val value = new Struct(Current)\n-    value.set(ProducerIdField, txnMetadata.producerId)\n-    value.set(ProducerEpochField, txnMetadata.producerEpoch)\n-    value.set(TxnTimeoutField, txnMetadata.txnTimeoutMs)\n-    value.set(TxnStatusField, txnMetadata.txnState.byte)\n-    value.set(TxnEntryTimestampField, txnMetadata.txnLastUpdateTimestamp)\n-    value.set(TxnStartTimestampField, txnMetadata.txnStartTimestamp)\n-\n-    if (txnMetadata.txnState == Empty) {\n-      if (txnMetadata.topicPartitions.nonEmpty)\n+    if (txnMetadata.txnState == Empty && txnMetadata.topicPartitions.nonEmpty)\n         throw new IllegalStateException(s\"Transaction is not expected to have any partitions since its state is ${txnMetadata.txnState}: $txnMetadata\")\n \n-      value.set(TxnPartitionsField, null)\n-    } else {\n-      // first group the topic partitions by their topic names\n-      val topicAndPartitions = txnMetadata.topicPartitions.groupBy(_.topic())\n-\n-      val partitionArray = topicAndPartitions.map { case(topic, partitions) =>\n-        val topicPartitionsStruct = value.instance(TxnPartitionsField)\n-        val partitionIds: Array[Integer] = partitions.map(topicPartition => Integer.valueOf(topicPartition.partition())).toArray\n-        topicPartitionsStruct.set(PartitionsTopicField, topic)\n-        topicPartitionsStruct.set(PartitionIdsField, partitionIds)\n-        topicPartitionsStruct\n-      }\n-      value.set(TxnPartitionsField, partitionArray.toArray)\n-    }\n-\n-    val byteBuffer = ByteBuffer.allocate(2 /* version */ + value.sizeOf)\n-    byteBuffer.putShort(CurrentVersion)\n-    value.writeTo(byteBuffer)\n-    byteBuffer.array()\n+      val transactionPartition = if (txnMetadata.txnState == Empty) null\n+      else txnMetadata.topicPartitions\n+        .groupBy(_.topic())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 151}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExNTk4NQ==", "bodyText": "nit: It may be better to combine map(_.partition()).map(Integer.valueOf) in one map to avoid intermediate collection.", "url": "https://github.com/apache/kafka/pull/9611#discussion_r531115985", "createdAt": "2020-11-26T15:52:57Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionLog.scala", "diffHunk": "@@ -146,38 +70,27 @@ object TransactionLog {\n     * @return value payload bytes\n     */\n   private[transaction] def valueToBytes(txnMetadata: TxnTransitMetadata): Array[Byte] = {\n-    import ValueSchema._\n-    val value = new Struct(Current)\n-    value.set(ProducerIdField, txnMetadata.producerId)\n-    value.set(ProducerEpochField, txnMetadata.producerEpoch)\n-    value.set(TxnTimeoutField, txnMetadata.txnTimeoutMs)\n-    value.set(TxnStatusField, txnMetadata.txnState.byte)\n-    value.set(TxnEntryTimestampField, txnMetadata.txnLastUpdateTimestamp)\n-    value.set(TxnStartTimestampField, txnMetadata.txnStartTimestamp)\n-\n-    if (txnMetadata.txnState == Empty) {\n-      if (txnMetadata.topicPartitions.nonEmpty)\n+    if (txnMetadata.txnState == Empty && txnMetadata.topicPartitions.nonEmpty)\n         throw new IllegalStateException(s\"Transaction is not expected to have any partitions since its state is ${txnMetadata.txnState}: $txnMetadata\")\n \n-      value.set(TxnPartitionsField, null)\n-    } else {\n-      // first group the topic partitions by their topic names\n-      val topicAndPartitions = txnMetadata.topicPartitions.groupBy(_.topic())\n-\n-      val partitionArray = topicAndPartitions.map { case(topic, partitions) =>\n-        val topicPartitionsStruct = value.instance(TxnPartitionsField)\n-        val partitionIds: Array[Integer] = partitions.map(topicPartition => Integer.valueOf(topicPartition.partition())).toArray\n-        topicPartitionsStruct.set(PartitionsTopicField, topic)\n-        topicPartitionsStruct.set(PartitionIdsField, partitionIds)\n-        topicPartitionsStruct\n-      }\n-      value.set(TxnPartitionsField, partitionArray.toArray)\n-    }\n-\n-    val byteBuffer = ByteBuffer.allocate(2 /* version */ + value.sizeOf)\n-    byteBuffer.putShort(CurrentVersion)\n-    value.writeTo(byteBuffer)\n-    byteBuffer.array()\n+      val transactionPartition = if (txnMetadata.txnState == Empty) null\n+      else txnMetadata.topicPartitions\n+        .groupBy(_.topic())\n+        .map { case(topic, partitions) =>\n+          new TransactionLogValue.PartitionsSchema()\n+            .setTopic(topic)\n+            .setPartitionIds(partitions.map(_.partition()).map(Integer.valueOf).toList.asJava)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExNzAxNQ==", "bodyText": "nit: transactionPartition -> transactionPartitions?", "url": "https://github.com/apache/kafka/pull/9611#discussion_r531117015", "createdAt": "2020-11-26T15:54:46Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionLog.scala", "diffHunk": "@@ -146,38 +70,27 @@ object TransactionLog {\n     * @return value payload bytes\n     */\n   private[transaction] def valueToBytes(txnMetadata: TxnTransitMetadata): Array[Byte] = {\n-    import ValueSchema._\n-    val value = new Struct(Current)\n-    value.set(ProducerIdField, txnMetadata.producerId)\n-    value.set(ProducerEpochField, txnMetadata.producerEpoch)\n-    value.set(TxnTimeoutField, txnMetadata.txnTimeoutMs)\n-    value.set(TxnStatusField, txnMetadata.txnState.byte)\n-    value.set(TxnEntryTimestampField, txnMetadata.txnLastUpdateTimestamp)\n-    value.set(TxnStartTimestampField, txnMetadata.txnStartTimestamp)\n-\n-    if (txnMetadata.txnState == Empty) {\n-      if (txnMetadata.topicPartitions.nonEmpty)\n+    if (txnMetadata.txnState == Empty && txnMetadata.topicPartitions.nonEmpty)\n         throw new IllegalStateException(s\"Transaction is not expected to have any partitions since its state is ${txnMetadata.txnState}: $txnMetadata\")\n \n-      value.set(TxnPartitionsField, null)\n-    } else {\n-      // first group the topic partitions by their topic names\n-      val topicAndPartitions = txnMetadata.topicPartitions.groupBy(_.topic())\n-\n-      val partitionArray = topicAndPartitions.map { case(topic, partitions) =>\n-        val topicPartitionsStruct = value.instance(TxnPartitionsField)\n-        val partitionIds: Array[Integer] = partitions.map(topicPartition => Integer.valueOf(topicPartition.partition())).toArray\n-        topicPartitionsStruct.set(PartitionsTopicField, topic)\n-        topicPartitionsStruct.set(PartitionIdsField, partitionIds)\n-        topicPartitionsStruct\n-      }\n-      value.set(TxnPartitionsField, partitionArray.toArray)\n-    }\n-\n-    val byteBuffer = ByteBuffer.allocate(2 /* version */ + value.sizeOf)\n-    byteBuffer.putShort(CurrentVersion)\n-    value.writeTo(byteBuffer)\n-    byteBuffer.array()\n+      val transactionPartition = if (txnMetadata.txnState == Empty) null\n+      else txnMetadata.topicPartitions\n+        .groupBy(_.topic())\n+        .map { case(topic, partitions) =>\n+          new TransactionLogValue.PartitionsSchema()\n+            .setTopic(topic)\n+            .setPartitionIds(partitions.map(_.partition()).map(Integer.valueOf).toList.asJava)\n+        }.toList.asJava\n+\n+    MessageUtil.toBytes(TransactionLogValue.HIGHEST_SUPPORTED_VERSION,\n+      new TransactionLogValue()\n+        .setProducerId(txnMetadata.producerId)\n+        .setProducerEpoch(txnMetadata.producerEpoch)\n+        .setTransactionTimeoutMs(txnMetadata.txnTimeoutMs)\n+        .setTransactionStatus(txnMetadata.txnState.byte)\n+        .setTransactionLastUpdateTimestampMs(txnMetadata.txnLastUpdateTimestamp)\n+        .setTransactionStartTimestampMs(txnMetadata.txnStartTimestamp)\n+        .setTransactionPartitions(transactionPartition))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 166}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40fd8980aee5737e465781b25e21ece9ec16a215", "author": {"user": {"login": "chia7712", "name": "Chia-Ping Tsai"}}, "url": "https://github.com/apache/kafka/commit/40fd8980aee5737e465781b25e21ece9ec16a215", "committedDate": "2020-11-26T16:34:15Z", "message": "KAFKA-10736 Convert transaction coordinator metadata schemas to use generated protocol"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52b0dd17380529cef1d8277614707acf5dad42f7", "author": {"user": {"login": "chia7712", "name": "Chia-Ping Tsai"}}, "url": "https://github.com/apache/kafka/commit/52b0dd17380529cef1d8277614707acf5dad42f7", "committedDate": "2020-11-26T16:39:52Z", "message": "review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "52b0dd17380529cef1d8277614707acf5dad42f7", "author": {"user": {"login": "chia7712", "name": "Chia-Ping Tsai"}}, "url": "https://github.com/apache/kafka/commit/52b0dd17380529cef1d8277614707acf5dad42f7", "committedDate": "2020-11-26T16:39:52Z", "message": "review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwNzA4NDkw", "url": "https://github.com/apache/kafka/pull/9611#pullrequestreview-540708490", "createdAt": "2020-11-30T09:01:38Z", "commit": {"oid": "52b0dd17380529cef1d8277614707acf5dad42f7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2804, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}