{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5MTcxMTU5", "number": 9026, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODowNDoyNFrOEOkrkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODowNDoyNFrOEOkrkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNzE2NDk4OnYy", "diffSide": "RIGHT", "path": "tests/kafkatest/tests/core/transactions_test.py", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwODowNDoyNFrOGxy51g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwNDoxOTo1MlrOGyZj5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2NzQxNA==", "bodyText": "How about using different transaction_timeout for different mode? For example, lower timeout for hard_bounce of client and higher timeout for broker. I try to avoid higher waiting time (progress_timeout_sec) when encountering other error.", "url": "https://github.com/apache/kafka/pull/9026#discussion_r454867414", "createdAt": "2020-07-15T08:04:24Z", "author": {"login": "chia7712"}, "path": "tests/kafkatest/tests/core/transactions_test.py", "diffHunk": "@@ -47,11 +47,15 @@ def __init__(self, test_context):\n         self.num_output_partitions = 3\n         self.num_seed_messages = 100000\n         self.transaction_size = 750\n-        # The timeout of transaction should be lower than the timeout of verification. The transactional message sent by\n-        # client may be not correctly completed in hard_bounce mode. The pending transaction (unstable offset) stored by\n-        # broker obstructs TransactionMessageCopier from getting offset of partition which is used to calculate\n-        # remaining messages after restarting.\n-        self.transaction_timeout = 5000\n+\n+        # The transaction timeout should be lower than the progress timeout, but at\n+        # least as high as the request timeout (which is 30s by default). When the\n+        # client is hard-bounced, progress may depend on the previous transaction\n+        # being aborted. When the broker is hard-bounced, we may have to wait as\n+        # long as the request timeout to get a `Produce` response and we do not\n+        # want the coordinator timing out the transaction.\n+        self.transaction_timeout = 40000\n+        self.progress_timeout_sec = 60", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dea96a4ff9e742ee522cf5469a071a7f5870739f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQzMjU4OQ==", "bodyText": "What might be preferable is to provide a way to override the request timeout in TransactionalMessageCopier so that we can use lower values in all cases. Unfortunately we didn't give this class an easy way to override producer configurations, so we would need another argument. I decided to hold off on this, but I can reconsider it if you think it's worthwhile. This service (as well as VerifiableConsumer and VerifiableProducer) are a bit of a grey area as far as whether they are public APIs or not, but I have tended to take the position that they are not \ud83d\ude42 .", "url": "https://github.com/apache/kafka/pull/9026#discussion_r455432589", "createdAt": "2020-07-16T00:01:28Z", "author": {"login": "hachikuji"}, "path": "tests/kafkatest/tests/core/transactions_test.py", "diffHunk": "@@ -47,11 +47,15 @@ def __init__(self, test_context):\n         self.num_output_partitions = 3\n         self.num_seed_messages = 100000\n         self.transaction_size = 750\n-        # The timeout of transaction should be lower than the timeout of verification. The transactional message sent by\n-        # client may be not correctly completed in hard_bounce mode. The pending transaction (unstable offset) stored by\n-        # broker obstructs TransactionMessageCopier from getting offset of partition which is used to calculate\n-        # remaining messages after restarting.\n-        self.transaction_timeout = 5000\n+\n+        # The transaction timeout should be lower than the progress timeout, but at\n+        # least as high as the request timeout (which is 30s by default). When the\n+        # client is hard-bounced, progress may depend on the previous transaction\n+        # being aborted. When the broker is hard-bounced, we may have to wait as\n+        # long as the request timeout to get a `Produce` response and we do not\n+        # want the coordinator timing out the transaction.\n+        self.transaction_timeout = 40000\n+        self.progress_timeout_sec = 60", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2NzQxNA=="}, "originalCommit": {"oid": "dea96a4ff9e742ee522cf5469a071a7f5870739f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTUwMDc3NQ==", "bodyText": "I decided to hold off on this, but I can reconsider it if you think it's worthwhile.\n\nit is fine to me as your approach is more simple :)\n\nWhat might be preferable is to provide a way to override the request timeout in TransactionalMessageCopier so that we can use lower values in all cases.\n\nthe root cause I observed is different to https://issues.apache.org/jira/browse/KAFKA-9802. On my local, TransactionalMessageCopier fails due to ProducerFencedException which is caused by that broker increases the producer epoch when aborting transaction.\n                    } catch (ProducerFencedException | OutOfOrderSequenceException e) {\n                        // We cannot recover from these errors, so just rethrow them and let the process fail\n                        throw e;\n                    } catch (KafkaException e) {\n                        producer.abortTransaction();\n                        resetToLastCommittedPositions(consumer);\n                    }\n\nPerhaps we should make TransactionalMessageCopier recoverable from transaction timeout before KIP-558 is addressed.\nBTW, group_mode_transactions_test.py has similar issue. Could you fix it also? Or we can apply your approach to fix group_mode_transactions_test.py in another PR.", "url": "https://github.com/apache/kafka/pull/9026#discussion_r455500775", "createdAt": "2020-07-16T04:19:52Z", "author": {"login": "chia7712"}, "path": "tests/kafkatest/tests/core/transactions_test.py", "diffHunk": "@@ -47,11 +47,15 @@ def __init__(self, test_context):\n         self.num_output_partitions = 3\n         self.num_seed_messages = 100000\n         self.transaction_size = 750\n-        # The timeout of transaction should be lower than the timeout of verification. The transactional message sent by\n-        # client may be not correctly completed in hard_bounce mode. The pending transaction (unstable offset) stored by\n-        # broker obstructs TransactionMessageCopier from getting offset of partition which is used to calculate\n-        # remaining messages after restarting.\n-        self.transaction_timeout = 5000\n+\n+        # The transaction timeout should be lower than the progress timeout, but at\n+        # least as high as the request timeout (which is 30s by default). When the\n+        # client is hard-bounced, progress may depend on the previous transaction\n+        # being aborted. When the broker is hard-bounced, we may have to wait as\n+        # long as the request timeout to get a `Produce` response and we do not\n+        # want the coordinator timing out the transaction.\n+        self.transaction_timeout = 40000\n+        self.progress_timeout_sec = 60", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDg2NzQxNA=="}, "originalCommit": {"oid": "dea96a4ff9e742ee522cf5469a071a7f5870739f"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2262, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}