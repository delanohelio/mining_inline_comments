{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0MzQ2MzIy", "number": 8628, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMzo1MjoxNVrOD6dfbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwMDozMToxOFrOD6d9GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjI3MTgyOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/admin/ConfigCommand.scala", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMzo1MjoxNVrOGSUMcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzoyNDo1M1rOGS2Uuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg1ODQxOA==", "bodyText": "It's not really that they're invalid, it's that we want to delete them and they're not present, right?  I realize this is an existing issue.", "url": "https://github.com/apache/kafka/pull/8628#discussion_r421858418", "createdAt": "2020-05-07T23:52:15Z", "author": {"login": "cmccabe"}, "path": "core/src/main/scala/kafka/admin/ConfigCommand.scala", "diffHunk": "@@ -362,21 +362,22 @@ object ConfigCommand extends Config {\n         ).asJavaCollection\n         adminClient.incrementalAlterConfigs(Map(configResource -> alterLogLevelEntries).asJava, alterOptions).all().get(60, TimeUnit.SECONDS)\n \n-      case ConfigType.User =>\n-      case ConfigType.Client =>\n-        val oldConfig: Map[String, java.lang.Double] = getClientQuotasConfig(adminClient, entityTypes, entityNames)\n+      case ConfigType.User | ConfigType.Client =>\n+        val oldConfig = getClientQuotasConfig(adminClient, entityTypes, entityNames)\n \n         val invalidConfigs = configsToBeDeleted.filterNot(oldConfig.contains)\n         if (invalidConfigs.nonEmpty)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "927580442ced625bf2988a440d78934665b3c062"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg1OTYzOQ==", "bodyText": "That's correct. I can rename the variable for the various cases if you'd prefer.", "url": "https://github.com/apache/kafka/pull/8628#discussion_r421859639", "createdAt": "2020-05-07T23:56:22Z", "author": {"login": "bdbyrne"}, "path": "core/src/main/scala/kafka/admin/ConfigCommand.scala", "diffHunk": "@@ -362,21 +362,22 @@ object ConfigCommand extends Config {\n         ).asJavaCollection\n         adminClient.incrementalAlterConfigs(Map(configResource -> alterLogLevelEntries).asJava, alterOptions).all().get(60, TimeUnit.SECONDS)\n \n-      case ConfigType.User =>\n-      case ConfigType.Client =>\n-        val oldConfig: Map[String, java.lang.Double] = getClientQuotasConfig(adminClient, entityTypes, entityNames)\n+      case ConfigType.User | ConfigType.Client =>\n+        val oldConfig = getClientQuotasConfig(adminClient, entityTypes, entityNames)\n \n         val invalidConfigs = configsToBeDeleted.filterNot(oldConfig.contains)\n         if (invalidConfigs.nonEmpty)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg1ODQxOA=="}, "originalCommit": {"oid": "927580442ced625bf2988a440d78934665b3c062"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzU5NQ==", "bodyText": "It's OK as-is.", "url": "https://github.com/apache/kafka/pull/8628#discussion_r422417595", "createdAt": "2020-05-08T23:24:53Z", "author": {"login": "cmccabe"}, "path": "core/src/main/scala/kafka/admin/ConfigCommand.scala", "diffHunk": "@@ -362,21 +362,22 @@ object ConfigCommand extends Config {\n         ).asJavaCollection\n         adminClient.incrementalAlterConfigs(Map(configResource -> alterLogLevelEntries).asJava, alterOptions).all().get(60, TimeUnit.SECONDS)\n \n-      case ConfigType.User =>\n-      case ConfigType.Client =>\n-        val oldConfig: Map[String, java.lang.Double] = getClientQuotasConfig(adminClient, entityTypes, entityNames)\n+      case ConfigType.User | ConfigType.Client =>\n+        val oldConfig = getClientQuotasConfig(adminClient, entityTypes, entityNames)\n \n         val invalidConfigs = configsToBeDeleted.filterNot(oldConfig.contains)\n         if (invalidConfigs.nonEmpty)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg1ODQxOA=="}, "originalCommit": {"oid": "927580442ced625bf2988a440d78934665b3c062"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjMxMDA4OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/admin/ConfigCommand.scala", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwMDoxMToyMFrOGSUiww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNzoyNTozOFrOGStRvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg2NDEzMQ==", "bodyText": "Since this map potentially contains nulls (a bad practice) we need to be very careful about its type.  Many newer map types don't allow nulls and I don't trust Scala to always create a map that allows this.  I suggest manually building a Java HashMap.", "url": "https://github.com/apache/kafka/pull/8628#discussion_r421864131", "createdAt": "2020-05-08T00:11:20Z", "author": {"login": "cmccabe"}, "path": "core/src/main/scala/kafka/admin/ConfigCommand.scala", "diffHunk": "@@ -362,21 +362,22 @@ object ConfigCommand extends Config {\n         ).asJavaCollection\n         adminClient.incrementalAlterConfigs(Map(configResource -> alterLogLevelEntries).asJava, alterOptions).all().get(60, TimeUnit.SECONDS)\n \n-      case ConfigType.User =>\n-      case ConfigType.Client =>\n-        val oldConfig: Map[String, java.lang.Double] = getClientQuotasConfig(adminClient, entityTypes, entityNames)\n+      case ConfigType.User | ConfigType.Client =>\n+        val oldConfig = getClientQuotasConfig(adminClient, entityTypes, entityNames)\n \n         val invalidConfigs = configsToBeDeleted.filterNot(oldConfig.contains)\n         if (invalidConfigs.nonEmpty)\n           throw new InvalidConfigurationException(s\"Invalid config(s): ${invalidConfigs.mkString(\",\")}\")\n \n-        val entity = new ClientQuotaEntity(opts.entityTypes.map { entType =>\n+        val alterEntityTypes = entityTypes.map { entType =>\n           entType match {\n             case ConfigType.User => ClientQuotaEntity.USER\n             case ConfigType.Client => ClientQuotaEntity.CLIENT_ID\n             case _ => throw new IllegalArgumentException(s\"Unexpected entity type: ${entType}\")\n           }\n-        }.zip(opts.entityNames).toMap.asJava)\n+        }\n+        val alterEntityNames = entityNames.map(en => if (en.nonEmpty) en else null)\n+        val entity = new ClientQuotaEntity(alterEntityTypes.zip(alterEntityNames).toMap.asJava)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "927580442ced625bf2988a440d78934665b3c062"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2OTM3Mg==", "bodyText": "Done.", "url": "https://github.com/apache/kafka/pull/8628#discussion_r422269372", "createdAt": "2020-05-08T17:25:38Z", "author": {"login": "bdbyrne"}, "path": "core/src/main/scala/kafka/admin/ConfigCommand.scala", "diffHunk": "@@ -362,21 +362,22 @@ object ConfigCommand extends Config {\n         ).asJavaCollection\n         adminClient.incrementalAlterConfigs(Map(configResource -> alterLogLevelEntries).asJava, alterOptions).all().get(60, TimeUnit.SECONDS)\n \n-      case ConfigType.User =>\n-      case ConfigType.Client =>\n-        val oldConfig: Map[String, java.lang.Double] = getClientQuotasConfig(adminClient, entityTypes, entityNames)\n+      case ConfigType.User | ConfigType.Client =>\n+        val oldConfig = getClientQuotasConfig(adminClient, entityTypes, entityNames)\n \n         val invalidConfigs = configsToBeDeleted.filterNot(oldConfig.contains)\n         if (invalidConfigs.nonEmpty)\n           throw new InvalidConfigurationException(s\"Invalid config(s): ${invalidConfigs.mkString(\",\")}\")\n \n-        val entity = new ClientQuotaEntity(opts.entityTypes.map { entType =>\n+        val alterEntityTypes = entityTypes.map { entType =>\n           entType match {\n             case ConfigType.User => ClientQuotaEntity.USER\n             case ConfigType.Client => ClientQuotaEntity.CLIENT_ID\n             case _ => throw new IllegalArgumentException(s\"Unexpected entity type: ${entType}\")\n           }\n-        }.zip(opts.entityNames).toMap.asJava)\n+        }\n+        val alterEntityNames = entityNames.map(en => if (en.nonEmpty) en else null)\n+        val entity = new ClientQuotaEntity(alterEntityTypes.zip(alterEntityNames).toMap.asJava)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg2NDEzMQ=="}, "originalCommit": {"oid": "927580442ced625bf2988a440d78934665b3c062"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNjM0Nzc3OnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/admin/ConfigCommandTest.scala", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwMDozMToxOFrOGSU5QQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNzoyNTozNFrOGStRlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg2OTg4OQ==", "bodyText": "Same comment here.  We should use java's HashMap specifically since we know it supports null values and we don't know if other maps do or not.", "url": "https://github.com/apache/kafka/pull/8628#discussion_r421869889", "createdAt": "2020-05-08T00:31:18Z", "author": {"login": "cmccabe"}, "path": "core/src/test/scala/unit/kafka/admin/ConfigCommandTest.scala", "diffHunk": "@@ -398,16 +398,30 @@ class ConfigCommandTest extends ZooKeeperTestHarness with Logging {\n     ConfigCommand.alterConfigWithZk(null, createOpts, new TestAdminZkClient(zkClient))\n   }\n \n-  @Test\n-  def shouldAddClientConfig(): Unit = {\n+  def testShouldAddClientConfig(user: Option[String], clientId: Option[String]): Unit = {\n+    def toValues(entityName: Option[String], entityType: String, command: String):\n+        (Array[String], Option[String], Option[ClientQuotaFilterComponent]) = {\n+      entityName match {\n+        case Some(null) =>\n+          (Array(\"--entity-type\", command, \"--entity-default\"), Some(null),\n+            Some(ClientQuotaFilterComponent.ofDefaultEntity(entityType)))\n+        case Some(name) =>\n+          (Array(\"--entity-type\", command, \"--entity-name\", name), Some(name),\n+            Some(ClientQuotaFilterComponent.ofEntity(entityType, name)))\n+        case None => (Array.empty, None, None)\n+      }\n+    }\n+    val (userArgs, userEntity, userComponent) = toValues(user, ClientQuotaEntity.USER, \"users\")\n+    val (clientIdArgs, clientIdEntity, clientIdComponent) = toValues(clientId, ClientQuotaEntity.CLIENT_ID, \"clients\")\n+\n     val createOpts = new ConfigCommandOptions(Array(\"--bootstrap-server\", \"localhost:9092\",\n-      \"--entity-name\", \"my-client-id\",\n-      \"--entity-type\", \"clients\",\n       \"--alter\",\n       \"--add-config\", \"consumer_byte_rate=20000,producer_byte_rate=10000\",\n-      \"--delete-config\", \"request_percentage\"))\n+      \"--delete-config\", \"request_percentage\") ++ userArgs ++ clientIdArgs)\n \n-    val entity = new ClientQuotaEntity(Map((ClientQuotaEntity.CLIENT_ID -> \"my-client-id\")).asJava)\n+    val entity = new ClientQuotaEntity(Seq(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "927580442ced625bf2988a440d78934665b3c062"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2OTMzNQ==", "bodyText": "Done.", "url": "https://github.com/apache/kafka/pull/8628#discussion_r422269335", "createdAt": "2020-05-08T17:25:34Z", "author": {"login": "bdbyrne"}, "path": "core/src/test/scala/unit/kafka/admin/ConfigCommandTest.scala", "diffHunk": "@@ -398,16 +398,30 @@ class ConfigCommandTest extends ZooKeeperTestHarness with Logging {\n     ConfigCommand.alterConfigWithZk(null, createOpts, new TestAdminZkClient(zkClient))\n   }\n \n-  @Test\n-  def shouldAddClientConfig(): Unit = {\n+  def testShouldAddClientConfig(user: Option[String], clientId: Option[String]): Unit = {\n+    def toValues(entityName: Option[String], entityType: String, command: String):\n+        (Array[String], Option[String], Option[ClientQuotaFilterComponent]) = {\n+      entityName match {\n+        case Some(null) =>\n+          (Array(\"--entity-type\", command, \"--entity-default\"), Some(null),\n+            Some(ClientQuotaFilterComponent.ofDefaultEntity(entityType)))\n+        case Some(name) =>\n+          (Array(\"--entity-type\", command, \"--entity-name\", name), Some(name),\n+            Some(ClientQuotaFilterComponent.ofEntity(entityType, name)))\n+        case None => (Array.empty, None, None)\n+      }\n+    }\n+    val (userArgs, userEntity, userComponent) = toValues(user, ClientQuotaEntity.USER, \"users\")\n+    val (clientIdArgs, clientIdEntity, clientIdComponent) = toValues(clientId, ClientQuotaEntity.CLIENT_ID, \"clients\")\n+\n     val createOpts = new ConfigCommandOptions(Array(\"--bootstrap-server\", \"localhost:9092\",\n-      \"--entity-name\", \"my-client-id\",\n-      \"--entity-type\", \"clients\",\n       \"--alter\",\n       \"--add-config\", \"consumer_byte_rate=20000,producer_byte_rate=10000\",\n-      \"--delete-config\", \"request_percentage\"))\n+      \"--delete-config\", \"request_percentage\") ++ userArgs ++ clientIdArgs)\n \n-    val entity = new ClientQuotaEntity(Map((ClientQuotaEntity.CLIENT_ID -> \"my-client-id\")).asJava)\n+    val entity = new ClientQuotaEntity(Seq(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg2OTg4OQ=="}, "originalCommit": {"oid": "927580442ced625bf2988a440d78934665b3c062"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2909, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}