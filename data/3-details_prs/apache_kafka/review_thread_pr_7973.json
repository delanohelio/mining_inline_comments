{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzNzA1NDg2", "number": 7973, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNzoxOToxM1rODYu5hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNzozNDozMVrODYvCMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjYwODA1OnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNzoxOToxNFrOFewk3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMDowNDozNVrOFe0LxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc5NzQ2OQ==", "bodyText": "This is just ensuring there is one call to updateFollowers with every append?", "url": "https://github.com/apache/kafka/pull/7973#discussion_r367797469", "createdAt": "2020-01-17T07:19:14Z", "author": {"login": "hachikuji"}, "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -111,62 +111,75 @@ class PartitionLockTest extends Logging {\n \n     val future = scheduleShrinkIsr(active, mockTimeSleepMs = 10000)\n     TestUtils.waitUntilTrue(() => shrinkIsrSemaphore.hasQueuedThreads, \"shrinkIsr not invoked\")\n-    concurrentProduceFetch(numProducers, numReplicaFetchers, numRecordsPerProducer, appendSemaphore, Some(shrinkIsrSemaphore))\n+    concurrentProduceFetchWithWriteLock(appendSemaphore, shrinkIsrSemaphore)\n     active.set(false)\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n-  private def concurrentProduceFetch(numProducers: Int,\n-                                     numReplicaFetchers: Int,\n-                                     numRecords: Int,\n-                                     appendSemaphore: Semaphore,\n-                                     shrinkIsrSemaphore: Option[Semaphore]): Unit = {\n-    val followerQueues = (0 until numReplicaFetchers).map(_ => new ArrayBlockingQueue[MemoryRecords](2))\n+  /**\n+   * Perform concurrent appends and replica fetch requests that don't require write lock to\n+   * update follower state. Release sufficient append permits to complete all except one append.\n+   * Verify that follower state updates complete even though an append holding read lock is in progress.\n+   * Then release the permit for the final append and verify that all appends and follower updates complete.\n+   */\n+  private def concurrentProduceFetchWithReadLockOnly(appendSemaphore: Semaphore): Unit = {\n+    val appendFutures = scheduleAppends()\n+    val stateUpdateFutures = scheduleUpdateFollowers(numProducers * numRecordsPerProducer - 1)\n+\n+    appendSemaphore.release(numProducers * numRecordsPerProducer - 1)\n+    stateUpdateFutures.foreach(_.get(15, TimeUnit.SECONDS))\n+\n+    appendSemaphore.release(1)\n+    scheduleUpdateFollowers(1).foreach(_.get(15, TimeUnit.SECONDS))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "babce59e894003d2149b9fc0ce2130709d07ce06"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg1NjU4MQ==", "bodyText": "yes, it isn't really necessary for the test, but kept it anyway and added a comment.", "url": "https://github.com/apache/kafka/pull/7973#discussion_r367856581", "createdAt": "2020-01-17T10:04:35Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -111,62 +111,75 @@ class PartitionLockTest extends Logging {\n \n     val future = scheduleShrinkIsr(active, mockTimeSleepMs = 10000)\n     TestUtils.waitUntilTrue(() => shrinkIsrSemaphore.hasQueuedThreads, \"shrinkIsr not invoked\")\n-    concurrentProduceFetch(numProducers, numReplicaFetchers, numRecordsPerProducer, appendSemaphore, Some(shrinkIsrSemaphore))\n+    concurrentProduceFetchWithWriteLock(appendSemaphore, shrinkIsrSemaphore)\n     active.set(false)\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n-  private def concurrentProduceFetch(numProducers: Int,\n-                                     numReplicaFetchers: Int,\n-                                     numRecords: Int,\n-                                     appendSemaphore: Semaphore,\n-                                     shrinkIsrSemaphore: Option[Semaphore]): Unit = {\n-    val followerQueues = (0 until numReplicaFetchers).map(_ => new ArrayBlockingQueue[MemoryRecords](2))\n+  /**\n+   * Perform concurrent appends and replica fetch requests that don't require write lock to\n+   * update follower state. Release sufficient append permits to complete all except one append.\n+   * Verify that follower state updates complete even though an append holding read lock is in progress.\n+   * Then release the permit for the final append and verify that all appends and follower updates complete.\n+   */\n+  private def concurrentProduceFetchWithReadLockOnly(appendSemaphore: Semaphore): Unit = {\n+    val appendFutures = scheduleAppends()\n+    val stateUpdateFutures = scheduleUpdateFollowers(numProducers * numRecordsPerProducer - 1)\n+\n+    appendSemaphore.release(numProducers * numRecordsPerProducer - 1)\n+    stateUpdateFutures.foreach(_.get(15, TimeUnit.SECONDS))\n+\n+    appendSemaphore.release(1)\n+    scheduleUpdateFollowers(1).foreach(_.get(15, TimeUnit.SECONDS))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc5NzQ2OQ=="}, "originalCommit": {"oid": "babce59e894003d2149b9fc0ce2130709d07ce06"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjYxOTMwOnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNzoyNzowM1rOFewr3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNzoyNzowM1rOFewr3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc5OTI2MQ==", "bodyText": "nit: would be nice to be consistent on the usage of class fields. This wouldn't work if the passed semaphore wasn't the class field since that is what we used when building the log. Maybe we can drop the parameter?", "url": "https://github.com/apache/kafka/pull/7973#discussion_r367799261", "createdAt": "2020-01-17T07:27:03Z", "author": {"login": "hachikuji"}, "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -111,62 +111,75 @@ class PartitionLockTest extends Logging {\n \n     val future = scheduleShrinkIsr(active, mockTimeSleepMs = 10000)\n     TestUtils.waitUntilTrue(() => shrinkIsrSemaphore.hasQueuedThreads, \"shrinkIsr not invoked\")\n-    concurrentProduceFetch(numProducers, numReplicaFetchers, numRecordsPerProducer, appendSemaphore, Some(shrinkIsrSemaphore))\n+    concurrentProduceFetchWithWriteLock(appendSemaphore, shrinkIsrSemaphore)\n     active.set(false)\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n-  private def concurrentProduceFetch(numProducers: Int,\n-                                     numReplicaFetchers: Int,\n-                                     numRecords: Int,\n-                                     appendSemaphore: Semaphore,\n-                                     shrinkIsrSemaphore: Option[Semaphore]): Unit = {\n-    val followerQueues = (0 until numReplicaFetchers).map(_ => new ArrayBlockingQueue[MemoryRecords](2))\n+  /**\n+   * Perform concurrent appends and replica fetch requests that don't require write lock to\n+   * update follower state. Release sufficient append permits to complete all except one append.\n+   * Verify that follower state updates complete even though an append holding read lock is in progress.\n+   * Then release the permit for the final append and verify that all appends and follower updates complete.\n+   */\n+  private def concurrentProduceFetchWithReadLockOnly(appendSemaphore: Semaphore): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "babce59e894003d2149b9fc0ce2130709d07ce06"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjYzMDI3OnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwNzozNDozMVrOFewygA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMDowNDo1N1rOFe0MWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgwMDk2MA==", "bodyText": "Just checking my understanding, but it seems there's no need to do this after the shrink semaphore is released. If we did it before, then we could assert that the append futures are blocked just like the update follower futures.", "url": "https://github.com/apache/kafka/pull/7973#discussion_r367800960", "createdAt": "2020-01-17T07:34:31Z", "author": {"login": "hachikuji"}, "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -111,62 +111,75 @@ class PartitionLockTest extends Logging {\n \n     val future = scheduleShrinkIsr(active, mockTimeSleepMs = 10000)\n     TestUtils.waitUntilTrue(() => shrinkIsrSemaphore.hasQueuedThreads, \"shrinkIsr not invoked\")\n-    concurrentProduceFetch(numProducers, numReplicaFetchers, numRecordsPerProducer, appendSemaphore, Some(shrinkIsrSemaphore))\n+    concurrentProduceFetchWithWriteLock(appendSemaphore, shrinkIsrSemaphore)\n     active.set(false)\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n-  private def concurrentProduceFetch(numProducers: Int,\n-                                     numReplicaFetchers: Int,\n-                                     numRecords: Int,\n-                                     appendSemaphore: Semaphore,\n-                                     shrinkIsrSemaphore: Option[Semaphore]): Unit = {\n-    val followerQueues = (0 until numReplicaFetchers).map(_ => new ArrayBlockingQueue[MemoryRecords](2))\n+  /**\n+   * Perform concurrent appends and replica fetch requests that don't require write lock to\n+   * update follower state. Release sufficient append permits to complete all except one append.\n+   * Verify that follower state updates complete even though an append holding read lock is in progress.\n+   * Then release the permit for the final append and verify that all appends and follower updates complete.\n+   */\n+  private def concurrentProduceFetchWithReadLockOnly(appendSemaphore: Semaphore): Unit = {\n+    val appendFutures = scheduleAppends()\n+    val stateUpdateFutures = scheduleUpdateFollowers(numProducers * numRecordsPerProducer - 1)\n+\n+    appendSemaphore.release(numProducers * numRecordsPerProducer - 1)\n+    stateUpdateFutures.foreach(_.get(15, TimeUnit.SECONDS))\n+\n+    appendSemaphore.release(1)\n+    scheduleUpdateFollowers(1).foreach(_.get(15, TimeUnit.SECONDS))\n+    appendFutures.foreach(_.get(15, TimeUnit.SECONDS))\n+  }\n+\n+  /**\n+   * Perform concurrent appends and replica fetch requests that may require write lock to update\n+   * follower state. Threads waiting for write lock to update follower state while append thread is\n+   * holding read lock will prevent other threads acquiring the read or write lock. So release sufficient\n+   * permits for all appends to complete before verifying state updates.\n+   */\n+  private def concurrentProduceFetchWithWriteLock(appendSemaphore: Semaphore,\n+                                                  shrinkIsrSemaphore: Semaphore): Unit = {\n+\n+    val appendFutures = scheduleAppends()\n+    val stateUpdateFutures = scheduleUpdateFollowers(numProducers * numRecordsPerProducer)\n+\n+    assertFalse(stateUpdateFutures.exists(_.isDone))\n+    shrinkIsrSemaphore.release()\n+    appendSemaphore.release(numProducers * numRecordsPerProducer)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "babce59e894003d2149b9fc0ce2130709d07ce06"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg1NjczMA==", "bodyText": "Good idea, updated.", "url": "https://github.com/apache/kafka/pull/7973#discussion_r367856730", "createdAt": "2020-01-17T10:04:57Z", "author": {"login": "rajinisivaram"}, "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -111,62 +111,75 @@ class PartitionLockTest extends Logging {\n \n     val future = scheduleShrinkIsr(active, mockTimeSleepMs = 10000)\n     TestUtils.waitUntilTrue(() => shrinkIsrSemaphore.hasQueuedThreads, \"shrinkIsr not invoked\")\n-    concurrentProduceFetch(numProducers, numReplicaFetchers, numRecordsPerProducer, appendSemaphore, Some(shrinkIsrSemaphore))\n+    concurrentProduceFetchWithWriteLock(appendSemaphore, shrinkIsrSemaphore)\n     active.set(false)\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n-  private def concurrentProduceFetch(numProducers: Int,\n-                                     numReplicaFetchers: Int,\n-                                     numRecords: Int,\n-                                     appendSemaphore: Semaphore,\n-                                     shrinkIsrSemaphore: Option[Semaphore]): Unit = {\n-    val followerQueues = (0 until numReplicaFetchers).map(_ => new ArrayBlockingQueue[MemoryRecords](2))\n+  /**\n+   * Perform concurrent appends and replica fetch requests that don't require write lock to\n+   * update follower state. Release sufficient append permits to complete all except one append.\n+   * Verify that follower state updates complete even though an append holding read lock is in progress.\n+   * Then release the permit for the final append and verify that all appends and follower updates complete.\n+   */\n+  private def concurrentProduceFetchWithReadLockOnly(appendSemaphore: Semaphore): Unit = {\n+    val appendFutures = scheduleAppends()\n+    val stateUpdateFutures = scheduleUpdateFollowers(numProducers * numRecordsPerProducer - 1)\n+\n+    appendSemaphore.release(numProducers * numRecordsPerProducer - 1)\n+    stateUpdateFutures.foreach(_.get(15, TimeUnit.SECONDS))\n+\n+    appendSemaphore.release(1)\n+    scheduleUpdateFollowers(1).foreach(_.get(15, TimeUnit.SECONDS))\n+    appendFutures.foreach(_.get(15, TimeUnit.SECONDS))\n+  }\n+\n+  /**\n+   * Perform concurrent appends and replica fetch requests that may require write lock to update\n+   * follower state. Threads waiting for write lock to update follower state while append thread is\n+   * holding read lock will prevent other threads acquiring the read or write lock. So release sufficient\n+   * permits for all appends to complete before verifying state updates.\n+   */\n+  private def concurrentProduceFetchWithWriteLock(appendSemaphore: Semaphore,\n+                                                  shrinkIsrSemaphore: Semaphore): Unit = {\n+\n+    val appendFutures = scheduleAppends()\n+    val stateUpdateFutures = scheduleUpdateFollowers(numProducers * numRecordsPerProducer)\n+\n+    assertFalse(stateUpdateFutures.exists(_.isDone))\n+    shrinkIsrSemaphore.release()\n+    appendSemaphore.release(numProducers * numRecordsPerProducer)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgwMDk2MA=="}, "originalCommit": {"oid": "babce59e894003d2149b9fc0ce2130709d07ce06"}, "originalPosition": 88}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4385, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}