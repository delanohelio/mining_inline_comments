{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxMjU3Njg4", "number": 8319, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjowMDoxMFrODpsQ7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjoxNTowNFrODpsftw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDQzNDM4OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjowMDoxMFrOF5B3CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwMjowMzoxMlrOF5F6AQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MzYyNQ==", "bodyText": "I moved this inside the block because we should only need to do it if we are transitioning from restoring standbys. I wanted to make the idempotent call slightly more efficient, since we now call this method every time in StreamThread#runOnce.", "url": "https://github.com/apache/kafka/pull/8319#discussion_r395343625", "createdAt": "2020-03-19T22:00:10Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -279,13 +279,13 @@ private boolean hasRestoredToEnd(final ChangelogMetadata metadata) {\n     // NOTE: even if the newly created tasks do not need any restoring, we still first transit to this state and then\n     // immediately transit back -- there's no overhead of transiting back and forth but simplifies the logic a lot.\n     @Override\n-    public void transitToRestoreActive() {\n+    public void enforceRestoreActive() {\n         if (state != ChangelogReaderState.ACTIVE_RESTORING) {\n             log.debug(\"Transiting to restore active tasks: {}\", changelogs);\n-        }\n \n-        // pause all partitions that are for standby tasks from the restore consumer\n-        pauseChangelogsFromRestoreConsumer(standbyRestoringChangelogs());\n+            // pause all partitions that are for standby tasks from the restore consumer\n+            pauseChangelogsFromRestoreConsumer(standbyRestoringChangelogs());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7ac051e495a98b6c72a340c24f4b9bb1f25dcdd"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM2OTc4MA==", "bodyText": "We can move the line 290 inside as well?", "url": "https://github.com/apache/kafka/pull/8319#discussion_r395369780", "createdAt": "2020-03-19T23:12:09Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -279,13 +279,13 @@ private boolean hasRestoredToEnd(final ChangelogMetadata metadata) {\n     // NOTE: even if the newly created tasks do not need any restoring, we still first transit to this state and then\n     // immediately transit back -- there's no overhead of transiting back and forth but simplifies the logic a lot.\n     @Override\n-    public void transitToRestoreActive() {\n+    public void enforceRestoreActive() {\n         if (state != ChangelogReaderState.ACTIVE_RESTORING) {\n             log.debug(\"Transiting to restore active tasks: {}\", changelogs);\n-        }\n \n-        // pause all partitions that are for standby tasks from the restore consumer\n-        pauseChangelogsFromRestoreConsumer(standbyRestoringChangelogs());\n+            // pause all partitions that are for standby tasks from the restore consumer\n+            pauseChangelogsFromRestoreConsumer(standbyRestoringChangelogs());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MzYyNQ=="}, "originalCommit": {"oid": "c7ac051e495a98b6c72a340c24f4b9bb1f25dcdd"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQwOTkyMQ==", "bodyText": "Oh, yeah, of course :)", "url": "https://github.com/apache/kafka/pull/8319#discussion_r395409921", "createdAt": "2020-03-20T02:03:12Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -279,13 +279,13 @@ private boolean hasRestoredToEnd(final ChangelogMetadata metadata) {\n     // NOTE: even if the newly created tasks do not need any restoring, we still first transit to this state and then\n     // immediately transit back -- there's no overhead of transiting back and forth but simplifies the logic a lot.\n     @Override\n-    public void transitToRestoreActive() {\n+    public void enforceRestoreActive() {\n         if (state != ChangelogReaderState.ACTIVE_RESTORING) {\n             log.debug(\"Transiting to restore active tasks: {}\", changelogs);\n-        }\n \n-        // pause all partitions that are for standby tasks from the restore consumer\n-        pauseChangelogsFromRestoreConsumer(standbyRestoringChangelogs());\n+            // pause all partitions that are for standby tasks from the restore consumer\n+            pauseChangelogsFromRestoreConsumer(standbyRestoringChangelogs());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MzYyNQ=="}, "originalCommit": {"oid": "c7ac051e495a98b6c72a340c24f4b9bb1f25dcdd"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDQzNzM3OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjowMToxNFrOF5B4zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjowMToxNFrOF5B4zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NDA3Nw==", "bodyText": "This might be a bit redundant, but it wasted a bit of my time to find out that if it wasn't in active_restoring, it must have been in restoring standbys because that's the only other state. I figure it doesn't hurt to just be explicit.", "url": "https://github.com/apache/kafka/pull/8319#discussion_r395344077", "createdAt": "2020-03-19T22:01:14Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -300,8 +300,10 @@ public void transitToRestoreActive() {\n     @Override\n     public void transitToUpdateStandby() {\n         if (state != ChangelogReaderState.ACTIVE_RESTORING) {\n-            throw new IllegalStateException(\"The changelog reader is not restoring active tasks while trying to \" +\n-                \"transit to update standby tasks: \" + changelogs);\n+            throw new IllegalStateException(\n+                \"The changelog reader is not restoring active tasks (is \" + state + \") while trying to \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7ac051e495a98b6c72a340c24f4b9bb1f25dcdd"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDQzOTIzOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjowMTo1NFrOF5B57Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjowMTo1NFrOF5B57Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NDM2NQ==", "bodyText": "Rearranged this so we can include the exception itself. The stacktrace is useful for tracking down the reason for the exception.", "url": "https://github.com/apache/kafka/pull/8319#discussion_r395344365", "createdAt": "2020-03-19T22:01:54Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -501,14 +501,14 @@ private void runLoop() {\n                     mainConsumer.enforceRebalance();\n                 }\n             } catch (final TaskCorruptedException e) {\n-                log.warn(\"Detected the states of tasks {} are corrupted. \" +\n-                    \"Will close the task as dirty and re-create and bootstrap from scratch.\", e.corruptedTaskWithChangelogs());\n+                log.warn(\"Detected the states of tasks \" + e.corruptedTaskWithChangelogs() + \" are corrupted. \" +\n+                             \"Will close the task as dirty and re-create and bootstrap from scratch.\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7ac051e495a98b6c72a340c24f4b9bb1f25dcdd"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDQzOTU0OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjowMjowMVrOF5B6Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjowMjowMVrOF5B6Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NDQxOA==", "bodyText": "Also, here.", "url": "https://github.com/apache/kafka/pull/8319#discussion_r395344418", "createdAt": "2020-03-19T22:02:01Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -501,14 +501,14 @@ private void runLoop() {\n                     mainConsumer.enforceRebalance();\n                 }\n             } catch (final TaskCorruptedException e) {\n-                log.warn(\"Detected the states of tasks {} are corrupted. \" +\n-                    \"Will close the task as dirty and re-create and bootstrap from scratch.\", e.corruptedTaskWithChangelogs());\n+                log.warn(\"Detected the states of tasks \" + e.corruptedTaskWithChangelogs() + \" are corrupted. \" +\n+                             \"Will close the task as dirty and re-create and bootstrap from scratch.\", e);\n \n                 taskManager.handleCorruption(e.corruptedTaskWithChangelogs());\n             } catch (final TaskMigratedException e) {\n                 log.warn(\"Detected that the thread is being fenced. \" +\n-                    \"This implies that this thread missed a rebalance and dropped out of the consumer group. \" +\n-                    \"Will close out all assigned tasks and rejoin the consumer group.\");\n+                             \"This implies that this thread missed a rebalance and dropped out of the consumer group. \" +\n+                             \"Will close out all assigned tasks and rejoin the consumer group.\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7ac051e495a98b6c72a340c24f4b9bb1f25dcdd"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDQ1NDgxOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjowNzo1NVrOF5CDUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjowNzo1NVrOF5CDUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0Njc3MA==", "bodyText": "This is the primary fix. Instead of relying (hoping) on TaskManager to put the changelog reader into restoring_active, we just idempotently make sure it's in that state any time we're in partitions_assigned.", "url": "https://github.com/apache/kafka/pull/8319#discussion_r395346770", "createdAt": "2020-03-19T22:07:55Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -578,13 +578,13 @@ void runOnce() {\n         // only try to initialize the assigned tasks\n         // if the state is still in PARTITION_ASSIGNED after the poll call\n         if (state == State.PARTITIONS_ASSIGNED) {\n+            // transit to restore active is idempotent so we can call it multiple times\n+            changelogReader.enforceRestoreActive();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7ac051e495a98b6c72a340c24f4b9bb1f25dcdd"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDQ2NzgwOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjoxMzoxM1rOF5CLiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjoxMzoxM1rOF5CLiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0ODg3Mw==", "bodyText": "Renamed this method to make it clear we aren't necessarily \"transitioning\", we actually call it all the time now any time we want to \"be in restoreActive\".", "url": "https://github.com/apache/kafka/pull/8319#discussion_r395348873", "createdAt": "2020-03-19T22:13:13Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -279,13 +279,13 @@ private boolean hasRestoredToEnd(final ChangelogMetadata metadata) {\n     // NOTE: even if the newly created tasks do not need any restoring, we still first transit to this state and then\n     // immediately transit back -- there's no overhead of transiting back and forth but simplifies the logic a lot.\n     @Override\n-    public void transitToRestoreActive() {\n+    public void enforceRestoreActive() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7ac051e495a98b6c72a340c24f4b9bb1f25dcdd"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDQ3MjIzOnYy", "diffSide": "LEFT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjoxNTowNFrOF5COYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMjoxNTowNFrOF5COYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0OTYwMA==", "bodyText": "This is a strict mock, so we have to remove this expectation, since the TaskManager no longer calls it.", "url": "https://github.com/apache/kafka/pull/8319#discussion_r395349600", "createdAt": "2020-03-19T22:15:04Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -677,8 +677,6 @@ public void closeClean() {\n         };\n \n         resetToStrict(changeLogReader);\n-        changeLogReader.transitToRestoreActive();\n-        expectLastCall();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7ac051e495a98b6c72a340c24f4b9bb1f25dcdd"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3370, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}