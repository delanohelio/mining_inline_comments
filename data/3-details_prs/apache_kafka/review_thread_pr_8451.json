{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwOTM5NjE2", "number": 8451, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjoxNjoxN1rODwEMDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjozMzozNFrODwEnsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzI2ODYwOnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/common/record/FileRecords.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjoxNjoxN1rOGC2syA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjozMjoxOVrOGC3Wfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0NjUzNg==", "bodyText": "Was the boundary check wrong? You changed >= to >.", "url": "https://github.com/apache/kafka/pull/8451#discussion_r405646536", "createdAt": "2020-04-08T16:16:17Z", "author": {"login": "ijuma"}, "path": "clients/src/main/java/org/apache/kafka/common/record/FileRecords.java", "diffHunk": "@@ -135,17 +135,20 @@ public void readInto(ByteBuffer buffer, int position) throws IOException {\n      * @return A sliced wrapper on this message set limited based on the given position and size\n      */\n     public FileRecords slice(int position, int size) throws IOException {\n+        // Cache current size in case concurrent write changes it\n+        int currentSizeInBytes = sizeInBytes();\n+\n         if (position < 0)\n             throw new IllegalArgumentException(\"Invalid position: \" + position + \" in read from \" + this);\n-        if (position > sizeInBytes() - start)\n+        if (position > currentSizeInBytes - start)\n             throw new IllegalArgumentException(\"Slice from position \" + position + \" exceeds end position of \" + this);\n         if (size < 0)\n             throw new IllegalArgumentException(\"Invalid size: \" + size + \" in read from \" + this);\n \n         int end = this.start + position + size;\n         // handle integer overflow or if end is beyond the end of the file\n-        if (end < 0 || end >= start + sizeInBytes())\n-            end = start + sizeInBytes();\n+        if (end < 0 || end > start + currentSizeInBytes)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a362b45b814a5712861d7eca66f1453361aa1bff"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MTU0OQ==", "bodyText": "The common case that we would see this is when the limit matches the file end exactly. So changing this to > would also have fixed this problem for that case. I decided to remove it here though just because the equality check is redundant (if end == start + currentSizeInBytes, then there's no need to update it).", "url": "https://github.com/apache/kafka/pull/8451#discussion_r405651549", "createdAt": "2020-04-08T16:23:54Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/common/record/FileRecords.java", "diffHunk": "@@ -135,17 +135,20 @@ public void readInto(ByteBuffer buffer, int position) throws IOException {\n      * @return A sliced wrapper on this message set limited based on the given position and size\n      */\n     public FileRecords slice(int position, int size) throws IOException {\n+        // Cache current size in case concurrent write changes it\n+        int currentSizeInBytes = sizeInBytes();\n+\n         if (position < 0)\n             throw new IllegalArgumentException(\"Invalid position: \" + position + \" in read from \" + this);\n-        if (position > sizeInBytes() - start)\n+        if (position > currentSizeInBytes - start)\n             throw new IllegalArgumentException(\"Slice from position \" + position + \" exceeds end position of \" + this);\n         if (size < 0)\n             throw new IllegalArgumentException(\"Invalid size: \" + size + \" in read from \" + this);\n \n         int end = this.start + position + size;\n         // handle integer overflow or if end is beyond the end of the file\n-        if (end < 0 || end >= start + sizeInBytes())\n-            end = start + sizeInBytes();\n+        if (end < 0 || end > start + currentSizeInBytes)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0NjUzNg=="}, "originalCommit": {"oid": "a362b45b814a5712861d7eca66f1453361aa1bff"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1NzIxNA==", "bodyText": "Makes sense.", "url": "https://github.com/apache/kafka/pull/8451#discussion_r405657214", "createdAt": "2020-04-08T16:32:19Z", "author": {"login": "ijuma"}, "path": "clients/src/main/java/org/apache/kafka/common/record/FileRecords.java", "diffHunk": "@@ -135,17 +135,20 @@ public void readInto(ByteBuffer buffer, int position) throws IOException {\n      * @return A sliced wrapper on this message set limited based on the given position and size\n      */\n     public FileRecords slice(int position, int size) throws IOException {\n+        // Cache current size in case concurrent write changes it\n+        int currentSizeInBytes = sizeInBytes();\n+\n         if (position < 0)\n             throw new IllegalArgumentException(\"Invalid position: \" + position + \" in read from \" + this);\n-        if (position > sizeInBytes() - start)\n+        if (position > currentSizeInBytes - start)\n             throw new IllegalArgumentException(\"Slice from position \" + position + \" exceeds end position of \" + this);\n         if (size < 0)\n             throw new IllegalArgumentException(\"Invalid size: \" + size + \" in read from \" + this);\n \n         int end = this.start + position + size;\n         // handle integer overflow or if end is beyond the end of the file\n-        if (end < 0 || end >= start + sizeInBytes())\n-            end = start + sizeInBytes();\n+        if (end < 0 || end > start + currentSizeInBytes)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0NjUzNg=="}, "originalCommit": {"oid": "a362b45b814a5712861d7eca66f1453361aa1bff"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNzMzOTM2OnYy", "diffSide": "RIGHT", "path": "clients/src/test/java/org/apache/kafka/common/record/FileRecordsTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNjozMzozNFrOGC3ZsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNzozNjozOFrOGC5zxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1ODAzMg==", "bodyText": "How often does this fail?", "url": "https://github.com/apache/kafka/pull/8451#discussion_r405658032", "createdAt": "2020-04-08T16:33:34Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/record/FileRecordsTest.java", "diffHunk": "@@ -118,6 +121,36 @@ public void testIterationOverPartialAndTruncation() throws IOException {\n         testPartialWrite(6, fileRecords);\n     }\n \n+    @Test\n+    public void testSliceSizeLimitWithConcurrentWrite() throws Exception {\n+        FileRecords log = FileRecords.open(tempFile());\n+        ExecutorService executor = Executors.newFixedThreadPool(2);\n+        int maxSizeInBytes = 16384;\n+\n+        try {\n+            Future<Object> readerCompletion = executor.submit(() -> {\n+                while (log.sizeInBytes() < maxSizeInBytes) {\n+                    int currentSize = log.sizeInBytes();\n+                    FileRecords slice = log.slice(0, currentSize);\n+                    assertEquals(currentSize, slice.sizeInBytes());\n+                }\n+                return null;\n+            });\n+\n+            Future<Object> writerCompletion = executor.submit(() -> {\n+                while (log.sizeInBytes() < maxSizeInBytes) {\n+                    append(log, values);\n+                }\n+                return null;\n+            });\n+\n+            writerCompletion.get();\n+            readerCompletion.get();\n+        } finally {\n+            executor.shutdownNow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a362b45b814a5712861d7eca66f1453361aa1bff"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1OTQzOQ==", "bodyText": "It fails consistently for me without the fix.", "url": "https://github.com/apache/kafka/pull/8451#discussion_r405659439", "createdAt": "2020-04-08T16:35:45Z", "author": {"login": "hachikuji"}, "path": "clients/src/test/java/org/apache/kafka/common/record/FileRecordsTest.java", "diffHunk": "@@ -118,6 +121,36 @@ public void testIterationOverPartialAndTruncation() throws IOException {\n         testPartialWrite(6, fileRecords);\n     }\n \n+    @Test\n+    public void testSliceSizeLimitWithConcurrentWrite() throws Exception {\n+        FileRecords log = FileRecords.open(tempFile());\n+        ExecutorService executor = Executors.newFixedThreadPool(2);\n+        int maxSizeInBytes = 16384;\n+\n+        try {\n+            Future<Object> readerCompletion = executor.submit(() -> {\n+                while (log.sizeInBytes() < maxSizeInBytes) {\n+                    int currentSize = log.sizeInBytes();\n+                    FileRecords slice = log.slice(0, currentSize);\n+                    assertEquals(currentSize, slice.sizeInBytes());\n+                }\n+                return null;\n+            });\n+\n+            Future<Object> writerCompletion = executor.submit(() -> {\n+                while (log.sizeInBytes() < maxSizeInBytes) {\n+                    append(log, values);\n+                }\n+                return null;\n+            });\n+\n+            writerCompletion.get();\n+            readerCompletion.get();\n+        } finally {\n+            executor.shutdownNow();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1ODAzMg=="}, "originalCommit": {"oid": "a362b45b814a5712861d7eca66f1453361aa1bff"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY5NzQ3Nw==", "bodyText": "Nice", "url": "https://github.com/apache/kafka/pull/8451#discussion_r405697477", "createdAt": "2020-04-08T17:36:38Z", "author": {"login": "ijuma"}, "path": "clients/src/test/java/org/apache/kafka/common/record/FileRecordsTest.java", "diffHunk": "@@ -118,6 +121,36 @@ public void testIterationOverPartialAndTruncation() throws IOException {\n         testPartialWrite(6, fileRecords);\n     }\n \n+    @Test\n+    public void testSliceSizeLimitWithConcurrentWrite() throws Exception {\n+        FileRecords log = FileRecords.open(tempFile());\n+        ExecutorService executor = Executors.newFixedThreadPool(2);\n+        int maxSizeInBytes = 16384;\n+\n+        try {\n+            Future<Object> readerCompletion = executor.submit(() -> {\n+                while (log.sizeInBytes() < maxSizeInBytes) {\n+                    int currentSize = log.sizeInBytes();\n+                    FileRecords slice = log.slice(0, currentSize);\n+                    assertEquals(currentSize, slice.sizeInBytes());\n+                }\n+                return null;\n+            });\n+\n+            Future<Object> writerCompletion = executor.submit(() -> {\n+                while (log.sizeInBytes() < maxSizeInBytes) {\n+                    append(log, values);\n+                }\n+                return null;\n+            });\n+\n+            writerCompletion.get();\n+            readerCompletion.get();\n+        } finally {\n+            executor.shutdownNow();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1ODAzMg=="}, "originalCommit": {"oid": "a362b45b814a5712861d7eca66f1453361aa1bff"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2947, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}