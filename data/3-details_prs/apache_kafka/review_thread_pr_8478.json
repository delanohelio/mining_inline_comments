{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyOTI4Nzk5", "number": 8478, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzozNToxMFrODxwEew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxODowMDozNFrODyLuAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNDk0Mzk1OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateManagerUtil.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzozNToxMFrOGFZkQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoyNTo1OVrOGFjKjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxNDk0NQ==", "bodyText": "Not clear to me why we need a nested try-catch IOException here?", "url": "https://github.com/apache/kafka/pull/8478#discussion_r408314945", "createdAt": "2020-04-14T17:35:10Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateManagerUtil.java", "diffHunk": "@@ -100,41 +100,44 @@ static void closeStateManager(final Logger log,\n             throw new IllegalArgumentException(\"State store could not be wiped out during clean close\");\n         }\n \n-        ProcessorStateException exception = null;\n-\n         final TaskId id = stateMgr.taskId();\n-        log.trace(\"Closing state manager for {}\", id);\n+        log.trace(\"Closing state manager for {} task {}\", taskType, id);\n \n+        ProcessorStateException exception = null;\n         try {\n-            stateMgr.close();\n-\n-            if (wipeStateStore) {\n-                // we can just delete the whole dir of the task, including the state store images and the checkpoint files,\n-                // and then we write an empty checkpoint file indicating that the previous close is graceful and we just\n-                // need to re-bootstrap the restoration from the beginning\n-                Utils.delete(stateMgr.baseDir());\n-            }\n-        } catch (final ProcessorStateException e) {\n-            exception = e;\n-        } catch (final IOException e) {\n-            throw new ProcessorStateException(\"Failed to wiping state stores for task \" + id, e);\n-        } finally {\n-            try {\n-                stateDirectory.unlock(id);\n-            } catch (final IOException e) {\n-                if (exception == null) {\n-                    exception = new ProcessorStateException(\n-                        String.format(\"%sFailed to release state dir lock\", logPrefix), e);\n+            if (stateDirectory.lock(id)) {\n+                try {\n+                    stateMgr.close();\n+\n+                    if (wipeStateStore) {\n+                        // we can just delete the whole dir of the task, including the state store images and the checkpoint files,\n+                        // and then we write an empty checkpoint file indicating that the previous close is graceful and we just\n+                        // need to re-bootstrap the restoration from the beginning\n+                        Utils.delete(stateMgr.baseDir());\n+                    }\n+                } catch (final ProcessorStateException e) {\n+                    exception = e;\n+                } catch (final IOException e) {\n+                    throw new ProcessorStateException(\"Failed to wiping state stores for task \" + id, e);\n+                } finally {\n+                    try {\n+                        stateDirectory.unlock(id);\n+                    } catch (final IOException e) {\n+                        if (exception == null) {\n+                            exception = new ProcessorStateException(String.format(\"%sFailed to release state dir lock\", logPrefix), e);\n+                        }\n+                    }\n                 }\n             }\n+        } catch (final IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2NzQ5NQ==", "bodyText": "The only reason would be to distinguish between an IOException on lock, and one on unlock. But I guess that's not actually useful to differentiate, I'll take it out", "url": "https://github.com/apache/kafka/pull/8478#discussion_r408467495", "createdAt": "2020-04-14T22:13:59Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateManagerUtil.java", "diffHunk": "@@ -100,41 +100,44 @@ static void closeStateManager(final Logger log,\n             throw new IllegalArgumentException(\"State store could not be wiped out during clean close\");\n         }\n \n-        ProcessorStateException exception = null;\n-\n         final TaskId id = stateMgr.taskId();\n-        log.trace(\"Closing state manager for {}\", id);\n+        log.trace(\"Closing state manager for {} task {}\", taskType, id);\n \n+        ProcessorStateException exception = null;\n         try {\n-            stateMgr.close();\n-\n-            if (wipeStateStore) {\n-                // we can just delete the whole dir of the task, including the state store images and the checkpoint files,\n-                // and then we write an empty checkpoint file indicating that the previous close is graceful and we just\n-                // need to re-bootstrap the restoration from the beginning\n-                Utils.delete(stateMgr.baseDir());\n-            }\n-        } catch (final ProcessorStateException e) {\n-            exception = e;\n-        } catch (final IOException e) {\n-            throw new ProcessorStateException(\"Failed to wiping state stores for task \" + id, e);\n-        } finally {\n-            try {\n-                stateDirectory.unlock(id);\n-            } catch (final IOException e) {\n-                if (exception == null) {\n-                    exception = new ProcessorStateException(\n-                        String.format(\"%sFailed to release state dir lock\", logPrefix), e);\n+            if (stateDirectory.lock(id)) {\n+                try {\n+                    stateMgr.close();\n+\n+                    if (wipeStateStore) {\n+                        // we can just delete the whole dir of the task, including the state store images and the checkpoint files,\n+                        // and then we write an empty checkpoint file indicating that the previous close is graceful and we just\n+                        // need to re-bootstrap the restoration from the beginning\n+                        Utils.delete(stateMgr.baseDir());\n+                    }\n+                } catch (final ProcessorStateException e) {\n+                    exception = e;\n+                } catch (final IOException e) {\n+                    throw new ProcessorStateException(\"Failed to wiping state stores for task \" + id, e);\n+                } finally {\n+                    try {\n+                        stateDirectory.unlock(id);\n+                    } catch (final IOException e) {\n+                        if (exception == null) {\n+                            exception = new ProcessorStateException(String.format(\"%sFailed to release state dir lock\", logPrefix), e);\n+                        }\n+                    }\n                 }\n             }\n+        } catch (final IOException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxNDk0NQ=="}, "originalCommit": null, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MjIwNw==", "bodyText": "(or during wiping of the state stores, but presumably all this can be discovered through the state trace anyway)", "url": "https://github.com/apache/kafka/pull/8478#discussion_r408472207", "createdAt": "2020-04-14T22:25:59Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateManagerUtil.java", "diffHunk": "@@ -100,41 +100,44 @@ static void closeStateManager(final Logger log,\n             throw new IllegalArgumentException(\"State store could not be wiped out during clean close\");\n         }\n \n-        ProcessorStateException exception = null;\n-\n         final TaskId id = stateMgr.taskId();\n-        log.trace(\"Closing state manager for {}\", id);\n+        log.trace(\"Closing state manager for {} task {}\", taskType, id);\n \n+        ProcessorStateException exception = null;\n         try {\n-            stateMgr.close();\n-\n-            if (wipeStateStore) {\n-                // we can just delete the whole dir of the task, including the state store images and the checkpoint files,\n-                // and then we write an empty checkpoint file indicating that the previous close is graceful and we just\n-                // need to re-bootstrap the restoration from the beginning\n-                Utils.delete(stateMgr.baseDir());\n-            }\n-        } catch (final ProcessorStateException e) {\n-            exception = e;\n-        } catch (final IOException e) {\n-            throw new ProcessorStateException(\"Failed to wiping state stores for task \" + id, e);\n-        } finally {\n-            try {\n-                stateDirectory.unlock(id);\n-            } catch (final IOException e) {\n-                if (exception == null) {\n-                    exception = new ProcessorStateException(\n-                        String.format(\"%sFailed to release state dir lock\", logPrefix), e);\n+            if (stateDirectory.lock(id)) {\n+                try {\n+                    stateMgr.close();\n+\n+                    if (wipeStateStore) {\n+                        // we can just delete the whole dir of the task, including the state store images and the checkpoint files,\n+                        // and then we write an empty checkpoint file indicating that the previous close is graceful and we just\n+                        // need to re-bootstrap the restoration from the beginning\n+                        Utils.delete(stateMgr.baseDir());\n+                    }\n+                } catch (final ProcessorStateException e) {\n+                    exception = e;\n+                } catch (final IOException e) {\n+                    throw new ProcessorStateException(\"Failed to wiping state stores for task \" + id, e);\n+                } finally {\n+                    try {\n+                        stateDirectory.unlock(id);\n+                    } catch (final IOException e) {\n+                        if (exception == null) {\n+                            exception = new ProcessorStateException(String.format(\"%sFailed to release state dir lock\", logPrefix), e);\n+                        }\n+                    }\n                 }\n             }\n+        } catch (final IOException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxNDk0NQ=="}, "originalCommit": null, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNDk0NTA1OnYy", "diffSide": "LEFT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzozNToyNFrOGFZk7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzo0OTo1NlrOGGE6Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxNTExNg==", "bodyText": "Is this change intentional?", "url": "https://github.com/apache/kafka/pull/8478#discussion_r408315116", "createdAt": "2020-04-14T17:35:24Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -459,7 +459,6 @@ void handleLostAll() {\n         final Iterator<Task> iterator = tasks.values().iterator();\n         while (iterator.hasNext()) {\n             final Task task = iterator.next();\n-            final Set<TopicPartition> inputPartitions = task.inputPartitions();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2NTY5OA==", "bodyText": "Yep, sorry I meant to leave a comment. I noticed this is redundant since cleanupTask (invoked by closeTaskDirty) does the same thing", "url": "https://github.com/apache/kafka/pull/8478#discussion_r408465698", "createdAt": "2020-04-14T22:09:48Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -459,7 +459,6 @@ void handleLostAll() {\n         final Iterator<Task> iterator = tasks.values().iterator();\n         while (iterator.hasNext()) {\n             final Task task = iterator.next();\n-            final Set<TopicPartition> inputPartitions = task.inputPartitions();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxNTExNg=="}, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNTA1NQ==", "bodyText": "Thanks! SG.", "url": "https://github.com/apache/kafka/pull/8478#discussion_r409025055", "createdAt": "2020-04-15T17:49:56Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -459,7 +459,6 @@ void handleLostAll() {\n         final Iterator<Task> iterator = tasks.values().iterator();\n         while (iterator.hasNext()) {\n             final Task task = iterator.next();\n-            final Set<TopicPartition> inputPartitions = task.inputPartitions();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMxNTExNg=="}, "originalCommit": null, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjA0MDA5OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzoxNDoxM1rOGFkNIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzoxNDoxM1rOGFkNIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4OTI0OA==", "bodyText": "We actually were already throwing some ProcessorStateExceptions up through  close even when unclean, which I think was the cause of a bug we resolved a few weeks ago. Now we just make no assumptions about whether this will throw or not, and catch any exceptions in StreamTask / StandbyTask if it's a dirty close.", "url": "https://github.com/apache/kafka/pull/8478#discussion_r408489248", "createdAt": "2020-04-14T23:14:13Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java", "diffHunk": "@@ -249,32 +247,35 @@ public void testCloseStateManagerOnlyThrowsFirstExceptionWhenClean() throws IOEx\n     }\n \n     @Test\n-    public void testCloseStateManagerDirtyShallSwallowException() throws IOException {\n-        final LogCaptureAppender appender = LogCaptureAppender.createAndRegister();\n-\n+    public void testCloseStateManagerThrowsExceptionWhenDirty() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dad39b7e03f0098a4f4e4620b388e87770452bed"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzOTQyMDMxOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateManagerUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzo0NTo0NVrOGGEwUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzo0NTo0NVrOGGEwUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyMjU0Nw==", "bodyText": "Nice clean, now we catch the exception in the caller.", "url": "https://github.com/apache/kafka/pull/8478#discussion_r409022547", "createdAt": "2020-04-15T17:45:45Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateManagerUtil.java", "diffHunk": "@@ -92,49 +93,46 @@ static void registerStateStores(final Logger log,\n     static void closeStateManager(final Logger log,\n                                   final String logPrefix,\n                                   final boolean closeClean,\n-                                  final boolean wipeStateStore,\n+                                  final boolean eosEnabled,\n                                   final ProcessorStateManager stateMgr,\n                                   final StateDirectory stateDirectory,\n                                   final TaskType taskType) {\n-        if (closeClean && wipeStateStore) {\n-            throw new IllegalArgumentException(\"State store could not be wiped out during clean close\");\n-        }\n-\n-        ProcessorStateException exception = null;\n+        // if EOS is enabled, wipe out the whole state store for unclean close since it is now invalid\n+        final boolean wipeStateStore = !closeClean && eosEnabled;\n \n         final TaskId id = stateMgr.taskId();\n-        log.trace(\"Closing state manager for {}\", id);\n+        log.trace(\"Closing state manager for {} task {}\", taskType, id);\n \n+        final AtomicReference<ProcessorStateException> firstException = new AtomicReference<>(null);\n         try {\n-            stateMgr.close();\n-\n-            if (wipeStateStore) {\n-                // we can just delete the whole dir of the task, including the state store images and the checkpoint files,\n-                // and then we write an empty checkpoint file indicating that the previous close is graceful and we just\n-                // need to re-bootstrap the restoration from the beginning\n-                Utils.delete(stateMgr.baseDir());\n-            }\n-        } catch (final ProcessorStateException e) {\n-            exception = e;\n-        } catch (final IOException e) {\n-            throw new ProcessorStateException(\"Failed to wiping state stores for task \" + id, e);\n-        } finally {\n-            try {\n-                stateDirectory.unlock(id);\n-            } catch (final IOException e) {\n-                if (exception == null) {\n-                    exception = new ProcessorStateException(\n-                        String.format(\"%sFailed to release state dir lock\", logPrefix), e);\n+            if (stateDirectory.lock(id)) {\n+                try {\n+                    stateMgr.close();\n+\n+                    if (wipeStateStore) {\n+                        log.debug(\"Wiping state stores for {} task {}\", taskType, id);\n+                        // we can just delete the whole dir of the task, including the state store images and the checkpoint files,\n+                        // and then we write an empty checkpoint file indicating that the previous close is graceful and we just\n+                        // need to re-bootstrap the restoration from the beginning\n+                        Utils.delete(stateMgr.baseDir());\n+                    }\n+                } catch (final ProcessorStateException e) {\n+                    firstException.compareAndSet(null, e);\n+                } finally {\n+                    stateDirectory.unlock(id);\n                 }\n             }\n+        } catch (final IOException e) {\n+            final ProcessorStateException exception = new ProcessorStateException(\n+                String.format(\"%sFatal error while trying to close the state manager for task %s\", logPrefix, id), e\n+            );\n+            firstException.compareAndSet(null, exception);\n+\n         }\n \n+        final ProcessorStateException exception = firstException.get();\n         if (exception != null) {\n-            if (closeClean) {\n-                throw exception;\n-            } else {\n-                log.warn(\"Closing {} task {} uncleanly and swallows an exception\", taskType, id, exception);\n-            }\n+            throw exception;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dad39b7e03f0098a4f4e4620b388e87770452bed"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzOTQ1NDEwOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzo1NDo1OVrOGGFF7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzo1NDo1OVrOGGFF7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyODA3OA==", "bodyText": "nit: we can throw AssertionError here to indicate this should not happen.", "url": "https://github.com/apache/kafka/pull/8478#discussion_r409028078", "createdAt": "2020-04-15T17:54:59Z", "author": {"login": "guozhangwang"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java", "diffHunk": "@@ -319,9 +322,47 @@ public void testCloseStateManagerWithStateStoreWipeOutRethrowWrappedIOException(\n             ProcessorStateException.class, () -> StateManagerUtil.closeStateManager(logger,\n                 \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE));\n \n-        assertEquals(\"Failed to wiping state stores for task 0_0\", thrown.getMessage());\n         assertEquals(IOException.class, thrown.getCause().getClass());\n \n         ctrl.verify();\n     }\n+\n+    @Test\n+    public void shouldNotStateManagerIfUnableToLockTaskDirectory() throws IOException {\n+        expect(stateManager.taskId()).andReturn(taskId);\n+\n+        expect(stateDirectory.lock(taskId)).andReturn(false);\n+\n+        stateManager.close();\n+        expectLastCall().andThrow(new StreamsException(\"Should not be trying to close state you don't own!\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dad39b7e03f0098a4f4e4620b388e87770452bed"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzOTQ1NDc2OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzo1NTowOVrOGGFGWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzo1NTowOVrOGGFGWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyODE4Nw==", "bodyText": "nit: shouldNotClose...?", "url": "https://github.com/apache/kafka/pull/8478#discussion_r409028187", "createdAt": "2020-04-15T17:55:09Z", "author": {"login": "guozhangwang"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java", "diffHunk": "@@ -319,9 +322,47 @@ public void testCloseStateManagerWithStateStoreWipeOutRethrowWrappedIOException(\n             ProcessorStateException.class, () -> StateManagerUtil.closeStateManager(logger,\n                 \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE));\n \n-        assertEquals(\"Failed to wiping state stores for task 0_0\", thrown.getMessage());\n         assertEquals(IOException.class, thrown.getCause().getClass());\n \n         ctrl.verify();\n     }\n+\n+    @Test\n+    public void shouldNotStateManagerIfUnableToLockTaskDirectory() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dad39b7e03f0098a4f4e4620b388e87770452bed"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzOTQ3MTY4OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNzo1OTo1MlrOGGFRPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxODoyODoxN1rOGGGQww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAzMDk3Mg==", "bodyText": "nit: we can set eosEnabled to false since we set it to true in the next test?", "url": "https://github.com/apache/kafka/pull/8478#discussion_r409030972", "createdAt": "2020-04-15T17:59:52Z", "author": {"login": "guozhangwang"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java", "diffHunk": "@@ -319,9 +322,47 @@ public void testCloseStateManagerWithStateStoreWipeOutRethrowWrappedIOException(\n             ProcessorStateException.class, () -> StateManagerUtil.closeStateManager(logger,\n                 \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE));\n \n-        assertEquals(\"Failed to wiping state stores for task 0_0\", thrown.getMessage());\n         assertEquals(IOException.class, thrown.getCause().getClass());\n \n         ctrl.verify();\n     }\n+\n+    @Test\n+    public void shouldNotStateManagerIfUnableToLockTaskDirectory() throws IOException {\n+        expect(stateManager.taskId()).andReturn(taskId);\n+\n+        expect(stateDirectory.lock(taskId)).andReturn(false);\n+\n+        stateManager.close();\n+        expectLastCall().andThrow(new StreamsException(\"Should not be trying to close state you don't own!\"));\n+\n+        ctrl.checkOrder(true);\n+        ctrl.replay();\n+\n+        replayAll();\n+\n+        StateManagerUtil.closeStateManager(\n+            logger, \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dad39b7e03f0098a4f4e4620b388e87770452bed"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA0NzIzNQ==", "bodyText": "good call", "url": "https://github.com/apache/kafka/pull/8478#discussion_r409047235", "createdAt": "2020-04-15T18:28:17Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java", "diffHunk": "@@ -319,9 +322,47 @@ public void testCloseStateManagerWithStateStoreWipeOutRethrowWrappedIOException(\n             ProcessorStateException.class, () -> StateManagerUtil.closeStateManager(logger,\n                 \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE));\n \n-        assertEquals(\"Failed to wiping state stores for task 0_0\", thrown.getMessage());\n         assertEquals(IOException.class, thrown.getCause().getClass());\n \n         ctrl.verify();\n     }\n+\n+    @Test\n+    public void shouldNotStateManagerIfUnableToLockTaskDirectory() throws IOException {\n+        expect(stateManager.taskId()).andReturn(taskId);\n+\n+        expect(stateDirectory.lock(taskId)).andReturn(false);\n+\n+        stateManager.close();\n+        expectLastCall().andThrow(new StreamsException(\"Should not be trying to close state you don't own!\"));\n+\n+        ctrl.checkOrder(true);\n+        ctrl.replay();\n+\n+        replayAll();\n+\n+        StateManagerUtil.closeStateManager(\n+            logger, \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAzMDk3Mg=="}, "originalCommit": {"oid": "dad39b7e03f0098a4f4e4620b388e87770452bed"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzOTQ3Mzk0OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxODowMDozNFrOGGFSzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxODowMDozNFrOGGFSzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAzMTM3Mw==", "bodyText": "Ditto here, we can use AssertionError", "url": "https://github.com/apache/kafka/pull/8478#discussion_r409031373", "createdAt": "2020-04-15T18:00:34Z", "author": {"login": "guozhangwang"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StateManagerUtilTest.java", "diffHunk": "@@ -319,9 +322,47 @@ public void testCloseStateManagerWithStateStoreWipeOutRethrowWrappedIOException(\n             ProcessorStateException.class, () -> StateManagerUtil.closeStateManager(logger,\n                 \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE));\n \n-        assertEquals(\"Failed to wiping state stores for task 0_0\", thrown.getMessage());\n         assertEquals(IOException.class, thrown.getCause().getClass());\n \n         ctrl.verify();\n     }\n+\n+    @Test\n+    public void shouldNotStateManagerIfUnableToLockTaskDirectory() throws IOException {\n+        expect(stateManager.taskId()).andReturn(taskId);\n+\n+        expect(stateDirectory.lock(taskId)).andReturn(false);\n+\n+        stateManager.close();\n+        expectLastCall().andThrow(new StreamsException(\"Should not be trying to close state you don't own!\"));\n+\n+        ctrl.checkOrder(true);\n+        ctrl.replay();\n+\n+        replayAll();\n+\n+        StateManagerUtil.closeStateManager(\n+            logger, \"logPrefix:\", false, true, stateManager, stateDirectory, TaskType.ACTIVE);\n+    }\n+\n+    @Test\n+    public void shouldNotWipeStateStoresIfUnableToLockTaskDirectory() throws IOException {\n+        final File unknownFile = new File(\"/unknown/path\");\n+        expect(stateManager.taskId()).andReturn(taskId);\n+\n+        expect(stateDirectory.lock(taskId)).andReturn(false);\n+\n+        expect(stateManager.baseDir()).andReturn(unknownFile);\n+\n+        Utils.delete(unknownFile);\n+        expectLastCall().andThrow(new StreamsException(\"Should not be trying to wipe state you don't own!\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dad39b7e03f0098a4f4e4620b388e87770452bed"}, "originalPosition": 165}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2987, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}