{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyODAzNTg2", "number": 8724, "title": "KAFKA-10040; Make computing the PreferredReplicaImbalanceCount metric more efficient", "bodyText": "This PR changes the way PreferredReplicaImbalanceCount is computed. It moves from re-computing after the processing of each event in the controller to continuously maintaining the count.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-05-25T15:26:33Z", "url": "https://github.com/apache/kafka/pull/8724", "merged": true, "mergeCommit": {"oid": "7867c24a40ab0a8d1e7b0d9bcb7776d1335ad3ea"}, "closed": true, "closedAt": "2020-06-05T00:31:19Z", "author": {"login": "dajac"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABckxiX9gH2gAyNDIyODAzNTg2OmMyZmI4N2E5YWIzNzBmZTM4YWQ3YWUyOTQ5MjA0ZTg2NDFkY2ZlMzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcoA1odAFqTQyNDYzNjEyNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c2fb87a9ab370fe38ad7ae2949204e8641dcfe36", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/c2fb87a9ab370fe38ad7ae2949204e8641dcfe36", "committedDate": "2020-05-25T15:10:15Z", "message": "KAFKA-10040; Make computing the PreferredReplicaImbalanceCount metric more efficient"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2c9df960726243528b91c1a4aa8de1af713e464", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/f2c9df960726243528b91c1a4aa8de1af713e464", "committedDate": "2020-05-26T07:02:48Z", "message": "refactoring"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNTI5MzU0", "url": "https://github.com/apache/kafka/pull/8724#pullrequestreview-421529354", "createdAt": "2020-05-31T21:32:28Z", "commit": {"oid": "f2c9df960726243528b91c1a4aa8de1af713e464"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQyMTozMjoyOFrOGc7Yow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQyMTozMjoyOFrOGc7Yow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk4NjI3NQ==", "bodyText": "nit: I think this exact argument doesn't need to be an Option", "url": "https://github.com/apache/kafka/pull/8724#discussion_r432986275", "createdAt": "2020-05-31T21:32:28Z", "author": {"login": "stanislavkozlovski"}, "path": "core/src/main/scala/kafka/controller/ControllerContext.scala", "diffHunk": "@@ -391,6 +404,54 @@ class ControllerContext {\n     partitionsForTopic(topic).filter { partition => states.contains(partitionState(partition)) }.toSet\n   }\n \n+  def putLeadershipInfo(partition: TopicPartition, leaderIsrAndControllerEpoch: LeaderIsrAndControllerEpoch): Unit = {\n+    val previous = partitionLeadershipInfo.put(partition, leaderIsrAndControllerEpoch)\n+    val replicaAssignment = partitionFullReplicaAssignment(partition)\n+    updatePreferredReplicaImbalanceMetric(partition, Some(replicaAssignment), previous,\n+      Some(replicaAssignment), Some(leaderIsrAndControllerEpoch))\n+  }\n+\n+  private def updatePreferredReplicaImbalanceMetric(partition: TopicPartition,\n+                                                    oldReplicaAssignment: Option[ReplicaAssignment],\n+                                                    oldLeadershipInfo: Option[LeaderIsrAndControllerEpoch],\n+                                                    newReplicaAssignment: Option[ReplicaAssignment],", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c9df960726243528b91c1a4aa8de1af713e464"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMTU5Mzk3", "url": "https://github.com/apache/kafka/pull/8724#pullrequestreview-423159397", "createdAt": "2020-06-03T01:26:02Z", "commit": {"oid": "f2c9df960726243528b91c1a4aa8de1af713e464"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMToyNjowM1rOGeJGqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMTo0MDoxMFrOGeJTuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1OTYyNw==", "bodyText": "What about hasPreferredLeader?", "url": "https://github.com/apache/kafka/pull/8724#discussion_r434259627", "createdAt": "2020-06-03T01:26:03Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/controller/ControllerContext.scala", "diffHunk": "@@ -391,6 +404,54 @@ class ControllerContext {\n     partitionsForTopic(topic).filter { partition => states.contains(partitionState(partition)) }.toSet\n   }\n \n+  def putLeadershipInfo(partition: TopicPartition, leaderIsrAndControllerEpoch: LeaderIsrAndControllerEpoch): Unit = {\n+    val previous = partitionLeadershipInfo.put(partition, leaderIsrAndControllerEpoch)\n+    val replicaAssignment = partitionFullReplicaAssignment(partition)\n+    updatePreferredReplicaImbalanceMetric(partition, Some(replicaAssignment), previous,\n+      Some(replicaAssignment), Some(leaderIsrAndControllerEpoch))\n+  }\n+\n+  private def updatePreferredReplicaImbalanceMetric(partition: TopicPartition,\n+                                                    oldReplicaAssignment: Option[ReplicaAssignment],\n+                                                    oldLeadershipInfo: Option[LeaderIsrAndControllerEpoch],\n+                                                    newReplicaAssignment: Option[ReplicaAssignment],\n+                                                    newLeadershipInfo: Option[LeaderIsrAndControllerEpoch]): Unit = {\n+    if (!isTopicQueuedUpForDeletion(partition.topic)) {\n+      oldReplicaAssignment.foreach { replicaAssignment =>\n+        oldLeadershipInfo.foreach { leadershipInfo =>\n+          if (isReplicaImbalance(replicaAssignment, leadershipInfo))\n+            preferredReplicaImbalanceCount -= 1\n+        }\n+      }\n+\n+      newReplicaAssignment.foreach { replicaAssignment =>\n+        newLeadershipInfo.foreach { leadershipInfo =>\n+          if (isReplicaImbalance(replicaAssignment, leadershipInfo))\n+            preferredReplicaImbalanceCount += 1\n+        }\n+      }\n+    }\n+  }\n+\n+  private def cleanPreferredReplicaImbalanceMetric(topic: String): Unit = {\n+    partitionAssignments.getOrElse(topic, mutable.Map.empty).foreach { case (partition, replicaAssignment) =>\n+      partitionLeadershipInfo.get(new TopicPartition(topic, partition)).foreach { leadershipInfo =>\n+        if (isReplicaImbalance(replicaAssignment, leadershipInfo))\n+          preferredReplicaImbalanceCount -= 1\n+      }\n+    }\n+  }\n+\n+  private def isReplicaImbalance(replicaAssignment: ReplicaAssignment,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c9df960726243528b91c1a4aa8de1af713e464"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2MTc3Mg==", "bodyText": "Not something to change here, but it's a little curious that we only do this when a reassignment is in progress. I'm not sure it's useful to distinguish that case as opposed to a broker that is catching up after a restart. If the preferred leader is not in the ISR, then we can't elect it anyway. Seems like it might be more useful if this metric captured the \"eligible imbalance\".", "url": "https://github.com/apache/kafka/pull/8724#discussion_r434261772", "createdAt": "2020-06-03T01:34:56Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/controller/ControllerContext.scala", "diffHunk": "@@ -391,6 +404,54 @@ class ControllerContext {\n     partitionsForTopic(topic).filter { partition => states.contains(partitionState(partition)) }.toSet\n   }\n \n+  def putLeadershipInfo(partition: TopicPartition, leaderIsrAndControllerEpoch: LeaderIsrAndControllerEpoch): Unit = {\n+    val previous = partitionLeadershipInfo.put(partition, leaderIsrAndControllerEpoch)\n+    val replicaAssignment = partitionFullReplicaAssignment(partition)\n+    updatePreferredReplicaImbalanceMetric(partition, Some(replicaAssignment), previous,\n+      Some(replicaAssignment), Some(leaderIsrAndControllerEpoch))\n+  }\n+\n+  private def updatePreferredReplicaImbalanceMetric(partition: TopicPartition,\n+                                                    oldReplicaAssignment: Option[ReplicaAssignment],\n+                                                    oldLeadershipInfo: Option[LeaderIsrAndControllerEpoch],\n+                                                    newReplicaAssignment: Option[ReplicaAssignment],\n+                                                    newLeadershipInfo: Option[LeaderIsrAndControllerEpoch]): Unit = {\n+    if (!isTopicQueuedUpForDeletion(partition.topic)) {\n+      oldReplicaAssignment.foreach { replicaAssignment =>\n+        oldLeadershipInfo.foreach { leadershipInfo =>\n+          if (isReplicaImbalance(replicaAssignment, leadershipInfo))\n+            preferredReplicaImbalanceCount -= 1\n+        }\n+      }\n+\n+      newReplicaAssignment.foreach { replicaAssignment =>\n+        newLeadershipInfo.foreach { leadershipInfo =>\n+          if (isReplicaImbalance(replicaAssignment, leadershipInfo))\n+            preferredReplicaImbalanceCount += 1\n+        }\n+      }\n+    }\n+  }\n+\n+  private def cleanPreferredReplicaImbalanceMetric(topic: String): Unit = {\n+    partitionAssignments.getOrElse(topic, mutable.Map.empty).foreach { case (partition, replicaAssignment) =>\n+      partitionLeadershipInfo.get(new TopicPartition(topic, partition)).foreach { leadershipInfo =>\n+        if (isReplicaImbalance(replicaAssignment, leadershipInfo))\n+          preferredReplicaImbalanceCount -= 1\n+      }\n+    }\n+  }\n+\n+  private def isReplicaImbalance(replicaAssignment: ReplicaAssignment,\n+                                 leadershipInfo: LeaderIsrAndControllerEpoch): Boolean = {\n+    val preferredReplica = replicaAssignment.replicas.head\n+    if (replicaAssignment.isBeingReassigned && replicaAssignment.addingReplicas.contains(preferredReplica))\n+      // reassigning partitions are not counted as imbalanced until the new replica joins the ISR (completes reassignment)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c9df960726243528b91c1a4aa8de1af713e464"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2MjUzOQ==", "bodyText": "Wonder if we should consider making partitionLeadershipInfo private so that we do not mistakenly invoke put in the future directly.", "url": "https://github.com/apache/kafka/pull/8724#discussion_r434262539", "createdAt": "2020-06-03T01:38:18Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/controller/ControllerContext.scala", "diffHunk": "@@ -391,6 +404,54 @@ class ControllerContext {\n     partitionsForTopic(topic).filter { partition => states.contains(partitionState(partition)) }.toSet\n   }\n \n+  def putLeadershipInfo(partition: TopicPartition, leaderIsrAndControllerEpoch: LeaderIsrAndControllerEpoch): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c9df960726243528b91c1a4aa8de1af713e464"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2Mjk3MQ==", "bodyText": "Ouch. So the main issue is that we were doing this full iteration over all partitions on every controller event.", "url": "https://github.com/apache/kafka/pull/8724#discussion_r434262971", "createdAt": "2020-06-03T01:40:10Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/controller/KafkaController.scala", "diffHunk": "@@ -1254,23 +1254,7 @@ class KafkaController(val config: KafkaConfig,\n       if (!isActive) {\n         0\n       } else {\n-        controllerContext.allPartitions.count { topicPartition =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2c9df960726243528b91c1a4aa8de1af713e464"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "303bb10bf7ddbea779a0bacab88267f9a6e79afc", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/303bb10bf7ddbea779a0bacab88267f9a6e79afc", "committedDate": "2020-06-03T07:16:01Z", "message": "refactor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c86178f5ece91fe815be17fc9ea9ffada19e99b", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/8c86178f5ece91fe815be17fc9ea9ffada19e99b", "committedDate": "2020-06-03T07:46:03Z", "message": "cleanuo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNzMzMzUy", "url": "https://github.com/apache/kafka/pull/8724#pullrequestreview-423733352", "createdAt": "2020-06-03T16:32:48Z", "commit": {"oid": "8c86178f5ece91fe815be17fc9ea9ffada19e99b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNjozMjo0OFrOGekGxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNjo0NjowMlrOGekoSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcwMjAyMw==", "bodyText": "nit: partitionLeadersOnBroker?", "url": "https://github.com/apache/kafka/pull/8724#discussion_r434702023", "createdAt": "2020-06-03T16:32:48Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/controller/ControllerContext.scala", "diffHunk": "@@ -391,6 +404,90 @@ class ControllerContext {\n     partitionsForTopic(topic).filter { partition => states.contains(partitionState(partition)) }.toSet\n   }\n \n+  def putPartitionLeadershipInfo(partition: TopicPartition,\n+                                 leaderIsrAndControllerEpoch: LeaderIsrAndControllerEpoch): Unit = {\n+    val previous = partitionLeadershipInfo.put(partition, leaderIsrAndControllerEpoch)\n+    val replicaAssignment = partitionFullReplicaAssignment(partition)\n+    updatePreferredReplicaImbalanceMetric(partition, Some(replicaAssignment), previous,\n+      Some(replicaAssignment), Some(leaderIsrAndControllerEpoch))\n+  }\n+\n+  def partitionLeadershipInfo(partition: TopicPartition): Option[LeaderIsrAndControllerEpoch] = {\n+    partitionLeadershipInfo.get(partition)\n+  }\n+\n+  def partitionsLeadershipInfo(): Iterable[(TopicPartition, LeaderIsrAndControllerEpoch)] = {\n+    partitionLeadershipInfo\n+  }\n+\n+  def partitionsWithLeaders(): Set[TopicPartition] = {\n+    partitionLeadershipInfo.keySet\n+  }\n+\n+  def partitionsWithoutLeaders(): Set[TopicPartition] = {\n+    partitionLeadershipInfo.filter { case (topicPartition, leaderIsrAndControllerEpoch) =>\n+      !isReplicaOnline(leaderIsrAndControllerEpoch.leaderAndIsr.leader, topicPartition) &&\n+        !isTopicQueuedUpForDeletion(topicPartition.topic)\n+    }.keySet\n+  }\n+\n+  def partitionLeadsOnBroker(brokerId: Int): Set[TopicPartition] = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c86178f5ece91fe815be17fc9ea9ffada19e99b"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcxMDYwMg==", "bodyText": "This definition seems inconsistent with partitionsWithoutLeaders. I think you're just trying to preserve the existing logic. It might make sense to use a different name to avoid the apparent inconsistency? Maybe we could change partitionsWithoutLeaders to be partitionsWithOfflineLeaders or something like that. Looking at the caller, it looks like it would be reasonable to exclude topics which are being queued for deletion in both cases, but we could change that separately if you think it is risky.", "url": "https://github.com/apache/kafka/pull/8724#discussion_r434710602", "createdAt": "2020-06-03T16:46:02Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/controller/ControllerContext.scala", "diffHunk": "@@ -391,6 +404,90 @@ class ControllerContext {\n     partitionsForTopic(topic).filter { partition => states.contains(partitionState(partition)) }.toSet\n   }\n \n+  def putPartitionLeadershipInfo(partition: TopicPartition,\n+                                 leaderIsrAndControllerEpoch: LeaderIsrAndControllerEpoch): Unit = {\n+    val previous = partitionLeadershipInfo.put(partition, leaderIsrAndControllerEpoch)\n+    val replicaAssignment = partitionFullReplicaAssignment(partition)\n+    updatePreferredReplicaImbalanceMetric(partition, Some(replicaAssignment), previous,\n+      Some(replicaAssignment), Some(leaderIsrAndControllerEpoch))\n+  }\n+\n+  def partitionLeadershipInfo(partition: TopicPartition): Option[LeaderIsrAndControllerEpoch] = {\n+    partitionLeadershipInfo.get(partition)\n+  }\n+\n+  def partitionsLeadershipInfo(): Iterable[(TopicPartition, LeaderIsrAndControllerEpoch)] = {\n+    partitionLeadershipInfo\n+  }\n+\n+  def partitionsWithLeaders(): Set[TopicPartition] = {\n+    partitionLeadershipInfo.keySet", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c86178f5ece91fe815be17fc9ea9ffada19e99b"}, "originalPosition": 87}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f016427bfc7a46f3cd5f2135ab56cccf1be176b", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/4f016427bfc7a46f3cd5f2135ab56cccf1be176b", "committedDate": "2020-06-04T08:48:06Z", "message": "address review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NjM2MTI2", "url": "https://github.com/apache/kafka/pull/8724#pullrequestreview-424636126", "createdAt": "2020-06-04T16:41:38Z", "commit": {"oid": "4f016427bfc7a46f3cd5f2135ab56cccf1be176b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1174, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}