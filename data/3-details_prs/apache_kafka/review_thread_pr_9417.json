{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxODYwNzk2", "number": 9417, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMjoyODo1NVrOEuehAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwNzo0NDoyNlrOEvL1OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MTY5OTIzOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/ClientQuotaManager.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMjoyODo1NVrOHi5_cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMjoyODo1NVrOHi5_cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM2Mzc2Mg==", "bodyText": "While this works, I wonder if this is the right way to overcome the issue. My concern is that there are other read paths which remain unprotected so we are not consistent. I would rather prefer to update the test as you suggested.", "url": "https://github.com/apache/kafka/pull/9417#discussion_r506363762", "createdAt": "2020-10-16T12:28:55Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/ClientQuotaManager.scala", "diffHunk": "@@ -360,8 +360,14 @@ class ClientQuotaManager(private val config: ClientQuotaManagerConfig,\n    * Note: this method is expensive, it is meant to be used by tests only\n    */\n   def quota(userPrincipal: KafkaPrincipal, clientId: String): Quota = {\n-    val metricTags = quotaCallback.quotaMetricTags(clientQuotaType, userPrincipal, clientId)\n-    Quota.upperBound(quotaLimit(metricTags))\n+    // acquire read lock to ensure that both quota limit and metric config are updated atomically\n+    lock.readLock().lock()\n+    try {\n+      val metricTags = quotaCallback.quotaMetricTags(clientQuotaType, userPrincipal, clientId)\n+      Quota.upperBound(quotaLimit(metricTags))\n+    } finally {\n+      lock.readLock().unlock()\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3OTEyMzc2OnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/server/ControllerMutationQuotaTest.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwNzo0NDoyNlrOHkBmPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwNzo0NDoyNlrOHkBmPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzUzNjk1Ng==", "bodyText": "nit: Could we use DEFAULT_MAX_WAIT_MS (defined in o.a.k.t.TestUtils) here?", "url": "https://github.com/apache/kafka/pull/9417#discussion_r507536956", "createdAt": "2020-10-19T07:44:26Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/server/ControllerMutationQuotaTest.scala", "diffHunk": "@@ -381,16 +381,18 @@ class ControllerMutationQuotaTest extends BaseRequestTest {\n     Option(servers.head.metrics.metric(metricName))\n   }\n \n-  private def verifyQuotaMetric(user: String, expectedQuota: Double): Unit = {\n-    quotaMetric(user) match {\n-      case Some(metric) =>\n-        val config = metric.config()\n-        assertEquals(expectedQuota, config.quota().bound(), 0.1)\n-        assertEquals(ControllerQuotaSamples, config.samples())\n-        assertEquals(ControllerQuotaWindowSizeSeconds * 1000, config.timeWindowMs())\n-\n-      case None =>\n-        fail(s\"Quota metric of $user is not defined\")\n+  private def waitQuotaMetric(user: String, expectedQuota: Double): Unit = {\n+    TestUtils.retry(200) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1755, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}