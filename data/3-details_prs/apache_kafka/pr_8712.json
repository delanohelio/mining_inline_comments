{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxODM3MDM3", "number": 8712, "title": " KAFKA-10006: Don't create internal topics when LeaderNotAvailableException", "bodyText": "Separate the exception handler for LeaderNotAvailableException and UnknownTopicOrPartitionException\nFor UnknownTopicOrPartitionException, keep as is (i.e. take the topic as not existed)\nFor LeaderNotAvailableException, log with correct message, and keep retries until the old leader or new leader become available, or running out of retries\n3.1. add a set leaderNotAvailableTopics, to keep the topics that has LeaderNotAvailableException\n3.2. Before trying to add to topicsToCreate set, check if the topicName is in the leaderNotAvailableTopics, if yes, then don't add (i.e. don't create this topic b/c its leader currently is not available)\n3.3. When running out of retries, throw StreamsException with correct message\nadd tests\n\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-05-22T10:16:05Z", "url": "https://github.com/apache/kafka/pull/8712", "merged": true, "mergeCommit": {"oid": "cf1ebcbbbde0430663afd20d4f9753583ed35d81"}, "closed": true, "closedAt": "2020-07-02T20:57:38Z", "author": {"login": "showuon"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcjuj_1gH2gAyNDIxODM3MDM3OjZiMDFlY2RkOGZhMjJkODEyYjZmNjU5MDE0NGM3MzNiNDNlODcwNjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcw3aFZgFqTQ0MTM0NzQ0Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6b01ecdd8fa22d812b6f6590144c733b43e87060", "author": {"user": {"login": "showuon", "name": "Luke Chen"}}, "url": "https://github.com/apache/kafka/commit/6b01ecdd8fa22d812b6f6590144c733b43e87060", "committedDate": "2020-05-22T09:08:23Z", "message": "KAFKA-10006: do not attempt to create internal topics if got LeaderNotAvailableException"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3fb9fdc1239d14d6b2eb9a33224f23e5ee7f052", "author": {"user": {"login": "showuon", "name": "Luke Chen"}}, "url": "https://github.com/apache/kafka/commit/e3fb9fdc1239d14d6b2eb9a33224f23e5ee7f052", "committedDate": "2020-05-22T10:12:46Z", "message": "KAFKA-10006: add tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTUwNjg1", "url": "https://github.com/apache/kafka/pull/8712#pullrequestreview-416950685", "createdAt": "2020-05-22T14:22:30Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDoyMjozMFrOGZY9-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDoyMjozMFrOGZY9-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI3NjY2NA==", "bodyText": "the log should put remainingRetries since it's logging with {} retries left", "url": "https://github.com/apache/kafka/pull/8712#discussion_r429276664", "createdAt": "2020-05-22T14:22:30Z", "author": {"login": "showuon"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -157,16 +161,16 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n             }\n \n \n-            if (!topicsNotReady.isEmpty()) {\n-                log.info(\"Topics {} can not be made ready with {} retries left\", topicsNotReady, retries);\n+            if (isNeedRetry(topicsNotReady)) {\n+                log.info(\"Topics {} can not be made ready with {} retries left\", topicsNotReady, remainingRetries);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "608e52b86d40de8b4031894d7a513869a65dd6bb", "author": {"user": {"login": "showuon", "name": "Luke Chen"}}, "url": "https://github.com/apache/kafka/commit/608e52b86d40de8b4031894d7a513869a65dd6bb", "committedDate": "2020-05-22T14:28:56Z", "message": "KAFKA-10006: refactor"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "608e52b86d40de8b4031894d7a513869a65dd6bb", "author": {"user": {"login": "showuon", "name": "Luke Chen"}}, "url": "https://github.com/apache/kafka/commit/608e52b86d40de8b4031894d7a513869a65dd6bb", "committedDate": "2020-05-22T14:28:56Z", "message": "KAFKA-10006: refactor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTY1MzU2", "url": "https://github.com/apache/kafka/pull/8712#pullrequestreview-416965356", "createdAt": "2020-05-22T14:41:48Z", "commit": {"oid": "608e52b86d40de8b4031894d7a513869a65dd6bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo0MTo0OFrOGZZsAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo0MTo0OFrOGZZsAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4ODQ0OQ==", "bodyText": "Try to simulate the LeaderNotAvailableException in the MockAdminClient, if the topic name isLeaderNotAvailableTopic.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r429288449", "createdAt": "2020-05-22T14:41:48Z", "author": {"login": "showuon"}, "path": "clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java", "diffHunk": "@@ -330,6 +331,12 @@ synchronized public DescribeTopicsResult describeTopics(Collection<String> topic\n                 future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                 topicDescriptions.put(requestedTopic, future);\n             }\n+            // try to simulate the leader not available situation when topic name is \"LeaderNotAvailableTopic\"\n+            if (requestedTopic.equals(\"LeaderNotAvailableTopic\")) {\n+                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n+                future.completeExceptionally(new LeaderNotAvailableException(\"The leader of Topic \" + requestedTopic + \" is not available.\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "608e52b86d40de8b4031894d7a513869a65dd6bb"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2OTY2NTc4", "url": "https://github.com/apache/kafka/pull/8712#pullrequestreview-416966578", "createdAt": "2020-05-22T14:43:20Z", "commit": {"oid": "608e52b86d40de8b4031894d7a513869a65dd6bb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo0MzoyMFrOGZZvpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo0MzoyMFrOGZZvpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4OTM4MA==", "bodyText": "If there's topic with LeaderNotAvailableException, we also need to retry.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r429289380", "createdAt": "2020-05-22T14:43:20Z", "author": {"login": "showuon"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -247,11 +261,19 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n                     log.error(errorMsg);\n                     throw new StreamsException(errorMsg);\n                 }\n-            } else {\n+            } else if (!needRetryTopics.contains(topicName)) {\n                 topicsToCreate.add(topicName);\n             }\n         }\n \n         return topicsToCreate;\n     }\n+\n+    private boolean isNeedRetry(final Set<String> topicsNotReady) {\n+        return !topicsNotReady.isEmpty() || hasNeedRetryTopic();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "608e52b86d40de8b4031894d7a513869a65dd6bb"}, "originalPosition": 104}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6", "author": {"user": {"login": "showuon", "name": "Luke Chen"}}, "url": "https://github.com/apache/kafka/commit/ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6", "committedDate": "2020-05-25T02:25:11Z", "message": "KAFKA-10006: refactor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NzUzMDI5", "url": "https://github.com/apache/kafka/pull/8712#pullrequestreview-425753029", "createdAt": "2020-06-06T16:45:15Z", "commit": {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNjo0NToxNVrOGgElfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNzowMjo0MFrOGgEqkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mjc1MQ==", "bodyText": "This should be declared final.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436282751", "createdAt": "2020-06-06T16:45:15Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -59,6 +59,9 @@ private InternalAdminClientConfig(final Map<?, ?> props) {\n \n     private final int retries;\n     private final long retryBackOffMs;\n+    private int remainingRetries;\n+\n+    private HashSet<String> leaderNotAvailableTopics = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjkyMw==", "bodyText": "This contains check is unnecessary.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436282923", "createdAt": "2020-06-06T16:47:21Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -195,20 +198,30 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n             final String topicName = topicFuture.getKey();\n             try {\n                 final TopicDescription topicDescription = topicFuture.getValue().get();\n-                existedTopicPartition.put(\n-                    topicFuture.getKey(),\n-                    topicDescription.partitions().size());\n+                existedTopicPartition.put(topicName, topicDescription.partitions().size());\n+                if (leaderNotAvailableTopics.contains(topicName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MzQ3Mw==", "bodyText": "This is a personal preference, but I think we should not attempt to include a temporal variable as part of the class struct. We could change the internal function signatures to pass around remainingRetries (like validateTopics) instead.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436283473", "createdAt": "2020-06-06T16:54:20Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -100,11 +103,11 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         // have existed with the expected number of partitions, or some create topic returns fatal errors.\n         log.debug(\"Starting to validate internal topics {} in partition assignor.\", topics);\n \n-        int remainingRetries = retries;\n+        remainingRetries = retries;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mzc0NQ==", "bodyText": "Similar to this struct, it doesn't make sense to have a non-empty leaderNotAvailableTopics after each call to makeReady, I would prefer building it as local variable, cc @ableegoldman", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436283745", "createdAt": "2020-06-06T16:58:02Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -59,6 +59,9 @@ private InternalAdminClientConfig(final Map<?, ?> props) {\n \n     private final int retries;\n     private final long retryBackOffMs;\n+    private int remainingRetries;\n+\n+    private HashSet<String> leaderNotAvailableTopics = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mjc1MQ=="}, "originalCommit": {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mzk2OQ==", "bodyText": "This workaround is very hard to be found by other developers, as a minimum we should define a constant and make it part of MockAdminClient class", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436283969", "createdAt": "2020-06-06T17:01:35Z", "author": {"login": "abbccdda"}, "path": "clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java", "diffHunk": "@@ -330,6 +331,12 @@ synchronized public DescribeTopicsResult describeTopics(Collection<String> topic\n                 future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                 topicDescriptions.put(requestedTopic, future);\n             }\n+            // try to simulate the leader not available situation when topic name is \"LeaderNotAvailableTopic\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDA0OQ==", "bodyText": "Testing against log message is error-prone and hard to maintain, I think just making sure the thrown exception type is expected should be sufficient.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436284049", "createdAt": "2020-06-06T17:02:40Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,49 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldLogWhenTopicLeaderNotAvailableAndThrowException() {\n+        final String topicLeaderNotAvailable = \"LeaderNotAvailableTopic\";\n+        mockAdminClient.addTopic(\n+            false,\n+            topicLeaderNotAvailable,\n+            Collections.singletonList(new TopicPartitionInfo(0, broker1, cluster, Collections.emptyList())),\n+            null);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(topicLeaderNotAvailable, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(topicLeaderNotAvailable, internalTopicConfig);\n+\n+        LogCaptureAppender.setClassLoggerToDebug(InternalTopicManager.class);\n+        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister(InternalTopicManager.class)) {\n+            final StreamsException exception = assertThrows(\n+                StreamsException.class,\n+                () -> internalTopicManager.makeReady(topicConfigMap));\n+\n+            final String expectedMessage = \"Could not create topics after 1 retries. This can happen if the Kafka cluster is temporary not available\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f015fa945537b73725b48fd2554dc1327a41a80", "author": {"user": {"login": "showuon", "name": "Luke Chen"}}, "url": "https://github.com/apache/kafka/commit/2f015fa945537b73725b48fd2554dc1327a41a80", "committedDate": "2020-06-08T03:16:27Z", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into KAFKA-10006"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "0567ecbc82c01b0c6e596fe5c28918f3b530a263", "author": {"user": {"login": "showuon", "name": "Luke Chen"}}, "url": "https://github.com/apache/kafka/commit/0567ecbc82c01b0c6e596fe5c28918f3b530a263", "committedDate": "2020-06-08T06:18:01Z", "message": "KAFKA-10006: address reviewer's comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "0567ecbc82c01b0c6e596fe5c28918f3b530a263", "author": {"user": {"login": "showuon", "name": "Luke Chen"}}, "url": "https://github.com/apache/kafka/commit/0567ecbc82c01b0c6e596fe5c28918f3b530a263", "committedDate": "2020-06-08T06:18:01Z", "message": "KAFKA-10006: address reviewer's comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MjE3MDk4", "url": "https://github.com/apache/kafka/pull/8712#pullrequestreview-436217098", "createdAt": "2020-06-23T23:01:47Z", "commit": {"oid": "0567ecbc82c01b0c6e596fe5c28918f3b530a263"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMzowMTo0N1rOGn9cgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMzowODozMlrOGn9lGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NDM2OA==", "bodyText": "Is it possible to use EasyMock instead of adding this to the actual MockAdminClient? I know it's kind of a pain to set up but I think it'll make the test a lot more clear. I did something similar in StreamsPartitionAssignorTest to mock the results of the listOffsets request", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444554368", "createdAt": "2020-06-23T23:01:47Z", "author": {"login": "ableegoldman"}, "path": "clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java", "diffHunk": "@@ -330,6 +331,12 @@ synchronized public DescribeTopicsResult describeTopics(Collection<String> topic\n                 future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                 topicDescriptions.put(requestedTopic, future);\n             }\n+            // try to simulate the leader not available situation when topic name is \"LeaderNotAvailableTopic\"\n+            if (requestedTopic.equals(\"LeaderNotAvailableTopic\")) {\n+                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n+                future.completeExceptionally(new LeaderNotAvailableException(\"The leader of Topic \" + requestedTopic + \" is not available.\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4ODQ0OQ=="}, "originalCommit": {"oid": "608e52b86d40de8b4031894d7a513869a65dd6bb"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NTcyNA==", "bodyText": "Can we give this a more descriptive name? It might be obvious to you, but I think someone just looking at this code for the first time would not get that this actually means topics that may or may not already exist.\nThat said, I'm struggling to think of a good alternative...maybe possiblyCreatedTopics or unknownTopics...any better ideas?", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444555724", "createdAt": "2020-06-23T23:05:58Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -98,9 +98,10 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         int remainingRetries = retries;\n         Set<String> topicsNotReady = new HashSet<>(topics.keySet());\n         final Set<String> newlyCreatedTopics = new HashSet<>();\n+        final HashSet<String> leaderNotAvailableTopics = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0567ecbc82c01b0c6e596fe5c28918f3b530a263"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NTg5NQ==", "bodyText": "Good catch", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444555895", "createdAt": "2020-06-23T23:06:27Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -157,16 +161,16 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n             }\n \n \n-            if (!topicsNotReady.isEmpty()) {\n-                log.info(\"Topics {} can not be made ready with {} retries left\", topicsNotReady, retries);\n+            if (isNeedRetry(topicsNotReady)) {\n+                log.info(\"Topics {} can not be made ready with {} retries left\", topicsNotReady, remainingRetries);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI3NjY2NA=="}, "originalCommit": null, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NjU2OA==", "bodyText": "Can we just use !isEmpty for both sets?", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444556568", "createdAt": "2020-06-23T23:08:32Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -242,11 +256,16 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n                     log.error(errorMsg);\n                     throw new StreamsException(errorMsg);\n                 }\n-            } else {\n+            } else if (!leaderNotAvailableTopics.contains(topicName)) {\n                 topicsToCreate.add(topicName);\n             }\n         }\n \n         return topicsToCreate;\n     }\n+\n+    private boolean shouldRetry(final Set<String> topicsNotReady, final HashSet<String> leaderNotAvailableTopics) {\n+        // If there's topic with LeaderNotAvailableException, we still need retry\n+        return !topicsNotReady.isEmpty() || leaderNotAvailableTopics.size() > 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0567ecbc82c01b0c6e596fe5c28918f3b530a263"}, "originalPosition": 114}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0", "author": {"user": {"login": "showuon", "name": "Luke Chen"}}, "url": "https://github.com/apache/kafka/commit/f378c34d10c57d796412ac946f867e5787f93af0", "committedDate": "2020-06-24T14:07:48Z", "message": "KAFKA-10006: use EasyMock to rewrite the test, and remove the unneeded hack in MockAdminClient"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2ODY1MzYz", "url": "https://github.com/apache/kafka/pull/8712#pullrequestreview-436865363", "createdAt": "2020-06-24T17:37:51Z", "commit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2OTYwMDY3", "url": "https://github.com/apache/kafka/pull/8712#pullrequestreview-436960067", "createdAt": "2020-06-24T19:54:53Z", "commit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTo1NDo1M1rOGog5XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwMjo1MjowOVrOGopqjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNTE5Ng==", "bodyText": "s/HashSet/Set?", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445135196", "createdAt": "2020-06-24T19:54:53Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -98,9 +98,10 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         int remainingRetries = retries;\n         Set<String> topicsNotReady = new HashSet<>(topics.keySet());\n         final Set<String> newlyCreatedTopics = new HashSet<>();\n+        final HashSet<String> tempUnknownTopics = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNjE3Nw==", "bodyText": "Could be merged with above else", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445136177", "createdAt": "2020-06-24T19:56:44Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -243,10 +259,18 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n                     throw new StreamsException(errorMsg);\n                 }\n             } else {\n-                topicsToCreate.add(topicName);\n+                // for the tempUnknownTopics, we'll check again later if retries > 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNzE0Ng==", "bodyText": "Use 4 space format to align with other tests.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445137146", "createdAt": "2020-06-24T19:58:25Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +291,41 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldLogWhenTopicLeaderNotAvailableAndThrowException() {\n+        final String leaderNotAvailableTopic = \"LeaderNotAvailableTopic\";\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+\n+        // simulate describeTopics got LeaderNotAvailableException\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+                .andReturn(new MockDescribeTopicsResult(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3NzU0OQ==", "bodyText": "We could just pass in a boolean here to indicate whether there are remaining retries", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445277549", "createdAt": "2020-06-25T02:46:40Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -179,31 +180,43 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n      * Topics that were not able to get its description will simply not be returned\n      */\n     // visible for testing\n-    protected Map<String, Integer> getNumPartitions(final Set<String> topics) {\n-        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", topics);\n-\n-        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(topics);\n+    protected Map<String, Integer> getNumPartitions(final Set<String> topics,\n+                                                    final HashSet<String> tempUnknownTopics,\n+                                                    final int remainingRetries) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3Nzk2MQ==", "bodyText": "Could reduce the if-else block as:\nif (remainingRetries <= 0) {\n  // run out of retries, throw exception directly \n  throw new StreamsException(\n    String.format(\"The leader of the Topic %s is not available after %d retries.\", topicName, retries), cause);\n }\n log.debug(\"The leader of the Topic {} is not available, with {} retries left.\\n\" +\n   \"Error message was: {}\", topicName, remainingRetries, cause.toString());", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445277961", "createdAt": "2020-06-25T02:48:20Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -179,31 +180,43 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n      * Topics that were not able to get its description will simply not be returned\n      */\n     // visible for testing\n-    protected Map<String, Integer> getNumPartitions(final Set<String> topics) {\n-        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", topics);\n-\n-        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(topics);\n+    protected Map<String, Integer> getNumPartitions(final Set<String> topics,\n+                                                    final HashSet<String> tempUnknownTopics,\n+                                                    final int remainingRetries) {\n+        final Set<String> allTopicsToDescribe = new HashSet<>(topics);\n+        allTopicsToDescribe.addAll(tempUnknownTopics);\n+        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", allTopicsToDescribe);\n+\n+        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(allTopicsToDescribe);\n         final Map<String, KafkaFuture<TopicDescription>> futures = describeTopicsResult.values();\n \n         final Map<String, Integer> existedTopicPartition = new HashMap<>();\n         for (final Map.Entry<String, KafkaFuture<TopicDescription>> topicFuture : futures.entrySet()) {\n             final String topicName = topicFuture.getKey();\n             try {\n                 final TopicDescription topicDescription = topicFuture.getValue().get();\n-                existedTopicPartition.put(\n-                    topicFuture.getKey(),\n-                    topicDescription.partitions().size());\n+                existedTopicPartition.put(topicName, topicDescription.partitions().size());\n+                tempUnknownTopics.remove(topicName);\n             } catch (final InterruptedException fatalException) {\n                 // this should not happen; if it ever happens it indicate a bug\n                 Thread.currentThread().interrupt();\n                 log.error(INTERRUPTED_ERROR_MESSAGE, fatalException);\n                 throw new IllegalStateException(INTERRUPTED_ERROR_MESSAGE, fatalException);\n             } catch (final ExecutionException couldNotDescribeTopicException) {\n                 final Throwable cause = couldNotDescribeTopicException.getCause();\n-                if (cause instanceof UnknownTopicOrPartitionException ||\n-                    cause instanceof LeaderNotAvailableException) {\n-                    // This topic didn't exist or leader is not known yet, proceed to try to create it\n-                    log.debug(\"Topic {} is unknown or not found, hence not existed yet: {}\", topicName, cause.toString());\n+                if (cause instanceof UnknownTopicOrPartitionException) {\n+                    // This topic didn't exist, proceed to try to create it\n+                    log.debug(\"Topic {} is unknown or not found, hence not existed yet.\\n\" +\n+                        \"Error message was: {}\", topicName, cause.toString());\n+                } else if (cause instanceof LeaderNotAvailableException) {\n+                    tempUnknownTopics.add(topicName);\n+                    if (remainingRetries > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODQ1Nw==", "bodyText": "Why do we need allTopicsToDescribe? It seems only queried once locally.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445278457", "createdAt": "2020-06-25T02:50:25Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -179,31 +180,43 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n      * Topics that were not able to get its description will simply not be returned\n      */\n     // visible for testing\n-    protected Map<String, Integer> getNumPartitions(final Set<String> topics) {\n-        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", topics);\n-\n-        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(topics);\n+    protected Map<String, Integer> getNumPartitions(final Set<String> topics,\n+                                                    final HashSet<String> tempUnknownTopics,\n+                                                    final int remainingRetries) {\n+        final Set<String> allTopicsToDescribe = new HashSet<>(topics);\n+        allTopicsToDescribe.addAll(tempUnknownTopics);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODY2Mg==", "bodyText": "Similar here, we could reduce to Set", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445278662", "createdAt": "2020-06-25T02:51:13Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -218,13 +231,16 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n     /**\n      * Check the existing topics to have correct number of partitions; and return the remaining topics that needs to be created\n      */\n-    private Set<String> validateTopics(final Set<String> topicsToValidate, final Map<String, InternalTopicConfig> topicsMap) {\n+    private Set<String> validateTopics(final Set<String> topicsToValidate,\n+                                       final Map<String, InternalTopicConfig> topicsMap,\n+                                       final HashSet<String> tempUnknownTopics,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODg2Mw==", "bodyText": "Could use Collections.emptySet() if reduced to Set", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445278863", "createdAt": "2020-06-25T02:52:09Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -108,7 +111,8 @@ public void shouldReturnCorrectPartitionCounts() {\n             topic,\n             Collections.singletonList(new TopicPartitionInfo(0, broker1, singleReplica, Collections.emptyList())),\n             null);\n-        assertEquals(Collections.singletonMap(topic, 1), internalTopicManager.getNumPartitions(Collections.singleton(topic)));\n+        assertEquals(Collections.singletonMap(topic, 1),\n+                internalTopicManager.getNumPartitions(Collections.singleton(topic), new HashSet<String>(), 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70d41212fe8a4d5055993c56e30c2342498e1664", "author": {"user": {"login": "showuon", "name": "Luke Chen"}}, "url": "https://github.com/apache/kafka/commit/70d41212fe8a4d5055993c56e30c2342498e1664", "committedDate": "2020-06-25T14:30:29Z", "message": "KAFKA-10006: address reviewer's comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "70d41212fe8a4d5055993c56e30c2342498e1664", "author": {"user": {"login": "showuon", "name": "Luke Chen"}}, "url": "https://github.com/apache/kafka/commit/70d41212fe8a4d5055993c56e30c2342498e1664", "committedDate": "2020-06-25T14:30:29Z", "message": "KAFKA-10006: address reviewer's comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00", "author": {"user": {"login": "showuon", "name": "Luke Chen"}}, "url": "https://github.com/apache/kafka/commit/9089b4bb8ddef924e45e19d7806343627f206b00", "committedDate": "2020-06-27T02:02:24Z", "message": "KAFKA-10006: fix the log flaw to count the tempUnkonwnTopics as topicsNotReady and add 2 more tests\n\n1. Return the topicsNotReady to makeReady including tempUnknownTopics, and not create topic to wait for next retry\n2. tempUnknownTopics will be created each retry since we count the tempUnknownTopics as part of topicsNotReady\n3. add 2 more tests to total test 3 cases:\n  3.1 shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound\n  3.2 shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess\n  3.3 shouldThrowExceptionWhenKeepsTopicLeaderNotAvailable"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00", "author": {"user": {"login": "showuon", "name": "Luke Chen"}}, "url": "https://github.com/apache/kafka/commit/9089b4bb8ddef924e45e19d7806343627f206b00", "committedDate": "2020-06-27T02:02:24Z", "message": "KAFKA-10006: fix the log flaw to count the tempUnkonwnTopics as topicsNotReady and add 2 more tests\n\n1. Return the topicsNotReady to makeReady including tempUnknownTopics, and not create topic to wait for next retry\n2. tempUnknownTopics will be created each retry since we count the tempUnknownTopics as part of topicsNotReady\n3. add 2 more tests to total test 3 cases:\n  3.1 shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound\n  3.2 shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess\n  3.3 shouldThrowExceptionWhenKeepsTopicLeaderNotAvailable"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMjA0OTMz", "url": "https://github.com/apache/kafka/pull/8712#pullrequestreview-440204933", "createdAt": "2020-06-30T16:48:18Z", "commit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjo0ODoxOFrOGrFfkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjo1ODoyNFrOGrF5OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMTk1Mw==", "bodyText": "Better to be name as leaderUnavailableTopics to match the error code.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447831953", "createdAt": "2020-06-30T16:48:18Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -100,13 +100,19 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         final Set<String> newlyCreatedTopics = new HashSet<>();\n \n         while (!topicsNotReady.isEmpty() && remainingRetries >= 0) {\n-            topicsNotReady = validateTopics(topicsNotReady, topics);\n+            final Set<String> tempUnknownTopics = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNDM3Mg==", "bodyText": "Could be simplified as topicManager.makeReady(Collections.singletonMap(leaderNotAvailableTopic, internalTopicConfig));", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447834372", "createdAt": "2020-06-30T16:52:07Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNTg5MQ==", "bodyText": "This test seems to be overlapping with shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound. I don't think we need both to return LeaderNotAvailable unless they are evaluating different scenarios.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447835891", "createdAt": "2020-06-30T16:54:25Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNjM3Mw==", "bodyText": "nit: if it will return topicDescriptionSuccessFuture, then we should not use leaderNotAvailableTopic", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447836373", "createdAt": "2020-06-30T16:55:09Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+        final TopicPartitionInfo partitionInfo = new TopicPartitionInfo(0, broker1,\n+                Collections.singletonList(broker1), Collections.singletonList(broker1));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionSuccessFuture = new KafkaFutureImpl<>();\n+        topicDescriptionSuccessFuture.complete(\n+            new TopicDescription(topic, false, Collections.singletonList(partitionInfo), Collections.emptySet())\n+        );\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNjg1Nw==", "bodyText": "exception not used.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447836857", "createdAt": "2020-06-30T16:55:49Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+        final TopicPartitionInfo partitionInfo = new TopicPartitionInfo(0, broker1,\n+                Collections.singletonList(broker1), Collections.singletonList(broker1));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionSuccessFuture = new KafkaFutureImpl<>();\n+        topicDescriptionSuccessFuture.complete(\n+            new TopicDescription(topic, false, Collections.singletonList(partitionInfo), Collections.emptySet())\n+        );\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionSuccessFuture)))\n+            .once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldThrowExceptionWhenKeepsTopicLeaderNotAvailable() {\n+        final String leaderNotAvailableTopic = \"LeaderNotAvailableTopic\";\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+\n+        // simulate describeTopics got LeaderNotAvailableException\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .times(2);\n+\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+\n+        final StreamsException exception = assertThrows(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzODUyMA==", "bodyText": "nit: we could set a final int for numRetries as:\n            put(StreamsConfig.adminClientPrefix(StreamsConfig.RETRIES_CONFIG), numRetries);\n\n\nand use (numRetries + 1) here to clearly indicate we are trying to go beyond the retry limit.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447838520", "createdAt": "2020-06-30T16:58:24Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+        final TopicPartitionInfo partitionInfo = new TopicPartitionInfo(0, broker1,\n+                Collections.singletonList(broker1), Collections.singletonList(broker1));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionSuccessFuture = new KafkaFutureImpl<>();\n+        topicDescriptionSuccessFuture.complete(\n+            new TopicDescription(topic, false, Collections.singletonList(partitionInfo), Collections.emptySet())\n+        );\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionSuccessFuture)))\n+            .once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldThrowExceptionWhenKeepsTopicLeaderNotAvailable() {\n+        final String leaderNotAvailableTopic = \"LeaderNotAvailableTopic\";\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+\n+        // simulate describeTopics got LeaderNotAvailableException\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .times(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 136}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b57a606a3834323302b6d3d33ab95e5b88d183b", "author": {"user": {"login": "showuon", "name": "Luke Chen"}}, "url": "https://github.com/apache/kafka/commit/4b57a606a3834323302b6d3d33ab95e5b88d183b", "committedDate": "2020-07-01T04:08:41Z", "message": "KAFKA-10006: address reviewer's comments\n\n1. simplifiy code\n2. use the existing topic name in tests, instead of creating a new one\n3. use numRetries to indicate we are trying to go beyond the retry limit"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwOTk4OTUy", "url": "https://github.com/apache/kafka/pull/8712#pullrequestreview-440998952", "createdAt": "2020-07-01T15:54:51Z", "commit": {"oid": "4b57a606a3834323302b6d3d33ab95e5b88d183b"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de9be72f4ccfddd7dc2e2b5b4968f4ecdb1693b0", "author": {"user": {"login": "showuon", "name": "Luke Chen"}}, "url": "https://github.com/apache/kafka/commit/de9be72f4ccfddd7dc2e2b5b4968f4ecdb1693b0", "committedDate": "2020-07-02T00:32:20Z", "message": "KAFKA-10006: remove duplicate properties"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMzQ3NDQy", "url": "https://github.com/apache/kafka/pull/8712#pullrequestreview-441347442", "createdAt": "2020-07-02T04:47:43Z", "commit": {"oid": "de9be72f4ccfddd7dc2e2b5b4968f4ecdb1693b0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1140, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}