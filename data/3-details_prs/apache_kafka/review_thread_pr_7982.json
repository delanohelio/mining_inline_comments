{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0NDQ2NjU5", "number": 7982, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQxNzo1NTozNVrODZAdWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQxODoxOToxOVrODZAgsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTQ4NTA2OnYy", "diffSide": "RIGHT", "path": "clients/src/test/java/org/apache/kafka/clients/producer/internals/BufferPoolTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQxNzo1NTozNVrOFfLj9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQxODowNTo1NFrOFfLl1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIzOTYwNA==", "bodyText": "Do you know why the sleep is needed ?\nFrom my experiment, 1 millis sleep suffices.\nThe timeout for completed.await() below can be shortened as well since the allocate() call would return immediately.", "url": "https://github.com/apache/kafka/pull/7982#discussion_r368239604", "createdAt": "2020-01-18T17:55:35Z", "author": {"login": "tedyu"}, "path": "clients/src/test/java/org/apache/kafka/clients/producer/internals/BufferPoolTest.java", "diffHunk": "@@ -416,6 +418,10 @@ public Void call() throws Exception {\n             executor.submit(work);\n         }\n \n+        // Wait for the workers to be blocked in their buffer allocations.\n+        ready.await(15, TimeUnit.SECONDS);\n+        Thread.sleep(100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI0MDA4NA==", "bodyText": "It's not necessary, but was done to ensure better predictability.\nIn the latch implementation, it may notify a futex which, depending on the scheduler, may pause the worker thread and schedule back to the main thread which would call close() before the worker was waiting in the buffer pool. Adding a sleep deschedules the main thread again so that the worker may continue.\n1 ms should accomplish the same thing. As @hachikuji noted in the previous PR, timeouts should be fairly lax so that they don't induce flakiness when running on Jenkins, so I'll defer to him on any modifications there.", "url": "https://github.com/apache/kafka/pull/7982#discussion_r368240084", "createdAt": "2020-01-18T18:05:54Z", "author": {"login": "bdbyrne"}, "path": "clients/src/test/java/org/apache/kafka/clients/producer/internals/BufferPoolTest.java", "diffHunk": "@@ -416,6 +418,10 @@ public Void call() throws Exception {\n             executor.submit(work);\n         }\n \n+        // Wait for the workers to be blocked in their buffer allocations.\n+        ready.await(15, TimeUnit.SECONDS);\n+        Thread.sleep(100);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODIzOTYwNA=="}, "originalCommit": null, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3NTQ5MzYwOnYy", "diffSide": "RIGHT", "path": "clients/src/test/java/org/apache/kafka/clients/producer/internals/BufferPoolTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOFQxODoxOToxOVrOFfLodg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QyMDowMzoxMlrOGM1WHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI0MDc1OA==", "bodyText": "As you mentioned, without sleep(), the pool.close() would be called immediately - reverting to the behavior prior to this change.\nI think the following formation would achieve what you want to test without the need to choose a proper sleep period.\n        ready.await(15, TimeUnit.SECONDS);\n\n        assertEquals(\"Allocation shouldn't have happened yet, waiting on memory\", numWorkers, completed.getCount());\n        Thread.yield();\n\nVerified via additional logging:\nallocating\nallocating\nclosing\nallocated\nallocated", "url": "https://github.com/apache/kafka/pull/7982#discussion_r368240758", "createdAt": "2020-01-18T18:19:19Z", "author": {"login": "tedyu"}, "path": "clients/src/test/java/org/apache/kafka/clients/producer/internals/BufferPoolTest.java", "diffHunk": "@@ -416,6 +418,10 @@ public Void call() throws Exception {\n             executor.submit(work);\n         }\n \n+        // Wait for the workers to be blocked in their buffer allocations.\n+        ready.await(15, TimeUnit.SECONDS);\n+        Thread.sleep(10);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI0MTQxNw==", "bodyText": "As you mentioned, without sleep(), the pool.close() would be called immediately - reverting to the behavior prior to this change.\n\nNot exactly. The addition of ready ensures that the threads have at least gotten as far as immediately before the call, which is the bulk of the setup.\n\nI think the following formation would achieve what you want to test without the need to choose a proper sleep period.\n        ready.await(15, TimeUnit.SECONDS);\n\n        assertEquals(\"Allocation shouldn't have happened yet, waiting on memory\", numWorkers, completed.getCount());\n        Thread.yield();\n\nVerified via additional logging:\nallocating\nallocating\nclosing\nallocated\nallocated\n\n\nSo keep in mind the sleep is in terms of milliseconds, where 10 ms shouldn't be an issue, as opposed to yield which can be more relaxed in whether to suspend the thread. However you'd want the yield to come before the assertion to provide more chance that the workers have made it inside the buffer pool and have been unable to make progress.", "url": "https://github.com/apache/kafka/pull/7982#discussion_r368241417", "createdAt": "2020-01-18T18:30:37Z", "author": {"login": "bdbyrne"}, "path": "clients/src/test/java/org/apache/kafka/clients/producer/internals/BufferPoolTest.java", "diffHunk": "@@ -416,6 +418,10 @@ public Void call() throws Exception {\n             executor.submit(work);\n         }\n \n+        // Wait for the workers to be blocked in their buffer allocations.\n+        ready.await(15, TimeUnit.SECONDS);\n+        Thread.sleep(10);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI0MDc1OA=="}, "originalCommit": null, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg5NzQ4NQ==", "bodyText": "@bdbyrne Couldn't we wait for the pool to have non-empty waiters instead of using Thread.sleep?", "url": "https://github.com/apache/kafka/pull/7982#discussion_r397897485", "createdAt": "2020-03-25T14:28:19Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/test/java/org/apache/kafka/clients/producer/internals/BufferPoolTest.java", "diffHunk": "@@ -416,6 +418,10 @@ public Void call() throws Exception {\n             executor.submit(work);\n         }\n \n+        // Wait for the workers to be blocked in their buffer allocations.\n+        ready.await(15, TimeUnit.SECONDS);\n+        Thread.sleep(10);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI0MDc1OA=="}, "originalCommit": null, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjExMDEwOA==", "bodyText": "Yes. Done.", "url": "https://github.com/apache/kafka/pull/7982#discussion_r416110108", "createdAt": "2020-04-27T20:03:12Z", "author": {"login": "bdbyrne"}, "path": "clients/src/test/java/org/apache/kafka/clients/producer/internals/BufferPoolTest.java", "diffHunk": "@@ -416,6 +418,10 @@ public Void call() throws Exception {\n             executor.submit(work);\n         }\n \n+        // Wait for the workers to be blocked in their buffer allocations.\n+        ready.await(15, TimeUnit.SECONDS);\n+        Thread.sleep(10);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI0MDc1OA=="}, "originalCommit": null, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4391, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}