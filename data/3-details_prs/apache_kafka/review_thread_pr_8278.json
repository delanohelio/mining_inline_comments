{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2ODM3ODEy", "number": 8278, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxOTozNDoxOFrODn82yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxOTozNDozNFrODn82-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMjE4MTIzOnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/coordinator/transaction/TransactionMetadataTest.scala", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxOTozNDoxOFrOF2QCog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMTo1Njo1NlrOF3HF9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQzMDI0Mg==", "bodyText": "This test would fail without the one-liner in this PR.", "url": "https://github.com/apache/kafka/pull/8278#discussion_r392430242", "createdAt": "2020-03-13T19:34:18Z", "author": {"login": "guozhangwang"}, "path": "core/src/test/scala/unit/kafka/coordinator/transaction/TransactionMetadataTest.scala", "diffHunk": "@@ -98,10 +95,198 @@ class TransactionMetadataTest {\n     txnMetadata.prepareIncrementProducerEpoch(30000, None, time.milliseconds())\n   }\n \n+  @Test\n+  def testTolerateUpdateTimeShiftDuringEpochBump(): Unit = {\n+    val producerEpoch: Short = 1\n+    val txnMetadata = new TransactionMetadata(\n+      transactionalId = transactionalId,\n+      producerId = producerId,\n+      lastProducerId = RecordBatch.NO_PRODUCER_ID,\n+      producerEpoch = producerEpoch,\n+      lastProducerEpoch = RecordBatch.NO_PRODUCER_EPOCH,\n+      txnTimeoutMs = 30000,\n+      state = Empty,\n+      topicPartitions = mutable.Set.empty,\n+      txnStartTimestamp = 1L,\n+      txnLastUpdateTimestamp = time.milliseconds())\n+\n+    // let new time be smaller\n+    val transitMetadata = txnMetadata.prepareIncrementProducerEpoch(30000, Option(producerEpoch), time.milliseconds() - 1).right.get\n+    txnMetadata.completeTransitionTo(transitMetadata)\n+    assertEquals(producerId, txnMetadata.producerId)\n+    assertEquals(producerEpoch + 1, txnMetadata.producerEpoch)\n+    assertEquals(producerEpoch, txnMetadata.lastProducerEpoch)\n+    assertEquals(1L, txnMetadata.txnStartTimestamp)\n+    assertEquals(time.milliseconds() - 1, txnMetadata.txnLastUpdateTimestamp)\n+  }\n+\n+  @Test\n+  def testTolerateUpdateTimeResetDuringProducerIdRotation(): Unit = {\n+    val producerEpoch: Short = 1\n+    val txnMetadata = new TransactionMetadata(\n+      transactionalId = transactionalId,\n+      producerId = producerId,\n+      lastProducerId = RecordBatch.NO_PRODUCER_ID,\n+      producerEpoch = producerEpoch,\n+      lastProducerEpoch = RecordBatch.NO_PRODUCER_EPOCH,\n+      txnTimeoutMs = 30000,\n+      state = Empty,\n+      topicPartitions = mutable.Set.empty,\n+      txnStartTimestamp = 1L,\n+      txnLastUpdateTimestamp = time.milliseconds())\n+\n+    // let new time be smaller\n+    val transitMetadata = txnMetadata.prepareProducerIdRotation(producerId + 1, 30000, time.milliseconds() - 1, recordLastEpoch = true)\n+    txnMetadata.completeTransitionTo(transitMetadata)\n+    assertEquals(producerId + 1, txnMetadata.producerId)\n+    assertEquals(producerEpoch, txnMetadata.lastProducerEpoch)\n+    assertEquals(0, txnMetadata.producerEpoch)\n+    assertEquals(1L, txnMetadata.txnStartTimestamp)\n+    assertEquals(time.milliseconds() - 1, txnMetadata.txnLastUpdateTimestamp)\n+  }\n+\n+  @Test\n+  def testTolerateTimeShiftDuringAddPartitions(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01fabcc02e0e7fd2613cc18c73817d07a354af3f"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxNTA4Mg==", "bodyText": "I checked this and the test still passes. I think the issue is that we are initializing txnStartTimestamp to 1 below.", "url": "https://github.com/apache/kafka/pull/8278#discussion_r393215082", "createdAt": "2020-03-16T18:03:58Z", "author": {"login": "hachikuji"}, "path": "core/src/test/scala/unit/kafka/coordinator/transaction/TransactionMetadataTest.scala", "diffHunk": "@@ -98,10 +95,198 @@ class TransactionMetadataTest {\n     txnMetadata.prepareIncrementProducerEpoch(30000, None, time.milliseconds())\n   }\n \n+  @Test\n+  def testTolerateUpdateTimeShiftDuringEpochBump(): Unit = {\n+    val producerEpoch: Short = 1\n+    val txnMetadata = new TransactionMetadata(\n+      transactionalId = transactionalId,\n+      producerId = producerId,\n+      lastProducerId = RecordBatch.NO_PRODUCER_ID,\n+      producerEpoch = producerEpoch,\n+      lastProducerEpoch = RecordBatch.NO_PRODUCER_EPOCH,\n+      txnTimeoutMs = 30000,\n+      state = Empty,\n+      topicPartitions = mutable.Set.empty,\n+      txnStartTimestamp = 1L,\n+      txnLastUpdateTimestamp = time.milliseconds())\n+\n+    // let new time be smaller\n+    val transitMetadata = txnMetadata.prepareIncrementProducerEpoch(30000, Option(producerEpoch), time.milliseconds() - 1).right.get\n+    txnMetadata.completeTransitionTo(transitMetadata)\n+    assertEquals(producerId, txnMetadata.producerId)\n+    assertEquals(producerEpoch + 1, txnMetadata.producerEpoch)\n+    assertEquals(producerEpoch, txnMetadata.lastProducerEpoch)\n+    assertEquals(1L, txnMetadata.txnStartTimestamp)\n+    assertEquals(time.milliseconds() - 1, txnMetadata.txnLastUpdateTimestamp)\n+  }\n+\n+  @Test\n+  def testTolerateUpdateTimeResetDuringProducerIdRotation(): Unit = {\n+    val producerEpoch: Short = 1\n+    val txnMetadata = new TransactionMetadata(\n+      transactionalId = transactionalId,\n+      producerId = producerId,\n+      lastProducerId = RecordBatch.NO_PRODUCER_ID,\n+      producerEpoch = producerEpoch,\n+      lastProducerEpoch = RecordBatch.NO_PRODUCER_EPOCH,\n+      txnTimeoutMs = 30000,\n+      state = Empty,\n+      topicPartitions = mutable.Set.empty,\n+      txnStartTimestamp = 1L,\n+      txnLastUpdateTimestamp = time.milliseconds())\n+\n+    // let new time be smaller\n+    val transitMetadata = txnMetadata.prepareProducerIdRotation(producerId + 1, 30000, time.milliseconds() - 1, recordLastEpoch = true)\n+    txnMetadata.completeTransitionTo(transitMetadata)\n+    assertEquals(producerId + 1, txnMetadata.producerId)\n+    assertEquals(producerEpoch, txnMetadata.lastProducerEpoch)\n+    assertEquals(0, txnMetadata.producerEpoch)\n+    assertEquals(1L, txnMetadata.txnStartTimestamp)\n+    assertEquals(time.milliseconds() - 1, txnMetadata.txnLastUpdateTimestamp)\n+  }\n+\n+  @Test\n+  def testTolerateTimeShiftDuringAddPartitions(): Unit = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQzMDI0Mg=="}, "originalCommit": {"oid": "01fabcc02e0e7fd2613cc18c73817d07a354af3f"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMzMjIxNA==", "bodyText": "Updated the test, could you review again?", "url": "https://github.com/apache/kafka/pull/8278#discussion_r393332214", "createdAt": "2020-03-16T21:56:56Z", "author": {"login": "guozhangwang"}, "path": "core/src/test/scala/unit/kafka/coordinator/transaction/TransactionMetadataTest.scala", "diffHunk": "@@ -98,10 +95,198 @@ class TransactionMetadataTest {\n     txnMetadata.prepareIncrementProducerEpoch(30000, None, time.milliseconds())\n   }\n \n+  @Test\n+  def testTolerateUpdateTimeShiftDuringEpochBump(): Unit = {\n+    val producerEpoch: Short = 1\n+    val txnMetadata = new TransactionMetadata(\n+      transactionalId = transactionalId,\n+      producerId = producerId,\n+      lastProducerId = RecordBatch.NO_PRODUCER_ID,\n+      producerEpoch = producerEpoch,\n+      lastProducerEpoch = RecordBatch.NO_PRODUCER_EPOCH,\n+      txnTimeoutMs = 30000,\n+      state = Empty,\n+      topicPartitions = mutable.Set.empty,\n+      txnStartTimestamp = 1L,\n+      txnLastUpdateTimestamp = time.milliseconds())\n+\n+    // let new time be smaller\n+    val transitMetadata = txnMetadata.prepareIncrementProducerEpoch(30000, Option(producerEpoch), time.milliseconds() - 1).right.get\n+    txnMetadata.completeTransitionTo(transitMetadata)\n+    assertEquals(producerId, txnMetadata.producerId)\n+    assertEquals(producerEpoch + 1, txnMetadata.producerEpoch)\n+    assertEquals(producerEpoch, txnMetadata.lastProducerEpoch)\n+    assertEquals(1L, txnMetadata.txnStartTimestamp)\n+    assertEquals(time.milliseconds() - 1, txnMetadata.txnLastUpdateTimestamp)\n+  }\n+\n+  @Test\n+  def testTolerateUpdateTimeResetDuringProducerIdRotation(): Unit = {\n+    val producerEpoch: Short = 1\n+    val txnMetadata = new TransactionMetadata(\n+      transactionalId = transactionalId,\n+      producerId = producerId,\n+      lastProducerId = RecordBatch.NO_PRODUCER_ID,\n+      producerEpoch = producerEpoch,\n+      lastProducerEpoch = RecordBatch.NO_PRODUCER_EPOCH,\n+      txnTimeoutMs = 30000,\n+      state = Empty,\n+      topicPartitions = mutable.Set.empty,\n+      txnStartTimestamp = 1L,\n+      txnLastUpdateTimestamp = time.milliseconds())\n+\n+    // let new time be smaller\n+    val transitMetadata = txnMetadata.prepareProducerIdRotation(producerId + 1, 30000, time.milliseconds() - 1, recordLastEpoch = true)\n+    txnMetadata.completeTransitionTo(transitMetadata)\n+    assertEquals(producerId + 1, txnMetadata.producerId)\n+    assertEquals(producerEpoch, txnMetadata.lastProducerEpoch)\n+    assertEquals(0, txnMetadata.producerEpoch)\n+    assertEquals(1L, txnMetadata.txnStartTimestamp)\n+    assertEquals(time.milliseconds() - 1, txnMetadata.txnLastUpdateTimestamp)\n+  }\n+\n+  @Test\n+  def testTolerateTimeShiftDuringAddPartitions(): Unit = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQzMDI0Mg=="}, "originalCommit": {"oid": "01fabcc02e0e7fd2613cc18c73817d07a354af3f"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMjE4MTY4OnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/coordinator/transaction/TransactionMetadataTest.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxOTozNDozNFrOF2QC8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxOTozNDozNFrOF2QC8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQzMDMyMQ==", "bodyText": "These tests are added to cover #3286", "url": "https://github.com/apache/kafka/pull/8278#discussion_r392430321", "createdAt": "2020-03-13T19:34:34Z", "author": {"login": "guozhangwang"}, "path": "core/src/test/scala/unit/kafka/coordinator/transaction/TransactionMetadataTest.scala", "diffHunk": "@@ -98,10 +95,198 @@ class TransactionMetadataTest {\n     txnMetadata.prepareIncrementProducerEpoch(30000, None, time.milliseconds())\n   }\n \n+  @Test\n+  def testTolerateUpdateTimeShiftDuringEpochBump(): Unit = {\n+    val producerEpoch: Short = 1\n+    val txnMetadata = new TransactionMetadata(\n+      transactionalId = transactionalId,\n+      producerId = producerId,\n+      lastProducerId = RecordBatch.NO_PRODUCER_ID,\n+      producerEpoch = producerEpoch,\n+      lastProducerEpoch = RecordBatch.NO_PRODUCER_EPOCH,\n+      txnTimeoutMs = 30000,\n+      state = Empty,\n+      topicPartitions = mutable.Set.empty,\n+      txnStartTimestamp = 1L,\n+      txnLastUpdateTimestamp = time.milliseconds())\n+\n+    // let new time be smaller\n+    val transitMetadata = txnMetadata.prepareIncrementProducerEpoch(30000, Option(producerEpoch), time.milliseconds() - 1).right.get\n+    txnMetadata.completeTransitionTo(transitMetadata)\n+    assertEquals(producerId, txnMetadata.producerId)\n+    assertEquals(producerEpoch + 1, txnMetadata.producerEpoch)\n+    assertEquals(producerEpoch, txnMetadata.lastProducerEpoch)\n+    assertEquals(1L, txnMetadata.txnStartTimestamp)\n+    assertEquals(time.milliseconds() - 1, txnMetadata.txnLastUpdateTimestamp)\n+  }\n+\n+  @Test\n+  def testTolerateUpdateTimeResetDuringProducerIdRotation(): Unit = {\n+    val producerEpoch: Short = 1\n+    val txnMetadata = new TransactionMetadata(\n+      transactionalId = transactionalId,\n+      producerId = producerId,\n+      lastProducerId = RecordBatch.NO_PRODUCER_ID,\n+      producerEpoch = producerEpoch,\n+      lastProducerEpoch = RecordBatch.NO_PRODUCER_EPOCH,\n+      txnTimeoutMs = 30000,\n+      state = Empty,\n+      topicPartitions = mutable.Set.empty,\n+      txnStartTimestamp = 1L,\n+      txnLastUpdateTimestamp = time.milliseconds())\n+\n+    // let new time be smaller\n+    val transitMetadata = txnMetadata.prepareProducerIdRotation(producerId + 1, 30000, time.milliseconds() - 1, recordLastEpoch = true)\n+    txnMetadata.completeTransitionTo(transitMetadata)\n+    assertEquals(producerId + 1, txnMetadata.producerId)\n+    assertEquals(producerEpoch, txnMetadata.lastProducerEpoch)\n+    assertEquals(0, txnMetadata.producerEpoch)\n+    assertEquals(1L, txnMetadata.txnStartTimestamp)\n+    assertEquals(time.milliseconds() - 1, txnMetadata.txnLastUpdateTimestamp)\n+  }\n+\n+  @Test\n+  def testTolerateTimeShiftDuringAddPartitions(): Unit = {\n+    val producerEpoch: Short = 1\n+    val txnMetadata = new TransactionMetadata(\n+      transactionalId = transactionalId,\n+      producerId = producerId,\n+      lastProducerId = RecordBatch.NO_PRODUCER_ID,\n+      producerEpoch = producerEpoch,\n+      lastProducerEpoch = RecordBatch.NO_PRODUCER_EPOCH,\n+      txnTimeoutMs = 30000,\n+      state = Empty,\n+      topicPartitions = mutable.Set.empty,\n+      txnStartTimestamp = 1L,\n+      txnLastUpdateTimestamp = time.milliseconds())\n+\n+    // let new time be smaller\n+    var transitMetadata = txnMetadata.prepareAddPartitions(Set[TopicPartition](new TopicPartition(\"topic1\", 0)), time.milliseconds() - 1)\n+    txnMetadata.completeTransitionTo(transitMetadata)\n+    assertEquals(Set[TopicPartition](new TopicPartition(\"topic1\", 0)), txnMetadata.topicPartitions)\n+    assertEquals(producerId, txnMetadata.producerId)\n+    assertEquals(RecordBatch.NO_PRODUCER_EPOCH, txnMetadata.lastProducerEpoch)\n+    assertEquals(producerEpoch, txnMetadata.producerEpoch)\n+    assertEquals(time.milliseconds() - 1, txnMetadata.txnStartTimestamp)\n+    assertEquals(time.milliseconds() - 1, txnMetadata.txnLastUpdateTimestamp)\n+\n+    // add another partition, check that this time the start timestamp would not change\n+    transitMetadata = txnMetadata.prepareAddPartitions(Set[TopicPartition](new TopicPartition(\"topic2\", 0)), time.milliseconds() - 2)\n+    txnMetadata.completeTransitionTo(transitMetadata)\n+    assertEquals(Set[TopicPartition](new TopicPartition(\"topic1\", 0), new TopicPartition(\"topic2\", 0)), txnMetadata.topicPartitions)\n+    assertEquals(producerId, txnMetadata.producerId)\n+    assertEquals(RecordBatch.NO_PRODUCER_EPOCH, txnMetadata.lastProducerEpoch)\n+    assertEquals(producerEpoch, txnMetadata.producerEpoch)\n+    assertEquals(time.milliseconds() - 1, txnMetadata.txnStartTimestamp)\n+    assertEquals(time.milliseconds() - 2, txnMetadata.txnLastUpdateTimestamp)\n+  }\n+\n+  @Test\n+  def testTolerateTimeShiftDuringPrepareCommit(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01fabcc02e0e7fd2613cc18c73817d07a354af3f"}, "originalPosition": 131}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3315, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}