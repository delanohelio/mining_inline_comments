{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxMDYzOTk5", "number": 8187, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMjo0Mzo0OFrODjozMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMzozNDo1OFrODjr65Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Njk1MjE4OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateManagerUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMjo0Mzo0OFrOFvj1pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMjo0Mzo0OFrOFvj1pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxNDU2Ng==", "bodyText": "Add a logging to log the IO exception.", "url": "https://github.com/apache/kafka/pull/8187#discussion_r385414566", "createdAt": "2020-02-27T22:43:48Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StateManagerUtil.java", "diffHunk": "@@ -84,7 +84,7 @@ static void wipeStateStores(final Logger log, final ProcessorStateManager stateM\n             Utils.delete(stateMgr.baseDir());\n         } catch (final IOException fatalException) {\n             // since it is only called under dirty close, we always swallow the exception\n-            log.warn(\"Failed to wiping state stores for task {}\", stateMgr.taskId());\n+            log.warn(\"Failed to wiping state stores for task {} due to {}\", stateMgr.taskId(), fatalException);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4Njk2MjQ2OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMjo0ODoyMFrOFvj8Kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMTo0NTo0N1rOFvnIAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxNjIzNQ==", "bodyText": "Simplify the logic here as we no longer throws before task suspend", "url": "https://github.com/apache/kafka/pull/8187#discussion_r385416235", "createdAt": "2020-02-27T22:48:20Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -293,12 +301,11 @@ boolean tryToCompleteRestoration() {\n      * @throws TaskMigratedException if the task producer got fenced (EOS only)\n      */\n     void handleRevocation(final Collection<TopicPartition> revokedPartitions) {\n-        final Set<TaskId> revokedTasks = new HashSet<>();\n         final Set<TopicPartition> remainingPartitions = new HashSet<>(revokedPartitions);\n \n         for (final Task task : tasks.values()) {\n             if (remainingPartitions.containsAll(task.inputPartitions())) {\n-                revokedTasks.add(task.id());\n+                task.suspend();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ1Njg1Mw==", "bodyText": "Not sure I follow: we can still throw from inside suspend right?", "url": "https://github.com/apache/kafka/pull/8187#discussion_r385456853", "createdAt": "2020-02-28T01:01:23Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -293,12 +301,11 @@ boolean tryToCompleteRestoration() {\n      * @throws TaskMigratedException if the task producer got fenced (EOS only)\n      */\n     void handleRevocation(final Collection<TopicPartition> revokedPartitions) {\n-        final Set<TaskId> revokedTasks = new HashSet<>();\n         final Set<TopicPartition> remainingPartitions = new HashSet<>(revokedPartitions);\n \n         for (final Task task : tasks.values()) {\n             if (remainingPartitions.containsAll(task.inputPartitions())) {\n-                revokedTasks.add(task.id());\n+                task.suspend();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxNjIzNQ=="}, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ2NTgwMg==", "bodyText": "What I mean is that we do not throw if remaining partitions are not empty anymore. We could directly suspend a task here.", "url": "https://github.com/apache/kafka/pull/8187#discussion_r385465802", "createdAt": "2020-02-28T01:35:18Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -293,12 +301,11 @@ boolean tryToCompleteRestoration() {\n      * @throws TaskMigratedException if the task producer got fenced (EOS only)\n      */\n     void handleRevocation(final Collection<TopicPartition> revokedPartitions) {\n-        final Set<TaskId> revokedTasks = new HashSet<>();\n         final Set<TopicPartition> remainingPartitions = new HashSet<>(revokedPartitions);\n \n         for (final Task task : tasks.values()) {\n             if (remainingPartitions.containsAll(task.inputPartitions())) {\n-                revokedTasks.add(task.id());\n+                task.suspend();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxNjIzNQ=="}, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ2ODQxOA==", "bodyText": "I see.", "url": "https://github.com/apache/kafka/pull/8187#discussion_r385468418", "createdAt": "2020-02-28T01:45:47Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -293,12 +301,11 @@ boolean tryToCompleteRestoration() {\n      * @throws TaskMigratedException if the task producer got fenced (EOS only)\n      */\n     void handleRevocation(final Collection<TopicPartition> revokedPartitions) {\n-        final Set<TaskId> revokedTasks = new HashSet<>();\n         final Set<TopicPartition> remainingPartitions = new HashSet<>(revokedPartitions);\n \n         for (final Task task : tasks.values()) {\n             if (remainingPartitions.containsAll(task.inputPartitions())) {\n-                revokedTasks.add(task.id());\n+                task.suspend();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxNjIzNQ=="}, "originalCommit": null, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NzIzMTM5OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMTowMjoyN1rOFvmb3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMTo0Nzo0MlrOFvnKAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ1NzExOQ==", "bodyText": "I think we should use instanceof KafkaException as well here:  if it is any inheritance of KafkaException, we should not wrap it.", "url": "https://github.com/apache/kafka/pull/8187#discussion_r385457119", "createdAt": "2020-02-28T01:02:27Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -198,12 +198,19 @@ public void handleAssignment(final Map<TaskId, Set<TopicPartition>> activeTasks,\n         }\n \n         if (!taskCloseExceptions.isEmpty()) {\n+            for (final Map.Entry<TaskId, RuntimeException> entry : taskCloseExceptions.entrySet()) {\n+                if (!(entry.getValue() instanceof TaskMigratedException)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e5126740306723247e240ca4617091f3ee6f0b9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ2ODkyOA==", "bodyText": "Sounds good", "url": "https://github.com/apache/kafka/pull/8187#discussion_r385468928", "createdAt": "2020-02-28T01:47:42Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -198,12 +198,19 @@ public void handleAssignment(final Map<TaskId, Set<TopicPartition>> activeTasks,\n         }\n \n         if (!taskCloseExceptions.isEmpty()) {\n+            for (final Map.Entry<TaskId, RuntimeException> entry : taskCloseExceptions.entrySet()) {\n+                if (!(entry.getValue() instanceof TaskMigratedException)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ1NzExOQ=="}, "originalCommit": {"oid": "9e5126740306723247e240ca4617091f3ee6f0b9"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NzMxNDI3OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMTo1MTowM1rOFvnNVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMTo1MTowM1rOFvnNVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ2OTc4Mw==", "bodyText": "Thank you for the added tests!", "url": "https://github.com/apache/kafka/pull/8187#discussion_r385469783", "createdAt": "2020-02-28T01:51:03Z", "author": {"login": "guozhangwang"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -741,6 +733,85 @@ public void shouldHaveRemainingPartitionsUncleared() {\n             \"detecting the heartbeat failure, or the tasks have been cleaned up by the handleAssignment callback.\"));\n     }\n \n+    @Test\n+    public void shouldThrowTaskMigratedWhenAllTaskCloseExceptionsAreTaskMigrated() {\n+        final StateMachineTask migratedTask01 = new StateMachineTask(taskId01, taskId01Partitions, false) {\n+            @Override\n+            public void closeClean() {\n+                throw new TaskMigratedException(\"t1 close exception\", new RuntimeException());\n+            }\n+        };\n+\n+        final StateMachineTask migratedTask02 = new StateMachineTask(taskId02, taskId02Partitions, false) {\n+            @Override\n+            public void closeClean() {\n+                throw new TaskMigratedException(\"t2 close exception\", new RuntimeException());\n+            }\n+        };\n+        taskManager.tasks().put(taskId01, migratedTask01);\n+        taskManager.tasks().put(taskId02, migratedTask02);\n+\n+        final TaskMigratedException thrown = assertThrows(TaskMigratedException.class,\n+            () -> taskManager.handleAssignment(emptyMap(), emptyMap()));\n+        // The task map orders tasks based on topic group id and partition, so here\n+        // t1 should always be the first.\n+        assertThat(thrown.getMessage(), equalTo(\"t1 close exception; it means all tasks belonging to this thread should be migrated.\"));\n+    }\n+\n+    @Test\n+    public void shouldThrowRuntimeExceptionWhenEncounteredUnknownExceptionDuringTaskClose() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1347ddc2c399ecddc1fa488c8188f3a74f0f5f49"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NzQ2MzQxOnYy", "diffSide": "RIGHT", "path": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinatorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMzozNDo1OFrOFvonCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwMzozNDo1OFrOFvonCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ5Mjc0NQ==", "bodyText": "just a side cleanup", "url": "https://github.com/apache/kafka/pull/8187#discussion_r385492745", "createdAt": "2020-02-28T03:34:58Z", "author": {"login": "abbccdda"}, "path": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinatorTest.java", "diffHunk": "@@ -338,14 +353,11 @@ public void testManyInFlightAsyncCommitsWithCoordinatorDisconnect() {\n \n         for (int i = 0; i < numRequests; i++) {\n             Map<TopicPartition, OffsetAndMetadata> offsets = singletonMap(tp, new OffsetAndMetadata(i));\n-            coordinator.commitOffsetsAsync(offsets, new OffsetCommitCallback() {\n-                @Override\n-                public void onComplete(Map<TopicPartition, OffsetAndMetadata> offsets, Exception exception) {\n-                    responses.incrementAndGet();\n-                    Throwable cause = exception.getCause();\n-                    assertTrue(\"Unexpected exception cause type: \" + (cause == null ? null : cause.getClass()),\n-                            cause instanceof DisconnectException);\n-                }\n+            coordinator.commitOffsetsAsync(offsets, (offsets1, exception) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1347ddc2c399ecddc1fa488c8188f3a74f0f5f49"}, "originalPosition": 52}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4120, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}