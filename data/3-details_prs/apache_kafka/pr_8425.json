{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4NDY0NDUz", "number": 8425, "title": "KAFKA-6145: KIP-441 Move tasks with caught-up destination clients right away", "bodyText": "If a stateful task is intended to be moved to a client which is already caught-up, we should not create a warmup task for it. Instead, just reassign that task right away.", "createdAt": "2020-04-04T04:04:28Z", "url": "https://github.com/apache/kafka/pull/8425", "merged": true, "mergeCommit": {"oid": "ed3a7157e0d1ecfddf5a0cd9d839635cc78f3e60"}, "closed": true, "closedAt": "2020-04-09T01:08:41Z", "author": {"login": "ableegoldman"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcUNer3gFqTM4NzY2NTI2OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcVsfGWgH2gAyMzk4NDY0NDUzOmU1YTg5NjNjOWNmNjRhNjBkMjZhZmZkNjllNTNmNDc3NmU5ZGVlNDk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NjY1MjY4", "url": "https://github.com/apache/kafka/pull/8425#pullrequestreview-387665268", "createdAt": "2020-04-04T04:06:51Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwNDowNjo1MVrOGAu5TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwNDowNjo1MVrOGAu5TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQyMTUxNg==", "bodyText": "This is just a side bug that StreamsPartitionAssignorTest caught, we need to pin the overflow here too", "url": "https://github.com/apache/kafka/pull/8425#discussion_r403421516", "createdAt": "2020-04-04T04:06:51Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamsPartitionAssignor.java", "diffHunk": "@@ -792,7 +792,13 @@ private boolean populateClientStatesMap(final Map<UUID, ClientState> clientState\n                     log.debug(\"Fetched end offsets did not contain the changelog {} of task {}\", changelog, task);\n                     throw new IllegalStateException(\"Could not get end offset for \" + changelog);\n                 }\n-                taskEndOffsetSums.computeIfPresent(task, (id, curOffsetSum) -> curOffsetSum + offsetResult.offset());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NjY1Mjg5", "url": "https://github.com/apache/kafka/pull/8425#pullrequestreview-387665289", "createdAt": "2020-04-04T04:07:18Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwNDowNzoxOFrOGAu5cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwNDowNzoxOFrOGAu5cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQyMTU1Mg==", "bodyText": "Since we now need this in getMovements as well, I moved this for reusability", "url": "https://github.com/apache/kafka/pull/8425#discussion_r403421552", "createdAt": "2020-04-04T04:07:18Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -101,28 +103,6 @@ private void checkClientsAndNumberOfStreamThreads(final Map<UUID, Integer> clien\n         return assignment;\n     }\n \n-    /**\n-     * Maps tasks to clients with caught-up states for the task.\n-     *\n-     * @param statefulTasksToRankedClients ranked clients map\n-     * @return map from tasks with caught-up clients to the list of client candidates\n-     */\n-    private Map<TaskId, List<UUID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<RankedClient>> statefulTasksToRankedClients) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NzQyNDk2", "url": "https://github.com/apache/kafka/pull/8425#pullrequestreview-388742496", "createdAt": "2020-04-07T02:23:38Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMjoyMzozOFrOGBwo5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwMjoyMzozOFrOGBwo5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQ5ODY2Mw==", "bodyText": "There are no logical changes to this file, just factoring out the statefulTasksToRankedCandidates and supplying the tasksToCaughtUpClients as an additional input parameter", "url": "https://github.com/apache/kafka/pull/8425#discussion_r404498663", "createdAt": "2020-04-07T02:23:38Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignorTest.java", "diffHunk": "@@ -41,6 +41,7 @@\n import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.UUID_1;\n import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.UUID_2;\n import static org.apache.kafka.streams.processor.internals.assignment.AssignmentTestUtils.UUID_3;\n+import static org.apache.kafka.streams.processor.internals.assignment.RankedClient.tasksToCaughtUpClients;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NDM1OTAx", "url": "https://github.com/apache/kafka/pull/8425#pullrequestreview-389435901", "createdAt": "2020-04-07T19:45:18Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxOTo0NToxOFrOGCTXkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxOTo0NToxOFrOGCTXkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA2NzY2NA==", "bodyText": "Just out of curiosity, what is the motivation for adding this method and making a copy of the list?", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405067664", "createdAt": "2020-04-07T19:45:18Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java", "diffHunk": "@@ -96,34 +139,46 @@ public void shouldReturnEmptyMovementsWhenPassedEmptyTaskAssignments() {\n             mkEntry(UUID_1, emptyList()),\n             mkEntry(UUID_2, emptyList())\n         );\n-        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas).isEmpty());\n+        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas).isEmpty());\n     }\n \n     @Test\n     public void shouldReturnEmptyMovementsWhenPassedIdenticalTaskAssignments() {\n         final int maxWarmupReplicas = 2;\n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n-        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas).isEmpty());\n+        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas).isEmpty());\n     }\n \n     @Test\n     public void shouldThrowIllegalStateExceptionIfAssignmentsAreOfDifferentSize() {\n         final int maxWarmupReplicas = 2;\n \n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_0_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_0_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n-        assertThrows(IllegalStateException.class, () -> getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas));\n+        assertThrows(IllegalStateException.class, () -> getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas));\n+    }\n+\n+    private static List<TaskId> mkTaskList(final TaskId... tasks) {\n+        return new ArrayList<>(asList(tasks));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 166}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMDE4NDky", "url": "https://github.com/apache/kafka/pull/8425#pullrequestreview-390018492", "createdAt": "2020-04-08T14:17:12Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDoxNzoxM1rOGCxaMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQxNDo1NzoyMVrOGCzNXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1OTg1Nw==", "bodyText": "req: My IDE says that this import is not needed. Since the imported method is in the same package, I agree with my IDE. Could you please remove it? Isn't strange that checkstyle did not find this?", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405559857", "createdAt": "2020-04-08T14:17:13Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignor.java", "diffHunk": "@@ -16,6 +16,8 @@\n  */\n package org.apache.kafka.streams.processor.internals.assignment;\n \n+import static org.apache.kafka.streams.processor.internals.assignment.RankedClient.tasksToCaughtUpClients;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MjQ2Mw==", "bodyText": "req: Now that we can test this method. Could you please add unit tests for this method in RankedClientTest?", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405562463", "createdAt": "2020-04-08T14:20:39Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/assignment/RankedClient.java", "diffHunk": "@@ -78,6 +79,28 @@ public int hashCode() {\n         return Objects.hash(clientId, rank);\n     }\n \n+    /**\n+     * Maps tasks to clients with caught-up states for the task.\n+     *\n+     * @param statefulTasksToRankedClients ranked clients map\n+     * @return map from tasks with caught-up clients to the list of client candidates\n+     */\n+    static Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients(final SortedMap<TaskId, SortedSet<RankedClient>> statefulTasksToRankedClients) {\n+        final Map<TaskId, SortedSet<UUID>> taskToCaughtUpClients = new HashMap<>();\n+        for (final SortedMap.Entry<TaskId, SortedSet<RankedClient>> taskToRankedClients : statefulTasksToRankedClients.entrySet()) {\n+            final SortedSet<RankedClient> rankedClients = taskToRankedClients.getValue();\n+            for (final RankedClient rankedClient : rankedClients) {\n+                if (rankedClient.rank() == Task.LATEST_OFFSET || rankedClient.rank() == 0) {\n+                    final TaskId taskId = taskToRankedClients.getKey();\n+                    taskToCaughtUpClients.computeIfAbsent(taskId, ignored -> new TreeSet<>()).add(rankedClient.clientId());\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+        return taskToCaughtUpClients;\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU3NDY2Ng==", "bodyText": "req:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        rankForTask01OnClient1,\n          \n          \n            \n                        rankForTask01OnClient2,\n          \n          \n            \n                        rankForTask12OnClient1,\n          \n          \n            \n                        rankForTask12OnClient2\n          \n          \n            \n                    );\n          \n          \n            \n                            rankForTask01OnClient1,\n          \n          \n            \n                            rankForTask01OnClient2,\n          \n          \n            \n                            rankForTask12OnClient1,\n          \n          \n            \n                            rankForTask12OnClient2\n          \n          \n            \n                        );", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405574666", "createdAt": "2020-04-08T14:37:29Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/DefaultStateConstrainedBalancedAssignorTest.java", "diffHunk": "@@ -147,16 +153,19 @@ public void shouldEvenlyDistributeTasksToCaughtUpClientsThatAreNotPreviousHosts(\n         final long rankForTask12OnClient2 = 0;\n         final int balanceFactor = 1;\n \n-        final Map<UUID, List<TaskId>> assignment = new DefaultStateConstrainedBalancedAssignor().assign(\n+        final SortedMap<TaskId, SortedSet<RankedClient>> statefulTasksToRankedCandidates =\n             twoStatefulTasksToTwoRankedClients(\n-                rankForTask01OnClient1,\n-                rankForTask01OnClient2,\n-                rankForTask12OnClient1,\n-                rankForTask12OnClient2\n-            ),\n+            rankForTask01OnClient1,\n+            rankForTask01OnClient2,\n+            rankForTask12OnClient1,\n+            rankForTask12OnClient2\n+        );", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4NTcyOA==", "bodyText": "prop:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(getMovements(stateConstrainedAssignment, balancedAssignment, tasksToCaughtUpClients, maxWarmupReplicas), equalTo(expectedMovements));\n          \n          \n            \n                    assertThat(\n          \n          \n            \n                        getMovements(stateConstrainedAssignment, balancedAssignment, tasksToCaughtUpClients, maxWarmupReplicas), \n          \n          \n            \n                        equalTo(expectedMovements)\n          \n          \n            \n                    );", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405585728", "createdAt": "2020-04-08T14:52:36Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java", "diffHunk": "@@ -49,40 +57,75 @@\n     public void shouldGetMovementsFromStateConstrainedToBalancedAssignment() {\n         final int maxWarmupReplicas = Integer.MAX_VALUE;\n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_2)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_0)),\n-            mkEntry(UUID_3, asList(TASK_0_2, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_2)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_0)),\n+            mkEntry(UUID_3, mkTaskList(TASK_0_2, TASK_1_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1)),\n-            mkEntry(UUID_3, asList(TASK_0_2, TASK_1_2))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1)),\n+            mkEntry(UUID_3, mkTaskList(TASK_0_2, TASK_1_2))\n         );\n+        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = getMapWithNoCaughtUpClients(\n+            mkSet(TASK_0_0, TASK_0_1, TASK_0_2, TASK_1_0, TASK_1_1, TASK_1_2)\n+        );\n+\n         final Queue<TaskMovement> expectedMovements = new LinkedList<>();\n         expectedMovements.add(new TaskMovement(TASK_1_2, UUID_1, UUID_3));\n         expectedMovements.add(new TaskMovement(TASK_1_0, UUID_2, UUID_1));\n         expectedMovements.add(new TaskMovement(TASK_1_1, UUID_3, UUID_2));\n \n-        assertThat(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas), equalTo(expectedMovements));\n+        assertThat(getMovements(stateConstrainedAssignment, balancedAssignment, tasksToCaughtUpClients, maxWarmupReplicas), equalTo(expectedMovements));\n+    }\n+\n+    @Test\n+    public void shouldImmediatelyMoveTasksWithCaughtUpDestinationClients() {\n+        final int maxWarmupReplicas = Integer.MAX_VALUE;\n+        final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_2)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_0)),\n+            mkEntry(UUID_3, mkTaskList(TASK_0_2, TASK_1_1))\n+        );\n+        final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1)),\n+            mkEntry(UUID_3, mkTaskList(TASK_0_2, TASK_1_2))\n+        );\n+        final Map<TaskId, SortedSet<UUID>> tasksToCaughtUpClients = getMapWithNoCaughtUpClients(\n+            mkSet(TASK_0_0, TASK_0_1, TASK_0_2, TASK_1_0, TASK_1_1, TASK_1_2)\n+        );\n+        tasksToCaughtUpClients.get(TASK_1_0).add(UUID_1);\n+\n+        final Queue<TaskMovement> expectedMovements = new LinkedList<>();\n+        expectedMovements.add(new TaskMovement(TASK_1_2, UUID_1, UUID_3));\n+        expectedMovements.add(new TaskMovement(TASK_1_1, UUID_3, UUID_2));\n+\n+        assertThat(getMovements(stateConstrainedAssignment, balancedAssignment, tasksToCaughtUpClients, maxWarmupReplicas), equalTo(expectedMovements));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU4OTM0Mw==", "bodyText": "req: Please add a test that verifies the IllegalStateException when a task does not have a destination.", "url": "https://github.com/apache/kafka/pull/8425#discussion_r405589343", "createdAt": "2020-04-08T14:57:21Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/assignment/TaskMovementTest.java", "diffHunk": "@@ -96,34 +139,46 @@ public void shouldReturnEmptyMovementsWhenPassedEmptyTaskAssignments() {\n             mkEntry(UUID_1, emptyList()),\n             mkEntry(UUID_2, emptyList())\n         );\n-        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas).isEmpty());\n+        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas).isEmpty());\n     }\n \n     @Test\n     public void shouldReturnEmptyMovementsWhenPassedIdenticalTaskAssignments() {\n         final int maxWarmupReplicas = 2;\n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n-        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas).isEmpty());\n+        assertTrue(getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas).isEmpty());\n     }\n \n     @Test\n     public void shouldThrowIllegalStateExceptionIfAssignmentsAreOfDifferentSize() {\n         final int maxWarmupReplicas = 2;\n \n         final Map<UUID, List<TaskId>> stateConstrainedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_0_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_0_1))\n         );\n         final Map<UUID, List<TaskId>> balancedAssignment = mkMap(\n-            mkEntry(UUID_1, asList(TASK_0_0, TASK_1_0)),\n-            mkEntry(UUID_2, asList(TASK_0_1, TASK_1_1))\n+            mkEntry(UUID_1, mkTaskList(TASK_0_0, TASK_1_0)),\n+            mkEntry(UUID_2, mkTaskList(TASK_0_1, TASK_1_1))\n         );\n-        assertThrows(IllegalStateException.class, () -> getMovements(stateConstrainedAssignment, balancedAssignment, maxWarmupReplicas));\n+        assertThrows(IllegalStateException.class, () -> getMovements(stateConstrainedAssignment, balancedAssignment, emptyMap(), maxWarmupReplicas));\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 163}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9ae9121195c351f4600d9c4707270a170cbec9d", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/a9ae9121195c351f4600d9c4707270a170cbec9d", "committedDate": "2020-04-08T18:10:54Z", "message": "move immediately"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8301b5b01084d6a2051d9ab686e7a80276915d82", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/8301b5b01084d6a2051d9ab686e7a80276915d82", "committedDate": "2020-04-08T18:10:54Z", "message": "pin overflow in end offsets"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab1e002982198ea5960257678a8e7e1175291dfa", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/ab1e002982198ea5960257678a8e7e1175291dfa", "committedDate": "2020-04-08T18:10:54Z", "message": "extract to static method"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "ab1e002982198ea5960257678a8e7e1175291dfa", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/ab1e002982198ea5960257678a8e7e1175291dfa", "committedDate": "2020-04-08T18:10:54Z", "message": "extract to static method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5a8963c9cf64a60d26affd69e53f4776e9dee49", "author": {"user": {"login": "ableegoldman", "name": "A. Sophie Blee-Goldman"}}, "url": "https://github.com/apache/kafka/commit/e5a8963c9cf64a60d26affd69e53f4776e9dee49", "committedDate": "2020-04-08T18:48:17Z", "message": "github review comments and tests"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 96, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}