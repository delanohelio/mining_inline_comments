{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwNjQ4NDY4", "number": 9202, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQwNDo1Mzo0NVrOEbLqIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwMDowODo0NVrOElJhlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2OTM4MDE5OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQwNDo1Mzo0NVrOHFCidA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwNTozNjozMFrOHFVOBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA0NjUxNg==", "bodyText": "We should use an if/else here, no point in using pattern matching.", "url": "https://github.com/apache/kafka/pull/9202#discussion_r475046516", "createdAt": "2020-08-22T04:53:45Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "diffHunk": "@@ -1401,16 +1401,17 @@ object GroupMetadataManager {\n       val version = buffer.getShort\n       val valueSchema = schemaForGroupValue(version)\n       val value = valueSchema.read(buffer)\n+      val maxVersion = GROUP_VALUE_SCHEMAS.size - 1\n \n-      if (version >= 0 && version <= 3) {\n+      if (0 to maxVersion contains version) {\n         val generationId = value.get(GENERATION_KEY).asInstanceOf[Int]\n         val protocolType = value.get(PROTOCOL_TYPE_KEY).asInstanceOf[String]\n         val protocol = value.get(PROTOCOL_KEY).asInstanceOf[String]\n         val leaderId = value.get(LEADER_KEY).asInstanceOf[String]\n         val memberMetadataArray = value.getArray(MEMBERS_KEY)\n         val initialState = if (memberMetadataArray.isEmpty) Empty else Stable\n         val currentStateTimestamp: Option[Long] = version match {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd8787a3df279ebd5e802008700b1c41a65f60ec"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM1MjU4Mg==", "bodyText": "Nice catch! Yes, it's better to use if/else.", "url": "https://github.com/apache/kafka/pull/9202#discussion_r475352582", "createdAt": "2020-08-24T05:36:30Z", "author": {"login": "showuon"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "diffHunk": "@@ -1401,16 +1401,17 @@ object GroupMetadataManager {\n       val version = buffer.getShort\n       val valueSchema = schemaForGroupValue(version)\n       val value = valueSchema.read(buffer)\n+      val maxVersion = GROUP_VALUE_SCHEMAS.size - 1\n \n-      if (version >= 0 && version <= 3) {\n+      if (0 to maxVersion contains version) {\n         val generationId = value.get(GENERATION_KEY).asInstanceOf[Int]\n         val protocolType = value.get(PROTOCOL_TYPE_KEY).asInstanceOf[String]\n         val protocol = value.get(PROTOCOL_KEY).asInstanceOf[String]\n         val leaderId = value.get(LEADER_KEY).asInstanceOf[String]\n         val memberMetadataArray = value.getArray(MEMBERS_KEY)\n         val initialState = if (memberMetadataArray.isEmpty) Empty else Stable\n         val currentStateTimestamp: Option[Long] = version match {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA0NjUxNg=="}, "originalCommit": {"oid": "fd8787a3df279ebd5e802008700b1c41a65f60ec"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2OTM4MDQ5OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQwNDo1NDoxNlrOHFCilA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQwNDo1NDoxNlrOHFCilA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA0NjU0OA==", "bodyText": "I'd keep the old code and simply change the second clause to use maxVersion.", "url": "https://github.com/apache/kafka/pull/9202#discussion_r475046548", "createdAt": "2020-08-22T04:54:16Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "diffHunk": "@@ -1401,16 +1401,17 @@ object GroupMetadataManager {\n       val version = buffer.getShort\n       val valueSchema = schemaForGroupValue(version)\n       val value = valueSchema.read(buffer)\n+      val maxVersion = GROUP_VALUE_SCHEMAS.size - 1\n \n-      if (version >= 0 && version <= 3) {\n+      if (0 to maxVersion contains version) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd8787a3df279ebd5e802008700b1c41a65f60ec"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNzcwMzIxOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNDoyMzowMVrOHPJ4bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODoyODowN1rOHPoy-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY1MjU5MQ==", "bodyText": "We should add a constant in GroupMetadataManager for this, maybe call it CURRENT_GROUP_METADATA_VALUE_SCHEMA_VERSION for consistency with the other two similar fields.", "url": "https://github.com/apache/kafka/pull/9202#discussion_r485652591", "createdAt": "2020-09-09T14:23:01Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "diffHunk": "@@ -1401,24 +1401,20 @@ object GroupMetadataManager {\n       val version = buffer.getShort\n       val valueSchema = schemaForGroupValue(version)\n       val value = valueSchema.read(buffer)\n+      val maxVersion = GROUP_VALUE_SCHEMAS.size - 1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "468505e65be60f0e3d2ce71ebe3af50966026289"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1OTA5Ng==", "bodyText": "Good suggestion! Updated.", "url": "https://github.com/apache/kafka/pull/9202#discussion_r486159096", "createdAt": "2020-09-10T08:28:07Z", "author": {"login": "showuon"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "diffHunk": "@@ -1401,24 +1401,20 @@ object GroupMetadataManager {\n       val version = buffer.getShort\n       val valueSchema = schemaForGroupValue(version)\n       val value = valueSchema.read(buffer)\n+      val maxVersion = GROUP_VALUE_SCHEMAS.size - 1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY1MjU5MQ=="}, "originalCommit": {"oid": "468505e65be60f0e3d2ce71ebe3af50966026289"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNzcwNTk4OnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNDoyMzozNVrOHPJ6Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNDoyMzozNVrOHPJ6Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY1MzAxOQ==", "bodyText": "Nit: un-supported -> unsupported.", "url": "https://github.com/apache/kafka/pull/9202#discussion_r485653019", "createdAt": "2020-09-09T14:23:35Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "diffHunk": "@@ -931,6 +932,42 @@ class GroupMetadataManagerTest {\n     assertTrue(group.has(memberId))\n   }\n \n+  @Test\n+  def testShouldThrowExceptionForUnsupportedGroupMetadataVersion(): Unit = {\n+    val generation = 1\n+    val protocol = \"range\"\n+    val memberId = \"memberId\"\n+    val unSupportedVersion = Short.MinValue\n+\n+    // put the un-supported version as the version value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "468505e65be60f0e3d2ce71ebe3af50966026289"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNzcwNzA2OnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNDoyMzo0OFrOHPJ6xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNDoyMzo0OFrOHPJ6xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY1MzE5MQ==", "bodyText": "Nit: unsupportedVersion.", "url": "https://github.com/apache/kafka/pull/9202#discussion_r485653191", "createdAt": "2020-09-09T14:23:48Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "diffHunk": "@@ -931,6 +932,42 @@ class GroupMetadataManagerTest {\n     assertTrue(group.has(memberId))\n   }\n \n+  @Test\n+  def testShouldThrowExceptionForUnsupportedGroupMetadataVersion(): Unit = {\n+    val generation = 1\n+    val protocol = \"range\"\n+    val memberId = \"memberId\"\n+    val unSupportedVersion = Short.MinValue", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "468505e65be60f0e3d2ce71ebe3af50966026289"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNzcxOTk3OnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNDoyNjoyMVrOHPKCyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNDoyNjoyMVrOHPKCyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY1NTI0Mg==", "bodyText": "Nit: TS -> Timestamp for clarity. Also, Version -> Versions.", "url": "https://github.com/apache/kafka/pull/9202#discussion_r485655242", "createdAt": "2020-09-09T14:26:21Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "diffHunk": "@@ -931,6 +932,42 @@ class GroupMetadataManagerTest {\n     assertTrue(group.has(memberId))\n   }\n \n+  @Test\n+  def testShouldThrowExceptionForUnsupportedGroupMetadataVersion(): Unit = {\n+    val generation = 1\n+    val protocol = \"range\"\n+    val memberId = \"memberId\"\n+    val unSupportedVersion = Short.MinValue\n+\n+    // put the un-supported version as the version value\n+    val groupMetadataRecordValue = buildStableGroupRecordWithMember(generation, protocolType, protocol, memberId)\n+      .value().putShort(unSupportedVersion)\n+    // reset the position to the starting position 0 so that it can read the data in correct order\n+    groupMetadataRecordValue.position(0)\n+\n+    val e = assertThrows(classOf[KafkaException],\n+      () => GroupMetadataManager.readGroupMessageValue(groupId, groupMetadataRecordValue, time))\n+    assertEquals(s\"Unknown group metadata version ${unSupportedVersion}\", e.getMessage)\n+  }\n+\n+  @Test\n+  def testCurrentStateTSForAllGroupMetadataVersion(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "468505e65be60f0e3d2ce71ebe3af50966026289"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNzcyNjM3OnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNDoyNzo0MVrOHPKGww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODozMTo0NVrOHPo8FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY1NjI1OQ==", "bodyText": "This fails without the change, right?", "url": "https://github.com/apache/kafka/pull/9202#discussion_r485656259", "createdAt": "2020-09-09T14:27:41Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "diffHunk": "@@ -931,6 +932,42 @@ class GroupMetadataManagerTest {\n     assertTrue(group.has(memberId))\n   }\n \n+  @Test\n+  def testShouldThrowExceptionForUnsupportedGroupMetadataVersion(): Unit = {\n+    val generation = 1\n+    val protocol = \"range\"\n+    val memberId = \"memberId\"\n+    val unSupportedVersion = Short.MinValue\n+\n+    // put the un-supported version as the version value\n+    val groupMetadataRecordValue = buildStableGroupRecordWithMember(generation, protocolType, protocol, memberId)\n+      .value().putShort(unSupportedVersion)\n+    // reset the position to the starting position 0 so that it can read the data in correct order\n+    groupMetadataRecordValue.position(0)\n+\n+    val e = assertThrows(classOf[KafkaException],\n+      () => GroupMetadataManager.readGroupMessageValue(groupId, groupMetadataRecordValue, time))\n+    assertEquals(s\"Unknown group metadata version ${unSupportedVersion}\", e.getMessage)\n+  }\n+\n+  @Test\n+  def testCurrentStateTSForAllGroupMetadataVersion(): Unit = {\n+    val generation = 1\n+    val protocol = \"range\"\n+    val memberId = \"memberId\"\n+\n+    for (apiVersion <- ApiVersion.allVersions) {\n+      val groupMetadataRecord = buildStableGroupRecordWithMember(generation, protocolType, protocol, memberId, apiVersion = apiVersion)\n+\n+      val deserializedGroupMetadata = GroupMetadataManager.readGroupMessageValue(groupId, groupMetadataRecord.value(), time)\n+      // GROUP_METADATA_VALUE_SCHEMA_V2 or higher should correctly set the currentStateTimestamp\n+      if (apiVersion >= KAFKA_2_1_IV0)\n+        assertEquals(time.milliseconds(), deserializedGroupMetadata.currentStateTimestamp.get)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "468505e65be60f0e3d2ce71ebe3af50966026289"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2MTQyOA==", "bodyText": "Correct! Also, after your question, I tried and found the message when test failed will be:\nkafka.coordinator.group.GroupMetadataManagerTest > testCurrentStateTimestampForAllGroupMetadataVersions FAILED\n    java.util.NoSuchElementException: None.get\n\nIt's not clear and not helpful for debugging. So I added failed message and use getOrElse(-1) to get an unexpected timestamp when none. Now, the failed message will be:\nkafka.coordinator.group.GroupMetadataManagerTest > testCurrentStateTimestampForAllGroupMetadataVersions FAILED\n    java.lang.AssertionError: the apiVersion 2.3-IV0 doesn't set the currentStateTimestamp correctly. expected:<1599726297785> but was:<-1>\n\nIt'll be more clear to show which version cause this error and what error it is.", "url": "https://github.com/apache/kafka/pull/9202#discussion_r486161428", "createdAt": "2020-09-10T08:31:45Z", "author": {"login": "showuon"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "diffHunk": "@@ -931,6 +932,42 @@ class GroupMetadataManagerTest {\n     assertTrue(group.has(memberId))\n   }\n \n+  @Test\n+  def testShouldThrowExceptionForUnsupportedGroupMetadataVersion(): Unit = {\n+    val generation = 1\n+    val protocol = \"range\"\n+    val memberId = \"memberId\"\n+    val unSupportedVersion = Short.MinValue\n+\n+    // put the un-supported version as the version value\n+    val groupMetadataRecordValue = buildStableGroupRecordWithMember(generation, protocolType, protocol, memberId)\n+      .value().putShort(unSupportedVersion)\n+    // reset the position to the starting position 0 so that it can read the data in correct order\n+    groupMetadataRecordValue.position(0)\n+\n+    val e = assertThrows(classOf[KafkaException],\n+      () => GroupMetadataManager.readGroupMessageValue(groupId, groupMetadataRecordValue, time))\n+    assertEquals(s\"Unknown group metadata version ${unSupportedVersion}\", e.getMessage)\n+  }\n+\n+  @Test\n+  def testCurrentStateTSForAllGroupMetadataVersion(): Unit = {\n+    val generation = 1\n+    val protocol = \"range\"\n+    val memberId = \"memberId\"\n+\n+    for (apiVersion <- ApiVersion.allVersions) {\n+      val groupMetadataRecord = buildStableGroupRecordWithMember(generation, protocolType, protocol, memberId, apiVersion = apiVersion)\n+\n+      val deserializedGroupMetadata = GroupMetadataManager.readGroupMessageValue(groupId, groupMetadataRecord.value(), time)\n+      // GROUP_METADATA_VALUE_SCHEMA_V2 or higher should correctly set the currentStateTimestamp\n+      if (apiVersion >= KAFKA_2_1_IV0)\n+        assertEquals(time.milliseconds(), deserializedGroupMetadata.currentStateTimestamp.get)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY1NjI1OQ=="}, "originalCommit": {"oid": "468505e65be60f0e3d2ce71ebe3af50966026289"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNzczMDMyOnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxNDoyODozMFrOHPKJUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwODozMzozN1rOHPpAzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY1NjkxNQ==", "bodyText": "Is this test related to the change or a gap you identified? It's fine if it's the latter, just trying to understand.", "url": "https://github.com/apache/kafka/pull/9202#discussion_r485656915", "createdAt": "2020-09-09T14:28:30Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "diffHunk": "@@ -931,6 +932,42 @@ class GroupMetadataManagerTest {\n     assertTrue(group.has(memberId))\n   }\n \n+  @Test\n+  def testShouldThrowExceptionForUnsupportedGroupMetadataVersion(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "468505e65be60f0e3d2ce71ebe3af50966026289"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2MjYzNw==", "bodyText": "This test doesn't relate to the change. I just like to add missing tests for what I saw. :)", "url": "https://github.com/apache/kafka/pull/9202#discussion_r486162637", "createdAt": "2020-09-10T08:33:37Z", "author": {"login": "showuon"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "diffHunk": "@@ -931,6 +932,42 @@ class GroupMetadataManagerTest {\n     assertTrue(group.has(memberId))\n   }\n \n+  @Test\n+  def testShouldThrowExceptionForUnsupportedGroupMetadataVersion(): Unit = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY1NjkxNQ=="}, "originalCommit": {"oid": "468505e65be60f0e3d2ce71ebe3af50966026289"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzU4Mjc4OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzo1MTo0MVrOHTjRIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDoxNjo1NlrOHTkgjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI2MjgxNw==", "bodyText": "This would be more robust if we did something like:\nGROUP_VALUE_SCHEMAS.keySet.max\nOr something along those lines.", "url": "https://github.com/apache/kafka/pull/9202#discussion_r490262817", "createdAt": "2020-09-17T13:51:41Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "diffHunk": "@@ -1139,6 +1139,7 @@ object GroupMetadataManager {\n \n   private val CURRENT_OFFSET_KEY_SCHEMA = schemaForKey(CURRENT_OFFSET_KEY_SCHEMA_VERSION)\n   private val CURRENT_GROUP_KEY_SCHEMA = schemaForKey(CURRENT_GROUP_KEY_SCHEMA_VERSION)\n+  private val CURRENT_GROUP_METADATA_VALUE_SCHEMA_VERSION = GROUP_VALUE_SCHEMAS.size - 1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f01aaa643840c871d613c9e0af538b79519f2667"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI4MzE0OA==", "bodyText": "good suggestion! Thanks.", "url": "https://github.com/apache/kafka/pull/9202#discussion_r490283148", "createdAt": "2020-09-17T14:16:56Z", "author": {"login": "showuon"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "diffHunk": "@@ -1139,6 +1139,7 @@ object GroupMetadataManager {\n \n   private val CURRENT_OFFSET_KEY_SCHEMA = schemaForKey(CURRENT_OFFSET_KEY_SCHEMA_VERSION)\n   private val CURRENT_GROUP_KEY_SCHEMA = schemaForKey(CURRENT_GROUP_KEY_SCHEMA_VERSION)\n+  private val CURRENT_GROUP_METADATA_VALUE_SCHEMA_VERSION = GROUP_VALUE_SCHEMAS.size - 1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI2MjgxNw=="}, "originalCommit": {"oid": "f01aaa643840c871d613c9e0af538b79519f2667"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2NzU5MDA4OnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxMzo1MzoxM1rOHTjVnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNDoxNjo1OFrOHTkgrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI2Mzk2NQ==", "bodyText": "I think it would be better to have the expected side be Some(time.milliseconds()), then you don't need the getOrElse on the actual side.", "url": "https://github.com/apache/kafka/pull/9202#discussion_r490263965", "createdAt": "2020-09-17T13:53:13Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "diffHunk": "@@ -931,6 +932,44 @@ class GroupMetadataManagerTest {\n     assertTrue(group.has(memberId))\n   }\n \n+  @Test\n+  def testShouldThrowExceptionForUnsupportedGroupMetadataVersion(): Unit = {\n+    val generation = 1\n+    val protocol = \"range\"\n+    val memberId = \"memberId\"\n+    val unsupportedVersion = Short.MinValue\n+\n+    // put the unsupported version as the version value\n+    val groupMetadataRecordValue = buildStableGroupRecordWithMember(generation, protocolType, protocol, memberId)\n+      .value().putShort(unsupportedVersion)\n+    // reset the position to the starting position 0 so that it can read the data in correct order\n+    groupMetadataRecordValue.position(0)\n+\n+    val e = assertThrows(classOf[KafkaException],\n+      () => GroupMetadataManager.readGroupMessageValue(groupId, groupMetadataRecordValue, time))\n+    assertEquals(s\"Unknown group metadata version ${unsupportedVersion}\", e.getMessage)\n+  }\n+\n+  @Test\n+  def testCurrentStateTimestampForAllGroupMetadataVersions(): Unit = {\n+    val generation = 1\n+    val protocol = \"range\"\n+    val memberId = \"memberId\"\n+\n+    for (apiVersion <- ApiVersion.allVersions) {\n+      val groupMetadataRecord = buildStableGroupRecordWithMember(generation, protocolType, protocol, memberId, apiVersion = apiVersion)\n+\n+      val deserializedGroupMetadata = GroupMetadataManager.readGroupMessageValue(groupId, groupMetadataRecord.value(), time)\n+      // GROUP_METADATA_VALUE_SCHEMA_V2 or higher should correctly set the currentStateTimestamp\n+      if (apiVersion >= KAFKA_2_1_IV0)\n+        assertEquals(s\"the apiVersion $apiVersion doesn't set the currentStateTimestamp correctly.\",\n+          time.milliseconds(), deserializedGroupMetadata.currentStateTimestamp.getOrElse(-1))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f01aaa643840c871d613c9e0af538b79519f2667"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI4MzE4MA==", "bodyText": "Good suggestion! Thanks.", "url": "https://github.com/apache/kafka/pull/9202#discussion_r490283180", "createdAt": "2020-09-17T14:16:58Z", "author": {"login": "showuon"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupMetadataManagerTest.scala", "diffHunk": "@@ -931,6 +932,44 @@ class GroupMetadataManagerTest {\n     assertTrue(group.has(memberId))\n   }\n \n+  @Test\n+  def testShouldThrowExceptionForUnsupportedGroupMetadataVersion(): Unit = {\n+    val generation = 1\n+    val protocol = \"range\"\n+    val memberId = \"memberId\"\n+    val unsupportedVersion = Short.MinValue\n+\n+    // put the unsupported version as the version value\n+    val groupMetadataRecordValue = buildStableGroupRecordWithMember(generation, protocolType, protocol, memberId)\n+      .value().putShort(unsupportedVersion)\n+    // reset the position to the starting position 0 so that it can read the data in correct order\n+    groupMetadataRecordValue.position(0)\n+\n+    val e = assertThrows(classOf[KafkaException],\n+      () => GroupMetadataManager.readGroupMessageValue(groupId, groupMetadataRecordValue, time))\n+    assertEquals(s\"Unknown group metadata version ${unsupportedVersion}\", e.getMessage)\n+  }\n+\n+  @Test\n+  def testCurrentStateTimestampForAllGroupMetadataVersions(): Unit = {\n+    val generation = 1\n+    val protocol = \"range\"\n+    val memberId = \"memberId\"\n+\n+    for (apiVersion <- ApiVersion.allVersions) {\n+      val groupMetadataRecord = buildStableGroupRecordWithMember(generation, protocolType, protocol, memberId, apiVersion = apiVersion)\n+\n+      val deserializedGroupMetadata = GroupMetadataManager.readGroupMessageValue(groupId, groupMetadataRecord.value(), time)\n+      // GROUP_METADATA_VALUE_SCHEMA_V2 or higher should correctly set the currentStateTimestamp\n+      if (apiVersion >= KAFKA_2_1_IV0)\n+        assertEquals(s\"the apiVersion $apiVersion doesn't set the currentStateTimestamp correctly.\",\n+          time.milliseconds(), deserializedGroupMetadata.currentStateTimestamp.getOrElse(-1))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDI2Mzk2NQ=="}, "originalCommit": {"oid": "f01aaa643840c871d613c9e0af538b79519f2667"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3Mzg4ODIyOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOVQwMDowODo0NVrOHUe9-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjo0NjowNFrOHVZuIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0MDk1Mw==", "bodyText": "I wonder if the version check is necessary. Is the presence of the field enough?", "url": "https://github.com/apache/kafka/pull/9202#discussion_r491240953", "createdAt": "2020-09-19T00:08:45Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "diffHunk": "@@ -1402,23 +1403,18 @@ object GroupMetadataManager {\n       val valueSchema = schemaForGroupValue(version)\n       val value = valueSchema.read(buffer)\n \n-      if (version >= 0 && version <= 3) {\n+      if (version >= 0 && version <= CURRENT_GROUP_METADATA_VALUE_SCHEMA_VERSION) {\n         val generationId = value.get(GENERATION_KEY).asInstanceOf[Int]\n         val protocolType = value.get(PROTOCOL_TYPE_KEY).asInstanceOf[String]\n         val protocol = value.get(PROTOCOL_KEY).asInstanceOf[String]\n         val leaderId = value.get(LEADER_KEY).asInstanceOf[String]\n         val memberMetadataArray = value.getArray(MEMBERS_KEY)\n         val initialState = if (memberMetadataArray.isEmpty) Empty else Stable\n-        val currentStateTimestamp: Option[Long] = version match {\n-          case version if version == 2 =>\n-            if (value.hasField(CURRENT_STATE_TIMESTAMP_KEY)) {\n-              val timestamp = value.getLong(CURRENT_STATE_TIMESTAMP_KEY)\n-              if (timestamp == -1) None else Some(timestamp)\n-            } else\n-              None\n-          case _ =>\n-            None\n-        }\n+        val currentStateTimestamp: Option[Long] =\n+          if (version >= 2 && value.hasField(CURRENT_STATE_TIMESTAMP_KEY)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85b0b7a459a4e6c9fb3c49a976b1c75062b12e3b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkwODU0Mg==", "bodyText": "@hachikuji , well, you're right, the CURRENT_STATE_TIMESTAMP_KEY field only set in version >= 2... in normal cases. I'm not sure if there's possibility that there will be version 0 or 1 containing the CURRENT_STATE_TIMESTAMP_KEY field situation. In my opinion, I think the check is OK and make it more robust, and most importantly, it's a simple check, not too many overhead to the resource. What do you think?", "url": "https://github.com/apache/kafka/pull/9202#discussion_r491908542", "createdAt": "2020-09-21T09:37:32Z", "author": {"login": "showuon"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "diffHunk": "@@ -1402,23 +1403,18 @@ object GroupMetadataManager {\n       val valueSchema = schemaForGroupValue(version)\n       val value = valueSchema.read(buffer)\n \n-      if (version >= 0 && version <= 3) {\n+      if (version >= 0 && version <= CURRENT_GROUP_METADATA_VALUE_SCHEMA_VERSION) {\n         val generationId = value.get(GENERATION_KEY).asInstanceOf[Int]\n         val protocolType = value.get(PROTOCOL_TYPE_KEY).asInstanceOf[String]\n         val protocol = value.get(PROTOCOL_KEY).asInstanceOf[String]\n         val leaderId = value.get(LEADER_KEY).asInstanceOf[String]\n         val memberMetadataArray = value.getArray(MEMBERS_KEY)\n         val initialState = if (memberMetadataArray.isEmpty) Empty else Stable\n-        val currentStateTimestamp: Option[Long] = version match {\n-          case version if version == 2 =>\n-            if (value.hasField(CURRENT_STATE_TIMESTAMP_KEY)) {\n-              val timestamp = value.getLong(CURRENT_STATE_TIMESTAMP_KEY)\n-              if (timestamp == -1) None else Some(timestamp)\n-            } else\n-              None\n-          case _ =>\n-            None\n-        }\n+        val currentStateTimestamp: Option[Long] =\n+          if (version >= 2 && value.hasField(CURRENT_STATE_TIMESTAMP_KEY)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0MDk1Mw=="}, "originalCommit": {"oid": "85b0b7a459a4e6c9fb3c49a976b1c75062b12e3b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIwMzU1NQ==", "bodyText": "No strong opinion. I'm ok leaving the check.", "url": "https://github.com/apache/kafka/pull/9202#discussion_r492203555", "createdAt": "2020-09-21T16:46:04Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala", "diffHunk": "@@ -1402,23 +1403,18 @@ object GroupMetadataManager {\n       val valueSchema = schemaForGroupValue(version)\n       val value = valueSchema.read(buffer)\n \n-      if (version >= 0 && version <= 3) {\n+      if (version >= 0 && version <= CURRENT_GROUP_METADATA_VALUE_SCHEMA_VERSION) {\n         val generationId = value.get(GENERATION_KEY).asInstanceOf[Int]\n         val protocolType = value.get(PROTOCOL_TYPE_KEY).asInstanceOf[String]\n         val protocol = value.get(PROTOCOL_KEY).asInstanceOf[String]\n         val leaderId = value.get(LEADER_KEY).asInstanceOf[String]\n         val memberMetadataArray = value.getArray(MEMBERS_KEY)\n         val initialState = if (memberMetadataArray.isEmpty) Empty else Stable\n-        val currentStateTimestamp: Option[Long] = version match {\n-          case version if version == 2 =>\n-            if (value.hasField(CURRENT_STATE_TIMESTAMP_KEY)) {\n-              val timestamp = value.getLong(CURRENT_STATE_TIMESTAMP_KEY)\n-              if (timestamp == -1) None else Some(timestamp)\n-            } else\n-              None\n-          case _ =>\n-            None\n-        }\n+        val currentStateTimestamp: Option[Long] =\n+          if (version >= 2 && value.hasField(CURRENT_STATE_TIMESTAMP_KEY)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTI0MDk1Mw=="}, "originalCommit": {"oid": "85b0b7a459a4e6c9fb3c49a976b1c75062b12e3b"}, "originalPosition": 31}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1938, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}