{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxODM3MDM3", "number": 8712, "reviewThreads": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDoyMjozMFrOD-99ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjo1ODoyNFrOEKMRYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzUzNDQ1OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDoyMjozMFrOGZY9-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMzowNjoyN1rOGn9idw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI3NjY2NA==", "bodyText": "the log should put remainingRetries since it's logging with {} retries left", "url": "https://github.com/apache/kafka/pull/8712#discussion_r429276664", "createdAt": "2020-05-22T14:22:30Z", "author": {"login": "showuon"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -157,16 +161,16 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n             }\n \n \n-            if (!topicsNotReady.isEmpty()) {\n-                log.info(\"Topics {} can not be made ready with {} retries left\", topicsNotReady, retries);\n+            if (isNeedRetry(topicsNotReady)) {\n+                log.info(\"Topics {} can not be made ready with {} retries left\", topicsNotReady, remainingRetries);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NTg5NQ==", "bodyText": "Good catch", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444555895", "createdAt": "2020-06-23T23:06:27Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -157,16 +161,16 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n             }\n \n \n-            if (!topicsNotReady.isEmpty()) {\n-                log.info(\"Topics {} can not be made ready with {} retries left\", topicsNotReady, retries);\n+            if (isNeedRetry(topicsNotReady)) {\n+                log.info(\"Topics {} can not be made ready with {} retries left\", topicsNotReady, remainingRetries);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI3NjY2NA=="}, "originalCommit": null, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzYwOTA3OnYy", "diffSide": "RIGHT", "path": "clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo0MTo0OFrOGZZsAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMzowMTo0N1rOGn9cgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4ODQ0OQ==", "bodyText": "Try to simulate the LeaderNotAvailableException in the MockAdminClient, if the topic name isLeaderNotAvailableTopic.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r429288449", "createdAt": "2020-05-22T14:41:48Z", "author": {"login": "showuon"}, "path": "clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java", "diffHunk": "@@ -330,6 +331,12 @@ synchronized public DescribeTopicsResult describeTopics(Collection<String> topic\n                 future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                 topicDescriptions.put(requestedTopic, future);\n             }\n+            // try to simulate the leader not available situation when topic name is \"LeaderNotAvailableTopic\"\n+            if (requestedTopic.equals(\"LeaderNotAvailableTopic\")) {\n+                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n+                future.completeExceptionally(new LeaderNotAvailableException(\"The leader of Topic \" + requestedTopic + \" is not available.\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "608e52b86d40de8b4031894d7a513869a65dd6bb"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NDM2OA==", "bodyText": "Is it possible to use EasyMock instead of adding this to the actual MockAdminClient? I know it's kind of a pain to set up but I think it'll make the test a lot more clear. I did something similar in StreamsPartitionAssignorTest to mock the results of the listOffsets request", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444554368", "createdAt": "2020-06-23T23:01:47Z", "author": {"login": "ableegoldman"}, "path": "clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java", "diffHunk": "@@ -330,6 +331,12 @@ synchronized public DescribeTopicsResult describeTopics(Collection<String> topic\n                 future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                 topicDescriptions.put(requestedTopic, future);\n             }\n+            // try to simulate the leader not available situation when topic name is \"LeaderNotAvailableTopic\"\n+            if (requestedTopic.equals(\"LeaderNotAvailableTopic\")) {\n+                KafkaFutureImpl<TopicDescription> future = new KafkaFutureImpl<>();\n+                future.completeExceptionally(new LeaderNotAvailableException(\"The leader of Topic \" + requestedTopic + \" is not available.\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4ODQ0OQ=="}, "originalCommit": {"oid": "608e52b86d40de8b4031894d7a513869a65dd6bb"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzYxNDU2OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo0MzoyMFrOGZZvpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDo0MzoyMFrOGZZvpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4OTM4MA==", "bodyText": "If there's topic with LeaderNotAvailableException, we also need to retry.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r429289380", "createdAt": "2020-05-22T14:43:20Z", "author": {"login": "showuon"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -247,11 +261,19 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n                     log.error(errorMsg);\n                     throw new StreamsException(errorMsg);\n                 }\n-            } else {\n+            } else if (!needRetryTopics.contains(topicName)) {\n                 topicsToCreate.add(topicName);\n             }\n         }\n \n         return topicsToCreate;\n     }\n+\n+    private boolean isNeedRetry(final Set<String> topicsNotReady) {\n+        return !topicsNotReady.isEmpty() || hasNeedRetryTopic();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "608e52b86d40de8b4031894d7a513869a65dd6bb"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzY3MTM4OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNjo0NToxNVrOGgElfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjoyNzowNVrOGgQmGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mjc1MQ==", "bodyText": "This should be declared final.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436282751", "createdAt": "2020-06-06T16:45:15Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -59,6 +59,9 @@ private InternalAdminClientConfig(final Map<?, ?> props) {\n \n     private final int retries;\n     private final long retryBackOffMs;\n+    private int remainingRetries;\n+\n+    private HashSet<String> leaderNotAvailableTopics = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mzc0NQ==", "bodyText": "Similar to this struct, it doesn't make sense to have a non-empty leaderNotAvailableTopics after each call to makeReady, I would prefer building it as local variable, cc @ableegoldman", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436283745", "createdAt": "2020-06-06T16:58:02Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -59,6 +59,9 @@ private InternalAdminClientConfig(final Map<?, ?> props) {\n \n     private final int retries;\n     private final long retryBackOffMs;\n+    private int remainingRetries;\n+\n+    private HashSet<String> leaderNotAvailableTopics = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mjc1MQ=="}, "originalCommit": {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3OTUxNQ==", "bodyText": "Oh, Nice catch! You're correct, @abbccdda , it might have a non-empty leaderNotAvailableTopics after each call to makeReady. I changed it to using local variable. Thank you.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436479515", "createdAt": "2020-06-08T06:27:05Z", "author": {"login": "showuon"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -59,6 +59,9 @@ private InternalAdminClientConfig(final Map<?, ?> props) {\n \n     private final int retries;\n     private final long retryBackOffMs;\n+    private int remainingRetries;\n+\n+    private HashSet<String> leaderNotAvailableTopics = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mjc1MQ=="}, "originalCommit": {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzY3MjcwOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNjo0NzoyMVrOGgEmKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzo0NTo0MlrOGgObew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjkyMw==", "bodyText": "This contains check is unnecessary.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436282923", "createdAt": "2020-06-06T16:47:21Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -195,20 +198,30 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n             final String topicName = topicFuture.getKey();\n             try {\n                 final TopicDescription topicDescription = topicFuture.getValue().get();\n-                existedTopicPartition.put(\n-                    topicFuture.getKey(),\n-                    topicDescription.partitions().size());\n+                existedTopicPartition.put(topicName, topicDescription.partitions().size());\n+                if (leaderNotAvailableTopics.contains(topicName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDAyNw==", "bodyText": "Good point! The remove method will return true/false for key found/not found. Fixed.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436444027", "createdAt": "2020-06-08T03:45:42Z", "author": {"login": "showuon"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -195,20 +198,30 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n             final String topicName = topicFuture.getKey();\n             try {\n                 final TopicDescription topicDescription = topicFuture.getValue().get();\n-                existedTopicPartition.put(\n-                    topicFuture.getKey(),\n-                    topicDescription.partitions().size());\n+                existedTopicPartition.put(topicName, topicDescription.partitions().size());\n+                if (leaderNotAvailableTopics.contains(topicName)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjkyMw=="}, "originalCommit": {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzY3NzExOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNjo1NDoyMFrOGgEoUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNToxNToxOFrOGgPckw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MzQ3Mw==", "bodyText": "This is a personal preference, but I think we should not attempt to include a temporal variable as part of the class struct. We could change the internal function signatures to pass around remainingRetries (like validateTopics) instead.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436283473", "createdAt": "2020-06-06T16:54:20Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -100,11 +103,11 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         // have existed with the expected number of partitions, or some create topic returns fatal errors.\n         log.debug(\"Starting to validate internal topics {} in partition assignor.\", topics);\n \n-        int remainingRetries = retries;\n+        remainingRetries = retries;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ2MDY5MQ==", "bodyText": "OK, fixed. Thanks.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436460691", "createdAt": "2020-06-08T05:15:18Z", "author": {"login": "showuon"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -100,11 +103,11 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         // have existed with the expected number of partitions, or some create topic returns fatal errors.\n         log.debug(\"Starting to validate internal topics {} in partition assignor.\", topics);\n \n-        int remainingRetries = retries;\n+        remainingRetries = retries;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MzQ3Mw=="}, "originalCommit": {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzY4MDk2OnYy", "diffSide": "RIGHT", "path": "clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNzowMTozNVrOGgEqQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNDowMDoyNlrOGgOlWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mzk2OQ==", "bodyText": "This workaround is very hard to be found by other developers, as a minimum we should define a constant and make it part of MockAdminClient class", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436283969", "createdAt": "2020-06-06T17:01:35Z", "author": {"login": "abbccdda"}, "path": "clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java", "diffHunk": "@@ -330,6 +331,12 @@ synchronized public DescribeTopicsResult describeTopics(Collection<String> topic\n                 future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                 topicDescriptions.put(requestedTopic, future);\n             }\n+            // try to simulate the leader not available situation when topic name is \"LeaderNotAvailableTopic\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NjU1Mg==", "bodyText": "Good suggestion. I put it as a constant. Thanks.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436446552", "createdAt": "2020-06-08T04:00:26Z", "author": {"login": "showuon"}, "path": "clients/src/test/java/org/apache/kafka/clients/admin/MockAdminClient.java", "diffHunk": "@@ -330,6 +331,12 @@ synchronized public DescribeTopicsResult describeTopics(Collection<String> topic\n                 future.completeExceptionally(new UnknownTopicOrPartitionException(\"Topic \" + requestedTopic + \" not found.\"));\n                 topicDescriptions.put(requestedTopic, future);\n             }\n+            // try to simulate the leader not available situation when topic name is \"LeaderNotAvailableTopic\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4Mzk2OQ=="}, "originalCommit": {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzY4MTU4OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNlQxNzowMjo0MFrOGgEqkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNDowMjoyOFrOGgOmuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDA0OQ==", "bodyText": "Testing against log message is error-prone and hard to maintain, I think just making sure the thrown exception type is expected should be sufficient.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436284049", "createdAt": "2020-06-06T17:02:40Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,49 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldLogWhenTopicLeaderNotAvailableAndThrowException() {\n+        final String topicLeaderNotAvailable = \"LeaderNotAvailableTopic\";\n+        mockAdminClient.addTopic(\n+            false,\n+            topicLeaderNotAvailable,\n+            Collections.singletonList(new TopicPartitionInfo(0, broker1, cluster, Collections.emptyList())),\n+            null);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(topicLeaderNotAvailable, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(topicLeaderNotAvailable, internalTopicConfig);\n+\n+        LogCaptureAppender.setClassLoggerToDebug(InternalTopicManager.class);\n+        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister(InternalTopicManager.class)) {\n+            final StreamsException exception = assertThrows(\n+                StreamsException.class,\n+                () -> internalTopicManager.makeReady(topicConfigMap));\n+\n+            final String expectedMessage = \"Could not create topics after 1 retries. This can happen if the Kafka cluster is temporary not available\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NjkwNw==", "bodyText": "Good suggestion. Remove the log message check and only verify the exception thrown. Thanks.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r436446907", "createdAt": "2020-06-08T04:02:28Z", "author": {"login": "showuon"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,49 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldLogWhenTopicLeaderNotAvailableAndThrowException() {\n+        final String topicLeaderNotAvailable = \"LeaderNotAvailableTopic\";\n+        mockAdminClient.addTopic(\n+            false,\n+            topicLeaderNotAvailable,\n+            Collections.singletonList(new TopicPartitionInfo(0, broker1, cluster, Collections.emptyList())),\n+            null);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(topicLeaderNotAvailable, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(topicLeaderNotAvailable, internalTopicConfig);\n+\n+        LogCaptureAppender.setClassLoggerToDebug(InternalTopicManager.class);\n+        try (final LogCaptureAppender appender = LogCaptureAppender.createAndRegister(InternalTopicManager.class)) {\n+            final StreamsException exception = assertThrows(\n+                StreamsException.class,\n+                () -> internalTopicManager.makeReady(topicConfigMap));\n+\n+            final String expectedMessage = \"Could not create topics after 1 retries. This can happen if the Kafka cluster is temporary not available\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDA0OQ=="}, "originalCommit": {"oid": "ad65f10b93d52921e1ccdd8f459a7f72d6c7cbf6"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTk1MDEzOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMzowNTo1OFrOGn9hzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwODo0NDo0N1rOGoIwrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NTcyNA==", "bodyText": "Can we give this a more descriptive name? It might be obvious to you, but I think someone just looking at this code for the first time would not get that this actually means topics that may or may not already exist.\nThat said, I'm struggling to think of a good alternative...maybe possiblyCreatedTopics or unknownTopics...any better ideas?", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444555724", "createdAt": "2020-06-23T23:05:58Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -98,9 +98,10 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         int remainingRetries = retries;\n         Set<String> topicsNotReady = new HashSet<>(topics.keySet());\n         final Set<String> newlyCreatedTopics = new HashSet<>();\n+        final HashSet<String> leaderNotAvailableTopics = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0567ecbc82c01b0c6e596fe5c28918f3b530a263"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDczOTc1OA==", "bodyText": "Good suggestion, I changed to tempUnknownTopics, because they are temporarily unknown topics for now. How do you think?", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444739758", "createdAt": "2020-06-24T08:44:47Z", "author": {"login": "showuon"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -98,9 +98,10 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         int remainingRetries = retries;\n         Set<String> topicsNotReady = new HashSet<>(topics.keySet());\n         final Set<String> newlyCreatedTopics = new HashSet<>();\n+        final HashSet<String> leaderNotAvailableTopics = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NTcyNA=="}, "originalCommit": {"oid": "0567ecbc82c01b0c6e596fe5c28918f3b530a263"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2OTk1NTc0OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMzowODozMlrOGn9lGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwODo0Njo1N1rOGoI1rQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NjU2OA==", "bodyText": "Can we just use !isEmpty for both sets?", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444556568", "createdAt": "2020-06-23T23:08:32Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -242,11 +256,16 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n                     log.error(errorMsg);\n                     throw new StreamsException(errorMsg);\n                 }\n-            } else {\n+            } else if (!leaderNotAvailableTopics.contains(topicName)) {\n                 topicsToCreate.add(topicName);\n             }\n         }\n \n         return topicsToCreate;\n     }\n+\n+    private boolean shouldRetry(final Set<String> topicsNotReady, final HashSet<String> leaderNotAvailableTopics) {\n+        // If there's topic with LeaderNotAvailableException, we still need retry\n+        return !topicsNotReady.isEmpty() || leaderNotAvailableTopics.size() > 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0567ecbc82c01b0c6e596fe5c28918f3b530a263"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc0MTAzNw==", "bodyText": "Good suggestion. Updated.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r444741037", "createdAt": "2020-06-24T08:46:57Z", "author": {"login": "showuon"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -242,11 +256,16 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n                     log.error(errorMsg);\n                     throw new StreamsException(errorMsg);\n                 }\n-            } else {\n+            } else if (!leaderNotAvailableTopics.contains(topicName)) {\n                 topicsToCreate.add(topicName);\n             }\n         }\n \n         return topicsToCreate;\n     }\n+\n+    private boolean shouldRetry(final Set<String> topicsNotReady, final HashSet<String> leaderNotAvailableTopics) {\n+        // If there's topic with LeaderNotAvailableException, we still need retry\n+        return !topicsNotReady.isEmpty() || leaderNotAvailableTopics.size() > 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU1NjU2OA=="}, "originalCommit": {"oid": "0567ecbc82c01b0c6e596fe5c28918f3b530a263"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzU2MTQxOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTo1NDo1M1rOGog5XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDoyODo0MFrOGo9Wmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNTE5Ng==", "bodyText": "s/HashSet/Set?", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445135196", "createdAt": "2020-06-24T19:54:53Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -98,9 +98,10 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         int remainingRetries = retries;\n         Set<String> topicsNotReady = new HashSet<>(topics.keySet());\n         final Set<String> newlyCreatedTopics = new HashSet<>();\n+        final HashSet<String> tempUnknownTopics = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTQzNQ==", "bodyText": "Fixed. Thanks.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601435", "createdAt": "2020-06-25T14:28:40Z", "author": {"login": "showuon"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -98,9 +98,10 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         int remainingRetries = retries;\n         Set<String> topicsNotReady = new HashSet<>(topics.keySet());\n         final Set<String> newlyCreatedTopics = new HashSet<>();\n+        final HashSet<String> tempUnknownTopics = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNTE5Ng=="}, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzU2NzQ5OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTo1Njo0NFrOGog9MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDoyODozN1rOGo9WbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNjE3Nw==", "bodyText": "Could be merged with above else", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445136177", "createdAt": "2020-06-24T19:56:44Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -243,10 +259,18 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n                     throw new StreamsException(errorMsg);\n                 }\n             } else {\n-                topicsToCreate.add(topicName);\n+                // for the tempUnknownTopics, we'll check again later if retries > 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTM4OA==", "bodyText": "Fixed", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601388", "createdAt": "2020-06-25T14:28:37Z", "author": {"login": "showuon"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -243,10 +259,18 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n                     throw new StreamsException(errorMsg);\n                 }\n             } else {\n-                topicsToCreate.add(topicName);\n+                // for the tempUnknownTopics, we'll check again later if retries > 0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNjE3Nw=="}, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzU3MzU0OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTo1ODoyNVrOGohA-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDoyODozNVrOGo9WSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNzE0Ng==", "bodyText": "Use 4 space format to align with other tests.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445137146", "createdAt": "2020-06-24T19:58:25Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +291,41 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldLogWhenTopicLeaderNotAvailableAndThrowException() {\n+        final String leaderNotAvailableTopic = \"LeaderNotAvailableTopic\";\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+\n+        // simulate describeTopics got LeaderNotAvailableException\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+                .andReturn(new MockDescribeTopicsResult(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTM1Mg==", "bodyText": "Nice catch! Fixed.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601352", "createdAt": "2020-06-25T14:28:35Z", "author": {"login": "showuon"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +291,41 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldLogWhenTopicLeaderNotAvailableAndThrowException() {\n+        final String leaderNotAvailableTopic = \"LeaderNotAvailableTopic\";\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+\n+        // simulate describeTopics got LeaderNotAvailableException\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+                .andReturn(new MockDescribeTopicsResult(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzNzE0Ng=="}, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NDQ2NDc4OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwMjo0Njo0MFrOGoplbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDoyODozMlrOGo9WLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3NzU0OQ==", "bodyText": "We could just pass in a boolean here to indicate whether there are remaining retries", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445277549", "createdAt": "2020-06-25T02:46:40Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -179,31 +180,43 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n      * Topics that were not able to get its description will simply not be returned\n      */\n     // visible for testing\n-    protected Map<String, Integer> getNumPartitions(final Set<String> topics) {\n-        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", topics);\n-\n-        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(topics);\n+    protected Map<String, Integer> getNumPartitions(final Set<String> topics,\n+                                                    final HashSet<String> tempUnknownTopics,\n+                                                    final int remainingRetries) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTMyNQ==", "bodyText": "Updated.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601325", "createdAt": "2020-06-25T14:28:32Z", "author": {"login": "showuon"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -179,31 +180,43 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n      * Topics that were not able to get its description will simply not be returned\n      */\n     // visible for testing\n-    protected Map<String, Integer> getNumPartitions(final Set<String> topics) {\n-        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", topics);\n-\n-        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(topics);\n+    protected Map<String, Integer> getNumPartitions(final Set<String> topics,\n+                                                    final HashSet<String> tempUnknownTopics,\n+                                                    final int remainingRetries) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3NzU0OQ=="}, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NDQ2NzQ0OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwMjo0ODoyMFrOGopnCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDoyODoyOVrOGo9V_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3Nzk2MQ==", "bodyText": "Could reduce the if-else block as:\nif (remainingRetries <= 0) {\n  // run out of retries, throw exception directly \n  throw new StreamsException(\n    String.format(\"The leader of the Topic %s is not available after %d retries.\", topicName, retries), cause);\n }\n log.debug(\"The leader of the Topic {} is not available, with {} retries left.\\n\" +\n   \"Error message was: {}\", topicName, remainingRetries, cause.toString());", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445277961", "createdAt": "2020-06-25T02:48:20Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -179,31 +180,43 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n      * Topics that were not able to get its description will simply not be returned\n      */\n     // visible for testing\n-    protected Map<String, Integer> getNumPartitions(final Set<String> topics) {\n-        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", topics);\n-\n-        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(topics);\n+    protected Map<String, Integer> getNumPartitions(final Set<String> topics,\n+                                                    final HashSet<String> tempUnknownTopics,\n+                                                    final int remainingRetries) {\n+        final Set<String> allTopicsToDescribe = new HashSet<>(topics);\n+        allTopicsToDescribe.addAll(tempUnknownTopics);\n+        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", allTopicsToDescribe);\n+\n+        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(allTopicsToDescribe);\n         final Map<String, KafkaFuture<TopicDescription>> futures = describeTopicsResult.values();\n \n         final Map<String, Integer> existedTopicPartition = new HashMap<>();\n         for (final Map.Entry<String, KafkaFuture<TopicDescription>> topicFuture : futures.entrySet()) {\n             final String topicName = topicFuture.getKey();\n             try {\n                 final TopicDescription topicDescription = topicFuture.getValue().get();\n-                existedTopicPartition.put(\n-                    topicFuture.getKey(),\n-                    topicDescription.partitions().size());\n+                existedTopicPartition.put(topicName, topicDescription.partitions().size());\n+                tempUnknownTopics.remove(topicName);\n             } catch (final InterruptedException fatalException) {\n                 // this should not happen; if it ever happens it indicate a bug\n                 Thread.currentThread().interrupt();\n                 log.error(INTERRUPTED_ERROR_MESSAGE, fatalException);\n                 throw new IllegalStateException(INTERRUPTED_ERROR_MESSAGE, fatalException);\n             } catch (final ExecutionException couldNotDescribeTopicException) {\n                 final Throwable cause = couldNotDescribeTopicException.getCause();\n-                if (cause instanceof UnknownTopicOrPartitionException ||\n-                    cause instanceof LeaderNotAvailableException) {\n-                    // This topic didn't exist or leader is not known yet, proceed to try to create it\n-                    log.debug(\"Topic {} is unknown or not found, hence not existed yet: {}\", topicName, cause.toString());\n+                if (cause instanceof UnknownTopicOrPartitionException) {\n+                    // This topic didn't exist, proceed to try to create it\n+                    log.debug(\"Topic {} is unknown or not found, hence not existed yet.\\n\" +\n+                        \"Error message was: {}\", topicName, cause.toString());\n+                } else if (cause instanceof LeaderNotAvailableException) {\n+                    tempUnknownTopics.add(topicName);\n+                    if (remainingRetries > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTI3OQ==", "bodyText": "Updated.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601279", "createdAt": "2020-06-25T14:28:29Z", "author": {"login": "showuon"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -179,31 +180,43 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n      * Topics that were not able to get its description will simply not be returned\n      */\n     // visible for testing\n-    protected Map<String, Integer> getNumPartitions(final Set<String> topics) {\n-        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", topics);\n-\n-        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(topics);\n+    protected Map<String, Integer> getNumPartitions(final Set<String> topics,\n+                                                    final HashSet<String> tempUnknownTopics,\n+                                                    final int remainingRetries) {\n+        final Set<String> allTopicsToDescribe = new HashSet<>(topics);\n+        allTopicsToDescribe.addAll(tempUnknownTopics);\n+        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", allTopicsToDescribe);\n+\n+        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(allTopicsToDescribe);\n         final Map<String, KafkaFuture<TopicDescription>> futures = describeTopicsResult.values();\n \n         final Map<String, Integer> existedTopicPartition = new HashMap<>();\n         for (final Map.Entry<String, KafkaFuture<TopicDescription>> topicFuture : futures.entrySet()) {\n             final String topicName = topicFuture.getKey();\n             try {\n                 final TopicDescription topicDescription = topicFuture.getValue().get();\n-                existedTopicPartition.put(\n-                    topicFuture.getKey(),\n-                    topicDescription.partitions().size());\n+                existedTopicPartition.put(topicName, topicDescription.partitions().size());\n+                tempUnknownTopics.remove(topicName);\n             } catch (final InterruptedException fatalException) {\n                 // this should not happen; if it ever happens it indicate a bug\n                 Thread.currentThread().interrupt();\n                 log.error(INTERRUPTED_ERROR_MESSAGE, fatalException);\n                 throw new IllegalStateException(INTERRUPTED_ERROR_MESSAGE, fatalException);\n             } catch (final ExecutionException couldNotDescribeTopicException) {\n                 final Throwable cause = couldNotDescribeTopicException.getCause();\n-                if (cause instanceof UnknownTopicOrPartitionException ||\n-                    cause instanceof LeaderNotAvailableException) {\n-                    // This topic didn't exist or leader is not known yet, proceed to try to create it\n-                    log.debug(\"Topic {} is unknown or not found, hence not existed yet: {}\", topicName, cause.toString());\n+                if (cause instanceof UnknownTopicOrPartitionException) {\n+                    // This topic didn't exist, proceed to try to create it\n+                    log.debug(\"Topic {} is unknown or not found, hence not existed yet.\\n\" +\n+                        \"Error message was: {}\", topicName, cause.toString());\n+                } else if (cause instanceof LeaderNotAvailableException) {\n+                    tempUnknownTopics.add(topicName);\n+                    if (remainingRetries > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3Nzk2MQ=="}, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NDQ3MDc5OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwMjo1MDoyNVrOGopo-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNTowMDowOFrOGo-zGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODQ1Nw==", "bodyText": "Why do we need allTopicsToDescribe? It seems only queried once locally.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445278457", "createdAt": "2020-06-25T02:50:25Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -179,31 +180,43 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n      * Topics that were not able to get its description will simply not be returned\n      */\n     // visible for testing\n-    protected Map<String, Integer> getNumPartitions(final Set<String> topics) {\n-        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", topics);\n-\n-        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(topics);\n+    protected Map<String, Integer> getNumPartitions(final Set<String> topics,\n+                                                    final HashSet<String> tempUnknownTopics,\n+                                                    final int remainingRetries) {\n+        final Set<String> allTopicsToDescribe = new HashSet<>(topics);\n+        allTopicsToDescribe.addAll(tempUnknownTopics);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYyNTExMg==", "bodyText": "The allTopicsToDescribe is for tempUnknownTopics to have chance to get described again, by the retries in makeReady method. In the makeReady, we want to know which topics existed and to validate it, and which topics not existed that needed to be created. But for the LeaderNotAvailabletopics, we can't know if topics existed or not. So, we need to merge topics(topics to validate) and tempUnknownTopics here to describe them all (again) here.\nThanks.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445625112", "createdAt": "2020-06-25T15:00:08Z", "author": {"login": "showuon"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -179,31 +180,43 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n      * Topics that were not able to get its description will simply not be returned\n      */\n     // visible for testing\n-    protected Map<String, Integer> getNumPartitions(final Set<String> topics) {\n-        log.debug(\"Trying to check if topics {} have been created with expected number of partitions.\", topics);\n-\n-        final DescribeTopicsResult describeTopicsResult = adminClient.describeTopics(topics);\n+    protected Map<String, Integer> getNumPartitions(final Set<String> topics,\n+                                                    final HashSet<String> tempUnknownTopics,\n+                                                    final int remainingRetries) {\n+        final Set<String> allTopicsToDescribe = new HashSet<>(topics);\n+        allTopicsToDescribe.addAll(tempUnknownTopics);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODQ1Nw=="}, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NDQ3MjIxOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwMjo1MToxM1rOGoppxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDoyODoyNlrOGo9V1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODY2Mg==", "bodyText": "Similar here, we could reduce to Set", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445278662", "createdAt": "2020-06-25T02:51:13Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -218,13 +231,16 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n     /**\n      * Check the existing topics to have correct number of partitions; and return the remaining topics that needs to be created\n      */\n-    private Set<String> validateTopics(final Set<String> topicsToValidate, final Map<String, InternalTopicConfig> topicsMap) {\n+    private Set<String> validateTopics(final Set<String> topicsToValidate,\n+                                       final Map<String, InternalTopicConfig> topicsMap,\n+                                       final HashSet<String> tempUnknownTopics,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTIzOA==", "bodyText": "Fixed.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601238", "createdAt": "2020-06-25T14:28:26Z", "author": {"login": "showuon"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -218,13 +231,16 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n     /**\n      * Check the existing topics to have correct number of partitions; and return the remaining topics that needs to be created\n      */\n-    private Set<String> validateTopics(final Set<String> topicsToValidate, final Map<String, InternalTopicConfig> topicsMap) {\n+    private Set<String> validateTopics(final Set<String> topicsToValidate,\n+                                       final Map<String, InternalTopicConfig> topicsMap,\n+                                       final HashSet<String> tempUnknownTopics,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODY2Mg=="}, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3NDQ3MzQ1OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQwMjo1MjowOVrOGopqjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNDoyODoyM1rOGo9Vtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODg2Mw==", "bodyText": "Could use Collections.emptySet() if reduced to Set", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445278863", "createdAt": "2020-06-25T02:52:09Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -108,7 +111,8 @@ public void shouldReturnCorrectPartitionCounts() {\n             topic,\n             Collections.singletonList(new TopicPartitionInfo(0, broker1, singleReplica, Collections.emptyList())),\n             null);\n-        assertEquals(Collections.singletonMap(topic, 1), internalTopicManager.getNumPartitions(Collections.singleton(topic)));\n+        assertEquals(Collections.singletonMap(topic, 1),\n+                internalTopicManager.getNumPartitions(Collections.singleton(topic), new HashSet<String>(), 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYwMTIwNw==", "bodyText": "Updated. Thanks.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r445601207", "createdAt": "2020-06-25T14:28:23Z", "author": {"login": "showuon"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -108,7 +111,8 @@ public void shouldReturnCorrectPartitionCounts() {\n             topic,\n             Collections.singletonList(new TopicPartitionInfo(0, broker1, singleReplica, Collections.emptyList())),\n             null);\n-        assertEquals(Collections.singletonMap(topic, 1), internalTopicManager.getNumPartitions(Collections.singleton(topic)));\n+        assertEquals(Collections.singletonMap(topic, 1),\n+                internalTopicManager.getNumPartitions(Collections.singleton(topic), new HashSet<String>(), 1));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3ODg2Mw=="}, "originalCommit": {"oid": "f378c34d10c57d796412ac946f867e5787f93af0"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTE4MjA2OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjo0ODoxOFrOGrFfkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxNTo0OTozN1rOGrrqpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMTk1Mw==", "bodyText": "Better to be name as leaderUnavailableTopics to match the error code.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447831953", "createdAt": "2020-06-30T16:48:18Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -100,13 +100,19 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         final Set<String> newlyCreatedTopics = new HashSet<>();\n \n         while (!topicsNotReady.isEmpty() && remainingRetries >= 0) {\n-            topicsNotReady = validateTopics(topicsNotReady, topics);\n+            final Set<String> tempUnknownTopics = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA5NTEyNA==", "bodyText": "Well, this variable naming is actually suggested by @ableegoldman , and I also think the tempUnknownTopics is more descriptive. Is that OK for you?\n#8712 (comment)", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448095124", "createdAt": "2020-07-01T03:29:06Z", "author": {"login": "showuon"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -100,13 +100,19 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         final Set<String> newlyCreatedTopics = new HashSet<>();\n \n         while (!topicsNotReady.isEmpty() && remainingRetries >= 0) {\n-            topicsNotReady = validateTopics(topicsNotReady, topics);\n+            final Set<String> tempUnknownTopics = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMTk1Mw=="}, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ1NzM4MQ==", "bodyText": "Sure, I don't feel strong about reverting the naming once we already got a reason there.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448457381", "createdAt": "2020-07-01T15:49:37Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopicManager.java", "diffHunk": "@@ -100,13 +100,19 @@ public InternalTopicManager(final Admin adminClient, final StreamsConfig streams\n         final Set<String> newlyCreatedTopics = new HashSet<>();\n \n         while (!topicsNotReady.isEmpty() && remainingRetries >= 0) {\n-            topicsNotReady = validateTopics(topicsNotReady, topics);\n+            final Set<String> tempUnknownTopics = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMTk1Mw=="}, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTE5NzQxOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjo1MjowN1rOGrFpBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMzo1NjoyOVrOGrV6gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNDM3Mg==", "bodyText": "Could be simplified as topicManager.makeReady(Collections.singletonMap(leaderNotAvailableTopic, internalTopicConfig));", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447834372", "createdAt": "2020-06-30T16:52:07Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEwMDk5NA==", "bodyText": "good. Thanks.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448100994", "createdAt": "2020-07-01T03:56:29Z", "author": {"login": "showuon"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNDM3Mg=="}, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTIwNjcyOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjo1NDoyNVrOGrFu8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwMDozNTo0MlrOGr5kqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNTg5MQ==", "bodyText": "This test seems to be overlapping with shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound. I don't think we need both to return LeaderNotAvailable unless they are evaluating different scenarios.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447835891", "createdAt": "2020-06-30T16:54:25Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA5OTM1OA==", "bodyText": "Yes, they are different scenarios. You can check below diagram for reference. (red and green for different cases)", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448099358", "createdAt": "2020-07-01T03:48:35Z", "author": {"login": "showuon"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNTg5MQ=="}, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ2MDE5Nw==", "bodyText": "Thanks for explaining! May I know what this software you uses to generate the graph?", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448460197", "createdAt": "2020-07-01T15:54:18Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNTg5MQ=="}, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY4NTIyNA==", "bodyText": "Actually, I drew it by myself on the MS office powerpoint. haha", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448685224", "createdAt": "2020-07-02T00:35:42Z", "author": {"login": "showuon"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNTg5MQ=="}, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTIwOTgwOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjo1NTowOVrOGrFw1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwNDowNzowNVrOGrWDow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNjM3Mw==", "bodyText": "nit: if it will return topicDescriptionSuccessFuture, then we should not use leaderNotAvailableTopic", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447836373", "createdAt": "2020-06-30T16:55:09Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+        final TopicPartitionInfo partitionInfo = new TopicPartitionInfo(0, broker1,\n+                Collections.singletonList(broker1), Collections.singletonList(broker1));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionSuccessFuture = new KafkaFutureImpl<>();\n+        topicDescriptionSuccessFuture.complete(\n+            new TopicDescription(topic, false, Collections.singletonList(partitionInfo), Collections.emptySet())\n+        );\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEwMzMzMQ==", "bodyText": "good. Thanks.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448103331", "createdAt": "2020-07-01T04:07:05Z", "author": {"login": "showuon"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+        final TopicPartitionInfo partitionInfo = new TopicPartitionInfo(0, broker1,\n+                Collections.singletonList(broker1), Collections.singletonList(broker1));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionSuccessFuture = new KafkaFutureImpl<>();\n+        topicDescriptionSuccessFuture.complete(\n+            new TopicDescription(topic, false, Collections.singletonList(partitionInfo), Collections.emptySet())\n+        );\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNjM3Mw=="}, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTIxMzExOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjo1NTo0OVrOGrFyuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMzo0OTozNlrOGrV1Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNjg1Nw==", "bodyText": "exception not used.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447836857", "createdAt": "2020-06-30T16:55:49Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+        final TopicPartitionInfo partitionInfo = new TopicPartitionInfo(0, broker1,\n+                Collections.singletonList(broker1), Collections.singletonList(broker1));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionSuccessFuture = new KafkaFutureImpl<>();\n+        topicDescriptionSuccessFuture.complete(\n+            new TopicDescription(topic, false, Collections.singletonList(partitionInfo), Collections.emptySet())\n+        );\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionSuccessFuture)))\n+            .once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldThrowExceptionWhenKeepsTopicLeaderNotAvailable() {\n+        final String leaderNotAvailableTopic = \"LeaderNotAvailableTopic\";\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+\n+        // simulate describeTopics got LeaderNotAvailableException\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .times(2);\n+\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+\n+        final StreamsException exception = assertThrows(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA5OTU5OA==", "bodyText": "Nice catch!", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448099598", "createdAt": "2020-07-01T03:49:36Z", "author": {"login": "showuon"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+        final TopicPartitionInfo partitionInfo = new TopicPartitionInfo(0, broker1,\n+                Collections.singletonList(broker1), Collections.singletonList(broker1));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionSuccessFuture = new KafkaFutureImpl<>();\n+        topicDescriptionSuccessFuture.complete(\n+            new TopicDescription(topic, false, Collections.singletonList(partitionInfo), Collections.emptySet())\n+        );\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionSuccessFuture)))\n+            .once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldThrowExceptionWhenKeepsTopicLeaderNotAvailable() {\n+        final String leaderNotAvailableTopic = \"LeaderNotAvailableTopic\";\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+\n+        // simulate describeTopics got LeaderNotAvailableException\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .times(2);\n+\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+\n+        final StreamsException exception = assertThrows(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzNjg1Nw=="}, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTIyMjc0OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjo1ODoyNFrOGrF5OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMzo1NjoxMVrOGrV6Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzODUyMA==", "bodyText": "nit: we could set a final int for numRetries as:\n            put(StreamsConfig.adminClientPrefix(StreamsConfig.RETRIES_CONFIG), numRetries);\n\n\nand use (numRetries + 1) here to clearly indicate we are trying to go beyond the retry limit.", "url": "https://github.com/apache/kafka/pull/8712#discussion_r447838520", "createdAt": "2020-06-30T16:58:24Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+        final TopicPartitionInfo partitionInfo = new TopicPartitionInfo(0, broker1,\n+                Collections.singletonList(broker1), Collections.singletonList(broker1));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionSuccessFuture = new KafkaFutureImpl<>();\n+        topicDescriptionSuccessFuture.complete(\n+            new TopicDescription(topic, false, Collections.singletonList(partitionInfo), Collections.emptySet())\n+        );\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionSuccessFuture)))\n+            .once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldThrowExceptionWhenKeepsTopicLeaderNotAvailable() {\n+        final String leaderNotAvailableTopic = \"LeaderNotAvailableTopic\";\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+\n+        // simulate describeTopics got LeaderNotAvailableException\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .times(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEwMDkzMA==", "bodyText": "good suggestion!", "url": "https://github.com/apache/kafka/pull/8712#discussion_r448100930", "createdAt": "2020-07-01T03:56:11Z", "author": {"login": "showuon"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/InternalTopicManagerTest.java", "diffHunk": "@@ -287,12 +290,124 @@ public void shouldLogWhenTopicNotFoundAndNotThrowException() {\n \n             assertThat(\n                 appender.getMessages(),\n-                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet:\" +\n-                    \" org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n+                hasItem(\"stream-thread [\" + threadName + \"] Topic internal-topic is unknown or not found, hence not existed yet.\\n\" +\n+                    \"Error message was: org.apache.kafka.common.errors.UnknownTopicOrPartitionException: Topic internal-topic not found.\")\n             );\n         }\n     }\n \n+    @Test\n+    public void shouldCreateTopicWhenTopicLeaderNotAvailableAndThenTopicNotFound() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionLeaderNotAvailableFuture = new KafkaFutureImpl<>();\n+        topicDescriptionLeaderNotAvailableFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionUnknownTopicFuture = new KafkaFutureImpl<>();\n+        topicDescriptionUnknownTopicFuture.completeExceptionally(new UnknownTopicOrPartitionException(\"Unknown Topic!\"));\n+        final KafkaFutureImpl<CreateTopicsResult.TopicMetadataAndConfig> topicCreationFuture = new KafkaFutureImpl<>();\n+        topicCreationFuture.complete(EasyMock.createNiceMock(CreateTopicsResult.TopicMetadataAndConfig.class));\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionLeaderNotAvailableFuture)))\n+            .once();\n+        // return empty set for 1st time\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionUnknownTopicFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.singleton(\n+                new NewTopic(leaderNotAvailableTopic, Optional.of(1), Optional.of((short) 1))\n+            .configs(Utils.mkMap(Utils.mkEntry(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_DELETE),\n+                Utils.mkEntry(TopicConfig.MESSAGE_TIMESTAMP_TYPE_CONFIG, \"CreateTime\"),\n+                Utils.mkEntry(TopicConfig.SEGMENT_BYTES_CONFIG, \"52428800\"),\n+                Utils.mkEntry(TopicConfig.RETENTION_MS_CONFIG, \"-1\"))))))\n+            .andReturn(new MockCreateTopicsResult(Collections.singletonMap(leaderNotAvailableTopic, topicCreationFuture))).once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldCompleteValidateWhenTopicLeaderNotAvailableAndThenDescribeSuccess() {\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+        final TopicPartitionInfo partitionInfo = new TopicPartitionInfo(0, broker1,\n+                Collections.singletonList(broker1), Collections.singletonList(broker1));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionSuccessFuture = new KafkaFutureImpl<>();\n+        topicDescriptionSuccessFuture.complete(\n+            new TopicDescription(topic, false, Collections.singletonList(partitionInfo), Collections.emptySet())\n+        );\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .once();\n+        EasyMock.expect(admin.createTopics(Collections.emptySet()))\n+            .andReturn(new MockCreateTopicsResult(Collections.emptyMap())).once();\n+\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionSuccessFuture)))\n+            .once();\n+\n+        EasyMock.replay(admin);\n+\n+        final InternalTopicConfig internalTopicConfig = new RepartitionTopicConfig(leaderNotAvailableTopic, Collections.emptyMap());\n+        internalTopicConfig.setNumberOfPartitions(1);\n+        final Map<String, InternalTopicConfig> topicConfigMap = new HashMap<>();\n+        topicConfigMap.put(leaderNotAvailableTopic, internalTopicConfig);\n+        topicManager.makeReady(topicConfigMap);\n+\n+        EasyMock.verify(admin);\n+    }\n+\n+    @Test\n+    public void shouldThrowExceptionWhenKeepsTopicLeaderNotAvailable() {\n+        final String leaderNotAvailableTopic = \"LeaderNotAvailableTopic\";\n+        final AdminClient admin = EasyMock.createNiceMock(AdminClient.class);\n+        final InternalTopicManager topicManager = new InternalTopicManager(admin, new StreamsConfig(config));\n+\n+        final KafkaFutureImpl<TopicDescription> topicDescriptionFailFuture = new KafkaFutureImpl<>();\n+        topicDescriptionFailFuture.completeExceptionally(new LeaderNotAvailableException(\"Leader Not Available!\"));\n+\n+        // simulate describeTopics got LeaderNotAvailableException\n+        EasyMock.expect(admin.describeTopics(Collections.singleton(leaderNotAvailableTopic)))\n+            .andReturn(new MockDescribeTopicsResult(\n+                Collections.singletonMap(leaderNotAvailableTopic, topicDescriptionFailFuture)))\n+            .times(2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzODUyMA=="}, "originalCommit": {"oid": "9089b4bb8ddef924e45e19d7806343627f206b00"}, "originalPosition": 136}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2713, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}