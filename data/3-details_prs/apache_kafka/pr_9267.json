{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyMTczNDk2", "number": 9267, "title": "MINOR: Add debug logs for StreamThread", "bodyText": "Add debug logs to see when Streams calls poll, process, commit, etc.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-09-08T16:50:08Z", "url": "https://github.com/apache/kafka/pull/9267", "merged": true, "mergeCommit": {"oid": "5ee3ecb1e3bb4f6a8f8e344229c1a88b1d230e73"}, "closed": true, "closedAt": "2020-09-10T20:47:16Z", "author": {"login": "vvcephei"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdG6ezNgH2gAyNDgyMTczNDk2OjJiOWY2MTIyYTJiMWQzYTUwM2YzYThhNjEwNGJlZmExNWRlNmVmYmQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdHPvs3gFqTQ4NTI1MDczOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2b9f6122a2b1d3a503f3a8a6104befa15de6efbd", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/2b9f6122a2b1d3a503f3a8a6104befa15de6efbd", "committedDate": "2020-09-08T16:48:55Z", "message": "MINOR: Add debug logs for StreamThread"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MzI0MTQw", "url": "https://github.com/apache/kafka/pull/9267#pullrequestreview-484324140", "createdAt": "2020-09-08T16:50:45Z", "commit": {"oid": "2b9f6122a2b1d3a503f3a8a6104befa15de6efbd"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNjo1MDo0NVrOHOl2lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNzowNjoyOFrOHOmZ6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2MjI5NQ==", "bodyText": "runOnce was too long, according to checkStyle, so I factored out some of the execution phases.", "url": "https://github.com/apache/kafka/pull/9267#discussion_r485062295", "createdAt": "2020-09-08T16:50:45Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -612,63 +612,18 @@ void runOnce() {\n         final long startMs = time.milliseconds();\n         now = startMs;\n \n-        if (state == State.PARTITIONS_ASSIGNED) {\n-            // try to fetch some records with zero poll millis\n-            // to unblock the restoration as soon as possible\n-            records = pollRequests(Duration.ZERO);\n-        } else if (state == State.PARTITIONS_REVOKED) {\n-            // try to fetch som records with zero poll millis to unblock\n-            // other useful work while waiting for the join response\n-            records = pollRequests(Duration.ZERO);\n-        } else if (state == State.RUNNING || state == State.STARTING) {\n-            // try to fetch some records with normal poll time\n-            // in order to get long polling\n-            records = pollRequests(pollTime);\n-        } else if (state == State.PENDING_SHUTDOWN) {\n-            // we are only here because there's rebalance in progress,\n-            // just poll with zero to complete it\n-            records = pollRequests(Duration.ZERO);\n-        } else {\n-            // any other state should not happen\n-            log.error(\"Unexpected state {} during normal iteration\", state);\n-            throw new StreamsException(logPrefix + \"Unexpected state \" + state + \" during normal iteration\");\n-        }\n-\n-        final long pollLatency = advanceNowAndComputeLatency();\n-\n-        pollSensor.record(pollLatency, now);\n-        if (records != null && !records.isEmpty()) {\n-            pollRecordsSensor.record(records.count(), now);\n-            taskManager.addRecordsToTasks(records);\n-        }\n+        final long pollLatency = pollPhase();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b9f6122a2b1d3a503f3a8a6104befa15de6efbd"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2MjUyNg==", "bodyText": "Just a slight rewording I thought could be clearer.", "url": "https://github.com/apache/kafka/pull/9267#discussion_r485062526", "createdAt": "2020-09-08T16:51:10Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -612,63 +612,18 @@ void runOnce() {\n         final long startMs = time.milliseconds();\n         now = startMs;\n \n-        if (state == State.PARTITIONS_ASSIGNED) {\n-            // try to fetch some records with zero poll millis\n-            // to unblock the restoration as soon as possible\n-            records = pollRequests(Duration.ZERO);\n-        } else if (state == State.PARTITIONS_REVOKED) {\n-            // try to fetch som records with zero poll millis to unblock\n-            // other useful work while waiting for the join response\n-            records = pollRequests(Duration.ZERO);\n-        } else if (state == State.RUNNING || state == State.STARTING) {\n-            // try to fetch some records with normal poll time\n-            // in order to get long polling\n-            records = pollRequests(pollTime);\n-        } else if (state == State.PENDING_SHUTDOWN) {\n-            // we are only here because there's rebalance in progress,\n-            // just poll with zero to complete it\n-            records = pollRequests(Duration.ZERO);\n-        } else {\n-            // any other state should not happen\n-            log.error(\"Unexpected state {} during normal iteration\", state);\n-            throw new StreamsException(logPrefix + \"Unexpected state \" + state + \" during normal iteration\");\n-        }\n-\n-        final long pollLatency = advanceNowAndComputeLatency();\n-\n-        pollSensor.record(pollLatency, now);\n-        if (records != null && !records.isEmpty()) {\n-            pollRecordsSensor.record(records.count(), now);\n-            taskManager.addRecordsToTasks(records);\n-        }\n+        final long pollLatency = pollPhase();\n \n         // Shutdown hook could potentially be triggered and transit the thread state to PENDING_SHUTDOWN during #pollRequests().\n         // The task manager internal states could be uninitialized if the state transition happens during #onPartitionsAssigned().\n         // Should only proceed when the thread is still running after #pollRequests(), because no external state mutation\n         // could affect the task manager state beyond this point within #runOnce().\n         if (!isRunning()) {\n-            log.debug(\"State already transits to {}, skipping the run once call after poll request\", state);\n+            log.debug(\"Thread state is already {}, skipping the run once call after poll request\", state);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b9f6122a2b1d3a503f3a8a6104befa15de6efbd"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2NDIwMA==", "bodyText": "I wanted to make all my new debug statements zero-cost if debug isn't enabled. Since state is volatile, resolving the arguments for this call would result in an uncached read of main memory regardless of the log level. Since we don't expect state to actually change in these few lines, I just read it once and saved it in stateSnapshot.", "url": "https://github.com/apache/kafka/pull/9267#discussion_r485064200", "createdAt": "2020-09-08T16:54:11Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -752,6 +712,77 @@ void runOnce() {\n         commitRatioSensor.record((double) totalCommitLatency / runOnceLatency, now);\n     }\n \n+    private void initializeAndRestorePhase() {\n+        {\n+            // only try to initialize the assigned tasks\n+            // if the state is still in PARTITION_ASSIGNED after the poll call\n+            final State stateSnapshot = state;\n+            if (stateSnapshot == State.PARTITIONS_ASSIGNED\n+                || stateSnapshot == State.RUNNING && taskManager.needsInitializationOrRestoration()) {\n+\n+                log.debug(\"State is {}; initializing and restoring\", stateSnapshot);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b9f6122a2b1d3a503f3a8a6104befa15de6efbd"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2NDU4Ng==", "bodyText": "This time, we really need to read the field, so I'm guarding the method call for the common case in which debug is off.", "url": "https://github.com/apache/kafka/pull/9267#discussion_r485064586", "createdAt": "2020-09-08T16:54:54Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -752,6 +712,77 @@ void runOnce() {\n         commitRatioSensor.record((double) totalCommitLatency / runOnceLatency, now);\n     }\n \n+    private void initializeAndRestorePhase() {\n+        {\n+            // only try to initialize the assigned tasks\n+            // if the state is still in PARTITION_ASSIGNED after the poll call\n+            final State stateSnapshot = state;\n+            if (stateSnapshot == State.PARTITIONS_ASSIGNED\n+                || stateSnapshot == State.RUNNING && taskManager.needsInitializationOrRestoration()) {\n+\n+                log.debug(\"State is {}; initializing and restoring\", stateSnapshot);\n+\n+                // transit to restore active is idempotent so we can call it multiple times\n+                changelogReader.enforceRestoreActive();\n+\n+                if (taskManager.tryToCompleteRestoration()) {\n+                    changelogReader.transitToUpdateStandby();\n+\n+                    setState(State.RUNNING);\n+                }\n+\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Initialization and restore call done. State is {}\", state);\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b9f6122a2b1d3a503f3a8a6104befa15de6efbd"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2NTA2MA==", "bodyText": "Guarded to avoid calling records.count() when debug is off.", "url": "https://github.com/apache/kafka/pull/9267#discussion_r485065060", "createdAt": "2020-09-08T16:55:40Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -752,6 +712,77 @@ void runOnce() {\n         commitRatioSensor.record((double) totalCommitLatency / runOnceLatency, now);\n     }\n \n+    private void initializeAndRestorePhase() {\n+        {\n+            // only try to initialize the assigned tasks\n+            // if the state is still in PARTITION_ASSIGNED after the poll call\n+            final State stateSnapshot = state;\n+            if (stateSnapshot == State.PARTITIONS_ASSIGNED\n+                || stateSnapshot == State.RUNNING && taskManager.needsInitializationOrRestoration()) {\n+\n+                log.debug(\"State is {}; initializing and restoring\", stateSnapshot);\n+\n+                // transit to restore active is idempotent so we can call it multiple times\n+                changelogReader.enforceRestoreActive();\n+\n+                if (taskManager.tryToCompleteRestoration()) {\n+                    changelogReader.transitToUpdateStandby();\n+\n+                    setState(State.RUNNING);\n+                }\n+\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Initialization and restore call done. State is {}\", state);\n+                }\n+            }\n+        }\n+\n+        log.debug(\"Invoking ChangeLogReader#restore\");\n+        // we can always let changelog reader try restoring in order to initialize the changelogs;\n+        // if there's no active restoring or standby updating it would not try to fetch any data\n+        changelogReader.restore();\n+    }\n+\n+    private long pollPhase() {\n+        final ConsumerRecords<byte[], byte[]> records;\n+        log.debug(\"Invoking Consumer#poll\");\n+\n+        if (state == State.PARTITIONS_ASSIGNED) {\n+            // try to fetch some records with zero poll millis\n+            // to unblock the restoration as soon as possible\n+            records = pollRequests(Duration.ZERO);\n+        } else if (state == State.PARTITIONS_REVOKED) {\n+            // try to fetch som records with zero poll millis to unblock\n+            // other useful work while waiting for the join response\n+            records = pollRequests(Duration.ZERO);\n+        } else if (state == State.RUNNING || state == State.STARTING) {\n+            // try to fetch some records with normal poll time\n+            // in order to get long polling\n+            records = pollRequests(pollTime);\n+        } else if (state == State.PENDING_SHUTDOWN) {\n+            // we are only here because there's rebalance in progress,\n+            // just poll with zero to complete it\n+            records = pollRequests(Duration.ZERO);\n+        } else {\n+            // any other state should not happen\n+            log.error(\"Unexpected state {} during normal iteration\", state);\n+            throw new StreamsException(logPrefix + \"Unexpected state \" + state + \" during normal iteration\");\n+        }\n+\n+        final long pollLatency = advanceNowAndComputeLatency();\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Consumer#poll completed in {} ms and fetched {} records\", pollLatency, records.count());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b9f6122a2b1d3a503f3a8a6104befa15de6efbd"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2NzA1Mg==", "bodyText": "Note, this was previously records != null && !records.isEmpty():\nhttps://github.com/apache/kafka/pull/9267/files#diff-045aeaddb4232a85a8560186b4901e69L640\nHowever, records can never be null, except if Consumer#poll returns null, which it does not. It turned out the reason for checking this condition was that there was exactly one test that relied on a nice mock returning null. I fixed the test below.\nNote, the only reason I messed with this was to simplify the debug log message on L775. Otherwise, I'd have needed to think of what to say if records were null.", "url": "https://github.com/apache/kafka/pull/9267#discussion_r485067052", "createdAt": "2020-09-08T16:59:07Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -752,6 +712,77 @@ void runOnce() {\n         commitRatioSensor.record((double) totalCommitLatency / runOnceLatency, now);\n     }\n \n+    private void initializeAndRestorePhase() {\n+        {\n+            // only try to initialize the assigned tasks\n+            // if the state is still in PARTITION_ASSIGNED after the poll call\n+            final State stateSnapshot = state;\n+            if (stateSnapshot == State.PARTITIONS_ASSIGNED\n+                || stateSnapshot == State.RUNNING && taskManager.needsInitializationOrRestoration()) {\n+\n+                log.debug(\"State is {}; initializing and restoring\", stateSnapshot);\n+\n+                // transit to restore active is idempotent so we can call it multiple times\n+                changelogReader.enforceRestoreActive();\n+\n+                if (taskManager.tryToCompleteRestoration()) {\n+                    changelogReader.transitToUpdateStandby();\n+\n+                    setState(State.RUNNING);\n+                }\n+\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Initialization and restore call done. State is {}\", state);\n+                }\n+            }\n+        }\n+\n+        log.debug(\"Invoking ChangeLogReader#restore\");\n+        // we can always let changelog reader try restoring in order to initialize the changelogs;\n+        // if there's no active restoring or standby updating it would not try to fetch any data\n+        changelogReader.restore();\n+    }\n+\n+    private long pollPhase() {\n+        final ConsumerRecords<byte[], byte[]> records;\n+        log.debug(\"Invoking Consumer#poll\");\n+\n+        if (state == State.PARTITIONS_ASSIGNED) {\n+            // try to fetch some records with zero poll millis\n+            // to unblock the restoration as soon as possible\n+            records = pollRequests(Duration.ZERO);\n+        } else if (state == State.PARTITIONS_REVOKED) {\n+            // try to fetch som records with zero poll millis to unblock\n+            // other useful work while waiting for the join response\n+            records = pollRequests(Duration.ZERO);\n+        } else if (state == State.RUNNING || state == State.STARTING) {\n+            // try to fetch some records with normal poll time\n+            // in order to get long polling\n+            records = pollRequests(pollTime);\n+        } else if (state == State.PENDING_SHUTDOWN) {\n+            // we are only here because there's rebalance in progress,\n+            // just poll with zero to complete it\n+            records = pollRequests(Duration.ZERO);\n+        } else {\n+            // any other state should not happen\n+            log.error(\"Unexpected state {} during normal iteration\", state);\n+            throw new StreamsException(logPrefix + \"Unexpected state \" + state + \" during normal iteration\");\n+        }\n+\n+        final long pollLatency = advanceNowAndComputeLatency();\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Consumer#poll completed in {} ms and fetched {} records\", pollLatency, records.count());\n+        }\n+        pollSensor.record(pollLatency, now);\n+\n+        if (!records.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b9f6122a2b1d3a503f3a8a6104befa15de6efbd"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2NzQyOA==", "bodyText": "Not necessary, but also not harmful, since it's a static final instance anyway. I thought it was nicer for self-documentation this way.", "url": "https://github.com/apache/kafka/pull/9267#discussion_r485067428", "createdAt": "2020-09-08T16:59:46Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -760,7 +791,7 @@ void runOnce() {\n      * @throws TaskMigratedException if the task producer got fenced (EOS only)\n      */\n     private ConsumerRecords<byte[], byte[]> pollRequests(final Duration pollTime) {\n-        ConsumerRecords<byte[], byte[]> records = null;\n+        ConsumerRecords<byte[], byte[]> records = ConsumerRecords.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b9f6122a2b1d3a503f3a8a6104befa15de6efbd"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2OTc5OQ==", "bodyText": "Switched these to debug now, since they seem to fit with the newly added logs.", "url": "https://github.com/apache/kafka/pull/9267#discussion_r485069799", "createdAt": "2020-09-08T17:03:49Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -845,8 +876,8 @@ private void addToResetList(final TopicPartition partition, final Set<TopicParti\n     int maybeCommit() {\n         final int committed;\n         if (now - lastCommitMs > commitTimeMs) {\n-            if (log.isTraceEnabled()) {\n-                log.trace(\"Committing all active tasks {} and standby tasks {} since {}ms has elapsed (commit interval is {}ms)\",\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Committing all active tasks {} and standby tasks {} since {}ms has elapsed (commit interval is {}ms)\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b9f6122a2b1d3a503f3a8a6104befa15de6efbd"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA3MTMzNg==", "bodyText": "This was a bad input for the test, since poll can never actually return null.", "url": "https://github.com/apache/kafka/pull/9267#discussion_r485071336", "createdAt": "2020-09-08T17:06:28Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java", "diffHunk": "@@ -496,6 +498,7 @@ public void shouldEnforceRebalanceAfterNextScheduledProbingRebalanceTime() throw\n         );\n         \n         final Consumer<byte[], byte[]> mockConsumer = EasyMock.createNiceMock(Consumer.class);\n+        expect(mockConsumer.poll(anyObject())).andStubReturn(ConsumerRecords.empty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b9f6122a2b1d3a503f3a8a6104befa15de6efbd"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0MzcwMzU3", "url": "https://github.com/apache/kafka/pull/9267#pullrequestreview-484370357", "createdAt": "2020-09-08T17:55:48Z", "commit": {"oid": "2b9f6122a2b1d3a503f3a8a6104befa15de6efbd"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNzo1NTo0OVrOHOoDow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNzo1NTo1N1rOHOoD4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5ODQwMw==", "bodyText": "Is this necessary with the logs inside restore()?\nmaybe can include snapshotState so we can see if it's STARTING or RUNNING? because we don't see the state unless it enters the initialization. Not sure if this would be useful", "url": "https://github.com/apache/kafka/pull/9267#discussion_r485098403", "createdAt": "2020-09-08T17:55:49Z", "author": {"login": "wcarlson5"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -752,6 +712,77 @@ void runOnce() {\n         commitRatioSensor.record((double) totalCommitLatency / runOnceLatency, now);\n     }\n \n+    private void initializeAndRestorePhase() {\n+        {\n+            // only try to initialize the assigned tasks\n+            // if the state is still in PARTITION_ASSIGNED after the poll call\n+            final State stateSnapshot = state;\n+            if (stateSnapshot == State.PARTITIONS_ASSIGNED\n+                || stateSnapshot == State.RUNNING && taskManager.needsInitializationOrRestoration()) {\n+\n+                log.debug(\"State is {}; initializing and restoring\", stateSnapshot);\n+\n+                // transit to restore active is idempotent so we can call it multiple times\n+                changelogReader.enforceRestoreActive();\n+\n+                if (taskManager.tryToCompleteRestoration()) {\n+                    changelogReader.transitToUpdateStandby();\n+\n+                    setState(State.RUNNING);\n+                }\n+\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Initialization and restore call done. State is {}\", state);\n+                }\n+            }\n+        }\n+\n+        log.debug(\"Invoking ChangeLogReader#restore\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b9f6122a2b1d3a503f3a8a6104befa15de6efbd"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5ODQ2NQ==", "bodyText": "trace?", "url": "https://github.com/apache/kafka/pull/9267#discussion_r485098465", "createdAt": "2020-09-08T17:55:57Z", "author": {"login": "wcarlson5"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -706,13 +662,17 @@ void runOnce() {\n                     totalProcessed += processed;\n                 }\n \n+                log.debug(\"TaskManager#process handled {} records; invoking TaskManager#punctuate\", processed);\n+\n                 final int punctuated = taskManager.punctuate();\n                 final long punctuateLatency = advanceNowAndComputeLatency();\n                 totalPunctuateLatency += punctuateLatency;\n                 if (punctuated > 0) {\n                     punctuateSensor.record(punctuateLatency / (double) punctuated, now);\n                 }\n \n+                log.debug(\"TaskManager#punctuate executed: {}\", punctuated);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b9f6122a2b1d3a503f3a8a6104befa15de6efbd"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDEzMTM1", "url": "https://github.com/apache/kafka/pull/9267#pullrequestreview-484413135", "createdAt": "2020-09-08T18:59:21Z", "commit": {"oid": "2b9f6122a2b1d3a503f3a8a6104befa15de6efbd"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxODo1OToyMVrOHOqIPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOToxODozM1rOHOqunQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzMjM0OA==", "bodyText": "Nit: I'd suggest we do not expose internal class names in log entries, e.g. here we can say \"Processed {} records with {} iterations, invoking punctuation now\", ditto below.", "url": "https://github.com/apache/kafka/pull/9267#discussion_r485132348", "createdAt": "2020-09-08T18:59:21Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -706,13 +662,17 @@ void runOnce() {\n                     totalProcessed += processed;\n                 }\n \n+                log.debug(\"TaskManager#process handled {} records; invoking TaskManager#punctuate\", processed);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b9f6122a2b1d3a503f3a8a6104befa15de6efbd"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzMjgxMQ==", "bodyText": "What's the rationale of recording both the starting and the ending of a procedure? If it is for trouble shooting purposes only maybe the starting log entry can be trace while ending entry is debug?", "url": "https://github.com/apache/kafka/pull/9267#discussion_r485132811", "createdAt": "2020-09-08T19:00:07Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -689,6 +644,7 @@ void runOnce() {\n              *  6. Otherwise, increment N.\n              */\n             do {\n+                log.debug(\"Invoking TaskManager#process with {} iterations.\", numIterations);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b9f6122a2b1d3a503f3a8a6104befa15de6efbd"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MjAxNw==", "bodyText": "SG.", "url": "https://github.com/apache/kafka/pull/9267#discussion_r485142017", "createdAt": "2020-09-08T19:18:12Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -752,6 +712,77 @@ void runOnce() {\n         commitRatioSensor.record((double) totalCommitLatency / runOnceLatency, now);\n     }\n \n+    private void initializeAndRestorePhase() {\n+        {\n+            // only try to initialize the assigned tasks\n+            // if the state is still in PARTITION_ASSIGNED after the poll call\n+            final State stateSnapshot = state;\n+            if (stateSnapshot == State.PARTITIONS_ASSIGNED\n+                || stateSnapshot == State.RUNNING && taskManager.needsInitializationOrRestoration()) {\n+\n+                log.debug(\"State is {}; initializing and restoring\", stateSnapshot);\n+\n+                // transit to restore active is idempotent so we can call it multiple times\n+                changelogReader.enforceRestoreActive();\n+\n+                if (taskManager.tryToCompleteRestoration()) {\n+                    changelogReader.transitToUpdateStandby();\n+\n+                    setState(State.RUNNING);\n+                }\n+\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Initialization and restore call done. State is {}\", state);\n+                }\n+            }\n+        }\n+\n+        log.debug(\"Invoking ChangeLogReader#restore\");\n+        // we can always let changelog reader try restoring in order to initialize the changelogs;\n+        // if there's no active restoring or standby updating it would not try to fetch any data\n+        changelogReader.restore();\n+    }\n+\n+    private long pollPhase() {\n+        final ConsumerRecords<byte[], byte[]> records;\n+        log.debug(\"Invoking Consumer#poll\");\n+\n+        if (state == State.PARTITIONS_ASSIGNED) {\n+            // try to fetch some records with zero poll millis\n+            // to unblock the restoration as soon as possible\n+            records = pollRequests(Duration.ZERO);\n+        } else if (state == State.PARTITIONS_REVOKED) {\n+            // try to fetch som records with zero poll millis to unblock\n+            // other useful work while waiting for the join response\n+            records = pollRequests(Duration.ZERO);\n+        } else if (state == State.RUNNING || state == State.STARTING) {\n+            // try to fetch some records with normal poll time\n+            // in order to get long polling\n+            records = pollRequests(pollTime);\n+        } else if (state == State.PENDING_SHUTDOWN) {\n+            // we are only here because there's rebalance in progress,\n+            // just poll with zero to complete it\n+            records = pollRequests(Duration.ZERO);\n+        } else {\n+            // any other state should not happen\n+            log.error(\"Unexpected state {} during normal iteration\", state);\n+            throw new StreamsException(logPrefix + \"Unexpected state \" + state + \" during normal iteration\");\n+        }\n+\n+        final long pollLatency = advanceNowAndComputeLatency();\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Consumer#poll completed in {} ms and fetched {} records\", pollLatency, records.count());\n+        }\n+        pollSensor.record(pollLatency, now);\n+\n+        if (!records.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2NzA1Mg=="}, "originalCommit": {"oid": "2b9f6122a2b1d3a503f3a8a6104befa15de6efbd"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MjE3Mw==", "bodyText": "Not sure what's the purpose of this log entry?", "url": "https://github.com/apache/kafka/pull/9267#discussion_r485142173", "createdAt": "2020-09-08T19:18:33Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -752,6 +712,77 @@ void runOnce() {\n         commitRatioSensor.record((double) totalCommitLatency / runOnceLatency, now);\n     }\n \n+    private void initializeAndRestorePhase() {\n+        {\n+            // only try to initialize the assigned tasks\n+            // if the state is still in PARTITION_ASSIGNED after the poll call\n+            final State stateSnapshot = state;\n+            if (stateSnapshot == State.PARTITIONS_ASSIGNED\n+                || stateSnapshot == State.RUNNING && taskManager.needsInitializationOrRestoration()) {\n+\n+                log.debug(\"State is {}; initializing and restoring\", stateSnapshot);\n+\n+                // transit to restore active is idempotent so we can call it multiple times\n+                changelogReader.enforceRestoreActive();\n+\n+                if (taskManager.tryToCompleteRestoration()) {\n+                    changelogReader.transitToUpdateStandby();\n+\n+                    setState(State.RUNNING);\n+                }\n+\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"Initialization and restore call done. State is {}\", state);\n+                }\n+            }\n+        }\n+\n+        log.debug(\"Invoking ChangeLogReader#restore\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5ODQwMw=="}, "originalCommit": {"oid": "2b9f6122a2b1d3a503f3a8a6104befa15de6efbd"}, "originalPosition": 122}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "beb93768cb761367344fb31e40945bdebbba7cb5", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/beb93768cb761367344fb31e40945bdebbba7cb5", "committedDate": "2020-09-09T17:15:43Z", "message": "CR feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1MjUwNzM5", "url": "https://github.com/apache/kafka/pull/9267#pullrequestreview-485250739", "createdAt": "2020-09-09T17:35:23Z", "commit": {"oid": "beb93768cb761367344fb31e40945bdebbba7cb5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 580, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}