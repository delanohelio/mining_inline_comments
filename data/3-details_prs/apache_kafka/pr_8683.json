{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5MjEzMTc1", "number": 8683, "title": "KAFKA-9893: Configurable TCP connection timeout and improve the initial metadata fetch", "bodyText": "More detailed description of your change,\nif necessary. The PR title and PR message become\nthe squashed commit message, so use a separate\ncomment to ping reviewers.\n\nAdded a new common client configuration parameter socket.connection.setup.timeout.ms to the NetworkClient. Handle potential transportation layer timeout using the same approach as it handling potential request timeout.\nWhen no connected channel exists, leastLoadedNode() will now provide a disconnected node that has the least recent connection attempts.\nClusterConnectionStates will keep the connecting node ids. Now it also has several new public methods to provide per connection relavant data.\n\nSummary of testing strategy (including rationale)\nfor the feature or bug fix. Unit and/or integration\ntests are expected for any behaviour change and\nsystem tests should be considered for larger changes.\n\nA unit test for the basic functionality of the new configuration\nA unit test for optimized leastLoadedNode()\nUse docker scenarios for system tests. May add a duckertape test.\n\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-05-18T01:41:48Z", "url": "https://github.com/apache/kafka/pull/8683", "merged": true, "mergeCommit": {"oid": "55b5b248cd0974f48e8bf261f61227722cb47570"}, "closed": true, "closedAt": "2020-06-30T11:15:18Z", "author": {"login": "ctan888"}, "timelineItems": {"totalCount": 47, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcha6MugH2gAyNDE5MjEzMTc1OmYyMDI1ZDcyOTFkNDE5ZWIwZGEwMWJiYWJlMmJhMzZmN2ZiOGI3YmI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcyhz3kgFqTQ0MzY4NjUwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f2025d7291d419eb0da01bbabe2ba36f7fb8b7bb", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/f2025d7291d419eb0da01bbabe2ba36f7fb8b7bb", "committedDate": "2020-05-15T05:06:41Z", "message": "Adding client configs and change the signature of NetworkClient"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b795a823a57cdcd664dc50932724769c49aa9b7a", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/b795a823a57cdcd664dc50932724769c49aa9b7a", "committedDate": "2020-05-18T01:11:56Z", "message": "Clean the config names and types"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "57661e544f4b137fdcc53e4ec2cff5ff2ecef74c", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/57661e544f4b137fdcc53e4ec2cff5ff2ecef74c", "committedDate": "2020-05-18T09:25:48Z", "message": "Added testLeastLoadedNodeProvideDisconnectedNodesPrioritizedByFailedAttempts(), fixed the failedAttempts counting bug"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "57661e544f4b137fdcc53e4ec2cff5ff2ecef74c", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/57661e544f4b137fdcc53e4ec2cff5ff2ecef74c", "committedDate": "2020-05-18T09:25:48Z", "message": "Added testLeastLoadedNodeProvideDisconnectedNodesPrioritizedByFailedAttempts(), fixed the failedAttempts counting bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d19e5d7c8715d6d0234b166c577691f48712507c", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/d19e5d7c8715d6d0234b166c577691f48712507c", "committedDate": "2020-06-03T05:59:44Z", "message": "fix state transition"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9118c944c5668ca00109e7d88b74c02824f2787", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/b9118c944c5668ca00109e7d88b74c02824f2787", "committedDate": "2020-06-05T08:39:10Z", "message": "Migrate static timeout to exponential timeout"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "06bdd5d394086a40d75742b6904607906ec971a1", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/06bdd5d394086a40d75742b6904607906ec971a1", "committedDate": "2020-06-06T02:08:54Z", "message": "Finished the Javadoc, adding more tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "06bdd5d394086a40d75742b6904607906ec971a1", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/06bdd5d394086a40d75742b6904607906ec971a1", "committedDate": "2020-06-06T02:08:54Z", "message": "Finished the Javadoc, adding more tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "6daba4155e6052e42985ba7f8d9572ef8cef2a01", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/6daba4155e6052e42985ba7f8d9572ef8cef2a01", "committedDate": "2020-06-06T07:29:04Z", "message": "NIT, and apply config to more clients"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "6daba4155e6052e42985ba7f8d9572ef8cef2a01", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/6daba4155e6052e42985ba7f8d9572ef8cef2a01", "committedDate": "2020-06-06T07:29:04Z", "message": "NIT, and apply config to more clients"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22b1b4c1a7a80df827ea6a50d82afaed004f369f", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/22b1b4c1a7a80df827ea6a50d82afaed004f369f", "committedDate": "2020-06-06T15:54:03Z", "message": "resolve merge conflict"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de0c5af8a6ad306766ca2c809161f5032f4de387", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/de0c5af8a6ad306766ca2c809161f5032f4de387", "committedDate": "2020-06-06T16:22:29Z", "message": "Fix BrokerApiVersionsCommand"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/b1a62f8bb374bd52baa4e8bdb389526ddcfd1595", "committedDate": "2020-06-06T20:53:25Z", "message": "Support connection timeout in KafkaConfig"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/b1a62f8bb374bd52baa4e8bdb389526ddcfd1595", "committedDate": "2020-06-06T20:53:25Z", "message": "Support connection timeout in KafkaConfig"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5OTU0NTE5", "url": "https://github.com/apache/kafka/pull/8683#pullrequestreview-429954519", "createdAt": "2020-06-12T18:28:43Z", "commit": {"oid": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxODoyODo0M1rOGjNz3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxODo0NzozMlrOGjOUhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3OTYxMg==", "bodyText": "Just to be sure, we are reusing the code, but not changing the behaviour for backoff right?", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439579612", "createdAt": "2020-06-12T18:28:43Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -34,19 +36,22 @@\n  *\n  */\n final class ClusterConnectionStates {\n-    private final long reconnectBackoffInitMs;\n-    private final long reconnectBackoffMaxMs;\n-    private final static int RECONNECT_BACKOFF_EXP_BASE = 2;\n-    private final double reconnectBackoffMaxExp;\n     private final Map<String, NodeConnectionState> nodeState;\n     private final Logger log;\n+    private Set<String> connectingNodes;\n+    private GeometricProgression reconnectBackoff;\n+    private GeometricProgression connectionSetupTimeout;\n \n-    public ClusterConnectionStates(long reconnectBackoffMs, long reconnectBackoffMaxMs, LogContext logContext) {\n+    public ClusterConnectionStates(long reconnectBackoffMs, long reconnectBackoffMaxMs,\n+                                   long connectionSetupTimeoutMs, long connectionSetupTimeoutMaxMs,\n+                                   LogContext logContext) {\n         this.log = logContext.logger(ClusterConnectionStates.class);\n-        this.reconnectBackoffInitMs = reconnectBackoffMs;\n-        this.reconnectBackoffMaxMs = reconnectBackoffMaxMs;\n-        this.reconnectBackoffMaxExp = Math.log(this.reconnectBackoffMaxMs / (double) Math.max(reconnectBackoffMs, 1)) / Math.log(RECONNECT_BACKOFF_EXP_BASE);\n+        this.reconnectBackoff = new GeometricProgression(\n+                reconnectBackoffMs, 2, reconnectBackoffMaxMs, 0.2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MDUxOA==", "bodyText": "why did we remove the constance and hard-code the number inline?", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439580518", "createdAt": "2020-06-12T18:30:40Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -34,19 +36,22 @@\n  *\n  */\n final class ClusterConnectionStates {\n-    private final long reconnectBackoffInitMs;\n-    private final long reconnectBackoffMaxMs;\n-    private final static int RECONNECT_BACKOFF_EXP_BASE = 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MjgxMQ==", "bodyText": "failedAttempts isn't really the number of failed connections, so not sure what we are setting timeout to.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439582811", "createdAt": "2020-06-12T18:35:47Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -158,9 +165,16 @@ public InetAddress currentAddress(String id) throws UnknownHostException {\n      */\n     public void disconnected(String id, long now) {\n         NodeConnectionState nodeState = nodeState(id);\n-        nodeState.state = ConnectionState.DISCONNECTED;\n         nodeState.lastConnectAttemptMs = now;\n-        updateReconnectBackoff(nodeState);\n+        nodeState.failedAttempts++;\n+        nodeState.reconnectBackoffMs = reconnectBackoff.term(nodeState.failedAttempts - 1);\n+        if (nodeState.state == ConnectionState.CONNECTING) {\n+            nodeState.connectionSetupTimeoutMs = connectionSetupTimeout.term(nodeState.failedAttempts);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4MzY5MA==", "bodyText": "Can't we keep this method to perform reset (perhaps rename the method) and include all types of reset?", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439583690", "createdAt": "2020-06-12T18:37:53Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -296,36 +314,6 @@ public AuthenticationException authenticationException(String id) {\n         return state != null ? state.authenticationException : null;\n     }\n \n-    /**\n-     * Resets the failure count for a node and sets the reconnect backoff to the base\n-     * value configured via reconnect.backoff.ms\n-     *\n-     * @param nodeState The node state object to update\n-     */\n-    private void resetReconnectBackoff(NodeConnectionState nodeState) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NDY3MQ==", "bodyText": "Didn't we decide to call this socket.connection.setup.timeout.ms during KIP discussion? (connection instead of connections)", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439584671", "createdAt": "2020-06-12T18:40:17Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/CommonClientConfigs.java", "diffHunk": "@@ -103,6 +103,12 @@\n         Utils.join(SecurityProtocol.names(), \", \") + \".\";\n     public static final String DEFAULT_SECURITY_PROTOCOL = \"PLAINTEXT\";\n \n+    public static final String SOCKET_CONNECTIONS_SETUP_TIMEOUT_MS_CONFIG = \"socket.connections.setup.timeout.ms\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NTMwNw==", "bodyText": "TimeOut => TimedOut", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439585307", "createdAt": "2020-06-12T18:41:40Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java", "diffHunk": "@@ -554,6 +571,7 @@ private void doSend(ClientRequest clientRequest, boolean isInternalRequest, long\n         handleDisconnections(responses, updatedNow);\n         handleConnections();\n         handleInitiateApiVersionRequests(updatedNow);\n+        handleTimeOutConnections(responses, updatedNow);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NjQyNA==", "bodyText": "Shouldn't we also check that the node is in connecting state?", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439586424", "createdAt": "2020-06-12T18:44:10Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -357,6 +345,37 @@ private NodeConnectionState nodeState(String id) {\n         return state;\n     }\n \n+    /**\n+     * Get the id set of nodes which are in CONNECTING state\n+     */\n+    public Set<String> connectingNodes() {\n+        return this.connectingNodes;\n+    }\n+\n+    /**\n+     * Get the timestamp of the latest connection attempt of a given node\n+     * @param id the connection to fetch the state for\n+     */\n+    public long lastConnectAttemptMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState == null ? 0 : nodeState.lastConnectAttemptMs;\n+    }\n+\n+    // Visible for testing\n+    long connectionSetupTimeoutMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState.connectionSetupTimeoutMs;\n+    }\n+\n+    /**\n+     * Test if the connection to the given node has reached its timeout\n+     * @param id the connection to fetch the state for\n+     * @param now the current time in ms\n+     */\n+    public boolean isConnectionSetupTimeout(String id, long now) {\n+        return now - lastConnectAttemptMs(id) > connectionSetupTimeoutMs(id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NjgwOQ==", "bodyText": "comment unnecessary since it is obvious from the line below", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439586809", "createdAt": "2020-06-12T18:45:03Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java", "diffHunk": "@@ -786,6 +808,26 @@ private void handleAbortedSends(List<ClientResponse> responses) {\n         abortedSends.clear();\n     }\n \n+    /**\n+     * Handle socket channel connection timeout. The timeout will hit iff a connection\n+     * stays at the ConnectionState.CONNECTING state longer than the timeout value,\n+     * as indicated by ClusterConnectionStates.NodeConnectionState.\n+     *\n+     * @param responses The list of responses to update\n+     * @param now The current time\n+     */\n+    private void handleTimeOutConnections(List<ClientResponse> responses, long now) {\n+        Set<String> connectingNodes = connectionStates.connectingNodes();\n+        for (String nodeId: connectingNodes) {\n+            if (connectionStates.isConnectionSetupTimeout(nodeId, now)) {\n+                // close connection to the node", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4Njk5NA==", "bodyText": "Can we include the timeout in the log line?", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439586994", "createdAt": "2020-06-12T18:45:25Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java", "diffHunk": "@@ -786,6 +808,26 @@ private void handleAbortedSends(List<ClientResponse> responses) {\n         abortedSends.clear();\n     }\n \n+    /**\n+     * Handle socket channel connection timeout. The timeout will hit iff a connection\n+     * stays at the ConnectionState.CONNECTING state longer than the timeout value,\n+     * as indicated by ClusterConnectionStates.NodeConnectionState.\n+     *\n+     * @param responses The list of responses to update\n+     * @param now The current time\n+     */\n+    private void handleTimeOutConnections(List<ClientResponse> responses, long now) {\n+        Set<String> connectingNodes = connectionStates.connectingNodes();\n+        for (String nodeId: connectingNodes) {\n+            if (connectionStates.isConnectionSetupTimeout(nodeId, now)) {\n+                // close connection to the node\n+                this.selector.close(nodeId);\n+                log.debug(\"Disconnecting from node {} due to socket connection setup timeout.\", nodeId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NzY1MA==", "bodyText": "Can we define the defaults in CommonClientConfigs?", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439587650", "createdAt": "2020-06-12T18:46:51Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/AdminClientConfig.java", "diffHunk": "@@ -149,6 +155,16 @@\n                                         atLeast(0),\n                                         Importance.MEDIUM,\n                                         REQUEST_TIMEOUT_MS_DOC)\n+                                .define(SOCKET_CONNECTIONS_SETUP_TIMEOUT_MS_CONFIG,\n+                                        Type.LONG,\n+                                        10 * 1000,\n+                                        Importance.MEDIUM,\n+                                        CommonClientConfigs.SOCKET_CONNECTIONS_SETUP_TIMEOUT_MS_DOC)\n+                                .define(SOCKET_CONNECTIONS_SETUP_TIMEOUT_MAX_MS_CONFIG,\n+                                        Type.LONG,\n+                                        127 * 1000,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4Nzk3NA==", "bodyText": "This is not exactly a geometric progression?", "url": "https://github.com/apache/kafka/pull/8683#discussion_r439587974", "createdAt": "2020-06-12T18:47:32Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/common/utils/GeometricProgression.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * An util class for exponential backoff, backoff, etc...\n+ * The formula is Term(n) = random(1 - jitter, 1 + jitter) * scaleFactor * (ratio) ^ n\n+ * If scaleFactor is greater or equal than termMax, a constant term of will be provided\n+ * This class is thread-safe\n+ */\n+public class GeometricProgression {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595"}, "originalPosition": 28}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "982957988046b5964624d29ad916de0d5d0dfab2", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/982957988046b5964624d29ad916de0d5d0dfab2", "committedDate": "2020-06-13T17:49:24Z", "message": "Rename config, extract reset and update logic, some small NIT refactor"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "982957988046b5964624d29ad916de0d5d0dfab2", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/982957988046b5964624d29ad916de0d5d0dfab2", "committedDate": "2020-06-13T17:49:24Z", "message": "Rename config, extract reset and update logic, some small NIT refactor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMjQyMDQx", "url": "https://github.com/apache/kafka/pull/8683#pullrequestreview-431242041", "createdAt": "2020-06-16T07:45:29Z", "commit": {"oid": "982957988046b5964624d29ad916de0d5d0dfab2"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwNzo0NToyOVrOGkPMtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwODoyODo0M1rOGkQx_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MDkzMg==", "bodyText": "Shouldn't we increment before computing the new reconnect backoff?", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440650932", "createdAt": "2020-06-16T07:45:29Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -300,30 +323,48 @@ public AuthenticationException authenticationException(String id) {\n      * Resets the failure count for a node and sets the reconnect backoff to the base\n      * value configured via reconnect.backoff.ms\n      *\n-     * @param nodeState The node state object to update\n+     * @param nodeState nodeState The node state object to update\n      */\n     private void resetReconnectBackoff(NodeConnectionState nodeState) {\n         nodeState.failedAttempts = 0;\n-        nodeState.reconnectBackoffMs = this.reconnectBackoffInitMs;\n+        nodeState.reconnectBackoffMs = reconnectBackoff.term(0);\n+    }\n+\n+    /**\n+     * Resets the failure count for a node and sets the connection setup timeout to the base\n+     * value configured via socket.connection.setup.timeout.ms\n+     *\n+     * @param nodeState nodeState The node state object to update\n+     */\n+    private void resetConnectionSetupTimeout(NodeConnectionState nodeState) {\n+        nodeState.failedConnectAttempts = 0;\n+        nodeState.connectionSetupTimeoutMs = connectionSetupTimeout.term(0);\n     }\n \n     /**\n-     * Update the node reconnect backoff exponentially.\n+     * Increment the failure counter, update the node reconnect backoff exponentially,\n+     * and record the current timestamp.\n      * The delay is reconnect.backoff.ms * 2**(failures - 1) * (+/- 20% random jitter)\n      * Up to a (pre-jitter) maximum of reconnect.backoff.max.ms\n      *\n      * @param nodeState The node state object to update\n      */\n-    private void updateReconnectBackoff(NodeConnectionState nodeState) {\n-        if (this.reconnectBackoffMaxMs > this.reconnectBackoffInitMs) {\n-            nodeState.failedAttempts += 1;\n-            double backoffExp = Math.min(nodeState.failedAttempts - 1, this.reconnectBackoffMaxExp);\n-            double backoffFactor = Math.pow(RECONNECT_BACKOFF_EXP_BASE, backoffExp);\n-            long reconnectBackoffMs = (long) (this.reconnectBackoffInitMs * backoffFactor);\n-            // Actual backoff is randomized to avoid connection storms.\n-            double randomFactor = ThreadLocalRandom.current().nextDouble(0.8, 1.2);\n-            nodeState.reconnectBackoffMs = (long) (randomFactor * reconnectBackoffMs);\n-        }\n+    private void incrementReconnectBackoff(NodeConnectionState nodeState, long now) {\n+        nodeState.reconnectBackoffMs = reconnectBackoff.term(nodeState.failedAttempts);\n+        nodeState.failedAttempts++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "982957988046b5964624d29ad916de0d5d0dfab2"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1NTk2OA==", "bodyText": "Are you sure that using lastConnectAttemptMs is correct here? lastConnectAttemptMs is recorded when a connection is disconnected and as we respect the reconnectBackoffMs before reconnecting, the connection timeout computed here will also include the current reconnectBackoffMs. Is this what we want? It may be better to record the time in connecting.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440655968", "createdAt": "2020-06-16T07:53:51Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -357,6 +398,36 @@ private NodeConnectionState nodeState(String id) {\n         return state;\n     }\n \n+    /**\n+     * Get the id set of nodes which are in CONNECTING state\n+     */\n+    public Set<String> connectingNodes() {\n+        return this.connectingNodes;\n+    }\n+\n+    /**\n+     * Get the timestamp of the latest connection attempt of a given node\n+     * @param id the connection to fetch the state for\n+     */\n+    public long lastConnectAttemptMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState == null ? 0 : nodeState.lastConnectAttemptMs;\n+    }\n+\n+    public long connectionSetupTimeoutMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState.connectionSetupTimeoutMs;\n+    }\n+\n+    /**\n+     * Test if the connection to the given node has reached its timeout\n+     * @param id the connection to fetch the state for\n+     * @param now the current time in ms\n+     */\n+    public boolean isConnectionSetupTimeout(String id, long now) {\n+        return now - lastConnectAttemptMs(id) > connectionSetupTimeoutMs(id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "982957988046b5964624d29ad916de0d5d0dfab2"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1NjU4Ng==", "bodyText": "Should we ensure that nodeState is not null here?", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440656586", "createdAt": "2020-06-16T07:54:53Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -357,6 +398,36 @@ private NodeConnectionState nodeState(String id) {\n         return state;\n     }\n \n+    /**\n+     * Get the id set of nodes which are in CONNECTING state\n+     */\n+    public Set<String> connectingNodes() {\n+        return this.connectingNodes;\n+    }\n+\n+    /**\n+     * Get the timestamp of the latest connection attempt of a given node\n+     * @param id the connection to fetch the state for\n+     */\n+    public long lastConnectAttemptMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState == null ? 0 : nodeState.lastConnectAttemptMs;\n+    }\n+\n+    public long connectionSetupTimeoutMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState.connectionSetupTimeoutMs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "982957988046b5964624d29ad916de0d5d0dfab2"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1ODc5Ng==", "bodyText": "It would be great if you could update the javadoc of the method to reflect this.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440658796", "createdAt": "2020-06-16T07:58:35Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java", "diffHunk": "@@ -678,7 +696,11 @@ public Node leastLoadedNode(long now) {\n             } else if (connectionStates.isPreparingConnection(node.idString())) {\n                 foundConnecting = node;\n             } else if (canConnect(node, now)) {\n-                foundCanConnect = node;\n+                if (foundCanConnect == null ||\n+                        this.connectionStates.lastConnectAttemptMs(foundCanConnect.idString()) >\n+                                this.connectionStates.lastConnectAttemptMs(node.idString())) {\n+                    foundCanConnect = node;\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "982957988046b5964624d29ad916de0d5d0dfab2"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1OTQyNg==", "bodyText": "nit: We usually put a space before and after the :.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440659426", "createdAt": "2020-06-16T07:59:41Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java", "diffHunk": "@@ -786,6 +808,29 @@ private void handleAbortedSends(List<ClientResponse> responses) {\n         abortedSends.clear();\n     }\n \n+    /**\n+     * Handle socket channel connection timeout. The timeout will hit iff a connection\n+     * stays at the ConnectionState.CONNECTING state longer than the timeout value,\n+     * as indicated by ClusterConnectionStates.NodeConnectionState.\n+     *\n+     * @param responses The list of responses to update\n+     * @param now The current time\n+     */\n+    private void handleTimeoutConnections(List<ClientResponse> responses, long now) {\n+        Set<String> connectingNodes = connectionStates.connectingNodes();\n+        for (String nodeId: connectingNodes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "982957988046b5964624d29ad916de0d5d0dfab2"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY2MTg5Mw==", "bodyText": "This one can be removed I suppose.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440661893", "createdAt": "2020-06-16T08:03:58Z", "author": {"login": "dajac"}, "path": "clients/src/test/java/org/apache/kafka/common/utils/GeometricProgressionTest.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public class GeometricProgressionTest {\n+    @Test\n+    public void testGeometricProgression() {\n+        long scaleFactor = 100;\n+        int ratio = 2;\n+        long termMax = 2000;\n+        double jitter = 0.2;\n+        GeometricProgression geometricProgression = new GeometricProgression(\n+                scaleFactor, ratio, termMax, jitter\n+        );\n+\n+        for (int i = 0; i <= 100; i++) {\n+            for (int n = 0; n <= 4; n++) {\n+                assertEquals(scaleFactor * Math.pow(ratio, n), geometricProgression.term(n),\n+                        scaleFactor * Math.pow(ratio, n) * jitter);\n+            }\n+            System.out.println(geometricProgression.term(5));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "982957988046b5964624d29ad916de0d5d0dfab2"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3MTQ4MA==", "bodyText": "nit: I would use to be established instead of to be built and I think that we should avoid putting default values in the documentation here because first the default can be changed on a per client basis and second the default will be documented based on the default value provided in config definition.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440671480", "createdAt": "2020-06-16T08:20:02Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/CommonClientConfigs.java", "diffHunk": "@@ -103,6 +103,12 @@\n         Utils.join(SecurityProtocol.names(), \", \") + \".\";\n     public static final String DEFAULT_SECURITY_PROTOCOL = \"PLAINTEXT\";\n \n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_CONFIG = \"socket.connection.setup.timeout.ms\";\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_DOC = \"The amount of time the client will wait for the initial socket connection to be built. If the connection is not built before the timeout elapses the network client will close the socket channel. The default value will be 10 seconds.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "982957988046b5964624d29ad916de0d5d0dfab2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3MTY0Nw==", "bodyText": "Same comment as above.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440671647", "createdAt": "2020-06-16T08:20:17Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/CommonClientConfigs.java", "diffHunk": "@@ -103,6 +103,12 @@\n         Utils.join(SecurityProtocol.names(), \", \") + \".\";\n     public static final String DEFAULT_SECURITY_PROTOCOL = \"PLAINTEXT\";\n \n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_CONFIG = \"socket.connection.setup.timeout.ms\";\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_DOC = \"The amount of time the client will wait for the initial socket connection to be built. If the connection is not built before the timeout elapses the network client will close the socket channel. The default value will be 10 seconds.\";\n+\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS_CONFIG = \"socket.connection.setup.timeout.max.ms\";\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS_DOC = \"The maximum amount of time the client will wait for the initial socket connection to be built. The connection setup timeout will increase exponentially for each consecutive connection failure up to this maximum. To avoid connection storms, a randomization factor of 0.2 will be applied to the backoff resulting in a random range between 20% below and 20% above the computed value. The default value will be 127 seconds.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "982957988046b5964624d29ad916de0d5d0dfab2"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3NDkwNQ==", "bodyText": "While I also recognize that we are not consistent with this, I would do it as suggested by Rajini. The defaults are the same everywhere so it makes sense to have it defined centrally for now.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440674905", "createdAt": "2020-06-16T08:25:38Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/AdminClientConfig.java", "diffHunk": "@@ -149,6 +155,16 @@\n                                         atLeast(0),\n                                         Importance.MEDIUM,\n                                         REQUEST_TIMEOUT_MS_DOC)\n+                                .define(SOCKET_CONNECTIONS_SETUP_TIMEOUT_MS_CONFIG,\n+                                        Type.LONG,\n+                                        10 * 1000,\n+                                        Importance.MEDIUM,\n+                                        CommonClientConfigs.SOCKET_CONNECTIONS_SETUP_TIMEOUT_MS_DOC)\n+                                .define(SOCKET_CONNECTIONS_SETUP_TIMEOUT_MAX_MS_CONFIG,\n+                                        Type.LONG,\n+                                        127 * 1000,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NzY1MA=="}, "originalCommit": {"oid": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3NjI0Ng==", "bodyText": "I would go with ExponentialBackoff even if we use it for computing an exponential timeout as well. I think that people will understand this.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440676246", "createdAt": "2020-06-16T08:27:46Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/common/utils/GeometricProgression.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * An util class for exponential backoff, backoff, etc...\n+ * The formula is Term(n) = random(1 - jitter, 1 + jitter) * scaleFactor * (ratio) ^ n\n+ * If scaleFactor is greater or equal than termMax, a constant term of will be provided\n+ * This class is thread-safe\n+ */\n+public class GeometricProgression {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4Nzk3NA=="}, "originalCommit": {"oid": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3Njg2Mg==", "bodyText": "nit: What about using retries instead of n? It may help to understand that the exponential value is computed based on the number of tries or retries.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r440676862", "createdAt": "2020-06-16T08:28:43Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/common/utils/GeometricProgression.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * An util class for exponential backoff, backoff, etc...\n+ * The formula is Term(n) = random(1 - jitter, 1 + jitter) * scaleFactor * (ratio) ^ n\n+ * If scaleFactor is greater or equal than termMax, a constant term of will be provided\n+ * This class is thread-safe\n+ */\n+public class GeometricProgression {\n+    private final int ratio;\n+    private final double expMax;\n+    private final long scaleFactor;\n+    private final double jitter;\n+\n+    public GeometricProgression(long scaleFactor, int ratio, long termMax, double jitter) {\n+        this.scaleFactor = scaleFactor;\n+        this.ratio = ratio;\n+        this.jitter = jitter;\n+        this.expMax = termMax > scaleFactor ?\n+                Math.log(termMax / (double) Math.max(scaleFactor, 1)) / Math.log(ratio) : 0;\n+    }\n+\n+    public long term(long n) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "982957988046b5964624d29ad916de0d5d0dfab2"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/27fa1cf7a07d14ad8a2677c73b4393531fabb43c", "committedDate": "2020-06-18T17:49:52Z", "message": "Second round refactoring"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzODg5NzAy", "url": "https://github.com/apache/kafka/pull/8683#pullrequestreview-433889702", "createdAt": "2020-06-19T08:16:23Z", "commit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwODoxNjoyM1rOGmMUcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxMDozMzowNFrOGmQKQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwMDkxNA==", "bodyText": "That makes sense. Thanks for the clarification.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442700914", "createdAt": "2020-06-19T08:16:23Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -300,30 +323,48 @@ public AuthenticationException authenticationException(String id) {\n      * Resets the failure count for a node and sets the reconnect backoff to the base\n      * value configured via reconnect.backoff.ms\n      *\n-     * @param nodeState The node state object to update\n+     * @param nodeState nodeState The node state object to update\n      */\n     private void resetReconnectBackoff(NodeConnectionState nodeState) {\n         nodeState.failedAttempts = 0;\n-        nodeState.reconnectBackoffMs = this.reconnectBackoffInitMs;\n+        nodeState.reconnectBackoffMs = reconnectBackoff.term(0);\n+    }\n+\n+    /**\n+     * Resets the failure count for a node and sets the connection setup timeout to the base\n+     * value configured via socket.connection.setup.timeout.ms\n+     *\n+     * @param nodeState nodeState The node state object to update\n+     */\n+    private void resetConnectionSetupTimeout(NodeConnectionState nodeState) {\n+        nodeState.failedConnectAttempts = 0;\n+        nodeState.connectionSetupTimeoutMs = connectionSetupTimeout.term(0);\n     }\n \n     /**\n-     * Update the node reconnect backoff exponentially.\n+     * Increment the failure counter, update the node reconnect backoff exponentially,\n+     * and record the current timestamp.\n      * The delay is reconnect.backoff.ms * 2**(failures - 1) * (+/- 20% random jitter)\n      * Up to a (pre-jitter) maximum of reconnect.backoff.max.ms\n      *\n      * @param nodeState The node state object to update\n      */\n-    private void updateReconnectBackoff(NodeConnectionState nodeState) {\n-        if (this.reconnectBackoffMaxMs > this.reconnectBackoffInitMs) {\n-            nodeState.failedAttempts += 1;\n-            double backoffExp = Math.min(nodeState.failedAttempts - 1, this.reconnectBackoffMaxExp);\n-            double backoffFactor = Math.pow(RECONNECT_BACKOFF_EXP_BASE, backoffExp);\n-            long reconnectBackoffMs = (long) (this.reconnectBackoffInitMs * backoffFactor);\n-            // Actual backoff is randomized to avoid connection storms.\n-            double randomFactor = ThreadLocalRandom.current().nextDouble(0.8, 1.2);\n-            nodeState.reconnectBackoffMs = (long) (randomFactor * reconnectBackoffMs);\n-        }\n+    private void incrementReconnectBackoff(NodeConnectionState nodeState, long now) {\n+        nodeState.reconnectBackoffMs = reconnectBackoff.term(nodeState.failedAttempts);\n+        nodeState.failedAttempts++;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1MDkzMg=="}, "originalCommit": {"oid": "982957988046b5964624d29ad916de0d5d0dfab2"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTM5NA==", "bodyText": "I would rather prefer to handle this like we did in lastConnectAttemptMs in order to remain consistent. If nodeState is null, we can return 0.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442725394", "createdAt": "2020-06-19T09:13:24Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -357,6 +398,36 @@ private NodeConnectionState nodeState(String id) {\n         return state;\n     }\n \n+    /**\n+     * Get the id set of nodes which are in CONNECTING state\n+     */\n+    public Set<String> connectingNodes() {\n+        return this.connectingNodes;\n+    }\n+\n+    /**\n+     * Get the timestamp of the latest connection attempt of a given node\n+     * @param id the connection to fetch the state for\n+     */\n+    public long lastConnectAttemptMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState == null ? 0 : nodeState.lastConnectAttemptMs;\n+    }\n+\n+    public long connectionSetupTimeoutMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState.connectionSetupTimeoutMs;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1NjU4Ng=="}, "originalCommit": {"oid": "982957988046b5964624d29ad916de0d5d0dfab2"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTU0Nw==", "bodyText": "Can we add a javadoc for this method?", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442725547", "createdAt": "2020-06-19T09:13:47Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -357,6 +399,38 @@ private NodeConnectionState nodeState(String id) {\n         return state;\n     }\n \n+    /**\n+     * Get the id set of nodes which are in CONNECTING state\n+     */\n+    public Set<String> connectingNodes() {\n+        return this.connectingNodes;\n+    }\n+\n+    /**\n+     * Get the timestamp of the latest connection attempt of a given node\n+     * @param id the connection to fetch the state for\n+     */\n+    public long lastConnectAttemptMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState == null ? 0 : nodeState.lastConnectAttemptMs;\n+    }\n+\n+    public long connectionSetupTimeoutMs(String id) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNjMzNw==", "bodyText": "That is indeed true today as the caller only calls with nodes in connectingNodes but that may not be true forever. I would add the check as suggested by Rajini here to make the implementation safe.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442726337", "createdAt": "2020-06-19T09:15:23Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -357,6 +345,37 @@ private NodeConnectionState nodeState(String id) {\n         return state;\n     }\n \n+    /**\n+     * Get the id set of nodes which are in CONNECTING state\n+     */\n+    public Set<String> connectingNodes() {\n+        return this.connectingNodes;\n+    }\n+\n+    /**\n+     * Get the timestamp of the latest connection attempt of a given node\n+     * @param id the connection to fetch the state for\n+     */\n+    public long lastConnectAttemptMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState == null ? 0 : nodeState.lastConnectAttemptMs;\n+    }\n+\n+    // Visible for testing\n+    long connectionSetupTimeoutMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState.connectionSetupTimeoutMs;\n+    }\n+\n+    /**\n+     * Test if the connection to the given node has reached its timeout\n+     * @param id the connection to fetch the state for\n+     * @param now the current time in ms\n+     */\n+    public boolean isConnectionSetupTimeout(String id, long now) {\n+        return now - lastConnectAttemptMs(id) > connectionSetupTimeoutMs(id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NjQyNA=="}, "originalCommit": {"oid": "b1a62f8bb374bd52baa4e8bdb389526ddcfd1595"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNjYwMA==", "bodyText": "Oh right. I missed the ones in connecting. Thanks for the clarification.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442726600", "createdAt": "2020-06-19T09:15:56Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -357,6 +398,36 @@ private NodeConnectionState nodeState(String id) {\n         return state;\n     }\n \n+    /**\n+     * Get the id set of nodes which are in CONNECTING state\n+     */\n+    public Set<String> connectingNodes() {\n+        return this.connectingNodes;\n+    }\n+\n+    /**\n+     * Get the timestamp of the latest connection attempt of a given node\n+     * @param id the connection to fetch the state for\n+     */\n+    public long lastConnectAttemptMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState == null ? 0 : nodeState.lastConnectAttemptMs;\n+    }\n+\n+    public long connectionSetupTimeoutMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState.connectionSetupTimeoutMs;\n+    }\n+\n+    /**\n+     * Test if the connection to the given node has reached its timeout\n+     * @param id the connection to fetch the state for\n+     * @param now the current time in ms\n+     */\n+    public boolean isConnectionSetupTimeout(String id, long now) {\n+        return now - lastConnectAttemptMs(id) > connectionSetupTimeoutMs(id);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1NTk2OA=="}, "originalCommit": {"oid": "982957988046b5964624d29ad916de0d5d0dfab2"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyOTI3NA==", "bodyText": "We usually defined constants with capital letters and underscores to separate words. Moreover, we usually put defaults next to the config and the doc. We could use the following:\n\nSOCKET_CONNECTION_SETUP_TIMEOUT_MS_DEFAULT; and\nSOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS_DEFAULT.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442729274", "createdAt": "2020-06-19T09:21:43Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/CommonClientConfigs.java", "diffHunk": "@@ -185,4 +191,9 @@ public static void warnIfDeprecatedDnsLookupValue(AbstractConfig config) {\n                 CLIENT_DNS_LOOKUP_CONFIG, ClientDnsLookup.DEFAULT,\n                 ClientDnsLookup.USE_ALL_DNS_IPS);\n     }\n+\n+    public class Defaults {\n+        public static final long SocketConnectionSetupTimeoutMs = 10 * 1000;\n+        public static final long SocketConnectionSetupTimeoutMaxMs = 127 * 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMDA4Nw==", "bodyText": "nit: I personally prefer the previous name. I would also rename handleTimeoutConnections to handleTimedOutConnections.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442730087", "createdAt": "2020-06-19T09:23:21Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java", "diffHunk": "@@ -771,7 +794,7 @@ private void processDisconnection(List<ClientResponse> responses,\n      * @param responses The list of responses to update\n      * @param now The current time\n      */\n-    private void handleTimedOutRequests(List<ClientResponse> responses, long now) {\n+    private void handleTimeoutRequests(List<ClientResponse> responses, long now) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0Nzg3Ng==", "bodyText": "I find the terminology used here not intuitive. What about using something like: initialInterval, multiplier and maxInterval? I think these are more common when it comes to configuring backoff.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442747876", "createdAt": "2020-06-19T09:58:50Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/common/utils/ExponentialBackoff.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * An utility class for exponential backoff, timeout, etc...\n+ * The formula is Term(n) = random(1 - jitter, 1 + jitter) * scaleFactor * (ratio) ^ n\n+ * If scaleFactor is greater or equal than termMax, a constant term of will be provided\n+ * This class is thread-safe\n+ */\n+public class ExponentialBackoff {\n+    private final int ratio;\n+    private final double expMax;\n+    private final long scaleFactor;\n+    private final double jitter;\n+\n+    public ExponentialBackoff(long scaleFactor, int ratio, long termMax, double jitter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0ODU2NA==", "bodyText": "nit: Let me try with another suggestion ;) What about backoff(long attempts)?", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442748564", "createdAt": "2020-06-19T10:00:11Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/common/utils/ExponentialBackoff.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * An utility class for exponential backoff, timeout, etc...\n+ * The formula is Term(n) = random(1 - jitter, 1 + jitter) * scaleFactor * (ratio) ^ n\n+ * If scaleFactor is greater or equal than termMax, a constant term of will be provided\n+ * This class is thread-safe\n+ */\n+public class ExponentialBackoff {\n+    private final int ratio;\n+    private final double expMax;\n+    private final long scaleFactor;\n+    private final double jitter;\n+\n+    public ExponentialBackoff(long scaleFactor, int ratio, long termMax, double jitter) {\n+        this.scaleFactor = scaleFactor;\n+        this.ratio = ratio;\n+        this.jitter = jitter;\n+        this.expMax = termMax > scaleFactor ?\n+                Math.log(termMax / (double) Math.max(scaleFactor, 1)) / Math.log(ratio) : 0;\n+    }\n+\n+    public long term(long n) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0OTg1MQ==", "bodyText": "nit: I would rephrase this a bit and also explain briefly how we use it in AK (e.g. connect timeout, reconnection backoff, etc.). Also, I would suggest to terminate phrases with ..", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442749851", "createdAt": "2020-06-19T10:02:49Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/common/utils/ExponentialBackoff.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * An utility class for exponential backoff, timeout, etc...", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc1NjE1NA==", "bodyText": "nit: Could we define a local constant for the base 2 and reuse it everywhere?", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442756154", "createdAt": "2020-06-19T10:16:04Z", "author": {"login": "dajac"}, "path": "clients/src/test/java/org/apache/kafka/clients/ClusterConnectionStatesTest.java", "diffHunk": "@@ -321,4 +325,37 @@ public void testIsPreparingConnection() {\n         connectionStates.disconnected(nodeId1, time.milliseconds());\n         assertFalse(connectionStates.isPreparingConnection(nodeId1));\n     }\n+\n+    @Test\n+    public void testExponentialConnectionSetupTimeout() {\n+        assertTrue(connectionStates.canConnect(nodeId1, time.milliseconds()));\n+\n+        // Check the exponential timeout growth\n+        for (int n = 0; n <= Math.log((double) connectionSetupTimeoutMaxMs / connectionSetupTimeoutMs) / Math.log(2); n++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc1NjYyNg==", "bodyText": "nit: For the jitter, what about defining a constant like reconnectBackoffJitter?", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442756626", "createdAt": "2020-06-19T10:17:10Z", "author": {"login": "dajac"}, "path": "clients/src/test/java/org/apache/kafka/clients/ClusterConnectionStatesTest.java", "diffHunk": "@@ -321,4 +325,37 @@ public void testIsPreparingConnection() {\n         connectionStates.disconnected(nodeId1, time.milliseconds());\n         assertFalse(connectionStates.isPreparingConnection(nodeId1));\n     }\n+\n+    @Test\n+    public void testExponentialConnectionSetupTimeout() {\n+        assertTrue(connectionStates.canConnect(nodeId1, time.milliseconds()));\n+\n+        // Check the exponential timeout growth\n+        for (int n = 0; n <= Math.log((double) connectionSetupTimeoutMaxMs / connectionSetupTimeoutMs) / Math.log(2); n++) {\n+            connectionStates.connecting(nodeId1, time.milliseconds(), \"localhost\", ClientDnsLookup.DEFAULT);\n+            assertTrue(connectionStates.connectingNodes().contains(nodeId1));\n+            assertEquals(connectionSetupTimeoutMs * Math.pow(2, n),\n+                    connectionStates.connectionSetupTimeoutMs(nodeId1),\n+                    connectionSetupTimeoutMs * Math.pow(2, n) * 0.2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc1NzE3Mw==", "bodyText": "nit: I would put connectionSetupTimeoutMaxMs first as it is the expected value. The same applies below.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442757173", "createdAt": "2020-06-19T10:18:14Z", "author": {"login": "dajac"}, "path": "clients/src/test/java/org/apache/kafka/clients/ClusterConnectionStatesTest.java", "diffHunk": "@@ -321,4 +325,37 @@ public void testIsPreparingConnection() {\n         connectionStates.disconnected(nodeId1, time.milliseconds());\n         assertFalse(connectionStates.isPreparingConnection(nodeId1));\n     }\n+\n+    @Test\n+    public void testExponentialConnectionSetupTimeout() {\n+        assertTrue(connectionStates.canConnect(nodeId1, time.milliseconds()));\n+\n+        // Check the exponential timeout growth\n+        for (int n = 0; n <= Math.log((double) connectionSetupTimeoutMaxMs / connectionSetupTimeoutMs) / Math.log(2); n++) {\n+            connectionStates.connecting(nodeId1, time.milliseconds(), \"localhost\", ClientDnsLookup.DEFAULT);\n+            assertTrue(connectionStates.connectingNodes().contains(nodeId1));\n+            assertEquals(connectionSetupTimeoutMs * Math.pow(2, n),\n+                    connectionStates.connectionSetupTimeoutMs(nodeId1),\n+                    connectionSetupTimeoutMs * Math.pow(2, n) * 0.2);\n+            connectionStates.disconnected(nodeId1, time.milliseconds());\n+            assertFalse(connectionStates.connectingNodes().contains(nodeId1));\n+        }\n+\n+        // Check the timeout value upper bound\n+        connectionStates.connecting(nodeId1, time.milliseconds(), \"localhost\", ClientDnsLookup.DEFAULT);\n+        assertEquals(connectionStates.connectionSetupTimeoutMs(nodeId1), connectionSetupTimeoutMaxMs, connectionSetupTimeoutMaxMs * 0.2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc2MDcyNg==", "bodyText": "It seems that we can remove these two and use the ones in CommonClientConfigs.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442760726", "createdAt": "2020-06-19T10:25:51Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/admin/BrokerApiVersionsCommand.scala", "diffHunk": "@@ -205,6 +205,8 @@ object BrokerApiVersionsCommand {\n   private object AdminClient {\n     val DefaultConnectionMaxIdleMs = 9 * 60 * 1000\n     val DefaultRequestTimeoutMs = 5000\n+    val DefaultSocketConnectionSetupMs = 10 * 1000\n+    val DefaultSocketConnectionSetupMaxMs = 127 * 1000", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc2MjE2Ng==", "bodyText": "We can use the ones defined in CommonClientConfigs here.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442762166", "createdAt": "2020-06-19T10:29:21Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/KafkaConfig.scala", "diffHunk": "@@ -88,6 +88,8 @@ object Defaults {\n   val MaxConnections: Int = Int.MaxValue\n   val ConnectionsMaxIdleMs = 10 * 60 * 1000L\n   val RequestTimeoutMs = 30000\n+  val ConnectionSetupTimeoutMs = 10 * 1000L\n+  val ConnectionSetupTimeoutMaxMs = 127 * 1000L", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc2Mzg0MQ==", "bodyText": "I think that it would be good to test with n=5 as well to ensure that termMax is already applied from it. Perhaps, we could do the following:\nfor (int n = 0; n <= 100; n++) {\n  if (n <= 4)\n    assertEquals(scaleFactor * Math.pow(ratio, n), exponentialBackoff.term(n),\n       scaleFactor * Math.pow(ratio, n) * jitter);\n  else\n    assertTrue(exponentialBackoff.term(1000) <= termMax * (1 + jitter));\n}", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442763841", "createdAt": "2020-06-19T10:33:04Z", "author": {"login": "dajac"}, "path": "clients/src/test/java/org/apache/kafka/common/utils/ExponentialBackoffTest.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public class ExponentialBackoffTest {\n+    @Test\n+    public void testExponentialBackoff() {\n+        long scaleFactor = 100;\n+        int ratio = 2;\n+        long termMax = 2000;\n+        double jitter = 0.2;\n+        ExponentialBackoff exponentialBackoff = new ExponentialBackoff(\n+                scaleFactor, ratio, termMax, jitter\n+        );\n+\n+        for (int i = 0; i <= 100; i++) {\n+            for (int n = 0; n <= 4; n++) {\n+                assertEquals(scaleFactor * Math.pow(ratio, n), exponentialBackoff.term(n),\n+                        scaleFactor * Math.pow(ratio, n) * jitter);\n+            }\n+            assertTrue(exponentialBackoff.term(1000) <= termMax * (1 + jitter));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MDMzMTIy", "url": "https://github.com/apache/kafka/pull/8683#pullrequestreview-434033122", "createdAt": "2020-06-19T12:22:01Z", "commit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxMjoyMjowMVrOGmS3Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxMjozODozMVrOGmTVDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgwODE1NA==", "bodyText": "the attempt number is incremented, but backoff value is not exactly incremented. I think we should leave it as updateReconnectBackoff.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442808154", "createdAt": "2020-06-19T12:22:01Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -158,9 +175,15 @@ public InetAddress currentAddress(String id) throws UnknownHostException {\n      */\n     public void disconnected(String id, long now) {\n         NodeConnectionState nodeState = nodeState(id);\n-        nodeState.state = ConnectionState.DISCONNECTED;\n         nodeState.lastConnectAttemptMs = now;\n-        updateReconnectBackoff(nodeState);\n+        incrementReconnectBackoff(nodeState);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgwODQwNg==", "bodyText": "update instead of increment here too?", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442808406", "createdAt": "2020-06-19T12:22:36Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -158,9 +175,15 @@ public InetAddress currentAddress(String id) throws UnknownHostException {\n      */\n     public void disconnected(String id, long now) {\n         NodeConnectionState nodeState = nodeState(id);\n-        nodeState.state = ConnectionState.DISCONNECTED;\n         nodeState.lastConnectAttemptMs = now;\n-        updateReconnectBackoff(nodeState);\n+        incrementReconnectBackoff(nodeState);\n+        if (nodeState.state == ConnectionState.CONNECTING) {\n+            incrementConnectionSetupTimeout(nodeState);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgwODYxMQ==", "bodyText": "nodeState added twice?", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442808611", "createdAt": "2020-06-19T12:23:06Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -300,30 +325,47 @@ public AuthenticationException authenticationException(String id) {\n      * Resets the failure count for a node and sets the reconnect backoff to the base\n      * value configured via reconnect.backoff.ms\n      *\n-     * @param nodeState The node state object to update\n+     * @param nodeState nodeState The node state object to update", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxMTEyNA==", "bodyText": "initial socket connection  - not initial?", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442811124", "createdAt": "2020-06-19T12:28:24Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/CommonClientConfigs.java", "diffHunk": "@@ -103,6 +103,12 @@\n         Utils.join(SecurityProtocol.names(), \", \") + \".\";\n     public static final String DEFAULT_SECURITY_PROTOCOL = \"PLAINTEXT\";\n \n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_CONFIG = \"socket.connection.setup.timeout.ms\";\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_DOC = \"The amount of time the client will wait for the initial socket connection to be established. If the connection is not built before the timeout elapses the network client will close the socket channel.\";\n+\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS_CONFIG = \"socket.connection.setup.timeout.max.ms\";\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS_DOC = \"The maximum amount of time the client will wait for the initial socket connection to be established. The connection setup timeout will increase exponentially for each consecutive connection failure up to this maximum. To avoid connection storms, a randomization factor of 0.2 will be applied to the backoff resulting in a random range between 20% below and 20% above the computed value.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxMjM3MA==", "bodyText": "I agree, the previous name was better", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442812370", "createdAt": "2020-06-19T12:31:11Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java", "diffHunk": "@@ -771,7 +794,7 @@ private void processDisconnection(List<ClientResponse> responses,\n      * @param responses The list of responses to update\n      * @param now The current time\n      */\n-    private void handleTimedOutRequests(List<ClientResponse> responses, long now) {\n+    private void handleTimeoutRequests(List<ClientResponse> responses, long now) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMDA4Nw=="}, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxNDI3OQ==", "bodyText": "In KafkaConfigs alone, we separated the defaults. For this one, we should do as @dajac suggested above (similar one is DEFAULT_SECURITY_PROTOCOL).", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442814279", "createdAt": "2020-06-19T12:35:22Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/CommonClientConfigs.java", "diffHunk": "@@ -185,4 +191,9 @@ public static void warnIfDeprecatedDnsLookupValue(AbstractConfig config) {\n                 CLIENT_DNS_LOOKUP_CONFIG, ClientDnsLookup.DEFAULT,\n                 ClientDnsLookup.USE_ALL_DNS_IPS);\n     }\n+\n+    public class Defaults {\n+        public static final long SocketConnectionSetupTimeoutMs = 10 * 1000;\n+        public static final long SocketConnectionSetupTimeoutMaxMs = 127 * 1000;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyOTI3NA=="}, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxNTc1Nw==", "bodyText": "term is non-intuitive. backoff doesn't quite fit for connection timeout, but I guess it fits with ExponentialBackoff. So unless there is a better suggestion, backoff seems reasonable.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r442815757", "createdAt": "2020-06-19T12:38:31Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/common/utils/ExponentialBackoff.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * An utility class for exponential backoff, timeout, etc...\n+ * The formula is Term(n) = random(1 - jitter, 1 + jitter) * scaleFactor * (ratio) ^ n\n+ * If scaleFactor is greater or equal than termMax, a constant term of will be provided\n+ * This class is thread-safe\n+ */\n+public class ExponentialBackoff {\n+    private final int ratio;\n+    private final double expMax;\n+    private final long scaleFactor;\n+    private final double jitter;\n+\n+    public ExponentialBackoff(long scaleFactor, int ratio, long termMax, double jitter) {\n+        this.scaleFactor = scaleFactor;\n+        this.ratio = ratio;\n+        this.jitter = jitter;\n+        this.expMax = termMax > scaleFactor ?\n+                Math.log(termMax / (double) Math.max(scaleFactor, 1)) / Math.log(ratio) : 0;\n+    }\n+\n+    public long term(long n) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0ODU2NA=="}, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e92a0f42be128011ecda49438d67c95fbc54bbc", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/3e92a0f42be128011ecda49438d67c95fbc54bbc", "committedDate": "2020-06-23T05:30:59Z", "message": "comment adoption"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2NzE1NTY2", "url": "https://github.com/apache/kafka/pull/8683#pullrequestreview-436715566", "createdAt": "2020-06-24T14:41:17Z", "commit": {"oid": "3e92a0f42be128011ecda49438d67c95fbc54bbc"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDo0MToxN1rOGoVUhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDo0NDoxNlrOGoVdXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk0NTU0MQ==", "bodyText": "Looks like the constants haven't been removed.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r444945541", "createdAt": "2020-06-24T14:41:17Z", "author": {"login": "rajinisivaram"}, "path": "core/src/main/scala/kafka/admin/BrokerApiVersionsCommand.scala", "diffHunk": "@@ -205,6 +205,8 @@ object BrokerApiVersionsCommand {\n   private object AdminClient {\n     val DefaultConnectionMaxIdleMs = 9 * 60 * 1000\n     val DefaultRequestTimeoutMs = 5000\n+    val DefaultSocketConnectionSetupMs = 10 * 1000\n+    val DefaultSocketConnectionSetupMaxMs = 127 * 1000", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc2MDcyNg=="}, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk0NzU5NA==", "bodyText": "We should be consistent with the naming above for DEFAULT_SECURITY_PROTOCOL and name this DEFAULT_SOCKET_CONNECTION_SETUP_TIMEOUT_MS. We seem to use xxx_DEFAULT in some places, but common configs here and in SslConfigs and SaslConfigs use DEFAULT_xxx, so let's stick to that.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r444947594", "createdAt": "2020-06-24T14:43:56Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/CommonClientConfigs.java", "diffHunk": "@@ -103,6 +103,14 @@\n         Utils.join(SecurityProtocol.names(), \", \") + \".\";\n     public static final String DEFAULT_SECURITY_PROTOCOL = \"PLAINTEXT\";\n \n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_CONFIG = \"socket.connection.setup.timeout.ms\";\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_DOC = \"The amount of time the client will wait for the socket connection to be established. If the connection is not built before the timeout elapses, clients will close the socket channel.\";\n+    public static final Long SOCKET_CONNECTION_SETUP_TIMEOUT_MS_DEFAULT = 10 * 1000L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e92a0f42be128011ecda49438d67c95fbc54bbc"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk0NzgwNA==", "bodyText": "As above, DEFAULT_SOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS", "url": "https://github.com/apache/kafka/pull/8683#discussion_r444947804", "createdAt": "2020-06-24T14:44:16Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/CommonClientConfigs.java", "diffHunk": "@@ -103,6 +103,14 @@\n         Utils.join(SecurityProtocol.names(), \", \") + \".\";\n     public static final String DEFAULT_SECURITY_PROTOCOL = \"PLAINTEXT\";\n \n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_CONFIG = \"socket.connection.setup.timeout.ms\";\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_DOC = \"The amount of time the client will wait for the socket connection to be established. If the connection is not built before the timeout elapses, clients will close the socket channel.\";\n+    public static final Long SOCKET_CONNECTION_SETUP_TIMEOUT_MS_DEFAULT = 10 * 1000L;\n+\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS_CONFIG = \"socket.connection.setup.timeout.max.ms\";\n+    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS_DOC = \"The maximum amount of time the client will wait for the socket connection to be established. The connection setup timeout will increase exponentially for each consecutive connection failure up to this maximum. To avoid connection storms, a randomization factor of 0.2 will be applied to the timeout resulting in a random range between 20% below and 20% above the computed value.\";\n+    public static final Long SOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS_DEFAULT = 127 * 1000L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e92a0f42be128011ecda49438d67c95fbc54bbc"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2NzIyNzg4", "url": "https://github.com/apache/kafka/pull/8683#pullrequestreview-436722788", "createdAt": "2020-06-24T14:48:29Z", "commit": {"oid": "3e92a0f42be128011ecda49438d67c95fbc54bbc"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDo0ODoyOVrOGoVqug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNDo1NDozOFrOGoV9ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk1MTIyNg==", "bodyText": "Thanks for the clarification. In this case, let's reuse the nodeState method which check null and throws an IllegalStateException as you do here. We may be able to use it in isConnectionSetupTimeout as well.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r444951226", "createdAt": "2020-06-24T14:48:29Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -357,6 +398,36 @@ private NodeConnectionState nodeState(String id) {\n         return state;\n     }\n \n+    /**\n+     * Get the id set of nodes which are in CONNECTING state\n+     */\n+    public Set<String> connectingNodes() {\n+        return this.connectingNodes;\n+    }\n+\n+    /**\n+     * Get the timestamp of the latest connection attempt of a given node\n+     * @param id the connection to fetch the state for\n+     */\n+    public long lastConnectAttemptMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState == null ? 0 : nodeState.lastConnectAttemptMs;\n+    }\n+\n+    public long connectionSetupTimeoutMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState.connectionSetupTimeoutMs;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY1NjU4Ng=="}, "originalCommit": {"oid": "982957988046b5964624d29ad916de0d5d0dfab2"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk1NDY1MA==", "bodyText": "@rajinisivaram What do you think about the proposal?", "url": "https://github.com/apache/kafka/pull/8683#discussion_r444954650", "createdAt": "2020-06-24T14:52:43Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/common/utils/ExponentialBackoff.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * An utility class for exponential backoff, timeout, etc...\n+ * The formula is Term(n) = random(1 - jitter, 1 + jitter) * scaleFactor * (ratio) ^ n\n+ * If scaleFactor is greater or equal than termMax, a constant term of will be provided\n+ * This class is thread-safe\n+ */\n+public class ExponentialBackoff {\n+    private final int ratio;\n+    private final double expMax;\n+    private final long scaleFactor;\n+    private final double jitter;\n+\n+    public ExponentialBackoff(long scaleFactor, int ratio, long termMax, double jitter) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0Nzg3Ng=="}, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk1NjA5MA==", "bodyText": "nit: It may be better to keep them as lower case to stay inline with the other constants. Or shall we convert all the others to upper case and to static constant?", "url": "https://github.com/apache/kafka/pull/8683#discussion_r444956090", "createdAt": "2020-06-24T14:54:38Z", "author": {"login": "dajac"}, "path": "clients/src/test/java/org/apache/kafka/clients/ClusterConnectionStatesTest.java", "diffHunk": "@@ -40,7 +40,12 @@\n     private final MockTime time = new MockTime();\n     private final long reconnectBackoffMs = 10 * 1000;\n     private final long reconnectBackoffMax = 60 * 1000;\n-    private final double reconnectBackoffJitter = 0.2;\n+    private final long connectionSetupTimeoutMs = 10 * 1000;\n+    private final long connectionSetupTimeoutMaxMs = 127 * 1000;\n+    private final static int RECONNECT_BACKOFF_EXP_BASE = 2;\n+    private final static double RECONNECT_BACKOFF_JITTER = 0.2;\n+    private final static int CONNECTION_SETUP_TIMEOUT_EXP_BASE = 2;\n+    private final static double CONNECTION_SETUP_TIMEOUT_JITTER = 0.2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e92a0f42be128011ecda49438d67c95fbc54bbc"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2NzkzNjAy", "url": "https://github.com/apache/kafka/pull/8683#pullrequestreview-436793602", "createdAt": "2020-06-24T16:04:26Z", "commit": {"oid": "3e92a0f42be128011ecda49438d67c95fbc54bbc"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNjowNDoyNlrOGoY_EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNjowOToyNVrOGoZLSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAwNTU4NQ==", "bodyText": "Sorry, missed this earlier. Yes, I prefer initialInterval, multiplier, and maxInterval too since they fit better with  ExponentialBackoff.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445005585", "createdAt": "2020-06-24T16:04:26Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/common/utils/ExponentialBackoff.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * An utility class for exponential backoff, timeout, etc...\n+ * The formula is Term(n) = random(1 - jitter, 1 + jitter) * scaleFactor * (ratio) ^ n\n+ * If scaleFactor is greater or equal than termMax, a constant term of will be provided\n+ * This class is thread-safe\n+ */\n+public class ExponentialBackoff {\n+    private final int ratio;\n+    private final double expMax;\n+    private final long scaleFactor;\n+    private final double jitter;\n+\n+    public ExponentialBackoff(long scaleFactor, int ratio, long termMax, double jitter) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjc0Nzg3Ng=="}, "originalCommit": {"oid": "27fa1cf7a07d14ad8a2677c73b4393531fabb43c"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAwODcxNQ==", "bodyText": "We can just make the constants in ClusterConnectionStates package-private and reuse them here?", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445008715", "createdAt": "2020-06-24T16:09:25Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/test/java/org/apache/kafka/clients/ClusterConnectionStatesTest.java", "diffHunk": "@@ -40,7 +40,12 @@\n     private final MockTime time = new MockTime();\n     private final long reconnectBackoffMs = 10 * 1000;\n     private final long reconnectBackoffMax = 60 * 1000;\n-    private final double reconnectBackoffJitter = 0.2;\n+    private final long connectionSetupTimeoutMs = 10 * 1000;\n+    private final long connectionSetupTimeoutMaxMs = 127 * 1000;\n+    private final static int RECONNECT_BACKOFF_EXP_BASE = 2;\n+    private final static double RECONNECT_BACKOFF_JITTER = 0.2;\n+    private final static int CONNECTION_SETUP_TIMEOUT_EXP_BASE = 2;\n+    private final static double CONNECTION_SETUP_TIMEOUT_JITTER = 0.2;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDk1NjA5MA=="}, "originalCommit": {"oid": "3e92a0f42be128011ecda49438d67c95fbc54bbc"}, "originalPosition": 10}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a945cfa4eeb367394b32cc6f99a1bf107333e4b", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/3a945cfa4eeb367394b32cc6f99a1bf107333e4b", "committedDate": "2020-06-24T22:45:06Z", "message": "3rd round of comment adoption"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "3a945cfa4eeb367394b32cc6f99a1bf107333e4b", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/3a945cfa4eeb367394b32cc6f99a1bf107333e4b", "committedDate": "2020-06-24T22:45:06Z", "message": "3rd round of comment adoption"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3NjIyMTM2", "url": "https://github.com/apache/kafka/pull/8683#pullrequestreview-437622136", "createdAt": "2020-06-25T15:41:55Z", "commit": {"oid": "3a945cfa4eeb367394b32cc6f99a1bf107333e4b"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNTo0MTo1NVrOGpAmMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNTo0NjoxMlrOGpAxfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1NDU3Ng==", "bodyText": "nit: This can be replaced by this.nodeState(id).", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445654576", "createdAt": "2020-06-25T15:41:55Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -357,6 +402,46 @@ private NodeConnectionState nodeState(String id) {\n         return state;\n     }\n \n+    /**\n+     * Get the id set of nodes which are in CONNECTING state\n+     */\n+    public Set<String> connectingNodes() {\n+        return this.connectingNodes;\n+    }\n+\n+    /**\n+     * Get the timestamp of the latest connection attempt of a given node\n+     * @param id the connection to fetch the state for\n+     */\n+    public long lastConnectAttemptMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState == null ? 0 : nodeState.lastConnectAttemptMs;\n+    }\n+\n+    /**\n+     * Get the current socket connection setup timeout of the given node.\n+     * The base value is defined via socket.connection.setup.timeout.\n+     * @param id the connection to fetch the state for\n+     */\n+    public long connectionSetupTimeoutMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        if (nodeState == null)\n+            throw new IllegalStateException(\"Connection to node \" + id + \" hasn't been initialized\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a945cfa4eeb367394b32cc6f99a1bf107333e4b"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1NDc4MQ==", "bodyText": "nit: You can also use this.nodeState(id) here.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445654781", "createdAt": "2020-06-25T15:42:13Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java", "diffHunk": "@@ -357,6 +402,46 @@ private NodeConnectionState nodeState(String id) {\n         return state;\n     }\n \n+    /**\n+     * Get the id set of nodes which are in CONNECTING state\n+     */\n+    public Set<String> connectingNodes() {\n+        return this.connectingNodes;\n+    }\n+\n+    /**\n+     * Get the timestamp of the latest connection attempt of a given node\n+     * @param id the connection to fetch the state for\n+     */\n+    public long lastConnectAttemptMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        return nodeState == null ? 0 : nodeState.lastConnectAttemptMs;\n+    }\n+\n+    /**\n+     * Get the current socket connection setup timeout of the given node.\n+     * The base value is defined via socket.connection.setup.timeout.\n+     * @param id the connection to fetch the state for\n+     */\n+    public long connectionSetupTimeoutMs(String id) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);\n+        if (nodeState == null)\n+            throw new IllegalStateException(\"Connection to node \" + id + \" hasn't been initialized\");\n+        return nodeState.connectionSetupTimeoutMs;\n+    }\n+\n+    /**\n+     * Test if the connection to the given node has reached its timeout\n+     * @param id the connection to fetch the state for\n+     * @param now the current time in ms\n+     */\n+    public boolean isConnectionSetupTimeout(String id, long now) {\n+        NodeConnectionState nodeState = this.nodeState.get(id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a945cfa4eeb367394b32cc6f99a1bf107333e4b"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1NzEyMA==", "bodyText": "Replace scaleFactor and termMax with the new terms.", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445657120", "createdAt": "2020-06-25T15:45:43Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/common/utils/ExponentialBackoff.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * An utility class for keeping the parameters and providing the value of exponential\n+ * retry backoff, exponential reconnect backoff, exponential timeout, etc.\n+ * The formula is\n+ * Backoff(attempts) = random(1 - jitter, 1 + jitter) * initialInterval * multiplier ^ attempts\n+ * If scaleFactor is greater or equal than termMax, a constant backoff of will be provided", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a945cfa4eeb367394b32cc6f99a1bf107333e4b"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1NzQ3MQ==", "bodyText": "nit: The formula is -> The formula is:", "url": "https://github.com/apache/kafka/pull/8683#discussion_r445657471", "createdAt": "2020-06-25T15:46:12Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/common/utils/ExponentialBackoff.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.utils;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+/**\n+ * An utility class for keeping the parameters and providing the value of exponential\n+ * retry backoff, exponential reconnect backoff, exponential timeout, etc.\n+ * The formula is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a945cfa4eeb367394b32cc6f99a1bf107333e4b"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36c9cdd4d6815e56904d5b2657e5f605888e2ea5", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/36c9cdd4d6815e56904d5b2657e5f605888e2ea5", "committedDate": "2020-06-26T00:44:15Z", "message": "4th comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a160400df526c60ce7d6550592bbafc45ecd3539", "author": {"user": {"login": "ctan888", "name": "Cheng Tan"}}, "url": "https://github.com/apache/kafka/commit/a160400df526c60ce7d6550592bbafc45ecd3539", "committedDate": "2020-06-27T23:48:01Z", "message": "merge upstream"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4OTk1ODk5", "url": "https://github.com/apache/kafka/pull/8683#pullrequestreview-438995899", "createdAt": "2020-06-29T08:37:39Z", "commit": {"oid": "a160400df526c60ce7d6550592bbafc45ecd3539"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNjg2NTA2", "url": "https://github.com/apache/kafka/pull/8683#pullrequestreview-443686506", "createdAt": "2020-07-07T08:45:49Z", "commit": {"oid": "a160400df526c60ce7d6550592bbafc45ecd3539"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwODo0NTo0OVrOGt06ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwODo0NTo0OVrOGt06ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDcwNjAyNg==", "bodyText": "@guozhangwang Thanks for reporting the exception in this code.\n@d8tltanc @dajac This code segment is unsafe, we are removing node from connectingNodes in pprocessDisconnection() while iterating over the set. We must be missing a test too (or we have a test with only one connection).", "url": "https://github.com/apache/kafka/pull/8683#discussion_r450706026", "createdAt": "2020-07-07T08:45:49Z", "author": {"login": "rajinisivaram"}, "path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java", "diffHunk": "@@ -786,6 +809,29 @@ private void handleAbortedSends(List<ClientResponse> responses) {\n         abortedSends.clear();\n     }\n \n+    /**\n+     * Handle socket channel connection timeout. The timeout will hit iff a connection\n+     * stays at the ConnectionState.CONNECTING state longer than the timeout value,\n+     * as indicated by ClusterConnectionStates.NodeConnectionState.\n+     *\n+     * @param responses The list of responses to update\n+     * @param now The current time\n+     */\n+    private void handleTimedOutConnections(List<ClientResponse> responses, long now) {\n+        Set<String> connectingNodes = connectionStates.connectingNodes();\n+        for (String nodeId : connectingNodes) {\n+            if (connectionStates.isConnectionSetupTimeout(nodeId, now)) {\n+                this.selector.close(nodeId);\n+                log.debug(\n+                    \"Disconnecting from node {} due to socket connection setup timeout. \" +\n+                    \"The timeout value is {} ms.\",\n+                    nodeId,\n+                    connectionStates.connectionSetupTimeoutMs(nodeId));\n+                processDisconnection(responses, nodeId, now, ChannelState.LOCAL_CLOSE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a160400df526c60ce7d6550592bbafc45ecd3539"}, "originalPosition": 135}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1071, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}