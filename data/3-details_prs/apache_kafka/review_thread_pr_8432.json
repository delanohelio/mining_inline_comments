{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk5NjkzMTE0", "number": 8432, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNDo0NzozN1rODvKeCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNjoxMjo1N1rODvM8Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwNzgxMTk1OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNDo0NzozN1rOGBbY5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNjowNjo1N1rOGBfEfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE1MDUwMg==", "bodyText": "The ordering is relevant (see the zip call below) and we lose it with this change. Did the tests pass with this change? If so, maybe we need to add more tests as they should not.\nSeems like the easiest fix may be to call resourceNames.distinct before using it anywhere else.", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404150502", "createdAt": "2020-04-06T14:47:37Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -2868,35 +2876,36 @@ class KafkaApis(val requestChannel: RequestChannel,\n     }\n   }\n \n-  private def authorize(request: RequestChannel.Request,\n-                        operation: AclOperation,\n-                        resourceType: ResourceType,\n-                        resourceName: String,\n-                        logIfAllowed: Boolean = true,\n-                        logIfDenied: Boolean = true,\n-                        refCount: Int = 1): Boolean = {\n+  // private package for testing\n+  private[server] def authorize(requestContext: RequestContext,\n+                                operation: AclOperation,\n+                                resourceType: ResourceType,\n+                                resourceName: String,\n+                                logIfAllowed: Boolean = true,\n+                                logIfDenied: Boolean = true,\n+                                refCount: Int = 1): Boolean = {\n     authorizer.forall { authZ =>\n       val resource = new ResourcePattern(resourceType, resourceName, PatternType.LITERAL)\n       val actions = Collections.singletonList(new Action(operation, resource, refCount, logIfAllowed, logIfDenied))\n-      authZ.authorize(request.context, actions).asScala.head == AuthorizationResult.ALLOWED\n+      authZ.authorize(requestContext, actions).asScala.head == AuthorizationResult.ALLOWED\n     }\n   }\n \n-  private def filterAuthorized(request: RequestChannel.Request,\n-                               operation: AclOperation,\n-                               resourceType: ResourceType,\n-                               resourceNames: Seq[String],\n-                               logIfAllowed: Boolean = true,\n-                               logIfDenied: Boolean = true): Set[String] = {\n+  // private package for testing\n+  private[server] def filterAuthorized(requestContext: RequestContext,\n+                                       operation: AclOperation,\n+                                       resourceType: ResourceType,\n+                                       resourceNames: Seq[String],\n+                                       logIfAllowed: Boolean = true,\n+                                       logIfDenied: Boolean = true): Set[String] = {\n     authorizer match {\n       case Some(authZ) =>\n         val groupedResourceNames = resourceNames.groupBy(identity)\n-        val actions = resourceNames.map { resourceName =>\n-          val count = groupedResourceNames(resourceName).size\n+        val actions = groupedResourceNames.map { case (resourceName, groupedNames) =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 493}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE2MjEwMw==", "bodyText": "Oh, right. Let me fix that.", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404162103", "createdAt": "2020-04-06T15:02:06Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -2868,35 +2876,36 @@ class KafkaApis(val requestChannel: RequestChannel,\n     }\n   }\n \n-  private def authorize(request: RequestChannel.Request,\n-                        operation: AclOperation,\n-                        resourceType: ResourceType,\n-                        resourceName: String,\n-                        logIfAllowed: Boolean = true,\n-                        logIfDenied: Boolean = true,\n-                        refCount: Int = 1): Boolean = {\n+  // private package for testing\n+  private[server] def authorize(requestContext: RequestContext,\n+                                operation: AclOperation,\n+                                resourceType: ResourceType,\n+                                resourceName: String,\n+                                logIfAllowed: Boolean = true,\n+                                logIfDenied: Boolean = true,\n+                                refCount: Int = 1): Boolean = {\n     authorizer.forall { authZ =>\n       val resource = new ResourcePattern(resourceType, resourceName, PatternType.LITERAL)\n       val actions = Collections.singletonList(new Action(operation, resource, refCount, logIfAllowed, logIfDenied))\n-      authZ.authorize(request.context, actions).asScala.head == AuthorizationResult.ALLOWED\n+      authZ.authorize(requestContext, actions).asScala.head == AuthorizationResult.ALLOWED\n     }\n   }\n \n-  private def filterAuthorized(request: RequestChannel.Request,\n-                               operation: AclOperation,\n-                               resourceType: ResourceType,\n-                               resourceNames: Seq[String],\n-                               logIfAllowed: Boolean = true,\n-                               logIfDenied: Boolean = true): Set[String] = {\n+  // private package for testing\n+  private[server] def filterAuthorized(requestContext: RequestContext,\n+                                       operation: AclOperation,\n+                                       resourceType: ResourceType,\n+                                       resourceNames: Seq[String],\n+                                       logIfAllowed: Boolean = true,\n+                                       logIfDenied: Boolean = true): Set[String] = {\n     authorizer match {\n       case Some(authZ) =>\n         val groupedResourceNames = resourceNames.groupBy(identity)\n-        val actions = resourceNames.map { resourceName =>\n-          val count = groupedResourceNames(resourceName).size\n+        val actions = groupedResourceNames.map { case (resourceName, groupedNames) =>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE1MDUwMg=="}, "originalCommit": null, "originalPosition": 493}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE3MTMxOA==", "bodyText": "I have extended the unit test to cover this case and updated the implementation as well.", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404171318", "createdAt": "2020-04-06T15:14:29Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -2868,35 +2876,36 @@ class KafkaApis(val requestChannel: RequestChannel,\n     }\n   }\n \n-  private def authorize(request: RequestChannel.Request,\n-                        operation: AclOperation,\n-                        resourceType: ResourceType,\n-                        resourceName: String,\n-                        logIfAllowed: Boolean = true,\n-                        logIfDenied: Boolean = true,\n-                        refCount: Int = 1): Boolean = {\n+  // private package for testing\n+  private[server] def authorize(requestContext: RequestContext,\n+                                operation: AclOperation,\n+                                resourceType: ResourceType,\n+                                resourceName: String,\n+                                logIfAllowed: Boolean = true,\n+                                logIfDenied: Boolean = true,\n+                                refCount: Int = 1): Boolean = {\n     authorizer.forall { authZ =>\n       val resource = new ResourcePattern(resourceType, resourceName, PatternType.LITERAL)\n       val actions = Collections.singletonList(new Action(operation, resource, refCount, logIfAllowed, logIfDenied))\n-      authZ.authorize(request.context, actions).asScala.head == AuthorizationResult.ALLOWED\n+      authZ.authorize(requestContext, actions).asScala.head == AuthorizationResult.ALLOWED\n     }\n   }\n \n-  private def filterAuthorized(request: RequestChannel.Request,\n-                               operation: AclOperation,\n-                               resourceType: ResourceType,\n-                               resourceNames: Seq[String],\n-                               logIfAllowed: Boolean = true,\n-                               logIfDenied: Boolean = true): Set[String] = {\n+  // private package for testing\n+  private[server] def filterAuthorized(requestContext: RequestContext,\n+                                       operation: AclOperation,\n+                                       resourceType: ResourceType,\n+                                       resourceNames: Seq[String],\n+                                       logIfAllowed: Boolean = true,\n+                                       logIfDenied: Boolean = true): Set[String] = {\n     authorizer match {\n       case Some(authZ) =>\n         val groupedResourceNames = resourceNames.groupBy(identity)\n-        val actions = resourceNames.map { resourceName =>\n-          val count = groupedResourceNames(resourceName).size\n+        val actions = groupedResourceNames.map { case (resourceName, groupedNames) =>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE1MDUwMg=="}, "originalCommit": null, "originalPosition": 493}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIxMDgxNQ==", "bodyText": "To verify, the test case failed without the second fix?", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404210815", "createdAt": "2020-04-06T16:06:57Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -2868,35 +2876,36 @@ class KafkaApis(val requestChannel: RequestChannel,\n     }\n   }\n \n-  private def authorize(request: RequestChannel.Request,\n-                        operation: AclOperation,\n-                        resourceType: ResourceType,\n-                        resourceName: String,\n-                        logIfAllowed: Boolean = true,\n-                        logIfDenied: Boolean = true,\n-                        refCount: Int = 1): Boolean = {\n+  // private package for testing\n+  private[server] def authorize(requestContext: RequestContext,\n+                                operation: AclOperation,\n+                                resourceType: ResourceType,\n+                                resourceName: String,\n+                                logIfAllowed: Boolean = true,\n+                                logIfDenied: Boolean = true,\n+                                refCount: Int = 1): Boolean = {\n     authorizer.forall { authZ =>\n       val resource = new ResourcePattern(resourceType, resourceName, PatternType.LITERAL)\n       val actions = Collections.singletonList(new Action(operation, resource, refCount, logIfAllowed, logIfDenied))\n-      authZ.authorize(request.context, actions).asScala.head == AuthorizationResult.ALLOWED\n+      authZ.authorize(requestContext, actions).asScala.head == AuthorizationResult.ALLOWED\n     }\n   }\n \n-  private def filterAuthorized(request: RequestChannel.Request,\n-                               operation: AclOperation,\n-                               resourceType: ResourceType,\n-                               resourceNames: Seq[String],\n-                               logIfAllowed: Boolean = true,\n-                               logIfDenied: Boolean = true): Set[String] = {\n+  // private package for testing\n+  private[server] def filterAuthorized(requestContext: RequestContext,\n+                                       operation: AclOperation,\n+                                       resourceType: ResourceType,\n+                                       resourceNames: Seq[String],\n+                                       logIfAllowed: Boolean = true,\n+                                       logIfDenied: Boolean = true): Set[String] = {\n     authorizer match {\n       case Some(authZ) =>\n         val groupedResourceNames = resourceNames.groupBy(identity)\n-        val actions = resourceNames.map { resourceName =>\n-          val count = groupedResourceNames(resourceName).size\n+        val actions = groupedResourceNames.map { case (resourceName, groupedNames) =>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDE1MDUwMg=="}, "originalCommit": null, "originalPosition": 493}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODIwMDAzOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNjowOToxMVrOGBfLJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNjo0NjoxMVrOGBgtXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIxMjUxOQ==", "bodyText": "Nit: I would move this to the next line, it's a bit hard to read with if/else misaligned.", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404212519", "createdAt": "2020-04-06T16:09:11Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1673,11 +1678,13 @@ class KafkaApis(val requestChannel: RequestChannel,\n       createTopicsRequest.data.topics.asScala.foreach { topic =>\n         results.add(new CreatableTopicResult().setName(topic.name))\n       }\n-      val hasClusterAuthorization = authorize(request, CREATE, CLUSTER, CLUSTER_NAME, logIfDenied = false)\n+      val hasClusterAuthorization = authorize(request.context, CREATE, CLUSTER, CLUSTER_NAME,\n+        logIfDenied = false)\n       val topics = createTopicsRequest.data.topics.asScala.map(_.name)\n-      val authorizedTopics = if (hasClusterAuthorization) topics.toSet else filterAuthorized(request, CREATE, TOPIC, topics.toSeq)\n-      val authorizedForDescribeConfigs = filterAuthorized(request, DESCRIBE_CONFIGS, TOPIC, topics.toSeq, logIfDenied = false)\n-        .map(name => name -> results.find(name)).toMap\n+      val authorizedTopics = if (hasClusterAuthorization) topics.toSet", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b16a898db41a015717079bec0aacc4dedb14df0"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIzNzY2MA==", "bodyText": "Ack.", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404237660", "createdAt": "2020-04-06T16:46:11Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1673,11 +1678,13 @@ class KafkaApis(val requestChannel: RequestChannel,\n       createTopicsRequest.data.topics.asScala.foreach { topic =>\n         results.add(new CreatableTopicResult().setName(topic.name))\n       }\n-      val hasClusterAuthorization = authorize(request, CREATE, CLUSTER, CLUSTER_NAME, logIfDenied = false)\n+      val hasClusterAuthorization = authorize(request.context, CREATE, CLUSTER, CLUSTER_NAME,\n+        logIfDenied = false)\n       val topics = createTopicsRequest.data.topics.asScala.map(_.name)\n-      val authorizedTopics = if (hasClusterAuthorization) topics.toSet else filterAuthorized(request, CREATE, TOPIC, topics.toSeq)\n-      val authorizedForDescribeConfigs = filterAuthorized(request, DESCRIBE_CONFIGS, TOPIC, topics.toSeq, logIfDenied = false)\n-        .map(name => name -> results.find(name)).toMap\n+      val authorizedTopics = if (hasClusterAuthorization) topics.toSet", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIxMjUxOQ=="}, "originalCommit": {"oid": "8b16a898db41a015717079bec0aacc4dedb14df0"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODIxMTQ5OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNjoxMTo1MVrOGBfSdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNjo0NjowNVrOGBgtHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIxNDM5MA==", "bodyText": "We can replace the next line by uniqueResourceNames.toSet? Doesn't change the behavior, but slightly better performance if there were indeed duplicates.", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404214390", "createdAt": "2020-04-06T16:11:51Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -2868,36 +2876,39 @@ class KafkaApis(val requestChannel: RequestChannel,\n     }\n   }\n \n-  private def authorize(request: RequestChannel.Request,\n-                        operation: AclOperation,\n-                        resourceType: ResourceType,\n-                        resourceName: String,\n-                        logIfAllowed: Boolean = true,\n-                        logIfDenied: Boolean = true,\n-                        refCount: Int = 1): Boolean = {\n+  // private package for testing\n+  private[server] def authorize(requestContext: RequestContext,\n+                                operation: AclOperation,\n+                                resourceType: ResourceType,\n+                                resourceName: String,\n+                                logIfAllowed: Boolean = true,\n+                                logIfDenied: Boolean = true,\n+                                refCount: Int = 1): Boolean = {\n     authorizer.forall { authZ =>\n       val resource = new ResourcePattern(resourceType, resourceName, PatternType.LITERAL)\n       val actions = Collections.singletonList(new Action(operation, resource, refCount, logIfAllowed, logIfDenied))\n-      authZ.authorize(request.context, actions).asScala.head == AuthorizationResult.ALLOWED\n+      authZ.authorize(requestContext, actions).asScala.head == AuthorizationResult.ALLOWED\n     }\n   }\n \n-  private def filterAuthorized(request: RequestChannel.Request,\n-                               operation: AclOperation,\n-                               resourceType: ResourceType,\n-                               resourceNames: Seq[String],\n-                               logIfAllowed: Boolean = true,\n-                               logIfDenied: Boolean = true): Set[String] = {\n+  // private package for testing\n+  private[server] def filterAuthorized(requestContext: RequestContext,\n+                                       operation: AclOperation,\n+                                       resourceType: ResourceType,\n+                                       resourceNames: Seq[String],\n+                                       logIfAllowed: Boolean = true,\n+                                       logIfDenied: Boolean = true): Set[String] = {\n     authorizer match {\n       case Some(authZ) =>\n+        val uniqueResourceNames = resourceNames.distinct\n         val groupedResourceNames = resourceNames.groupBy(identity)\n-        val actions = resourceNames.map { resourceName =>\n+        val actions = uniqueResourceNames.map { resourceName =>\n           val count = groupedResourceNames(resourceName).size\n           val resource = new ResourcePattern(resourceType, resourceName, PatternType.LITERAL)\n           new Action(operation, resource, count, logIfAllowed, logIfDenied)\n         }\n-        authZ.authorize(request.context, actions.asJava).asScala\n-          .zip(resourceNames)\n+        authZ.authorize(requestContext, actions.asJava).asScala\n+          .zip(uniqueResourceNames)\n           .filter { case (authzResult, _) => authzResult == AuthorizationResult.ALLOWED }\n           .map { case (_, resourceName) => resourceName }.toSet\n       case None =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b16a898db41a015717079bec0aacc4dedb14df0"}, "originalPosition": 504}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIzNzU5Nw==", "bodyText": "Yes.", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404237597", "createdAt": "2020-04-06T16:46:05Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -2868,36 +2876,39 @@ class KafkaApis(val requestChannel: RequestChannel,\n     }\n   }\n \n-  private def authorize(request: RequestChannel.Request,\n-                        operation: AclOperation,\n-                        resourceType: ResourceType,\n-                        resourceName: String,\n-                        logIfAllowed: Boolean = true,\n-                        logIfDenied: Boolean = true,\n-                        refCount: Int = 1): Boolean = {\n+  // private package for testing\n+  private[server] def authorize(requestContext: RequestContext,\n+                                operation: AclOperation,\n+                                resourceType: ResourceType,\n+                                resourceName: String,\n+                                logIfAllowed: Boolean = true,\n+                                logIfDenied: Boolean = true,\n+                                refCount: Int = 1): Boolean = {\n     authorizer.forall { authZ =>\n       val resource = new ResourcePattern(resourceType, resourceName, PatternType.LITERAL)\n       val actions = Collections.singletonList(new Action(operation, resource, refCount, logIfAllowed, logIfDenied))\n-      authZ.authorize(request.context, actions).asScala.head == AuthorizationResult.ALLOWED\n+      authZ.authorize(requestContext, actions).asScala.head == AuthorizationResult.ALLOWED\n     }\n   }\n \n-  private def filterAuthorized(request: RequestChannel.Request,\n-                               operation: AclOperation,\n-                               resourceType: ResourceType,\n-                               resourceNames: Seq[String],\n-                               logIfAllowed: Boolean = true,\n-                               logIfDenied: Boolean = true): Set[String] = {\n+  // private package for testing\n+  private[server] def filterAuthorized(requestContext: RequestContext,\n+                                       operation: AclOperation,\n+                                       resourceType: ResourceType,\n+                                       resourceNames: Seq[String],\n+                                       logIfAllowed: Boolean = true,\n+                                       logIfDenied: Boolean = true): Set[String] = {\n     authorizer match {\n       case Some(authZ) =>\n+        val uniqueResourceNames = resourceNames.distinct\n         val groupedResourceNames = resourceNames.groupBy(identity)\n-        val actions = resourceNames.map { resourceName =>\n+        val actions = uniqueResourceNames.map { resourceName =>\n           val count = groupedResourceNames(resourceName).size\n           val resource = new ResourcePattern(resourceType, resourceName, PatternType.LITERAL)\n           new Action(operation, resource, count, logIfAllowed, logIfDenied)\n         }\n-        authZ.authorize(request.context, actions.asJava).asScala\n-          .zip(resourceNames)\n+        authZ.authorize(requestContext, actions.asJava).asScala\n+          .zip(uniqueResourceNames)\n           .filter { case (authzResult, _) => authzResult == AuthorizationResult.ALLOWED }\n           .map { case (_, resourceName) => resourceName }.toSet\n       case None =>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIxNDM5MA=="}, "originalCommit": {"oid": "8b16a898db41a015717079bec0aacc4dedb14df0"}, "originalPosition": 504}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODIxNTYzOnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNjoxMjo0MlrOGBfU7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNjo0NTo0OFrOGBgsVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIxNTAyMw==", "bodyText": "Do we need to specify the val type here? Since we are passing it to niceMock, doesn't it figure it out by itself? Same question for the next test.", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404215023", "createdAt": "2020-04-06T16:12:42Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -126,6 +132,93 @@ class KafkaApisTest {\n     )\n   }\n \n+  @Test\n+  def testAuthorize(): Unit = {\n+    val authorizer: Authorizer = EasyMock.niceMock(classOf[Authorizer])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b16a898db41a015717079bec0aacc4dedb14df0"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIzNzM5OQ==", "bodyText": "It does not compile without the type: value authorize is not a member of Nothing at L153.", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404237399", "createdAt": "2020-04-06T16:45:48Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -126,6 +132,93 @@ class KafkaApisTest {\n     )\n   }\n \n+  @Test\n+  def testAuthorize(): Unit = {\n+    val authorizer: Authorizer = EasyMock.niceMock(classOf[Authorizer])", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIxNTAyMw=="}, "originalCommit": {"oid": "8b16a898db41a015717079bec0aacc4dedb14df0"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwODIxNjg2OnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNjoxMjo1N1rOGBfVpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQxNjo0NTo1OFrOGBgs0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIxNTIwNg==", "bodyText": "Nit: is the () needed here? Same question in the next test.", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404215206", "createdAt": "2020-04-06T16:12:57Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -126,6 +132,93 @@ class KafkaApisTest {\n     )\n   }\n \n+  @Test\n+  def testAuthorize(): Unit = {\n+    val authorizer: Authorizer = EasyMock.niceMock(classOf[Authorizer])\n+\n+    val operation = AclOperation.WRITE\n+    val resourceType = ResourceType.TOPIC\n+    val resourceName = \"topic-1\"\n+    val requestHeader = new RequestHeader(ApiKeys.PRODUCE, ApiKeys.PRODUCE.latestVersion(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b16a898db41a015717079bec0aacc4dedb14df0"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIzNzUyMg==", "bodyText": "Right, it is not.", "url": "https://github.com/apache/kafka/pull/8432#discussion_r404237522", "createdAt": "2020-04-06T16:45:58Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -126,6 +132,93 @@ class KafkaApisTest {\n     )\n   }\n \n+  @Test\n+  def testAuthorize(): Unit = {\n+    val authorizer: Authorizer = EasyMock.niceMock(classOf[Authorizer])\n+\n+    val operation = AclOperation.WRITE\n+    val resourceType = ResourceType.TOPIC\n+    val resourceName = \"topic-1\"\n+    val requestHeader = new RequestHeader(ApiKeys.PRODUCE, ApiKeys.PRODUCE.latestVersion(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIxNTIwNg=="}, "originalCommit": {"oid": "8b16a898db41a015717079bec0aacc4dedb14df0"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3216, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}