{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0NTMxNTAy", "number": 8233, "title": "KAFKA-9668: Iterating over KafkaStreams.getAllMetadata() results in ConcurrentModificationException", "bodyText": "Fixes KAFKA-9668\nKafkaStreams.getAllMetadata() returns StreamsMetadataState.getAllMetadata(). All the latter methods is synchronized it returns a reference to internal mutable state.  Not only does this break encapsulation, but it means any thread iterating over the returned collection when the metadata gets rebuilt will encounter a ConcurrentModificationException.\nThis change:\n\nswitches from clearing and rebuild allMetadata when onChange is called to building a new list and swapping this in. This is thread safe and has the benefit that the returned list is not empty during a rebuild: you either get the old or the new list.\nremoves synchronisation from getAllMetadata and getLocalMetadata. These are returning member variables. Synchronisation adds nothing.\nchanges getAllMetadata to wrap its return value in an unmodifiable wrapper to avoid breaking encapsulation.\nchanges the getters in StreamsMetadata to wrap their return values in unmodifiable wrapper to avoid breaking encapsulation.\n\nUnit tests have been added to cover both changes classes to ensure encapsulation and thread-safety are maintained.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-03-05T22:24:58Z", "url": "https://github.com/apache/kafka/pull/8233", "merged": true, "mergeCommit": {"oid": "ca90a8480183bf287d07baf6b3794bc51f76b89e"}, "closed": true, "closedAt": "2020-03-06T21:08:53Z", "author": {"login": "big-andy-coates"}, "timelineItems": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcKzKorAH2gAyMzg0NTMxNTAyOjUxYzc2ZmVkZDlkYThjMjdiNjY3MDc1ZDMzNGRjOGRhOWJlZDY0ODk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcKzjyDAFqTM2OTk2ODQwNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "51c76fedd9da8c27b667075d334dc8da9bed6489", "author": {"user": {"login": "big-andy-coates", "name": "Andy Coates"}}, "url": "https://github.com/apache/kafka/commit/51c76fedd9da8c27b667075d334dc8da9bed6489", "committedDate": "2020-03-05T22:22:06Z", "message": "KAFKA-9668: Iterating over KafkaStreams.getAllMetadata() results in ConcurrentModificationException\n\n`KafkaStreams.getAllMetadata()` returns `StreamsMetadataState.getAllMetadata()`. All the latter methods is `synchronized` it returns a reference to internal mutable state.  Not only does this break encapsulation, but it means any thread iterating over the returned collection when the metadata gets rebuilt will encounter a `ConcurrentModificationException`.\n\nThis change:\n * switches from clearing and rebuild `allMetadata` when `onChange` is called to building a new list and swapping this in. This is thread safe and has the benefit that the returned list is not empty during a rebuild: you either get the old or the new list.\n * removes synchronisation from `getAllMetadata` and `getLocalMetadata`. These are returning member variables. Synchronisation adds nothing.\n * changes `getAllMetadata` to wrap its return value in an unmodifiable wrapper to avoid breaking encapsulation.\n * changes the getters in `StreamsMetadata` to wrap their return values in unmodifiable wrapper to avoid breaking encapsulation."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTY4NDA3", "url": "https://github.com/apache/kafka/pull/8233#pullrequestreview-369968407", "createdAt": "2020-03-05T22:45:41Z", "commit": {"oid": "51c76fedd9da8c27b667075d334dc8da9bed6489"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMjo0NTo0MlrOFym66g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMjo0NTo0MlrOFym66g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYxMDc5NA==", "bodyText": "Why move the reset into the condition? if the passed in values are empty we should still set it to empty because the previous map may be out-dated right?", "url": "https://github.com/apache/kafka/pull/8233#discussion_r388610794", "createdAt": "2020-03-05T22:45:42Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamsMetadataState.java", "diffHunk": "@@ -316,10 +315,12 @@ private boolean hasPartitionsForAnyTopics(final List<String> topicNames, final S\n \n     private void rebuildMetadata(final Map<HostInfo, Set<TopicPartition>> activePartitionHostMap,\n                                  final Map<HostInfo, Set<TopicPartition>> standbyPartitionHostMap) {\n-        allMetadata.clear();\n         if (activePartitionHostMap.isEmpty() && standbyPartitionHostMap.isEmpty()) {\n+            allMetadata = Collections.emptyList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51c76fedd9da8c27b667075d334dc8da9bed6489"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 413, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}