{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxMTEwNzY3", "number": 9409, "title": "KAFKA-10599: Implement basic CLI tool for feature versioning system", "bodyText": "This PR implements a basic CLI tool for feature versioning system. The KIP-584 write up has been updated to suit this PR. The following is implemented in this PR:\n\n--describe:\n\nDescribe supported and finalized features.\nUsage: $> ./bin/kafka-features.sh --bootstrap-server host1:port1, host2:port2 --describe [--from-controller] [--command-config <path_to_java_properties_file>]\nOptionally, use the --from-controller option to get features from the controller.\n\n\n--upgrade-all:\n\nUpgrades all features known to the tool to their highest max version levels.\nUsage: $> ./bin/kafka-features.sh --bootstrap-server host1:port1, host2:port2 --upgrade-all [--dry-run] [--command-config <path_to_java_properties_file>]\nOptionally, use the --dry-run CLI option to preview the feature updates without actually applying them.\n\n\n--downgrade-all:\n\nDowngrades existing finalized features to the highest max version levels known to this tool.\nUsage: $> ./bin/kafka-features.sh --bootstrap-server host1:port1, host2:port2  --downgrade-all [--dry-run] [--command-config <path_to_java_properties_file>].\nOptionally, use the --dry-run CLI option to preview the feature updates without actually applying them.\n\n\n\nTests:\nAdded a new FeatureCommand integration test suite to test the CLI tool.", "createdAt": "2020-10-11T09:49:09Z", "url": "https://github.com/apache/kafka/pull/9409", "merged": true, "mergeCommit": {"oid": "d99fe49234d94bbd7893c130edbb8c7138a180c2"}, "closed": true, "closedAt": "2020-10-19T16:24:27Z", "author": {"login": "kowshik"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdRjxJ_gBqjM4NjM5NjIyMTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdTPYgCAFqTUxMDg1MTcxMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa639287eef752f050aa39bf87dfe9cc6638832c", "author": {"user": {"login": "kowshik", "name": "Kowshik Prakasam"}}, "url": "https://github.com/apache/kafka/commit/aa639287eef752f050aa39bf87dfe9cc6638832c", "committedDate": "2020-10-12T03:45:09Z", "message": "KAFKA-10599: Implement basic CLI tool for feature versioning system"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "aa639287eef752f050aa39bf87dfe9cc6638832c", "author": {"user": {"login": "kowshik", "name": "Kowshik Prakasam"}}, "url": "https://github.com/apache/kafka/commit/aa639287eef752f050aa39bf87dfe9cc6638832c", "committedDate": "2020-10-12T03:45:09Z", "message": "KAFKA-10599: Implement basic CLI tool for feature versioning system"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4", "author": {"user": {"login": "kowshik", "name": "Kowshik Prakasam"}}, "url": "https://github.com/apache/kafka/commit/06788eb9a300acc9aa78ab19b2efbee7abbb4ee4", "committedDate": "2020-10-12T16:59:12Z", "message": "Minor changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2ODA3NzUz", "url": "https://github.com/apache/kafka/pull/9409#pullrequestreview-506807753", "createdAt": "2020-10-12T17:44:27Z", "commit": {"oid": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNzo0NDoyN1rOHgHxVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxODoxMzo0NFrOHgIs9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0Mzc5Ng==", "bodyText": "Is the \\n necessary?", "url": "https://github.com/apache/kafka/pull/9409#discussion_r503443796", "createdAt": "2020-10-12T17:44:27Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0NDkyOQ==", "bodyText": "I feel we don't need the has prefix for all the options, which seem not matching with the conventions by looking at examples as CofnigCommand.scala", "url": "https://github.com/apache/kafka/pull/9409#discussion_r503444929", "createdAt": "2020-10-12T17:46:53Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+    features.toList.sorted.foreach {\n+      case feature =>\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        print(s\"Feature: $feature\")\n+        print(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        print(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+        print(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        print(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+        println(s\"\\tEpoch: $epoch\")\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, (updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\")\n+      println(ListMap(updates.toSeq.sortBy(_._1):_*)\n+                .map { case(_, (updateStr, _)) => updateStr}\n+                .mkString(\"\\n\"))\n+    } else {\n+      val result = adminClient.updateFeatures(\n+        updates.map { case(feature, (_, update)) => (feature, update)}.asJava,\n+        new UpdateFeaturesOptions())\n+      val failures = ListMap(result.values.asScala.toSeq.sortBy(_._1):_*).map {\n+        case (feature, updateFuture) =>\n+          val (updateStr, _) = updates(feature)\n+          try {\n+            updateFuture.get\n+            println(updateStr + \"\\tResult: OK\")\n+            0\n+          } catch {\n+            case e: Exception =>\n+              println(updateStr + \"\\tResult: FAILED due to \" + e.getMessage)\n+              1\n+          }\n+      }.sum\n+      if (failures > 0) {\n+        throw new UpdateFeaturesException(s\"$failures feature updates failed!\")\n+      }\n+    }\n+  }\n+\n+  def execute(): Unit = {\n+    if (opts.hasDescribeOption) {\n+      describeFeatures()\n+    } else if (opts.hasUpgradeAllOption) {\n+      upgradeAllFeatures()\n+    } else if (opts.hasDowngradeAllOption) {\n+      downgradeAllFeatures()\n+    } else {\n+      throw new IllegalStateException(\"Unexpected state: no CLI command could be executed.\")\n+    }\n+  }\n+\n+  def close(): Unit = {\n+    adminClient.close()\n+  }\n+\n+  private def createAdminClient(): Admin = {\n+    val props = new Properties()\n+    props.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, opts.bootstrapServers)\n+    Admin.create(props)\n+  }\n+}\n+\n+class FeatureCommandOptions(args: Array[String]) extends CommandDefaultOptions(args) {\n+  private val bootstrapServerOpt =\n+    parser.accepts(\"bootstrap-server\", \"REQUIRED: The Kafka server(s) to connect to.\")\n+      .withRequiredArg\n+      .describedAs(\"server to connect to\")\n+      .ofType(classOf[String])\n+  private val describeOpt = parser.accepts(\n+    \"describe\",\n+    \"Describe supported and finalized features. By default, the features are described from a\" +\n+    \" random broker. The request can be optionally directed only to the controller using the\" +\n+    \" --from-controller option.\")\n+  private val fromControllerOpt = parser.accepts(\n+    \"from-controller\",\n+    \"Describe supported and finalized features from the controller.\")\n+  private val upgradeAllOpt = parser.accepts(\n+    \"upgrade-all\",\n+    \"Upgrades all finalized features to the maximum version levels known to the tool.\" +\n+    \" This command finalizes new features known to the tool that were never finalized\" +\n+    \" previously in the cluster, but it is guaranteed to not delete any existing feature.\")\n+  private val downgradeAllOpt = parser.accepts(\n+    \"downgrade-all\",\n+    \"Downgrades all finalized features to the maximum version levels known to the tool.\" +\n+    \" This command deletes unknown features from the list of finalized features in the\" +\n+    \" cluster, but it is guaranteed to not add a new feature.\")\n+  private val dryRunOpt = parser.accepts(\n+    \"dry-run\",\n+    \"Performs a dry-run of upgrade/downgrade mutations to finalized feature without applying them.\")\n+\n+  options = parser.parse(args : _*)\n+\n+  checkArgs()\n+\n+  def has(builder: OptionSpec[_]): Boolean = options.has(builder)\n+\n+  def hasDescribeOption: Boolean = has(describeOpt)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4"}, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0NjEwMw==", "bodyText": "A random thought I have is that since describe/upgrade/downgrade are mutually-exclusive, we could define one flag like --action and pass in the different options as strings to translate the an enum matching scenario.", "url": "https://github.com/apache/kafka/pull/9409#discussion_r503446103", "createdAt": "2020-10-12T17:49:31Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+    features.toList.sorted.foreach {\n+      case feature =>\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        print(s\"Feature: $feature\")\n+        print(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        print(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+        print(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        print(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+        println(s\"\\tEpoch: $epoch\")\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, (updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\")\n+      println(ListMap(updates.toSeq.sortBy(_._1):_*)\n+                .map { case(_, (updateStr, _)) => updateStr}\n+                .mkString(\"\\n\"))\n+    } else {\n+      val result = adminClient.updateFeatures(\n+        updates.map { case(feature, (_, update)) => (feature, update)}.asJava,\n+        new UpdateFeaturesOptions())\n+      val failures = ListMap(result.values.asScala.toSeq.sortBy(_._1):_*).map {\n+        case (feature, updateFuture) =>\n+          val (updateStr, _) = updates(feature)\n+          try {\n+            updateFuture.get\n+            println(updateStr + \"\\tResult: OK\")\n+            0\n+          } catch {\n+            case e: Exception =>\n+              println(updateStr + \"\\tResult: FAILED due to \" + e.getMessage)\n+              1\n+          }\n+      }.sum\n+      if (failures > 0) {\n+        throw new UpdateFeaturesException(s\"$failures feature updates failed!\")\n+      }\n+    }\n+  }\n+\n+  def execute(): Unit = {\n+    if (opts.hasDescribeOption) {\n+      describeFeatures()\n+    } else if (opts.hasUpgradeAllOption) {\n+      upgradeAllFeatures()\n+    } else if (opts.hasDowngradeAllOption) {\n+      downgradeAllFeatures()\n+    } else {\n+      throw new IllegalStateException(\"Unexpected state: no CLI command could be executed.\")\n+    }\n+  }\n+\n+  def close(): Unit = {\n+    adminClient.close()\n+  }\n+\n+  private def createAdminClient(): Admin = {\n+    val props = new Properties()\n+    props.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, opts.bootstrapServers)\n+    Admin.create(props)\n+  }\n+}\n+\n+class FeatureCommandOptions(args: Array[String]) extends CommandDefaultOptions(args) {\n+  private val bootstrapServerOpt =\n+    parser.accepts(\"bootstrap-server\", \"REQUIRED: The Kafka server(s) to connect to.\")\n+      .withRequiredArg\n+      .describedAs(\"server to connect to\")\n+      .ofType(classOf[String])\n+  private val describeOpt = parser.accepts(\n+    \"describe\",\n+    \"Describe supported and finalized features. By default, the features are described from a\" +\n+    \" random broker. The request can be optionally directed only to the controller using the\" +\n+    \" --from-controller option.\")\n+  private val fromControllerOpt = parser.accepts(\n+    \"from-controller\",\n+    \"Describe supported and finalized features from the controller.\")\n+  private val upgradeAllOpt = parser.accepts(\n+    \"upgrade-all\",\n+    \"Upgrades all finalized features to the maximum version levels known to the tool.\" +\n+    \" This command finalizes new features known to the tool that were never finalized\" +\n+    \" previously in the cluster, but it is guaranteed to not delete any existing feature.\")\n+  private val downgradeAllOpt = parser.accepts(\n+    \"downgrade-all\",\n+    \"Downgrades all finalized features to the maximum version levels known to the tool.\" +\n+    \" This command deletes unknown features from the list of finalized features in the\" +\n+    \" cluster, but it is guaranteed to not add a new feature.\")\n+  private val dryRunOpt = parser.accepts(\n+    \"dry-run\",\n+    \"Performs a dry-run of upgrade/downgrade mutations to finalized feature without applying them.\")\n+\n+  options = parser.parse(args : _*)\n+\n+  checkArgs()\n+\n+  def has(builder: OptionSpec[_]): Boolean = options.has(builder)\n+\n+  def hasDescribeOption: Boolean = has(describeOpt)\n+\n+  def hasFromControllerOption: Boolean = has(fromControllerOpt)\n+\n+  def hasDryRunOption: Boolean = has(dryRunOpt)\n+\n+  def hasUpgradeAllOption: Boolean = has(upgradeAllOpt)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4"}, "originalPosition": 324}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0NzMxMg==", "bodyText": "Could we just log a warning in this case instead of failing?", "url": "https://github.com/apache/kafka/pull/9409#discussion_r503447312", "createdAt": "2020-10-12T17:52:09Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+    features.toList.sorted.foreach {\n+      case feature =>\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        print(s\"Feature: $feature\")\n+        print(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        print(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+        print(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        print(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+        println(s\"\\tEpoch: $epoch\")\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, (updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\")\n+      println(ListMap(updates.toSeq.sortBy(_._1):_*)\n+                .map { case(_, (updateStr, _)) => updateStr}\n+                .mkString(\"\\n\"))\n+    } else {\n+      val result = adminClient.updateFeatures(\n+        updates.map { case(feature, (_, update)) => (feature, update)}.asJava,\n+        new UpdateFeaturesOptions())\n+      val failures = ListMap(result.values.asScala.toSeq.sortBy(_._1):_*).map {\n+        case (feature, updateFuture) =>\n+          val (updateStr, _) = updates(feature)\n+          try {\n+            updateFuture.get\n+            println(updateStr + \"\\tResult: OK\")\n+            0\n+          } catch {\n+            case e: Exception =>\n+              println(updateStr + \"\\tResult: FAILED due to \" + e.getMessage)\n+              1\n+          }\n+      }.sum\n+      if (failures > 0) {\n+        throw new UpdateFeaturesException(s\"$failures feature updates failed!\")\n+      }\n+    }\n+  }\n+\n+  def execute(): Unit = {\n+    if (opts.hasDescribeOption) {\n+      describeFeatures()\n+    } else if (opts.hasUpgradeAllOption) {\n+      upgradeAllFeatures()\n+    } else if (opts.hasDowngradeAllOption) {\n+      downgradeAllFeatures()\n+    } else {\n+      throw new IllegalStateException(\"Unexpected state: no CLI command could be executed.\")\n+    }\n+  }\n+\n+  def close(): Unit = {\n+    adminClient.close()\n+  }\n+\n+  private def createAdminClient(): Admin = {\n+    val props = new Properties()\n+    props.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, opts.bootstrapServers)\n+    Admin.create(props)\n+  }\n+}\n+\n+class FeatureCommandOptions(args: Array[String]) extends CommandDefaultOptions(args) {\n+  private val bootstrapServerOpt =\n+    parser.accepts(\"bootstrap-server\", \"REQUIRED: The Kafka server(s) to connect to.\")\n+      .withRequiredArg\n+      .describedAs(\"server to connect to\")\n+      .ofType(classOf[String])\n+  private val describeOpt = parser.accepts(\n+    \"describe\",\n+    \"Describe supported and finalized features. By default, the features are described from a\" +\n+    \" random broker. The request can be optionally directed only to the controller using the\" +\n+    \" --from-controller option.\")\n+  private val fromControllerOpt = parser.accepts(\n+    \"from-controller\",\n+    \"Describe supported and finalized features from the controller.\")\n+  private val upgradeAllOpt = parser.accepts(\n+    \"upgrade-all\",\n+    \"Upgrades all finalized features to the maximum version levels known to the tool.\" +\n+    \" This command finalizes new features known to the tool that were never finalized\" +\n+    \" previously in the cluster, but it is guaranteed to not delete any existing feature.\")\n+  private val downgradeAllOpt = parser.accepts(\n+    \"downgrade-all\",\n+    \"Downgrades all finalized features to the maximum version levels known to the tool.\" +\n+    \" This command deletes unknown features from the list of finalized features in the\" +\n+    \" cluster, but it is guaranteed to not add a new feature.\")\n+  private val dryRunOpt = parser.accepts(\n+    \"dry-run\",\n+    \"Performs a dry-run of upgrade/downgrade mutations to finalized feature without applying them.\")\n+\n+  options = parser.parse(args : _*)\n+\n+  checkArgs()\n+\n+  def has(builder: OptionSpec[_]): Boolean = options.has(builder)\n+\n+  def hasDescribeOption: Boolean = has(describeOpt)\n+\n+  def hasFromControllerOption: Boolean = has(fromControllerOpt)\n+\n+  def hasDryRunOption: Boolean = has(dryRunOpt)\n+\n+  def hasUpgradeAllOption: Boolean = has(upgradeAllOpt)\n+\n+  def hasDowngradeAllOption: Boolean = has(downgradeAllOpt)\n+\n+  def bootstrapServers: String = options.valueOf(bootstrapServerOpt)\n+\n+  def checkArgs(): Unit = {\n+    CommandLineUtils.printHelpAndExitIfNeeded(this, \"This tool describes and updates finalized features.\")\n+    val numActions = Seq(describeOpt, upgradeAllOpt, downgradeAllOpt).count(has)\n+    if (numActions != 1) {\n+      CommandLineUtils.printUsageAndDie(\n+        parser,\n+        \"Command must include exactly one action: --describe, --upgrade-all, --downgrade-all.\")\n+    }\n+    CommandLineUtils.checkRequiredArgs(parser, options, bootstrapServerOpt)\n+    if (hasDryRunOption && !hasUpgradeAllOption && !hasDowngradeAllOption) {\n+      CommandLineUtils.printUsageAndDie(\n+        parser,\n+        \"Command can contain --dry-run option only when either --upgrade-all or --downgrade-all actions are provided.\")\n+    }\n+    if (hasFromControllerOption && !hasDescribeOption) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4"}, "originalPosition": 344}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0OTY1Nw==", "bodyText": "I'm not sure the exception thrown here is necessary since we already printed out the result, is this just for testing purpose?", "url": "https://github.com/apache/kafka/pull/9409#discussion_r503449657", "createdAt": "2020-10-12T17:57:21Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+    features.toList.sorted.foreach {\n+      case feature =>\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        print(s\"Feature: $feature\")\n+        print(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        print(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+        print(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        print(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+        println(s\"\\tEpoch: $epoch\")\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, (updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\")\n+      println(ListMap(updates.toSeq.sortBy(_._1):_*)\n+                .map { case(_, (updateStr, _)) => updateStr}\n+                .mkString(\"\\n\"))\n+    } else {\n+      val result = adminClient.updateFeatures(\n+        updates.map { case(feature, (_, update)) => (feature, update)}.asJava,\n+        new UpdateFeaturesOptions())\n+      val failures = ListMap(result.values.asScala.toSeq.sortBy(_._1):_*).map {\n+        case (feature, updateFuture) =>\n+          val (updateStr, _) = updates(feature)\n+          try {\n+            updateFuture.get\n+            println(updateStr + \"\\tResult: OK\")\n+            0\n+          } catch {\n+            case e: Exception =>\n+              println(updateStr + \"\\tResult: FAILED due to \" + e.getMessage)\n+              1\n+          }\n+      }.sum\n+      if (failures > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ1MjYxMw==", "bodyText": "nit: case not necessary", "url": "https://github.com/apache/kafka/pull/9409#discussion_r503452613", "createdAt": "2020-10-12T18:01:58Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+    features.toList.sorted.foreach {\n+      case feature =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ1MzIyMw==", "bodyText": "Why do we need to sort the features?", "url": "https://github.com/apache/kafka/pull/9409#discussion_r503453223", "createdAt": "2020-10-12T18:02:38Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+    features.toList.sorted.foreach {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ1NDQzNA==", "bodyText": "nit: we could do the comment immediately after the version get extracted, just like moving L132 to be after L113", "url": "https://github.com/apache/kafka/pull/9409#discussion_r503454434", "createdAt": "2020-10-12T18:05:24Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+    features.toList.sorted.foreach {\n+      case feature =>\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        print(s\"Feature: $feature\")\n+        print(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        print(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+        print(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ1OTA2MQ==", "bodyText": "Do we need a downgrade failure test as well?", "url": "https://github.com/apache/kafka/pull/9409#discussion_r503459061", "createdAt": "2020-10-12T18:13:44Z", "author": {"login": "abbccdda"}, "path": "core/src/test/scala/unit/kafka/admin/FeatureCommandTest.scala", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.api.KAFKA_2_7_IV0\n+import kafka.server.{BaseRequestTest, KafkaConfig, KafkaServer}\n+import kafka.utils.TestUtils\n+import kafka.utils.TestUtils.waitUntilTrue\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+\n+import org.junit.Assert.{assertEquals, assertTrue}\n+import org.junit.Test\n+import org.scalatest.Assertions.intercept\n+\n+class FeatureCommandTest extends BaseRequestTest {\n+  override def brokerCount: Int = 3\n+\n+  override def brokerPropertyOverrides(props: Properties): Unit = {\n+    props.put(KafkaConfig.InterBrokerProtocolVersionProp, KAFKA_2_7_IV0.toString)\n+  }\n+\n+  private def defaultSupportedFeatures(): Features[SupportedVersionRange] = {\n+    Features.supportedFeatures(Utils.mkMap(Utils.mkEntry(\"feature_1\", new SupportedVersionRange(1, 3)),\n+                                           Utils.mkEntry(\"feature_2\", new SupportedVersionRange(1, 5))))\n+  }\n+\n+  private def updateSupportedFeatures(features: Features[SupportedVersionRange],\n+                                      targetServers: Set[KafkaServer]): Unit = {\n+    targetServers.foreach(s => {\n+      s.brokerFeatures.setSupportedFeatures(features)\n+      s.zkClient.updateBrokerInfo(s.createBrokerInfo)\n+    })\n+\n+    // Wait until updates to all BrokerZNode supported features propagate to the controller.\n+    val brokerIds = targetServers.map(s => s.config.brokerId)\n+    waitUntilTrue(\n+      () => servers.exists(s => {\n+        if (s.kafkaController.isActive) {\n+          s.kafkaController.controllerContext.liveOrShuttingDownBrokers\n+            .filter(b => brokerIds.contains(b.id))\n+            .forall(b => {\n+              b.features.equals(features)\n+            })\n+        } else {\n+          false\n+        }\n+      }),\n+      \"Controller did not get broker updates\")\n+  }\n+\n+  private def updateSupportedFeaturesInAllBrokers(features: Features[SupportedVersionRange]): Unit = {\n+    updateSupportedFeatures(features, Set[KafkaServer]() ++ servers)\n+  }\n+\n+  /**\n+   * Tests if the FeatureApis#describeFeatures API works as expected when describing features before and\n+   * after upgrading features.\n+   */\n+  @Test\n+  def testDescribeFeaturesSuccess(): Unit = {\n+    updateSupportedFeaturesInAllBrokers(defaultSupportedFeatures())\n+    val featureApis = new FeatureApis(new FeatureCommandOptions(Array(\"--bootstrap-server\", brokerList, \"--describe\", \"--from-controller\")))\n+    featureApis.setSupportedFeatures(defaultSupportedFeatures())\n+    try {\n+      val initialDescribeOutput = TestUtils.grabConsoleOutput(featureApis.describeFeatures())\n+      val expectedInitialDescribeOutput =\n+        \"Feature: feature_1\\tSupportedMinVersion: 1\\tSupportedMaxVersion: 3\\tFinalizedMinVersionLevel: -\\tFinalizedMaxVersionLevel: -\\tEpoch: 0\\n\" +\n+        \"Feature: feature_2\\tSupportedMinVersion: 1\\tSupportedMaxVersion: 5\\tFinalizedMinVersionLevel: -\\tFinalizedMaxVersionLevel: -\\tEpoch: 0\\n\"\n+      assertEquals(expectedInitialDescribeOutput, initialDescribeOutput)\n+      featureApis.upgradeAllFeatures()\n+      val finalDescribeOutput = TestUtils.grabConsoleOutput(featureApis.describeFeatures())\n+      val expectedFinalDescribeOutput =\n+        \"Feature: feature_1\\tSupportedMinVersion: 1\\tSupportedMaxVersion: 3\\tFinalizedMinVersionLevel: 1\\tFinalizedMaxVersionLevel: 3\\tEpoch: 1\\n\" +\n+        \"Feature: feature_2\\tSupportedMinVersion: 1\\tSupportedMaxVersion: 5\\tFinalizedMinVersionLevel: 1\\tFinalizedMaxVersionLevel: 5\\tEpoch: 1\\n\"\n+      assertEquals(expectedFinalDescribeOutput, finalDescribeOutput)\n+    } finally {\n+      featureApis.close()\n+    }\n+  }\n+\n+  /**\n+   * Tests if the FeatureApis#upgradeAllFeatures API works as expected during a success case.\n+   */\n+  @Test\n+  def testUpgradeAllFeaturesSuccess(): Unit = {\n+    val upgradeOpts = new FeatureCommandOptions(Array(\"--bootstrap-server\", brokerList, \"--upgrade-all\"))\n+    val featureApis = new FeatureApis(upgradeOpts)\n+    try {\n+      // Step (1):\n+      // - Update the supported features across all brokers.\n+      // - Upgrade non-existing feature_1 to maxVersionLevel: 2.\n+      // - Verify results.\n+      val initialSupportedFeatures = Features.supportedFeatures(Utils.mkMap(Utils.mkEntry(\"feature_1\", new SupportedVersionRange(1, 2))))\n+      updateSupportedFeaturesInAllBrokers(initialSupportedFeatures)\n+      featureApis.setSupportedFeatures(initialSupportedFeatures)\n+      var output = TestUtils.grabConsoleOutput(featureApis.upgradeAllFeatures())\n+      var expected =\n+        \"      [Add]\\tFeature: feature_1\\tExistingFinalizedMaxVersion: -\\tNewFinalizedMaxVersion: 2\\tResult: OK\\n\"\n+      assertEquals(expected, output)\n+\n+      // Step (2):\n+      // - Update the supported features across all brokers.\n+      // - Upgrade existing feature_1 to maxVersionLevel: 3.\n+      // - Upgrade non-existing feature_2 to maxVersionLevel: 5.\n+      // - Verify results.\n+      updateSupportedFeaturesInAllBrokers(defaultSupportedFeatures())\n+      featureApis.setSupportedFeatures(defaultSupportedFeatures())\n+      output = TestUtils.grabConsoleOutput(featureApis.upgradeAllFeatures())\n+      expected =\n+        \"  [Upgrade]\\tFeature: feature_1\\tExistingFinalizedMaxVersion: 2\\tNewFinalizedMaxVersion: 3\\tResult: OK\\n\" +\n+        \"      [Add]\\tFeature: feature_2\\tExistingFinalizedMaxVersion: -\\tNewFinalizedMaxVersion: 5\\tResult: OK\\n\"\n+      assertEquals(expected, output)\n+\n+      // Step (3):\n+      // - Perform an upgrade of all features again.\n+      // - Since supported features have not changed, expect that the above action does not yield\n+      //   any results.\n+      output = TestUtils.grabConsoleOutput(featureApis.upgradeAllFeatures())\n+      assertTrue(output.isEmpty)\n+      featureApis.setOptions(upgradeOpts)\n+      output = TestUtils.grabConsoleOutput(featureApis.upgradeAllFeatures())\n+      assertTrue(output.isEmpty)\n+    } finally {\n+      featureApis.close()\n+    }\n+  }\n+\n+  /**\n+   * Tests if the FeatureApis#downgradeAllFeatures API works as expected during a success case.\n+   */\n+  @Test\n+  def testDowngradeFeaturesSuccess(): Unit = {\n+    val downgradeOpts = new FeatureCommandOptions(Array(\"--bootstrap-server\", brokerList, \"--downgrade-all\"))\n+    val upgradeOpts = new FeatureCommandOptions(Array(\"--bootstrap-server\", brokerList, \"--upgrade-all\"))\n+    val featureApis = new FeatureApis(upgradeOpts)\n+    try {\n+      // Step (1):\n+      // - Update the supported features across all brokers.\n+      // - Upgrade non-existing feature_1 to maxVersionLevel: 3.\n+      // - Upgrade non-existing feature_2 to maxVersionLevel: 5.\n+      updateSupportedFeaturesInAllBrokers(defaultSupportedFeatures())\n+      featureApis.setSupportedFeatures(defaultSupportedFeatures())\n+      featureApis.upgradeAllFeatures()\n+\n+      // Step (2):\n+      // - Downgrade existing feature_1 to maxVersionLevel: 2.\n+      // - Delete feature_2 since it is no longer supported by the FeatureApis object.\n+      // - Verify results.\n+      val downgradedFeatures = Features.supportedFeatures(Utils.mkMap(Utils.mkEntry(\"feature_1\", new SupportedVersionRange(1, 2))))\n+      featureApis.setSupportedFeatures(downgradedFeatures)\n+      featureApis.setOptions(downgradeOpts)\n+      var output = TestUtils.grabConsoleOutput(featureApis.downgradeAllFeatures())\n+      var expected =\n+        \"[Downgrade]\\tFeature: feature_1\\tExistingFinalizedMaxVersion: 3\\tNewFinalizedMaxVersion: 2\\tResult: OK\\n\" +\n+        \"   [Delete]\\tFeature: feature_2\\tExistingFinalizedMaxVersion: 5\\tNewFinalizedMaxVersion: -\\tResult: OK\\n\"\n+      assertEquals(expected, output)\n+\n+      // Step (3):\n+      // - Perform a downgrade of all features again.\n+      // - Since supported features have not changed, expect that the above action does not yield\n+      //   any results.\n+      updateSupportedFeaturesInAllBrokers(downgradedFeatures)\n+      output = TestUtils.grabConsoleOutput(featureApis.downgradeAllFeatures())\n+      assertTrue(output.isEmpty)\n+\n+      // Step (4):\n+      // - Delete feature_1 since it is no longer supported by the FeatureApis object.\n+      // - Verify results.\n+      featureApis.setSupportedFeatures(Features.emptySupportedFeatures())\n+      output = TestUtils.grabConsoleOutput(featureApis.downgradeAllFeatures())\n+      expected =\n+        \"   [Delete]\\tFeature: feature_1\\tExistingFinalizedMaxVersion: 2\\tNewFinalizedMaxVersion: -\\tResult: OK\\n\"\n+      assertEquals(expected, output)\n+    } finally {\n+      featureApis.close()\n+    }\n+  }\n+\n+  /**\n+   * Tests if the FeatureApis#upgradeAllFeatures API works as expected during a partial failure case.\n+   */\n+  @Test\n+  def testUpgradeFeaturesFailure(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06788eb9a300acc9aa78ab19b2efbee7abbb4ee4"}, "originalPosition": 201}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c57b7de4e8e93f008bc5089a615c1a539ce63c1", "author": {"user": {"login": "kowshik", "name": "Kowshik Prakasam"}}, "url": "https://github.com/apache/kafka/commit/4c57b7de4e8e93f008bc5089a615c1a539ce63c1", "committedDate": "2020-10-13T17:40:14Z", "message": "Address comments from Boyang"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4NTQ4MjY4", "url": "https://github.com/apache/kafka/pull/9409#pullrequestreview-508548268", "createdAt": "2020-10-14T16:56:46Z", "commit": {"oid": "4c57b7de4e8e93f008bc5089a615c1a539ce63c1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjo1Njo0N1rOHhcdtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQxNjo1Njo0N1rOHhcdtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDgzMTQxMg==", "bodyText": "nit: we could make these functions package private", "url": "https://github.com/apache/kafka/pull/9409#discussion_r504831412", "createdAt": "2020-10-14T16:56:47Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,359 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case _: UpdateFeaturesException =>\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4c57b7de4e8e93f008bc5089a615c1a539ce63c1"}, "originalPosition": 84}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b307227e2d540fbfa7e957f8e22ebc0f8556dc8e", "author": {"user": {"login": "kowshik", "name": "Kowshik Prakasam"}}, "url": "https://github.com/apache/kafka/commit/b307227e2d540fbfa7e957f8e22ebc0f8556dc8e", "committedDate": "2020-10-14T19:19:12Z", "message": "Address comment from Boyang"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA4ODExMjQx", "url": "https://github.com/apache/kafka/pull/9409#pullrequestreview-508811241", "createdAt": "2020-10-14T22:22:34Z", "commit": {"oid": "b307227e2d540fbfa7e957f8e22ebc0f8556dc8e"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMjoyMjozNFrOHhn7gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQyMzo1OTozNlrOHhsB_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTAxOTI2NQ==", "bodyText": "Perhaps we can describe the format is host:port list.", "url": "https://github.com/apache/kafka/pull/9409#discussion_r505019265", "createdAt": "2020-10-14T22:22:34Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,359 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case _: UpdateFeaturesException =>\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  private[admin] def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  private[admin] def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+\n+    features.toList.sorted.foreach {\n+      feature =>\n+        val output = new StringBuilder()\n+        output.append(s\"Feature: $feature\")\n+\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        output.append(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        output.append(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        output.append(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        output.append(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        output.append(s\"\\tEpoch: $epoch\")\n+\n+        println(output)\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, (updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\")\n+      println(ListMap(updates.toSeq.sortBy(_._1):_*)\n+                .map { case(_, (updateStr, _)) => updateStr}\n+                .mkString(\"\\n\"))\n+    } else {\n+      val result = adminClient.updateFeatures(\n+        updates.map { case(feature, (_, update)) => (feature, update)}.asJava,\n+        new UpdateFeaturesOptions())\n+      val failures = ListMap(result.values.asScala.toSeq.sortBy(_._1):_*).map {\n+        case (feature, updateFuture) =>\n+          val (updateStr, _) = updates(feature)\n+          try {\n+            updateFuture.get\n+            println(updateStr + \"\\tResult: OK\")\n+            0\n+          } catch {\n+            case e: Exception =>\n+              println(updateStr + \"\\tResult: FAILED due to \" + e.getMessage)\n+              1\n+          }\n+      }.sum\n+      if (failures > 0) {\n+        throw new UpdateFeaturesException(s\"$failures feature updates failed!\")\n+      }\n+    }\n+  }\n+\n+  def execute(): Unit = {\n+    if (opts.hasDescribeOption) {\n+      describeFeatures()\n+    } else if (opts.hasUpgradeAllOption) {\n+      upgradeAllFeatures()\n+    } else if (opts.hasDowngradeAllOption) {\n+      downgradeAllFeatures()\n+    } else {\n+      throw new IllegalStateException(\"Unexpected state: no CLI command could be executed.\")\n+    }\n+  }\n+\n+  def close(): Unit = {\n+    adminClient.close()\n+  }\n+\n+  private def createAdminClient(): Admin = {\n+    val props = new Properties()\n+    props.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, opts.bootstrapServers)\n+    Admin.create(props)\n+  }\n+}\n+\n+class FeatureCommandOptions(args: Array[String]) extends CommandDefaultOptions(args) {\n+  private val bootstrapServerOpt =\n+    parser.accepts(\"bootstrap-server\", \"REQUIRED: The Kafka server(s) to connect to.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b307227e2d540fbfa7e957f8e22ebc0f8556dc8e"}, "originalPosition": 295}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA3MzE5Nw==", "bodyText": "Perhaps we could use Option to avoid null?", "url": "https://github.com/apache/kafka/pull/9409#discussion_r505073197", "createdAt": "2020-10-14T23:40:13Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,359 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case _: UpdateFeaturesException =>\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  private[admin] def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  private[admin] def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+\n+    features.toList.sorted.foreach {\n+      feature =>\n+        val output = new StringBuilder()\n+        output.append(s\"Feature: $feature\")\n+\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        output.append(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        output.append(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        output.append(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        output.append(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        output.append(s\"\\tEpoch: $epoch\")\n+\n+        println(output)\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b307227e2d540fbfa7e957f8e22ebc0f8556dc8e"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA3MzY3Mg==", "bodyText": "Could we use case to avoid unnamed reference _._1?", "url": "https://github.com/apache/kafka/pull/9409#discussion_r505073672", "createdAt": "2020-10-14T23:40:53Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,359 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case _: UpdateFeaturesException =>\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  private[admin] def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  private[admin] def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+\n+    features.toList.sorted.foreach {\n+      feature =>\n+        val output = new StringBuilder()\n+        output.append(s\"Feature: $feature\")\n+\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        output.append(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        output.append(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        output.append(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        output.append(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        output.append(s\"\\tEpoch: $epoch\")\n+\n+        println(output)\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, (updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\")\n+      println(ListMap(updates.toSeq.sortBy(_._1):_*)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b307227e2d540fbfa7e957f8e22ebc0f8556dc8e"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA3NDY0Mw==", "bodyText": "Could we use case to avoid unnamed reference _._1?", "url": "https://github.com/apache/kafka/pull/9409#discussion_r505074643", "createdAt": "2020-10-14T23:42:16Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,359 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case _: UpdateFeaturesException =>\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  private[admin] def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  private[admin] def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+\n+    features.toList.sorted.foreach {\n+      feature =>\n+        val output = new StringBuilder()\n+        output.append(s\"Feature: $feature\")\n+\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        output.append(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        output.append(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        output.append(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        output.append(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        output.append(s\"\\tEpoch: $epoch\")\n+\n+        println(output)\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, (updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\")\n+      println(ListMap(updates.toSeq.sortBy(_._1):_*)\n+                .map { case(_, (updateStr, _)) => updateStr}\n+                .mkString(\"\\n\"))\n+    } else {\n+      val result = adminClient.updateFeatures(\n+        updates.map { case(feature, (_, update)) => (feature, update)}.asJava,\n+        new UpdateFeaturesOptions())\n+      val failures = ListMap(result.values.asScala.toSeq.sortBy(_._1):_*).map {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b307227e2d540fbfa7e957f8e22ebc0f8556dc8e"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA3NzkxMQ==", "bodyText": "Do we need to get the cause from ExecutionException thrown from Future?", "url": "https://github.com/apache/kafka/pull/9409#discussion_r505077911", "createdAt": "2020-10-14T23:47:02Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,359 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case _: UpdateFeaturesException =>\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  private[admin] def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  private[admin] def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+\n+    features.toList.sorted.foreach {\n+      feature =>\n+        val output = new StringBuilder()\n+        output.append(s\"Feature: $feature\")\n+\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        output.append(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        output.append(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        output.append(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        output.append(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        output.append(s\"\\tEpoch: $epoch\")\n+\n+        println(output)\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, (updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\")\n+      println(ListMap(updates.toSeq.sortBy(_._1):_*)\n+                .map { case(_, (updateStr, _)) => updateStr}\n+                .mkString(\"\\n\"))\n+    } else {\n+      val result = adminClient.updateFeatures(\n+        updates.map { case(feature, (_, update)) => (feature, update)}.asJava,\n+        new UpdateFeaturesOptions())\n+      val failures = ListMap(result.values.asScala.toSeq.sortBy(_._1):_*).map {\n+        case (feature, updateFuture) =>\n+          val (updateStr, _) = updates(feature)\n+          try {\n+            updateFuture.get\n+            println(updateStr + \"\\tResult: OK\")\n+            0\n+          } catch {\n+            case e: Exception =>\n+              println(updateStr + \"\\tResult: FAILED due to \" + e.getMessage)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b307227e2d540fbfa7e957f8e22ebc0f8556dc8e"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA4MTIxNg==", "bodyText": "The bootstrap port may be secured (e.g., SSL, SASL). So we need to be able to pass in the security configs from the command line. See commandConfigOpt in TopicCommand.", "url": "https://github.com/apache/kafka/pull/9409#discussion_r505081216", "createdAt": "2020-10-14T23:52:08Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,359 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case _: UpdateFeaturesException =>\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge the Admin client feature APIs with the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = createAdminClient()\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  private[admin] def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  private[admin] def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+\n+    features.toList.sorted.foreach {\n+      feature =>\n+        val output = new StringBuilder()\n+        output.append(s\"Feature: $feature\")\n+\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        output.append(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        output.append(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        output.append(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        output.append(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        output.append(s\"\\tEpoch: $epoch\")\n+\n+        println(output)\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, false)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, (updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, (updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, null)\n+          }\n+        }\n+    }.filter{ case(_, updateInfo) => updateInfo != null}.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\")\n+      println(ListMap(updates.toSeq.sortBy(_._1):_*)\n+                .map { case(_, (updateStr, _)) => updateStr}\n+                .mkString(\"\\n\"))\n+    } else {\n+      val result = adminClient.updateFeatures(\n+        updates.map { case(feature, (_, update)) => (feature, update)}.asJava,\n+        new UpdateFeaturesOptions())\n+      val failures = ListMap(result.values.asScala.toSeq.sortBy(_._1):_*).map {\n+        case (feature, updateFuture) =>\n+          val (updateStr, _) = updates(feature)\n+          try {\n+            updateFuture.get\n+            println(updateStr + \"\\tResult: OK\")\n+            0\n+          } catch {\n+            case e: Exception =>\n+              println(updateStr + \"\\tResult: FAILED due to \" + e.getMessage)\n+              1\n+          }\n+      }.sum\n+      if (failures > 0) {\n+        throw new UpdateFeaturesException(s\"$failures feature updates failed!\")\n+      }\n+    }\n+  }\n+\n+  def execute(): Unit = {\n+    if (opts.hasDescribeOption) {\n+      describeFeatures()\n+    } else if (opts.hasUpgradeAllOption) {\n+      upgradeAllFeatures()\n+    } else if (opts.hasDowngradeAllOption) {\n+      downgradeAllFeatures()\n+    } else {\n+      throw new IllegalStateException(\"Unexpected state: no CLI command could be executed.\")\n+    }\n+  }\n+\n+  def close(): Unit = {\n+    adminClient.close()\n+  }\n+\n+  private def createAdminClient(): Admin = {\n+    val props = new Properties()\n+    props.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, opts.bootstrapServers)\n+    Admin.create(props)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b307227e2d540fbfa7e957f8e22ebc0f8556dc8e"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA4NjQ2MQ==", "bodyText": "Could this be a val?", "url": "https://github.com/apache/kafka/pull/9409#discussion_r505086461", "createdAt": "2020-10-14T23:59:36Z", "author": {"login": "junrao"}, "path": "core/src/test/scala/unit/kafka/admin/FeatureCommandTest.scala", "diffHunk": "@@ -0,0 +1,245 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.api.KAFKA_2_7_IV0\n+import kafka.server.{BaseRequestTest, KafkaConfig, KafkaServer}\n+import kafka.utils.TestUtils\n+import kafka.utils.TestUtils.waitUntilTrue\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+\n+import org.junit.Assert.{assertEquals, assertTrue}\n+import org.junit.Test\n+import org.scalatest.Assertions.intercept\n+\n+class FeatureCommandTest extends BaseRequestTest {\n+  override def brokerCount: Int = 3\n+\n+  override def brokerPropertyOverrides(props: Properties): Unit = {\n+    props.put(KafkaConfig.InterBrokerProtocolVersionProp, KAFKA_2_7_IV0.toString)\n+  }\n+\n+  private def defaultSupportedFeatures(): Features[SupportedVersionRange] = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b307227e2d540fbfa7e957f8e22ebc0f8556dc8e"}, "originalPosition": 40}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ef54f5aad2acaa3734200332daaf7787219d0df", "author": {"user": {"login": "kowshik", "name": "Kowshik Prakasam"}}, "url": "https://github.com/apache/kafka/commit/0ef54f5aad2acaa3734200332daaf7787219d0df", "committedDate": "2020-10-16T19:35:42Z", "message": "Address comments from Jun"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98f6888d44181e22decd4371877a7b935d963706", "author": {"user": {"login": "kowshik", "name": "Kowshik Prakasam"}}, "url": "https://github.com/apache/kafka/commit/98f6888d44181e22decd4371877a7b935d963706", "committedDate": "2020-10-16T19:42:18Z", "message": "Small changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c4906b50154c24025fc55966beb6b420eb18180", "author": {"user": {"login": "kowshik", "name": "Kowshik Prakasam"}}, "url": "https://github.com/apache/kafka/commit/0c4906b50154c24025fc55966beb6b420eb18180", "committedDate": "2020-10-16T19:43:39Z", "message": "Small change"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNzY2NTYy", "url": "https://github.com/apache/kafka/pull/9409#pullrequestreview-510766562", "createdAt": "2020-10-16T20:05:50Z", "commit": {"oid": "0c4906b50154c24025fc55966beb6b420eb18180"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMDowNTo1MFrOHjOSzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQyMDoxMDoxMlrOHjOZiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5NjM5Ng==", "bodyText": "If we hit ExecutionException and the exception has a cause, the wrapper ExecutionException is not really relevant and we should just print the cause. See TopicCommand as a reference.", "url": "https://github.com/apache/kafka/pull/9409#discussion_r506696396", "createdAt": "2020-10-16T20:05:50Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,393 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case _: UpdateFeaturesException =>\n+        exitCode = 1\n+      case e: Throwable =>\n+        printException(e)\n+        exitCode = 1\n+    } finally {\n+      featureApis.close()\n+      Exit.exit(exitCode)\n+    }\n+  }\n+\n+  private def printException(exception: Throwable): Unit = {\n+    System.err.println(\"\\nError encountered when executing command: \" + Utils.stackTrace(exception))\n+  }\n+}\n+\n+class UpdateFeaturesException(message: String) extends RuntimeException(message)\n+\n+/**\n+ * A class that provides necessary APIs to bridge feature APIs provided by the the Admin client with\n+ * the requirements of the CLI tool.\n+ *\n+ * @param opts the CLI options\n+ */\n+class FeatureApis(var opts: FeatureCommandOptions) {\n+  private var supportedFeatures = BrokerFeatures.createDefault().supportedFeatures\n+  private val adminClient = {\n+    val props = new Properties()\n+    props.putAll(opts.commandConfig)\n+    props.put(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, opts.bootstrapServers)\n+    Admin.create(props)\n+  }\n+\n+  private def pad(op: String): String = {\n+    f\"$op%11s\"\n+  }\n+\n+  private val addOp = pad(\"[Add]\")\n+  private val upgradeOp = pad(\"[Upgrade]\")\n+  private val deleteOp = pad(\"[Delete]\")\n+  private val downgradeOp = pad(\"[Downgrade]\")\n+\n+  // For testing only.\n+  private[admin] def setSupportedFeatures(newFeatures: Features[SupportedVersionRange]): Unit = {\n+    supportedFeatures = newFeatures\n+  }\n+\n+  // For testing only.\n+  private[admin] def setOptions(newOpts: FeatureCommandOptions): Unit = {\n+    opts = newOpts\n+  }\n+\n+  private def describeFeatures(sendRequestToController: Boolean): FeatureMetadata = {\n+    val options = new DescribeFeaturesOptions().sendRequestToController(sendRequestToController)\n+    adminClient.describeFeatures(options).featureMetadata().get()\n+  }\n+\n+  /**\n+   * Describes the supported and finalized features. If the --from-controller CLI option\n+   * is provided, then the request is issued only to the controller, otherwise the request is issued\n+   * to any of the provided bootstrap servers.\n+   */\n+  def describeFeatures(): Unit = {\n+    val result = describeFeatures(opts.hasFromControllerOption)\n+    val features = result.supportedFeatures.asScala.keys.toSet ++ result.finalizedFeatures.asScala.keys.toSet\n+\n+    features.toList.sorted.foreach {\n+      feature =>\n+        val output = new StringBuilder()\n+        output.append(s\"Feature: $feature\")\n+\n+        val (supportedMinVersion, supportedMaxVersion) = {\n+          val supportedVersionRange = result.supportedFeatures.get(feature)\n+          if (supportedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (supportedVersionRange.minVersion, supportedVersionRange.maxVersion)\n+          }\n+        }\n+        output.append(s\"\\tSupportedMinVersion: $supportedMinVersion\")\n+        output.append(s\"\\tSupportedMaxVersion: $supportedMaxVersion\")\n+\n+        val (finalizedMinVersionLevel, finalizedMaxVersionLevel) = {\n+          val finalizedVersionRange = result.finalizedFeatures.get(feature)\n+          if (finalizedVersionRange == null) {\n+            (\"-\", \"-\")\n+          } else {\n+            (finalizedVersionRange.minVersionLevel, finalizedVersionRange.maxVersionLevel)\n+          }\n+        }\n+        output.append(s\"\\tFinalizedMinVersionLevel: $finalizedMinVersionLevel\")\n+        output.append(s\"\\tFinalizedMaxVersionLevel: $finalizedMaxVersionLevel\")\n+\n+        val epoch = {\n+          if (result.finalizedFeaturesEpoch.isPresent) {\n+            result.finalizedFeaturesEpoch.get.toString\n+          } else {\n+            \"-\"\n+          }\n+        }\n+        output.append(s\"\\tEpoch: $epoch\")\n+\n+        println(output)\n+    }\n+  }\n+\n+  /**\n+   * Upgrades all features known to this tool to their highest max version levels. The method may\n+   * add new finalized features if they were not finalized previously, but it does not delete\n+   * any existing finalized feature. The results of the feature updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def upgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val updates = supportedFeatures.features.asScala.map {\n+      case (feature, targetVersionRange) =>\n+        val existingVersionRange = existingFinalizedFeatures.get(feature)\n+        if (existingVersionRange == null) {\n+          val updateStr =\n+            addOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: -\" +\n+            s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+          (feature, Some((updateStr, new FeatureUpdate(targetVersionRange.max, false))))\n+        } else {\n+          if (targetVersionRange.max > existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              upgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, Some((updateStr, new FeatureUpdate(targetVersionRange.max, false))))\n+          } else {\n+            (feature, Option.empty)\n+          }\n+        }\n+    }.filter {\n+      case(_, updateInfo) => updateInfo.isDefined\n+    }.map {\n+      case(feature, updateInfo) => (feature, updateInfo.get)\n+    }.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Downgrades existing finalized features to the highest max version levels known to this tool.\n+   * The method may delete existing finalized features if they are no longer seen to be supported,\n+   * but it does not add a feature that was not finalized previously. The results of the feature\n+   * updates are written to STDOUT.\n+   *\n+   * NOTE: if the --dry-run CLI option is provided, this method only prints the expected feature\n+   * updates to STDOUT, without applying them.\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  def downgradeAllFeatures(): Unit = {\n+    val metadata = describeFeatures(true)\n+    val existingFinalizedFeatures = metadata.finalizedFeatures\n+    val supportedFeaturesMap = supportedFeatures.features\n+    val updates = existingFinalizedFeatures.asScala.map {\n+      case (feature, existingVersionRange) =>\n+        val targetVersionRange = supportedFeaturesMap.get(feature)\n+        if (targetVersionRange == null) {\n+          val updateStr =\n+            deleteOp +\n+            s\"\\tFeature: $feature\" +\n+            s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+            s\"\\tNewFinalizedMaxVersion: -\"\n+          (feature, Some(updateStr, new FeatureUpdate(0, true)))\n+        } else {\n+          if (targetVersionRange.max < existingVersionRange.maxVersionLevel) {\n+            val updateStr =\n+              downgradeOp +\n+              s\"\\tFeature: $feature\" +\n+              s\"\\tExistingFinalizedMaxVersion: ${existingVersionRange.maxVersionLevel}\" +\n+              s\"\\tNewFinalizedMaxVersion: ${targetVersionRange.max}\"\n+            (feature, Some(updateStr, new FeatureUpdate(targetVersionRange.max, true)))\n+          } else {\n+            (feature, Option.empty)\n+          }\n+        }\n+    }.filter {\n+      case(_, updateInfo) => updateInfo.isDefined\n+    }.map {\n+      case(feature, updateInfo) => (feature, updateInfo.get)\n+    }.toMap\n+\n+    if (updates.nonEmpty) {\n+      maybeApplyFeatureUpdates(updates)\n+    }\n+  }\n+\n+  /**\n+   * Applies the provided feature updates. If the --dry-run CLI option is provided, the method\n+   * only prints the expected feature updates to STDOUT without applying them.\n+   *\n+   * @param updates the feature updates to be applied via the admin client\n+   *\n+   * @throws UpdateFeaturesException if at least one of the feature updates failed\n+   */\n+  private def maybeApplyFeatureUpdates(updates: Map[String, (String, FeatureUpdate)]): Unit = {\n+    if (opts.hasDryRunOption) {\n+      println(\"Expected feature updates:\" + ListMap(\n+        updates\n+          .toSeq\n+          .sortBy { case(feature, _) => feature} :_*)\n+          .map { case(_, (updateStr, _)) => updateStr}\n+          .mkString(\"\\n\"))\n+    } else {\n+      val result = adminClient.updateFeatures(\n+        updates\n+          .map { case(feature, (_, update)) => (feature, update)}\n+          .asJava,\n+        new UpdateFeaturesOptions())\n+      val resultSortedByFeature = ListMap(\n+        result\n+          .values\n+          .asScala\n+          .toSeq\n+          .sortBy { case(feature, _) => feature} :_*)\n+      val failures = resultSortedByFeature.map {\n+        case (feature, updateFuture) =>\n+          val (updateStr, _) = updates(feature)\n+          try {\n+            updateFuture.get\n+            println(updateStr + \"\\tResult: OK\")\n+            0\n+          } catch {\n+            case e: Exception =>\n+              println(updateStr + \"\\tResult: FAILED due to \" + e)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c4906b50154c24025fc55966beb6b420eb18180"}, "originalPosition": 284}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5ODEyMw==", "bodyText": "It seems that we can hit ExecutionException through describeFeatures. We want to handle it properly too.", "url": "https://github.com/apache/kafka/pull/9409#discussion_r506698123", "createdAt": "2020-10-16T20:10:12Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/admin/FeatureCommand.scala", "diffHunk": "@@ -0,0 +1,393 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package kafka.admin\n+\n+import kafka.server.BrokerFeatures\n+import kafka.utils.{CommandDefaultOptions, CommandLineUtils, Exit}\n+import org.apache.kafka.clients.CommonClientConfigs\n+import org.apache.kafka.clients.admin.{Admin, DescribeFeaturesOptions, FeatureMetadata, FeatureUpdate, UpdateFeaturesOptions}\n+import org.apache.kafka.common.feature.{Features, SupportedVersionRange}\n+import org.apache.kafka.common.utils.Utils\n+\n+import java.util.Properties\n+import scala.collection.Seq\n+import scala.collection.immutable.ListMap\n+import scala.jdk.CollectionConverters._\n+\n+import joptsimple.OptionSpec\n+\n+object FeatureCommand {\n+\n+  def main(args: Array[String]): Unit = {\n+    val opts = new FeatureCommandOptions(args)\n+    val featureApis = new FeatureApis(opts)\n+    var exitCode = 0\n+    try {\n+      featureApis.execute()\n+    } catch {\n+      case e: IllegalArgumentException =>\n+        printException(e)\n+        opts.parser.printHelpOn(System.err)\n+        exitCode = 1\n+      case _: UpdateFeaturesException =>\n+        exitCode = 1\n+      case e: Throwable =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0c4906b50154c24025fc55966beb6b420eb18180"}, "originalPosition": 49}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a03f973b18d2468cd8a114e5b7ce22f2bf279b4", "author": {"user": {"login": "kowshik", "name": "Kowshik Prakasam"}}, "url": "https://github.com/apache/kafka/commit/7a03f973b18d2468cd8a114e5b7ce22f2bf279b4", "committedDate": "2020-10-16T21:31:39Z", "message": "Address comments from Jun"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecdb0830e433bd445d73bd51c9ea50a0226afc01", "author": {"user": {"login": "kowshik", "name": "Kowshik Prakasam"}}, "url": "https://github.com/apache/kafka/commit/ecdb0830e433bd445d73bd51c9ea50a0226afc01", "committedDate": "2020-10-16T22:24:15Z", "message": "Small improvement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e568285c314102b9e4f7351badfcdf73a5c5a53", "author": {"user": {"login": "kowshik", "name": "Kowshik Prakasam"}}, "url": "https://github.com/apache/kafka/commit/2e568285c314102b9e4f7351badfcdf73a5c5a53", "committedDate": "2020-10-16T22:32:10Z", "message": "Small improvement"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODMxNzI5", "url": "https://github.com/apache/kafka/pull/9409#pullrequestreview-510831729", "createdAt": "2020-10-16T22:32:26Z", "commit": {"oid": "ecdb0830e433bd445d73bd51c9ea50a0226afc01"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwODUxNzEx", "url": "https://github.com/apache/kafka/pull/9409#pullrequestreview-510851711", "createdAt": "2020-10-16T23:57:08Z", "commit": {"oid": "2e568285c314102b9e4f7351badfcdf73a5c5a53"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 498, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}