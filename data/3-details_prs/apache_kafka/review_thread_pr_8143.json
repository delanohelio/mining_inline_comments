{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4MDEyMjQ4", "number": 8143, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMjoxNjo0MFrODhvmxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNzozODo1N1rODh9UoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NzA5NTcyOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMjoxNjo0MFrOFsposw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMzowMDozM1rOFsqRGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2MzgyNw==", "bodyText": "This one in particular might be worth a comment that we're specifically checking because we don't want to call methods on the producer during an unclean close.", "url": "https://github.com/apache/kafka/pull/8143#discussion_r382363827", "createdAt": "2020-02-21T02:16:40Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "diffHunk": "@@ -1317,26 +1317,24 @@ public void shouldNotCloseProducerIfFencedOnCloseDuringCleanCloseWithEosEnabled(\n     }\n \n     @Test\n-    public void shouldAbortTransactionAndCloseProducerOnUncleanCloseWithEosEnabled() {\n+    public void shouldCloseProducerOnUncleanCloseWithEosEnabled() {\n         task = createStatelessTask(createConfig(true), StreamsConfig.METRICS_LATEST);\n         task.initializeTopology();\n \n         task.close(false, false);\n         task = null;\n \n-        assertTrue(producer.transactionAborted());\n-        assertFalse(producer.transactionInFlight());\n+        assertTrue(producer.transactionInFlight());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f315cac4a96db56ec72d3d5524a7e9042537234"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NDE3MQ==", "bodyText": "Sounds good!", "url": "https://github.com/apache/kafka/pull/8143#discussion_r382374171", "createdAt": "2020-02-21T03:00:33Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "diffHunk": "@@ -1317,26 +1317,24 @@ public void shouldNotCloseProducerIfFencedOnCloseDuringCleanCloseWithEosEnabled(\n     }\n \n     @Test\n-    public void shouldAbortTransactionAndCloseProducerOnUncleanCloseWithEosEnabled() {\n+    public void shouldCloseProducerOnUncleanCloseWithEosEnabled() {\n         task = createStatelessTask(createConfig(true), StreamsConfig.METRICS_LATEST);\n         task.initializeTopology();\n \n         task.close(false, false);\n         task = null;\n \n-        assertTrue(producer.transactionAborted());\n-        assertFalse(producer.transactionInFlight());\n+        assertTrue(producer.transactionInFlight());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2MzgyNw=="}, "originalCommit": {"oid": "4f315cac4a96db56ec72d3d5524a7e9042537234"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2OTM0MzA1OnYy", "diffSide": "LEFT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNzozODo1N1rOFs_C7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxODoyNzoxOVrOFtAYjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNDYwNA==", "bodyText": "I think there are some callers of suspend that would set clean to false while isZombie to false as well, e.g. suspendRunningTasks in this case should we still call abortTxn?", "url": "https://github.com/apache/kafka/pull/8143#discussion_r382714604", "createdAt": "2020-02-21T17:38:57Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -662,37 +650,26 @@ void suspend(final boolean clean,\n             }\n \n             if (eosEnabled) {\n-                maybeAbortTransactionAndCloseRecordCollector(isZombie);\n+                // Ignore any exceptions whilee closing the record collector, i.e task producer.\n+                closeRecordCollector();\n             }\n         }\n     }\n \n-    private void maybeAbortTransactionAndCloseRecordCollector(final boolean isZombie) {\n-        if (!isZombie) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "79860652913ae6f48141dbea92fefb06f65292ea"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNzgyOA==", "bodyText": "That call is inside the catch block of task.suspend. For simplicity, I think calling abortTxn is not very tempting at this point as well.", "url": "https://github.com/apache/kafka/pull/8143#discussion_r382717828", "createdAt": "2020-02-21T17:45:45Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -662,37 +650,26 @@ void suspend(final boolean clean,\n             }\n \n             if (eosEnabled) {\n-                maybeAbortTransactionAndCloseRecordCollector(isZombie);\n+                // Ignore any exceptions whilee closing the record collector, i.e task producer.\n+                closeRecordCollector();\n             }\n         }\n     }\n \n-    private void maybeAbortTransactionAndCloseRecordCollector(final boolean isZombie) {\n-        if (!isZombie) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNDYwNA=="}, "originalCommit": {"oid": "79860652913ae6f48141dbea92fefb06f65292ea"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczMTkwMQ==", "bodyText": "After another thought, I'm pretty sure the purpose of this PR is not to maintain the caller of abortTxn in either mode to simplify our error handling. The other txn mechanism like InitPid will make sure to cleanup the pending transactions or through the txn timeout. However the risk of calling abortTxn during close is much higher than a normal processing loop, at least for today's producer. If the producer is in FATAL_ERROR, it becomes a bomb for any caller touching on its APIs except close().\nWe could think of doing some safe abort operations for producer internally instead of externally, which could be done by either getting a new API or just change the default behavior of producer.close to do the transaction abortion when time allowed.", "url": "https://github.com/apache/kafka/pull/8143#discussion_r382731901", "createdAt": "2020-02-21T18:17:27Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -662,37 +650,26 @@ void suspend(final boolean clean,\n             }\n \n             if (eosEnabled) {\n-                maybeAbortTransactionAndCloseRecordCollector(isZombie);\n+                // Ignore any exceptions whilee closing the record collector, i.e task producer.\n+                closeRecordCollector();\n             }\n         }\n     }\n \n-    private void maybeAbortTransactionAndCloseRecordCollector(final boolean isZombie) {\n-        if (!isZombie) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNDYwNA=="}, "originalCommit": {"oid": "79860652913ae6f48141dbea92fefb06f65292ea"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjczNjUyNg==", "bodyText": "Cool I think I am convinced, let's just ignore the isZombie flag then.", "url": "https://github.com/apache/kafka/pull/8143#discussion_r382736526", "createdAt": "2020-02-21T18:27:19Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -662,37 +650,26 @@ void suspend(final boolean clean,\n             }\n \n             if (eosEnabled) {\n-                maybeAbortTransactionAndCloseRecordCollector(isZombie);\n+                // Ignore any exceptions whilee closing the record collector, i.e task producer.\n+                closeRecordCollector();\n             }\n         }\n     }\n \n-    private void maybeAbortTransactionAndCloseRecordCollector(final boolean isZombie) {\n-        if (!isZombie) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNDYwNA=="}, "originalCommit": {"oid": "79860652913ae6f48141dbea92fefb06f65292ea"}, "originalPosition": 74}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4055, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}