{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyNDA5MTA3", "number": 9689, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjoxMTozMlrOFC5EBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzozMzozOVrOFE_Auw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NTc2MzkxOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/AbstractFetcherThread.scala", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMjoxMTozMlrOICRfcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOTo1ODoxMlrOIDA3ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI1NDY0MQ==", "bodyText": "Should it call setPartition?", "url": "https://github.com/apache/kafka/pull/9689#discussion_r539254641", "createdAt": "2020-12-09T12:11:32Z", "author": {"login": "chia7712"}, "path": "core/src/main/scala/kafka/server/AbstractFetcherThread.scala", "diffHunk": "@@ -160,7 +161,9 @@ abstract class AbstractFetcherThread(name: String,\n       if (state.isTruncating) {\n         latestEpoch(tp) match {\n           case Some(epoch) if isOffsetForLeaderEpochSupported =>\n-            partitionsWithEpochs += tp -> new EpochData(Optional.of(state.currentLeaderEpoch), epoch)\n+            partitionsWithEpochs += tp -> new EpochData()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db69e9e7a4d55887a44c8a407c950e9c17efeff"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAxNzA2OA==", "bodyText": "Good catch! Let me fix this.", "url": "https://github.com/apache/kafka/pull/9689#discussion_r540017068", "createdAt": "2020-12-10T09:39:03Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/AbstractFetcherThread.scala", "diffHunk": "@@ -160,7 +161,9 @@ abstract class AbstractFetcherThread(name: String,\n       if (state.isTruncating) {\n         latestEpoch(tp) match {\n           case Some(epoch) if isOffsetForLeaderEpochSupported =>\n-            partitionsWithEpochs += tp -> new EpochData(Optional.of(state.currentLeaderEpoch), epoch)\n+            partitionsWithEpochs += tp -> new EpochData()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI1NDY0MQ=="}, "originalCommit": {"oid": "3db69e9e7a4d55887a44c8a407c950e9c17efeff"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAzMDg4Mw==", "bodyText": "I have updated tests to catch this.", "url": "https://github.com/apache/kafka/pull/9689#discussion_r540030883", "createdAt": "2020-12-10T09:58:12Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/AbstractFetcherThread.scala", "diffHunk": "@@ -160,7 +161,9 @@ abstract class AbstractFetcherThread(name: String,\n       if (state.isTruncating) {\n         latestEpoch(tp) match {\n           case Some(epoch) if isOffsetForLeaderEpochSupported =>\n-            partitionsWithEpochs += tp -> new EpochData(Optional.of(state.currentLeaderEpoch), epoch)\n+            partitionsWithEpochs += tp -> new EpochData()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI1NDY0MQ=="}, "originalCommit": {"oid": "3db69e9e7a4d55887a44c8a407c950e9c17efeff"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4ODcxMDM2OnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/common/requests/OffsetsForLeaderEpochRequest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMjozNzozNVrOICsuvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwOTozODo0NlrOIDAApA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwMDkyNg==", "bodyText": "Could we use RequestUtils.getLeaderEpoch?", "url": "https://github.com/apache/kafka/pull/9689#discussion_r539700926", "createdAt": "2020-12-09T22:37:35Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/OffsetsForLeaderEpochRequest.java", "diffHunk": "@@ -143,30 +127,24 @@ public AbstractResponse getErrorResponse(int throttleTimeMs, Throwable e) {\n         return new OffsetsForLeaderEpochResponse(responseData);\n     }\n \n-    public static class PartitionData {\n-        public final Optional<Integer> currentLeaderEpoch;\n-        public final int leaderEpoch;\n-\n-        public PartitionData(Optional<Integer> currentLeaderEpoch, int leaderEpoch) {\n-            this.currentLeaderEpoch = currentLeaderEpoch;\n-            this.leaderEpoch = leaderEpoch;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            StringBuilder bld = new StringBuilder();\n-            bld.append(\"(currentLeaderEpoch=\").append(currentLeaderEpoch).\n-                append(\", leaderEpoch=\").append(leaderEpoch).\n-                append(\")\");\n-            return bld.toString();\n-        }\n-    }\n-\n     /**\n      * Check whether a broker allows Topic-level permissions in order to use the\n      * OffsetForLeaderEpoch API. Old versions require Cluster permission.\n      */\n     public static boolean supportsTopicPermission(short latestUsableVersion) {\n         return latestUsableVersion >= 3;\n     }\n+\n+    /**\n+     * Exposed `OffsetForLeaderPartition.currentLeaderEpoch` as an `java.util.Optional`.\n+     *\n+     * Classes auto-generated based on the protocol do not support `java.util.Optional` yet. This\n+     * is a temporary workaround until that work is completed.\n+     */\n+    public static Optional<Integer> currentLeaderEpochOpt(OffsetForLeaderPartition offsetForLeaderPartition) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db69e9e7a4d55887a44c8a407c950e9c17efeff"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAxNjgwNA==", "bodyText": "Yes, let me change this.", "url": "https://github.com/apache/kafka/pull/9689#discussion_r540016804", "createdAt": "2020-12-10T09:38:46Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/OffsetsForLeaderEpochRequest.java", "diffHunk": "@@ -143,30 +127,24 @@ public AbstractResponse getErrorResponse(int throttleTimeMs, Throwable e) {\n         return new OffsetsForLeaderEpochResponse(responseData);\n     }\n \n-    public static class PartitionData {\n-        public final Optional<Integer> currentLeaderEpoch;\n-        public final int leaderEpoch;\n-\n-        public PartitionData(Optional<Integer> currentLeaderEpoch, int leaderEpoch) {\n-            this.currentLeaderEpoch = currentLeaderEpoch;\n-            this.leaderEpoch = leaderEpoch;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            StringBuilder bld = new StringBuilder();\n-            bld.append(\"(currentLeaderEpoch=\").append(currentLeaderEpoch).\n-                append(\", leaderEpoch=\").append(leaderEpoch).\n-                append(\")\");\n-            return bld.toString();\n-        }\n-    }\n-\n     /**\n      * Check whether a broker allows Topic-level permissions in order to use the\n      * OffsetForLeaderEpoch API. Old versions require Cluster permission.\n      */\n     public static boolean supportsTopicPermission(short latestUsableVersion) {\n         return latestUsableVersion >= 3;\n     }\n+\n+    /**\n+     * Exposed `OffsetForLeaderPartition.currentLeaderEpoch` as an `java.util.Optional`.\n+     *\n+     * Classes auto-generated based on the protocol do not support `java.util.Optional` yet. This\n+     * is a temporary workaround until that work is completed.\n+     */\n+    public static Optional<Integer> currentLeaderEpochOpt(OffsetForLeaderPartition offsetForLeaderPartition) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwMDkyNg=="}, "originalCommit": {"oid": "3db69e9e7a4d55887a44c8a407c950e9c17efeff"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4ODcxNTU1OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/AbstractFetcherThread.scala", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMjozOToxNFrOICsxzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMDo1Mzo0NlrOIFK1Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwMTcxMQ==", "bodyText": "Maybe we can use scala.compat.java8.OptionConverters._?", "url": "https://github.com/apache/kafka/pull/9689#discussion_r539701711", "createdAt": "2020-12-09T22:39:14Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AbstractFetcherThread.scala", "diffHunk": "@@ -268,11 +271,12 @@ abstract class AbstractFetcherThread(name: String,\n             fetchOffsets.put(tp, offsetTruncationState)\n \n         case Errors.FENCED_LEADER_EPOCH =>\n-          if (onPartitionFenced(tp, latestEpochsForPartitions.get(tp).flatMap {\n-            p =>\n-              if (p.currentLeaderEpoch.isPresent) Some(p.currentLeaderEpoch.get())\n-              else None\n-          })) partitionsWithError += tp\n+          val currentLeaderEpoch = latestEpochsForPartitions.get(tp) match {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3db69e9e7a4d55887a44c8a407c950e9c17efeff"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDAxNjY2Mg==", "bodyText": "We could but that would require two conversions instead of one:\nval currentLeaderEpoch = latestEpochsForPartitions.get(tp).flatMap { p =>\n    RequestUtils.getLeaderEpoch(p.currentLeaderEpoch).asScala\n}.asJava\n\nI have a small preference for the current approach to avoid this.", "url": "https://github.com/apache/kafka/pull/9689#discussion_r540016662", "createdAt": "2020-12-10T09:38:37Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/AbstractFetcherThread.scala", "diffHunk": "@@ -268,11 +271,12 @@ abstract class AbstractFetcherThread(name: String,\n             fetchOffsets.put(tp, offsetTruncationState)\n \n         case Errors.FENCED_LEADER_EPOCH =>\n-          if (onPartitionFenced(tp, latestEpochsForPartitions.get(tp).flatMap {\n-            p =>\n-              if (p.currentLeaderEpoch.isPresent) Some(p.currentLeaderEpoch.get())\n-              else None\n-          })) partitionsWithError += tp\n+          val currentLeaderEpoch = latestEpochsForPartitions.get(tp) match {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwMTcxMQ=="}, "originalCommit": {"oid": "3db69e9e7a4d55887a44c8a407c950e9c17efeff"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMxMTQ0MA==", "bodyText": "Hmm.. It's a little curious that we need the call to getLeaderEpoch here. Tracing this back to fetchTruncatingPartitions, it looks like we could not have a negative epoch here.", "url": "https://github.com/apache/kafka/pull/9689#discussion_r540311440", "createdAt": "2020-12-10T16:28:26Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AbstractFetcherThread.scala", "diffHunk": "@@ -268,11 +271,12 @@ abstract class AbstractFetcherThread(name: String,\n             fetchOffsets.put(tp, offsetTruncationState)\n \n         case Errors.FENCED_LEADER_EPOCH =>\n-          if (onPartitionFenced(tp, latestEpochsForPartitions.get(tp).flatMap {\n-            p =>\n-              if (p.currentLeaderEpoch.isPresent) Some(p.currentLeaderEpoch.get())\n-              else None\n-          })) partitionsWithError += tp\n+          val currentLeaderEpoch = latestEpochsForPartitions.get(tp) match {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwMTcxMQ=="}, "originalCommit": {"oid": "3db69e9e7a4d55887a44c8a407c950e9c17efeff"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDM4MjgyNQ==", "bodyText": "Yeah, that's because onPartitionFenced takes an Optional actually.", "url": "https://github.com/apache/kafka/pull/9689#discussion_r540382825", "createdAt": "2020-12-10T18:02:00Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/AbstractFetcherThread.scala", "diffHunk": "@@ -268,11 +271,12 @@ abstract class AbstractFetcherThread(name: String,\n             fetchOffsets.put(tp, offsetTruncationState)\n \n         case Errors.FENCED_LEADER_EPOCH =>\n-          if (onPartitionFenced(tp, latestEpochsForPartitions.get(tp).flatMap {\n-            p =>\n-              if (p.currentLeaderEpoch.isPresent) Some(p.currentLeaderEpoch.get())\n-              else None\n-          })) partitionsWithError += tp\n+          val currentLeaderEpoch = latestEpochsForPartitions.get(tp) match {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwMTcxMQ=="}, "originalCommit": {"oid": "3db69e9e7a4d55887a44c8a407c950e9c17efeff"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQwNjExMg==", "bodyText": "As onPartitionFenced is used in other code paths, I did not refactor it. We could have another variant which does not take an Optional. Is it worth doing it?", "url": "https://github.com/apache/kafka/pull/9689#discussion_r540406112", "createdAt": "2020-12-10T18:37:14Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/AbstractFetcherThread.scala", "diffHunk": "@@ -268,11 +271,12 @@ abstract class AbstractFetcherThread(name: String,\n             fetchOffsets.put(tp, offsetTruncationState)\n \n         case Errors.FENCED_LEADER_EPOCH =>\n-          if (onPartitionFenced(tp, latestEpochsForPartitions.get(tp).flatMap {\n-            p =>\n-              if (p.currentLeaderEpoch.isPresent) Some(p.currentLeaderEpoch.get())\n-              else None\n-          })) partitionsWithError += tp\n+          val currentLeaderEpoch = latestEpochsForPartitions.get(tp) match {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwMTcxMQ=="}, "originalCommit": {"oid": "3db69e9e7a4d55887a44c8a407c950e9c17efeff"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjI5MTI5NQ==", "bodyText": "@hachikuji Ah.. I see what you mean now. I have removed the call to getLeaderEpoch.", "url": "https://github.com/apache/kafka/pull/9689#discussion_r542291295", "createdAt": "2020-12-14T10:53:46Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/AbstractFetcherThread.scala", "diffHunk": "@@ -268,11 +271,12 @@ abstract class AbstractFetcherThread(name: String,\n             fetchOffsets.put(tp, offsetTruncationState)\n \n         case Errors.FENCED_LEADER_EPOCH =>\n-          if (onPartitionFenced(tp, latestEpochsForPartitions.get(tp).flatMap {\n-            p =>\n-              if (p.currentLeaderEpoch.isPresent) Some(p.currentLeaderEpoch.get())\n-              else None\n-          })) partitionsWithError += tp\n+          val currentLeaderEpoch = latestEpochsForPartitions.get(tp) match {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwMTcxMQ=="}, "originalCommit": {"oid": "3db69e9e7a4d55887a44c8a407c950e9c17efeff"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwNzcxMDAzOnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/common/requests/RequestUtils.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQxMzozMzozOVrOIFQniA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxMDo1MTo1M1rOIHvz4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM4NjA1Ng==", "bodyText": "There are some duplicate code. Maybe we can unify them in this PR (or we can address it in follow-up) ?\n\nhttps://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/consumer/internals/Fetcher.java#L1399\nhttps://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/consumer/internals/Fetcher.java#L1553\nhttps://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/common/record/FileRecords.java#L358\nhttps://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/coordinator/group/GroupMetadataManager.scala#L1124\nhttps://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/server/KafkaApis.scala#L534\nhttps://github.com/apache/kafka/blob/trunk/core/src/main/scala/kafka/server/ReplicaManager.scala#L1890", "url": "https://github.com/apache/kafka/pull/9689#discussion_r542386056", "createdAt": "2020-12-14T13:33:39Z", "author": {"login": "chia7712"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/RequestUtils.java", "diffHunk": "@@ -34,7 +34,7 @@\n \n     private RequestUtils() {}\n \n-    static Optional<Integer> getLeaderEpoch(int leaderEpoch) {\n+    public static Optional<Integer> getLeaderEpoch(int leaderEpoch) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26056e004d293bed8c6f123b259c0867ed54cb1e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk5MzY5NQ==", "bodyText": "@chia7712 Thanks for pointing this out. I think that we should tackle this in follow-up PRs as this is not strictly related to this change. Ok for you?", "url": "https://github.com/apache/kafka/pull/9689#discussion_r544993695", "createdAt": "2020-12-17T10:51:03Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/RequestUtils.java", "diffHunk": "@@ -34,7 +34,7 @@\n \n     private RequestUtils() {}\n \n-    static Optional<Integer> getLeaderEpoch(int leaderEpoch) {\n+    public static Optional<Integer> getLeaderEpoch(int leaderEpoch) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM4NjA1Ng=="}, "originalCommit": {"oid": "26056e004d293bed8c6f123b259c0867ed54cb1e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk5NDI3Mw==", "bodyText": "It is ok to me :)", "url": "https://github.com/apache/kafka/pull/9689#discussion_r544994273", "createdAt": "2020-12-17T10:51:53Z", "author": {"login": "chia7712"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/RequestUtils.java", "diffHunk": "@@ -34,7 +34,7 @@\n \n     private RequestUtils() {}\n \n-    static Optional<Integer> getLeaderEpoch(int leaderEpoch) {\n+    public static Optional<Integer> getLeaderEpoch(int leaderEpoch) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM4NjA1Ng=="}, "originalCommit": {"oid": "26056e004d293bed8c6f123b259c0867ed54cb1e"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3681, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}