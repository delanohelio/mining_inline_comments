{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxNTc3NTI1", "number": 8047, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMDo0NzoxNVrODdef6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwNDo0NTo0NVrODdj-nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjM0OTg2OnYy", "diffSide": "LEFT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ChangelogReader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMDo0NzoxNVrOFmGoRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMDo0NzoxNVrOFmGoRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ5ODgyMA==", "bodyText": "This function is only triggered internally and can be removed from interface.", "url": "https://github.com/apache/kafka/pull/8047#discussion_r375498820", "createdAt": "2020-02-05T20:47:15Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ChangelogReader.java", "diffHunk": "@@ -30,11 +30,6 @@\n      */\n     void restore();\n \n-    /**\n-     * Update offset limit of a given changelog partition\n-     */\n-    void updateLimitOffsets();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bfd87c37032b1a6bdd343e2ee135d0b3bf33b6f"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjM1MzY2OnYy", "diffSide": "LEFT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMDo0ODozMlrOFmGqjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMDo0ODozMlrOFmGqjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ5OTQwNw==", "bodyText": "Following the suggestion from KAFKA-9113 PR, by @ableegoldman we consolidate the limit-offset with end-offset.", "url": "https://github.com/apache/kafka/pull/8047#discussion_r375499407", "createdAt": "2020-02-05T20:48:32Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -99,11 +100,18 @@\n \n         // only for active restoring tasks (for standby changelog it is null)\n         // NOTE we do not book keep the current offset since we leverage state manager as its source of truth\n-        private Long restoreEndOffset;\n \n-        // only for standby tasks that use source topics as changelogs (for active it is null);\n-        // if it is not on source topics it is also null\n-        private Long restoreLimitOffset;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bfd87c37032b1a6bdd343e2ee135d0b3bf33b6f"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjM1NTIzOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMDo0OTowNlrOFmGrig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMDo0OTowNlrOFmGrig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ5OTY1OA==", "bodyText": "If user set this value to infinity we should still have a non-inf value to take care of the manual commit.", "url": "https://github.com/apache/kafka/pull/8047#discussion_r375499658", "createdAt": "2020-02-05T20:49:06Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -208,10 +215,12 @@ public StoreChangelogReader(final StreamsConfig config,\n         // NOTE for restoring active and updating standby we may prefer different poll time\n         // in order to make sure we call the main consumer#poll in time.\n         // TODO: once both of these are moved to a separate thread this may no longer be a concern\n-        this.pollTime = Duration.ofMillis(config.getLong(StreamsConfig.POLL_MS_CONFIG));\n+        this.pollTimeMs = Duration.ofMillis(config.getLong(StreamsConfig.POLL_MS_CONFIG));\n+        this.updateOffsetIntervalMs = config.getLong(StreamsConfig.COMMIT_INTERVAL_MS_CONFIG) == Long.MAX_VALUE ?\n+            DEFAULT_OFFSET_UPDATE_MS : config.getLong(StreamsConfig.COMMIT_INTERVAL_MS_CONFIG);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bfd87c37032b1a6bdd343e2ee135d0b3bf33b6f"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMjM2MjE3OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQyMDo1MToxNlrOFmGvkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMzoxNzoyOFrOFmtiuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUwMDY4OQ==", "bodyText": "If there's nothing to be updated or timed out, we do not update the timer.", "url": "https://github.com/apache/kafka/pull/8047#discussion_r375500689", "createdAt": "2020-02-05T20:51:16Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -517,16 +520,21 @@ private void restoreChangelog(final ChangelogMetadata changelogMetadata) {\n         if (partitions.isEmpty())\n             return Collections.emptyMap();\n \n+        final Map<TopicPartition, Long> committedOffsets;\n         try {\n             // those do not have a committed offset would default to 0\n-            return mainConsumer.committed(partitions).entrySet().stream()\n+            committedOffsets =  mainConsumer.committed(partitions).entrySet().stream()\n                 .collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue() == null ? 0L : e.getValue().offset()));\n         } catch (final TimeoutException e) {\n             // if it timed out we just retry next time.\n             return Collections.emptyMap();\n         } catch (final KafkaException e) {\n             throw new StreamsException(String.format(\"Failed to retrieve end offsets for %s\", partitions), e);\n         }\n+\n+        lastUpdateOffsetTime = time.milliseconds();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bfd87c37032b1a6bdd343e2ee135d0b3bf33b6f"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA1OTMyNA==", "bodyText": "This would be less mysterious if this method were inlined into updateLimitOffsets. Right now, it's not terribly clear why it's ok to set the \"last update offset time\" in a method that doesn't update the offsets.", "url": "https://github.com/apache/kafka/pull/8047#discussion_r376059324", "createdAt": "2020-02-06T20:17:00Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -517,16 +520,21 @@ private void restoreChangelog(final ChangelogMetadata changelogMetadata) {\n         if (partitions.isEmpty())\n             return Collections.emptyMap();\n \n+        final Map<TopicPartition, Long> committedOffsets;\n         try {\n             // those do not have a committed offset would default to 0\n-            return mainConsumer.committed(partitions).entrySet().stream()\n+            committedOffsets =  mainConsumer.committed(partitions).entrySet().stream()\n                 .collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue() == null ? 0L : e.getValue().offset()));\n         } catch (final TimeoutException e) {\n             // if it timed out we just retry next time.\n             return Collections.emptyMap();\n         } catch (final KafkaException e) {\n             throw new StreamsException(String.format(\"Failed to retrieve end offsets for %s\", partitions), e);\n         }\n+\n+        lastUpdateOffsetTime = time.milliseconds();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUwMDY4OQ=="}, "originalCommit": {"oid": "3bfd87c37032b1a6bdd343e2ee135d0b3bf33b6f"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEzNjM3Nw==", "bodyText": "This function is triggered by another caller besides updateLimitOffsets, plus it is a bit close to the NPathComplexity threshold..", "url": "https://github.com/apache/kafka/pull/8047#discussion_r376136377", "createdAt": "2020-02-06T23:17:28Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -517,16 +520,21 @@ private void restoreChangelog(final ChangelogMetadata changelogMetadata) {\n         if (partitions.isEmpty())\n             return Collections.emptyMap();\n \n+        final Map<TopicPartition, Long> committedOffsets;\n         try {\n             // those do not have a committed offset would default to 0\n-            return mainConsumer.committed(partitions).entrySet().stream()\n+            committedOffsets =  mainConsumer.committed(partitions).entrySet().stream()\n                 .collect(Collectors.toMap(Map.Entry::getKey, e -> e.getValue() == null ? 0L : e.getValue().offset()));\n         } catch (final TimeoutException e) {\n             // if it timed out we just retry next time.\n             return Collections.emptyMap();\n         } catch (final KafkaException e) {\n             throw new StreamsException(String.format(\"Failed to retrieve end offsets for %s\", partitions), e);\n         }\n+\n+        lastUpdateOffsetTime = time.milliseconds();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUwMDY4OQ=="}, "originalCommit": {"oid": "3bfd87c37032b1a6bdd343e2ee135d0b3bf33b6f"}, "originalPosition": 216}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMzI0NzY3OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQwNDo0NTo0NVrOFmPJ4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMzoxNjowOVrOFmtgwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYzODQ5Ng==", "bodyText": "the type of pollTimeMs is Duration. It seems to me that the \"ms\" is a bit redundant.", "url": "https://github.com/apache/kafka/pull/8047#discussion_r375638496", "createdAt": "2020-02-06T04:45:45Z", "author": {"login": "chia7712"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -208,10 +215,12 @@ public StoreChangelogReader(final StreamsConfig config,\n         // NOTE for restoring active and updating standby we may prefer different poll time\n         // in order to make sure we call the main consumer#poll in time.\n         // TODO: once both of these are moved to a separate thread this may no longer be a concern\n-        this.pollTime = Duration.ofMillis(config.getLong(StreamsConfig.POLL_MS_CONFIG));\n+        this.pollTimeMs = Duration.ofMillis(config.getLong(StreamsConfig.POLL_MS_CONFIG));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3bfd87c37032b1a6bdd343e2ee135d0b3bf33b6f"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA2MDMyNQ==", "bodyText": "+1", "url": "https://github.com/apache/kafka/pull/8047#discussion_r376060325", "createdAt": "2020-02-06T20:19:15Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -208,10 +215,12 @@ public StoreChangelogReader(final StreamsConfig config,\n         // NOTE for restoring active and updating standby we may prefer different poll time\n         // in order to make sure we call the main consumer#poll in time.\n         // TODO: once both of these are moved to a separate thread this may no longer be a concern\n-        this.pollTime = Duration.ofMillis(config.getLong(StreamsConfig.POLL_MS_CONFIG));\n+        this.pollTimeMs = Duration.ofMillis(config.getLong(StreamsConfig.POLL_MS_CONFIG));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYzODQ5Ng=="}, "originalCommit": {"oid": "3bfd87c37032b1a6bdd343e2ee135d0b3bf33b6f"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEzNTg3Mw==", "bodyText": "Ack.", "url": "https://github.com/apache/kafka/pull/8047#discussion_r376135873", "createdAt": "2020-02-06T23:16:09Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -208,10 +215,12 @@ public StoreChangelogReader(final StreamsConfig config,\n         // NOTE for restoring active and updating standby we may prefer different poll time\n         // in order to make sure we call the main consumer#poll in time.\n         // TODO: once both of these are moved to a separate thread this may no longer be a concern\n-        this.pollTime = Duration.ofMillis(config.getLong(StreamsConfig.POLL_MS_CONFIG));\n+        this.pollTimeMs = Duration.ofMillis(config.getLong(StreamsConfig.POLL_MS_CONFIG));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTYzODQ5Ng=="}, "originalCommit": {"oid": "3bfd87c37032b1a6bdd343e2ee135d0b3bf33b6f"}, "originalPosition": 111}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4196, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}