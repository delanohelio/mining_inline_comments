{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIxOTA0OTQ2", "number": 9600, "reviewThreads": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwMjoxMjozOVrOFMXP6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQyMTo0MjoxOFrOFPZAOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4NTA4MTM4OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwMjoxMjozOVrOIQDPKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwNzowNToxNlrOIQHyRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzcwMTE2MA==", "bodyText": "This seems a little severe. Not all apis need to be coordinated with the controller. We have to handle the case when we receive a version that the current controller cannot handle anyway, so I think it's ok to make this a best-effort intersection and return just the broker APIs if the controller APIs are not yet known.\nThe tricky case for this PR is when the controller changed or we learned about new API version support after a client had already connected to the broker and sent ApiVersions. In this case, we have to detect version incompatibility dynamically when we try to forward the request. I might be missing something, but the current patch doesn't seem to handle this. Maybe the simplest option is to let the controller return UNSUPPORTED_VERSION in the envelope response if the header indicates an api or version that it does not support. Then the question is whether this error should be sent back to the client, but that would be a little surprising.\nConsider this sequence:\n\nClient connects and sends ApiVersions request\nCurrent controller supports AlterConfig v0-4, so that is what the broker indicates in the ApiVersions response\nNew controller is elected and only supports AlterConfig v0-3\nClient sends AlterConfig v4\n\nNow what happens? An unsupported version error here would be treated as fatal by the client. I think we agreed that instead of sending back the error, the broker would just disconnect. This would force a reconnect and a refresh of the API versions.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r553701160", "createdAt": "2021-01-08T02:12:39Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1790,17 +1790,41 @@ class KafkaApis(val requestChannel: RequestChannel,\n       else {\n         val supportedFeatures = brokerFeatures.supportedFeatures\n         val finalizedFeaturesOpt = finalizedFeatureCache.get\n-        finalizedFeaturesOpt match {\n-          case Some(finalizedFeatures) => ApiVersion.apiVersionsResponse(\n-            requestThrottleMs,\n-            config.interBrokerProtocolVersion.recordVersion.value,\n-            supportedFeatures,\n-            finalizedFeatures.features,\n-            finalizedFeatures.epoch)\n-          case None => ApiVersion.apiVersionsResponse(\n-            requestThrottleMs,\n-            config.interBrokerProtocolVersion.recordVersion.value,\n-            supportedFeatures)\n+        val controllerApiVersions = if (isForwardingEnabled(request)) {\n+          forwardingManager.controllerApiVersions()\n+        } else\n+          None\n+\n+        if (isForwardingEnabled(request) && controllerApiVersions.isEmpty) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f9f580119e6a0adafa27b5f979aaa70046814be"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc3NTY4Ng==", "bodyText": "I think it relates to the timing of the forwarding. When the controller switches and certain ApiVersions are updated, the forwarding response will contain unsupported version exception. At that time, we would do a disconnect to the client. We have two options here to trigger the disconnect:\n\nwhen we detect unsupported version exception from the forwarding response\nwhen we detect the new ApiVersion set is different from the previous one\n\nI personally think #1 is more accurate, but it has a downside where we couldn't tell whether it was truly an incompatible admin client trying to make connection. #2 may have wider impact than necessary, although it could disconnect clients with unaffected RPCs unnecessarily.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r553775686", "createdAt": "2021-01-08T07:05:16Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1790,17 +1790,41 @@ class KafkaApis(val requestChannel: RequestChannel,\n       else {\n         val supportedFeatures = brokerFeatures.supportedFeatures\n         val finalizedFeaturesOpt = finalizedFeatureCache.get\n-        finalizedFeaturesOpt match {\n-          case Some(finalizedFeatures) => ApiVersion.apiVersionsResponse(\n-            requestThrottleMs,\n-            config.interBrokerProtocolVersion.recordVersion.value,\n-            supportedFeatures,\n-            finalizedFeatures.features,\n-            finalizedFeatures.epoch)\n-          case None => ApiVersion.apiVersionsResponse(\n-            requestThrottleMs,\n-            config.interBrokerProtocolVersion.recordVersion.value,\n-            supportedFeatures)\n+        val controllerApiVersions = if (isForwardingEnabled(request)) {\n+          forwardingManager.controllerApiVersions()\n+        } else\n+          None\n+\n+        if (isForwardingEnabled(request) && controllerApiVersions.isEmpty) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzcwMTE2MA=="}, "originalCommit": {"oid": "8f9f580119e6a0adafa27b5f979aaa70046814be"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NjU3MjMzOnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/common/protocol/ApiVersion.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMDowMDozMlrOIRr5Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDoyNTozOVrOIT8gIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQxNTgyNw==", "bodyText": "Why move this class?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r555415827", "createdAt": "2021-01-12T00:00:32Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/common/protocol/ApiVersion.java", "diffHunk": "@@ -14,10 +14,10 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.kafka.clients;\n+package org.apache.kafka.common.protocol;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc0MzExMw==", "bodyText": "I want to make ApiVersion to be usable for common/message/ApiVersionsResponse", "url": "https://github.com/apache/kafka/pull/9600#discussion_r556743113", "createdAt": "2021-01-13T18:33:23Z", "author": {"login": "abbccdda"}, "path": "clients/src/main/java/org/apache/kafka/common/protocol/ApiVersion.java", "diffHunk": "@@ -14,10 +14,10 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.kafka.clients;\n+package org.apache.kafka.common.protocol;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQxNTgyNw=="}, "originalCommit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4NTEyMg==", "bodyText": "Ok. I don't have a strong argument to keep it where it is today I guess.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557785122", "createdAt": "2021-01-15T00:25:39Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/common/protocol/ApiVersion.java", "diffHunk": "@@ -14,10 +14,10 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.kafka.clients;\n+package org.apache.kafka.common.protocol;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQxNTgyNw=="}, "originalCommit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NjU5MDg4OnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/common/protocol/ApiVersion.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMDowODo0M1rOIRsDnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xM1QwMzo0OToxMFrOISehWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQxODUyNQ==", "bodyText": "nit: we could simplify this a little bit. I'd suggest a non-static method. Maybe something like this:\npublic ApiVersion intersect(ApiVersion other) {\n  // verify this.apiKey matches other.apiKey\n  // return intersection as implemented below\n}", "url": "https://github.com/apache/kafka/pull/9600#discussion_r555418525", "createdAt": "2021-01-12T00:08:43Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/common/protocol/ApiVersion.java", "diffHunk": "@@ -53,4 +53,18 @@ public String toString() {\n             \", maxVersion= \" + maxVersion +\n             \")\";\n     }\n+\n+    public static ApiVersion versionsInCommon(ApiKeys apiKey, ApiVersion supportedVersions,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjI0NTMzNw==", "bodyText": "I looked up the usage of this API, it has the external effect to have reference min and max versions. At least the current format is the most straightforward refactoring without the need to create another ApiVersion instance.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r556245337", "createdAt": "2021-01-13T03:49:10Z", "author": {"login": "abbccdda"}, "path": "clients/src/main/java/org/apache/kafka/common/protocol/ApiVersion.java", "diffHunk": "@@ -53,4 +53,18 @@ public String toString() {\n             \", maxVersion= \" + maxVersion +\n             \")\";\n     }\n+\n+    public static ApiVersion versionsInCommon(ApiKeys apiKey, ApiVersion supportedVersions,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQxODUyNQ=="}, "originalCommit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NjU5NTcxOnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/common/protocol/ApiVersion.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMDoxMTowMFrOIRsGbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMDoxMTowMFrOIRsGbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQxOTI0NA==", "bodyText": "Not totally sure this gets thrown in the right place. If there are no overlapping versions, perhaps we should leave the api out of the result. Perhaps that suggests we should use this definition:\n// Return common api versions or empty if there are none\npublic Optional<ApiVersion> intersect(ApiVersion other);\nThen we can let the caller decide how to handle this case.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r555419244", "createdAt": "2021-01-12T00:11:00Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/common/protocol/ApiVersion.java", "diffHunk": "@@ -53,4 +53,18 @@ public String toString() {\n             \", maxVersion= \" + maxVersion +\n             \")\";\n     }\n+\n+    public static ApiVersion versionsInCommon(ApiKeys apiKey, ApiVersion supportedVersions,\n+                                              short minAllowedVersion, short maxAllowedVersion) {\n+        if (supportedVersions == null)\n+            throw new UnsupportedVersionException(\"The broker does not support \" + apiKey);\n+\n+        short minVersion = (short) Math.max(minAllowedVersion, supportedVersions.minVersion);\n+        short maxVersion = (short) Math.min(maxAllowedVersion, supportedVersions.maxVersion);\n+        if (minVersion > maxVersion)\n+            throw new UnsupportedVersionException(\"The broker does not support \" + apiKey +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NjYxOTAxOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManager.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMDoxNTo0NFrOIRsVVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMDoxNTo0NFrOIRsVVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQyMzA2Mw==", "bodyText": "This might be overkill. Perhaps we could make activeController volatile or an atomic reference?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r555423063", "createdAt": "2021-01-12T00:15:44Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManager.scala", "diffHunk": "@@ -171,6 +184,20 @@ class BrokerToControllerRequestThread(\n   private val requestQueue = new LinkedBlockingDeque[BrokerToControllerQueueItem]()\n   private var activeController: Option[Node] = None\n \n+  private val lock = new ReentrantReadWriteLock\n+\n+  def activeControllerAddress(): Option[Node] = {\n+    CoreUtils.inReadLock(lock) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NjYyOTIyOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/ForwardingManager.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMDoxNzozOFrOIRsb4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMDoxNzozOFrOIRsb4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQyNDczOA==", "bodyText": "Taking into account #9850, I think we should be checking envelopeError. If the broker could not parse the embedded request, then it would not be able to include an embedded response.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r555424738", "createdAt": "2021-01-12T00:17:38Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/ForwardingManager.scala", "diffHunk": "@@ -109,7 +113,14 @@ class ForwardingManagerImpl(\n         } else {\n           parseResponse(envelopeResponse.responseData, requestBody, request.header)\n         }\n-        responseCallback(response)\n+\n+        // Unsupported version indicates an incompatibility between controller and client API versions. The\n+        // forwarding broker should close the connection with the client and let it reinitialize the connection\n+        // and refresh the controller API versions.\n+        if (response.errorCounts().containsKey(Errors.UNSUPPORTED_VERSION)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NjYzNjQ1OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/ForwardingManager.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMDoxOToxM1rOIRsggw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMDoxOToxM1rOIRsggw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQyNTkyMw==", "bodyText": "I think we could generalize the response callback and avoid the additional callback argument. Perhaps we could return Either[Response, Exception]. Then in KafkaApis, we can log an error in the exceptional case and close the connection.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r555425923", "createdAt": "2021-01-12T00:19:13Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/ForwardingManager.scala", "diffHunk": "@@ -77,7 +80,8 @@ class ForwardingManagerImpl(\n \n   override def forwardRequest(\n     request: RequestChannel.Request,\n-    responseCallback: AbstractResponse => Unit\n+    responseCallback: AbstractResponse => Unit,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ5NjY0NjU2OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMDoyMzo1M1rOIRsmTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xMlQwMDoyMzo1M1rOIRsmTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTQyNzQwNw==", "bodyText": "As mentioned previously, I think we want to relax this. It's fine to return the broker versions if the controller versions are unknown.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r555427407", "createdAt": "2021-01-12T00:23:53Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1790,17 +1790,41 @@ class KafkaApis(val requestChannel: RequestChannel,\n       else {\n         val supportedFeatures = brokerFeatures.supportedFeatures\n         val finalizedFeaturesOpt = finalizedFeatureCache.get\n-        finalizedFeaturesOpt match {\n-          case Some(finalizedFeatures) => ApiVersion.apiVersionsResponse(\n-            requestThrottleMs,\n-            config.interBrokerProtocolVersion.recordVersion.value,\n-            supportedFeatures,\n-            finalizedFeatures.features,\n-            finalizedFeatures.epoch)\n-          case None => ApiVersion.apiVersionsResponse(\n-            requestThrottleMs,\n-            config.interBrokerProtocolVersion.recordVersion.value,\n-            supportedFeatures)\n+        val controllerApiVersions = if (isForwardingEnabled(request)) {\n+          forwardingManager.controllerApiVersions()\n+        } else\n+          None\n+\n+        if (isForwardingEnabled(request) && controllerApiVersions.isEmpty) {\n+          // If the controller api version is missing and we already enabled feature support,\n+          // we need to let ApiVersion request retry by sending unsupported version.\n+          apiVersionRequest.getErrorResponse(requestThrottleMs, Errors.UNSUPPORTED_VERSION.exception)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a3a545968ec9a6b91b2fcd9a06ce7cdd3299237"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTczNDE2OnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/clients/NodeApiVersions.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDoyMDowMFrOIT8ZXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMTo0NjowMFrOIT-E8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4MzM5MQ==", "bodyText": "nit: since we moved the null check here, why don't we remove the parameter as well and call supportedVersions.get(apiKey) here?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557783391", "createdAt": "2021-01-15T00:20:00Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/NodeApiVersions.java", "diffHunk": "@@ -123,21 +125,25 @@ public short latestUsableVersion(ApiKeys apiKey) {\n      * Get the latest version supported by the broker within an allowed range of versions\n      */\n     public short latestUsableVersion(ApiKeys apiKey, short oldestAllowedVersion, short latestAllowedVersion) {\n-        ApiVersion usableVersion = supportedVersions.get(apiKey);\n-        if (usableVersion == null)\n-            throw new UnsupportedVersionException(\"The broker does not support \" + apiKey);\n-        return latestUsableVersion(apiKey, usableVersion, oldestAllowedVersion, latestAllowedVersion);\n+        return latestUsableVersion(apiKey, supportedVersions.get(apiKey), oldestAllowedVersion, latestAllowedVersion);\n     }\n \n-    private short latestUsableVersion(ApiKeys apiKey, ApiVersion supportedVersions,\n-                                      short minAllowedVersion, short maxAllowedVersion) {\n-        short minVersion = (short) Math.max(minAllowedVersion, supportedVersions.minVersion);\n-        short maxVersion = (short) Math.min(maxAllowedVersion, supportedVersions.maxVersion);\n-        if (minVersion > maxVersion)\n+    private short latestUsableVersion(ApiKeys apiKey,\n+                                      ApiVersion supportedVersions,\n+                                      short minAllowedVersion,\n+                                      short maxAllowedVersion) {\n+        if (supportedVersions == null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgxMDkyOQ==", "bodyText": "Yea, actually we could remove the private function since it becomes single caller.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557810929", "createdAt": "2021-01-15T01:46:00Z", "author": {"login": "abbccdda"}, "path": "clients/src/main/java/org/apache/kafka/clients/NodeApiVersions.java", "diffHunk": "@@ -123,21 +125,25 @@ public short latestUsableVersion(ApiKeys apiKey) {\n      * Get the latest version supported by the broker within an allowed range of versions\n      */\n     public short latestUsableVersion(ApiKeys apiKey, short oldestAllowedVersion, short latestAllowedVersion) {\n-        ApiVersion usableVersion = supportedVersions.get(apiKey);\n-        if (usableVersion == null)\n-            throw new UnsupportedVersionException(\"The broker does not support \" + apiKey);\n-        return latestUsableVersion(apiKey, usableVersion, oldestAllowedVersion, latestAllowedVersion);\n+        return latestUsableVersion(apiKey, supportedVersions.get(apiKey), oldestAllowedVersion, latestAllowedVersion);\n     }\n \n-    private short latestUsableVersion(ApiKeys apiKey, ApiVersion supportedVersions,\n-                                      short minAllowedVersion, short maxAllowedVersion) {\n-        short minVersion = (short) Math.max(minAllowedVersion, supportedVersions.minVersion);\n-        short maxVersion = (short) Math.min(maxAllowedVersion, supportedVersions.maxVersion);\n-        if (minVersion > maxVersion)\n+    private short latestUsableVersion(ApiKeys apiKey,\n+                                      ApiVersion supportedVersions,\n+                                      short minAllowedVersion,\n+                                      short maxAllowedVersion) {\n+        if (supportedVersions == null)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4MzM5MQ=="}, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTczNzcxOnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/clients/NodeApiVersions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDoyMToyOFrOIT8bTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDoyMToyOFrOIT8bTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4Mzg4NQ==", "bodyText": "We could probably simplify this so that it takes a single ApiVersion parameter?\nBy the way, the implementation above latestUsableVersion(ApiKeys apiKey) since it basically does an intersection of the latest supported version with itself. A little helper (say latestSupportedOrThrow) might simplify this.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557783885", "createdAt": "2021-01-15T00:21:28Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/NodeApiVersions.java", "diffHunk": "@@ -123,21 +125,25 @@ public short latestUsableVersion(ApiKeys apiKey) {\n      * Get the latest version supported by the broker within an allowed range of versions\n      */\n     public short latestUsableVersion(ApiKeys apiKey, short oldestAllowedVersion, short latestAllowedVersion) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTc1NDI3OnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/common/requests/ApiVersionsResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDoyNzoyN1rOIT8lmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDoyNzoyN1rOIT8lmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4NjUyMg==", "bodyText": "Maybe intersectControllerApiVersions?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557786522", "createdAt": "2021-01-15T00:27:27Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/ApiVersionsResponse.java", "diffHunk": "@@ -129,6 +131,40 @@ public static ApiVersionsResponseKeyCollection defaultApiKeys(final byte minMagi\n         return apiKeys;\n     }\n \n+    public static ApiVersionsResponseKeyCollection commonApiVersionsWithActiveController(final byte minMagic,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTc2NDU3OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/api/ApiVersion.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDozMjowMVrOIT8rtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDozMjowMVrOIT8rtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODA4Nw==", "bodyText": "nit: since this is a big block, could we add the braces?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557788087", "createdAt": "2021-01-15T00:32:01Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/api/ApiVersion.scala", "diffHunk": "@@ -148,42 +149,49 @@ object ApiVersion {\n \n   def apiVersionsResponse(throttleTimeMs: Int,\n                           maxMagic: Byte,\n-                          latestSupportedFeatures: Features[SupportedVersionRange]): ApiVersionsResponse = {\n+                          latestSupportedFeatures: Features[SupportedVersionRange],\n+                          controllerApiVersions: Option[NodeApiVersions]): ApiVersionsResponse = {\n     apiVersionsResponse(\n       throttleTimeMs,\n       maxMagic,\n       latestSupportedFeatures,\n       Features.emptyFinalizedFeatures,\n-      ApiVersionsResponse.UNKNOWN_FINALIZED_FEATURES_EPOCH\n+      ApiVersionsResponse.UNKNOWN_FINALIZED_FEATURES_EPOCH,\n+      controllerApiVersions\n     )\n   }\n \n   def apiVersionsResponse(throttleTimeMs: Int,\n                           maxMagic: Byte,\n                           latestSupportedFeatures: Features[SupportedVersionRange],\n                           finalizedFeatures: Features[FinalizedVersionRange],\n-                          finalizedFeaturesEpoch: Long): ApiVersionsResponse = {\n-    val apiKeys = ApiVersionsResponse.defaultApiKeys(maxMagic)\n+                          finalizedFeaturesEpoch: Long,\n+                          controllerApiVersions: Option[NodeApiVersions]): ApiVersionsResponse = {\n+    val apiKeys = controllerApiVersions match {\n+      case None => ApiVersionsResponse.defaultApiKeys(maxMagic)\n+      case Some(controllerApiVersion) => ApiVersionsResponse.commonApiVersionsWithActiveController(\n+        maxMagic, controllerApiVersion.fullApiVersions())\n+    }\n+\n     if (maxMagic == RecordBatch.CURRENT_MAGIC_VALUE &&\n       throttleTimeMs == AbstractResponse.DEFAULT_THROTTLE_TIME)\n-      return new ApiVersionsResponse(\n+      new ApiVersionsResponse(\n         ApiVersionsResponse.createApiVersionsResponseData(\n           DEFAULT_API_VERSIONS_RESPONSE.throttleTimeMs,\n           Errors.forCode(DEFAULT_API_VERSIONS_RESPONSE.data.errorCode),\n           apiKeys,\n           latestSupportedFeatures,\n           finalizedFeatures,\n+          finalizedFeaturesEpoch))\n+    else", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTc2NjkxOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManager.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDozMzoxNFrOIT8tEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDozMzoxNFrOIT8tEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODQzNA==", "bodyText": "Seems like we can replace the match with a flatMap?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557788434", "createdAt": "2021-01-15T00:33:14Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManager.scala", "diffHunk": "@@ -140,6 +143,16 @@ class BrokerToControllerChannelManager(\n       callback\n     ))\n   }\n+\n+  def controllerApiVersions(): Option[NodeApiVersions] =\n+    requestThread.activeControllerAddress() match {\n+      case Some(activeController) =>\n+        if (activeController.id() == config.brokerId)\n+          Some(currentNodeApiVersions)\n+        else\n+          Option(apiVersions.get(activeController.idString()))\n+      case None => None", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTc3MDQwOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManager.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDozNTowNlrOIT8vLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDozNTowNlrOIT8vLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4ODk3NA==", "bodyText": "nit: an atomic reference of Option is a little strange. Could we just use null and change the code to use Option(activeController.get())?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557788974", "createdAt": "2021-01-15T00:35:06Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManager.scala", "diffHunk": "@@ -169,11 +182,19 @@ class BrokerToControllerRequestThread(\n ) extends InterBrokerSendThread(threadName, networkClient, config.controllerSocketTimeoutMs, time, isInterruptible = false) {\n \n   private val requestQueue = new LinkedBlockingDeque[BrokerToControllerQueueItem]()\n-  private var activeController: Option[Node] = None\n+  private val activeController = new AtomicReference[Option[Node]](None)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTc4MTQ5OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManager.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDo0MDowMFrOIT81Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDo0MDowMFrOIT81Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MDU2Nw==", "bodyText": "This is another slippery looking case. Can we just rewrite this as a foreach so that we don't need to worry about it?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557790567", "createdAt": "2021-01-15T00:40:00Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManager.scala", "diffHunk": "@@ -205,20 +226,20 @@ class BrokerToControllerRequestThread(\n \n   private[server] def handleResponse(request: BrokerToControllerQueueItem)(response: ClientResponse): Unit = {\n     if (response.wasDisconnected()) {\n-      activeController = None\n+      updateControllerAddress(None)\n       requestQueue.putFirst(request)\n     } else if (response.responseBody().errorCounts().containsKey(Errors.NOT_CONTROLLER)) {\n       // just close the controller connection and wait for metadata cache update in doWork\n-      networkClient.disconnect(activeController.get.idString)\n-      activeController = None\n+      networkClient.disconnect(activeControllerAddress().get.idString)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTc4NDQyOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManager.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDo0MToyMFrOIT83Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDo0MToyMFrOIT83Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MTAwMw==", "bodyText": "The usage is a tad suspicious because the atomic reference suggests that the value could change. I guess we are ok because the value will only be overwritten in the same thread that is calling generateRequests, but it might be worth rewriting this part anyway. For example:\n} else {\n  val controllerAddress = activeControllerAddress()\n  if (controllerAddress.isDefined) {\n...", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557791003", "createdAt": "2021-01-15T00:41:20Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManager.scala", "diffHunk": "@@ -190,11 +211,11 @@ class BrokerToControllerRequestThread(\n       if (currentTimeMs - request.createdTimeMs >= retryTimeoutMs) {\n         requestIter.remove()\n         request.callback.onTimeout()\n-      } else if (activeController.isDefined) {\n+      } else if (activeControllerAddress().isDefined) {\n         requestIter.remove()\n         return Some(RequestAndCompletionHandler(\n           time.milliseconds(),\n-          activeController.get,\n+          activeControllerAddress().get,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTc4ODQyOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/ForwardingManager.scala", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDo0MzoyOFrOIT85sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxODowNDoxOFrOIUm5PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MTY2Ng==", "bodyText": "Since we are not using the Error from the result, maybe Option[AbstractResponse] would be a better type.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557791666", "createdAt": "2021-01-15T00:43:28Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/ForwardingManager.scala", "diffHunk": "@@ -77,7 +79,7 @@ class ForwardingManagerImpl(\n \n   override def forwardRequest(\n     request: RequestChannel.Request,\n-    responseCallback: AbstractResponse => Unit\n+    responseCallback: Either[AbstractResponse, Errors] => Unit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgyMzY0NA==", "bodyText": "I'm inclined to keep it as it is, since the current return type gives caller a root cause message.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557823644", "createdAt": "2021-01-15T02:29:11Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/server/ForwardingManager.scala", "diffHunk": "@@ -77,7 +79,7 @@ class ForwardingManagerImpl(\n \n   override def forwardRequest(\n     request: RequestChannel.Request,\n-    responseCallback: AbstractResponse => Unit\n+    responseCallback: Either[AbstractResponse, Errors] => Unit", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MTY2Ng=="}, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ3OTY3Nw==", "bodyText": "Yeah, but that suggests a generality to the API that doesn't exist. There is only one error that is possible to be returned here.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r558479677", "createdAt": "2021-01-15T18:04:18Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/ForwardingManager.scala", "diffHunk": "@@ -77,7 +79,7 @@ class ForwardingManagerImpl(\n \n   override def forwardRequest(\n     request: RequestChannel.Request,\n-    responseCallback: AbstractResponse => Unit\n+    responseCallback: Either[AbstractResponse, Errors] => Unit", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MTY2Ng=="}, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTc4OTY5OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDo0NDowN1rOIT86fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDo0NDowN1rOIT86fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MTg3MQ==", "bodyText": "nit: add braces", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557791871", "createdAt": "2021-01-15T00:44:07Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1756,18 +1758,36 @@ class KafkaApis(val requestChannel: RequestChannel,\n       else {\n         val supportedFeatures = brokerFeatures.supportedFeatures\n         val finalizedFeaturesOpt = finalizedFeatureCache.get\n-        finalizedFeaturesOpt match {\n-          case Some(finalizedFeatures) => ApiVersion.apiVersionsResponse(\n-            requestThrottleMs,\n-            config.interBrokerProtocolVersion.recordVersion.value,\n-            supportedFeatures,\n-            finalizedFeatures.features,\n-            finalizedFeatures.epoch)\n-          case None => ApiVersion.apiVersionsResponse(\n-            requestThrottleMs,\n-            config.interBrokerProtocolVersion.recordVersion.value,\n-            supportedFeatures)\n+        val controllerApiVersions = if (isForwardingEnabled(request)) {\n+          forwardingManager.controllerApiVersions()\n+        } else", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTc5MjY4OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDo0NTozNFrOIT88Tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDo0NTozNFrOIT88Tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MjMzNQ==", "bodyText": "nit: unneeded newline", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557792335", "createdAt": "2021-01-15T00:45:34Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -1756,18 +1758,36 @@ class KafkaApis(val requestChannel: RequestChannel,\n       else {\n         val supportedFeatures = brokerFeatures.supportedFeatures\n         val finalizedFeaturesOpt = finalizedFeatureCache.get\n-        finalizedFeaturesOpt match {\n-          case Some(finalizedFeatures) => ApiVersion.apiVersionsResponse(\n-            requestThrottleMs,\n-            config.interBrokerProtocolVersion.recordVersion.value,\n-            supportedFeatures,\n-            finalizedFeatures.features,\n-            finalizedFeatures.epoch)\n-          case None => ApiVersion.apiVersionsResponse(\n-            requestThrottleMs,\n-            config.interBrokerProtocolVersion.recordVersion.value,\n-            supportedFeatures)\n+        val controllerApiVersions = if (isForwardingEnabled(request)) {\n+          forwardingManager.controllerApiVersions()\n+        } else\n+          None\n+\n+        val apiVersionsResponse =\n+          finalizedFeaturesOpt match {\n+            case Some(finalizedFeatures) => ApiVersion.apiVersionsResponse(\n+              requestThrottleMs,\n+              config.interBrokerProtocolVersion.recordVersion.value,\n+              supportedFeatures,\n+              finalizedFeatures.features,\n+              finalizedFeatures.epoch,\n+              controllerApiVersions)\n+            case None => ApiVersion.apiVersionsResponse(\n+              requestThrottleMs,\n+              config.interBrokerProtocolVersion.recordVersion.value,\n+              supportedFeatures,\n+              controllerApiVersions)\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTc5NTgxOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/ForwardingManager.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDo0Njo1MFrOIT8-Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDo0Njo1MFrOIT8-Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5Mjc3MQ==", "bodyText": "It may be helpful to mention that this can happen because the controller changed after a connection was established.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557792771", "createdAt": "2021-01-15T00:46:50Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/ForwardingManager.scala", "diffHunk": "@@ -98,30 +100,40 @@ class ForwardingManagerImpl(\n         val envelopeError = envelopeResponse.error()\n         val requestBody = request.body[AbstractRequest]\n \n-        val response = if (envelopeError != Errors.NONE) {\n-          // An envelope error indicates broker misconfiguration (e.g. the principal serde\n-          // might not be defined on the receiving broker). In this case, we do not return\n-          // the error directly to the client since it would not be expected. Instead we\n-          // return `UNKNOWN_SERVER_ERROR` so that the user knows that there is a problem\n-          // on the broker.\n-          debug(s\"Forwarded request $request failed with an error in the envelope response $envelopeError\")\n-          requestBody.getErrorResponse(Errors.UNKNOWN_SERVER_ERROR.exception)\n+        // Unsupported version indicates an incompatibility between controller and client API versions. The", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxMTgwMTE3OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMDo0OTowMVrOIT9A6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQwMjozNDoxOVrOIT-8Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MzUxNQ==", "bodyText": "A debug message would be helpful here so that we know why the connection was closed. I think we might actually prefer to use emptyMap() here since the unsupported version error would be misleading.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557793515", "createdAt": "2021-01-15T00:49:01Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -139,8 +138,11 @@ class KafkaApis(val requestChannel: RequestChannel,\n     request: RequestChannel.Request,\n     handler: RequestChannel.Request => Unit\n   ): Unit = {\n-    def responseCallback(response: AbstractResponse): Unit = {\n-      sendForwardedResponse(request, response)\n+    def responseCallback(responseEither: Either[AbstractResponse, Errors]): Unit = {\n+      responseEither match {\n+        case Left(response) => sendForwardedResponse(request, response)\n+        case Right(error) => closeConnection(request, Collections.singletonMap(error, 1))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgyNTA3MA==", "bodyText": "Sg, I prefer using info here since it should be a rare case.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r557825070", "createdAt": "2021-01-15T02:34:19Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -139,8 +138,11 @@ class KafkaApis(val requestChannel: RequestChannel,\n     request: RequestChannel.Request,\n     handler: RequestChannel.Request => Unit\n   ): Unit = {\n-    def responseCallback(response: AbstractResponse): Unit = {\n-      sendForwardedResponse(request, response)\n+    def responseCallback(responseEither: Either[AbstractResponse, Errors]): Unit = {\n+      responseEither match {\n+        case Left(response) => sendForwardedResponse(request, response)\n+        case Right(error) => closeConnection(request, Collections.singletonMap(error, 1))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc5MzUxNQ=="}, "originalCommit": {"oid": "669ad39b76d91aa64ed153672d4a8a7b7f8493c8"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNTk0NTg4OnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/clients/NodeApiVersions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxNzo0NjoyN1rOIUmFTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxNzo0NjoyN1rOIUmFTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ2NjM4Mw==", "bodyText": "How about allSupportedApiVersions?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r558466383", "createdAt": "2021-01-15T17:46:27Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/clients/NodeApiVersions.java", "diffHunk": "@@ -227,4 +230,7 @@ public ApiVersion apiVersion(ApiKeys apiKey) {\n         return supportedVersions.get(apiKey);\n     }\n \n+    public Map<ApiKeys, ApiVersion> fullApiVersions() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a70335129ab52913eed37414f49cc0c00c727d5"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNTk2NzE5OnYy", "diffSide": "LEFT", "path": "clients/src/test/java/org/apache/kafka/clients/NodeApiVersionsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxNzo1MDozMlrOIUmTAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxODoxMzoyOVrOIUnMjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ2OTg4OQ==", "bodyText": "Hmm.. I think my suggestion about latestUsableVersion(ApiKeys) was off if we had to remove this. I think I had failed to take into account that NodeApiVersions represented the versions supported by the remote node, so the intersection was in fact necessary. Sorry about that.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r558469889", "createdAt": "2021-01-15T17:50:32Z", "author": {"login": "hachikuji"}, "path": "clients/src/test/java/org/apache/kafka/clients/NodeApiVersionsTest.java", "diffHunk": "@@ -125,13 +126,6 @@ public void testUsableVersionCalculationNoKnownVersions() {\n             () -> versions.latestUsableVersion(ApiKeys.FETCH));\n     }\n \n-    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a70335129ab52913eed37414f49cc0c00c727d5"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ4NDYyMw==", "bodyText": "No worry, I will revert it", "url": "https://github.com/apache/kafka/pull/9600#discussion_r558484623", "createdAt": "2021-01-15T18:13:29Z", "author": {"login": "abbccdda"}, "path": "clients/src/test/java/org/apache/kafka/clients/NodeApiVersionsTest.java", "diffHunk": "@@ -125,13 +126,6 @@ public void testUsableVersionCalculationNoKnownVersions() {\n             () -> versions.latestUsableVersion(ApiKeys.FETCH));\n     }\n \n-    @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ2OTg4OQ=="}, "originalCommit": {"oid": "9a70335129ab52913eed37414f49cc0c00c727d5"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNTk3MjQ0OnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/common/requests/ApiVersionsResponse.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxNzo1MTozOFrOIUmWkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxNzo1MTozOFrOIUmWkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ3MDgwMw==", "bodyText": "nit: maybe add a short javadoc?", "url": "https://github.com/apache/kafka/pull/9600#discussion_r558470803", "createdAt": "2021-01-15T17:51:38Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/ApiVersionsResponse.java", "diffHunk": "@@ -129,6 +131,40 @@ public static ApiVersionsResponseKeyCollection defaultApiKeys(final byte minMagi\n         return apiKeys;\n     }\n \n+    public static ApiVersionsResponseKeyCollection intersectControllerApiVersions(final byte minMagic,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a70335129ab52913eed37414f49cc0c00c727d5"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNTk3OTM1OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManager.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxNzo1Mjo1MVrOIUmbDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxNzo1Mjo1MVrOIUmbDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ3MTk0OQ==", "bodyText": "nit: a little more idiomatic\nforeach { controllerAddress =>\n}", "url": "https://github.com/apache/kafka/pull/9600#discussion_r558471949", "createdAt": "2021-01-15T17:52:51Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/BrokerToControllerChannelManager.scala", "diffHunk": "@@ -190,35 +209,41 @@ class BrokerToControllerRequestThread(\n       if (currentTimeMs - request.createdTimeMs >= retryTimeoutMs) {\n         requestIter.remove()\n         request.callback.onTimeout()\n-      } else if (activeController.isDefined) {\n-        requestIter.remove()\n-        return Some(RequestAndCompletionHandler(\n-          time.milliseconds(),\n-          activeController.get,\n-          request.request,\n-          handleResponse(request)\n-        ))\n+      } else {\n+        val controllerAddress = activeControllerAddress()\n+        if (controllerAddress.isDefined) {\n+          requestIter.remove()\n+          return Some(RequestAndCompletionHandler(\n+            time.milliseconds(),\n+            controllerAddress.get,\n+            request.request,\n+            handleResponse(request)\n+          ))\n+        }\n       }\n     }\n     None\n   }\n \n   private[server] def handleResponse(request: BrokerToControllerQueueItem)(response: ClientResponse): Unit = {\n     if (response.wasDisconnected()) {\n-      activeController = None\n+      updateControllerAddress(null)\n       requestQueue.putFirst(request)\n     } else if (response.responseBody().errorCounts().containsKey(Errors.NOT_CONTROLLER)) {\n       // just close the controller connection and wait for metadata cache update in doWork\n-      networkClient.disconnect(activeController.get.idString)\n-      activeController = None\n+      activeControllerAddress().foreach(controllerAddress => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a70335129ab52913eed37414f49cc0c00c727d5"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNTk5NjAwOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxNzo1NjoxMVrOIUmlxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxNzo1NjoxMVrOIUmlxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODQ3NDY5Mg==", "bodyText": "It's a little odd to have the if check here since we will close the connection regardless of the error. That's one reason I thought Option[AbstractResponse] might be clearer. The None could be treated as implying an unsupported version.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r558474692", "createdAt": "2021-01-15T17:56:11Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -139,8 +138,16 @@ class KafkaApis(val requestChannel: RequestChannel,\n     request: RequestChannel.Request,\n     handler: RequestChannel.Request => Unit\n   ): Unit = {\n-    def responseCallback(response: AbstractResponse): Unit = {\n-      sendForwardedResponse(request, response)\n+    def responseCallback(responseEither: Either[AbstractResponse, Errors]): Unit = {\n+      responseEither match {\n+        case Left(response) => sendForwardedResponse(request, response)\n+        case Right(error) =>\n+          if (error == Errors.UNSUPPORTED_VERSION)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a70335129ab52913eed37414f49cc0c00c727d5"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNjMyNzQ0OnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/server/AbstractApiVersionsRequestTest.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxOToxMDo1MFrOIUp6MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQxOToxMDo1MFrOIUp6MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODUyOTA3Mw==", "bodyText": "It is a little strange for the test case to have a dependence on this. It seems we should be testing the inter-broker listener as well? I think I would instead try to modify failing assertions so that they assert the right thing depending on the listener config.", "url": "https://github.com/apache/kafka/pull/9600#discussion_r558529073", "createdAt": "2021-01-15T19:10:50Z", "author": {"login": "hachikuji"}, "path": "core/src/test/scala/unit/kafka/server/AbstractApiVersionsRequestTest.scala", "diffHunk": "@@ -25,6 +27,15 @@ import scala.jdk.CollectionConverters._\n \n abstract class AbstractApiVersionsRequestTest extends BaseRequestTest {\n \n+  // Configure control plane listener to make sure we have separate listeners from client,\n+  // in order to avoid returning Envelope API version.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6e71efa2417e105846fbd10fb6daa13dcd8de162"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUxNjgyNjE4OnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/server/AbstractApiVersionsRequestTest.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQyMTo0MjoxOFrOIUutVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNVQyMTo0MjoxOFrOIUutVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODYwNzcwMw==", "bodyText": "nit: can use == in scala", "url": "https://github.com/apache/kafka/pull/9600#discussion_r558607703", "createdAt": "2021-01-15T21:42:18Z", "author": {"login": "hachikuji"}, "path": "core/src/test/scala/unit/kafka/server/AbstractApiVersionsRequestTest.scala", "diffHunk": "@@ -45,10 +47,13 @@ abstract class AbstractApiVersionsRequestTest extends BaseRequestTest {\n     } finally socket.close()\n   }\n \n-  def validateApiVersionsResponse(apiVersionsResponse: ApiVersionsResponse): Unit = {\n-    val enabledPublicApis = ApiKeys.enabledApis()\n+  def validateApiVersionsResponse(apiVersionsResponse: ApiVersionsResponse, listenerName: ListenerName = interBrokerListenerName): Unit = {\n+    val expectedApis = ApiKeys.enabledApis()\n+    if (listenerName.equals(controlPlaneListenerName) ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd531d0b485a8780458f02cb10227e89c7268a3d"}, "originalPosition": 37}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3863, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}