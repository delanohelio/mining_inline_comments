{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyMTA4NDMz", "number": 8054, "title": "KAFKA-9390: Make serde pseudo-topics unique", "bodyText": "During the discussion for KIP-213, we decided to pass \"pseudo-topics\"\nto the internal serdes we use to construct the wrapper serdes for\nCombinedKey and hashing the left-hand-side value. However, during\nthe implementation, this strategy wasn't fully implemented, and we wound\nup using the same topic name for a few different data types.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-02-06T20:57:26Z", "url": "https://github.com/apache/kafka/pull/8054", "merged": true, "mergeCommit": {"oid": "e16859dc48c679b3c7d9735438df046479b8ec4a"}, "closed": true, "closedAt": "2020-02-11T23:34:01Z", "author": {"login": "vvcephei"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcCGtANgFqTM1NTQ1ODMwMw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcDYBl9gH2gAyMzcyMTA4NDMzOjBlMGZlZWQ0YzJlNmQyYmNlOTk5NjJkMzMyZmE1NTE2OTcwYWFkNjk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NDU4MzAz", "url": "https://github.com/apache/kafka/pull/8054#pullrequestreview-355458303", "createdAt": "2020-02-07T21:50:32Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTo1MDozMlrOFnLUKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMjowMjoyMVrOFnLk_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyNDE3MA==", "bodyText": "Defining the pseudo-topics up front to make sure they're used consistently. Also, I used abbreviations for the suffixes, since these topic names are already quite long.", "url": "https://github.com/apache/kafka/pull/8054#discussion_r376624170", "createdAt": "2020-02-07T21:50:32Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java", "diffHunk": "@@ -952,23 +952,34 @@ boolean sendingOldValueEnabled() {\n         //This occurs whenever the extracted foreignKey changes values.\n         enableSendingOldValues();\n \n-        final Serde<KO> foreignKeySerde = ((KTableImpl<KO, VO, ?>) foreignKeyTable).keySerde;\n-        final Serde<SubscriptionWrapper<K>> subscriptionWrapperSerde = new SubscriptionWrapperSerde<>(keySerde);\n-        final SubscriptionResponseWrapperSerde<VO> responseWrapperSerde =\n-            new SubscriptionResponseWrapperSerde<>(((KTableImpl<KO, VO, VO>) foreignKeyTable).valSerde);\n \n \n         final NamedInternal renamed = new NamedInternal(joinName);\n         final String subscriptionTopicName = renamed.suffixWithOrElseGet(\"-subscription-registration\", builder, SUBSCRIPTION_REGISTRATION) + TOPIC_SUFFIX;\n+        final String subscriptionPrimaryKeySerdePseudoTopic = subscriptionTopicName + \"-pk\";\n+        final String subscriptionForeignKeySerdePseudoTopic = subscriptionTopicName + \"-fk\";\n+        final String valueHashSerdePseudoTopic = subscriptionTopicName + \"-vh\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyNjM4NA==", "bodyText": "We're ignoring the passed-in topic so that we can use the same pseudo-topic to (de)serialize the primary key as we do elsewhere. Also because the values in the passed-in topic is not the result of primaryKeySerializer.serialize(...,data.getPrimaryKey()), but is rather a bigger data structure that contains that data. So, we can avoid misleading users for whom a schema registry would claim that the subscription topic has a certain schema when in fact it doesn't. Now, it would tell them that the PK pseudo-topic has that schema, which at least can't be inconsistent with data they might observe in Kafka.", "url": "https://github.com/apache/kafka/pull/8054#discussion_r376626384", "createdAt": "2020-02-07T21:56:27Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/foreignkeyjoin/SubscriptionWrapperSerde.java", "diffHunk": "@@ -43,21 +46,28 @@ public SubscriptionWrapperSerde(final Serde<K> primaryKeySerde) {\n     }\n \n     private static class SubscriptionWrapperSerializer<K> implements Serializer<SubscriptionWrapper<K>> {\n+        private final String primaryKeySerializationPseudoTopic;\n         private final Serializer<K> primaryKeySerializer;\n-        SubscriptionWrapperSerializer(final Serializer<K> primaryKeySerializer) {\n+\n+        SubscriptionWrapperSerializer(final String primaryKeySerializationPseudoTopic,\n+                                      final Serializer<K> primaryKeySerializer) {\n+            this.primaryKeySerializationPseudoTopic = primaryKeySerializationPseudoTopic;\n             this.primaryKeySerializer = primaryKeySerializer;\n         }\n \n         @Override\n-        public byte[] serialize(final String topic, final SubscriptionWrapper<K> data) {\n+        public byte[] serialize(final String ignored, final SubscriptionWrapper<K> data) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyNzA2MQ==", "bodyText": "This is how I verified this fix. Using this class to decorate all the serdes in a topology, we can ensure that we never try and write heterogeneous-typed data to a topic.", "url": "https://github.com/apache/kafka/pull/8054#discussion_r376627061", "createdAt": "2020-02-07T21:58:21Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/utils/UniqueTopicSerdeScope.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.utils;\n+\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Deserializer;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class UniqueTopicSerdeScope {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyNzQ1MQ==", "bodyText": "To verify the fix, we create a \"scope\", which will wrap all our serdes and make sure that we never try to write differently typed data to the same topic.", "url": "https://github.com/apache/kafka/pull/8054#discussion_r376627451", "createdAt": "2020-02-07T21:59:28Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/KTableKTableForeignKeyInnerJoinMultiIntegrationTest.java", "diffHunk": "@@ -206,17 +207,30 @@ private void verifyKTableKTableJoin(final JoinType joinType,\n     }\n \n     private KafkaStreams prepareTopology(final String queryableName, final String queryableNameTwo) {\n+        final UniqueTopicSerdeScope serdeScope = new UniqueTopicSerdeScope();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyNzg1OQ==", "bodyText": "We decorate each serde in the topology. This also has the side benefit of actually configuring the serdes, which we've usually neglected to do. Particularly, the last argument configures the serde as a \"key\" or \"value\" serde.", "url": "https://github.com/apache/kafka/pull/8054#discussion_r376627859", "createdAt": "2020-02-07T22:00:41Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/KTableKTableForeignKeyInnerJoinMultiIntegrationTest.java", "diffHunk": "@@ -206,17 +207,30 @@ private void verifyKTableKTableJoin(final JoinType joinType,\n     }\n \n     private KafkaStreams prepareTopology(final String queryableName, final String queryableNameTwo) {\n+        final UniqueTopicSerdeScope serdeScope = new UniqueTopicSerdeScope();\n         final StreamsBuilder builder = new StreamsBuilder();\n \n-        final KTable<Integer, Float> table1 = builder.table(TABLE_1, Consumed.with(Serdes.Integer(), Serdes.Float()));\n-        final KTable<String, Long> table2 = builder.table(TABLE_2, Consumed.with(Serdes.String(), Serdes.Long()));\n-        final KTable<Integer, String> table3 = builder.table(TABLE_3, Consumed.with(Serdes.Integer(), Serdes.String()));\n+        final KTable<Integer, Float> table1 = builder.table(\n+            TABLE_1,\n+            Consumed.with(serdeScope.decorateSerde(Serdes.Integer(), streamsConfig, true),\n+                          serdeScope.decorateSerde(Serdes.Float(), streamsConfig, false))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyODA5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                System.out.printf(\"storing key[%s] data[%s][%s]%n\", key, data, data.getClass());", "url": "https://github.com/apache/kafka/pull/8054#discussion_r376628099", "createdAt": "2020-02-07T22:01:16Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/utils/UniqueTopicSerdeScope.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.utils;\n+\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Deserializer;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class UniqueTopicSerdeScope {\n+    private final Map<String, Class<?>> topicTypeRegistry = new TreeMap<>();\n+\n+    public <T> UniqueTopicSerdeDecorator<T> decorateSerde(final Serde<T> delegate,\n+                                                          final Properties config,\n+                                                          final boolean isKey) {\n+        final UniqueTopicSerdeDecorator<T> decorator = new UniqueTopicSerdeDecorator<>(delegate);\n+        decorator.configure(config.entrySet().stream().collect(Collectors.toMap(e -> e.getKey().toString(), Map.Entry::getValue)), isKey);\n+        return decorator;\n+    }\n+\n+    public class UniqueTopicSerdeDecorator<T> implements Serde<T> {\n+        private final AtomicBoolean isKey = new AtomicBoolean(false);\n+        private final Serde<T> delegate;\n+\n+        public UniqueTopicSerdeDecorator(final Serde<T> delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public void configure(final Map<String, ?> configs, final boolean isKey) {\n+            delegate.configure(configs, isKey);\n+            this.isKey.set(isKey);\n+        }\n+\n+        @Override\n+        public void close() {\n+            delegate.close();\n+        }\n+\n+        @Override\n+        public Serializer<T> serializer() {\n+            return new UniqueTopicSerializerDecorator<>(isKey, delegate.serializer());\n+        }\n+\n+        @Override\n+        public Deserializer<T> deserializer() {\n+            return new UniqueTopicDeserializerDecorator<>(isKey, delegate.deserializer());\n+        }\n+    }\n+\n+    public class UniqueTopicSerializerDecorator<T> implements Serializer<T> {\n+        private final AtomicBoolean isKey;\n+        private final Serializer<T> delegate;\n+\n+        public UniqueTopicSerializerDecorator(final AtomicBoolean isKey, final Serializer<T> delegate) {\n+            this.isKey = isKey;\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public void configure(final Map<String, ?> configs, final boolean isKey) {\n+            delegate.configure(configs, isKey);\n+            this.isKey.set(isKey);\n+        }\n+\n+        @Override\n+        public byte[] serialize(final String topic, final T data) {\n+            verifyTopic(topic, data);\n+            return delegate.serialize(topic, data);\n+        }\n+\n+        @Override\n+        public byte[] serialize(final String topic, final Headers headers, final T data) {\n+            verifyTopic(topic, data);\n+            return delegate.serialize(topic, headers, data);\n+        }\n+\n+        private void verifyTopic(final String topic, final T data) {\n+            if (data != null) {\n+                final String key = topic + (isKey.get() ? \"--key\" : \"--value\");\n+                if (topicTypeRegistry.containsKey(key)) {\n+                    assertThat(String.format(\"key[%s] data[%s][%s]\", key, data, data.getClass()), topicTypeRegistry.get(key), equalTo(data.getClass()));\n+                } else {\n+                    System.out.printf(\"storing key[%s] data[%s][%s]%n\", key, data, data.getClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyODQ3OQ==", "bodyText": "Here's where the assertion takes place. A nice thing about this approach is that you don't have to make any extra assertions in the tests, you just decorate the serdes, and the assertions happen automatically when you run the program.", "url": "https://github.com/apache/kafka/pull/8054#discussion_r376628479", "createdAt": "2020-02-07T22:02:21Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/utils/UniqueTopicSerdeScope.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.utils;\n+\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Deserializer;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class UniqueTopicSerdeScope {\n+    private final Map<String, Class<?>> topicTypeRegistry = new TreeMap<>();\n+\n+    public <T> UniqueTopicSerdeDecorator<T> decorateSerde(final Serde<T> delegate,\n+                                                          final Properties config,\n+                                                          final boolean isKey) {\n+        final UniqueTopicSerdeDecorator<T> decorator = new UniqueTopicSerdeDecorator<>(delegate);\n+        decorator.configure(config.entrySet().stream().collect(Collectors.toMap(e -> e.getKey().toString(), Map.Entry::getValue)), isKey);\n+        return decorator;\n+    }\n+\n+    public class UniqueTopicSerdeDecorator<T> implements Serde<T> {\n+        private final AtomicBoolean isKey = new AtomicBoolean(false);\n+        private final Serde<T> delegate;\n+\n+        public UniqueTopicSerdeDecorator(final Serde<T> delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public void configure(final Map<String, ?> configs, final boolean isKey) {\n+            delegate.configure(configs, isKey);\n+            this.isKey.set(isKey);\n+        }\n+\n+        @Override\n+        public void close() {\n+            delegate.close();\n+        }\n+\n+        @Override\n+        public Serializer<T> serializer() {\n+            return new UniqueTopicSerializerDecorator<>(isKey, delegate.serializer());\n+        }\n+\n+        @Override\n+        public Deserializer<T> deserializer() {\n+            return new UniqueTopicDeserializerDecorator<>(isKey, delegate.deserializer());\n+        }\n+    }\n+\n+    public class UniqueTopicSerializerDecorator<T> implements Serializer<T> {\n+        private final AtomicBoolean isKey;\n+        private final Serializer<T> delegate;\n+\n+        public UniqueTopicSerializerDecorator(final AtomicBoolean isKey, final Serializer<T> delegate) {\n+            this.isKey = isKey;\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public void configure(final Map<String, ?> configs, final boolean isKey) {\n+            delegate.configure(configs, isKey);\n+            this.isKey.set(isKey);\n+        }\n+\n+        @Override\n+        public byte[] serialize(final String topic, final T data) {\n+            verifyTopic(topic, data);\n+            return delegate.serialize(topic, data);\n+        }\n+\n+        @Override\n+        public byte[] serialize(final String topic, final Headers headers, final T data) {\n+            verifyTopic(topic, data);\n+            return delegate.serialize(topic, headers, data);\n+        }\n+\n+        private void verifyTopic(final String topic, final T data) {\n+            if (data != null) {\n+                final String key = topic + (isKey.get() ? \"--key\" : \"--value\");\n+                if (topicTypeRegistry.containsKey(key)) {\n+                    assertThat(String.format(\"key[%s] data[%s][%s]\", key, data, data.getClass()), topicTypeRegistry.get(key), equalTo(data.getClass()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 105}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a18078fb9f748b2cd20865494047262343734f5", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/5a18078fb9f748b2cd20865494047262343734f5", "committedDate": "2020-02-10T22:57:23Z", "message": "KAFKA-9390: Make serde pseudo-topics unique"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODY1OTA3", "url": "https://github.com/apache/kafka/pull/8054#pullrequestreview-356865907", "createdAt": "2020-02-11T17:50:07Z", "commit": {"oid": "5a18078fb9f748b2cd20865494047262343734f5"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzo1MDowN1rOFoS58w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODowMjozNFrOFoTUIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc5NzEwNw==", "bodyText": "nit: define \"fkTopic\" and \"pkTopic\" as class private fields?", "url": "https://github.com/apache/kafka/pull/8054#discussion_r377797107", "createdAt": "2020-02-11T17:50:07Z", "author": {"login": "guozhangwang"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/foreignkeyjoin/CombinedKeySchemaTest.java", "diffHunk": "@@ -28,7 +28,8 @@\n \n     @Test\n     public void nonNullPrimaryKeySerdeTest() {\n-        final CombinedKeySchema<String, Integer> cks = new CombinedKeySchema<>(\"someTopic\", Serdes.String(), Serdes.Integer());\n+        final CombinedKeySchema<String, Integer> cks = new CombinedKeySchema<>(\"fkTopic\", Serdes.String(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a18078fb9f748b2cd20865494047262343734f5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwMDYwNA==", "bodyText": "qq For my own education: what would be the topic name for this subscription topic? For my understanding that topic name is not the same as primaryKeySerializationPseudoTopic, but I cannot remember why we decided to do so.", "url": "https://github.com/apache/kafka/pull/8054#discussion_r377800604", "createdAt": "2020-02-11T17:56:47Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/foreignkeyjoin/SubscriptionWrapperSerde.java", "diffHunk": "@@ -43,21 +46,28 @@ public SubscriptionWrapperSerde(final Serde<K> primaryKeySerde) {\n     }\n \n     private static class SubscriptionWrapperSerializer<K> implements Serializer<SubscriptionWrapper<K>> {\n+        private final String primaryKeySerializationPseudoTopic;\n         private final Serializer<K> primaryKeySerializer;\n-        SubscriptionWrapperSerializer(final Serializer<K> primaryKeySerializer) {\n+\n+        SubscriptionWrapperSerializer(final String primaryKeySerializationPseudoTopic,\n+                                      final Serializer<K> primaryKeySerializer) {\n+            this.primaryKeySerializationPseudoTopic = primaryKeySerializationPseudoTopic;\n             this.primaryKeySerializer = primaryKeySerializer;\n         }\n \n         @Override\n-        public byte[] serialize(final String topic, final SubscriptionWrapper<K> data) {\n+        public byte[] serialize(final String ignored, final SubscriptionWrapper<K> data) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyNjM4NA=="}, "originalCommit": null, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwMzIzNQ==", "bodyText": "Great idea.", "url": "https://github.com/apache/kafka/pull/8054#discussion_r377803235", "createdAt": "2020-02-11T18:01:29Z", "author": {"login": "guozhangwang"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/KTableKTableForeignKeyInnerJoinMultiIntegrationTest.java", "diffHunk": "@@ -206,17 +207,30 @@ private void verifyKTableKTableJoin(final JoinType joinType,\n     }\n \n     private KafkaStreams prepareTopology(final String queryableName, final String queryableNameTwo) {\n+        final UniqueTopicSerdeScope serdeScope = new UniqueTopicSerdeScope();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyNzQ1MQ=="}, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwMzgxMA==", "bodyText": "Suggesting a commit to your own PR? seems they are the same :P", "url": "https://github.com/apache/kafka/pull/8054#discussion_r377803810", "createdAt": "2020-02-11T18:02:34Z", "author": {"login": "guozhangwang"}, "path": "streams/src/test/java/org/apache/kafka/streams/utils/UniqueTopicSerdeScope.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.utils;\n+\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Deserializer;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class UniqueTopicSerdeScope {\n+    private final Map<String, Class<?>> topicTypeRegistry = new TreeMap<>();\n+\n+    public <T> UniqueTopicSerdeDecorator<T> decorateSerde(final Serde<T> delegate,\n+                                                          final Properties config,\n+                                                          final boolean isKey) {\n+        final UniqueTopicSerdeDecorator<T> decorator = new UniqueTopicSerdeDecorator<>(delegate);\n+        decorator.configure(config.entrySet().stream().collect(Collectors.toMap(e -> e.getKey().toString(), Map.Entry::getValue)), isKey);\n+        return decorator;\n+    }\n+\n+    public class UniqueTopicSerdeDecorator<T> implements Serde<T> {\n+        private final AtomicBoolean isKey = new AtomicBoolean(false);\n+        private final Serde<T> delegate;\n+\n+        public UniqueTopicSerdeDecorator(final Serde<T> delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public void configure(final Map<String, ?> configs, final boolean isKey) {\n+            delegate.configure(configs, isKey);\n+            this.isKey.set(isKey);\n+        }\n+\n+        @Override\n+        public void close() {\n+            delegate.close();\n+        }\n+\n+        @Override\n+        public Serializer<T> serializer() {\n+            return new UniqueTopicSerializerDecorator<>(isKey, delegate.serializer());\n+        }\n+\n+        @Override\n+        public Deserializer<T> deserializer() {\n+            return new UniqueTopicDeserializerDecorator<>(isKey, delegate.deserializer());\n+        }\n+    }\n+\n+    public class UniqueTopicSerializerDecorator<T> implements Serializer<T> {\n+        private final AtomicBoolean isKey;\n+        private final Serializer<T> delegate;\n+\n+        public UniqueTopicSerializerDecorator(final AtomicBoolean isKey, final Serializer<T> delegate) {\n+            this.isKey = isKey;\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public void configure(final Map<String, ?> configs, final boolean isKey) {\n+            delegate.configure(configs, isKey);\n+            this.isKey.set(isKey);\n+        }\n+\n+        @Override\n+        public byte[] serialize(final String topic, final T data) {\n+            verifyTopic(topic, data);\n+            return delegate.serialize(topic, data);\n+        }\n+\n+        @Override\n+        public byte[] serialize(final String topic, final Headers headers, final T data) {\n+            verifyTopic(topic, data);\n+            return delegate.serialize(topic, headers, data);\n+        }\n+\n+        private void verifyTopic(final String topic, final T data) {\n+            if (data != null) {\n+                final String key = topic + (isKey.get() ? \"--key\" : \"--value\");\n+                if (topicTypeRegistry.containsKey(key)) {\n+                    assertThat(String.format(\"key[%s] data[%s][%s]\", key, data, data.getClass()), topicTypeRegistry.get(key), equalTo(data.getClass()));\n+                } else {\n+                    System.out.printf(\"storing key[%s] data[%s][%s]%n\", key, data, data.getClass());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyODA5OQ=="}, "originalCommit": null, "originalPosition": 107}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d63f556eff69d62bd7f9c358a2ca215f2adab76", "author": {"user": {"login": "vvcephei", "name": "John Roesler"}}, "url": "https://github.com/apache/kafka/commit/8d63f556eff69d62bd7f9c358a2ca215f2adab76", "committedDate": "2020-02-11T20:37:49Z", "message": "Update streams/src/test/java/org/apache/kafka/streams/utils/UniqueTopicSerdeScope.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e0feed4c2e6d2bce99962d332fa5516970aad69", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/0e0feed4c2e6d2bce99962d332fa5516970aad69", "committedDate": "2020-02-11T20:47:19Z", "message": "fix test collisions on state directory"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1773, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}