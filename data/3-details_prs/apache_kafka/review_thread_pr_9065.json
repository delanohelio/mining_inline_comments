{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1NzgyNjIw", "number": 9065, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNToxNTowNFrOERfvmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzo0MjoyMVrOERjRNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NzgxMzM4OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/cluster/Partition.scala", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNToxNTowNFrOG2PTuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzowMTo0NFrOG2Th8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUyNzA5Nw==", "bodyText": "I decided to not get fancy with refactorings - this is literally the old code (\n  \n    \n      kafka/core/src/main/scala/kafka/cluster/Partition.scala\n    \n    \n         Line 657\n      in\n      7f9187f\n    \n    \n    \n    \n\n        \n          \n           removedReplicas.foreach(remoteReplicasMap.remove) \n        \n    \n  \n\n))", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459527097", "createdAt": "2020-07-23T15:15:04Z", "author": {"login": "stanislavkozlovski"}, "path": "core/src/main/scala/kafka/cluster/Partition.scala", "diffHunk": "@@ -678,11 +678,13 @@ class Partition(val topicPartition: TopicPartition,\n                              isr: Set[Int],\n                              addingReplicas: Seq[Int],\n                              removingReplicas: Seq[Int]): Unit = {\n-    remoteReplicasMap.clear()\n+    val replicaSet = assignment.toSet\n+    val removedReplicas = remoteReplicasMap.keys -- replicaSet\n+\n     assignment\n       .filter(_ != localBrokerId)\n       .foreach(id => remoteReplicasMap.getAndMaybePut(id, new Replica(id, topicPartition)))\n-\n+    removedReplicas.foreach(remoteReplicasMap.remove)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5611fd872eed98f02ea805eabaa170c9b09c81a5"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU2MzIwNQ==", "bodyText": "Would remoteReplicasMap --= removedReplicas work here?", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459563205", "createdAt": "2020-07-23T16:07:19Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/cluster/Partition.scala", "diffHunk": "@@ -678,11 +678,13 @@ class Partition(val topicPartition: TopicPartition,\n                              isr: Set[Int],\n                              addingReplicas: Seq[Int],\n                              removingReplicas: Seq[Int]): Unit = {\n-    remoteReplicasMap.clear()\n+    val replicaSet = assignment.toSet\n+    val removedReplicas = remoteReplicasMap.keys -- replicaSet\n+\n     assignment\n       .filter(_ != localBrokerId)\n       .foreach(id => remoteReplicasMap.getAndMaybePut(id, new Replica(id, topicPartition)))\n-\n+    removedReplicas.foreach(remoteReplicasMap.remove)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUyNzA5Nw=="}, "originalCommit": {"oid": "5611fd872eed98f02ea805eabaa170c9b09c81a5"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU4ODUwMQ==", "bodyText": "Oh, this is a Pool, so we would have to add a removeAll method. Seems easy enough though since it can call the relevant method in ConcurrentMap.", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459588501", "createdAt": "2020-07-23T16:48:51Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/cluster/Partition.scala", "diffHunk": "@@ -678,11 +678,13 @@ class Partition(val topicPartition: TopicPartition,\n                              isr: Set[Int],\n                              addingReplicas: Seq[Int],\n                              removingReplicas: Seq[Int]): Unit = {\n-    remoteReplicasMap.clear()\n+    val replicaSet = assignment.toSet\n+    val removedReplicas = remoteReplicasMap.keys -- replicaSet\n+\n     assignment\n       .filter(_ != localBrokerId)\n       .foreach(id => remoteReplicasMap.getAndMaybePut(id, new Replica(id, topicPartition)))\n-\n+    removedReplicas.foreach(remoteReplicasMap.remove)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUyNzA5Nw=="}, "originalCommit": {"oid": "5611fd872eed98f02ea805eabaa170c9b09c81a5"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5NjI3NA==", "bodyText": "remoteReplicasMap --= removedReplicas doesn't compile - the remoteReplicasMap is using a Kafka Pool class which itself is using a Java Map and I don't think they support the --= notation", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459596274", "createdAt": "2020-07-23T17:01:44Z", "author": {"login": "stanislavkozlovski"}, "path": "core/src/main/scala/kafka/cluster/Partition.scala", "diffHunk": "@@ -678,11 +678,13 @@ class Partition(val topicPartition: TopicPartition,\n                              isr: Set[Int],\n                              addingReplicas: Seq[Int],\n                              removingReplicas: Seq[Int]): Unit = {\n-    remoteReplicasMap.clear()\n+    val replicaSet = assignment.toSet\n+    val removedReplicas = remoteReplicasMap.keys -- replicaSet\n+\n     assignment\n       .filter(_ != localBrokerId)\n       .foreach(id => remoteReplicasMap.getAndMaybePut(id, new Replica(id, topicPartition)))\n-\n+    removedReplicas.foreach(remoteReplicasMap.remove)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUyNzA5Nw=="}, "originalCommit": {"oid": "5611fd872eed98f02ea805eabaa170c9b09c81a5"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODI1NjA3OnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzowNToyNlrOG2TqZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzowNToyNlrOG2TqZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5ODQzOQ==", "bodyText": "This fails incredibly quickly 100/100 times without the Partition.scala changes.", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459598439", "createdAt": "2020-07-23T17:05:26Z", "author": {"login": "stanislavkozlovski"}, "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -116,6 +117,56 @@ class PartitionLockTest extends Logging {\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n+  /**\n+   * Concurrently calling updateAssignmentAndIsr should always ensure that non-lock access\n+   * to the inner remoteReplicaMap (accessed by getReplica) cannot see an intermediate state\n+   * where replicas present both in the old and new assignment are missing\n+   */\n+  @Test\n+  def testGetReplicaWithUpdateAssignmentAndIsr(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12016f1d9ad55482edf89f7315191f131dc1dac6"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODMxMjU5OnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/utils/PoolTest.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoyMDo1M1rOG2UNtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoyMDo1M1rOG2UNtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwNzQ3Ng==", "bodyText": "Remove unit.", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459607476", "createdAt": "2020-07-23T17:20:53Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/utils/PoolTest.scala", "diffHunk": "@@ -0,0 +1,41 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package unit.kafka.utils", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21fb575aa28581f5b40953726dc8a9868cc46867"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODM1MDA2OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/utils/Pool.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzozMTowOFrOG2Uk1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzozMTowOFrOG2Uk1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxMzM5OQ==", "bodyText": "Nit: () is not needed.", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459613399", "createdAt": "2020-07-23T17:31:08Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/utils/Pool.scala", "diffHunk": "@@ -69,6 +69,8 @@ class Pool[K,V](valueFactory: Option[K => V] = None) extends Iterable[(K, V)] {\n \n   def remove(key: K, value: V): Boolean = pool.remove(key, value)\n \n+  def removeAll(keys: Iterable[K]): Unit = pool.keySet().removeAll(keys.asJavaCollection)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c13e73849e4bb1c322aaa099432a4b34401a8085"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODM2MjcyOnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzozNDo0MFrOG2Uspw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzozNDo0MFrOG2Uspw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxNTM5OQ==", "bodyText": "No need to repeat LeaderAndIsrPartitionState twice.", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459615399", "createdAt": "2020-07-23T17:34:40Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -116,6 +117,56 @@ class PartitionLockTest extends Logging {\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n+  /**\n+   * Concurrently calling updateAssignmentAndIsr should always ensure that non-lock access\n+   * to the inner remoteReplicaMap (accessed by getReplica) cannot see an intermediate state\n+   * where replicas present both in the old and new assignment are missing\n+   */\n+  @Test\n+  def testGetReplicaWithUpdateAssignmentAndIsr(): Unit = {\n+    val active = new AtomicBoolean(true)\n+    val replicaToCheck = 3\n+    val firstReplicaSet = Seq[Integer](3, 4, 5).asJava\n+    val secondReplicaSet = Seq[Integer](1, 2, 3).asJava\n+    def partitionState(replicas: java.util.List[Integer]): LeaderAndIsrPartitionState = new LeaderAndIsrPartitionState()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c13e73849e4bb1c322aaa099432a4b34401a8085"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODM2NzYxOnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzozNjowM1rOG2Uvmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxODoxNzo0M1rOG2WNRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxNjE1NA==", "bodyText": "Shouldn't this be inside the thread state?", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459616154", "createdAt": "2020-07-23T17:36:03Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -116,6 +117,56 @@ class PartitionLockTest extends Logging {\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n+  /**\n+   * Concurrently calling updateAssignmentAndIsr should always ensure that non-lock access\n+   * to the inner remoteReplicaMap (accessed by getReplica) cannot see an intermediate state\n+   * where replicas present both in the old and new assignment are missing\n+   */\n+  @Test\n+  def testGetReplicaWithUpdateAssignmentAndIsr(): Unit = {\n+    val active = new AtomicBoolean(true)\n+    val replicaToCheck = 3\n+    val firstReplicaSet = Seq[Integer](3, 4, 5).asJava\n+    val secondReplicaSet = Seq[Integer](1, 2, 3).asJava\n+    def partitionState(replicas: java.util.List[Integer]): LeaderAndIsrPartitionState = new LeaderAndIsrPartitionState()\n+      .setControllerEpoch(1)\n+      .setLeader(replicas.get(0))\n+      .setLeaderEpoch(1)\n+      .setIsr(replicas)\n+      .setZkVersion(1)\n+      .setReplicas(replicas)\n+      .setIsNew(true)\n+    val offsetCheckpoints: OffsetCheckpoints = mock(classOf[OffsetCheckpoints])\n+    // Update replica set synchronously first to avoid race conditions\n+    partition.makeLeader(partitionState(secondReplicaSet), offsetCheckpoints)\n+    assertTrue(s\"Expected replica $replicaToCheck to be defined\", partition.getReplica(replicaToCheck).isDefined)\n+\n+    var i = 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c13e73849e4bb1c322aaa099432a4b34401a8085"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY0MDEzNA==", "bodyText": "Yeah, nice catch", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459640134", "createdAt": "2020-07-23T18:17:43Z", "author": {"login": "stanislavkozlovski"}, "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -116,6 +117,56 @@ class PartitionLockTest extends Logging {\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n+  /**\n+   * Concurrently calling updateAssignmentAndIsr should always ensure that non-lock access\n+   * to the inner remoteReplicaMap (accessed by getReplica) cannot see an intermediate state\n+   * where replicas present both in the old and new assignment are missing\n+   */\n+  @Test\n+  def testGetReplicaWithUpdateAssignmentAndIsr(): Unit = {\n+    val active = new AtomicBoolean(true)\n+    val replicaToCheck = 3\n+    val firstReplicaSet = Seq[Integer](3, 4, 5).asJava\n+    val secondReplicaSet = Seq[Integer](1, 2, 3).asJava\n+    def partitionState(replicas: java.util.List[Integer]): LeaderAndIsrPartitionState = new LeaderAndIsrPartitionState()\n+      .setControllerEpoch(1)\n+      .setLeader(replicas.get(0))\n+      .setLeaderEpoch(1)\n+      .setIsr(replicas)\n+      .setZkVersion(1)\n+      .setReplicas(replicas)\n+      .setIsNew(true)\n+    val offsetCheckpoints: OffsetCheckpoints = mock(classOf[OffsetCheckpoints])\n+    // Update replica set synchronously first to avoid race conditions\n+    partition.makeLeader(partitionState(secondReplicaSet), offsetCheckpoints)\n+    assertTrue(s\"Expected replica $replicaToCheck to be defined\", partition.getReplica(replicaToCheck).isDefined)\n+\n+    var i = 0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxNjE1NA=="}, "originalCommit": {"oid": "c13e73849e4bb1c322aaa099432a4b34401a8085"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODM3NDg3OnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzozNzo1N1rOG2U0Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxODoyNzoyNVrOG2Wh4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxNzI5OA==", "bodyText": "5 seconds is quite a bit. Can it be lower?", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459617298", "createdAt": "2020-07-23T17:37:57Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -116,6 +117,56 @@ class PartitionLockTest extends Logging {\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n+  /**\n+   * Concurrently calling updateAssignmentAndIsr should always ensure that non-lock access\n+   * to the inner remoteReplicaMap (accessed by getReplica) cannot see an intermediate state\n+   * where replicas present both in the old and new assignment are missing\n+   */\n+  @Test\n+  def testGetReplicaWithUpdateAssignmentAndIsr(): Unit = {\n+    val active = new AtomicBoolean(true)\n+    val replicaToCheck = 3\n+    val firstReplicaSet = Seq[Integer](3, 4, 5).asJava\n+    val secondReplicaSet = Seq[Integer](1, 2, 3).asJava\n+    def partitionState(replicas: java.util.List[Integer]): LeaderAndIsrPartitionState = new LeaderAndIsrPartitionState()\n+      .setControllerEpoch(1)\n+      .setLeader(replicas.get(0))\n+      .setLeaderEpoch(1)\n+      .setIsr(replicas)\n+      .setZkVersion(1)\n+      .setReplicas(replicas)\n+      .setIsNew(true)\n+    val offsetCheckpoints: OffsetCheckpoints = mock(classOf[OffsetCheckpoints])\n+    // Update replica set synchronously first to avoid race conditions\n+    partition.makeLeader(partitionState(secondReplicaSet), offsetCheckpoints)\n+    assertTrue(s\"Expected replica $replicaToCheck to be defined\", partition.getReplica(replicaToCheck).isDefined)\n+\n+    var i = 0\n+    val future = executorService.submit((() => {\n+      // Flip assignment between two replica sets\n+      while (active.get) {\n+        val replicas = if (i % 2 == 0) {\n+          firstReplicaSet\n+        } else {\n+          secondReplicaSet\n+        }\n+\n+        partition.makeLeader(partitionState(replicas), offsetCheckpoints)\n+\n+        i += 1\n+        Thread.sleep(1) // just to avoid tight loop\n+      }\n+    }): Runnable)\n+\n+    val deadline = 5.seconds.fromNow", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c13e73849e4bb1c322aaa099432a4b34401a8085"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY0MDg1NA==", "bodyText": "I think so. I opted for 5s as I saw the other tests had up to 15s of waits for futures. Let me see if 1s can go", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459640854", "createdAt": "2020-07-23T18:19:04Z", "author": {"login": "stanislavkozlovski"}, "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -116,6 +117,56 @@ class PartitionLockTest extends Logging {\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n+  /**\n+   * Concurrently calling updateAssignmentAndIsr should always ensure that non-lock access\n+   * to the inner remoteReplicaMap (accessed by getReplica) cannot see an intermediate state\n+   * where replicas present both in the old and new assignment are missing\n+   */\n+  @Test\n+  def testGetReplicaWithUpdateAssignmentAndIsr(): Unit = {\n+    val active = new AtomicBoolean(true)\n+    val replicaToCheck = 3\n+    val firstReplicaSet = Seq[Integer](3, 4, 5).asJava\n+    val secondReplicaSet = Seq[Integer](1, 2, 3).asJava\n+    def partitionState(replicas: java.util.List[Integer]): LeaderAndIsrPartitionState = new LeaderAndIsrPartitionState()\n+      .setControllerEpoch(1)\n+      .setLeader(replicas.get(0))\n+      .setLeaderEpoch(1)\n+      .setIsr(replicas)\n+      .setZkVersion(1)\n+      .setReplicas(replicas)\n+      .setIsNew(true)\n+    val offsetCheckpoints: OffsetCheckpoints = mock(classOf[OffsetCheckpoints])\n+    // Update replica set synchronously first to avoid race conditions\n+    partition.makeLeader(partitionState(secondReplicaSet), offsetCheckpoints)\n+    assertTrue(s\"Expected replica $replicaToCheck to be defined\", partition.getReplica(replicaToCheck).isDefined)\n+\n+    var i = 0\n+    val future = executorService.submit((() => {\n+      // Flip assignment between two replica sets\n+      while (active.get) {\n+        val replicas = if (i % 2 == 0) {\n+          firstReplicaSet\n+        } else {\n+          secondReplicaSet\n+        }\n+\n+        partition.makeLeader(partitionState(replicas), offsetCheckpoints)\n+\n+        i += 1\n+        Thread.sleep(1) // just to avoid tight loop\n+      }\n+    }): Runnable)\n+\n+    val deadline = 5.seconds.fromNow", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxNzI5OA=="}, "originalCommit": {"oid": "c13e73849e4bb1c322aaa099432a4b34401a8085"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY0NTQxMQ==", "bodyText": "Lowered to 1s", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459645411", "createdAt": "2020-07-23T18:27:25Z", "author": {"login": "stanislavkozlovski"}, "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -116,6 +117,56 @@ class PartitionLockTest extends Logging {\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n+  /**\n+   * Concurrently calling updateAssignmentAndIsr should always ensure that non-lock access\n+   * to the inner remoteReplicaMap (accessed by getReplica) cannot see an intermediate state\n+   * where replicas present both in the old and new assignment are missing\n+   */\n+  @Test\n+  def testGetReplicaWithUpdateAssignmentAndIsr(): Unit = {\n+    val active = new AtomicBoolean(true)\n+    val replicaToCheck = 3\n+    val firstReplicaSet = Seq[Integer](3, 4, 5).asJava\n+    val secondReplicaSet = Seq[Integer](1, 2, 3).asJava\n+    def partitionState(replicas: java.util.List[Integer]): LeaderAndIsrPartitionState = new LeaderAndIsrPartitionState()\n+      .setControllerEpoch(1)\n+      .setLeader(replicas.get(0))\n+      .setLeaderEpoch(1)\n+      .setIsr(replicas)\n+      .setZkVersion(1)\n+      .setReplicas(replicas)\n+      .setIsNew(true)\n+    val offsetCheckpoints: OffsetCheckpoints = mock(classOf[OffsetCheckpoints])\n+    // Update replica set synchronously first to avoid race conditions\n+    partition.makeLeader(partitionState(secondReplicaSet), offsetCheckpoints)\n+    assertTrue(s\"Expected replica $replicaToCheck to be defined\", partition.getReplica(replicaToCheck).isDefined)\n+\n+    var i = 0\n+    val future = executorService.submit((() => {\n+      // Flip assignment between two replica sets\n+      while (active.get) {\n+        val replicas = if (i % 2 == 0) {\n+          firstReplicaSet\n+        } else {\n+          secondReplicaSet\n+        }\n+\n+        partition.makeLeader(partitionState(replicas), offsetCheckpoints)\n+\n+        i += 1\n+        Thread.sleep(1) // just to avoid tight loop\n+      }\n+    }): Runnable)\n+\n+    val deadline = 5.seconds.fromNow", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxNzI5OA=="}, "originalCommit": {"oid": "c13e73849e4bb1c322aaa099432a4b34401a8085"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODM5MDkyOnYy", "diffSide": "RIGHT", "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzo0MjoyMVrOG2U97Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzo0MjoyMVrOG2U97Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxOTgyMQ==", "bodyText": "Nit: space missing after while.", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459619821", "createdAt": "2020-07-23T17:42:21Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -116,6 +117,56 @@ class PartitionLockTest extends Logging {\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n+  /**\n+   * Concurrently calling updateAssignmentAndIsr should always ensure that non-lock access\n+   * to the inner remoteReplicaMap (accessed by getReplica) cannot see an intermediate state\n+   * where replicas present both in the old and new assignment are missing\n+   */\n+  @Test\n+  def testGetReplicaWithUpdateAssignmentAndIsr(): Unit = {\n+    val active = new AtomicBoolean(true)\n+    val replicaToCheck = 3\n+    val firstReplicaSet = Seq[Integer](3, 4, 5).asJava\n+    val secondReplicaSet = Seq[Integer](1, 2, 3).asJava\n+    def partitionState(replicas: java.util.List[Integer]): LeaderAndIsrPartitionState = new LeaderAndIsrPartitionState()\n+      .setControllerEpoch(1)\n+      .setLeader(replicas.get(0))\n+      .setLeaderEpoch(1)\n+      .setIsr(replicas)\n+      .setZkVersion(1)\n+      .setReplicas(replicas)\n+      .setIsNew(true)\n+    val offsetCheckpoints: OffsetCheckpoints = mock(classOf[OffsetCheckpoints])\n+    // Update replica set synchronously first to avoid race conditions\n+    partition.makeLeader(partitionState(secondReplicaSet), offsetCheckpoints)\n+    assertTrue(s\"Expected replica $replicaToCheck to be defined\", partition.getReplica(replicaToCheck).isDefined)\n+\n+    var i = 0\n+    val future = executorService.submit((() => {\n+      // Flip assignment between two replica sets\n+      while (active.get) {\n+        val replicas = if (i % 2 == 0) {\n+          firstReplicaSet\n+        } else {\n+          secondReplicaSet\n+        }\n+\n+        partition.makeLeader(partitionState(replicas), offsetCheckpoints)\n+\n+        i += 1\n+        Thread.sleep(1) // just to avoid tight loop\n+      }\n+    }): Runnable)\n+\n+    val deadline = 5.seconds.fromNow\n+    while(deadline.hasTimeLeft()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c13e73849e4bb1c322aaa099432a4b34401a8085"}, "originalPosition": 54}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2305, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}