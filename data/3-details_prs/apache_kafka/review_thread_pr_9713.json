{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0NjcwMDc2", "number": 9713, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxOTo1NDowOFrOFCkSvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOTo0MjoyNVrOFHUtOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MjM2MDk1OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxOTo1NDowOFrOIBzcEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMTo0MzoyN1rOICq2_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2MjI1Ng==", "bodyText": "We don't have to do it here, but I think the controller epoch is no longer needed. This was previously used as a sort of poor man's controller fencing, but now the controller has a stronger mechanism relying on conditional zk updates.\nBy the way, do we need the default value? Especially the fact that it is a sentinel seems dangerous.", "url": "https://github.com/apache/kafka/pull/9713#discussion_r538762256", "createdAt": "2020-12-08T19:54:08Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -46,13 +51,36 @@ trait AlterIsrManager {\n   def clearPending(topicPartition: TopicPartition): Unit\n }\n \n-case class AlterIsrItem(topicPartition: TopicPartition, leaderAndIsr: LeaderAndIsr, callback: Either[Errors, LeaderAndIsr] => Unit)\n+case class AlterIsrItem(topicPartition: TopicPartition,\n+                        leaderAndIsr: LeaderAndIsr,\n+                        callback: Either[Errors, LeaderAndIsr] => Unit,\n+                        controllerEpoch: Int = -1) // controllerEpoch needed for Zk impl", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec56bd1fa835e34158c5a6ce70e692dee858c4d2"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY3MDI3MQ==", "bodyText": "That -1 is left over from test refactoring. I'll remove", "url": "https://github.com/apache/kafka/pull/9713#discussion_r539670271", "createdAt": "2020-12-09T21:43:27Z", "author": {"login": "mumrah"}, "path": "core/src/main/scala/kafka/server/AlterIsrManager.scala", "diffHunk": "@@ -46,13 +51,36 @@ trait AlterIsrManager {\n   def clearPending(topicPartition: TopicPartition): Unit\n }\n \n-case class AlterIsrItem(topicPartition: TopicPartition, leaderAndIsr: LeaderAndIsr, callback: Either[Errors, LeaderAndIsr] => Unit)\n+case class AlterIsrItem(topicPartition: TopicPartition,\n+                        leaderAndIsr: LeaderAndIsr,\n+                        callback: Either[Errors, LeaderAndIsr] => Unit,\n+                        controllerEpoch: Int = -1) // controllerEpoch needed for Zk impl", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2MjI1Ng=="}, "originalCommit": {"oid": "ec56bd1fa835e34158c5a6ce70e692dee858c4d2"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4ODI3NjA1OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/cluster/Partition.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMDo0ODozNFrOICozog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMDo0ODozNFrOICozog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYzNjY0Mg==", "bodyText": "nit: I wonder if it might be better to use a verb like fetch which suggests some overhead involved", "url": "https://github.com/apache/kafka/pull/9713#discussion_r539636642", "createdAt": "2020-12-09T20:48:34Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/cluster/Partition.scala", "diffHunk": "@@ -51,40 +51,8 @@ trait IsrChangeListener {\n   def markFailed(): Unit\n }\n \n-trait PartitionStateStore {\n-  def fetchTopicConfig(): Properties\n-  def shrinkIsr(controllerEpoch: Int, leaderAndIsr: LeaderAndIsr): Option[Int]\n-  def expandIsr(controllerEpoch: Int, leaderAndIsr: LeaderAndIsr): Option[Int]\n-}\n-\n-class ZkPartitionStateStore(topicPartition: TopicPartition,\n-                            zkClient: KafkaZkClient) extends PartitionStateStore {\n-\n-  override def fetchTopicConfig(): Properties = {\n-    val adminZkClient = new AdminZkClient(zkClient)\n-    adminZkClient.fetchEntityConfig(ConfigType.Topic, topicPartition.topic)\n-  }\n-\n-  override def shrinkIsr(controllerEpoch: Int, leaderAndIsr: LeaderAndIsr): Option[Int] = {\n-    val newVersionOpt = updateIsr(controllerEpoch, leaderAndIsr)\n-    newVersionOpt\n-  }\n-\n-  override def expandIsr(controllerEpoch: Int, leaderAndIsr: LeaderAndIsr): Option[Int] = {\n-    val newVersionOpt = updateIsr(controllerEpoch, leaderAndIsr)\n-    newVersionOpt\n-  }\n-\n-  private def updateIsr(controllerEpoch: Int, leaderAndIsr: LeaderAndIsr): Option[Int] = {\n-    val (updateSucceeded, newVersion) = ReplicationUtils.updateLeaderAndIsr(zkClient, topicPartition,\n-      leaderAndIsr, controllerEpoch)\n-\n-    if (updateSucceeded) {\n-      Some(newVersion)\n-    } else {\n-      None\n-    }\n-  }\n+trait TopicConfigProvider {\n+  def get(): Properties", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec56bd1fa835e34158c5a6ce70e692dee858c4d2"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4ODMwMzY3OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/ZkIsrManager.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMDo1NTowNFrOICpDDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMDo1NTowNFrOICpDDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0MDU5MA==", "bodyText": "The name \"enqueue\" suggests an asynchronous change. Wonder if there is another name we could use. Perhaps \"submit\" suggests less about the implementation?", "url": "https://github.com/apache/kafka/pull/9713#discussion_r539640590", "createdAt": "2020-12-09T20:55:04Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/ZkIsrManager.scala", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.utils.{Logging, ReplicationUtils, Scheduler}\n+import kafka.zk.KafkaZkClient\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicLong\n+import scala.collection.mutable\n+\n+/**\n+ * @param checkIntervalMs How often to check for ISR\n+ * @param maxDelayMs  Maximum time that an ISR change may be delayed before sending the notification\n+ * @param lingerMs  Maximum time to await additional changes before sending the notification\n+ */\n+case class IsrChangePropagationConfig(checkIntervalMs: Long, maxDelayMs: Long, lingerMs: Long)\n+\n+object ZkIsrManager {\n+  // This field is mutable to allow overriding change notification behavior in test cases\n+  @volatile var DefaultIsrPropagationConfig: IsrChangePropagationConfig = IsrChangePropagationConfig(\n+    checkIntervalMs = 2500,\n+    lingerMs = 5000,\n+    maxDelayMs = 60000,\n+  )\n+}\n+\n+class ZkIsrManager(scheduler: Scheduler, time: Time, zkClient: KafkaZkClient) extends AlterIsrManager with Logging {\n+\n+  private val isrChangeNotificationConfig = ZkIsrManager.DefaultIsrPropagationConfig\n+  // Visible for testing\n+  private[server] val isrChangeSet: mutable.Set[TopicPartition] = new mutable.HashSet[TopicPartition]()\n+  private val lastIsrChangeMs = new AtomicLong(time.milliseconds())\n+  private val lastIsrPropagationMs = new AtomicLong(time.milliseconds())\n+\n+  override def start(): Unit = {\n+    scheduler.schedule(\"isr-change-propagation\", maybePropagateIsrChanges _,\n+      period = isrChangeNotificationConfig.checkIntervalMs, unit = TimeUnit.MILLISECONDS)\n+  }\n+\n+  override def clearPending(topicPartition: TopicPartition): Unit = {\n+    // Since we always immediately process ZK updates and never actually enqueue anything, there is nothing to\n+    // clear here so this is a no-op. Even if there are changes that have not been propagated, the write to ZK\n+    // has already happened, so we may as well send the notification to the controller.\n+  }\n+\n+  override def enqueue(alterIsrItem: AlterIsrItem): Boolean = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec56bd1fa835e34158c5a6ce70e692dee858c4d2"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4ODMyNzAxOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/ZkIsrManager.scala", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMTowMDo0OFrOICpQtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQxMzoyNzowNVrOID4sQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0NDA4Nw==", "bodyText": "Hmm.. It feels a tad brittle to rely on locking assumptions like this. Perhaps we could let enqueue return a different response in the case that the change was applied immediately? For example, we could return Option[Int] to indicate that new version if the change was applied. Note that we can probably discard the boolean return type and let enqueue raise an illegal state exception directly since that is what Partition is already doing.", "url": "https://github.com/apache/kafka/pull/9713#discussion_r539644087", "createdAt": "2020-12-09T21:00:48Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/ZkIsrManager.scala", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.utils.{Logging, ReplicationUtils, Scheduler}\n+import kafka.zk.KafkaZkClient\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicLong\n+import scala.collection.mutable\n+\n+/**\n+ * @param checkIntervalMs How often to check for ISR\n+ * @param maxDelayMs  Maximum time that an ISR change may be delayed before sending the notification\n+ * @param lingerMs  Maximum time to await additional changes before sending the notification\n+ */\n+case class IsrChangePropagationConfig(checkIntervalMs: Long, maxDelayMs: Long, lingerMs: Long)\n+\n+object ZkIsrManager {\n+  // This field is mutable to allow overriding change notification behavior in test cases\n+  @volatile var DefaultIsrPropagationConfig: IsrChangePropagationConfig = IsrChangePropagationConfig(\n+    checkIntervalMs = 2500,\n+    lingerMs = 5000,\n+    maxDelayMs = 60000,\n+  )\n+}\n+\n+class ZkIsrManager(scheduler: Scheduler, time: Time, zkClient: KafkaZkClient) extends AlterIsrManager with Logging {\n+\n+  private val isrChangeNotificationConfig = ZkIsrManager.DefaultIsrPropagationConfig\n+  // Visible for testing\n+  private[server] val isrChangeSet: mutable.Set[TopicPartition] = new mutable.HashSet[TopicPartition]()\n+  private val lastIsrChangeMs = new AtomicLong(time.milliseconds())\n+  private val lastIsrPropagationMs = new AtomicLong(time.milliseconds())\n+\n+  override def start(): Unit = {\n+    scheduler.schedule(\"isr-change-propagation\", maybePropagateIsrChanges _,\n+      period = isrChangeNotificationConfig.checkIntervalMs, unit = TimeUnit.MILLISECONDS)\n+  }\n+\n+  override def clearPending(topicPartition: TopicPartition): Unit = {\n+    // Since we always immediately process ZK updates and never actually enqueue anything, there is nothing to\n+    // clear here so this is a no-op. Even if there are changes that have not been propagated, the write to ZK\n+    // has already happened, so we may as well send the notification to the controller.\n+  }\n+\n+  override def enqueue(alterIsrItem: AlterIsrItem): Boolean = {\n+    debug(s\"Writing new ISR \" + alterIsrItem.leaderAndIsr.isr + \" to ZooKeeper with version \" +\n+      alterIsrItem.leaderAndIsr.zkVersion + \" for partition \" + alterIsrItem.topicPartition)\n+\n+    val (updateSucceeded, newVersion) = ReplicationUtils.updateLeaderAndIsr(zkClient, alterIsrItem.topicPartition,\n+      alterIsrItem.leaderAndIsr, alterIsrItem.controllerEpoch)\n+\n+    if (updateSucceeded) {\n+      // Track which partitions need to be propagated to the controller\n+      isrChangeSet synchronized {\n+        isrChangeSet += alterIsrItem.topicPartition\n+        lastIsrChangeMs.set(time.milliseconds())\n+      }\n+\n+      // We actually need to apply the callback in another thread since Partition#sendAlterIsrRequest will write", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec56bd1fa835e34158c5a6ce70e692dee858c4d2"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNTE1Nw==", "bodyText": "Ok, so in this case, we would need to call the callback from sendAlterIsrRequest for the ZK case. I think that would probably be ok. I agree that relying on the separate thread and the lock is a little wonky.\nSomething like this?\ntry {\n  alterIsrManager.enqueue(alterIsrItem) match {\n    case Some(newVersion) => \n      isrState = proposedIsrState\n      handleAlterIsrResponse(proposedState.withZkVersion(newVersion))\n    case None =>\n      isrState = proposedIsrState\n} catch {\n   e: Throwable => \n    isrChangeListener.markFailed()\n    throw e\n}", "url": "https://github.com/apache/kafka/pull/9713#discussion_r539705157", "createdAt": "2020-12-09T22:45:54Z", "author": {"login": "mumrah"}, "path": "core/src/main/scala/kafka/server/ZkIsrManager.scala", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.utils.{Logging, ReplicationUtils, Scheduler}\n+import kafka.zk.KafkaZkClient\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicLong\n+import scala.collection.mutable\n+\n+/**\n+ * @param checkIntervalMs How often to check for ISR\n+ * @param maxDelayMs  Maximum time that an ISR change may be delayed before sending the notification\n+ * @param lingerMs  Maximum time to await additional changes before sending the notification\n+ */\n+case class IsrChangePropagationConfig(checkIntervalMs: Long, maxDelayMs: Long, lingerMs: Long)\n+\n+object ZkIsrManager {\n+  // This field is mutable to allow overriding change notification behavior in test cases\n+  @volatile var DefaultIsrPropagationConfig: IsrChangePropagationConfig = IsrChangePropagationConfig(\n+    checkIntervalMs = 2500,\n+    lingerMs = 5000,\n+    maxDelayMs = 60000,\n+  )\n+}\n+\n+class ZkIsrManager(scheduler: Scheduler, time: Time, zkClient: KafkaZkClient) extends AlterIsrManager with Logging {\n+\n+  private val isrChangeNotificationConfig = ZkIsrManager.DefaultIsrPropagationConfig\n+  // Visible for testing\n+  private[server] val isrChangeSet: mutable.Set[TopicPartition] = new mutable.HashSet[TopicPartition]()\n+  private val lastIsrChangeMs = new AtomicLong(time.milliseconds())\n+  private val lastIsrPropagationMs = new AtomicLong(time.milliseconds())\n+\n+  override def start(): Unit = {\n+    scheduler.schedule(\"isr-change-propagation\", maybePropagateIsrChanges _,\n+      period = isrChangeNotificationConfig.checkIntervalMs, unit = TimeUnit.MILLISECONDS)\n+  }\n+\n+  override def clearPending(topicPartition: TopicPartition): Unit = {\n+    // Since we always immediately process ZK updates and never actually enqueue anything, there is nothing to\n+    // clear here so this is a no-op. Even if there are changes that have not been propagated, the write to ZK\n+    // has already happened, so we may as well send the notification to the controller.\n+  }\n+\n+  override def enqueue(alterIsrItem: AlterIsrItem): Boolean = {\n+    debug(s\"Writing new ISR \" + alterIsrItem.leaderAndIsr.isr + \" to ZooKeeper with version \" +\n+      alterIsrItem.leaderAndIsr.zkVersion + \" for partition \" + alterIsrItem.topicPartition)\n+\n+    val (updateSucceeded, newVersion) = ReplicationUtils.updateLeaderAndIsr(zkClient, alterIsrItem.topicPartition,\n+      alterIsrItem.leaderAndIsr, alterIsrItem.controllerEpoch)\n+\n+    if (updateSucceeded) {\n+      // Track which partitions need to be propagated to the controller\n+      isrChangeSet synchronized {\n+        isrChangeSet += alterIsrItem.topicPartition\n+        lastIsrChangeMs.set(time.milliseconds())\n+      }\n+\n+      // We actually need to apply the callback in another thread since Partition#sendAlterIsrRequest will write", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0NDA4Nw=="}, "originalCommit": {"oid": "ec56bd1fa835e34158c5a6ce70e692dee858c4d2"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNzcwMA==", "bodyText": "One issue is the invalid version case for ZK -- if we return None there then partition will think it's a call to DefaultAlterIsrManager... I guess we could throw from ZkIsrManager if the update fails. WDYT?", "url": "https://github.com/apache/kafka/pull/9713#discussion_r539707700", "createdAt": "2020-12-09T22:51:10Z", "author": {"login": "mumrah"}, "path": "core/src/main/scala/kafka/server/ZkIsrManager.scala", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.utils.{Logging, ReplicationUtils, Scheduler}\n+import kafka.zk.KafkaZkClient\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicLong\n+import scala.collection.mutable\n+\n+/**\n+ * @param checkIntervalMs How often to check for ISR\n+ * @param maxDelayMs  Maximum time that an ISR change may be delayed before sending the notification\n+ * @param lingerMs  Maximum time to await additional changes before sending the notification\n+ */\n+case class IsrChangePropagationConfig(checkIntervalMs: Long, maxDelayMs: Long, lingerMs: Long)\n+\n+object ZkIsrManager {\n+  // This field is mutable to allow overriding change notification behavior in test cases\n+  @volatile var DefaultIsrPropagationConfig: IsrChangePropagationConfig = IsrChangePropagationConfig(\n+    checkIntervalMs = 2500,\n+    lingerMs = 5000,\n+    maxDelayMs = 60000,\n+  )\n+}\n+\n+class ZkIsrManager(scheduler: Scheduler, time: Time, zkClient: KafkaZkClient) extends AlterIsrManager with Logging {\n+\n+  private val isrChangeNotificationConfig = ZkIsrManager.DefaultIsrPropagationConfig\n+  // Visible for testing\n+  private[server] val isrChangeSet: mutable.Set[TopicPartition] = new mutable.HashSet[TopicPartition]()\n+  private val lastIsrChangeMs = new AtomicLong(time.milliseconds())\n+  private val lastIsrPropagationMs = new AtomicLong(time.milliseconds())\n+\n+  override def start(): Unit = {\n+    scheduler.schedule(\"isr-change-propagation\", maybePropagateIsrChanges _,\n+      period = isrChangeNotificationConfig.checkIntervalMs, unit = TimeUnit.MILLISECONDS)\n+  }\n+\n+  override def clearPending(topicPartition: TopicPartition): Unit = {\n+    // Since we always immediately process ZK updates and never actually enqueue anything, there is nothing to\n+    // clear here so this is a no-op. Even if there are changes that have not been propagated, the write to ZK\n+    // has already happened, so we may as well send the notification to the controller.\n+  }\n+\n+  override def enqueue(alterIsrItem: AlterIsrItem): Boolean = {\n+    debug(s\"Writing new ISR \" + alterIsrItem.leaderAndIsr.isr + \" to ZooKeeper with version \" +\n+      alterIsrItem.leaderAndIsr.zkVersion + \" for partition \" + alterIsrItem.topicPartition)\n+\n+    val (updateSucceeded, newVersion) = ReplicationUtils.updateLeaderAndIsr(zkClient, alterIsrItem.topicPartition,\n+      alterIsrItem.leaderAndIsr, alterIsrItem.controllerEpoch)\n+\n+    if (updateSucceeded) {\n+      // Track which partitions need to be propagated to the controller\n+      isrChangeSet synchronized {\n+        isrChangeSet += alterIsrItem.topicPartition\n+        lastIsrChangeMs.set(time.milliseconds())\n+      }\n+\n+      // We actually need to apply the callback in another thread since Partition#sendAlterIsrRequest will write", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0NDA4Nw=="}, "originalCommit": {"oid": "ec56bd1fa835e34158c5a6ce70e692dee858c4d2"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk0NTQ3Mw==", "bodyText": "I went with a slightly different approach. See the latest commits", "url": "https://github.com/apache/kafka/pull/9713#discussion_r540945473", "createdAt": "2020-12-11T13:27:05Z", "author": {"login": "mumrah"}, "path": "core/src/main/scala/kafka/server/ZkIsrManager.scala", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.utils.{Logging, ReplicationUtils, Scheduler}\n+import kafka.zk.KafkaZkClient\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicLong\n+import scala.collection.mutable\n+\n+/**\n+ * @param checkIntervalMs How often to check for ISR\n+ * @param maxDelayMs  Maximum time that an ISR change may be delayed before sending the notification\n+ * @param lingerMs  Maximum time to await additional changes before sending the notification\n+ */\n+case class IsrChangePropagationConfig(checkIntervalMs: Long, maxDelayMs: Long, lingerMs: Long)\n+\n+object ZkIsrManager {\n+  // This field is mutable to allow overriding change notification behavior in test cases\n+  @volatile var DefaultIsrPropagationConfig: IsrChangePropagationConfig = IsrChangePropagationConfig(\n+    checkIntervalMs = 2500,\n+    lingerMs = 5000,\n+    maxDelayMs = 60000,\n+  )\n+}\n+\n+class ZkIsrManager(scheduler: Scheduler, time: Time, zkClient: KafkaZkClient) extends AlterIsrManager with Logging {\n+\n+  private val isrChangeNotificationConfig = ZkIsrManager.DefaultIsrPropagationConfig\n+  // Visible for testing\n+  private[server] val isrChangeSet: mutable.Set[TopicPartition] = new mutable.HashSet[TopicPartition]()\n+  private val lastIsrChangeMs = new AtomicLong(time.milliseconds())\n+  private val lastIsrPropagationMs = new AtomicLong(time.milliseconds())\n+\n+  override def start(): Unit = {\n+    scheduler.schedule(\"isr-change-propagation\", maybePropagateIsrChanges _,\n+      period = isrChangeNotificationConfig.checkIntervalMs, unit = TimeUnit.MILLISECONDS)\n+  }\n+\n+  override def clearPending(topicPartition: TopicPartition): Unit = {\n+    // Since we always immediately process ZK updates and never actually enqueue anything, there is nothing to\n+    // clear here so this is a no-op. Even if there are changes that have not been propagated, the write to ZK\n+    // has already happened, so we may as well send the notification to the controller.\n+  }\n+\n+  override def enqueue(alterIsrItem: AlterIsrItem): Boolean = {\n+    debug(s\"Writing new ISR \" + alterIsrItem.leaderAndIsr.isr + \" to ZooKeeper with version \" +\n+      alterIsrItem.leaderAndIsr.zkVersion + \" for partition \" + alterIsrItem.topicPartition)\n+\n+    val (updateSucceeded, newVersion) = ReplicationUtils.updateLeaderAndIsr(zkClient, alterIsrItem.topicPartition,\n+      alterIsrItem.leaderAndIsr, alterIsrItem.controllerEpoch)\n+\n+    if (updateSucceeded) {\n+      // Track which partitions need to be propagated to the controller\n+      isrChangeSet synchronized {\n+        isrChangeSet += alterIsrItem.topicPartition\n+        lastIsrChangeMs.set(time.milliseconds())\n+      }\n+\n+      // We actually need to apply the callback in another thread since Partition#sendAlterIsrRequest will write", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY0NDA4Nw=="}, "originalCommit": {"oid": "ec56bd1fa835e34158c5a6ce70e692dee858c4d2"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQyMjI0Mzc0OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/cluster/Partition.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQxOTo1NTozM1rOIHWnyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxNzowMDoxMlrOIIrBXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU4MTU3Ng==", "bodyText": "Could we solve the problem by moving this above the call to submit? Then the callback logic should work even if the change is made synchronously. In the case that the request fails to be submitted, then we can reset to the previous state. What do you think?", "url": "https://github.com/apache/kafka/pull/9713#discussion_r544581576", "createdAt": "2020-12-16T19:55:33Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/cluster/Partition.scala", "diffHunk": "@@ -1374,47 +1314,28 @@ class Partition(val topicPartition: TopicPartition,\n     }\n   }\n \n-  private def shrinkIsrWithZk(newIsr: Set[Int]): Unit = {\n-    val newLeaderAndIsr = new LeaderAndIsr(localBrokerId, leaderEpoch, newIsr.toList, zkVersion)\n-    val zkVersionOpt = stateStore.shrinkIsr(controllerEpoch, newLeaderAndIsr)\n-    if (zkVersionOpt.isDefined) {\n-      isrChangeListener.markShrink()\n-    }\n-    maybeUpdateIsrAndVersionWithZk(newIsr, zkVersionOpt)\n-  }\n-\n-  private def maybeUpdateIsrAndVersionWithZk(isr: Set[Int], zkVersionOpt: Option[Int]): Unit = {\n-    zkVersionOpt match {\n-      case Some(newVersion) =>\n-        isrState = CommittedIsr(isr)\n-        zkVersion = newVersion\n-        info(\"ISR updated to [%s] and zkVersion updated to [%d]\".format(isr.mkString(\",\"), zkVersion))\n-\n-      case None =>\n-        info(s\"Cached zkVersion $zkVersion not equal to that in zookeeper, skip updating ISR\")\n-        isrChangeListener.markFailed()\n-    }\n-  }\n-\n   private def sendAlterIsrRequest(proposedIsrState: IsrState): Unit = {\n     val isrToSend: Set[Int] = proposedIsrState match {\n       case PendingExpandIsr(isr, newInSyncReplicaId) => isr + newInSyncReplicaId\n       case PendingShrinkIsr(isr, outOfSyncReplicaIds) => isr -- outOfSyncReplicaIds\n       case state =>\n+        isrChangeListener.markFailed()\n         throw new IllegalStateException(s\"Invalid state $state for `AlterIsr` request for partition $topicPartition\")\n     }\n \n     val newLeaderAndIsr = new LeaderAndIsr(localBrokerId, leaderEpoch, isrToSend.toList, zkVersion)\n-    val alterIsrItem = AlterIsrItem(topicPartition, newLeaderAndIsr, handleAlterIsrResponse(proposedIsrState))\n+    val alterIsrItem = AlterIsrItem(topicPartition, newLeaderAndIsr, handleAlterIsrResponse(proposedIsrState), controllerEpoch)\n \n-    if (!alterIsrManager.enqueue(alterIsrItem)) {\n-      isrChangeListener.markFailed()\n-      throw new IllegalStateException(s\"Failed to enqueue `AlterIsr` request with state \" +\n-        s\"$newLeaderAndIsr for partition $topicPartition\")\n-    }\n-\n-    isrState = proposedIsrState\n-    debug(s\"Sent `AlterIsr` request to change state to $newLeaderAndIsr after transition to $proposedIsrState\")\n+    alterIsrManager.submit(alterIsrItem, (wasSubmitted: Boolean) => {\n+      if (wasSubmitted) {\n+        isrState = proposedIsrState", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e76df120641830364cdf6cfca9376bc4662e3b31"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk2NDM4Mg==", "bodyText": "Yea, this seems simpler than the callback thing. I've made this change in the latest commit", "url": "https://github.com/apache/kafka/pull/9713#discussion_r545964382", "createdAt": "2020-12-18T17:00:12Z", "author": {"login": "mumrah"}, "path": "core/src/main/scala/kafka/cluster/Partition.scala", "diffHunk": "@@ -1374,47 +1314,28 @@ class Partition(val topicPartition: TopicPartition,\n     }\n   }\n \n-  private def shrinkIsrWithZk(newIsr: Set[Int]): Unit = {\n-    val newLeaderAndIsr = new LeaderAndIsr(localBrokerId, leaderEpoch, newIsr.toList, zkVersion)\n-    val zkVersionOpt = stateStore.shrinkIsr(controllerEpoch, newLeaderAndIsr)\n-    if (zkVersionOpt.isDefined) {\n-      isrChangeListener.markShrink()\n-    }\n-    maybeUpdateIsrAndVersionWithZk(newIsr, zkVersionOpt)\n-  }\n-\n-  private def maybeUpdateIsrAndVersionWithZk(isr: Set[Int], zkVersionOpt: Option[Int]): Unit = {\n-    zkVersionOpt match {\n-      case Some(newVersion) =>\n-        isrState = CommittedIsr(isr)\n-        zkVersion = newVersion\n-        info(\"ISR updated to [%s] and zkVersion updated to [%d]\".format(isr.mkString(\",\"), zkVersion))\n-\n-      case None =>\n-        info(s\"Cached zkVersion $zkVersion not equal to that in zookeeper, skip updating ISR\")\n-        isrChangeListener.markFailed()\n-    }\n-  }\n-\n   private def sendAlterIsrRequest(proposedIsrState: IsrState): Unit = {\n     val isrToSend: Set[Int] = proposedIsrState match {\n       case PendingExpandIsr(isr, newInSyncReplicaId) => isr + newInSyncReplicaId\n       case PendingShrinkIsr(isr, outOfSyncReplicaIds) => isr -- outOfSyncReplicaIds\n       case state =>\n+        isrChangeListener.markFailed()\n         throw new IllegalStateException(s\"Invalid state $state for `AlterIsr` request for partition $topicPartition\")\n     }\n \n     val newLeaderAndIsr = new LeaderAndIsr(localBrokerId, leaderEpoch, isrToSend.toList, zkVersion)\n-    val alterIsrItem = AlterIsrItem(topicPartition, newLeaderAndIsr, handleAlterIsrResponse(proposedIsrState))\n+    val alterIsrItem = AlterIsrItem(topicPartition, newLeaderAndIsr, handleAlterIsrResponse(proposedIsrState), controllerEpoch)\n \n-    if (!alterIsrManager.enqueue(alterIsrItem)) {\n-      isrChangeListener.markFailed()\n-      throw new IllegalStateException(s\"Failed to enqueue `AlterIsr` request with state \" +\n-        s\"$newLeaderAndIsr for partition $topicPartition\")\n-    }\n-\n-    isrState = proposedIsrState\n-    debug(s\"Sent `AlterIsr` request to change state to $newLeaderAndIsr after transition to $proposedIsrState\")\n+    alterIsrManager.submit(alterIsrItem, (wasSubmitted: Boolean) => {\n+      if (wasSubmitted) {\n+        isrState = proposedIsrState", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU4MTU3Ng=="}, "originalCommit": {"oid": "e76df120641830364cdf6cfca9376bc4662e3b31"}, "originalPosition": 207}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjE3MzMxOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/cluster/Partition.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOToyMzoxNFrOIIv7uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOToyMzoxNFrOIIv7uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA0NDg1Nw==", "bodyText": "Should we generalize this log message as well? Also the couple IllegalStateException messages above.", "url": "https://github.com/apache/kafka/pull/9713#discussion_r546044857", "createdAt": "2020-12-18T19:23:14Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/cluster/Partition.scala", "diffHunk": "@@ -1374,46 +1314,29 @@ class Partition(val topicPartition: TopicPartition,\n     }\n   }\n \n-  private def shrinkIsrWithZk(newIsr: Set[Int]): Unit = {\n-    val newLeaderAndIsr = new LeaderAndIsr(localBrokerId, leaderEpoch, newIsr.toList, zkVersion)\n-    val zkVersionOpt = stateStore.shrinkIsr(controllerEpoch, newLeaderAndIsr)\n-    if (zkVersionOpt.isDefined) {\n-      isrChangeListener.markShrink()\n-    }\n-    maybeUpdateIsrAndVersionWithZk(newIsr, zkVersionOpt)\n-  }\n-\n-  private def maybeUpdateIsrAndVersionWithZk(isr: Set[Int], zkVersionOpt: Option[Int]): Unit = {\n-    zkVersionOpt match {\n-      case Some(newVersion) =>\n-        isrState = CommittedIsr(isr)\n-        zkVersion = newVersion\n-        info(\"ISR updated to [%s] and zkVersion updated to [%d]\".format(isr.mkString(\",\"), zkVersion))\n-\n-      case None =>\n-        info(s\"Cached zkVersion $zkVersion not equal to that in zookeeper, skip updating ISR\")\n-        isrChangeListener.markFailed()\n-    }\n-  }\n-\n   private def sendAlterIsrRequest(proposedIsrState: IsrState): Unit = {\n     val isrToSend: Set[Int] = proposedIsrState match {\n       case PendingExpandIsr(isr, newInSyncReplicaId) => isr + newInSyncReplicaId\n       case PendingShrinkIsr(isr, outOfSyncReplicaIds) => isr -- outOfSyncReplicaIds\n       case state =>\n+        isrChangeListener.markFailed()\n         throw new IllegalStateException(s\"Invalid state $state for `AlterIsr` request for partition $topicPartition\")\n     }\n \n     val newLeaderAndIsr = new LeaderAndIsr(localBrokerId, leaderEpoch, isrToSend.toList, zkVersion)\n-    val alterIsrItem = AlterIsrItem(topicPartition, newLeaderAndIsr, handleAlterIsrResponse(proposedIsrState))\n+    val alterIsrItem = AlterIsrItem(topicPartition, newLeaderAndIsr, handleAlterIsrResponse(proposedIsrState), controllerEpoch)\n \n-    if (!alterIsrManager.enqueue(alterIsrItem)) {\n+    val oldState = isrState\n+    isrState = proposedIsrState\n+\n+    if (!alterIsrManager.submit(alterIsrItem)) {\n+      // If the ISR manager did not accept our update, we need to revert back to previous state\n+      isrState = oldState\n       isrChangeListener.markFailed()\n       throw new IllegalStateException(s\"Failed to enqueue `AlterIsr` request with state \" +\n         s\"$newLeaderAndIsr for partition $topicPartition\")\n     }\n \n-    isrState = proposedIsrState\n     debug(s\"Sent `AlterIsr` request to change state to $newLeaderAndIsr after transition to $proposedIsrState\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8016d4e1323d11385a2c4232ffcc376e392cba95"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMjIzNjExOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/ZkIsrManager.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOTo0MjoyNVrOIIwhzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQxOTo0MjoyNVrOIIwhzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA1NDYwNQ==", "bodyText": "nit: rewrite using $ substitutions?", "url": "https://github.com/apache/kafka/pull/9713#discussion_r546054605", "createdAt": "2020-12-18T19:42:25Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/ZkIsrManager.scala", "diffHunk": "@@ -0,0 +1,109 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.server\n+\n+import kafka.utils.{Logging, ReplicationUtils, Scheduler}\n+import kafka.zk.KafkaZkClient\n+import org.apache.kafka.common.TopicPartition\n+import org.apache.kafka.common.protocol.Errors\n+import org.apache.kafka.common.utils.Time\n+\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.atomic.AtomicLong\n+import scala.collection.mutable\n+\n+/**\n+ * @param checkIntervalMs How often to check for ISR\n+ * @param maxDelayMs  Maximum time that an ISR change may be delayed before sending the notification\n+ * @param lingerMs  Maximum time to await additional changes before sending the notification\n+ */\n+case class IsrChangePropagationConfig(checkIntervalMs: Long, maxDelayMs: Long, lingerMs: Long)\n+\n+object ZkIsrManager {\n+  // This field is mutable to allow overriding change notification behavior in test cases\n+  @volatile var DefaultIsrPropagationConfig: IsrChangePropagationConfig = IsrChangePropagationConfig(\n+    checkIntervalMs = 2500,\n+    lingerMs = 5000,\n+    maxDelayMs = 60000,\n+  )\n+}\n+\n+class ZkIsrManager(scheduler: Scheduler, time: Time, zkClient: KafkaZkClient) extends AlterIsrManager with Logging {\n+\n+  private val isrChangeNotificationConfig = ZkIsrManager.DefaultIsrPropagationConfig\n+  // Visible for testing\n+  private[server] val isrChangeSet: mutable.Set[TopicPartition] = new mutable.HashSet[TopicPartition]()\n+  private val lastIsrChangeMs = new AtomicLong(time.milliseconds())\n+  private val lastIsrPropagationMs = new AtomicLong(time.milliseconds())\n+\n+  override def start(): Unit = {\n+    scheduler.schedule(\"isr-change-propagation\", maybePropagateIsrChanges _,\n+      period = isrChangeNotificationConfig.checkIntervalMs, unit = TimeUnit.MILLISECONDS)\n+  }\n+\n+  override def clearPending(topicPartition: TopicPartition): Unit = {\n+    // Since we always immediately process ZK updates and never actually enqueue anything, there is nothing to\n+    // clear here so this is a no-op. Even if there are changes that have not been propagated, the write to ZK\n+    // has already happened, so we may as well send the notification to the controller.\n+  }\n+\n+  override def submit(alterIsrItem: AlterIsrItem): Boolean = {\n+    debug(s\"Writing new ISR \" + alterIsrItem.leaderAndIsr.isr + \" to ZooKeeper with version \" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8016d4e1323d11385a2c4232ffcc376e392cba95"}, "originalPosition": 65}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3713, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}