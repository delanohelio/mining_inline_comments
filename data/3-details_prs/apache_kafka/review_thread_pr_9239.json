{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3MTkyMjY3", "number": 9239, "reviewThreads": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMTowMjowMlrOEfIkoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNTowOTowNVrOEilS_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxMDgxNzYwOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMTowMjowM1rOHLNiKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMTowMjowM1rOHLNiKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxODEyMQ==", "bodyText": "I'm not sure I understand the usage of backwardsIterator here. Do we ever set it to anything?\nI think you're overcomplicating this \ud83d\ude42  All you need to do is call windowStore.backwardsFetch(...) and if the underlying store doesn't support it, then it will throw UnsupportedOperationException. You don't need to use reflection/getMethod . Also, if we're ever in a position of catching SecurityException, something has probably gone wrong\nOriginally I was thinking we should do this in init so we don't have to figure out if it's a reverse store every time a new record gets processed. But I just realized that all of the SessionStore fetch methods require a key, so we have to do this in process (since we don't have a key to pass in during init, and null keys aren't allowed). We can at least just do it once in the first process, and then keep track of whether we should use forwards or reverse iteration in subsequent ones\n\nGiven the above (especially 3), there's no perfect solution, but one thing we can do is just keep a reverseIterationPossible boolean. If it's false we call processInOrder, if it's true we call processReverse. We also put a catch UnsupportedOperationException around the processReverse call, so if it does throw on the first invocation of process then we can call processInOrder and also set reverseIterationPossible to false so that we never call processReverse again. Does that make sense?", "url": "https://github.com/apache/kafka/pull/9239#discussion_r481518121", "createdAt": "2020-09-02T01:02:03Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -118,24 +121,28 @@ public void process(final K key, final V value) {\n             }\n \n             final long timestamp = context().timestamp();\n-            //don't process records that don't fall within a full sliding window\n-            if (timestamp < windows.timeDifferenceMs()) {\n-                log.warn(\n-                    \"Skipping record due to early arrival. value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n-                    value, context().topic(), context().partition(), context().offset()\n-                );\n-                droppedRecordsSensor.record();\n-                return;\n+            Method backwardsIterator = null;\n+\n+            try {\n+                windowStore.getClass().getMethod(\"backwardFetch\", new Class[] { Object.class, Object.class, Instant.class, Instant.class });\n+            } catch (NoSuchMethodException | SecurityException e)  { }\n+            if (backwardsIterator != null) {\n+                processReverse(key, value, timestamp);\n+            } else {\n+                processInOrder(key, value, timestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "527ddce5831408b31bac099c849874899289e8b7"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjM0MjYzOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDozNTowMlrOHMFCSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDozNjoyM1rOHMFJDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQyNzQ2Ng==", "bodyText": "We should log a debug message indicating which we decide to use", "url": "https://github.com/apache/kafka/pull/9239#discussion_r482427466", "createdAt": "2020-09-02T20:35:02Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -118,24 +120,56 @@ public void process(final K key, final V value) {\n             }\n \n             final long timestamp = context().timestamp();\n-            //don't process records that don't fall within a full sliding window\n-            if (timestamp < windows.timeDifferenceMs()) {\n+            observedStreamTime = Math.max(observedStreamTime, timestamp);\n+            final long closeTime = observedStreamTime - windows.gracePeriodMs();\n+\n+            if (timestamp + 1 + windows.timeDifferenceMs() <= closeTime) {\n                 log.warn(\n-                    \"Skipping record due to early arrival. value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n-                    value, context().topic(), context().partition(), context().offset()\n+                    \"Skipping record for expired window. \" +\n+                        \"key=[{}] \" +\n+                        \"topic=[{}] \" +\n+                        \"partition=[{}] \" +\n+                        \"offset=[{}] \" +\n+                        \"timestamp=[{}] \" +\n+                        \"window=[{},{}] \" +\n+                        \"expiration=[{}] \" +\n+                        \"streamTime=[{}]\",\n+                    key,\n+                    context().topic(),\n+                    context().partition(),\n+                    context().offset(),\n+                    context().timestamp(),\n+                    timestamp - windows.timeDifferenceMs(), timestamp,\n+                    closeTime,\n+                    observedStreamTime\n                 );\n-                droppedRecordsSensor.record();\n+                lateRecordDropSensor.record();\n                 return;\n             }\n-            processInOrder(key, value, timestamp);\n-        }\n \n-        public void processInOrder(final K key, final V value, final long timestamp) {\n+            if (timestamp < windows.timeDifferenceMs()) {\n+                processEarly(key, value, timestamp, closeTime);\n+                return;\n+            }\n \n-            observedStreamTime = Math.max(observedStreamTime, timestamp);\n-            final long closeTime = observedStreamTime - windows.gracePeriodMs();\n+            if (reverseIteratorPossible == null) {\n+                try {\n+                    windowStore.backwardFetch(key, 0L, 0L);\n+                    reverseIteratorPossible = true;\n+                } catch (final UnsupportedOperationException e)  {\n+                    reverseIteratorPossible = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ef2f3030006972660ea5d1d39b0ee1f9bf0b46f"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQyOTE5OA==", "bodyText": "Also we can then use the log message to verify that the correct process method gets chosen", "url": "https://github.com/apache/kafka/pull/9239#discussion_r482429198", "createdAt": "2020-09-02T20:36:23Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -118,24 +120,56 @@ public void process(final K key, final V value) {\n             }\n \n             final long timestamp = context().timestamp();\n-            //don't process records that don't fall within a full sliding window\n-            if (timestamp < windows.timeDifferenceMs()) {\n+            observedStreamTime = Math.max(observedStreamTime, timestamp);\n+            final long closeTime = observedStreamTime - windows.gracePeriodMs();\n+\n+            if (timestamp + 1 + windows.timeDifferenceMs() <= closeTime) {\n                 log.warn(\n-                    \"Skipping record due to early arrival. value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n-                    value, context().topic(), context().partition(), context().offset()\n+                    \"Skipping record for expired window. \" +\n+                        \"key=[{}] \" +\n+                        \"topic=[{}] \" +\n+                        \"partition=[{}] \" +\n+                        \"offset=[{}] \" +\n+                        \"timestamp=[{}] \" +\n+                        \"window=[{},{}] \" +\n+                        \"expiration=[{}] \" +\n+                        \"streamTime=[{}]\",\n+                    key,\n+                    context().topic(),\n+                    context().partition(),\n+                    context().offset(),\n+                    context().timestamp(),\n+                    timestamp - windows.timeDifferenceMs(), timestamp,\n+                    closeTime,\n+                    observedStreamTime\n                 );\n-                droppedRecordsSensor.record();\n+                lateRecordDropSensor.record();\n                 return;\n             }\n-            processInOrder(key, value, timestamp);\n-        }\n \n-        public void processInOrder(final K key, final V value, final long timestamp) {\n+            if (timestamp < windows.timeDifferenceMs()) {\n+                processEarly(key, value, timestamp, closeTime);\n+                return;\n+            }\n \n-            observedStreamTime = Math.max(observedStreamTime, timestamp);\n-            final long closeTime = observedStreamTime - windows.gracePeriodMs();\n+            if (reverseIteratorPossible == null) {\n+                try {\n+                    windowStore.backwardFetch(key, 0L, 0L);\n+                    reverseIteratorPossible = true;\n+                } catch (final UnsupportedOperationException e)  {\n+                    reverseIteratorPossible = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQyNzQ2Ng=="}, "originalCommit": {"oid": "8ef2f3030006972660ea5d1d39b0ee1f9bf0b46f"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjM2ODAzOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDozODozMFrOHMFUIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMTowNDozOFrOHOy8YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQzMjAzNQ==", "bodyText": "Is everything after this point the same for both processInOrder and processReverse? The only difference between the two is in the iterator loop, right? If so, we should try to reduce duplicate code and only invoke a difference in-order vs reverse method for the loop", "url": "https://github.com/apache/kafka/pull/9239#discussion_r482432035", "createdAt": "2020-09-02T20:38:30Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -180,41 +217,225 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                    createPreviousRightWindow(previousRightWinStart, timestamp, key, value, closeTime);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n-                final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n-                } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                createCurrentRecordLeftWindow(previousRecordTimestamp, timestamp, leftWinAgg, key, value, closeTime);\n+            }\n+            // create right window for new record, if necessary\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        public void processReverse(final K key, final V value, final long timestamp, final long closeTime) {\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.backwardFetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                //if we've already seen the window with the closest start time to the record\n+                boolean foundRightWinAgg = false;\n+\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (endTime > timestamp) {\n+                        if (!foundRightWinAgg) {\n+                            foundRightWinAgg = true;\n+                            rightWinAgg = next.value;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime == timestamp) {\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                        leftWinAlreadyCreated = true;\n+                    } else if (endTime < timestamp) {\n+                        leftWinAgg = next.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        break;\n+                    } else {\n+                        //determine if current record's right window exists, will only be true at most once, on the first pass\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            //create right window for previous record", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ef2f3030006972660ea5d1d39b0ee1f9bf0b46f"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE0Nzg1Mg==", "bodyText": "Okay I tried to reduce duplicate code, it led to some methods with long variable lists because of not being able to pass by reference. Maybe I'm missing some way to make it cleaner so let me know if it can be improved", "url": "https://github.com/apache/kafka/pull/9239#discussion_r483147852", "createdAt": "2020-09-03T17:39:22Z", "author": {"login": "lct45"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -180,41 +217,225 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                    createPreviousRightWindow(previousRightWinStart, timestamp, key, value, closeTime);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n-                final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n-                } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                createCurrentRecordLeftWindow(previousRecordTimestamp, timestamp, leftWinAgg, key, value, closeTime);\n+            }\n+            // create right window for new record, if necessary\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        public void processReverse(final K key, final V value, final long timestamp, final long closeTime) {\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.backwardFetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                //if we've already seen the window with the closest start time to the record\n+                boolean foundRightWinAgg = false;\n+\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (endTime > timestamp) {\n+                        if (!foundRightWinAgg) {\n+                            foundRightWinAgg = true;\n+                            rightWinAgg = next.value;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime == timestamp) {\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                        leftWinAlreadyCreated = true;\n+                    } else if (endTime < timestamp) {\n+                        leftWinAgg = next.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        break;\n+                    } else {\n+                        //determine if current record's right window exists, will only be true at most once, on the first pass\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            //create right window for previous record", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQzMjAzNQ=="}, "originalCommit": {"oid": "8ef2f3030006972660ea5d1d39b0ee1f9bf0b46f"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3Njc2OQ==", "bodyText": "Yeah, that's definitely a pretty long list of input parameters. I don't think that's necessarily a problem, but if you feel it's cleaner to just inline the window creation, then go for it.\nDuplicate code is not the end of the world. The only risk is that we might need to change the window creation logic and only do it in one place but not the other, but that's probably a low risk here. So just make a call \ud83d\ude42", "url": "https://github.com/apache/kafka/pull/9239#discussion_r485276769", "createdAt": "2020-09-09T01:04:38Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -180,41 +217,225 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                    createPreviousRightWindow(previousRightWinStart, timestamp, key, value, closeTime);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n-                final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n-                } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                createCurrentRecordLeftWindow(previousRecordTimestamp, timestamp, leftWinAgg, key, value, closeTime);\n+            }\n+            // create right window for new record, if necessary\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        public void processReverse(final K key, final V value, final long timestamp, final long closeTime) {\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.backwardFetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                //if we've already seen the window with the closest start time to the record\n+                boolean foundRightWinAgg = false;\n+\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (endTime > timestamp) {\n+                        if (!foundRightWinAgg) {\n+                            foundRightWinAgg = true;\n+                            rightWinAgg = next.value;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime == timestamp) {\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                        leftWinAlreadyCreated = true;\n+                    } else if (endTime < timestamp) {\n+                        leftWinAgg = next.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        break;\n+                    } else {\n+                        //determine if current record's right window exists, will only be true at most once, on the first pass\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            //create right window for previous record", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQzMjAzNQ=="}, "originalCommit": {"oid": "8ef2f3030006972660ea5d1d39b0ee1f9bf0b46f"}, "originalPosition": 209}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjM4NzEyOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDo0MDo1M1rOHMFhJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDo0MDo1M1rOHMFhJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQzNTM2Nw==", "bodyText": "Instead of the extra foundRightWinAgg  boolean, can we just check if rightWinAgg is still equal to null?", "url": "https://github.com/apache/kafka/pull/9239#discussion_r482435367", "createdAt": "2020-09-02T20:40:53Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -180,41 +217,225 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                    createPreviousRightWindow(previousRightWinStart, timestamp, key, value, closeTime);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n-                final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n-                } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                createCurrentRecordLeftWindow(previousRecordTimestamp, timestamp, leftWinAgg, key, value, closeTime);\n+            }\n+            // create right window for new record, if necessary\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        public void processReverse(final K key, final V value, final long timestamp, final long closeTime) {\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.backwardFetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                //if we've already seen the window with the closest start time to the record\n+                boolean foundRightWinAgg = false;\n+\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (endTime > timestamp) {\n+                        if (!foundRightWinAgg) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ef2f3030006972660ea5d1d39b0ee1f9bf0b46f"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjQwODc1OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDo0MzozNlrOHMFvwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDo1MToxNVrOHMGY2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQzOTEwNA==", "bodyText": "Instead of asserting that this will be true at most once in the comment, we should do so in the code by checking else if startTime == timestamp + 1 instead of just falling back to else. Tbh we should probably do the same for the processInOrder case and not make any assumptions (you can add an else case that throws IllegalStateException then, since every possible case should be covered by one of the above conditions)", "url": "https://github.com/apache/kafka/pull/9239#discussion_r482439104", "createdAt": "2020-09-02T20:43:36Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -180,41 +217,225 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                    createPreviousRightWindow(previousRightWinStart, timestamp, key, value, closeTime);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n-                final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n-                } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                createCurrentRecordLeftWindow(previousRecordTimestamp, timestamp, leftWinAgg, key, value, closeTime);\n+            }\n+            // create right window for new record, if necessary\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        public void processReverse(final K key, final V value, final long timestamp, final long closeTime) {\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.backwardFetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                //if we've already seen the window with the closest start time to the record\n+                boolean foundRightWinAgg = false;\n+\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (endTime > timestamp) {\n+                        if (!foundRightWinAgg) {\n+                            foundRightWinAgg = true;\n+                            rightWinAgg = next.value;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime == timestamp) {\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                        leftWinAlreadyCreated = true;\n+                    } else if (endTime < timestamp) {\n+                        leftWinAgg = next.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        break;\n+                    } else {\n+                        //determine if current record's right window exists, will only be true at most once, on the first pass\n+                        rightWinAlreadyCreated = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ef2f3030006972660ea5d1d39b0ee1f9bf0b46f"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ0OTYyNQ==", "bodyText": "I think it's also easiest to follow if we keep the conditions in the order that we will actually see them. So this case would be the first one (everything else is in order I think)", "url": "https://github.com/apache/kafka/pull/9239#discussion_r482449625", "createdAt": "2020-09-02T20:51:15Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -180,41 +217,225 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                    createPreviousRightWindow(previousRightWinStart, timestamp, key, value, closeTime);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n-                final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n-                } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                createCurrentRecordLeftWindow(previousRecordTimestamp, timestamp, leftWinAgg, key, value, closeTime);\n+            }\n+            // create right window for new record, if necessary\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        public void processReverse(final K key, final V value, final long timestamp, final long closeTime) {\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.backwardFetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                //if we've already seen the window with the closest start time to the record\n+                boolean foundRightWinAgg = false;\n+\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (endTime > timestamp) {\n+                        if (!foundRightWinAgg) {\n+                            foundRightWinAgg = true;\n+                            rightWinAgg = next.value;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime == timestamp) {\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                        leftWinAlreadyCreated = true;\n+                    } else if (endTime < timestamp) {\n+                        leftWinAgg = next.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        break;\n+                    } else {\n+                        //determine if current record's right window exists, will only be true at most once, on the first pass\n+                        rightWinAlreadyCreated = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQzOTEwNA=="}, "originalCommit": {"oid": "8ef2f3030006972660ea5d1d39b0ee1f9bf0b46f"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjQ2MDMzOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDo1MDoxOFrOHMGTdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMzo0ODozOFrOHM681g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ0ODI0Ng==", "bodyText": "Since this is the current record's left window, either this condition or true or we already had a record with the same timestamp as the current record. Just throwing out a suggestion, maybe we could keep a boolean that tracks whether we already have a record at the current timestamp and if so we can actaully skip everything after the loop", "url": "https://github.com/apache/kafka/pull/9239#discussion_r482448246", "createdAt": "2020-09-02T20:50:18Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -180,41 +217,225 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                    createPreviousRightWindow(previousRightWinStart, timestamp, key, value, closeTime);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n-                final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n-                } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                createCurrentRecordLeftWindow(previousRecordTimestamp, timestamp, leftWinAgg, key, value, closeTime);\n+            }\n+            // create right window for new record, if necessary\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        public void processReverse(final K key, final V value, final long timestamp, final long closeTime) {\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.backwardFetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                //if we've already seen the window with the closest start time to the record\n+                boolean foundRightWinAgg = false;\n+\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (endTime > timestamp) {\n+                        if (!foundRightWinAgg) {\n+                            foundRightWinAgg = true;\n+                            rightWinAgg = next.value;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime == timestamp) {\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ef2f3030006972660ea5d1d39b0ee1f9bf0b46f"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzEyOTcxNQ==", "bodyText": "Do we need a boolean? Or could we just return? If there's a record at the current record's timestamp, all we need to do is update the windows it falls within, and as we go back in time the earliest window it'll fall within is it's left window, so if we find the left window and the left window was created by a record at the same timestamp, we can just return after updating that window, right?", "url": "https://github.com/apache/kafka/pull/9239#discussion_r483129715", "createdAt": "2020-09-03T17:06:14Z", "author": {"login": "lct45"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -180,41 +217,225 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                    createPreviousRightWindow(previousRightWinStart, timestamp, key, value, closeTime);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n-                final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n-                } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                createCurrentRecordLeftWindow(previousRecordTimestamp, timestamp, leftWinAgg, key, value, closeTime);\n+            }\n+            // create right window for new record, if necessary\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        public void processReverse(final K key, final V value, final long timestamp, final long closeTime) {\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.backwardFetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                //if we've already seen the window with the closest start time to the record\n+                boolean foundRightWinAgg = false;\n+\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (endTime > timestamp) {\n+                        if (!foundRightWinAgg) {\n+                            foundRightWinAgg = true;\n+                            rightWinAgg = next.value;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime == timestamp) {\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ0ODI0Ng=="}, "originalCommit": {"oid": "8ef2f3030006972660ea5d1d39b0ee1f9bf0b46f"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMxMDgwNg==", "bodyText": "Hm, yeah, that makes sense to me. Nice! I guess if we wanted to do something similar for the forward and early case, we would have to store a boolean. Not sure if it's worth it or not, your call", "url": "https://github.com/apache/kafka/pull/9239#discussion_r483310806", "createdAt": "2020-09-03T23:48:38Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -180,41 +217,225 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                    createPreviousRightWindow(previousRightWinStart, timestamp, key, value, closeTime);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n-                final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n-                } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                createCurrentRecordLeftWindow(previousRecordTimestamp, timestamp, leftWinAgg, key, value, closeTime);\n+            }\n+            // create right window for new record, if necessary\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        public void processReverse(final K key, final V value, final long timestamp, final long closeTime) {\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.backwardFetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                //if we've already seen the window with the closest start time to the record\n+                boolean foundRightWinAgg = false;\n+\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (endTime > timestamp) {\n+                        if (!foundRightWinAgg) {\n+                            foundRightWinAgg = true;\n+                            rightWinAgg = next.value;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime == timestamp) {\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ0ODI0Ng=="}, "originalCommit": {"oid": "8ef2f3030006972660ea5d1d39b0ee1f9bf0b46f"}, "originalPosition": 195}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjQ5NzU4OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDo1NDoyOVrOHMGrcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDo1NDoyOVrOHMGrcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ1NDM4NA==", "bodyText": "Math.max(rightWinAgg.timestamp(), timestamp) doesn't make sense for this case, since we're not actually putting the current record in the window (although technically it will still choose the correct timestamp, for that reason).\nBut I think this might just be out of date and need to be rebased after the changes in the early records PR?", "url": "https://github.com/apache/kafka/pull/9239#discussion_r482454384", "createdAt": "2020-09-02T20:54:29Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -180,41 +217,225 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                    createPreviousRightWindow(previousRightWinStart, timestamp, key, value, closeTime);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n-                final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n-                } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                createCurrentRecordLeftWindow(previousRecordTimestamp, timestamp, leftWinAgg, key, value, closeTime);\n+            }\n+            // create right window for new record, if necessary\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        public void processReverse(final K key, final V value, final long timestamp, final long closeTime) {\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.backwardFetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                //if we've already seen the window with the closest start time to the record\n+                boolean foundRightWinAgg = false;\n+\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (endTime > timestamp) {\n+                        if (!foundRightWinAgg) {\n+                            foundRightWinAgg = true;\n+                            rightWinAgg = next.value;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime == timestamp) {\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                        leftWinAlreadyCreated = true;\n+                    } else if (endTime < timestamp) {\n+                        leftWinAgg = next.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        break;\n+                    } else {\n+                        //determine if current record's right window exists, will only be true at most once, on the first pass\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            //create right window for previous record\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                    createPreviousRightWindow(previousRightWinStart, timestamp, key, value, closeTime);\n+                }\n+            }\n+\n+            //create the left window of the current record if it's not created\n+            if (!leftWinAlreadyCreated) {\n+                createCurrentRecordLeftWindow(previousRecordTimestamp, timestamp, leftWinAgg, key, value, closeTime);\n+            }\n+            //create the right window for the current record, if need be\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n                 }\n-                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                createPreviousRightWindow(previousRecordTimestamp + 1, timestamp, key, value, closeTime);\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n             }\n+\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(rightWinAgg.value(), Math.max(rightWinAgg.timestamp(), timestamp));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ef2f3030006972660ea5d1d39b0ee1f9bf0b46f"}, "originalPosition": 313}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjUwMzA2OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDo1NToxNVrOHMGvgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDo1NToxNVrOHMGvgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ1NTQyNw==", "bodyText": "nit: name it createPreviousRecordRightWindow for consistency/clarity", "url": "https://github.com/apache/kafka/pull/9239#discussion_r482455427", "createdAt": "2020-09-02T20:55:15Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -180,41 +217,225 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                    createPreviousRightWindow(previousRightWinStart, timestamp, key, value, closeTime);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n-                final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n-                } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                createCurrentRecordLeftWindow(previousRecordTimestamp, timestamp, leftWinAgg, key, value, closeTime);\n+            }\n+            // create right window for new record, if necessary\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        public void processReverse(final K key, final V value, final long timestamp, final long closeTime) {\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.backwardFetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                //if we've already seen the window with the closest start time to the record\n+                boolean foundRightWinAgg = false;\n+\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (endTime > timestamp) {\n+                        if (!foundRightWinAgg) {\n+                            foundRightWinAgg = true;\n+                            rightWinAgg = next.value;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime == timestamp) {\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                        leftWinAlreadyCreated = true;\n+                    } else if (endTime < timestamp) {\n+                        leftWinAgg = next.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        break;\n+                    } else {\n+                        //determine if current record's right window exists, will only be true at most once, on the first pass\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            //create right window for previous record\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                    createPreviousRightWindow(previousRightWinStart, timestamp, key, value, closeTime);\n+                }\n+            }\n+\n+            //create the left window of the current record if it's not created\n+            if (!leftWinAlreadyCreated) {\n+                createCurrentRecordLeftWindow(previousRecordTimestamp, timestamp, leftWinAgg, key, value, closeTime);\n+            }\n+            //create the right window for the current record, if need be\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n                 }\n-                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                createPreviousRightWindow(previousRecordTimestamp + 1, timestamp, key, value, closeTime);\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n             }\n+\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(rightWinAgg.value(), Math.max(rightWinAgg.timestamp(), timestamp));\n+            windowStore.put(\n+                key,\n+                valueAndTime,\n+                window.start());\n+            tupleForwarder.maybeForward(\n+                new Windowed<>(key, window),\n+                rightWinAgg.value(),\n+                null,\n+                rightWinAgg.timestamp());        }\n+\n+        private void createPreviousRightWindow(final long windowStart,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ef2f3030006972660ea5d1d39b0ee1f9bf0b46f"}, "originalPosition": 324}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjUyMTg4OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDo1Nzo1NVrOHMG9IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMDo1Nzo1NVrOHMG9IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ1ODkxMg==", "bodyText": "We might as well move the previousRecordTimestamp null check into leftWindowNotEmpty. Also you can probably remove the comment then since it's saying basically the same thing as if leftWindowNotEmpty", "url": "https://github.com/apache/kafka/pull/9239#discussion_r482458912", "createdAt": "2020-09-02T20:57:55Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -180,41 +217,225 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                    createPreviousRightWindow(previousRightWinStart, timestamp, key, value, closeTime);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n-                final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n-                } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                createCurrentRecordLeftWindow(previousRecordTimestamp, timestamp, leftWinAgg, key, value, closeTime);\n+            }\n+            // create right window for new record, if necessary\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        public void processReverse(final K key, final V value, final long timestamp, final long closeTime) {\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.backwardFetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                //if we've already seen the window with the closest start time to the record\n+                boolean foundRightWinAgg = false;\n+\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (endTime > timestamp) {\n+                        if (!foundRightWinAgg) {\n+                            foundRightWinAgg = true;\n+                            rightWinAgg = next.value;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime == timestamp) {\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                        leftWinAlreadyCreated = true;\n+                    } else if (endTime < timestamp) {\n+                        leftWinAgg = next.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        break;\n+                    } else {\n+                        //determine if current record's right window exists, will only be true at most once, on the first pass\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            //create right window for previous record\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                    createPreviousRightWindow(previousRightWinStart, timestamp, key, value, closeTime);\n+                }\n+            }\n+\n+            //create the left window of the current record if it's not created\n+            if (!leftWinAlreadyCreated) {\n+                createCurrentRecordLeftWindow(previousRecordTimestamp, timestamp, leftWinAgg, key, value, closeTime);\n+            }\n+            //create the right window for the current record, if need be\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n                 }\n-                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                createPreviousRightWindow(previousRecordTimestamp + 1, timestamp, key, value, closeTime);\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n             }\n+\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(rightWinAgg.value(), Math.max(rightWinAgg.timestamp(), timestamp));\n+            windowStore.put(\n+                key,\n+                valueAndTime,\n+                window.start());\n+            tupleForwarder.maybeForward(\n+                new Windowed<>(key, window),\n+                rightWinAgg.value(),\n+                null,\n+                rightWinAgg.timestamp());        }\n+\n+        private void createPreviousRightWindow(final long windowStart,\n+                                               final long currentRecordTimestamp,\n+                                               final K key,\n+                                               final V value,\n+                                               final long closeTime) {\n+            final TimeWindow window = new TimeWindow(windowStart, windowStart + windows.timeDifferenceMs());\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), currentRecordTimestamp);\n+            putAndForward(window, valueAndTime, key, value, closeTime, currentRecordTimestamp);\n+        }\n+\n+        private void createCurrentRecordLeftWindow(final Long previousRecordTimestamp,\n+                                               final long timestamp,\n+                                               final ValueAndTimestamp<Agg> leftWinAgg,\n+                                               final K key,\n+                                               final V value,\n+                                               final long closeTime) {\n+            final ValueAndTimestamp<Agg> valueAndTime;\n+            // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+            if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ef2f3030006972660ea5d1d39b0ee1f9bf0b46f"}, "originalPosition": 342}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjU3OTcxOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMTowNTo0OVrOHMHlxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMTowNTo0OVrOHMHlxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ2OTMxOQ==", "bodyText": "Sorry but this method name continues to throw me off...the comment does a good job of reminding what the check actually does/means, but ideally the method name alone would do a reasonable job of that. What about previousRecordRightWindowMustBeCreated or previousRecordRightWindowDoesNotExistAndIsNotEmpty ? I know those are both super long, especially the 2nd option, but I personally think the 2nd option does the best job of providing the link between what the check actually does, and why we do it. It's better to be clear than concise (when you can't be both)", "url": "https://github.com/apache/kafka/pull/9239#discussion_r482469319", "createdAt": "2020-09-02T21:05:49Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -180,41 +217,225 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                    createPreviousRightWindow(previousRightWinStart, timestamp, key, value, closeTime);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n-                final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n-                } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                createCurrentRecordLeftWindow(previousRecordTimestamp, timestamp, leftWinAgg, key, value, closeTime);\n+            }\n+            // create right window for new record, if necessary\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        public void processReverse(final K key, final V value, final long timestamp, final long closeTime) {\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.backwardFetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                //if we've already seen the window with the closest start time to the record\n+                boolean foundRightWinAgg = false;\n+\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (endTime > timestamp) {\n+                        if (!foundRightWinAgg) {\n+                            foundRightWinAgg = true;\n+                            rightWinAgg = next.value;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime == timestamp) {\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                        leftWinAlreadyCreated = true;\n+                    } else if (endTime < timestamp) {\n+                        leftWinAgg = next.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        break;\n+                    } else {\n+                        //determine if current record's right window exists, will only be true at most once, on the first pass\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            //create right window for previous record\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, timestamp)) {\n+                    createPreviousRightWindow(previousRightWinStart, timestamp, key, value, closeTime);\n+                }\n+            }\n+\n+            //create the left window of the current record if it's not created\n+            if (!leftWinAlreadyCreated) {\n+                createCurrentRecordLeftWindow(previousRecordTimestamp, timestamp, leftWinAgg, key, value, closeTime);\n+            }\n+            //create the right window for the current record, if need be\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n                 }\n-                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                createPreviousRightWindow(previousRecordTimestamp + 1, timestamp, key, value, closeTime);\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n             }\n+\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(rightWinAgg.value(), Math.max(rightWinAgg.timestamp(), timestamp));\n+            windowStore.put(\n+                key,\n+                valueAndTime,\n+                window.start());\n+            tupleForwarder.maybeForward(\n+                new Windowed<>(key, window),\n+                rightWinAgg.value(),\n+                null,\n+                rightWinAgg.timestamp());        }\n+\n+        private void createPreviousRightWindow(final long windowStart,\n+                                               final long currentRecordTimestamp,\n+                                               final K key,\n+                                               final V value,\n+                                               final long closeTime) {\n+            final TimeWindow window = new TimeWindow(windowStart, windowStart + windows.timeDifferenceMs());\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), currentRecordTimestamp);\n+            putAndForward(window, valueAndTime, key, value, closeTime, currentRecordTimestamp);\n+        }\n+\n+        private void createCurrentRecordLeftWindow(final Long previousRecordTimestamp,\n+                                               final long timestamp,\n+                                               final ValueAndTimestamp<Agg> leftWinAgg,\n+                                               final K key,\n+                                               final V value,\n+                                               final long closeTime) {\n+            final ValueAndTimestamp<Agg> valueAndTime;\n+            // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+            if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n+                valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n+            } else {\n+                valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+            }\n+            final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n+            putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n         }\n \n-        private boolean isLeftWindow(final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> window) {\n-            return window.key.window().end() == window.value.timestamp();\n+        private boolean leftWindowNotEmpty(final long previousTimestamp, final long currentTimestamp) {\n+            return currentTimestamp - windows.timeDifferenceMs() <= previousTimestamp;\n+        }\n+\n+        // previous record's right window does not already exist and current record falls within previous record's right window\n+        private boolean rightWindowNecessaryAndPossible(final Set<Long> windowStartTimes,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ef2f3030006972660ea5d1d39b0ee1f9bf0b46f"}, "originalPosition": 358}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxNjYyMzI4OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQyMToxMjo0OFrOHMIDuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QxNzo0NzoxMVrOHMxRAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ3Njk4NA==", "bodyText": "I think it would be valuable to have all the tests run with both the forward and reverse iterators. You can actually parametrize the test class itself so that it runs multiple times with different input: the syntax is kind of hard to explain (and understand) but you can look at EosBetaUpgradeIntegrationTest as an example. It's parametrized by a injectFailure boolean -- you can do the same thing with a forwardIteration boolean.\nThen you could force it to run in the forward direction by providing a custom WindowBytesStoreSupplier that supplies a custom WindowStore implementation where the appropriate fetch method throws UnsupportedOperationException. You should be able to just extend one of the existing built-in stores (eg RocksDBWindowStore or InMemoryWindowStore) that just overrides fetch. Let me know if you have any questions about how all this would work", "url": "https://github.com/apache/kafka/pull/9239#discussion_r482476984", "createdAt": "2020-09-02T21:12:48Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "diffHunk": "@@ -608,10 +615,13 @@ public void testAggregateRandomInput() {\n \n     private void verifyRandomTestResults(final Map<Long, ValueAndTimestamp<String>> actual) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ef2f3030006972660ea5d1d39b0ee1f9bf0b46f"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE1MjEyOQ==", "bodyText": "Yeah I think running on both is definitely good to have. Along that line, should benchmark run with both reverse and forward? It could indicate if reverse is actually more efficient or if they run about the same", "url": "https://github.com/apache/kafka/pull/9239#discussion_r483152129", "createdAt": "2020-09-03T17:47:11Z", "author": {"login": "lct45"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "diffHunk": "@@ -608,10 +615,13 @@ public void testAggregateRandomInput() {\n \n     private void verifyRandomTestResults(final Map<Long, ValueAndTimestamp<String>> actual) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjQ3Njk4NA=="}, "originalCommit": {"oid": "8ef2f3030006972660ea5d1d39b0ee1f9bf0b46f"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTE5NTYzOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KGroupedStreamImplTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMDoyMDo0OVrOHOyOpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMzoyMjo0N1rOHQM5xQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2NTA2MA==", "bodyText": "Why this change?", "url": "https://github.com/apache/kafka/pull/9239#discussion_r485265060", "createdAt": "2020-09-09T00:20:49Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KGroupedStreamImplTest.java", "diffHunk": "@@ -239,52 +241,81 @@ private void doCountSlidingWindows(final  MockProcessorSupplier<Windowed<String>\n             inputTopic.pipeInput(\"2\", \"B\", 1000L);\n             inputTopic.pipeInput(\"3\", \"C\", 600L);\n         }\n-        assertThat(supplier.theCapturedProcessor().processed(), equalTo(Arrays.asList(\n-                // processing A@500\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(0L, 500L)), 1L, 500L),\n-                // processing A@999\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(501L, 1001L)), 1L, 999L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(499L, 999L)), 2L, 999L),\n-                // processing A@600\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(499L, 999L)), 3L, 999L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(501L, 1001L)), 2L, 999L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(100L, 600L)), 2L, 600L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(601L, 1101L)), 1L, 999L),\n-                // processing B@500\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(0L, 500L)), 1L, 500L),\n-                // processing B@600\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(501L, 1001L)), 1L, 600L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(100L, 600L)), 2L, 600L),\n-                // processing B@700\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(501L, 1001L)), 2L, 700L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(601L, 1101L)), 1L, 700L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(200L, 700L)), 3L, 700L),\n-                // processing C@501\n-                new KeyValueTimestamp<>(new Windowed<>(\"3\", new TimeWindow(1L, 501L)), 1L, 501L),\n-                // processing first A@1000\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(501L, 1001L)), 3L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(601L, 1101L)), 2L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(1000L, 1500L)), 1L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(500L, 1000L)), 4L, 1000L),\n-                // processing second A@1000\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(500L, 1000L)), 5L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(501L, 1001L)), 4L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(601L, 1101L)), 3L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(1000L, 1500L)), 2L, 1000L),\n-                // processing first B@1000\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(501L, 1001L)), 3L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(601L, 1101)), 2L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(701L, 1201L)), 1L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(500L, 1000L)), 4L, 1000L),\n-                // processing second B@1000\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(500L, 1000L)), 5L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(501L, 1001L)), 4L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(601L, 1101)), 3L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(701L, 1201L)), 2L, 1000L),\n-                // processing C@600\n-                new KeyValueTimestamp<>(new Windowed<>(\"3\", new TimeWindow(502L, 1002L)), 1L, 600L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"3\", new TimeWindow(100L, 600L)), 2L, 600L)\n \n+        final Comparator<KeyValueTimestamp<Windowed<String>, Long>> comparator =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90cfc6948987fc64c7bd568bbfa8b4e87c405ee4"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYyMzc4Ng==", "bodyText": "Because we're outputting all the intermediate data, the order of the internal windows aren't the same when you use the reverse iterator versus the in-order iterator. This is mainly an issue for large tests, but when there are a lot of windows to update as a new record comes in, the reverse iterator looks at them from largest start time to smallest start time, and the in-order iterator looks at them from smallest start time to largest start time. I suppose we could alter the algorithm to output results differently, but getting a different order didn't seem too harmful for users. WDYT?", "url": "https://github.com/apache/kafka/pull/9239#discussion_r485623786", "createdAt": "2020-09-09T13:45:51Z", "author": {"login": "lct45"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KGroupedStreamImplTest.java", "diffHunk": "@@ -239,52 +241,81 @@ private void doCountSlidingWindows(final  MockProcessorSupplier<Windowed<String>\n             inputTopic.pipeInput(\"2\", \"B\", 1000L);\n             inputTopic.pipeInput(\"3\", \"C\", 600L);\n         }\n-        assertThat(supplier.theCapturedProcessor().processed(), equalTo(Arrays.asList(\n-                // processing A@500\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(0L, 500L)), 1L, 500L),\n-                // processing A@999\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(501L, 1001L)), 1L, 999L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(499L, 999L)), 2L, 999L),\n-                // processing A@600\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(499L, 999L)), 3L, 999L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(501L, 1001L)), 2L, 999L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(100L, 600L)), 2L, 600L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(601L, 1101L)), 1L, 999L),\n-                // processing B@500\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(0L, 500L)), 1L, 500L),\n-                // processing B@600\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(501L, 1001L)), 1L, 600L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(100L, 600L)), 2L, 600L),\n-                // processing B@700\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(501L, 1001L)), 2L, 700L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(601L, 1101L)), 1L, 700L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(200L, 700L)), 3L, 700L),\n-                // processing C@501\n-                new KeyValueTimestamp<>(new Windowed<>(\"3\", new TimeWindow(1L, 501L)), 1L, 501L),\n-                // processing first A@1000\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(501L, 1001L)), 3L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(601L, 1101L)), 2L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(1000L, 1500L)), 1L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(500L, 1000L)), 4L, 1000L),\n-                // processing second A@1000\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(500L, 1000L)), 5L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(501L, 1001L)), 4L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(601L, 1101L)), 3L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(1000L, 1500L)), 2L, 1000L),\n-                // processing first B@1000\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(501L, 1001L)), 3L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(601L, 1101)), 2L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(701L, 1201L)), 1L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(500L, 1000L)), 4L, 1000L),\n-                // processing second B@1000\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(500L, 1000L)), 5L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(501L, 1001L)), 4L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(601L, 1101)), 3L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(701L, 1201L)), 2L, 1000L),\n-                // processing C@600\n-                new KeyValueTimestamp<>(new Windowed<>(\"3\", new TimeWindow(502L, 1002L)), 1L, 600L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"3\", new TimeWindow(100L, 600L)), 2L, 600L)\n \n+        final Comparator<KeyValueTimestamp<Windowed<String>, Long>> comparator =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2NTA2MA=="}, "originalCommit": {"oid": "90cfc6948987fc64c7bd568bbfa8b4e87c405ee4"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczODk3NQ==", "bodyText": "FWIW, I agree. The result of this aggregation is a KTable, i.e., a changelog stream. The semantics of the changelog stream only state that each record represents the latest state for that record's key. Just like the caches are free to drop arbitrary intermediate updates and KIP-557 is free to drop arbitrary idempotent updates, a processor that forwards updates for multiple different keys should be free to do it in any order.\nIn fact, I might go so far as to suggest that a proper behavioral test would load all the results into a map so that the test isn't sensitive to meaningless changes like this. But I won't go quite that far because it seems good to to have the opportunity to ask questions like @ableegoldman's. Just to be sure nothing unexpected is happening when we change things later.\nI also think it's better for performance not to try and buffer the window results and emit them in \"forward\" order, since it might be an arbitrarily large number of updates for us to keep in memory.", "url": "https://github.com/apache/kafka/pull/9239#discussion_r486738975", "createdAt": "2020-09-11T02:36:52Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KGroupedStreamImplTest.java", "diffHunk": "@@ -239,52 +241,81 @@ private void doCountSlidingWindows(final  MockProcessorSupplier<Windowed<String>\n             inputTopic.pipeInput(\"2\", \"B\", 1000L);\n             inputTopic.pipeInput(\"3\", \"C\", 600L);\n         }\n-        assertThat(supplier.theCapturedProcessor().processed(), equalTo(Arrays.asList(\n-                // processing A@500\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(0L, 500L)), 1L, 500L),\n-                // processing A@999\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(501L, 1001L)), 1L, 999L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(499L, 999L)), 2L, 999L),\n-                // processing A@600\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(499L, 999L)), 3L, 999L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(501L, 1001L)), 2L, 999L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(100L, 600L)), 2L, 600L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(601L, 1101L)), 1L, 999L),\n-                // processing B@500\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(0L, 500L)), 1L, 500L),\n-                // processing B@600\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(501L, 1001L)), 1L, 600L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(100L, 600L)), 2L, 600L),\n-                // processing B@700\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(501L, 1001L)), 2L, 700L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(601L, 1101L)), 1L, 700L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(200L, 700L)), 3L, 700L),\n-                // processing C@501\n-                new KeyValueTimestamp<>(new Windowed<>(\"3\", new TimeWindow(1L, 501L)), 1L, 501L),\n-                // processing first A@1000\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(501L, 1001L)), 3L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(601L, 1101L)), 2L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(1000L, 1500L)), 1L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(500L, 1000L)), 4L, 1000L),\n-                // processing second A@1000\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(500L, 1000L)), 5L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(501L, 1001L)), 4L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(601L, 1101L)), 3L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(1000L, 1500L)), 2L, 1000L),\n-                // processing first B@1000\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(501L, 1001L)), 3L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(601L, 1101)), 2L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(701L, 1201L)), 1L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(500L, 1000L)), 4L, 1000L),\n-                // processing second B@1000\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(500L, 1000L)), 5L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(501L, 1001L)), 4L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(601L, 1101)), 3L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(701L, 1201L)), 2L, 1000L),\n-                // processing C@600\n-                new KeyValueTimestamp<>(new Windowed<>(\"3\", new TimeWindow(502L, 1002L)), 1L, 600L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"3\", new TimeWindow(100L, 600L)), 2L, 600L)\n \n+        final Comparator<KeyValueTimestamp<Windowed<String>, Long>> comparator =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2NTA2MA=="}, "originalCommit": {"oid": "90cfc6948987fc64c7bd568bbfa8b4e87c405ee4"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1MDY2MQ==", "bodyText": "Sorry, I realize I never replied to your reply. I definitely agree, no need to force a particular inter-key ordering. The only ordering that would change is the updates to windows of different start times, which was arbitrary to begin with. The ordering that does matter -- intra-key ordering, ie updates with the same key and window start time -- isn't affected. Final results still come last, which is the important thing", "url": "https://github.com/apache/kafka/pull/9239#discussion_r486750661", "createdAt": "2020-09-11T03:22:47Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KGroupedStreamImplTest.java", "diffHunk": "@@ -239,52 +241,81 @@ private void doCountSlidingWindows(final  MockProcessorSupplier<Windowed<String>\n             inputTopic.pipeInput(\"2\", \"B\", 1000L);\n             inputTopic.pipeInput(\"3\", \"C\", 600L);\n         }\n-        assertThat(supplier.theCapturedProcessor().processed(), equalTo(Arrays.asList(\n-                // processing A@500\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(0L, 500L)), 1L, 500L),\n-                // processing A@999\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(501L, 1001L)), 1L, 999L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(499L, 999L)), 2L, 999L),\n-                // processing A@600\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(499L, 999L)), 3L, 999L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(501L, 1001L)), 2L, 999L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(100L, 600L)), 2L, 600L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(601L, 1101L)), 1L, 999L),\n-                // processing B@500\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(0L, 500L)), 1L, 500L),\n-                // processing B@600\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(501L, 1001L)), 1L, 600L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(100L, 600L)), 2L, 600L),\n-                // processing B@700\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(501L, 1001L)), 2L, 700L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(601L, 1101L)), 1L, 700L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(200L, 700L)), 3L, 700L),\n-                // processing C@501\n-                new KeyValueTimestamp<>(new Windowed<>(\"3\", new TimeWindow(1L, 501L)), 1L, 501L),\n-                // processing first A@1000\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(501L, 1001L)), 3L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(601L, 1101L)), 2L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(1000L, 1500L)), 1L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(500L, 1000L)), 4L, 1000L),\n-                // processing second A@1000\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(500L, 1000L)), 5L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(501L, 1001L)), 4L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(601L, 1101L)), 3L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"1\", new TimeWindow(1000L, 1500L)), 2L, 1000L),\n-                // processing first B@1000\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(501L, 1001L)), 3L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(601L, 1101)), 2L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(701L, 1201L)), 1L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(500L, 1000L)), 4L, 1000L),\n-                // processing second B@1000\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(500L, 1000L)), 5L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(501L, 1001L)), 4L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(601L, 1101)), 3L, 1000L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"2\", new TimeWindow(701L, 1201L)), 2L, 1000L),\n-                // processing C@600\n-                new KeyValueTimestamp<>(new Windowed<>(\"3\", new TimeWindow(502L, 1002L)), 1L, 600L),\n-                new KeyValueTimestamp<>(new Windowed<>(\"3\", new TimeWindow(100L, 600L)), 2L, 600L)\n \n+        final Comparator<KeyValueTimestamp<Windowed<String>, Long>> comparator =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2NTA2MA=="}, "originalCommit": {"oid": "90cfc6948987fc64c7bd568bbfa8b4e87c405ee4"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTIwNjU0OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/SlidingWindowedCogroupedKStreamImplTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMDoyNjoyNFrOHOyU3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQxMzo0MzowMVrOHPH--w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2NjY1Mw==", "bodyText": "This makes it sound like you want to assert that the output is not ordered, which I don't think is the point here?\nAlso, since you're only calling this from one place and are asserting a specific output that corresponds to a specific test, I would just inline this check in the test instead of moving it out to a new method", "url": "https://github.com/apache/kafka/pull/9239#discussion_r485266653", "createdAt": "2020-09-09T00:26:24Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/SlidingWindowedCogroupedKStreamImplTest.java", "diffHunk": "@@ -246,4 +238,31 @@ private void assertOutputKeyValueTimestamp(final TestOutputTopic<Windowed<String\n         final TestRecord<String, String> testRecord = new TestRecord<>(expectedKey, expectedValue, null, expectedTimestamp);\n         assertThat(nonWindowedRecord, equalTo(testRecord));\n     }\n+\n+    private void assertOutputKeyValueNotOrdered(final Set<TestRecord<String, String>> results) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90cfc6948987fc64c7bd568bbfa8b4e87c405ee4"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYyMTQ5OQ==", "bodyText": "Yeah the name was a struggle, but I just put it all back into the main function so should be cleaner now", "url": "https://github.com/apache/kafka/pull/9239#discussion_r485621499", "createdAt": "2020-09-09T13:43:01Z", "author": {"login": "lct45"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/SlidingWindowedCogroupedKStreamImplTest.java", "diffHunk": "@@ -246,4 +238,31 @@ private void assertOutputKeyValueTimestamp(final TestOutputTopic<Windowed<String\n         final TestRecord<String, String> testRecord = new TestRecord<>(expectedKey, expectedValue, null, expectedTimestamp);\n         assertThat(nonWindowedRecord, equalTo(testRecord));\n     }\n+\n+    private void assertOutputKeyValueNotOrdered(final Set<TestRecord<String, String>> results) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2NjY1Mw=="}, "originalCommit": {"oid": "90cfc6948987fc64c7bd568bbfa8b4e87c405ee4"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTIxNDU4OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/SuppressScenarioTest.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMDozMDo0M1rOHOyZfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNzowMjozOVrOHQmxAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2NzgzNw==", "bodyText": "Is this change just sorting the output by window start time? Why do that vs. verifying that the output is in a specific order? In general the output order may not matter much but it does seem important to verify for suppress (I think \ud83e\udd37\u200d\u2640\ufe0f )", "url": "https://github.com/apache/kafka/pull/9239#discussion_r485267837", "createdAt": "2020-09-09T00:30:43Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/SuppressScenarioTest.java", "diffHunk": "@@ -493,52 +494,59 @@ public void shouldSupportFinalResultsForSlidingWindows() {\n             inputTopic.pipeInput(\"k1\", \"v1\", 7L);\n             // final record to advance stream time and flush windows\n             inputTopic.pipeInput(\"k1\", \"v1\", 90L);\n+            final Comparator<TestRecord<String, Long>> comparator =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90cfc6948987fc64c7bd568bbfa8b4e87c405ee4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYyMDU1NA==", "bodyText": "Yeah it is just sorting the window by start time. With the reverse iterator looking at windows in a different order, the intermediate windows aren't updated in the same order as they are with in-order iterator. I don't think it should matter for suppress because the main list of output in this test is actually the raw output, it looks like the suppressed output didn't change after the ordering", "url": "https://github.com/apache/kafka/pull/9239#discussion_r485620554", "createdAt": "2020-09-09T13:41:44Z", "author": {"login": "lct45"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/SuppressScenarioTest.java", "diffHunk": "@@ -493,52 +494,59 @@ public void shouldSupportFinalResultsForSlidingWindows() {\n             inputTopic.pipeInput(\"k1\", \"v1\", 7L);\n             // final record to advance stream time and flush windows\n             inputTopic.pipeInput(\"k1\", \"v1\", 90L);\n+            final Comparator<TestRecord<String, Long>> comparator =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2NzgzNw=="}, "originalCommit": {"oid": "90cfc6948987fc64c7bd568bbfa8b4e87c405ee4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0MjczOA==", "bodyText": "It might matter for emit-on-full suppress buffers (if they actually get full), but even then, I think it's equally correct either way, so I don't think we need to be concerned.", "url": "https://github.com/apache/kafka/pull/9239#discussion_r486742738", "createdAt": "2020-09-11T02:51:20Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/SuppressScenarioTest.java", "diffHunk": "@@ -493,52 +494,59 @@ public void shouldSupportFinalResultsForSlidingWindows() {\n             inputTopic.pipeInput(\"k1\", \"v1\", 7L);\n             // final record to advance stream time and flush windows\n             inputTopic.pipeInput(\"k1\", \"v1\", 90L);\n+            final Comparator<TestRecord<String, Long>> comparator =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2NzgzNw=="}, "originalCommit": {"oid": "90cfc6948987fc64c7bd568bbfa8b4e87c405ee4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0MzQ5Nw==", "bodyText": "Ah, I belatedly realized what I think was @ableegoldman's concern. Suppress cares about the timestamps of the records, not the window start times. Since the timestamp of the windowed aggregation results are determined by the input record, not the window start times, all window agg updates that get forwarded happen \"at the same time\", right?\nIf that's true, then it doesn't matter the order we forward them in.", "url": "https://github.com/apache/kafka/pull/9239#discussion_r486743497", "createdAt": "2020-09-11T02:54:21Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/SuppressScenarioTest.java", "diffHunk": "@@ -493,52 +494,59 @@ public void shouldSupportFinalResultsForSlidingWindows() {\n             inputTopic.pipeInput(\"k1\", \"v1\", 7L);\n             // final record to advance stream time and flush windows\n             inputTopic.pipeInput(\"k1\", \"v1\", 90L);\n+            final Comparator<TestRecord<String, Long>> comparator =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2NzgzNw=="}, "originalCommit": {"oid": "90cfc6948987fc64c7bd568bbfa8b4e87c405ee4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1MzE5NQ==", "bodyText": "Actually, I think the timestamp of the forwarded results is now the window's \"event time\", ie the maximum timestamp of a record in the window. But in retrospect I don't see any correctness issues here: for one thing, as I mentioned in the other comment, this only affects the relative ordering of updates with different windowed keys. And there's no ordering guarantees between keys. It also shouldn't even have any impact on advancing stream-time and potentially dropping some windows due to grace", "url": "https://github.com/apache/kafka/pull/9239#discussion_r486753195", "createdAt": "2020-09-11T03:33:38Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/SuppressScenarioTest.java", "diffHunk": "@@ -493,52 +494,59 @@ public void shouldSupportFinalResultsForSlidingWindows() {\n             inputTopic.pipeInput(\"k1\", \"v1\", 7L);\n             // final record to advance stream time and flush windows\n             inputTopic.pipeInput(\"k1\", \"v1\", 90L);\n+            final Comparator<TestRecord<String, Long>> comparator =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2NzgzNw=="}, "originalCommit": {"oid": "90cfc6948987fc64c7bd568bbfa8b4e87c405ee4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3NDQwMA==", "bodyText": "Yeah, this sounds right. Either the current record's timestamp is less than the event time for some of the windows, in which case it doesn't advance the partition's stream time, or it is more advanced than the (prior) event time for all the windows, in which case it does advance the stream time, but all the updated windows' event times are equal to the current record's timestamp, which is also equal to the new stream time, which should also be ok for suppression.", "url": "https://github.com/apache/kafka/pull/9239#discussion_r487174400", "createdAt": "2020-09-11T17:02:39Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/SuppressScenarioTest.java", "diffHunk": "@@ -493,52 +494,59 @@ public void shouldSupportFinalResultsForSlidingWindows() {\n             inputTopic.pipeInput(\"k1\", \"v1\", 7L);\n             // final record to advance stream time and flush windows\n             inputTopic.pipeInput(\"k1\", \"v1\", 90L);\n+            final Comparator<TestRecord<String, Long>> comparator =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2NzgzNw=="}, "originalCommit": {"oid": "90cfc6948987fc64c7bd568bbfa8b4e87c405ee4"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNTI2MTg3OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMDo1NzowMVrOHOy0wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMDo1NzowMVrOHOy0wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3NDgxNw==", "bodyText": "nit: rename to inputRecordTimestamp to be consistent with the naming in the early records PR", "url": "https://github.com/apache/kafka/pull/9239#discussion_r485274817", "createdAt": "2020-09-09T00:57:01Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -161,60 +205,231 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n                     windowStartTimes.add(next.key.window().start());\n                     final long startTime = next.key.window().start();\n                     final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n \n                     if (endTime < timestamp) {\n                         leftWinAgg = next.value;\n-                        if (isLeftWindow(next)) {\n-                            latestLeftTypeWindow = next.key.window();\n-                        }\n+                        // update to store the previous record\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n                     } else if (endTime == timestamp) {\n                         leftWinAlreadyCreated = true;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n                         putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n                     } else if (endTime > timestamp && startTime <= timestamp) {\n                         rightWinAgg = next.value;\n                         putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    } else {\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n+                    }\n+                }\n+            }\n+            createWindows(key, value, timestamp, closeTime, windowStartTimes, rightWinAgg, leftWinAgg, leftWinAlreadyCreated, rightWinAlreadyCreated, previousRecordTimestamp);\n+        }\n+\n+        public void processReverse(final K key,\n+                                   final V value,\n+                                   final long timestamp,\n+                                   final long closeTime,\n+                                   final Set<Long> windowStartTimes,\n+                                   ValueAndTimestamp<Agg> leftWinAgg,\n+                                   ValueAndTimestamp<Agg> rightWinAgg,\n+                                   boolean leftWinAlreadyCreated,\n+                                   boolean rightWinAlreadyCreated,\n+                                   Long previousRecordTimestamp) {\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.backwardFetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+                    if (startTime == timestamp + 1) {\n+                        //determine if current record's right window exists, will only be true at most once, on the first pass\n+                        rightWinAlreadyCreated = true;\n+                    } else if (endTime > timestamp) {\n+                        if (rightWinAgg == null) {\n+                            rightWinAgg = next.value;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime == timestamp) {\n+                        leftWinAlreadyCreated = true;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        } else {\n+                            return;\n+                        }\n+                    } else if (endTime < timestamp) {\n+                        leftWinAgg = next.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        break;\n                     } else {\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n+                    }\n+                }\n+            }\n+            createWindows(key, value, timestamp, closeTime, windowStartTimes, rightWinAgg, leftWinAgg, leftWinAlreadyCreated, rightWinAlreadyCreated, previousRecordTimestamp);\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n                         rightWinAlreadyCreated = true;\n                     }\n                 }\n             }\n \n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                createPreviousRecordRightWindow(previousRecordTimestamp + 1, timestamp, key, value, closeTime);\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+\n+        }\n+\n+        private void createWindows(final K key,\n+                                   final V value,\n+                                   final long timestamp,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90cfc6948987fc64c7bd568bbfa8b4e87c405ee4"}, "originalPosition": 280}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzOTQyMzczOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMToxNzoxNlrOHPaoyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMToxNzoxNlrOHPaoyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNzExNA==", "bodyText": "Why create all of these here and then pass the uninitialized values into processInOrder/processReverse? If we only need them within the processX methods, let's just keep them there", "url": "https://github.com/apache/kafka/pull/9239#discussion_r485927114", "createdAt": "2020-09-09T21:17:16Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -150,23 +152,46 @@ public void process(final K key, final V value) {\n                 return;\n             }\n \n-            processInOrder(key, value, inputRecordTimestamp, closeTime);\n-        }\n-\n-        public void processInOrder(final K key, final V value, final long inputRecordTimestamp, final long closeTime) {\n+            if (reverseIteratorPossible == null) {\n+                try {\n+                    windowStore.backwardFetch(key, 0L, 0L);\n+                    reverseIteratorPossible = true;\n+                    log.debug(\"Sliding Windows aggregate using a reverse iterator\");\n+                } catch (final UnsupportedOperationException e)  {\n+                    reverseIteratorPossible = false;\n+                    log.debug(\"Sliding Windows aggregate using a forward iterator\");\n+                }\n+            }\n \n             final Set<Long> windowStartTimes = new HashSet<>();\n \n             // aggregate that will go in the current record\u2019s left/right window (if needed)\n-            ValueAndTimestamp<Agg> leftWinAgg = null;\n-            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            final ValueAndTimestamp<Agg> leftWinAgg = null;\n+            final ValueAndTimestamp<Agg> rightWinAgg = null;\n \n             //if current record's left/right windows already exist\n-            boolean leftWinAlreadyCreated = false;\n-            boolean rightWinAlreadyCreated = false;\n+            final boolean leftWinAlreadyCreated = false;\n+            final boolean rightWinAlreadyCreated = false;\n \n-            Long previousRecordTimestamp = null;\n+            final Long previousRecordTimestamp = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b32e0304ad2d0ed18bff97fff7d5830a360ca3f1"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzOTQyNTIxOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMToxNzo0NlrOHPapuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMToxNzo0NlrOHPapuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNzM1Mg==", "bodyText": "This comment doesn't really add much", "url": "https://github.com/apache/kafka/pull/9239#discussion_r485927352", "createdAt": "2020-09-09T21:17:46Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -184,6 +209,7 @@ public void processInOrder(final K key, final V value, final long inputRecordTim\n \n                     if (endTime < inputRecordTimestamp) {\n                         leftWinAgg = windowBeingProcessed.value;\n+                        // update to store the previous record", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b32e0304ad2d0ed18bff97fff7d5830a360ca3f1"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzOTQyOTE4OnYy", "diffSide": "LEFT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMToxODo1NlrOHPar9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMToxODo1NlrOHPar9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNzkyNg==", "bodyText": "Was this a rebasing accident? Seems like using startTime is correct", "url": "https://github.com/apache/kafka/pull/9239#discussion_r485927926", "createdAt": "2020-09-09T21:18:56Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -194,7 +220,7 @@ public void processInOrder(final K key, final V value, final long inputRecordTim\n                     } else if (endTime > inputRecordTimestamp && startTime <= inputRecordTimestamp) {\n                         rightWinAgg = windowBeingProcessed.value;\n                         updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n-                    } else if (startTime == inputRecordTimestamp + 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b32e0304ad2d0ed18bff97fff7d5830a360ca3f1"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzOTQzMzQ5OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMToyMDoxMlrOHPauWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMToyMDoxMlrOHPauWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyODUzNg==", "bodyText": "super nit: put a line break before the right window creation block below", "url": "https://github.com/apache/kafka/pull/9239#discussion_r485928536", "createdAt": "2020-09-09T21:20:12Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -327,6 +382,41 @@ private void processEarly(final K key, final V value, final long inputRecordTime\n \n         }\n \n+        private void createWindows(final K key,\n+                                   final V value,\n+                                   final long inputRecordTimestamp,\n+                                   final long closeTime,\n+                                   final Set<Long> windowStartTimes,\n+                                   final ValueAndTimestamp<Agg> rightWinAgg,\n+                                   final ValueAndTimestamp<Agg> leftWinAgg,\n+                                   final boolean leftWinAlreadyCreated,\n+                                   final boolean rightWinAlreadyCreated,\n+                                   final Long previousRecordTimestamp) {\n+            //create right window for previous record\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (previousRecordRightWindowDoesNotExistAndIsNotEmpty(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n+                    createPreviousRecordRightWindow(previousRightWinStart, inputRecordTimestamp, key, value, closeTime);\n+                }\n+            }\n+\n+            //create left window for new record\n+            if (!leftWinAlreadyCreated) {\n+                final ValueAndTimestamp<Agg> valueAndTime;\n+                if (leftWindowNotEmpty(previousRecordTimestamp, inputRecordTimestamp)) {\n+                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), inputRecordTimestamp);\n+                } else {\n+                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                }\n+                final TimeWindow window = new TimeWindow(inputRecordTimestamp - windows.timeDifferenceMs(), inputRecordTimestamp);\n+                updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b32e0304ad2d0ed18bff97fff7d5830a360ca3f1"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzOTQ0MzY2OnYy", "diffSide": "LEFT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMToyMzozNlrOHPa0Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMToyMzozNlrOHPa0Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzMDA1NA==", "bodyText": "I think some things got accidentally changed/reverted during the rebase, eg this paragraph and the comment on line 250 at least", "url": "https://github.com/apache/kafka/pull/9239#discussion_r485930054", "createdAt": "2020-09-09T21:23:36Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -205,38 +231,69 @@ public void processInOrder(final K key, final V value, final long inputRecordTim\n                     }\n                 }\n             }\n+            createWindows(key, value, inputRecordTimestamp, closeTime, windowStartTimes, rightWinAgg, leftWinAgg, leftWinAlreadyCreated, rightWinAlreadyCreated, previousRecordTimestamp);\n+        }\n \n-            //create right window for previous record\n-            if (previousRecordTimestamp != null) {\n-                final long previousRightWinStart = previousRecordTimestamp + 1;\n-                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n-                    final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n-                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n-                }\n-            }\n-\n-            //create left window for new record\n-            if (!leftWinAlreadyCreated) {\n-                final ValueAndTimestamp<Agg> valueAndTime;\n-                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n-                if (leftWindowNotEmpty(previousRecordTimestamp, inputRecordTimestamp)) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), inputRecordTimestamp);\n-                } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+        public void processReverse(final K key,\n+                                   final V value,\n+                                   final long inputRecordTimestamp,\n+                                   final long closeTime,\n+                                   final Set<Long> windowStartTimes,\n+                                   ValueAndTimestamp<Agg> leftWinAgg,\n+                                   ValueAndTimestamp<Agg> rightWinAgg,\n+                                   boolean leftWinAlreadyCreated,\n+                                   boolean rightWinAlreadyCreated,\n+                                   Long previousRecordTimestamp) {\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.backwardFetch(\n+                    key,\n+                    key,\n+                    Math.max(0, inputRecordTimestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    inputRecordTimestamp + 1)\n+            ) {\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n+                    if (startTime == inputRecordTimestamp + 1) {\n+                        //determine if current record's right window exists, will only be true at most once, on the first pass\n+                        rightWinAlreadyCreated = true;\n+                    } else if (endTime > inputRecordTimestamp) {\n+                        if (rightWinAgg == null) {\n+                            rightWinAgg = windowBeingProcessed.value;\n+                        }\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (endTime == inputRecordTimestamp) {\n+                        leftWinAlreadyCreated = true;\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                        if (windowMaxRecordTimestamp < inputRecordTimestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        } else {\n+                            return;\n+                        }\n+                    } else if (endTime < inputRecordTimestamp) {\n+                        leftWinAgg = windowBeingProcessed.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        break;\n+                    } else {\n+                        log.error(\n+                            \"Unexpected window with start {} found when processing record at {} in `KStreamSlidingWindowAggregate`.\",\n+                            startTime, inputRecordTimestamp\n+                        );\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n+                    }\n                 }\n-                final TimeWindow window = new TimeWindow(inputRecordTimestamp - windows.timeDifferenceMs(), inputRecordTimestamp);\n-                updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n-            }\n-            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, inputRecordTimestamp)) {\n-                createCurrentRecordRightWindow(inputRecordTimestamp, rightWinAgg, key);\n             }\n+            createWindows(key, value, inputRecordTimestamp, closeTime, windowStartTimes, rightWinAgg, leftWinAgg, leftWinAlreadyCreated, rightWinAlreadyCreated, previousRecordTimestamp);\n         }\n \n         /**\n-         * Created to handle records where 0 < inputRecordTimestamp < timeDifferenceMs. These records would create\n-         * windows with negative start times, which is not supported. Instead, we will put them into the [0, timeDifferenceMs]\n-         * window as a \"workaround\", and we will update or create their right windows as new records come in later", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b32e0304ad2d0ed18bff97fff7d5830a360ca3f1"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzg0NTMxOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDozOTowMlrOHQE6Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDozOTowMlrOHQE6Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxOTczNA==", "bodyText": "nit: add 1 to upper bound to catch the current records'... here and elsewhere, it's not totally clear what this comment is referring to", "url": "https://github.com/apache/kafka/pull/9239#discussion_r486619734", "createdAt": "2020-09-10T20:39:02Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -205,32 +221,67 @@ public void processInOrder(final K key, final V value, final long inputRecordTim\n                     }\n                 }\n             }\n+            createWindows(key, value, inputRecordTimestamp, closeTime, windowStartTimes, rightWinAgg, leftWinAgg, leftWinAlreadyCreated, rightWinAlreadyCreated, previousRecordTimestamp);\n+        }\n \n-            //create right window for previous record\n-            if (previousRecordTimestamp != null) {\n-                final long previousRightWinStart = previousRecordTimestamp + 1;\n-                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n-                    final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n-                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n-                }\n-            }\n+        public void processReverse(final K key, final V value, final long inputRecordTimestamp, final long closeTime) {\n \n-            //create left window for new record\n-            if (!leftWinAlreadyCreated) {\n-                final ValueAndTimestamp<Agg> valueAndTime;\n-                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n-                if (leftWindowNotEmpty(previousRecordTimestamp, inputRecordTimestamp)) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), inputRecordTimestamp);\n-                } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.backwardFetch(\n+                    key,\n+                    key,\n+                    Math.max(0, inputRecordTimestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "794c5710a77cdeffb907c985cc1a67215774aa38"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzg1NjQ3OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDo0MjowNVrOHQFAug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjoxOToxNlrOHQHr4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyMTM3MA==", "bodyText": "nit: maybe you can just remove this comment, the code seems pretty explanatory. We can see what @vvcephei  thinks", "url": "https://github.com/apache/kafka/pull/9239#discussion_r486621370", "createdAt": "2020-09-10T20:42:05Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -205,32 +221,67 @@ public void processInOrder(final K key, final V value, final long inputRecordTim\n                     }\n                 }\n             }\n+            createWindows(key, value, inputRecordTimestamp, closeTime, windowStartTimes, rightWinAgg, leftWinAgg, leftWinAlreadyCreated, rightWinAlreadyCreated, previousRecordTimestamp);\n+        }\n \n-            //create right window for previous record\n-            if (previousRecordTimestamp != null) {\n-                final long previousRightWinStart = previousRecordTimestamp + 1;\n-                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n-                    final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n-                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n-                }\n-            }\n+        public void processReverse(final K key, final V value, final long inputRecordTimestamp, final long closeTime) {\n \n-            //create left window for new record\n-            if (!leftWinAlreadyCreated) {\n-                final ValueAndTimestamp<Agg> valueAndTime;\n-                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n-                if (leftWindowNotEmpty(previousRecordTimestamp, inputRecordTimestamp)) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), inputRecordTimestamp);\n-                } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.backwardFetch(\n+                    key,\n+                    key,\n+                    Math.max(0, inputRecordTimestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    inputRecordTimestamp + 1)\n+            ) {\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n+                    if (startTime == inputRecordTimestamp + 1) {\n+                        //determine if current record's right window exists, will only be true at most once, on the first pass", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "794c5710a77cdeffb907c985cc1a67215774aa38"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2NTE4NQ==", "bodyText": "Yeah, it looks pretty straightforward without the comment. If anything would deserve clarification in a comment, it would be a reminder that we do not add the current record to the right-hand window. Then again, it's pretty fundamental to the algorithm.", "url": "https://github.com/apache/kafka/pull/9239#discussion_r486665185", "createdAt": "2020-09-10T22:19:16Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -205,32 +221,67 @@ public void processInOrder(final K key, final V value, final long inputRecordTim\n                     }\n                 }\n             }\n+            createWindows(key, value, inputRecordTimestamp, closeTime, windowStartTimes, rightWinAgg, leftWinAgg, leftWinAlreadyCreated, rightWinAlreadyCreated, previousRecordTimestamp);\n+        }\n \n-            //create right window for previous record\n-            if (previousRecordTimestamp != null) {\n-                final long previousRightWinStart = previousRecordTimestamp + 1;\n-                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n-                    final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n-                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n-                }\n-            }\n+        public void processReverse(final K key, final V value, final long inputRecordTimestamp, final long closeTime) {\n \n-            //create left window for new record\n-            if (!leftWinAlreadyCreated) {\n-                final ValueAndTimestamp<Agg> valueAndTime;\n-                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n-                if (leftWindowNotEmpty(previousRecordTimestamp, inputRecordTimestamp)) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), inputRecordTimestamp);\n-                } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.backwardFetch(\n+                    key,\n+                    key,\n+                    Math.max(0, inputRecordTimestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    inputRecordTimestamp + 1)\n+            ) {\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n+                    if (startTime == inputRecordTimestamp + 1) {\n+                        //determine if current record's right window exists, will only be true at most once, on the first pass", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyMTM3MA=="}, "originalCommit": {"oid": "794c5710a77cdeffb907c985cc1a67215774aa38"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzg3MDQ2OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/InMemoryWindowStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDo0NjoxOFrOHQFI-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMjoyOTowNlrOHQMDiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyMzQ4MQ==", "bodyText": "Need to make this public for the child class used to parametrize the test so we continue to test both forward and reverse directions. The alternative would be to just create a new standalone ForwardOnlyWindowStore test utility class and stick it in the same package\n(btw, need to fix parameter alignment)", "url": "https://github.com/apache/kafka/pull/9239#discussion_r486623481", "createdAt": "2020-09-10T20:46:18Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/InMemoryWindowStore.java", "diffHunk": "@@ -68,7 +68,7 @@\n \n     private volatile boolean open = false;\n \n-    InMemoryWindowStore(final String name,\n+    public InMemoryWindowStore(final String name,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "794c5710a77cdeffb907c985cc1a67215774aa38"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjczNjc3OQ==", "bodyText": "Thanks for the explanation. This sounds fine to me.", "url": "https://github.com/apache/kafka/pull/9239#discussion_r486736779", "createdAt": "2020-09-11T02:29:06Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/InMemoryWindowStore.java", "diffHunk": "@@ -68,7 +68,7 @@\n \n     private volatile boolean open = false;\n \n-    InMemoryWindowStore(final String name,\n+    public InMemoryWindowStore(final String name,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyMzQ4MQ=="}, "originalCommit": {"oid": "794c5710a77cdeffb907c985cc1a67215774aa38"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzg4MDM4OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDo0OTozMFrOHQFO-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMzoyNDoxNVrOHQM7Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNTAxOQ==", "bodyText": "Where does topic-Canonized come from? Also, if we need to set the ValueSerde to String here, then wouldn't we need to do so for the in-order case as well? Does that mean we don't actually need the withValueSerde thing here?", "url": "https://github.com/apache/kafka/pull/9239#discussion_r486625019", "createdAt": "2020-09-10T20:49:30Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "diffHunk": "@@ -78,16 +100,28 @@\n     public void testAggregateSmallInput() {\n         final StreamsBuilder builder = new StreamsBuilder();\n         final String topic = \"topic\";\n-\n-        final KTable<Windowed<String>, String> table = builder\n-            .stream(topic, Consumed.with(Serdes.String(), Serdes.String()))\n-            .groupByKey(Grouped.with(Serdes.String(), Serdes.String()))\n-            .windowedBy(SlidingWindows.withTimeDifferenceAndGrace(ofMillis(10), ofMillis(50)))\n-            .aggregate(\n-                MockInitializer.STRING_INIT,\n-                MockAggregator.TOSTRING_ADDER,\n-                Materialized.<String, String, WindowStore<Bytes, byte[]>>as(\"topic-Canonized\").withValueSerde(Serdes.String())\n-            );\n+        final KTable<Windowed<String>, String> table;\n+        if (inOrderIterator) {\n+            table = builder\n+                .stream(topic, Consumed.with(Serdes.String(), Serdes.String()))\n+                .groupByKey(Grouped.with(Serdes.String(), Serdes.String()))\n+                .windowedBy(SlidingWindows.withTimeDifferenceAndGrace(ofMillis(10), ofMillis(50)))\n+                .aggregate(\n+                    MockInitializer.STRING_INIT,\n+                    MockAggregator.TOSTRING_ADDER,\n+                    Materialized.as(new InOrderMemoryWindowStoreSupplier(\"InOrder\", 50000L, 10L, false))\n+                );\n+        } else {\n+            table = builder\n+                .stream(topic, Consumed.with(Serdes.String(), Serdes.String()))\n+                .groupByKey(Grouped.with(Serdes.String(), Serdes.String()))\n+                .windowedBy(SlidingWindows.withTimeDifferenceAndGrace(ofMillis(10), ofMillis(50)))\n+                .aggregate(\n+                    MockInitializer.STRING_INIT,\n+                    MockAggregator.TOSTRING_ADDER,\n+                    Materialized.<String, String, WindowStore<Bytes, byte[]>>as(\"topic-Canonized\").withValueSerde(Serdes.String())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "794c5710a77cdeffb907c985cc1a67215774aa38"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY3MzA3MA==", "bodyText": "I based the aggregate function off something else so topic-Canonized must be from there. It seems like generally, valueSerde doesn't need to be set to string so I removed it in most places. Changing to the custom window store made it complain about doing Serdes.String (it wanted an object) and it appears that we need a Serdes.String for the grace test so I'll mess around with that one more to see how it can be run with both iterators", "url": "https://github.com/apache/kafka/pull/9239#discussion_r486673070", "createdAt": "2020-09-10T22:40:56Z", "author": {"login": "lct45"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "diffHunk": "@@ -78,16 +100,28 @@\n     public void testAggregateSmallInput() {\n         final StreamsBuilder builder = new StreamsBuilder();\n         final String topic = \"topic\";\n-\n-        final KTable<Windowed<String>, String> table = builder\n-            .stream(topic, Consumed.with(Serdes.String(), Serdes.String()))\n-            .groupByKey(Grouped.with(Serdes.String(), Serdes.String()))\n-            .windowedBy(SlidingWindows.withTimeDifferenceAndGrace(ofMillis(10), ofMillis(50)))\n-            .aggregate(\n-                MockInitializer.STRING_INIT,\n-                MockAggregator.TOSTRING_ADDER,\n-                Materialized.<String, String, WindowStore<Bytes, byte[]>>as(\"topic-Canonized\").withValueSerde(Serdes.String())\n-            );\n+        final KTable<Windowed<String>, String> table;\n+        if (inOrderIterator) {\n+            table = builder\n+                .stream(topic, Consumed.with(Serdes.String(), Serdes.String()))\n+                .groupByKey(Grouped.with(Serdes.String(), Serdes.String()))\n+                .windowedBy(SlidingWindows.withTimeDifferenceAndGrace(ofMillis(10), ofMillis(50)))\n+                .aggregate(\n+                    MockInitializer.STRING_INIT,\n+                    MockAggregator.TOSTRING_ADDER,\n+                    Materialized.as(new InOrderMemoryWindowStoreSupplier(\"InOrder\", 50000L, 10L, false))\n+                );\n+        } else {\n+            table = builder\n+                .stream(topic, Consumed.with(Serdes.String(), Serdes.String()))\n+                .groupByKey(Grouped.with(Serdes.String(), Serdes.String()))\n+                .windowedBy(SlidingWindows.withTimeDifferenceAndGrace(ofMillis(10), ofMillis(50)))\n+                .aggregate(\n+                    MockInitializer.STRING_INIT,\n+                    MockAggregator.TOSTRING_ADDER,\n+                    Materialized.<String, String, WindowStore<Bytes, byte[]>>as(\"topic-Canonized\").withValueSerde(Serdes.String())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNTAxOQ=="}, "originalCommit": {"oid": "794c5710a77cdeffb907c985cc1a67215774aa38"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4NDE0NQ==", "bodyText": "It should ultimately be the same for both iterators, but there might be some weird type nonsense going on. These problems should go away if you go with the approach of just setting a StoreSupplier based on inOrderIterator and then only specifying the topology once", "url": "https://github.com/apache/kafka/pull/9239#discussion_r486684145", "createdAt": "2020-09-10T23:15:24Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "diffHunk": "@@ -78,16 +100,28 @@\n     public void testAggregateSmallInput() {\n         final StreamsBuilder builder = new StreamsBuilder();\n         final String topic = \"topic\";\n-\n-        final KTable<Windowed<String>, String> table = builder\n-            .stream(topic, Consumed.with(Serdes.String(), Serdes.String()))\n-            .groupByKey(Grouped.with(Serdes.String(), Serdes.String()))\n-            .windowedBy(SlidingWindows.withTimeDifferenceAndGrace(ofMillis(10), ofMillis(50)))\n-            .aggregate(\n-                MockInitializer.STRING_INIT,\n-                MockAggregator.TOSTRING_ADDER,\n-                Materialized.<String, String, WindowStore<Bytes, byte[]>>as(\"topic-Canonized\").withValueSerde(Serdes.String())\n-            );\n+        final KTable<Windowed<String>, String> table;\n+        if (inOrderIterator) {\n+            table = builder\n+                .stream(topic, Consumed.with(Serdes.String(), Serdes.String()))\n+                .groupByKey(Grouped.with(Serdes.String(), Serdes.String()))\n+                .windowedBy(SlidingWindows.withTimeDifferenceAndGrace(ofMillis(10), ofMillis(50)))\n+                .aggregate(\n+                    MockInitializer.STRING_INIT,\n+                    MockAggregator.TOSTRING_ADDER,\n+                    Materialized.as(new InOrderMemoryWindowStoreSupplier(\"InOrder\", 50000L, 10L, false))\n+                );\n+        } else {\n+            table = builder\n+                .stream(topic, Consumed.with(Serdes.String(), Serdes.String()))\n+                .groupByKey(Grouped.with(Serdes.String(), Serdes.String()))\n+                .windowedBy(SlidingWindows.withTimeDifferenceAndGrace(ofMillis(10), ofMillis(50)))\n+                .aggregate(\n+                    MockInitializer.STRING_INIT,\n+                    MockAggregator.TOSTRING_ADDER,\n+                    Materialized.<String, String, WindowStore<Bytes, byte[]>>as(\"topic-Canonized\").withValueSerde(Serdes.String())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNTAxOQ=="}, "originalCommit": {"oid": "794c5710a77cdeffb907c985cc1a67215774aa38"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0MTkxOA==", "bodyText": "The Materialized builder is notoriously vulnerable to \"weird type nonsense\" because it falls into a gap in Java's type inference system when you use chained methods. Let's see what happens when you implement @ableegoldman 's earlier suggestion.", "url": "https://github.com/apache/kafka/pull/9239#discussion_r486741918", "createdAt": "2020-09-11T02:47:57Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "diffHunk": "@@ -78,16 +100,28 @@\n     public void testAggregateSmallInput() {\n         final StreamsBuilder builder = new StreamsBuilder();\n         final String topic = \"topic\";\n-\n-        final KTable<Windowed<String>, String> table = builder\n-            .stream(topic, Consumed.with(Serdes.String(), Serdes.String()))\n-            .groupByKey(Grouped.with(Serdes.String(), Serdes.String()))\n-            .windowedBy(SlidingWindows.withTimeDifferenceAndGrace(ofMillis(10), ofMillis(50)))\n-            .aggregate(\n-                MockInitializer.STRING_INIT,\n-                MockAggregator.TOSTRING_ADDER,\n-                Materialized.<String, String, WindowStore<Bytes, byte[]>>as(\"topic-Canonized\").withValueSerde(Serdes.String())\n-            );\n+        final KTable<Windowed<String>, String> table;\n+        if (inOrderIterator) {\n+            table = builder\n+                .stream(topic, Consumed.with(Serdes.String(), Serdes.String()))\n+                .groupByKey(Grouped.with(Serdes.String(), Serdes.String()))\n+                .windowedBy(SlidingWindows.withTimeDifferenceAndGrace(ofMillis(10), ofMillis(50)))\n+                .aggregate(\n+                    MockInitializer.STRING_INIT,\n+                    MockAggregator.TOSTRING_ADDER,\n+                    Materialized.as(new InOrderMemoryWindowStoreSupplier(\"InOrder\", 50000L, 10L, false))\n+                );\n+        } else {\n+            table = builder\n+                .stream(topic, Consumed.with(Serdes.String(), Serdes.String()))\n+                .groupByKey(Grouped.with(Serdes.String(), Serdes.String()))\n+                .windowedBy(SlidingWindows.withTimeDifferenceAndGrace(ofMillis(10), ofMillis(50)))\n+                .aggregate(\n+                    MockInitializer.STRING_INIT,\n+                    MockAggregator.TOSTRING_ADDER,\n+                    Materialized.<String, String, WindowStore<Bytes, byte[]>>as(\"topic-Canonized\").withValueSerde(Serdes.String())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNTAxOQ=="}, "originalCommit": {"oid": "794c5710a77cdeffb907c985cc1a67215774aa38"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc1MTAwNg==", "bodyText": "I knew John would know what's up with the weird type nonsense \ud83d\ude1b", "url": "https://github.com/apache/kafka/pull/9239#discussion_r486751006", "createdAt": "2020-09-11T03:24:15Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "diffHunk": "@@ -78,16 +100,28 @@\n     public void testAggregateSmallInput() {\n         final StreamsBuilder builder = new StreamsBuilder();\n         final String topic = \"topic\";\n-\n-        final KTable<Windowed<String>, String> table = builder\n-            .stream(topic, Consumed.with(Serdes.String(), Serdes.String()))\n-            .groupByKey(Grouped.with(Serdes.String(), Serdes.String()))\n-            .windowedBy(SlidingWindows.withTimeDifferenceAndGrace(ofMillis(10), ofMillis(50)))\n-            .aggregate(\n-                MockInitializer.STRING_INIT,\n-                MockAggregator.TOSTRING_ADDER,\n-                Materialized.<String, String, WindowStore<Bytes, byte[]>>as(\"topic-Canonized\").withValueSerde(Serdes.String())\n-            );\n+        final KTable<Windowed<String>, String> table;\n+        if (inOrderIterator) {\n+            table = builder\n+                .stream(topic, Consumed.with(Serdes.String(), Serdes.String()))\n+                .groupByKey(Grouped.with(Serdes.String(), Serdes.String()))\n+                .windowedBy(SlidingWindows.withTimeDifferenceAndGrace(ofMillis(10), ofMillis(50)))\n+                .aggregate(\n+                    MockInitializer.STRING_INIT,\n+                    MockAggregator.TOSTRING_ADDER,\n+                    Materialized.as(new InOrderMemoryWindowStoreSupplier(\"InOrder\", 50000L, 10L, false))\n+                );\n+        } else {\n+            table = builder\n+                .stream(topic, Consumed.with(Serdes.String(), Serdes.String()))\n+                .groupByKey(Grouped.with(Serdes.String(), Serdes.String()))\n+                .windowedBy(SlidingWindows.withTimeDifferenceAndGrace(ofMillis(10), ofMillis(50)))\n+                .aggregate(\n+                    MockInitializer.STRING_INIT,\n+                    MockAggregator.TOSTRING_ADDER,\n+                    Materialized.<String, String, WindowStore<Bytes, byte[]>>as(\"topic-Canonized\").withValueSerde(Serdes.String())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNTAxOQ=="}, "originalCommit": {"oid": "794c5710a77cdeffb907c985cc1a67215774aa38"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzg5NjAwOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDo1NDoyMlrOHQFYiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMjo0NDo0MFrOHQMUdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNzQ2NA==", "bodyText": "Instead of specifying the whole thing for both cases, you could just create a\nfinal WindowBytesStoreSupplier supplier = inOrderIterator ? new InOrderMemoryWindowStoreSupplier(...) : Stores.InMemoryWindowStore(...)\n\nand then pass that into the Materialized without having to list the whole topology out twice.", "url": "https://github.com/apache/kafka/pull/9239#discussion_r486627464", "createdAt": "2020-09-10T20:54:22Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "diffHunk": "@@ -78,16 +100,28 @@\n     public void testAggregateSmallInput() {\n         final StreamsBuilder builder = new StreamsBuilder();\n         final String topic = \"topic\";\n-\n-        final KTable<Windowed<String>, String> table = builder\n-            .stream(topic, Consumed.with(Serdes.String(), Serdes.String()))\n-            .groupByKey(Grouped.with(Serdes.String(), Serdes.String()))\n-            .windowedBy(SlidingWindows.withTimeDifferenceAndGrace(ofMillis(10), ofMillis(50)))\n-            .aggregate(\n-                MockInitializer.STRING_INIT,\n-                MockAggregator.TOSTRING_ADDER,\n-                Materialized.<String, String, WindowStore<Bytes, byte[]>>as(\"topic-Canonized\").withValueSerde(Serdes.String())\n-            );\n+        final KTable<Windowed<String>, String> table;\n+        if (inOrderIterator) {\n+            table = builder", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "794c5710a77cdeffb907c985cc1a67215774aa38"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0MTEwOA==", "bodyText": "Yes, this would be better. Not sure if it helps, but for reference, this is what we did in org.apache.kafka.streams.integration.KTableKTableForeignKeyJoinMaterializationIntegrationTest#getTopology", "url": "https://github.com/apache/kafka/pull/9239#discussion_r486741108", "createdAt": "2020-09-11T02:44:40Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "diffHunk": "@@ -78,16 +100,28 @@\n     public void testAggregateSmallInput() {\n         final StreamsBuilder builder = new StreamsBuilder();\n         final String topic = \"topic\";\n-\n-        final KTable<Windowed<String>, String> table = builder\n-            .stream(topic, Consumed.with(Serdes.String(), Serdes.String()))\n-            .groupByKey(Grouped.with(Serdes.String(), Serdes.String()))\n-            .windowedBy(SlidingWindows.withTimeDifferenceAndGrace(ofMillis(10), ofMillis(50)))\n-            .aggregate(\n-                MockInitializer.STRING_INIT,\n-                MockAggregator.TOSTRING_ADDER,\n-                Materialized.<String, String, WindowStore<Bytes, byte[]>>as(\"topic-Canonized\").withValueSerde(Serdes.String())\n-            );\n+        final KTable<Windowed<String>, String> table;\n+        if (inOrderIterator) {\n+            table = builder", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNzQ2NA=="}, "originalCommit": {"oid": "794c5710a77cdeffb907c985cc1a67215774aa38"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NDExMTY3OnYy", "diffSide": "RIGHT", "path": "checkstyle/suppressions.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjowODowN1rOHQHaCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjowODowN1rOHQHaCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MDYxOA==", "bodyText": "It seems like resolving @ableegoldman 's comment ( https://github.com/apache/kafka/pull/9239/files#r486627464  ) would make this unnecessary.", "url": "https://github.com/apache/kafka/pull/9239#discussion_r486660618", "createdAt": "2020-09-10T22:08:07Z", "author": {"login": "vvcephei"}, "path": "checkstyle/suppressions.xml", "diffHunk": "@@ -203,6 +203,9 @@\n     <suppress checks=\"(FinalLocalVariable|WhitespaceAround|LocalVariableName|ImportControl|AvoidStarImport)\"\n               files=\"Murmur3Test.java\"/>\n \n+    <suppress checks=\"MethodLength\"\n+              files=\"KStreamSlidingWindowAggregateTest.java\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "794c5710a77cdeffb907c985cc1a67215774aa38"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NDY1ODgyOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMjo0ODo1NFrOHQMYYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMjo0ODo1NFrOHQMYYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc0MjExMw==", "bodyText": "Beautiful. Thanks!", "url": "https://github.com/apache/kafka/pull/9239#discussion_r486742113", "createdAt": "2020-09-11T02:48:54Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "diffHunk": "@@ -877,4 +1003,56 @@ private void assertLatenessMetrics(final TopologyTestDriver driver,\n         assertThat(driver.metrics().get(latenessMaxMetric).metricValue(), maxLateness);\n         assertThat(driver.metrics().get(latenessAvgMetric).metricValue(), avgLateness);\n     }\n-}\n\\ No newline at end of file\n+\n+    private static class InOrderMemoryWindowStore extends InMemoryWindowStore {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "794c5710a77cdeffb907c985cc1a67215774aa38"}, "originalPosition": 590}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Njk4MTA4OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNTowOTowNVrOHQi1mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNjo1NzoyMFrOHQml4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzExMDA0Mw==", "bodyText": "These lines ended up being pretty long but I wasn't sure how to best split them up. WDYT @ableegoldman ?", "url": "https://github.com/apache/kafka/pull/9239#discussion_r487110043", "createdAt": "2020-09-11T15:09:05Z", "author": {"login": "lct45"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "diffHunk": "@@ -131,14 +157,15 @@ public void testAggregateSmallInput() {\n     public void testReduceSmallInput() {\n         final StreamsBuilder builder = new StreamsBuilder();\n         final String topic = \"topic\";\n+        final WindowBytesStoreSupplier storeSupplier = inOrderIterator ? new InOrderMemoryWindowStoreSupplier(\"InOrder\", 50000L, 10L, false) : Stores.inMemoryWindowStore(\"Reverse\", Duration.ofMillis(50000), Duration.ofMillis(10), false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9387e0341c9aede088d970452439dd28a0aa1ee"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3MDY0Ng==", "bodyText": "This is how I typically break up ternaries.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final WindowBytesStoreSupplier storeSupplier = inOrderIterator ? new InOrderMemoryWindowStoreSupplier(\"InOrder\", 50000L, 10L, false) : Stores.inMemoryWindowStore(\"Reverse\", Duration.ofMillis(50000), Duration.ofMillis(10), false);\n          \n          \n            \n                    final WindowBytesStoreSupplier storeSupplier = \n          \n          \n            \n                        inOrderIterator \n          \n          \n            \n                            ? new InOrderMemoryWindowStoreSupplier(\"InOrder\", 50000L, 10L, false) \n          \n          \n            \n                            : Stores.inMemoryWindowStore(\"Reverse\", ofMillis(50000), ofMillis(10), false);", "url": "https://github.com/apache/kafka/pull/9239#discussion_r487170646", "createdAt": "2020-09-11T16:55:37Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "diffHunk": "@@ -131,14 +157,15 @@ public void testAggregateSmallInput() {\n     public void testReduceSmallInput() {\n         final StreamsBuilder builder = new StreamsBuilder();\n         final String topic = \"topic\";\n+        final WindowBytesStoreSupplier storeSupplier = inOrderIterator ? new InOrderMemoryWindowStoreSupplier(\"InOrder\", 50000L, 10L, false) : Stores.inMemoryWindowStore(\"Reverse\", Duration.ofMillis(50000), Duration.ofMillis(10), false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzExMDA0Mw=="}, "originalCommit": {"oid": "d9387e0341c9aede088d970452439dd28a0aa1ee"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3MTU1NQ==", "bodyText": "But I wouldn't be afraid to just use a full if/else block, either.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final WindowBytesStoreSupplier storeSupplier = inOrderIterator ? new InOrderMemoryWindowStoreSupplier(\"InOrder\", 50000L, 10L, false) : Stores.inMemoryWindowStore(\"Reverse\", Duration.ofMillis(50000), Duration.ofMillis(10), false);\n          \n          \n            \n                    final WindowBytesStoreSupplier storeSupplier;\n          \n          \n            \n                    if (inOrderIterator) {\n          \n          \n            \n                        storeSupplier = new InOrderMemoryWindowStoreSupplier(\"InOrder\", 50000L, 10L, false);\n          \n          \n            \n                    } else {\n          \n          \n            \n                        storeSupplier = Stores.inMemoryWindowStore(\"Reverse\", ofMillis(50000), ofMillis(10), false);\n          \n          \n            \n                    }", "url": "https://github.com/apache/kafka/pull/9239#discussion_r487171555", "createdAt": "2020-09-11T16:57:20Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "diffHunk": "@@ -131,14 +157,15 @@ public void testAggregateSmallInput() {\n     public void testReduceSmallInput() {\n         final StreamsBuilder builder = new StreamsBuilder();\n         final String topic = \"topic\";\n+        final WindowBytesStoreSupplier storeSupplier = inOrderIterator ? new InOrderMemoryWindowStoreSupplier(\"InOrder\", 50000L, 10L, false) : Stores.inMemoryWindowStore(\"Reverse\", Duration.ofMillis(50000), Duration.ofMillis(10), false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzExMDA0Mw=="}, "originalCommit": {"oid": "d9387e0341c9aede088d970452439dd28a0aa1ee"}, "originalPosition": 85}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1985, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}