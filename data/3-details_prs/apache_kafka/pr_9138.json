{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0Njk3OTEy", "number": 9138, "title": "KAFKA-9929: Support backward iterator on WindowStore", "bodyText": "Depends on #9137\nImplements KIP-617 on WindowStore.\nTesting strategy: extend existing tests to validate reverse operations are supported.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-08-07T16:22:27Z", "url": "https://github.com/apache/kafka/pull/9138", "merged": true, "mergeCommit": {"oid": "4f06d9e7d083c30912c810f9deadea809fd74edf"}, "closed": true, "closedAt": "2020-09-02T22:17:08Z", "author": {"login": "jeqo"}, "timelineItems": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc9b014gBqjM2MzczMTgzMjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdE9revAH2gAyNDY0Njk3OTEyOjI3M2Y2MTJiZmU5OGM1OGM0MGU3N2VjOGEyZDc3ZTVlYWJkZDJmMTg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyODM4NDkx", "url": "https://github.com/apache/kafka/pull/9138#pullrequestreview-472838491", "createdAt": "2020-08-21T21:53:45Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQyMTo1Mzo0NVrOHE-2DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQwMDoyOTo0MlrOHFA-VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDk4NTk5Nw==", "bodyText": "Do you know why we have all these ReadOnlyWindowStore methods also declared here in WindowStore? We don't need reverse variations of these I guess? \ud83e\udd14", "url": "https://github.com/apache/kafka/pull/9138#discussion_r474985997", "createdAt": "2020-08-21T21:53:45Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/WindowStore.java", "diffHunk": "@@ -119,15 +118,16 @@\n      * <p>\n      * This iterator must be closed after use.\n      *\n-     * @param from      the first key in the range\n-     * @param to        the last key in the range\n-     * @param timeFrom  time range start (inclusive)\n-     * @param timeTo    time range end (inclusive)\n+     * @param from     the first key in the range\n+     * @param to       the last key in the range\n+     * @param timeFrom time range start (inclusive)\n+     * @param timeTo   time range end (inclusive)\n      * @return an iterator over windowed key-value pairs {@code <Windowed<K>, value>}\n      * @throws InvalidStateStoreException if the store is not initialized\n-     * @throws NullPointerException if one of the given keys is {@code null}\n+     * @throws NullPointerException       if one of the given keys is {@code null}\n      */\n-    @SuppressWarnings(\"deprecation\") // note, this method must be kept if super#fetch(...) is removed\n+    // note, this method must be kept if super#fetch(...) is removed\n+    @SuppressWarnings(\"deprecation\")\n     KeyValueIterator<Windowed<K>, V> fetch(K from, K to, long timeFrom, long timeTo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDk4OTQ0Mw==", "bodyText": "Just noticed that we use == instead of .equals down on line 437, can you fix that on the side?", "url": "https://github.com/apache/kafka/pull/9138#discussion_r474989443", "createdAt": "2020-08-21T22:04:58Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingWindowStore.java", "diffHunk": "@@ -426,7 +558,12 @@ private void getNextSegmentIterator() {\n             setCacheKeyRange(currentSegmentBeginTime(), currentSegmentLastTime());\n \n             current.close();\n-            current = context.cache().range(cacheName, cacheKeyFrom, cacheKeyTo);\n+\n+            if (forward) {\n+                current = context.cache().range(cacheName, cacheKeyFrom, cacheKeyTo);\n+            } else {\n+                current = context.cache().reverseRange(cacheName, cacheKeyFrom, cacheKeyTo);\n+            }\n         }\n \n         private void setCacheKeyRange(final long lowerRangeEndTime, final long upperRangeEndTime) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDk5MTIxNw==", "bodyText": "Github won't let me comment up there but on line 418, shouldn't we should have to decrement the currentSegmentId for the reverse case? I'm a little confused because it looks like you have test coverage for the multi-segment case and it seems to pass. Maybe I'm just tired and missing something obvious here..\nFor example in CachingWindowStoreTest#shouldFetchAndIterateOverKeyBackwardRange the results seem to go across multiple segments, but it looks like we actually do return the record from the largest segment first?", "url": "https://github.com/apache/kafka/pull/9138#discussion_r474991217", "createdAt": "2020-08-21T22:11:12Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingWindowStore.java", "diffHunk": "@@ -426,7 +558,12 @@ private void getNextSegmentIterator() {\n             setCacheKeyRange(currentSegmentBeginTime(), currentSegmentLastTime());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDk5NTYwNg==", "bodyText": "I feel like it's a little awkward to have the reverse variations accept time parameters as an Instant while the forward versions just use a long. I would have thought we could migrate the long methods to Instant at some point but I see all these  note, this method must be kept if super#fetch(...) is removed comments littered throughout the code...so maybe there's a reason for sticking with the long overrides in the innermost store layer?\nDid you come across anything that suggested a reason for keeping the long flavors? cc @guozhangwang or @mjsax -- why can't we remove these?", "url": "https://github.com/apache/kafka/pull/9138#discussion_r474995606", "createdAt": "2020-08-21T22:27:20Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/InMemoryWindowStore.java", "diffHunk": "@@ -163,7 +164,17 @@ public void put(final Bytes key, final byte[] value, final long windowStartTimes\n     @Deprecated\n     @Override\n     public WindowStoreIterator<byte[]> fetch(final Bytes key, final long timeFrom, final long timeTo) {\n+        return fetch(key, timeFrom, timeTo, true);\n+    }\n+\n+    @Override\n+    public WindowStoreIterator<byte[]> backwardFetch(final Bytes key, final Instant from, final Instant to) {\n+        final long timeFrom = ApiUtils.validateMillisecondInstant(from, prepareMillisCheckFailMsgPrefix(from, \"from\"));\n+        final long timeTo = ApiUtils.validateMillisecondInstant(to, prepareMillisCheckFailMsgPrefix(to, \"to\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAwODY0NQ==", "bodyText": "As always Github won't let me comment on the line I actually want to (\ud83d\ude1e ) but I think we need a descending iterator for the reverse case in setRecordIterator (lines 411 & 413)", "url": "https://github.com/apache/kafka/pull/9138#discussion_r475008645", "createdAt": "2020-08-21T23:24:27Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/InMemoryWindowStore.java", "diffHunk": "@@ -419,13 +504,13 @@ Long minTime() {\n         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAxMzkwNw==", "bodyText": "This doesn't look quite right...shouldn't it be D, C, B, A? I guess in the test we just need to use a descending iterator", "url": "https://github.com/apache/kafka/pull/9138#discussion_r475013907", "createdAt": "2020-08-21T23:50:47Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/SegmentIteratorTest.java", "diffHunk": "@@ -107,26 +109,76 @@ public void shouldIterateOverAllSegments() {\n         assertFalse(iterator.hasNext());\n     }\n \n+    @Test\n+    public void shouldIterateBackwardOverAllSegments() {\n+        iterator = new SegmentIterator<>(\n+            Arrays.asList(segmentOne, segmentTwo).iterator(),\n+            hasNextCondition,\n+            Bytes.wrap(\"a\".getBytes()),\n+            Bytes.wrap(\"z\".getBytes()),\n+            false);\n+\n+        assertTrue(iterator.hasNext());\n+        assertEquals(\"b\", new String(iterator.peekNextKey().get()));\n+        assertEquals(KeyValue.pair(\"b\", \"2\"), toStringKeyValue(iterator.next()));\n+\n+        assertTrue(iterator.hasNext());\n+        assertEquals(\"a\", new String(iterator.peekNextKey().get()));\n+        assertEquals(KeyValue.pair(\"a\", \"1\"), toStringKeyValue(iterator.next()));\n+\n+        assertTrue(iterator.hasNext());\n+        assertEquals(\"d\", new String(iterator.peekNextKey().get()));\n+        assertEquals(KeyValue.pair(\"d\", \"4\"), toStringKeyValue(iterator.next()));\n+\n+        assertTrue(iterator.hasNext());\n+        assertEquals(\"c\", new String(iterator.peekNextKey().get()));\n+        assertEquals(KeyValue.pair(\"c\", \"3\"), toStringKeyValue(iterator.next()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAxNDEzNQ==", "bodyText": "This should be a descending iterator for the reverse case (here and the other reverse methods in this class)", "url": "https://github.com/apache/kafka/pull/9138#discussion_r475014135", "createdAt": "2020-08-21T23:51:52Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/AbstractRocksDBSegmentedBytesStore.java", "diffHunk": "@@ -72,22 +86,40 @@\n             searchSpace.iterator(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAxNTg5NQ==", "bodyText": "Need to flip the loop", "url": "https://github.com/apache/kafka/pull/9138#discussion_r475015895", "createdAt": "2020-08-22T00:02:07Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/ReadOnlyWindowStoreStub.java", "diffHunk": "@@ -212,17 +316,62 @@ public boolean hasNext() {\n         };\n     }\n \n-    @Override public KeyValueIterator<Windowed<K>, V> fetch(final K from,\n-                                                            final K to,\n-                                                            final Instant fromTime,\n-                                                            final Instant toTime) throws IllegalArgumentException {\n+    @Override\n+    public KeyValueIterator<Windowed<K>, V> fetch(final K from,\n+                                                  final K to,\n+                                                  final Instant fromTime,\n+                                                  final Instant toTime) throws IllegalArgumentException {\n         return fetch(\n             from,\n-            to, \n+            to,\n             ApiUtils.validateMillisecondInstant(fromTime, prepareMillisCheckFailMsgPrefix(fromTime, \"fromTime\")),\n             ApiUtils.validateMillisecondInstant(toTime, prepareMillisCheckFailMsgPrefix(toTime, \"toTime\")));\n     }\n \n+    @Override\n+    public KeyValueIterator<Windowed<K>, V> backwardFetch(final K from,\n+                                                          final K to,\n+                                                          final Instant fromTimeInstant,\n+                                                          final Instant toTimeInstant) throws IllegalArgumentException {\n+        final long timeFrom = ApiUtils.validateMillisecondInstant(fromTimeInstant, prepareMillisCheckFailMsgPrefix(fromTimeInstant, \"fromTimeInstant\"));\n+        final long timeTo = ApiUtils.validateMillisecondInstant(toTimeInstant, prepareMillisCheckFailMsgPrefix(toTimeInstant, \"toTimeInstant\"));\n+        if (!open) {\n+            throw new InvalidStateStoreException(\"Store is not open\");\n+        }\n+        final List<KeyValue<Windowed<K>, V>> results = new ArrayList<>();\n+        for (long now = timeFrom; now <= timeTo; now++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAxNzE0OQ==", "bodyText": "nit: the existing style here is  inconsistent with the rest of Streams, should have 1st parameter on same line as method declaration (and everything else aligned to that)", "url": "https://github.com/apache/kafka/pull/9138#discussion_r475017149", "createdAt": "2020-08-22T00:10:13Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/MergedSortedCacheWrappedWindowStoreKeyValueIteratorTest.java", "diffHunk": "@@ -123,7 +173,8 @@ public void shouldIterateBothStoreAndCache() {\n \n     private MergedSortedCacheWindowStoreKeyValueIterator createIterator(\n         final Iterator<KeyValue<Windowed<Bytes>, byte[]>> storeKvs,\n-        final Iterator<KeyValue<Bytes, LRUCacheEntry>> cacheKvs\n+        final Iterator<KeyValue<Bytes, LRUCacheEntry>> cacheKvs,\n+        final boolean forward", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAxOTExMw==", "bodyText": "nit: use assertThrows", "url": "https://github.com/apache/kafka/pull/9138#discussion_r475019113", "createdAt": "2020-08-22T00:17:02Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CompositeReadOnlyWindowStoreTest.java", "diffHunk": "@@ -135,24 +188,74 @@ public void shouldThrowInvalidStateStoreExceptionOnRebalance() {\n         store.fetch(\"key\", ofEpochMilli(1), ofEpochMilli(10));\n     }\n \n+    @Test(expected = InvalidStateStoreException.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAyMDg4NQ==", "bodyText": "We should start on the largest segment I think (largest segment == farthest advanced in time)", "url": "https://github.com/apache/kafka/pull/9138#discussion_r475020885", "createdAt": "2020-08-22T00:29:42Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingWindowStore.java", "diffHunk": "@@ -337,25 +462,32 @@ public synchronized void close() {\n \n         private CacheIteratorWrapper(final Bytes key,\n                                      final long timeFrom,\n-                                     final long timeTo) {\n-            this(key, key, timeFrom, timeTo);\n+                                     final long timeTo,\n+                                     final boolean forward) {\n+            this(key, key, timeFrom, timeTo, forward);\n         }\n \n         private CacheIteratorWrapper(final Bytes keyFrom,\n                                      final Bytes keyTo,\n                                      final long timeFrom,\n-                                     final long timeTo) {\n+                                     final long timeTo,\n+                                     final boolean forward) {\n             this.keyFrom = keyFrom;\n             this.keyTo = keyTo;\n             this.timeTo = timeTo;\n             this.lastSegmentId = cacheFunction.segmentId(Math.min(timeTo, maxObservedTimestamp.get()));\n+            this.forward = forward;\n \n             this.segmentInterval = cacheFunction.getSegmentInterval();\n             this.currentSegmentId = cacheFunction.segmentId(timeFrom);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 304}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "900639bf632cb5dd9ca3568f312a3e6159014db1", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/900639bf632cb5dd9ca3568f312a3e6159014db1", "committedDate": "2020-08-22T16:47:53Z", "message": "key/value reverse operations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37c340e81494e396fbf7d052654c3bd3f9aff580", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/37c340e81494e396fbf7d052654c3bd3f9aff580", "committedDate": "2020-08-22T16:49:31Z", "message": "improve ordering docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92dcec1b20248ef0647323471892f711ad5c7b71", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/92dcec1b20248ef0647323471892f711ad5c7b71", "committedDate": "2020-08-22T16:53:15Z", "message": "fix range validator not needed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26048cf65d3f8f5552d774e3c735233c76462a90", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/26048cf65d3f8f5552d774e3c735233c76462a90", "committedDate": "2020-08-22T17:00:06Z", "message": "improve tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07530e91e9913e6ecc0fe9995a25594a4fbb3a26", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/07530e91e9913e6ecc0fe9995a25594a4fbb3a26", "committedDate": "2020-08-22T17:06:19Z", "message": "improve range wrong order warning"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a733d3fe6056c44e11c6e7a5a0b40873f570aca3", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/a733d3fe6056c44e11c6e7a5a0b40873f570aca3", "committedDate": "2020-08-22T17:06:20Z", "message": "key/value reverse operation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "843980ba4eb35e67409f759f8af3be3991e8e4c1", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/843980ba4eb35e67409f759f8af3be3991e8e4c1", "committedDate": "2020-08-22T17:06:20Z", "message": "window backward operations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8fc3a44eb0f225a40ae8a2f5385397285697253", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/a8fc3a44eb0f225a40ae8a2f5385397285697253", "committedDate": "2020-08-22T17:06:20Z", "message": "small additions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39405c6adfc0d330ee80c2ac1659365ec411fb82", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/39405c6adfc0d330ee80c2ac1659365ec411fb82", "committedDate": "2020-08-22T17:06:21Z", "message": "rearrange code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1893fc1eaaa8792478b5ef11e4fe2412e6e73dec", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/1893fc1eaaa8792478b5ef11e4fe2412e6e73dec", "committedDate": "2020-08-22T17:06:21Z", "message": "improve time range comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f24e38ba26b5fd945df04e36afba12df08005783", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/f24e38ba26b5fd945df04e36afba12df08005783", "committedDate": "2020-08-22T17:06:21Z", "message": "fix bytes range validator not needed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cf2297e96bed7d5af34983b5445fca9c7d7d35e", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/2cf2297e96bed7d5af34983b5445fca9c7d7d35e", "committedDate": "2020-08-22T17:06:21Z", "message": "fix cache iterator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24b6e71cddcebb96645f7e7ba36f64403d9cc3fe", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/24b6e71cddcebb96645f7e7ba36f64403d9cc3fe", "committedDate": "2020-08-22T17:06:22Z", "message": "fix syntax"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56630d2a81cd4731382ebc1c12c971a3115c2620", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/56630d2a81cd4731382ebc1c12c971a3115c2620", "committedDate": "2020-08-22T17:06:22Z", "message": "improve tests exception handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92e39ff2375e0b4ebd7aca9eeacfb208b34ef0da", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/92e39ff2375e0b4ebd7aca9eeacfb208b34ef0da", "committedDate": "2020-08-22T17:06:22Z", "message": "fix ordered set"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a428d3d6abc5c2bc4f8210950269cd3a1f65941", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/2a428d3d6abc5c2bc4f8210950269cd3a1f65941", "committedDate": "2020-08-22T17:06:23Z", "message": "replace reverse with forward"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0871d19e1ef14a5fd56a56c8ec9725cb8fcbd29a", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/0871d19e1ef14a5fd56a56c8ec9725cb8fcbd29a", "committedDate": "2020-08-22T17:06:23Z", "message": "replace backward with forward flag"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "0871d19e1ef14a5fd56a56c8ec9725cb8fcbd29a", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/0871d19e1ef14a5fd56a56c8ec9725cb8fcbd29a", "committedDate": "2020-08-22T17:06:23Z", "message": "replace backward with forward flag"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07557b40127cfbb457686dc1bc262492546bface", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/07557b40127cfbb457686dc1bc262492546bface", "committedDate": "2020-08-24T21:18:01Z", "message": "apply suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33ee2a1039d922fb91af8b9d75c94be8fdbbbb5e", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/33ee2a1039d922fb91af8b9d75c94be8fdbbbb5e", "committedDate": "2020-08-24T23:38:27Z", "message": "fix: iterate segments backwards"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8725a7ea27db07273e9c19ec196f5b66c2d69f83", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/8725a7ea27db07273e9c19ec196f5b66c2d69f83", "committedDate": "2020-08-25T08:50:02Z", "message": "fix iteration"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1MDkxNzAz", "url": "https://github.com/apache/kafka/pull/9138#pullrequestreview-475091703", "createdAt": "2020-08-26T01:36:07Z", "commit": {"oid": "8725a7ea27db07273e9c19ec196f5b66c2d69f83"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwMTozNjowN1rOHG3H5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwMTo1NToxOFrOHG37dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njk1NjY0NA==", "bodyText": "I guess we should use the long signature here too, and do the conversion from Instant to long in a default implementation on the WindowStore interface?", "url": "https://github.com/apache/kafka/pull/9138#discussion_r476956644", "createdAt": "2020-08-26T01:36:07Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingWindowStore.java", "diffHunk": "@@ -201,18 +203,48 @@ public synchronized void put(final Bytes key,\n         }\n \n         final PeekingKeyValueIterator<Bytes, LRUCacheEntry> cacheIterator = wrapped().persistent() ?\n-            new CacheIteratorWrapper(key, timeFrom, timeTo) :\n-            context.cache().range(cacheName,\n-                        cacheFunction.cacheKey(keySchema.lowerRangeFixedSize(key, timeFrom)),\n-                        cacheFunction.cacheKey(keySchema.upperRangeFixedSize(key, timeTo))\n+            new CacheIteratorWrapper(key, timeFrom, timeTo, true) :\n+            context.cache().range(\n+                cacheName,\n+                cacheFunction.cacheKey(keySchema.lowerRangeFixedSize(key, timeFrom)),\n+                cacheFunction.cacheKey(keySchema.upperRangeFixedSize(key, timeTo))\n             );\n \n         final HasNextCondition hasNextCondition = keySchema.hasNextCondition(key, key, timeFrom, timeTo);\n-        final PeekingKeyValueIterator<Bytes, LRUCacheEntry> filteredCacheIterator = new FilteredCacheIterator(\n-            cacheIterator, hasNextCondition, cacheFunction\n-        );\n+        final PeekingKeyValueIterator<Bytes, LRUCacheEntry> filteredCacheIterator =\n+            new FilteredCacheIterator(cacheIterator, hasNextCondition, cacheFunction);\n \n-        return new MergedSortedCacheWindowStoreIterator(filteredCacheIterator, underlyingIterator);\n+        return new MergedSortedCacheWindowStoreIterator(filteredCacheIterator, underlyingIterator, true);\n+    }\n+\n+    @Override\n+    public synchronized WindowStoreIterator<byte[]> backwardFetch(final Bytes key,\n+                                                                  final Instant from,\n+                                                                  final Instant to) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8725a7ea27db07273e9c19ec196f5b66c2d69f83"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njk2MjA3NQ==", "bodyText": "Guessing this is not actually meant to be commented out \ud83d\ude42", "url": "https://github.com/apache/kafka/pull/9138#discussion_r476962075", "createdAt": "2020-08-26T01:44:13Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingWindowStore.java", "diffHunk": "@@ -416,26 +552,43 @@ private long currentSegmentLastTime() {\n         }\n \n         private void getNextSegmentIterator() {\n-            ++currentSegmentId;\n-            lastSegmentId = cacheFunction.segmentId(Math.min(timeTo, maxObservedTimestamp.get()));\n+            if (forward) {\n+                ++currentSegmentId;\n+                lastSegmentId = cacheFunction.segmentId(Math.min(timeTo, maxObservedTimestamp.get()));\n \n-            if (currentSegmentId > lastSegmentId) {\n-                current = null;\n-                return;\n-            }\n+                if (currentSegmentId > lastSegmentId) {\n+                    current = null;\n+                    return;\n+                }\n \n-            setCacheKeyRange(currentSegmentBeginTime(), currentSegmentLastTime());\n+                setCacheKeyRange(currentSegmentBeginTime(), currentSegmentLastTime());\n \n-            current.close();\n-            current = context.cache().range(cacheName, cacheKeyFrom, cacheKeyTo);\n+                current.close();\n+\n+                current = context.cache().range(cacheName, cacheKeyFrom, cacheKeyTo);\n+            } else {\n+                --currentSegmentId;\n+//                lastSegmentId = cacheFunction.segmentId(Math.min(timeTo, maxObservedTimestamp.get()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8725a7ea27db07273e9c19ec196f5b66c2d69f83"}, "originalPosition": 350}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njk2NTM5Nw==", "bodyText": "It feels kind of ridiculous to convert this from a list to a set to an array all in one line. Maybe we can use assertThat(result, equalTo(expectedResult)) here like we've started to do elsewhere in Streams?", "url": "https://github.com/apache/kafka/pull/9138#discussion_r476965397", "createdAt": "2020-08-26T01:49:05Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/AbstractWindowBytesStoreTest.java", "diffHunk": "@@ -287,17 +308,43 @@ public void shouldFetchAllInTimeRange() {\n         final KeyValue<Windowed<Integer>, String> four = windowedPair(4, \"four\", startTime + 4);\n         final KeyValue<Windowed<Integer>, String> five = windowedPair(5, \"five\", startTime + 5);\n \n-        assertEquals(\n-            new HashSet<>(asList(one, two, four)),\n-            toSet(windowStore.fetchAll(ofEpochMilli(startTime + 1), ofEpochMilli(startTime + 4)))\n+        assertArrayEquals(\n+            new LinkedHashSet<>(asList(one, two, four)).toArray(),\n+            toSet(windowStore.fetchAll(ofEpochMilli(startTime + 1), ofEpochMilli(startTime + 4))).toArray()\n         );\n-        assertEquals(\n-            new HashSet<>(asList(zero, one, two)),\n-            toSet(windowStore.fetchAll(ofEpochMilli(startTime + 0), ofEpochMilli(startTime + 3)))\n+        assertArrayEquals(\n+            new LinkedHashSet<>(asList(zero, one, two)).toArray(),\n+            toSet(windowStore.fetchAll(ofEpochMilli(startTime + 0), ofEpochMilli(startTime + 3))).toArray()\n         );\n-        assertEquals(\n-            new HashSet<>(asList(one, two, four, five)),\n-            toSet(windowStore.fetchAll(ofEpochMilli(startTime + 1), ofEpochMilli(startTime + 5)))\n+        assertArrayEquals(\n+            new LinkedHashSet<>(asList(one, two, four, five)).toArray(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8725a7ea27db07273e9c19ec196f5b66c2d69f83"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njk2OTg0Nw==", "bodyText": "Same here (and all the backwards ReadOnlyWindowStoreStub methods): I think we are kind of forced to invert the key ordering for the backwards fetch methods as well, even if we don't necessarily want to. Probably users shouldn't be relying on a strict ordering of the keys anyway but we do have to match the ordering of the cache", "url": "https://github.com/apache/kafka/pull/9138#discussion_r476969847", "createdAt": "2020-08-26T01:55:18Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/ReadOnlyWindowStoreStub.java", "diffHunk": "@@ -104,7 +121,47 @@ public V fetch(final K key, final long time) {\n \n         return new KeyValueIterator<Windowed<K>, V>() {\n             @Override\n-            public void close() {}\n+            public void close() {\n+            }\n+\n+            @Override\n+            public Windowed<K> peekNextKey() {\n+                throw new UnsupportedOperationException(\"peekNextKey() not supported in \" + getClass().getName());\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                return iterator.hasNext();\n+            }\n+\n+            @Override\n+            public KeyValue<Windowed<K>, V> next() {\n+                return iterator.next();\n+            }\n+\n+        };\n+    }\n+\n+    @Override\n+    public KeyValueIterator<Windowed<K>, V> backwardAll() {\n+        if (!open) {\n+            throw new InvalidStateStoreException(\"Store is not open\");\n+        }\n+        final List<KeyValue<Windowed<K>, V>> results = new ArrayList<>();\n+        for (final long now : data.keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8725a7ea27db07273e9c19ec196f5b66c2d69f83"}, "originalPosition": 71}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86932775070f2c33eedacbb9341c5f819bdd0cf1", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/86932775070f2c33eedacbb9341c5f819bdd0cf1", "committedDate": "2020-08-26T16:32:07Z", "message": "remove commented code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f81ba3985722efb1469dd653c44e8a2c17d1d8d", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/4f81ba3985722efb1469dd653c44e8a2c17d1d8d", "committedDate": "2020-08-27T09:50:11Z", "message": "adding long variant to backward methods."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a98827659a461e32641ea9781476b829f41e1c14", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/a98827659a461e32641ea9781476b829f41e1c14", "committedDate": "2020-08-27T14:18:39Z", "message": "fix: remove redundant array/set/list equals assertions"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MTc2NTY2", "url": "https://github.com/apache/kafka/pull/9138#pullrequestreview-477176566", "createdAt": "2020-08-28T01:00:19Z", "commit": {"oid": "8725a7ea27db07273e9c19ec196f5b66c2d69f83"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMTowMDoyMFrOHImDsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMTowMDoyMFrOHImDsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc3NDE5NQ==", "bodyText": "@jeqo I saw that you fixed this in ReadOnlyWindowStoreStub, I think InMemoryWindowStore is the only places that's still missing to reverse the key ordering on the backwards fetch methods", "url": "https://github.com/apache/kafka/pull/9138#discussion_r478774195", "createdAt": "2020-08-28T01:00:20Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/InMemoryWindowStore.java", "diffHunk": "@@ -419,13 +504,13 @@ Long minTime() {\n         }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAwODY0NQ=="}, "originalCommit": null, "originalPosition": 241}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4Nzk0NTQx", "url": "https://github.com/apache/kafka/pull/9138#pullrequestreview-478794541", "createdAt": "2020-08-31T17:14:18Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5MDI5MDYw", "url": "https://github.com/apache/kafka/pull/9138#pullrequestreview-479029060", "createdAt": "2020-08-31T23:10:23Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzoxMDoyM1rOHKNGmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMzozNjoxOVrOHKNy5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ2MjQ5MA==", "bodyText": "nit: is this intentional? Also I'd suggest we do not use capitalized If to be consistent with the above line, ditto elsewhere below.", "url": "https://github.com/apache/kafka/pull/9138#discussion_r480462490", "createdAt": "2020-08-31T23:10:23Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/ReadOnlyWindowStore.java", "diffHunk": "@@ -33,11 +33,11 @@\n     /**\n      * Get the value of key from a window.\n      *\n-     * @param key       the key to fetch\n-     * @param time      start timestamp (inclusive) of the window\n+     * @param key  the key to fetch\n+     * @param time start timestamp (inclusive) of the window\n      * @return The value or {@code null} if no value is found in the window\n      * @throws InvalidStateStoreException if the store is not initialized\n-     * @throws NullPointerException If {@code null} is used for any key.\n+     * @throws NullPointerException       If {@code null} is used for any key.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ2NTE1MA==", "bodyText": "Since we are going to remove deprecated overloads with primitive long in the future, I think we do not need to expose a default function here, but just provide a default impl of the function in 204 below as UnsupportedOperation?", "url": "https://github.com/apache/kafka/pull/9138#discussion_r480465150", "createdAt": "2020-08-31T23:14:27Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/WindowStore.java", "diffHunk": "@@ -150,13 +185,25 @@\n      * @return an iterator over windowed key-value pairs {@code <Windowed<K>, value>}\n      * @throws InvalidStateStoreException if the store is not initialized\n      */\n-    @SuppressWarnings(\"deprecation\") // note, this method must be kept if super#fetchAll(...) is removed\n+    // note, this method must be kept if super#fetchAll(...) is removed\n+    @SuppressWarnings(\"deprecation\")\n     KeyValueIterator<Windowed<K>, V> fetchAll(long timeFrom, long timeTo);\n \n     @Override\n-    default KeyValueIterator<Windowed<K>, V> fetchAll(final Instant from, final Instant to) {\n+    default KeyValueIterator<Windowed<K>, V> fetchAll(final Instant timeFrom, final Instant timeTo) {\n         return fetchAll(\n-            ApiUtils.validateMillisecondInstant(from, prepareMillisCheckFailMsgPrefix(from, \"from\")),\n-            ApiUtils.validateMillisecondInstant(to, prepareMillisCheckFailMsgPrefix(to, \"to\")));\n+            ApiUtils.validateMillisecondInstant(timeFrom, prepareMillisCheckFailMsgPrefix(timeFrom, \"timeFrom\")),\n+            ApiUtils.validateMillisecondInstant(timeTo, prepareMillisCheckFailMsgPrefix(timeTo, \"timeTo\")));\n+    }\n+\n+    default KeyValueIterator<Windowed<K>, V> backwardFetchAll(final long timeFrom, final long timeTo) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ2OTY4OA==", "bodyText": "This is out of the scope of this PR, but I'd like to point out that the current IQ does not actually obey the ordering when there are multiple local stores hosted on that instance. For example, if there are two stores from two tasks hosting keys {1, 3} and {2,4}, then a range query of key [1,4] would return in the order of 1,3,2,4 but not 1,2,3,4 since it is looping over the stores only. This would be the case for either forward or backward fetches on range-key-range-time.\nFor single key time range fetch, or course, there's no such issue.\nI think it worth documenting this for now until we have a fix (and actually we are going to propose something soon).", "url": "https://github.com/apache/kafka/pull/9138#discussion_r480469688", "createdAt": "2020-08-31T23:23:00Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/ReadOnlyWindowStore.java", "diffHunk": "@@ -136,34 +174,64 @@\n      * <p>\n      * This iterator must be closed after use.\n      *\n-     * @param from      the first key in the range\n-     * @param to        the last key in the range\n-     * @param fromTime  time range start (inclusive)\n-     * @param toTime    time range end (inclusive)\n-     * @return an iterator over windowed key-value pairs {@code <Windowed<K>, value>}\n+     * @param from     the first key in the range\n+     * @param to       the last key in the range\n+     * @param timeFrom time range start (inclusive), where iteration starts.\n+     * @param timeTo   time range end (inclusive), where iteration ends.\n+     * @return an iterator over windowed key-value pairs {@code <Windowed<K>, value>}, from beginning to end of time.\n      * @throws InvalidStateStoreException if the store is not initialized\n-     * @throws NullPointerException If {@code null} is used for any key.\n-     * @throws IllegalArgumentException if duration is negative or can't be represented as {@code long milliseconds}\n+     * @throws NullPointerException       If {@code null} is used for any key.\n+     * @throws IllegalArgumentException   if duration is negative or can't be represented as {@code long milliseconds}\n      */\n-    KeyValueIterator<Windowed<K>, V> fetch(K from, K to, Instant fromTime, Instant toTime)\n+    KeyValueIterator<Windowed<K>, V> fetch(K from, K to, Instant timeFrom, Instant timeTo)\n         throws IllegalArgumentException;\n \n     /**\n-    * Gets all the key-value pairs in the existing windows.\n-    *\n-    * @return an iterator over windowed key-value pairs {@code <Windowed<K>, value>}\n-    * @throws InvalidStateStoreException if the store is not initialized\n-    */\n+     * Get all the key-value pairs in the given key range and time range from all the existing windows\n+     * in backward order with respect to time (from end to beginning of time).\n+     * <p>\n+     * This iterator must be closed after use.\n+     *\n+     * @param from     the first key in the range\n+     * @param to       the last key in the range\n+     * @param timeFrom time range start (inclusive), where iteration ends.\n+     * @param timeTo   time range end (inclusive), where iteration starts.\n+     * @return an iterator over windowed key-value pairs {@code <Windowed<K>, value>}, from end to beginning of time.\n+     * @throws InvalidStateStoreException if the store is not initialized\n+     * @throws NullPointerException       If {@code null} is used for any key.\n+     * @throws IllegalArgumentException   if duration is negative or can't be represented as {@code long milliseconds}\n+     */\n+    KeyValueIterator<Windowed<K>, V> backwardFetch(K from, K to, Instant timeFrom, Instant timeTo)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3MDEzNA==", "bodyText": "Is this intentional? We usually have a newline at file end in case some specific IDEs do not like otherwise.", "url": "https://github.com/apache/kafka/pull/9138#discussion_r480470134", "createdAt": "2020-08-31T23:24:30Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/AbstractMergedSortedCacheStoreIterator.java", "diffHunk": "@@ -192,4 +192,3 @@ public void close() {\n         storeIterator.close();\n     }\n }\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3MDY0NA==", "bodyText": "nit: we can just call subMap out of the condition and only call descendingMap() based on the condition.", "url": "https://github.com/apache/kafka/pull/9138#discussion_r480470644", "createdAt": "2020-08-31T23:26:01Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/AbstractSegments.java", "diffHunk": "@@ -117,12 +118,20 @@ public void openExisting(final ProcessorContext context, final long streamTime)\n     }\n \n     @Override\n-    public List<S> segments(final long timeFrom, final long timeTo) {\n+    public List<S> segments(final long timeFrom, final long timeTo, final boolean forward) {\n         final List<S> result = new ArrayList<>();\n-        final NavigableMap<Long, S> segmentsInRange = segments.subMap(\n-            segmentId(timeFrom), true,\n-            segmentId(timeTo), true\n-        );\n+        final NavigableMap<Long, S> segmentsInRange;\n+        if (forward) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3MTE3Ng==", "bodyText": "See my other comments: I think we do not need to add overloads for primitive types for the newly added APIs?", "url": "https://github.com/apache/kafka/pull/9138#discussion_r480471176", "createdAt": "2020-08-31T23:27:40Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingWindowStore.java", "diffHunk": "@@ -271,27 +345,68 @@ public synchronized void put(final Bytes key,\n         final PeekingKeyValueIterator<Bytes, LRUCacheEntry> filteredCacheIterator =\n             new FilteredCacheIterator(cacheIterator, hasNextCondition, cacheFunction);\n         return new MergedSortedCacheWindowStoreKeyValueIterator(\n-                filteredCacheIterator,\n-                underlyingIterator,\n-                bytesSerdes,\n-                windowSize,\n-                cacheFunction\n+            filteredCacheIterator,\n+            underlyingIterator,\n+            bytesSerdes,\n+            windowSize,\n+            cacheFunction,\n+            true\n+        );\n+    }\n+\n+    @Override\n+    public KeyValueIterator<Windowed<Bytes>, byte[]> backwardFetchAll(final long timeFrom,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3MjQyNA==", "bodyText": "Why this call is different based on the forward boolean? It's not clear to me. cc @ableegoldman @lct45 could you double check?", "url": "https://github.com/apache/kafka/pull/9138#discussion_r480472424", "createdAt": "2020-08-31T23:31:42Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingWindowStore.java", "diffHunk": "@@ -338,25 +452,36 @@ public synchronized void close() {\n \n         private CacheIteratorWrapper(final Bytes key,\n                                      final long timeFrom,\n-                                     final long timeTo) {\n-            this(key, key, timeFrom, timeTo);\n+                                     final long timeTo,\n+                                     final boolean forward) {\n+            this(key, key, timeFrom, timeTo, forward);\n         }\n \n         private CacheIteratorWrapper(final Bytes keyFrom,\n                                      final Bytes keyTo,\n                                      final long timeFrom,\n-                                     final long timeTo) {\n+                                     final long timeTo,\n+                                     final boolean forward) {\n             this.keyFrom = keyFrom;\n             this.keyTo = keyTo;\n             this.timeTo = timeTo;\n-            this.lastSegmentId = cacheFunction.segmentId(Math.min(timeTo, maxObservedTimestamp.get()));\n+            this.forward = forward;\n \n             this.segmentInterval = cacheFunction.getSegmentInterval();\n-            this.currentSegmentId = cacheFunction.segmentId(timeFrom);\n \n-            setCacheKeyRange(timeFrom, currentSegmentLastTime());\n+            if (forward) {\n+                this.lastSegmentId = cacheFunction.segmentId(Math.min(timeTo, maxObservedTimestamp.get()));\n+                this.currentSegmentId = cacheFunction.segmentId(timeFrom);\n \n-            this.current = context.cache().range(cacheName, cacheKeyFrom, cacheKeyTo);\n+                setCacheKeyRange(timeFrom, currentSegmentLastTime());\n+                this.current = context.cache().range(cacheName, cacheKeyFrom, cacheKeyTo);\n+            } else {\n+                this.currentSegmentId = cacheFunction.segmentId(Math.min(timeTo, maxObservedTimestamp.get()));\n+                this.lastSegmentId = cacheFunction.segmentId(timeFrom);\n+\n+                setCacheKeyRange(currentSegmentBeginTime(), Math.min(timeTo, maxObservedTimestamp.get()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ3MzgzMA==", "bodyText": "This is not directly related to this PR, but it makes me wondering: why do we keep a separate range / all in extended Segment interface? Should we just remove that? Now we've added the reverse ones but only in the parent interface, it makes me feeling the original ones on Segment is not necessary.", "url": "https://github.com/apache/kafka/pull/9138#discussion_r480473830", "createdAt": "2020-08-31T23:36:19Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/SegmentIterator.java", "diffHunk": "@@ -67,14 +70,22 @@ public Bytes peekNextKey() {\n     public boolean hasNext() {\n         boolean hasNext = false;\n         while ((currentIterator == null || !(hasNext = hasNextConditionHasNext()) || !currentSegment.isOpen())\n-                && segments.hasNext()) {\n+            && segments.hasNext()) {\n             close();\n             currentSegment = segments.next();\n             try {\n                 if (from == null || to == null) {\n-                    currentIterator = currentSegment.all();\n+                    if (forward) {\n+                        currentIterator = currentSegment.all();\n+                    } else {\n+                        currentIterator = currentSegment.reverseAll();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ec40063d629db053853b5c77caa535b5644edd9", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/4ec40063d629db053853b5c77caa535b5644edd9", "committedDate": "2020-09-01T18:13:40Z", "message": "fix exception comment case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "814ef3bcc82bc1241d5b732c2ce1e00c2308cb73", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/814ef3bcc82bc1241d5b732c2ce1e00c2308cb73", "committedDate": "2020-09-02T08:59:18Z", "message": "align var names and exceptions"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "814ef3bcc82bc1241d5b732c2ce1e00c2308cb73", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/814ef3bcc82bc1241d5b732c2ce1e00c2308cb73", "committedDate": "2020-09-02T08:59:18Z", "message": "align var names and exceptions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58ce1d2d1eea3757548cd8975fe3213804d16b21", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/58ce1d2d1eea3757548cd8975fe3213804d16b21", "committedDate": "2020-09-02T14:02:39Z", "message": "fix check style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f66f247a7e76907caebb44c33d1e562bd707f51a", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/f66f247a7e76907caebb44c33d1e562bd707f51a", "committedDate": "2020-09-02T14:16:17Z", "message": "fix check style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ccaa57d3e3e7953619c35933c257c416ecca01b", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/1ccaa57d3e3e7953619c35933c257c416ecca01b", "committedDate": "2020-09-02T14:40:06Z", "message": "range and all already available on kvstore"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "273f612bfe98c58c40e77ec8a2d77e5eabdd2f18", "author": {"user": {"login": "jeqo", "name": "Jorge Esteban Quilcate Otoya"}}, "url": "https://github.com/apache/kafka/commit/273f612bfe98c58c40e77ec8a2d77e5eabdd2f18", "committedDate": "2020-09-02T15:24:38Z", "message": "add default impl"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1084, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}