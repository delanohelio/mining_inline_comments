{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxNjQyNzky", "number": 8457, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDozMTowNFrODxYKLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDozMTowNFrODxYKLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzMTAyNjM3OnYy", "diffSide": "RIGHT", "path": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/FetcherTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QyMDozMTowNFrOGE0M9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwMDoxODowNVrOGE5rZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwMjc3NA==", "bodyText": "So here we are checking that the request sent from validateOffsetsIfNeeded only includes the partitions whose leader is the current node? If the match fails do we get a nice junit assertion failure, or some funky mockito stack trace?", "url": "https://github.com/apache/kafka/pull/8457#discussion_r407702774", "createdAt": "2020-04-13T20:31:04Z", "author": {"login": "mumrah"}, "path": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/FetcherTest.java", "diffHunk": "@@ -3555,6 +3556,60 @@ public void testSubscriptionPositionUpdatedWithEpoch() {\n         assertOptional(subscriptions.position(tp0).offsetEpoch, value -> assertEquals(value.intValue(), 1));\n     }\n \n+    @Test\n+    public void testOffsetValidationRequestGrouping() {\n+        buildFetcher();\n+        assignFromUser(Utils.mkSet(tp0, tp1, tp2, tp3));\n+\n+        metadata.updateWithCurrentRequestVersion(TestUtils.metadataUpdateWith(\"dummy\", 3,\n+            Collections.emptyMap(), singletonMap(topicName, 4),\n+            tp -> 5), false, 0L);\n+\n+        for (TopicPartition tp : subscriptions.assignedPartitions()) {\n+            Metadata.LeaderAndEpoch leaderAndEpoch = new Metadata.LeaderAndEpoch(\n+                metadata.currentLeader(tp).leader, Optional.of(4));\n+            subscriptions.seekUnvalidated(tp,\n+                new SubscriptionState.FetchPosition(0, Optional.of(4), leaderAndEpoch));\n+        }\n+\n+        Set<TopicPartition> allRequestedPartitions = new HashSet<>();\n+\n+        for (Node node : metadata.fetch().nodes()) {\n+            apiVersions.update(node.idString(), NodeApiVersions.create());\n+\n+            Set<TopicPartition> expectedPartitions = subscriptions.assignedPartitions().stream()\n+                .filter(tp ->\n+                    metadata.currentLeader(tp).leader.equals(Optional.of(node)))\n+                .collect(Collectors.toSet());\n+\n+            assertTrue(expectedPartitions.stream().noneMatch(allRequestedPartitions::contains));\n+            assertTrue(expectedPartitions.size() > 0);\n+            allRequestedPartitions.addAll(expectedPartitions);\n+\n+            Map<TopicPartition, EpochEndOffset> endOffsets = expectedPartitions.stream().collect(Collectors.toMap(\n+                Function.identity(),\n+                tp -> new EpochEndOffset(Errors.NONE, 4, 0)\n+            ));\n+\n+            OffsetsForLeaderEpochResponse response = new OffsetsForLeaderEpochResponse(endOffsets);\n+            client.prepareResponseFrom(new MockClient.RequestMatcher() {\n+                @Override\n+                public boolean matches(AbstractRequest body) {\n+                    OffsetsForLeaderEpochRequest request = (OffsetsForLeaderEpochRequest) body;\n+                    return expectedPartitions.equals(request.epochsByTopicPartition().keySet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "201a4ec4651149aa0150f622915da4fe760628ab"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc5MjQ4Ng==", "bodyText": "You would get a message like this:\nRequest matcher did not match next-in-line request {replica_id=-1,topics=[{topic=test,partitions=[{partition=2,current_leader_epoch=5,leader_epoch=4}]}]} with prepared response (type=OffsetsForLeaderEpochResponse, , throttleTimeMs=0, epochEndOffsetsByPartition={test-2=EpochEndOffset{error=NONE, leaderEpoch=4, endOffset=0}})\n\nwhich I think is reasonable.", "url": "https://github.com/apache/kafka/pull/8457#discussion_r407792486", "createdAt": "2020-04-14T00:18:05Z", "author": {"login": "hachikuji"}, "path": "clients/src/test/java/org/apache/kafka/clients/consumer/internals/FetcherTest.java", "diffHunk": "@@ -3555,6 +3556,60 @@ public void testSubscriptionPositionUpdatedWithEpoch() {\n         assertOptional(subscriptions.position(tp0).offsetEpoch, value -> assertEquals(value.intValue(), 1));\n     }\n \n+    @Test\n+    public void testOffsetValidationRequestGrouping() {\n+        buildFetcher();\n+        assignFromUser(Utils.mkSet(tp0, tp1, tp2, tp3));\n+\n+        metadata.updateWithCurrentRequestVersion(TestUtils.metadataUpdateWith(\"dummy\", 3,\n+            Collections.emptyMap(), singletonMap(topicName, 4),\n+            tp -> 5), false, 0L);\n+\n+        for (TopicPartition tp : subscriptions.assignedPartitions()) {\n+            Metadata.LeaderAndEpoch leaderAndEpoch = new Metadata.LeaderAndEpoch(\n+                metadata.currentLeader(tp).leader, Optional.of(4));\n+            subscriptions.seekUnvalidated(tp,\n+                new SubscriptionState.FetchPosition(0, Optional.of(4), leaderAndEpoch));\n+        }\n+\n+        Set<TopicPartition> allRequestedPartitions = new HashSet<>();\n+\n+        for (Node node : metadata.fetch().nodes()) {\n+            apiVersions.update(node.idString(), NodeApiVersions.create());\n+\n+            Set<TopicPartition> expectedPartitions = subscriptions.assignedPartitions().stream()\n+                .filter(tp ->\n+                    metadata.currentLeader(tp).leader.equals(Optional.of(node)))\n+                .collect(Collectors.toSet());\n+\n+            assertTrue(expectedPartitions.stream().noneMatch(allRequestedPartitions::contains));\n+            assertTrue(expectedPartitions.size() > 0);\n+            allRequestedPartitions.addAll(expectedPartitions);\n+\n+            Map<TopicPartition, EpochEndOffset> endOffsets = expectedPartitions.stream().collect(Collectors.toMap(\n+                Function.identity(),\n+                tp -> new EpochEndOffset(Errors.NONE, 4, 0)\n+            ));\n+\n+            OffsetsForLeaderEpochResponse response = new OffsetsForLeaderEpochResponse(endOffsets);\n+            client.prepareResponseFrom(new MockClient.RequestMatcher() {\n+                @Override\n+                public boolean matches(AbstractRequest body) {\n+                    OffsetsForLeaderEpochRequest request = (OffsetsForLeaderEpochRequest) body;\n+                    return expectedPartitions.equals(request.epochsByTopicPartition().keySet());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcwMjc3NA=="}, "originalCommit": {"oid": "201a4ec4651149aa0150f622915da4fe760628ab"}, "originalPosition": 52}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2959, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}