{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE3NjUyNDAy", "number": 9576, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowNTo0M1rOE3IHZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowNTo0M1rOE3IHZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2MjQwMTAxOnYy", "diffSide": "LEFT", "path": "clients/src/main/java/org/apache/kafka/common/utils/Utils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowNTo0M1rOHwSkSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowNTo0M1rOHwSkSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5Nzg5Ng==", "bodyText": "It'll never be null or empty for the secondPart because we split(\"T\") without the 2nd argument, and it'll call with split(\"T\", 0). And from the javadoc:\n\nIf n is zero then the pattern will be applied as many times as possible, the array can have any length, and trailing empty strings will be discarded.\n\nhttps://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-int-", "url": "https://github.com/apache/kafka/pull/9576#discussion_r520397896", "createdAt": "2020-11-10T09:05:43Z", "author": {"login": "showuon"}, "path": "clients/src/main/java/org/apache/kafka/common/utils/Utils.java", "diffHunk": "@@ -1281,30 +1281,36 @@ private static byte checkRange(final byte i) {\n \n     /**\n      * Convert timestamp to an epoch value\n-     * @param timestamp to be converted\n-     * @return epoch value of a given timestamp\n-     * @throws ParseException for timestamp that doesn't follow ISO8601 format\n-     */\n-    public static long getDateTime(String timestamp) throws ParseException {\n+     * @param timestamp the timestamp to be converted, the accepted formats are: 2020-11-10T16:51:38.145, 2020-11-10T16:51:38.198+0800,\n+     *                  2020-11-10T16:51:38.198+08, 2020-11-10T16:51:38.199+0800, and 2020-11-10T16:51:38.199+08:00\n+     * @return epoch value of a given timestamp (i.e. the number of milliseconds since January 1, 1970, 00:00:00 GMT)\n+     * @throws ParseException for timestamp that doesn't follow ISO8601 format or the format is not expected\n+     */\n+    public static long getDateTime(String timestamp) throws ParseException, IllegalArgumentException {\n+        if (timestamp == null) {\n+            throw new IllegalArgumentException(\"Error parsing timestamp with null value\");\n+        }\n+\n         final String[] timestampParts = timestamp.split(\"T\");\n         if (timestampParts.length < 2) {\n             throw new ParseException(\"Error parsing timestamp. It does not contain a 'T' according to ISO8601 format\", timestamp.length());\n         }\n \n         final String secondPart = timestampParts[1];\n-        if (secondPart == null || secondPart.isEmpty()) {\n-            throw new ParseException(\"Error parsing timestamp. Time part after 'T' is null or empty\", timestamp.length());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3829, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}