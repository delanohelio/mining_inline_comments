{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczMzg1MzI4", "number": 8083, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNjo0OToxMlrODmxDLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNzoyNzo0OFrODmyCuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxOTc2MTExOnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/common/quota/QuotaFilter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNjo0OToxMlrOF0XyfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMDowNToxNlrOF0lLcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ2MDAyOA==", "bodyText": "Can we use Optional<String> for this?  Using magic string values feels messy, and will leak into the API", "url": "https://github.com/apache/kafka/pull/8083#discussion_r390460028", "createdAt": "2020-03-10T16:49:12Z", "author": {"login": "cmccabe"}, "path": "clients/src/main/java/org/apache/kafka/common/quota/QuotaFilter.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.quota;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Describes a quota entity filter.\n+ */\n+public class QuotaFilter {\n+\n+    // Matches all entities with the entity type specified.\n+    private static final String MATCH_SPECIFIED = \"\";\n+\n+    private final String entityType;\n+    private final String match;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY3OTQxMA==", "bodyText": "Done.", "url": "https://github.com/apache/kafka/pull/8083#discussion_r390679410", "createdAt": "2020-03-11T00:05:16Z", "author": {"login": "bdbyrne"}, "path": "clients/src/main/java/org/apache/kafka/common/quota/QuotaFilter.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.quota;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Describes a quota entity filter.\n+ */\n+public class QuotaFilter {\n+\n+    // Matches all entities with the entity type specified.\n+    private static final String MATCH_SPECIFIED = \"\";\n+\n+    private final String entityType;\n+    private final String match;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ2MDAyOA=="}, "originalCommit": null, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxOTkwNjgzOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/AdminManager.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNzoyMzozMVrOF0ZOBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMDowNjo0NFrOF0lM9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ4MzQ2MQ==", "bodyText": "I'd really rather not see the double equals used with strings.  I know Scala has special semantics for this, but it always looks wrong to people familiar with Java.  Maybe test isEmpty instead?", "url": "https://github.com/apache/kafka/pull/8083#discussion_r390483461", "createdAt": "2020-03-10T17:23:31Z", "author": {"login": "cmccabe"}, "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -700,4 +702,176 @@ class AdminManager(val config: KafkaConfig,\n     val readOnly = !DynamicBrokerConfig.AllDynamicConfigs.contains(name)\n     new DescribeConfigsResponse.ConfigEntry(name, valueAsString, source, isSensitive, readOnly, synonyms.asJava)\n   }\n+\n+  private def entityToSanitizedUserClientId(entity: QuotaEntity): (Option[String], Option[String]) = {\n+    if (entity.entries.isEmpty)\n+      throw new InvalidRequestException(\"Invalid empty quota entity\")\n+\n+    var user: Option[String] = None\n+    var clientId: Option[String] = None\n+    entity.entries().asScala.foreach { case (entityType, entityName) =>\n+      val sanitizedEntityName = Some(Sanitizer.sanitize(entityName))\n+      entityType match {\n+        case QuotaEntity.USER => user = sanitizedEntityName\n+        case QuotaEntity.CLIENT_ID => clientId = sanitizedEntityName\n+        case _ => throw new InvalidRequestException(s\"Unhandled quota entity type: ${entityType}\")\n+      }\n+      if (entityName == \"\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY3OTc5Ng==", "bodyText": "Done.", "url": "https://github.com/apache/kafka/pull/8083#discussion_r390679796", "createdAt": "2020-03-11T00:06:44Z", "author": {"login": "bdbyrne"}, "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -700,4 +702,176 @@ class AdminManager(val config: KafkaConfig,\n     val readOnly = !DynamicBrokerConfig.AllDynamicConfigs.contains(name)\n     new DescribeConfigsResponse.ConfigEntry(name, valueAsString, source, isSensitive, readOnly, synonyms.asJava)\n   }\n+\n+  private def entityToSanitizedUserClientId(entity: QuotaEntity): (Option[String], Option[String]) = {\n+    if (entity.entries.isEmpty)\n+      throw new InvalidRequestException(\"Invalid empty quota entity\")\n+\n+    var user: Option[String] = None\n+    var clientId: Option[String] = None\n+    entity.entries().asScala.foreach { case (entityType, entityName) =>\n+      val sanitizedEntityName = Some(Sanitizer.sanitize(entityName))\n+      entityType match {\n+        case QuotaEntity.USER => user = sanitizedEntityName\n+        case QuotaEntity.CLIENT_ID => clientId = sanitizedEntityName\n+        case _ => throw new InvalidRequestException(s\"Unhandled quota entity type: ${entityType}\")\n+      }\n+      if (entityName == \"\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ4MzQ2MQ=="}, "originalCommit": null, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxOTkxMzE4OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/server/AdminManager.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNzoyNToyMVrOF0ZSPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMDowODowOFrOF0lOTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ4NDU0Mg==", "bodyText": "If it's not supported, it shouldn't silently return incorrect data.  It should throw an UnsupportedVersionException", "url": "https://github.com/apache/kafka/pull/8083#discussion_r390484542", "createdAt": "2020-03-10T17:25:21Z", "author": {"login": "cmccabe"}, "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -700,4 +702,176 @@ class AdminManager(val config: KafkaConfig,\n     val readOnly = !DynamicBrokerConfig.AllDynamicConfigs.contains(name)\n     new DescribeConfigsResponse.ConfigEntry(name, valueAsString, source, isSensitive, readOnly, synonyms.asJava)\n   }\n+\n+  private def entityToSanitizedUserClientId(entity: QuotaEntity): (Option[String], Option[String]) = {\n+    if (entity.entries.isEmpty)\n+      throw new InvalidRequestException(\"Invalid empty quota entity\")\n+\n+    var user: Option[String] = None\n+    var clientId: Option[String] = None\n+    entity.entries().asScala.foreach { case (entityType, entityName) =>\n+      val sanitizedEntityName = Some(Sanitizer.sanitize(entityName))\n+      entityType match {\n+        case QuotaEntity.USER => user = sanitizedEntityName\n+        case QuotaEntity.CLIENT_ID => clientId = sanitizedEntityName\n+        case _ => throw new InvalidRequestException(s\"Unhandled quota entity type: ${entityType}\")\n+      }\n+      if (entityName == \"\")\n+        throw new InvalidRequestException(s\"Empty ${entityType} not supported\")\n+    }\n+    (user, clientId)\n+  }\n+\n+  private def userClientIdToEntity(user: Option[String], clientId: Option[String]): QuotaEntity = {\n+    new QuotaEntity((user.map(u => QuotaEntity.USER -> u) ++ clientId.map(c => QuotaEntity.CLIENT_ID -> c)).toMap.asJava)\n+  }\n+\n+  def describeClientQuotas(filters: Seq[QuotaFilter], includeUnspecifiedTypes: Boolean): Map[QuotaEntity, Map[String, Double]] = {\n+    var userFilter: Option[QuotaFilter] = None\n+    var clientIdFilter: Option[QuotaFilter] = None\n+    var otherFilter: Boolean = false\n+    filters.foreach { filter =>\n+      filter.entityType() match {\n+        case QuotaEntity.USER =>\n+          if (userFilter.isDefined)\n+            throw new InvalidRequestException(s\"Duplicate user filter entity type\");\n+          userFilter = Some(filter)\n+        case QuotaEntity.CLIENT_ID =>\n+          if (clientIdFilter.isDefined)\n+            throw new InvalidRequestException(s\"Duplicate client filter entity type\");\n+          clientIdFilter = Some(filter)\n+        case \"\" =>\n+          throw new InvalidRequestException(s\"Unexpected empty filter entity type\")\n+        case _ =>\n+          // Supplying other entity types is not yet supported.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY4MDE0MA==", "bodyText": "Done.", "url": "https://github.com/apache/kafka/pull/8083#discussion_r390680140", "createdAt": "2020-03-11T00:08:08Z", "author": {"login": "bdbyrne"}, "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -700,4 +702,176 @@ class AdminManager(val config: KafkaConfig,\n     val readOnly = !DynamicBrokerConfig.AllDynamicConfigs.contains(name)\n     new DescribeConfigsResponse.ConfigEntry(name, valueAsString, source, isSensitive, readOnly, synonyms.asJava)\n   }\n+\n+  private def entityToSanitizedUserClientId(entity: QuotaEntity): (Option[String], Option[String]) = {\n+    if (entity.entries.isEmpty)\n+      throw new InvalidRequestException(\"Invalid empty quota entity\")\n+\n+    var user: Option[String] = None\n+    var clientId: Option[String] = None\n+    entity.entries().asScala.foreach { case (entityType, entityName) =>\n+      val sanitizedEntityName = Some(Sanitizer.sanitize(entityName))\n+      entityType match {\n+        case QuotaEntity.USER => user = sanitizedEntityName\n+        case QuotaEntity.CLIENT_ID => clientId = sanitizedEntityName\n+        case _ => throw new InvalidRequestException(s\"Unhandled quota entity type: ${entityType}\")\n+      }\n+      if (entityName == \"\")\n+        throw new InvalidRequestException(s\"Empty ${entityType} not supported\")\n+    }\n+    (user, clientId)\n+  }\n+\n+  private def userClientIdToEntity(user: Option[String], clientId: Option[String]): QuotaEntity = {\n+    new QuotaEntity((user.map(u => QuotaEntity.USER -> u) ++ clientId.map(c => QuotaEntity.CLIENT_ID -> c)).toMap.asJava)\n+  }\n+\n+  def describeClientQuotas(filters: Seq[QuotaFilter], includeUnspecifiedTypes: Boolean): Map[QuotaEntity, Map[String, Double]] = {\n+    var userFilter: Option[QuotaFilter] = None\n+    var clientIdFilter: Option[QuotaFilter] = None\n+    var otherFilter: Boolean = false\n+    filters.foreach { filter =>\n+      filter.entityType() match {\n+        case QuotaEntity.USER =>\n+          if (userFilter.isDefined)\n+            throw new InvalidRequestException(s\"Duplicate user filter entity type\");\n+          userFilter = Some(filter)\n+        case QuotaEntity.CLIENT_ID =>\n+          if (clientIdFilter.isDefined)\n+            throw new InvalidRequestException(s\"Duplicate client filter entity type\");\n+          clientIdFilter = Some(filter)\n+        case \"\" =>\n+          throw new InvalidRequestException(s\"Unexpected empty filter entity type\")\n+        case _ =>\n+          // Supplying other entity types is not yet supported.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ4NDU0Mg=="}, "originalCommit": null, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxOTkyMzc2OnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/common/quota/QuotaFilter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNzoyNzo0OFrOF0ZY5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQwMDowNTo1NlrOF0lMHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ4NjI0NQ==", "bodyText": "Need to update this JavaDoc parameter to match the new name of the function parameter.", "url": "https://github.com/apache/kafka/pull/8083#discussion_r390486245", "createdAt": "2020-03-10T17:27:48Z", "author": {"login": "cmccabe"}, "path": "clients/src/main/java/org/apache/kafka/common/quota/QuotaFilter.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.quota;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Describes a quota entity filter.\n+ */\n+public class QuotaFilter {\n+\n+    // Matches all entities with the entity type specified.\n+    private static final String MATCH_SPECIFIED = \"\";\n+\n+    private final String entityType;\n+    private final String match;\n+\n+    /**\n+     * A filter to be applied.\n+     *\n+     * @param entityType the entity type the filter applies to\n+     * @param match the string that's matched exactly\n+     */\n+    private QuotaFilter(String entityType, String match) {\n+        this.entityType = Objects.requireNonNull(entityType);\n+        this.match = Objects.requireNonNull(match);\n+    }\n+\n+    /**\n+     * Constructs and returns a quota filter that matches the provided entity\n+     * name for the entity type exactly.\n+     *\n+     * @param entityType the entity type the filter applies to\n+     * @param match the string that's matched exactly", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY3OTU4MA==", "bodyText": "Done.", "url": "https://github.com/apache/kafka/pull/8083#discussion_r390679580", "createdAt": "2020-03-11T00:05:56Z", "author": {"login": "bdbyrne"}, "path": "clients/src/main/java/org/apache/kafka/common/quota/QuotaFilter.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.kafka.common.quota;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Describes a quota entity filter.\n+ */\n+public class QuotaFilter {\n+\n+    // Matches all entities with the entity type specified.\n+    private static final String MATCH_SPECIFIED = \"\";\n+\n+    private final String entityType;\n+    private final String match;\n+\n+    /**\n+     * A filter to be applied.\n+     *\n+     * @param entityType the entity type the filter applies to\n+     * @param match the string that's matched exactly\n+     */\n+    private QuotaFilter(String entityType, String match) {\n+        this.entityType = Objects.requireNonNull(entityType);\n+        this.match = Objects.requireNonNull(match);\n+    }\n+\n+    /**\n+     * Constructs and returns a quota filter that matches the provided entity\n+     * name for the entity type exactly.\n+     *\n+     * @param entityType the entity type the filter applies to\n+     * @param match the string that's matched exactly", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ4NjI0NQ=="}, "originalCommit": null, "originalPosition": 49}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4252, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}