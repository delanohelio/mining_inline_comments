{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyMTA4NDMz", "number": 8054, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTo1MDozMlrODeKTxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzo1MDowN1rODe5sbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTUyNzc1OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTo1MDozMlrOFnLUKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTo1MDozMlrOFnLUKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyNDE3MA==", "bodyText": "Defining the pseudo-topics up front to make sure they're used consistently. Also, I used abbreviations for the suffixes, since these topic names are already quite long.", "url": "https://github.com/apache/kafka/pull/8054#discussion_r376624170", "createdAt": "2020-02-07T21:50:32Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KTableImpl.java", "diffHunk": "@@ -952,23 +952,34 @@ boolean sendingOldValueEnabled() {\n         //This occurs whenever the extracted foreignKey changes values.\n         enableSendingOldValues();\n \n-        final Serde<KO> foreignKeySerde = ((KTableImpl<KO, VO, ?>) foreignKeyTable).keySerde;\n-        final Serde<SubscriptionWrapper<K>> subscriptionWrapperSerde = new SubscriptionWrapperSerde<>(keySerde);\n-        final SubscriptionResponseWrapperSerde<VO> responseWrapperSerde =\n-            new SubscriptionResponseWrapperSerde<>(((KTableImpl<KO, VO, VO>) foreignKeyTable).valSerde);\n \n \n         final NamedInternal renamed = new NamedInternal(joinName);\n         final String subscriptionTopicName = renamed.suffixWithOrElseGet(\"-subscription-registration\", builder, SUBSCRIPTION_REGISTRATION) + TOPIC_SUFFIX;\n+        final String subscriptionPrimaryKeySerdePseudoTopic = subscriptionTopicName + \"-pk\";\n+        final String subscriptionForeignKeySerdePseudoTopic = subscriptionTopicName + \"-fk\";\n+        final String valueHashSerdePseudoTopic = subscriptionTopicName + \"-vh\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTU0MTkwOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/foreignkeyjoin/SubscriptionWrapperSerde.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTo1NjoyN1rOFnLc0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDozNjo0NlrOFoYMag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyNjM4NA==", "bodyText": "We're ignoring the passed-in topic so that we can use the same pseudo-topic to (de)serialize the primary key as we do elsewhere. Also because the values in the passed-in topic is not the result of primaryKeySerializer.serialize(...,data.getPrimaryKey()), but is rather a bigger data structure that contains that data. So, we can avoid misleading users for whom a schema registry would claim that the subscription topic has a certain schema when in fact it doesn't. Now, it would tell them that the PK pseudo-topic has that schema, which at least can't be inconsistent with data they might observe in Kafka.", "url": "https://github.com/apache/kafka/pull/8054#discussion_r376626384", "createdAt": "2020-02-07T21:56:27Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/foreignkeyjoin/SubscriptionWrapperSerde.java", "diffHunk": "@@ -43,21 +46,28 @@ public SubscriptionWrapperSerde(final Serde<K> primaryKeySerde) {\n     }\n \n     private static class SubscriptionWrapperSerializer<K> implements Serializer<SubscriptionWrapper<K>> {\n+        private final String primaryKeySerializationPseudoTopic;\n         private final Serializer<K> primaryKeySerializer;\n-        SubscriptionWrapperSerializer(final Serializer<K> primaryKeySerializer) {\n+\n+        SubscriptionWrapperSerializer(final String primaryKeySerializationPseudoTopic,\n+                                      final Serializer<K> primaryKeySerializer) {\n+            this.primaryKeySerializationPseudoTopic = primaryKeySerializationPseudoTopic;\n             this.primaryKeySerializer = primaryKeySerializer;\n         }\n \n         @Override\n-        public byte[] serialize(final String topic, final SubscriptionWrapper<K> data) {\n+        public byte[] serialize(final String ignored, final SubscriptionWrapper<K> data) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwMDYwNA==", "bodyText": "qq For my own education: what would be the topic name for this subscription topic? For my understanding that topic name is not the same as primaryKeySerializationPseudoTopic, but I cannot remember why we decided to do so.", "url": "https://github.com/apache/kafka/pull/8054#discussion_r377800604", "createdAt": "2020-02-11T17:56:47Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/foreignkeyjoin/SubscriptionWrapperSerde.java", "diffHunk": "@@ -43,21 +46,28 @@ public SubscriptionWrapperSerde(final Serde<K> primaryKeySerde) {\n     }\n \n     private static class SubscriptionWrapperSerializer<K> implements Serializer<SubscriptionWrapper<K>> {\n+        private final String primaryKeySerializationPseudoTopic;\n         private final Serializer<K> primaryKeySerializer;\n-        SubscriptionWrapperSerializer(final Serializer<K> primaryKeySerializer) {\n+\n+        SubscriptionWrapperSerializer(final String primaryKeySerializationPseudoTopic,\n+                                      final Serializer<K> primaryKeySerializer) {\n+            this.primaryKeySerializationPseudoTopic = primaryKeySerializationPseudoTopic;\n             this.primaryKeySerializer = primaryKeySerializer;\n         }\n \n         @Override\n-        public byte[] serialize(final String topic, final SubscriptionWrapper<K> data) {\n+        public byte[] serialize(final String ignored, final SubscriptionWrapper<K> data) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyNjM4NA=="}, "originalCommit": null, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg4Mzc1NA==", "bodyText": "Hey @guozhangwang , the actual subscription topic name is defined here: https://github.com/apache/kafka/pull/8054/files#diff-05872eec0e2733128854406f87979013R959\nfinal String subscriptionTopicName = renamed.suffixWithOrElseGet(\"-subscription-registration\", builder, SUBSCRIPTION_REGISTRATION) + TOPIC_SUFFIX;\n\nThe reason we're not using that topic name for the \"primary key\" (which is actually part of the value here) is what I explained above. I see that my statement wasn't super clear, though...\n\nwe're already using that pseudo-topic for the primary key in the CombinedKeySchema, so we can avoid proliferating schemas we're registering\nusing the subscription topic would mean that we register the primary key as the \"value serde\" of the subscription topic, but the values in the topic are actually SubscriptionWrappers, not primary keys. So it would actually be misleading to use the subscription topic for this purpose. At least for the pseudo-topic, it doesn't actually exist in the brokers, so it's not possible to have an inconsistency between the registered serde and the log data.\n\nThe actual data in the subscription topic is like:\nkey: foreign key; value: subscription-wrapper (contains the primary-key)", "url": "https://github.com/apache/kafka/pull/8054#discussion_r377883754", "createdAt": "2020-02-11T20:36:46Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/foreignkeyjoin/SubscriptionWrapperSerde.java", "diffHunk": "@@ -43,21 +46,28 @@ public SubscriptionWrapperSerde(final Serde<K> primaryKeySerde) {\n     }\n \n     private static class SubscriptionWrapperSerializer<K> implements Serializer<SubscriptionWrapper<K>> {\n+        private final String primaryKeySerializationPseudoTopic;\n         private final Serializer<K> primaryKeySerializer;\n-        SubscriptionWrapperSerializer(final Serializer<K> primaryKeySerializer) {\n+\n+        SubscriptionWrapperSerializer(final String primaryKeySerializationPseudoTopic,\n+                                      final Serializer<K> primaryKeySerializer) {\n+            this.primaryKeySerializationPseudoTopic = primaryKeySerializationPseudoTopic;\n             this.primaryKeySerializer = primaryKeySerializer;\n         }\n \n         @Override\n-        public byte[] serialize(final String topic, final SubscriptionWrapper<K> data) {\n+        public byte[] serialize(final String ignored, final SubscriptionWrapper<K> data) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyNjM4NA=="}, "originalCommit": null, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTU0NjEwOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/utils/UniqueTopicSerdeScope.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTo1ODoyMVrOFnLfdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTo1ODoyMVrOFnLfdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyNzA2MQ==", "bodyText": "This is how I verified this fix. Using this class to decorate all the serdes in a topology, we can ensure that we never try and write heterogeneous-typed data to a topic.", "url": "https://github.com/apache/kafka/pull/8054#discussion_r376627061", "createdAt": "2020-02-07T21:58:21Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/utils/UniqueTopicSerdeScope.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.utils;\n+\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Deserializer;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class UniqueTopicSerdeScope {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTU0ODU4OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/integration/KTableKTableForeignKeyInnerJoinMultiIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMTo1OToyOFrOFnLg-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODowMToyOVrOFoTR4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyNzQ1MQ==", "bodyText": "To verify the fix, we create a \"scope\", which will wrap all our serdes and make sure that we never try to write differently typed data to the same topic.", "url": "https://github.com/apache/kafka/pull/8054#discussion_r376627451", "createdAt": "2020-02-07T21:59:28Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/KTableKTableForeignKeyInnerJoinMultiIntegrationTest.java", "diffHunk": "@@ -206,17 +207,30 @@ private void verifyKTableKTableJoin(final JoinType joinType,\n     }\n \n     private KafkaStreams prepareTopology(final String queryableName, final String queryableNameTwo) {\n+        final UniqueTopicSerdeScope serdeScope = new UniqueTopicSerdeScope();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwMzIzNQ==", "bodyText": "Great idea.", "url": "https://github.com/apache/kafka/pull/8054#discussion_r377803235", "createdAt": "2020-02-11T18:01:29Z", "author": {"login": "guozhangwang"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/KTableKTableForeignKeyInnerJoinMultiIntegrationTest.java", "diffHunk": "@@ -206,17 +207,30 @@ private void verifyKTableKTableJoin(final JoinType joinType,\n     }\n \n     private KafkaStreams prepareTopology(final String queryableName, final String queryableNameTwo) {\n+        final UniqueTopicSerdeScope serdeScope = new UniqueTopicSerdeScope();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyNzQ1MQ=="}, "originalCommit": null, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTU1MTE5OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/integration/KTableKTableForeignKeyInnerJoinMultiIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMjowMDo0MVrOFnLikw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMjowMDo0MVrOFnLikw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyNzg1OQ==", "bodyText": "We decorate each serde in the topology. This also has the side benefit of actually configuring the serdes, which we've usually neglected to do. Particularly, the last argument configures the serde as a \"key\" or \"value\" serde.", "url": "https://github.com/apache/kafka/pull/8054#discussion_r376627859", "createdAt": "2020-02-07T22:00:41Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/KTableKTableForeignKeyInnerJoinMultiIntegrationTest.java", "diffHunk": "@@ -206,17 +207,30 @@ private void verifyKTableKTableJoin(final JoinType joinType,\n     }\n \n     private KafkaStreams prepareTopology(final String queryableName, final String queryableNameTwo) {\n+        final UniqueTopicSerdeScope serdeScope = new UniqueTopicSerdeScope();\n         final StreamsBuilder builder = new StreamsBuilder();\n \n-        final KTable<Integer, Float> table1 = builder.table(TABLE_1, Consumed.with(Serdes.Integer(), Serdes.Float()));\n-        final KTable<String, Long> table2 = builder.table(TABLE_2, Consumed.with(Serdes.String(), Serdes.Long()));\n-        final KTable<Integer, String> table3 = builder.table(TABLE_3, Consumed.with(Serdes.Integer(), Serdes.String()));\n+        final KTable<Integer, Float> table1 = builder.table(\n+            TABLE_1,\n+            Consumed.with(serdeScope.decorateSerde(Serdes.Integer(), streamsConfig, true),\n+                          serdeScope.decorateSerde(Serdes.Float(), streamsConfig, false))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTU1MjgwOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/utils/UniqueTopicSerdeScope.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMjowMToxNlrOFnLjgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDozOTowNFrOFoYQjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyODA5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                System.out.printf(\"storing key[%s] data[%s][%s]%n\", key, data, data.getClass());", "url": "https://github.com/apache/kafka/pull/8054#discussion_r376628099", "createdAt": "2020-02-07T22:01:16Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/utils/UniqueTopicSerdeScope.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.utils;\n+\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Deserializer;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class UniqueTopicSerdeScope {\n+    private final Map<String, Class<?>> topicTypeRegistry = new TreeMap<>();\n+\n+    public <T> UniqueTopicSerdeDecorator<T> decorateSerde(final Serde<T> delegate,\n+                                                          final Properties config,\n+                                                          final boolean isKey) {\n+        final UniqueTopicSerdeDecorator<T> decorator = new UniqueTopicSerdeDecorator<>(delegate);\n+        decorator.configure(config.entrySet().stream().collect(Collectors.toMap(e -> e.getKey().toString(), Map.Entry::getValue)), isKey);\n+        return decorator;\n+    }\n+\n+    public class UniqueTopicSerdeDecorator<T> implements Serde<T> {\n+        private final AtomicBoolean isKey = new AtomicBoolean(false);\n+        private final Serde<T> delegate;\n+\n+        public UniqueTopicSerdeDecorator(final Serde<T> delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public void configure(final Map<String, ?> configs, final boolean isKey) {\n+            delegate.configure(configs, isKey);\n+            this.isKey.set(isKey);\n+        }\n+\n+        @Override\n+        public void close() {\n+            delegate.close();\n+        }\n+\n+        @Override\n+        public Serializer<T> serializer() {\n+            return new UniqueTopicSerializerDecorator<>(isKey, delegate.serializer());\n+        }\n+\n+        @Override\n+        public Deserializer<T> deserializer() {\n+            return new UniqueTopicDeserializerDecorator<>(isKey, delegate.deserializer());\n+        }\n+    }\n+\n+    public class UniqueTopicSerializerDecorator<T> implements Serializer<T> {\n+        private final AtomicBoolean isKey;\n+        private final Serializer<T> delegate;\n+\n+        public UniqueTopicSerializerDecorator(final AtomicBoolean isKey, final Serializer<T> delegate) {\n+            this.isKey = isKey;\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public void configure(final Map<String, ?> configs, final boolean isKey) {\n+            delegate.configure(configs, isKey);\n+            this.isKey.set(isKey);\n+        }\n+\n+        @Override\n+        public byte[] serialize(final String topic, final T data) {\n+            verifyTopic(topic, data);\n+            return delegate.serialize(topic, data);\n+        }\n+\n+        @Override\n+        public byte[] serialize(final String topic, final Headers headers, final T data) {\n+            verifyTopic(topic, data);\n+            return delegate.serialize(topic, headers, data);\n+        }\n+\n+        private void verifyTopic(final String topic, final T data) {\n+            if (data != null) {\n+                final String key = topic + (isKey.get() ? \"--key\" : \"--value\");\n+                if (topicTypeRegistry.containsKey(key)) {\n+                    assertThat(String.format(\"key[%s] data[%s][%s]\", key, data, data.getClass()), topicTypeRegistry.get(key), equalTo(data.getClass()));\n+                } else {\n+                    System.out.printf(\"storing key[%s] data[%s][%s]%n\", key, data, data.getClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwMzgxMA==", "bodyText": "Suggesting a commit to your own PR? seems they are the same :P", "url": "https://github.com/apache/kafka/pull/8054#discussion_r377803810", "createdAt": "2020-02-11T18:02:34Z", "author": {"login": "guozhangwang"}, "path": "streams/src/test/java/org/apache/kafka/streams/utils/UniqueTopicSerdeScope.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.utils;\n+\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Deserializer;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class UniqueTopicSerdeScope {\n+    private final Map<String, Class<?>> topicTypeRegistry = new TreeMap<>();\n+\n+    public <T> UniqueTopicSerdeDecorator<T> decorateSerde(final Serde<T> delegate,\n+                                                          final Properties config,\n+                                                          final boolean isKey) {\n+        final UniqueTopicSerdeDecorator<T> decorator = new UniqueTopicSerdeDecorator<>(delegate);\n+        decorator.configure(config.entrySet().stream().collect(Collectors.toMap(e -> e.getKey().toString(), Map.Entry::getValue)), isKey);\n+        return decorator;\n+    }\n+\n+    public class UniqueTopicSerdeDecorator<T> implements Serde<T> {\n+        private final AtomicBoolean isKey = new AtomicBoolean(false);\n+        private final Serde<T> delegate;\n+\n+        public UniqueTopicSerdeDecorator(final Serde<T> delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public void configure(final Map<String, ?> configs, final boolean isKey) {\n+            delegate.configure(configs, isKey);\n+            this.isKey.set(isKey);\n+        }\n+\n+        @Override\n+        public void close() {\n+            delegate.close();\n+        }\n+\n+        @Override\n+        public Serializer<T> serializer() {\n+            return new UniqueTopicSerializerDecorator<>(isKey, delegate.serializer());\n+        }\n+\n+        @Override\n+        public Deserializer<T> deserializer() {\n+            return new UniqueTopicDeserializerDecorator<>(isKey, delegate.deserializer());\n+        }\n+    }\n+\n+    public class UniqueTopicSerializerDecorator<T> implements Serializer<T> {\n+        private final AtomicBoolean isKey;\n+        private final Serializer<T> delegate;\n+\n+        public UniqueTopicSerializerDecorator(final AtomicBoolean isKey, final Serializer<T> delegate) {\n+            this.isKey = isKey;\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public void configure(final Map<String, ?> configs, final boolean isKey) {\n+            delegate.configure(configs, isKey);\n+            this.isKey.set(isKey);\n+        }\n+\n+        @Override\n+        public byte[] serialize(final String topic, final T data) {\n+            verifyTopic(topic, data);\n+            return delegate.serialize(topic, data);\n+        }\n+\n+        @Override\n+        public byte[] serialize(final String topic, final Headers headers, final T data) {\n+            verifyTopic(topic, data);\n+            return delegate.serialize(topic, headers, data);\n+        }\n+\n+        private void verifyTopic(final String topic, final T data) {\n+            if (data != null) {\n+                final String key = topic + (isKey.get() ? \"--key\" : \"--value\");\n+                if (topicTypeRegistry.containsKey(key)) {\n+                    assertThat(String.format(\"key[%s] data[%s][%s]\", key, data, data.getClass()), topicTypeRegistry.get(key), equalTo(data.getClass()));\n+                } else {\n+                    System.out.printf(\"storing key[%s] data[%s][%s]%n\", key, data, data.getClass());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyODA5OQ=="}, "originalCommit": null, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg4NDgxMg==", "bodyText": "Oops, that was just a self-suggestion to delete the line, which I forgot to actually click on.", "url": "https://github.com/apache/kafka/pull/8054#discussion_r377884812", "createdAt": "2020-02-11T20:39:04Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/utils/UniqueTopicSerdeScope.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.utils;\n+\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Deserializer;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class UniqueTopicSerdeScope {\n+    private final Map<String, Class<?>> topicTypeRegistry = new TreeMap<>();\n+\n+    public <T> UniqueTopicSerdeDecorator<T> decorateSerde(final Serde<T> delegate,\n+                                                          final Properties config,\n+                                                          final boolean isKey) {\n+        final UniqueTopicSerdeDecorator<T> decorator = new UniqueTopicSerdeDecorator<>(delegate);\n+        decorator.configure(config.entrySet().stream().collect(Collectors.toMap(e -> e.getKey().toString(), Map.Entry::getValue)), isKey);\n+        return decorator;\n+    }\n+\n+    public class UniqueTopicSerdeDecorator<T> implements Serde<T> {\n+        private final AtomicBoolean isKey = new AtomicBoolean(false);\n+        private final Serde<T> delegate;\n+\n+        public UniqueTopicSerdeDecorator(final Serde<T> delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public void configure(final Map<String, ?> configs, final boolean isKey) {\n+            delegate.configure(configs, isKey);\n+            this.isKey.set(isKey);\n+        }\n+\n+        @Override\n+        public void close() {\n+            delegate.close();\n+        }\n+\n+        @Override\n+        public Serializer<T> serializer() {\n+            return new UniqueTopicSerializerDecorator<>(isKey, delegate.serializer());\n+        }\n+\n+        @Override\n+        public Deserializer<T> deserializer() {\n+            return new UniqueTopicDeserializerDecorator<>(isKey, delegate.deserializer());\n+        }\n+    }\n+\n+    public class UniqueTopicSerializerDecorator<T> implements Serializer<T> {\n+        private final AtomicBoolean isKey;\n+        private final Serializer<T> delegate;\n+\n+        public UniqueTopicSerializerDecorator(final AtomicBoolean isKey, final Serializer<T> delegate) {\n+            this.isKey = isKey;\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public void configure(final Map<String, ?> configs, final boolean isKey) {\n+            delegate.configure(configs, isKey);\n+            this.isKey.set(isKey);\n+        }\n+\n+        @Override\n+        public byte[] serialize(final String topic, final T data) {\n+            verifyTopic(topic, data);\n+            return delegate.serialize(topic, data);\n+        }\n+\n+        @Override\n+        public byte[] serialize(final String topic, final Headers headers, final T data) {\n+            verifyTopic(topic, data);\n+            return delegate.serialize(topic, headers, data);\n+        }\n+\n+        private void verifyTopic(final String topic, final T data) {\n+            if (data != null) {\n+                final String key = topic + (isKey.get() ? \"--key\" : \"--value\");\n+                if (topicTypeRegistry.containsKey(key)) {\n+                    assertThat(String.format(\"key[%s] data[%s][%s]\", key, data, data.getClass()), topicTypeRegistry.get(key), equalTo(data.getClass()));\n+                } else {\n+                    System.out.printf(\"storing key[%s] data[%s][%s]%n\", key, data, data.getClass());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyODA5OQ=="}, "originalCommit": null, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTU1NTE5OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/utils/UniqueTopicSerdeScope.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMjowMjoyMVrOFnLk_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMjowMjoyMVrOFnLk_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjYyODQ3OQ==", "bodyText": "Here's where the assertion takes place. A nice thing about this approach is that you don't have to make any extra assertions in the tests, you just decorate the serdes, and the assertions happen automatically when you run the program.", "url": "https://github.com/apache/kafka/pull/8054#discussion_r376628479", "createdAt": "2020-02-07T22:02:21Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/utils/UniqueTopicSerdeScope.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.utils;\n+\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Deserializer;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class UniqueTopicSerdeScope {\n+    private final Map<String, Class<?>> topicTypeRegistry = new TreeMap<>();\n+\n+    public <T> UniqueTopicSerdeDecorator<T> decorateSerde(final Serde<T> delegate,\n+                                                          final Properties config,\n+                                                          final boolean isKey) {\n+        final UniqueTopicSerdeDecorator<T> decorator = new UniqueTopicSerdeDecorator<>(delegate);\n+        decorator.configure(config.entrySet().stream().collect(Collectors.toMap(e -> e.getKey().toString(), Map.Entry::getValue)), isKey);\n+        return decorator;\n+    }\n+\n+    public class UniqueTopicSerdeDecorator<T> implements Serde<T> {\n+        private final AtomicBoolean isKey = new AtomicBoolean(false);\n+        private final Serde<T> delegate;\n+\n+        public UniqueTopicSerdeDecorator(final Serde<T> delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public void configure(final Map<String, ?> configs, final boolean isKey) {\n+            delegate.configure(configs, isKey);\n+            this.isKey.set(isKey);\n+        }\n+\n+        @Override\n+        public void close() {\n+            delegate.close();\n+        }\n+\n+        @Override\n+        public Serializer<T> serializer() {\n+            return new UniqueTopicSerializerDecorator<>(isKey, delegate.serializer());\n+        }\n+\n+        @Override\n+        public Deserializer<T> deserializer() {\n+            return new UniqueTopicDeserializerDecorator<>(isKey, delegate.deserializer());\n+        }\n+    }\n+\n+    public class UniqueTopicSerializerDecorator<T> implements Serializer<T> {\n+        private final AtomicBoolean isKey;\n+        private final Serializer<T> delegate;\n+\n+        public UniqueTopicSerializerDecorator(final AtomicBoolean isKey, final Serializer<T> delegate) {\n+            this.isKey = isKey;\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public void configure(final Map<String, ?> configs, final boolean isKey) {\n+            delegate.configure(configs, isKey);\n+            this.isKey.set(isKey);\n+        }\n+\n+        @Override\n+        public byte[] serialize(final String topic, final T data) {\n+            verifyTopic(topic, data);\n+            return delegate.serialize(topic, data);\n+        }\n+\n+        @Override\n+        public byte[] serialize(final String topic, final Headers headers, final T data) {\n+            verifyTopic(topic, data);\n+            return delegate.serialize(topic, headers, data);\n+        }\n+\n+        private void verifyTopic(final String topic, final T data) {\n+            if (data != null) {\n+                final String key = topic + (isKey.get() ? \"--key\" : \"--value\");\n+                if (topicTypeRegistry.containsKey(key)) {\n+                    assertThat(String.format(\"key[%s] data[%s][%s]\", key, data, data.getClass()), topicTypeRegistry.get(key), equalTo(data.getClass()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzI5MTM0OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/foreignkeyjoin/CombinedKeySchemaTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzo1MDowN1rOFoS58w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMDo0NDoxMFrOFoYZ0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc5NzEwNw==", "bodyText": "nit: define \"fkTopic\" and \"pkTopic\" as class private fields?", "url": "https://github.com/apache/kafka/pull/8054#discussion_r377797107", "createdAt": "2020-02-11T17:50:07Z", "author": {"login": "guozhangwang"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/foreignkeyjoin/CombinedKeySchemaTest.java", "diffHunk": "@@ -28,7 +28,8 @@\n \n     @Test\n     public void nonNullPrimaryKeySerdeTest() {\n-        final CombinedKeySchema<String, Integer> cks = new CombinedKeySchema<>(\"someTopic\", Serdes.String(), Serdes.Integer());\n+        final CombinedKeySchema<String, Integer> cks = new CombinedKeySchema<>(\"fkTopic\", Serdes.String(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a18078fb9f748b2cd20865494047262343734f5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg4NzE4Ng==", "bodyText": "I could... but I'd rather not, if that's ok. These strings are only dummy values, and they appear only once in the test, so there's no safety/consistency savings by declaring a field. There's no reason all the tests need the same strings here, so a field actually creates indirection and coupling where it doesn't provide any value. And the name of the variable would be about as long as the string itself.\nI get the impression this won't bother you either way, but it seemed rude not to respond, if I wasn't going to take the suggestion.", "url": "https://github.com/apache/kafka/pull/8054#discussion_r377887186", "createdAt": "2020-02-11T20:44:10Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/foreignkeyjoin/CombinedKeySchemaTest.java", "diffHunk": "@@ -28,7 +28,8 @@\n \n     @Test\n     public void nonNullPrimaryKeySerdeTest() {\n-        final CombinedKeySchema<String, Integer> cks = new CombinedKeySchema<>(\"someTopic\", Serdes.String(), Serdes.Integer());\n+        final CombinedKeySchema<String, Integer> cks = new CombinedKeySchema<>(\"fkTopic\", Serdes.String(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc5NzEwNw=="}, "originalCommit": {"oid": "5a18078fb9f748b2cd20865494047262343734f5"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4212, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}