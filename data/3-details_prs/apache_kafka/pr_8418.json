{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4Mjk1MTEy", "number": 8418, "title": "KAFKA-9807; Protect LSO reads from concurrent high-watermark updates", "bodyText": "If the high-watermark is updated in the middle of a read with the read_committed isolation level, it is possible to return data above the LSO. In the worst case, this can lead to the read of an aborted transaction. The root cause is that the logic depends on reading the high-watermark twice. We fix the problem by reading it once and caching the value.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-04-03T17:23:33Z", "url": "https://github.com/apache/kafka/pull/8418", "merged": true, "mergeCommit": {"oid": "d4eb406f01e02f42d433caaa4752c66c9c792076"}, "closed": true, "closedAt": "2020-04-03T20:56:43Z", "author": {"login": "hachikuji"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcUEOgdAH2gAyMzk4Mjk1MTEyOmQxNjJjMjYyNDJhMWZhMjU0NzliOTA2N2U4MjM4ZGJkYWFmNGM3NWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcUHGQOAFqTM4NzU2NjU3Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d162c26242a1fa25479b9067e8238dbdaaf4c75a", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/d162c26242a1fa25479b9067e8238dbdaaf4c75a", "committedDate": "2020-04-03T17:20:02Z", "message": "KAFKA-9807; Protect LSO reads from concurrent high-watermark updates"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NDU1Mzkx", "url": "https://github.com/apache/kafka/pull/8418#pullrequestreview-387455391", "createdAt": "2020-04-03T17:40:07Z", "commit": {"oid": "d162c26242a1fa25479b9067e8238dbdaaf4c75a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNzo0MDowN1rOGAgT-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNzo0MDowN1rOGAgT-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE4MjU4Ng==", "bodyText": "Should we use lambdas for Runnable and Callable?", "url": "https://github.com/apache/kafka/pull/8418#discussion_r403182586", "createdAt": "2020-04-03T17:40:07Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/log/LogTest.scala", "diffHunk": "@@ -3649,6 +3650,61 @@ class LogTest {\n     assertEquals(None, log.firstUnstableOffset)\n   }\n \n+  @Test\n+  def testReadCommittedWithConcurrentHighWatermarkUpdates(): Unit = {\n+    val logConfig = LogTest.createLogConfig(segmentBytes = 1024 * 1024 * 5)\n+    val log = createLog(logDir, logConfig)\n+    val lastOffset = 50L\n+\n+    val producerEpoch = 0.toShort\n+    val producerId = 15L\n+    val appendProducer = appendTransactionalAsLeader(log, producerId, producerEpoch)\n+\n+    // Thread 1 writes single-record transactions and attempts to read them\n+    // before they have been aborted, and then aborts them\n+    val txnVerifier = new Callable[Int]() {\n+      override def call(): Int = {\n+        var nonEmptyReads = 0\n+        while (log.logEndOffset < lastOffset) {\n+          val currentLogEndOffset = log.logEndOffset\n+\n+          appendProducer(1)\n+\n+          val readInfo = log.read(\n+            startOffset = currentLogEndOffset,\n+            maxLength = Int.MaxValue,\n+            isolation = FetchTxnCommitted,\n+            minOneMessage = false)\n+\n+          if (readInfo.records.sizeInBytes() > 0)\n+            nonEmptyReads += 1\n+\n+          appendEndTxnMarkerAsLeader(log, producerId, producerEpoch, ControlRecordType.ABORT)\n+        }\n+        nonEmptyReads\n+      }\n+    }\n+\n+    // Thread 2 watches the log and updates the high watermark\n+    val hwUpdater = new Runnable() {\n+      override def run(): Unit = {\n+        while (log.logEndOffset < lastOffset) {\n+          log.updateHighWatermark(log.logEndOffset)\n+        }\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d162c26242a1fa25479b9067e8238dbdaaf4c75a"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NDU2MDg0", "url": "https://github.com/apache/kafka/pull/8418#pullrequestreview-387456084", "createdAt": "2020-04-03T17:41:07Z", "commit": {"oid": "d162c26242a1fa25479b9067e8238dbdaaf4c75a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNzo0MTowN1rOGAgXgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNzo0MTowN1rOGAgXgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzE4MzQ5MA==", "bodyText": "Shall we do this within a try/finally?", "url": "https://github.com/apache/kafka/pull/8418#discussion_r403183490", "createdAt": "2020-04-03T17:41:07Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/log/LogTest.scala", "diffHunk": "@@ -3649,6 +3650,61 @@ class LogTest {\n     assertEquals(None, log.firstUnstableOffset)\n   }\n \n+  @Test\n+  def testReadCommittedWithConcurrentHighWatermarkUpdates(): Unit = {\n+    val logConfig = LogTest.createLogConfig(segmentBytes = 1024 * 1024 * 5)\n+    val log = createLog(logDir, logConfig)\n+    val lastOffset = 50L\n+\n+    val producerEpoch = 0.toShort\n+    val producerId = 15L\n+    val appendProducer = appendTransactionalAsLeader(log, producerId, producerEpoch)\n+\n+    // Thread 1 writes single-record transactions and attempts to read them\n+    // before they have been aborted, and then aborts them\n+    val txnVerifier = new Callable[Int]() {\n+      override def call(): Int = {\n+        var nonEmptyReads = 0\n+        while (log.logEndOffset < lastOffset) {\n+          val currentLogEndOffset = log.logEndOffset\n+\n+          appendProducer(1)\n+\n+          val readInfo = log.read(\n+            startOffset = currentLogEndOffset,\n+            maxLength = Int.MaxValue,\n+            isolation = FetchTxnCommitted,\n+            minOneMessage = false)\n+\n+          if (readInfo.records.sizeInBytes() > 0)\n+            nonEmptyReads += 1\n+\n+          appendEndTxnMarkerAsLeader(log, producerId, producerEpoch, ControlRecordType.ABORT)\n+        }\n+        nonEmptyReads\n+      }\n+    }\n+\n+    // Thread 2 watches the log and updates the high watermark\n+    val hwUpdater = new Runnable() {\n+      override def run(): Unit = {\n+        while (log.logEndOffset < lastOffset) {\n+          log.updateHighWatermark(log.logEndOffset)\n+        }\n+      }\n+    }\n+\n+    val executor = Executors.newFixedThreadPool(2)\n+    executor.submit(hwUpdater)\n+\n+    val future = executor.submit(txnVerifier)\n+    val nonEmptyReads = future.get()\n+\n+    assertEquals(0, nonEmptyReads)\n+\n+    executor.shutdownNow()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d162c26242a1fa25479b9067e8238dbdaaf4c75a"}, "originalPosition": 64}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef0058146efe1bbd9b848be3395c4be571b4842f", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/ef0058146efe1bbd9b848be3395c4be571b4842f", "committedDate": "2020-04-03T17:54:30Z", "message": "Address feedback on test case"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NTM1Mzg4", "url": "https://github.com/apache/kafka/pull/8418#pullrequestreview-387535388", "createdAt": "2020-04-03T19:46:13Z", "commit": {"oid": "ef0058146efe1bbd9b848be3395c4be571b4842f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NTY2NTc3", "url": "https://github.com/apache/kafka/pull/8418#pullrequestreview-387566577", "createdAt": "2020-04-03T20:40:44Z", "commit": {"oid": "ef0058146efe1bbd9b848be3395c4be571b4842f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 80, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}