{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzNTM1NjM4", "number": 9619, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMzoxNDo1M1rOE624Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwOToyNTo0OVrOE68vNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTUxOTU4OnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/common/protocol/SendBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMzoxNDo1NFrOH2LFQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNDoxNjo0OFrOH2MH4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU2NjcyMQ==", "bodyText": "why sends is ArrayDeque and buffers is ArrayList?", "url": "https://github.com/apache/kafka/pull/9619#discussion_r526566721", "createdAt": "2020-11-19T03:14:54Z", "author": {"login": "chia7712"}, "path": "clients/src/main/java/org/apache/kafka/common/protocol/SendBuilder.java", "diffHunk": "@@ -39,6 +42,7 @@\n  */\n public class SendBuilder implements Writable {\n     private final Queue<Send> sends = new ArrayDeque<>();\n+    private final List<ByteBuffer> buffers = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce2fc73c36df444387d2ef7d16819361ca3c11de"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4Mzc3OA==", "bodyText": "Oh, just because MultiRecordsSend needs a Queue.", "url": "https://github.com/apache/kafka/pull/9619#discussion_r526583778", "createdAt": "2020-11-19T04:16:48Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/common/protocol/SendBuilder.java", "diffHunk": "@@ -39,6 +42,7 @@\n  */\n public class SendBuilder implements Writable {\n     private final Queue<Send> sends = new ArrayDeque<>();\n+    private final List<ByteBuffer> buffers = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU2NjcyMQ=="}, "originalCommit": {"oid": "ce2fc73c36df444387d2ef7d16819361ca3c11de"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMTUyNDQzOnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/common/protocol/SendBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMzoxNzoxMVrOH2LH-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwNDoxODoyMVrOH2MJXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU2NzQxNw==", "bodyText": "How about setting initial size of sends to 1 as auto-generated code use only MemoryRecords", "url": "https://github.com/apache/kafka/pull/9619#discussion_r526567417", "createdAt": "2020-11-19T03:17:11Z", "author": {"login": "chia7712"}, "path": "clients/src/main/java/org/apache/kafka/common/protocol/SendBuilder.java", "diffHunk": "@@ -130,13 +139,25 @@ public void writeVarlong(long i) {\n      */\n     @Override\n     public void writeRecords(BaseRecords records) {\n-        flushCurrentBuffer();\n-        sends.add(records.toSend(destinationId));\n+        flushPendingBuffer();\n+\n+        if (records instanceof MemoryRecords) {\n+            buffers.add(((MemoryRecords) records).buffer());\n+        } else {\n+            flushPendingSend();\n+            sends.add(records.toSend(destinationId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce2fc73c36df444387d2ef7d16819361ca3c11de"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU4NDE1Ng==", "bodyText": "That's fair. FetchResponse is the only case where we would use a different Records type, so may as well optimize for the common case.", "url": "https://github.com/apache/kafka/pull/9619#discussion_r526584156", "createdAt": "2020-11-19T04:18:21Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/common/protocol/SendBuilder.java", "diffHunk": "@@ -130,13 +139,25 @@ public void writeVarlong(long i) {\n      */\n     @Override\n     public void writeRecords(BaseRecords records) {\n-        flushCurrentBuffer();\n-        sends.add(records.toSend(destinationId));\n+        flushPendingBuffer();\n+\n+        if (records instanceof MemoryRecords) {\n+            buffers.add(((MemoryRecords) records).buffer());\n+        } else {\n+            flushPendingSend();\n+            sends.add(records.toSend(destinationId));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU2NzQxNw=="}, "originalCommit": {"oid": "ce2fc73c36df444387d2ef7d16819361ca3c11de"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMjQ3OTg4OnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/common/protocol/SendBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwOToyNTo0OVrOH2T4bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNzozNTo0NFrOH2p_eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcxMDg5Mw==", "bodyText": "I just noticed that ByteBufferSend re-iterates over the byte buffers to compute the total size. We could compute the size while we accumulate them. I suppose that the number of buffers is usually small so it should not make a big difference.", "url": "https://github.com/apache/kafka/pull/9619#discussion_r526710893", "createdAt": "2020-11-19T09:25:49Z", "author": {"login": "dajac"}, "path": "clients/src/main/java/org/apache/kafka/common/protocol/SendBuilder.java", "diffHunk": "@@ -122,6 +123,14 @@ public void writeVarlong(long i) {\n         ByteUtils.writeVarlong(i, buffer);\n     }\n \n+    private void flushPendingSend() {\n+        if (!buffers.isEmpty()) {\n+            ByteBuffer[] byteBufferArray = buffers.toArray(new ByteBuffer[0]);\n+            sends.add(new ByteBufferSend(destinationId, byteBufferArray));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33fbae5f7a2f6a7e2803a2a82b2b45beacc732ba"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3MzE0NA==", "bodyText": "I was somewhat inclined to leave this as is, but finally I decided to do it since it might help (even if only a little) with fetch overhead.", "url": "https://github.com/apache/kafka/pull/9619#discussion_r527073144", "createdAt": "2020-11-19T17:35:44Z", "author": {"login": "hachikuji"}, "path": "clients/src/main/java/org/apache/kafka/common/protocol/SendBuilder.java", "diffHunk": "@@ -122,6 +123,14 @@ public void writeVarlong(long i) {\n         ByteUtils.writeVarlong(i, buffer);\n     }\n \n+    private void flushPendingSend() {\n+        if (!buffers.isEmpty()) {\n+            ByteBuffer[] byteBufferArray = buffers.toArray(new ByteBuffer[0]);\n+            sends.add(new ByteBufferSend(destinationId, byteBufferArray));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcxMDg5Mw=="}, "originalCommit": {"oid": "33fbae5f7a2f6a7e2803a2a82b2b45beacc732ba"}, "originalPosition": 72}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3901, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}