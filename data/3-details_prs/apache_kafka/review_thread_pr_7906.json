{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMjQ0Nzgy", "number": 7906, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMTo0MDowMVrODWaxOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwNDo0OToyM1rODWcANA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0ODMzODUwOnYy", "diffSide": "RIGHT", "path": "clients/src/test/java/org/apache/kafka/clients/consumer/KafkaConsumerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMTo0MDowMVrOFbKvJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwMTo0MDowMVrOFbKvJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDAzMTc4MQ==", "bodyText": "Make reusable parameters for easier assertion calls, as some of the ids are not exposed from inside helper function.", "url": "https://github.com/apache/kafka/pull/7906#discussion_r364031781", "createdAt": "2020-01-08T01:40:01Z", "author": {"login": "abbccdda"}, "path": "clients/src/test/java/org/apache/kafka/clients/consumer/KafkaConsumerTest.java", "diffHunk": "@@ -148,6 +149,8 @@\n     private final int autoCommitIntervalMs = 500;\n \n     private final String groupId = \"mock-group\";\n+    private final String memberId = \"memberId\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0ODUzMjE0OnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/ConsumerGroupMetadata.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwNDo0MDo0N1rOFbMjRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQyMTo0MToyOFrOFbksOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2MTUwOQ==", "bodyText": "This is not introduced by this PR but: the fields can be declared final?", "url": "https://github.com/apache/kafka/pull/7906#discussion_r364061509", "createdAt": "2020-01-08T04:40:47Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/ConsumerGroupMetadata.java", "diffHunk": "@@ -18,6 +18,10 @@\n \n import java.util.Optional;\n \n+/**\n+ * A metadata struct containing the consumer group information.\n+ * Note: Any change to this class is considered public and requires a KIP.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e761cfae1457d672fc2f895ddd4b1d07fd6a8349"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ1NzAxNw==", "bodyText": "Yes, they could", "url": "https://github.com/apache/kafka/pull/7906#discussion_r364457017", "createdAt": "2020-01-08T21:41:28Z", "author": {"login": "abbccdda"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/ConsumerGroupMetadata.java", "diffHunk": "@@ -18,6 +18,10 @@\n \n import java.util.Optional;\n \n+/**\n+ * A metadata struct containing the consumer group information.\n+ * Note: Any change to this class is considered public and requires a KIP.\n+ */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2MTUwOQ=="}, "originalCommit": {"oid": "e761cfae1457d672fc2f895ddd4b1d07fd6a8349"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0ODUzNjQyOnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwNDo0NTowNVrOFbMlyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQyMTo0MDozM1rOFbkqyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2MjE1Mw==", "bodyText": "Why we want to return a clone of the groupMetadata? If we can declare all the fields as final, and whenever we update we always create a new ConsumerGroupMetadata object, then I think we can safely return the cached object directly.", "url": "https://github.com/apache/kafka/pull/7906#discussion_r364062153", "createdAt": "2020-01-08T04:45:05Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinator.java", "diffHunk": "@@ -815,6 +820,15 @@ public boolean refreshCommittedOffsetsIfNeeded(Timer timer) {\n         return null;\n     }\n \n+    /**\n+     * Return the consumer group metadata.\n+     *\n+     * @return the current consumer group metadata\n+     */\n+    public ConsumerGroupMetadata groupMetadata() {\n+        return new ConsumerGroupMetadata(groupMetadata);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e761cfae1457d672fc2f895ddd4b1d07fd6a8349"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ1NjY0OA==", "bodyText": "Good point, I think we probably don't need to have this.", "url": "https://github.com/apache/kafka/pull/7906#discussion_r364456648", "createdAt": "2020-01-08T21:40:33Z", "author": {"login": "abbccdda"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinator.java", "diffHunk": "@@ -815,6 +820,15 @@ public boolean refreshCommittedOffsetsIfNeeded(Timer timer) {\n         return null;\n     }\n \n+    /**\n+     * Return the consumer group metadata.\n+     *\n+     * @return the current consumer group metadata\n+     */\n+    public ConsumerGroupMetadata groupMetadata() {\n+        return new ConsumerGroupMetadata(groupMetadata);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2MjE1Mw=="}, "originalCommit": {"oid": "e761cfae1457d672fc2f895ddd4b1d07fd6a8349"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0ODU0MDY4OnYy", "diffSide": "RIGHT", "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQwNDo0OToyM1rOFbMoMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOFQyMjoxNDo0NFrOFbleyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2Mjc2OQ==", "bodyText": "Since this callback is not synchronized and nor does the getter groupMetadata(), we should declare this cached object volatile.", "url": "https://github.com/apache/kafka/pull/7906#discussion_r364062769", "createdAt": "2020-01-08T04:49:23Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinator.java", "diffHunk": "@@ -387,8 +392,8 @@ protected void onJoinComplete(int generation,\n         maybeUpdateJoinedSubscription(assignedPartitions);\n \n         // give the assignor a chance to update internal state based on the received assignment\n-        ConsumerGroupMetadata metadata = new ConsumerGroupMetadata(rebalanceConfig.groupId, generation, memberId, rebalanceConfig.groupInstanceId);\n-        assignor.onAssignment(assignment, metadata);\n+        groupMetadata = new ConsumerGroupMetadata(rebalanceConfig.groupId, generation, memberId, rebalanceConfig.groupInstanceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e761cfae1457d672fc2f895ddd4b1d07fd6a8349"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ1OTI4Ng==", "bodyText": "For normal consumer user, this callback should be executed on the same thread of the caller right? Why do we need to make it volatile?", "url": "https://github.com/apache/kafka/pull/7906#discussion_r364459286", "createdAt": "2020-01-08T21:47:07Z", "author": {"login": "abbccdda"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinator.java", "diffHunk": "@@ -387,8 +392,8 @@ protected void onJoinComplete(int generation,\n         maybeUpdateJoinedSubscription(assignedPartitions);\n \n         // give the assignor a chance to update internal state based on the received assignment\n-        ConsumerGroupMetadata metadata = new ConsumerGroupMetadata(rebalanceConfig.groupId, generation, memberId, rebalanceConfig.groupInstanceId);\n-        assignor.onAssignment(assignment, metadata);\n+        groupMetadata = new ConsumerGroupMetadata(rebalanceConfig.groupId, generation, memberId, rebalanceConfig.groupInstanceId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2Mjc2OQ=="}, "originalCommit": {"oid": "e761cfae1457d672fc2f895ddd4b1d07fd6a8349"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQ2OTk2Mw==", "bodyText": "Well I was thinking two threads could be two threads, one calling consumer.groupMetadata and one calling consumer.poll which is creating a new object, but on a second thought this race condition maybe fine anyways since we cannot guarantee time-ordering if it happens.", "url": "https://github.com/apache/kafka/pull/7906#discussion_r364469963", "createdAt": "2020-01-08T22:14:44Z", "author": {"login": "guozhangwang"}, "path": "clients/src/main/java/org/apache/kafka/clients/consumer/internals/ConsumerCoordinator.java", "diffHunk": "@@ -387,8 +392,8 @@ protected void onJoinComplete(int generation,\n         maybeUpdateJoinedSubscription(assignedPartitions);\n \n         // give the assignor a chance to update internal state based on the received assignment\n-        ConsumerGroupMetadata metadata = new ConsumerGroupMetadata(rebalanceConfig.groupId, generation, memberId, rebalanceConfig.groupInstanceId);\n-        assignor.onAssignment(assignment, metadata);\n+        groupMetadata = new ConsumerGroupMetadata(rebalanceConfig.groupId, generation, memberId, rebalanceConfig.groupInstanceId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA2Mjc2OQ=="}, "originalCommit": {"oid": "e761cfae1457d672fc2f895ddd4b1d07fd6a8349"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4459, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}