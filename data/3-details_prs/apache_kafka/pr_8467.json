{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyMjY5MTMw", "number": 8467, "title": "MINOR: reduce allocations in log start and recovery checkpoints", "bodyText": "For brokers with replica counts > 4000, allocations from logsByDir become substantial. logsByDir is called often by LogManager.checkpointLogRecoveryOffsets and LogManager.checkpointLogStartOffsets. The approach used is similar to the one from the checkpointHighwatermarks change in #6741.\nAre there better ways to structure out data structure to avoid creating logsByDir on demand for each checkpoint iteration? This micro-optimization will help as is, but if we can avoid doing this completely it'd be better.\nJMH benchmark results:\nBefore:\nBenchmark                                                                      (numPartitions)  (numTopics)   Mode  Cnt        Score        Error   Units\nCheckpointBench.measureCheckpointLogStartOffsets                                             3          100  thrpt   15        2.233 \u00b1      0.013  ops/ms\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.alloc.rate                              3          100  thrpt   15      477.097 \u00b1     49.731  MB/sec\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.alloc.rate.norm                         3          100  thrpt   15   246083.007 \u00b1     33.052    B/op\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Eden_Space                     3          100  thrpt   15      475.683 \u00b1     55.569  MB/sec\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Eden_Space.norm                3          100  thrpt   15   245474.040 \u00b1  14968.328    B/op\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Old_Gen                        3          100  thrpt   15        0.001 \u00b1      0.001  MB/sec\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Old_Gen.norm                   3          100  thrpt   15        0.341 \u00b1      0.268    B/op\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.count                                   3          100  thrpt   15      129.000               counts\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.time                                    3          100  thrpt   15       52.000                   ms\nCheckpointBench.measureCheckpointLogStartOffsets                                             3         1000  thrpt   15        0.572 \u00b1      0.004  ops/ms\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.alloc.rate                              3         1000  thrpt   15     1360.240 \u00b1    150.539  MB/sec\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.alloc.rate.norm                         3         1000  thrpt   15  2750221.257 \u00b1    891.024    B/op\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Eden_Space                     3         1000  thrpt   15     1362.908 \u00b1    148.799  MB/sec\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Eden_Space.norm                3         1000  thrpt   15  2756395.092 \u00b1  44671.843    B/op\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Old_Gen                        3         1000  thrpt   15        0.017 \u00b1      0.008  MB/sec\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Old_Gen.norm                   3         1000  thrpt   15       33.611 \u00b1     14.401    B/op\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.count                                   3         1000  thrpt   15      273.000               counts\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.time                                    3         1000  thrpt   15      186.000                   ms\nCheckpointBench.measureCheckpointLogStartOffsets                                             3         2000  thrpt   15        0.266 \u00b1      0.002  ops/ms\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.alloc.rate                              3         2000  thrpt   15     1342.557 \u00b1    171.260  MB/sec\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.alloc.rate.norm                         3         2000  thrpt   15  5877881.729 \u00b1   3695.086    B/op\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Eden_Space                     3         2000  thrpt   15     1343.965 \u00b1    186.069  MB/sec\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Eden_Space.norm                3         2000  thrpt   15  5877788.561 \u00b1 168540.343    B/op\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Old_Gen                        3         2000  thrpt   15        0.081 \u00b1      0.043  MB/sec\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Old_Gen.norm                   3         2000  thrpt   15      351.277 \u00b1    167.006    B/op\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.count                                   3         2000  thrpt   15      253.000               counts\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.time                                    3         2000  thrpt   15      231.000                   ms\nJMH benchmarks done\n\nAfter:\nCheckpointBench.measureCheckpointLogStartOffsets                                             3          100  thrpt   15        2.809 \u00b1     0.129  ops/ms\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.alloc.rate                              3          100  thrpt   15      211.248 \u00b1    25.953  MB/sec\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.alloc.rate.norm                         3          100  thrpt   15    86533.838 \u00b1  3763.989    B/op\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Eden_Space                     3          100  thrpt   15      211.512 \u00b1    38.669  MB/sec\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Eden_Space.norm                3          100  thrpt   15    86228.552 \u00b1  9590.781    B/op\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Old_Gen                        3          100  thrpt   15       \u2248 10\u207b\u00b3              MB/sec\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Old_Gen.norm                   3          100  thrpt   15        0.140 \u00b1     0.111    B/op\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.count                                   3          100  thrpt   15       57.000              counts\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.time                                    3          100  thrpt   15       25.000                  ms\nCheckpointBench.measureCheckpointLogStartOffsets                                             3         1000  thrpt   15        1.046 \u00b1     0.030  ops/ms\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.alloc.rate                              3         1000  thrpt   15      524.597 \u00b1    74.793  MB/sec\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.alloc.rate.norm                         3         1000  thrpt   15   582898.889 \u00b1 37552.262    B/op\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Eden_Space                     3         1000  thrpt   15      519.675 \u00b1    89.754  MB/sec\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Eden_Space.norm                3         1000  thrpt   15   576371.150 \u00b1 55972.955    B/op\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Old_Gen                        3         1000  thrpt   15        0.009 \u00b1     0.005  MB/sec\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Old_Gen.norm                   3         1000  thrpt   15        9.920 \u00b1     5.375    B/op\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.count                                   3         1000  thrpt   15      111.000              counts\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.time                                    3         1000  thrpt   15       56.000                  ms\nCheckpointBench.measureCheckpointLogStartOffsets                                             3         2000  thrpt   15        0.617 \u00b1     0.007  ops/ms\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.alloc.rate                              3         2000  thrpt   15      573.061 \u00b1    95.931  MB/sec\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.alloc.rate.norm                         3         2000  thrpt   15  1092098.004 \u00b1 75140.633    B/op\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Eden_Space                     3         2000  thrpt   15      572.448 \u00b1    97.960  MB/sec\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Eden_Space.norm                3         2000  thrpt   15  1091290.460 \u00b1 85946.164    B/op\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Old_Gen                        3         2000  thrpt   15        0.010 \u00b1     0.012  MB/sec\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.churn.G1_Old_Gen.norm                   3         2000  thrpt   15       19.990 \u00b1    24.407    B/op\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.count                                   3         2000  thrpt   15      109.000              counts\nCheckpointBench.measureCheckpointLogStartOffsets:\u00b7gc.time                                    3         2000  thrpt   15       67.000                  ms\nJMH benchmarks done\n\n\nFor the 2000 topic, 3 partition case, we see a reduction in normalized allocations from 5877881B/op to 1284190.774B/op, a reduction of 78%.\nSome allocation profiles from a mid sized broker follow. I have seen worse, but these add up to around 3.8% on a broker that saw GC overhead in CPU time of around 30%. You could argue that this is relatively small, but it seems worthwhile for a low risk change.", "createdAt": "2020-04-12T01:03:03Z", "url": "https://github.com/apache/kafka/pull/8467", "merged": true, "mergeCommit": {"oid": "cfc34cace523e6d9698a892b9ec7ba4af33d00ea"}, "closed": true, "closedAt": "2020-04-25T20:55:00Z", "author": {"login": "lbradstreet"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcWuSzLgH2gAyNDAyMjY5MTMwOmViYzUxMDRhNjliZmViMjBkN2FlYmI3YzAwZjIwMmEzYTViMDM0YTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABca5GsmgH2gAyNDAyMjY5MTMwOjQwOWY0ODMwZDIwZDljNzFhYmM0MDI1OTEzOTVjNmVhYzQyMzE2NTM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ebc5104a69bfeb20d7aebb7c00f202a3a5b034a1", "author": {"user": {"login": "lbradstreet", "name": "Lucas Bradstreet"}}, "url": "https://github.com/apache/kafka/commit/ebc5104a69bfeb20d7aebb7c00f202a3a5b034a1", "committedDate": "2020-04-11T23:28:35Z", "message": "Reduce allocations in logsbydir"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ace92dd5b7227bb6906ae1d72f51979be9acf6cf", "author": {"user": {"login": "lbradstreet", "name": "Lucas Bradstreet"}}, "url": "https://github.com/apache/kafka/commit/ace92dd5b7227bb6906ae1d72f51979be9acf6cf", "committedDate": "2020-04-12T00:56:42Z", "message": "Bring bench runs back in line"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0NjA5NTE1", "url": "https://github.com/apache/kafka/pull/8467#pullrequestreview-394609515", "createdAt": "2020-04-16T13:03:22Z", "commit": {"oid": "ace92dd5b7227bb6906ae1d72f51979be9acf6cf"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMzowMzoyM1rOGGkNfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQxMzowMzoyM1rOGGkNfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUzNzkxOQ==", "bodyText": "In the other PR we used AnyRefMap. Any reason why we are not doing that here?", "url": "https://github.com/apache/kafka/pull/8467#discussion_r409537919", "createdAt": "2020-04-16T13:03:23Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/log/LogManager.scala", "diffHunk": "@@ -1003,9 +1003,14 @@ class LogManager(logDirs: Seq[File],\n   /**\n    * Map of log dir to logs by topic and partitions in that dir\n    */\n-  private def logsByDir: Map[String, Map[TopicPartition, Log]] = {\n-    (this.currentLogs.toList ++ this.futureLogs.toList).toMap\n-      .groupBy { case (_, log) => log.parentDir }\n+  def logsByDir: Map[String, Map[TopicPartition, Log]] = {\n+    val byDir = new mutable.HashMap[String, mutable.HashMap[TopicPartition, Log]]()\n+    def addToDir(tp: TopicPartition, log: Log): Unit = {\n+      byDir.getOrElseUpdate(log.parentDir, new mutable.HashMap[TopicPartition, Log]()).put(tp, log)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ace92dd5b7227bb6906ae1d72f51979be9acf6cf"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2e4221df073ff43dac16351e060a44f8c39748e", "author": {"user": {"login": "lbradstreet", "name": "Lucas Bradstreet"}}, "url": "https://github.com/apache/kafka/commit/b2e4221df073ff43dac16351e060a44f8c39748e", "committedDate": "2020-04-19T21:35:46Z", "message": "Switch to AnyRefMap, add comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5MTM0NjEw", "url": "https://github.com/apache/kafka/pull/8467#pullrequestreview-399134610", "createdAt": "2020-04-23T14:08:43Z", "commit": {"oid": "b2e4221df073ff43dac16351e060a44f8c39748e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDowODo0M1rOGKp_RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDowODo0M1rOGKp_RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyNjg4NA==", "bodyText": "scala.collection.Map has a def foreachEntry[U](f: (K, V) => U): Unit method that avoids allocating tuples (it's a function with two parameters). If we want to avoid allocations, we should introduce a similar method to Pool and use it here.", "url": "https://github.com/apache/kafka/pull/8467#discussion_r413826884", "createdAt": "2020-04-23T14:08:43Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/log/LogManager.scala", "diffHunk": "@@ -1003,9 +1003,17 @@ class LogManager(logDirs: Seq[File],\n   /**\n    * Map of log dir to logs by topic and partitions in that dir\n    */\n-  private def logsByDir: Map[String, Map[TopicPartition, Log]] = {\n-    (this.currentLogs.toList ++ this.futureLogs.toList).toMap\n-      .groupBy { case (_, log) => log.parentDir }\n+  def logsByDir: Map[String, Map[TopicPartition, Log]] = {\n+    // This code is called often by checkpoint processes and is written in a way that reduces\n+    // allocations and CPU with many topic partitions.\n+    // When changing this code please measure the changes with org.apache.kafka.jmh.server.CheckpointBench\n+    val byDir = new mutable.AnyRefMap[String, mutable.AnyRefMap[TopicPartition, Log]]()\n+    def addToDir(tp: TopicPartition, log: Log): Unit = {\n+      byDir.getOrElseUpdate(log.parentDir, new mutable.AnyRefMap[TopicPartition, Log]()).put(tp, log)\n+    }\n+    currentLogs.foreach { case (tp, log) => addToDir(tp, log) }\n+    futureLogs.foreach { case (tp, log) => addToDir(tp, log) }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2e4221df073ff43dac16351e060a44f8c39748e"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ce3e124ea55bf3ca1728fb234dc53e159a50b7b", "author": {"user": {"login": "lbradstreet", "name": "Lucas Bradstreet"}}, "url": "https://github.com/apache/kafka/commit/2ce3e124ea55bf3ca1728fb234dc53e159a50b7b", "committedDate": "2020-04-23T21:53:23Z", "message": "Add foreachEntry to Pool"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f67c6230ac6f79e39eb11e2ba80264af6a7f296", "author": {"user": {"login": "lbradstreet", "name": "Lucas Bradstreet"}}, "url": "https://github.com/apache/kafka/commit/4f67c6230ac6f79e39eb11e2ba80264af6a7f296", "committedDate": "2020-04-23T21:56:06Z", "message": "Revert topic counts change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d54ecb85f549c1555fbd63c65b8e97dace4e9c1d", "author": {"user": {"login": "lbradstreet", "name": "Lucas Bradstreet"}}, "url": "https://github.com/apache/kafka/commit/d54ecb85f549c1555fbd63c65b8e97dace4e9c1d", "committedDate": "2020-04-24T13:49:56Z", "message": "Switch to using lambda with forEach"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5OTg3MjAx", "url": "https://github.com/apache/kafka/pull/8467#pullrequestreview-399987201", "createdAt": "2020-04-24T14:17:05Z", "commit": {"oid": "d54ecb85f549c1555fbd63c65b8e97dace4e9c1d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "409f4830d20d9c71abc402591395c6eac4231653", "author": {"user": {"login": "ijuma", "name": "Ismael Juma"}}, "url": "https://github.com/apache/kafka/commit/409f4830d20d9c71abc402591395c6eac4231653", "committedDate": "2020-04-24T22:20:01Z", "message": "Remove unused import"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1468, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}