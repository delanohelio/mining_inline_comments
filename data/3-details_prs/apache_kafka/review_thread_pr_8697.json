{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwNDk1MDIw", "number": 8697, "reviewThreads": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMTozMzowM1rOD-wkKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNzoyMToyMVrOD_xc6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MTMzOTk1OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/TaskMetrics.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMTozMzowM1rOGZDr8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMTo0Mzo1MVrOGZD_kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyNzk4NQ==", "bodyText": "Assuming that a task might have a cache, is this correct, ie, has been fully processed by the task)?", "url": "https://github.com/apache/kafka/pull/8697#discussion_r428927985", "createdAt": "2020-05-21T21:33:03Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/TaskMetrics.java", "diffHunk": "@@ -86,6 +87,14 @@ private TaskMetrics() {}\n     private static final String NUM_BUFFERED_RECORDS_DESCRIPTION = \"The count of buffered records that are polled \" +\n         \"from consumer and not yet processed for this active task\";\n \n+    private static final String RECORD_E2E_LATENCY = \"record-e2e-latency\";\n+    static final String RECORD_E2E_LATENCY_MAX_DESCRIPTION =\n+        \"The maximum end-to-end latency of a record, measuring by comparing the record timestamp with the \"\n+            + \"system time when it has been fully processed by the task\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkzMzAxMQ==", "bodyText": "Oh right, I put the record in the wrong place but this description is correct. It should record at the RecordCollector for the task-level metrics", "url": "https://github.com/apache/kafka/pull/8697#discussion_r428933011", "createdAt": "2020-05-21T21:43:51Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/TaskMetrics.java", "diffHunk": "@@ -86,6 +87,14 @@ private TaskMetrics() {}\n     private static final String NUM_BUFFERED_RECORDS_DESCRIPTION = \"The count of buffered records that are polled \" +\n         \"from consumer and not yet processed for this active task\";\n \n+    private static final String RECORD_E2E_LATENCY = \"record-e2e-latency\";\n+    static final String RECORD_E2E_LATENCY_MAX_DESCRIPTION =\n+        \"The maximum end-to-end latency of a record, measuring by comparing the record timestamp with the \"\n+            + \"system time when it has been fully processed by the task\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyNzk4NQ=="}, "originalCommit": null, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MTM1NTcwOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMTozNzoyOFrOGZD05A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMTozNzoyOFrOGZD05A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkzMDI3Ng==", "bodyText": "We we increase this ts to 35? This would allow to test min in the last step better", "url": "https://github.com/apache/kafka/pull/8697#discussion_r428930276", "createdAt": "2020-05-21T21:37:28Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "diffHunk": "@@ -420,6 +422,50 @@ public void shouldRecordProcessRatio() {\n         assertThat(metric.metricValue(), equalTo(1.0d));\n     }\n \n+    @Test\n+    public void shouldRecordE2ELatency() {\n+        time = new MockTime(0L, 0L, 0L);\n+        metrics = new Metrics(new MetricConfig().recordLevel(Sensor.RecordingLevel.DEBUG), time);\n+\n+        task = createStatelessTask(createConfig(false, \"0\"), StreamsConfig.METRICS_LATEST);\n+\n+        final KafkaMetric maxMetric = getMetric(\"record-e2e-latency\", \"%s-max\", task.id().toString(), StreamsConfig.METRICS_LATEST);\n+        final KafkaMetric minMetric = getMetric(\"record-e2e-latency\", \"%s-min\", task.id().toString(), StreamsConfig.METRICS_LATEST);\n+\n+        assertThat(maxMetric.metricValue(), equalTo(Double.NaN));\n+\n+        task.addRecords(partition1, asList(\n+            getConsumerRecord(partition1, 0L),\n+            getConsumerRecord(partition1, 10L),\n+            getConsumerRecord(partition1, 5L),\n+            getConsumerRecord(partition1, 20L)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MTM1NzE4OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/metrics/TaskMetricsTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMTozODowMFrOGZD1zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMDowNTozOFrOGZRyEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkzMDUwOQ==", "bodyText": "Nice one!", "url": "https://github.com/apache/kafka/pull/8697#discussion_r428930509", "createdAt": "2020-05-21T21:38:00Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/metrics/TaskMetricsTest.java", "diffHunk": "@@ -14,15 +14,11 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.kafka.streams.kstream.internals.metrics;\n+package org.apache.kafka.streams.processor.internals.metrics;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1ODkzMQ==", "bodyText": "Yes, very nice!", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429158931", "createdAt": "2020-05-22T10:05:38Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/metrics/TaskMetricsTest.java", "diffHunk": "@@ -14,15 +14,11 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-package org.apache.kafka.streams.kstream.internals.metrics;\n+package org.apache.kafka.streams.processor.internals.metrics;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkzMDUwOQ=="}, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Mjc5MjkxOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMDowNDoxOVrOGZRv1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMDowNDoxOVrOGZRv1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1ODM1Nw==", "bodyText": "prop (super-nit): Could you call the method addMinAndMaxToSensor() since we have already one method that is called addAvgAndMinAndMaxToSensor()?", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429158357", "createdAt": "2020-05-22T10:04:19Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "diffHunk": "@@ -642,6 +642,30 @@ public static void addAvgAndMaxToSensor(final Sensor sensor,\n         );\n     }\n \n+    public static void addMaxAndMinToSensor(final Sensor sensor,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MjgwMDIxOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/metrics/TaskMetricsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMDowNzoxM1rOGZR0qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMDowNzoxM1rOGZR0qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1OTU5Mw==", "bodyText": "req: Please do not use the constant here. The point of this test is also to check the correctness of the description, i.e., the content of that constant.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429159593", "createdAt": "2020-05-22T10:07:13Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/metrics/TaskMetricsTest.java", "diffHunk": "@@ -356,4 +354,27 @@ public void shouldGetDroppedRecordsSensorOrLateRecordDropSensor() {\n             shouldGetDroppedRecordsSensor();\n         }\n     }\n+\n+    @Test\n+    public void shouldGetRecordE2ELatencySensor() {\n+        final String operation = \"record-e2e-latency\";\n+        expect(streamsMetrics.taskLevelSensor(THREAD_ID, TASK_ID, operation, RecordingLevel.INFO))\n+            .andReturn(expectedSensor);\n+        expect(streamsMetrics.taskLevelTagMap(THREAD_ID, TASK_ID)).andReturn(tagMap);\n+        StreamsMetricsImpl.addMaxAndMinToSensor(\n+            expectedSensor,\n+            TASK_LEVEL_GROUP,\n+            tagMap,\n+            operation,\n+            RECORD_E2E_LATENCY_MAX_DESCRIPTION,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MjgwNjU1OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/TaskMetrics.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMDowOTo0NVrOGZR4zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMDowOTo0NVrOGZR4zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2MDY1NQ==", "bodyText": "req: Please define this constant as private as all the others. I left a request in TaskMetricsTest which makes this request clearer.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429160655", "createdAt": "2020-05-22T10:09:45Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/TaskMetrics.java", "diffHunk": "@@ -86,6 +87,14 @@ private TaskMetrics() {}\n     private static final String NUM_BUFFERED_RECORDS_DESCRIPTION = \"The count of buffered records that are polled \" +\n         \"from consumer and not yet processed for this active task\";\n \n+    private static final String RECORD_E2E_LATENCY = \"record-e2e-latency\";\n+    static final String RECORD_E2E_LATENCY_MAX_DESCRIPTION =", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MjgxNjIzOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/TaskMetrics.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMDoxMzoxMFrOGZR-wA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMDoxMzoxMFrOGZR-wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2MjE3Ng==", "bodyText": "See my comment above.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429162176", "createdAt": "2020-05-22T10:13:10Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/TaskMetrics.java", "diffHunk": "@@ -86,6 +87,14 @@ private TaskMetrics() {}\n     private static final String NUM_BUFFERED_RECORDS_DESCRIPTION = \"The count of buffered records that are polled \" +\n         \"from consumer and not yet processed for this active task\";\n \n+    private static final String RECORD_E2E_LATENCY = \"record-e2e-latency\";\n+    static final String RECORD_E2E_LATENCY_MAX_DESCRIPTION =\n+        \"The maximum end-to-end latency of a record, measuring by comparing the record timestamp with the \"\n+            + \"system time when it has been fully processed by the task\";\n+    static final String RECORD_E2E_LATENCY_MIN_DESCRIPTION =", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3Mjg4NTcxOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMDozOTo1NVrOGZSq8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxODozMToxMlrOGZgSLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE3MzQ4OA==", "bodyText": "Q: Is there a specific reason to init the sensor here and not in SinkNode? You can init and store it there. That was one motivation to make *Metrics classes (e.g. TaskMetrics) static, so that you do not need any code in the processor context to get specific sensors. If there is not specific reason, you could get rid of the changes in the *Context* classes.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429173488", "createdAt": "2020-05-22T10:39:55Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -137,6 +138,7 @@ public StreamTask(final TaskId id,\n         }\n         processRatioSensor = TaskMetrics.activeProcessRatioSensor(threadId, taskId, streamsMetrics);\n         processLatencySensor = TaskMetrics.processLatencySensor(threadId, taskId, streamsMetrics);\n+        recordE2ELatencySensor = TaskMetrics.recordE2ELatencySensor(threadId, taskId, streamsMetrics);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM5NjUyNA==", "bodyText": "I modified the proposal slightly to make these all processor-node level (will push the changes in a minute) but this question is still relevant, so here's the answer:\nWe can't record the e2e latency in the sink node because not all topologies have a sink node. For that reason we also can't record at the record collector. We need to figure out the terminal nodes when processing the topology, then record this metric after child.process in ProcessorContext#forward", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429396524", "createdAt": "2020-05-22T18:31:12Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -137,6 +138,7 @@ public StreamTask(final TaskId id,\n         }\n         processRatioSensor = TaskMetrics.activeProcessRatioSensor(threadId, taskId, streamsMetrics);\n         processLatencySensor = TaskMetrics.processLatencySensor(threadId, taskId, streamsMetrics);\n+        recordE2ELatencySensor = TaskMetrics.recordE2ELatencySensor(threadId, taskId, streamsMetrics);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE3MzQ4OA=="}, "originalCommit": null, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDY0MDY2OnYy", "diffSide": "RIGHT", "path": "checkstyle/suppressions.xml", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMToyNzozNVrOGZj_ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMToyNzozNVrOGZj_ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1NzMxMA==", "bodyText": "Checkstyle won't allow you to have a letter and number next to each other, but P90 and E2E_LATENCY seem preferable to P_90 and E_2_E_LATENCY", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429457310", "createdAt": "2020-05-22T21:27:35Z", "author": {"login": "ableegoldman"}, "path": "checkstyle/suppressions.xml", "diffHunk": "@@ -183,6 +183,8 @@\n               files=\"StreamsPartitionAssignor.java\"/>\n     <suppress checks=\"JavaNCSS\"\n               files=\"EosBetaUpgradeIntegrationTest.java\"/>\n+    <suppress checks=\"StaticVariableName\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDY2NjU1OnYy", "diffSide": "RIGHT", "path": "clients/src/test/java/org/apache/kafka/common/metrics/MetricsTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMTozNDo0NlrOGZkQLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMDo1OTowNlrOGZmkmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2MTU1MA==", "bodyText": "Trying to build confidence in the Percentiles implementation and gauge the accuracy with a more complicated test.\nI found it was accurate to within 5% maybe 2/3 or 3/4 of the time, but it seems reasonable to expect it to be accurate to within 10%", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429461550", "createdAt": "2020-05-22T21:34:46Z", "author": {"login": "ableegoldman"}, "path": "clients/src/test/java/org/apache/kafka/common/metrics/MetricsTest.java", "diffHunk": "@@ -492,6 +493,52 @@ public void testPercentiles() {\n         assertEquals(75, (Double) p75.metricValue(), 1.0);\n     }\n \n+    @Test\n+    public void testPercentilesWithRandomNumbersAndLinearBucketing() {\n+        long seed = new Random().nextLong();\n+        int sizeInBytes = 1000 * 1000;   // 1MB\n+        long maximumValue = 1000 * 24 * 60 * 60 * 1000L; // if values are ms, max is 1000 days\n+\n+        try {\n+            Random prng = new Random(seed);\n+            int numberOfValues = 5000 + prng.nextInt(10_000);  // ranges is [5000, 15000]\n+\n+            Percentiles percs = new Percentiles(sizeInBytes,\n+                                                maximumValue,\n+                                                BucketSizing.LINEAR,\n+                                                new Percentile(metrics.metricName(\"test.p90\", \"grp1\"), 90),\n+                                                new Percentile(metrics.metricName(\"test.p99\", \"grp1\"), 99));\n+            MetricConfig config = new MetricConfig().eventWindow(50).samples(2);\n+            Sensor sensor = metrics.sensor(\"test\", config);\n+            sensor.add(percs);\n+            Metric p90 = this.metrics.metrics().get(metrics.metricName(\"test.p90\", \"grp1\"));\n+            Metric p99 = this.metrics.metrics().get(metrics.metricName(\"test.p99\", \"grp1\"));\n+\n+            final List<Long> values = new ArrayList<>(numberOfValues);\n+            // record two windows worth of sequential values\n+            for (int i = 0; i < numberOfValues; ++i) {\n+                long value = Math.abs(prng.nextLong()) % maximumValue;\n+                values.add(value);\n+                sensor.record(value);\n+            }\n+\n+            Collections.sort(values);\n+\n+            int p90Index = (int)Math.ceil(((double)(90 * numberOfValues)) / 100);\n+            int p99Index = (int)Math.ceil(((double)(99 * numberOfValues)) / 100);\n+\n+            double expectedP90 = values.get(p90Index - 1);\n+            double expectedP99 = values.get(p99Index - 1);\n+\n+            assertEquals(expectedP90, (Double) p90.metricValue(), expectedP90 / 10);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5OTU0Nw==", "bodyText": "Let's see...", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429499547", "createdAt": "2020-05-23T00:59:06Z", "author": {"login": "mjsax"}, "path": "clients/src/test/java/org/apache/kafka/common/metrics/MetricsTest.java", "diffHunk": "@@ -492,6 +493,52 @@ public void testPercentiles() {\n         assertEquals(75, (Double) p75.metricValue(), 1.0);\n     }\n \n+    @Test\n+    public void testPercentilesWithRandomNumbersAndLinearBucketing() {\n+        long seed = new Random().nextLong();\n+        int sizeInBytes = 1000 * 1000;   // 1MB\n+        long maximumValue = 1000 * 24 * 60 * 60 * 1000L; // if values are ms, max is 1000 days\n+\n+        try {\n+            Random prng = new Random(seed);\n+            int numberOfValues = 5000 + prng.nextInt(10_000);  // ranges is [5000, 15000]\n+\n+            Percentiles percs = new Percentiles(sizeInBytes,\n+                                                maximumValue,\n+                                                BucketSizing.LINEAR,\n+                                                new Percentile(metrics.metricName(\"test.p90\", \"grp1\"), 90),\n+                                                new Percentile(metrics.metricName(\"test.p99\", \"grp1\"), 99));\n+            MetricConfig config = new MetricConfig().eventWindow(50).samples(2);\n+            Sensor sensor = metrics.sensor(\"test\", config);\n+            sensor.add(percs);\n+            Metric p90 = this.metrics.metrics().get(metrics.metricName(\"test.p90\", \"grp1\"));\n+            Metric p99 = this.metrics.metrics().get(metrics.metricName(\"test.p99\", \"grp1\"));\n+\n+            final List<Long> values = new ArrayList<>(numberOfValues);\n+            // record two windows worth of sequential values\n+            for (int i = 0; i < numberOfValues; ++i) {\n+                long value = Math.abs(prng.nextLong()) % maximumValue;\n+                values.add(value);\n+                sensor.record(value);\n+            }\n+\n+            Collections.sort(values);\n+\n+            int p90Index = (int)Math.ceil(((double)(90 * numberOfValues)) / 100);\n+            int p99Index = (int)Math.ceil(((double)(99 * numberOfValues)) / 100);\n+\n+            double expectedP90 = values.get(p90Index - 1);\n+            double expectedP99 = values.get(p99Index - 1);\n+\n+            assertEquals(expectedP90, (Double) p90.metricValue(), expectedP90 / 10);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2MTU1MA=="}, "originalCommit": null, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDcxNjcxOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMTo1NzowMVrOGZkv0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMTo1Nzo1M1rOGZkyUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2OTY1MQ==", "bodyText": "Want to call attention to these...do they seem reasonable? The size is the bytes per each percentile sensor, so 2 per source or terminal node. The minimum has to be 0 for the linear bucketing (which I found significantly more accurate than constant bucketing in my tests).\nOn the other hand, the maximum is obviously not representative of the maximum difference between the current and record timestamp. If someone's processing historical data, it can exceed this. But I figure if you're processing historical data than the e2e latency isn't really going to be at all useful anyways, so we may as well set it to something reasonable", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429469651", "createdAt": "2020-05-22T21:57:01Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "diffHunk": "@@ -149,6 +154,10 @@ public int hashCode() {\n     public static final String RATE_DESCRIPTION_PREFIX = \"The average number of \";\n     public static final String RATE_DESCRIPTION_SUFFIX = \" per second\";\n \n+    public static final int PERCENTILES_SIZE_IN_BYTES = 1000 * 1000;    // 1 MB\n+    public static double MAXIMUM_E2E_LATENCY = 100 * 24 * 60 * 60 * 1000d; // maximum latency is 1000 days", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MDI5MA==", "bodyText": "Not sure if we might want to make it configurable though? Or just pick a number and see if anyone complains?", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429470290", "createdAt": "2020-05-22T21:57:53Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "diffHunk": "@@ -149,6 +154,10 @@ public int hashCode() {\n     public static final String RATE_DESCRIPTION_PREFIX = \"The average number of \";\n     public static final String RATE_DESCRIPTION_SUFFIX = \" per second\";\n \n+    public static final int PERCENTILES_SIZE_IN_BYTES = 1000 * 1000;    // 1 MB\n+    public static double MAXIMUM_E2E_LATENCY = 100 * 24 * 60 * 60 * 1000d; // maximum latency is 1000 days", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2OTY1MQ=="}, "originalCommit": null, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDkxMjIwOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTowMTo1OFrOGZmlvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNzowOTozNVrOGaoHhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5OTgzOQ==", "bodyText": "Not sure about this... Why do we need/want to have a limit?\nNit: double space", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429499839", "createdAt": "2020-05-23T01:01:58Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -899,6 +920,28 @@ public boolean maybePunctuateSystemTime() {\n         return punctuated;\n     }\n \n+    void maybeRecordE2ELatency(final long recordTimestamp, final String nodeName) {\n+        maybeRecordE2ELatency(recordTimestamp, time.milliseconds(), nodeName);\n+    }\n+\n+    private void maybeRecordE2ELatency(final long recordTimestamp, final long now, final String nodeName) {\n+        final Sensor e2eLatencySensor = e2eLatencySensors.get(nodeName);\n+        if (e2eLatencySensor == null) {\n+            throw new IllegalStateException(\"Requested to record e2e latency but could not find sensor for node \" + nodeName);\n+        } else if (e2eLatencySensor.shouldRecord() && e2eLatencySensor.hasMetrics()) {\n+            final long e2eLatency = now - recordTimestamp;\n+            if (e2eLatency >  MAXIMUM_E2E_LATENCY) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwNTUxNw==", "bodyText": "Ack (limit explanation on comment below)", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429505517", "createdAt": "2020-05-23T02:16:06Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -899,6 +920,28 @@ public boolean maybePunctuateSystemTime() {\n         return punctuated;\n     }\n \n+    void maybeRecordE2ELatency(final long recordTimestamp, final String nodeName) {\n+        maybeRecordE2ELatency(recordTimestamp, time.milliseconds(), nodeName);\n+    }\n+\n+    private void maybeRecordE2ELatency(final long recordTimestamp, final long now, final String nodeName) {\n+        final Sensor e2eLatencySensor = e2eLatencySensors.get(nodeName);\n+        if (e2eLatencySensor == null) {\n+            throw new IllegalStateException(\"Requested to record e2e latency but could not find sensor for node \" + nodeName);\n+        } else if (e2eLatencySensor.shouldRecord() && e2eLatencySensor.hasMetrics()) {\n+            final long e2eLatency = now - recordTimestamp;\n+            if (e2eLatency >  MAXIMUM_E2E_LATENCY) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5OTgzOQ=="}, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg5NjUzNQ==", "bodyText": "Q: Wouldn't it be better to count measurements beyond the maximum latency towards the highest bucket as the Percentiles metric does?\nAdmittedly, the measured value would be quite wrong in the case of a lot of measurements greater than the maximum latency. However, with the sizes of the buckets that increase linearly, the reported values would be quite wrong anyways due to the increased approximation error. Furthermore, I guess users would put an alert on substantially smaller values.\nOTOH, not counting measurements beyond the maximum latency would falsify a bit the metric because they would not count towards the remaining 1% or 10% (for p99 and p90, respectively). Additionally, the max metric would also be falsified by not counting those measurements.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429896535", "createdAt": "2020-05-25T11:58:23Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -899,6 +920,28 @@ public boolean maybePunctuateSystemTime() {\n         return punctuated;\n     }\n \n+    void maybeRecordE2ELatency(final long recordTimestamp, final String nodeName) {\n+        maybeRecordE2ELatency(recordTimestamp, time.milliseconds(), nodeName);\n+    }\n+\n+    private void maybeRecordE2ELatency(final long recordTimestamp, final long now, final String nodeName) {\n+        final Sensor e2eLatencySensor = e2eLatencySensors.get(nodeName);\n+        if (e2eLatencySensor == null) {\n+            throw new IllegalStateException(\"Requested to record e2e latency but could not find sensor for node \" + nodeName);\n+        } else if (e2eLatencySensor.shouldRecord() && e2eLatencySensor.hasMetrics()) {\n+            final long e2eLatency = now - recordTimestamp;\n+            if (e2eLatency >  MAXIMUM_E2E_LATENCY) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5OTgzOQ=="}, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MzQ0NQ==", "bodyText": "Meta-review procedural question: In the future, can we try to avoid making the same comment in multiple places in the PR, since it leads to split discussions like this one?", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430573445", "createdAt": "2020-05-26T17:09:35Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -899,6 +920,28 @@ public boolean maybePunctuateSystemTime() {\n         return punctuated;\n     }\n \n+    void maybeRecordE2ELatency(final long recordTimestamp, final String nodeName) {\n+        maybeRecordE2ELatency(recordTimestamp, time.milliseconds(), nodeName);\n+    }\n+\n+    private void maybeRecordE2ELatency(final long recordTimestamp, final long now, final String nodeName) {\n+        final Sensor e2eLatencySensor = e2eLatencySensors.get(nodeName);\n+        if (e2eLatencySensor == null) {\n+            throw new IllegalStateException(\"Requested to record e2e latency but could not find sensor for node \" + nodeName);\n+        } else if (e2eLatencySensor.shouldRecord() && e2eLatencySensor.hasMetrics()) {\n+            final long e2eLatency = now - recordTimestamp;\n+            if (e2eLatency >  MAXIMUM_E2E_LATENCY) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5OTgzOQ=="}, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDkxMjU2OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTowMjoyM1rOGZml7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMzowNTo1M1rOGazMmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5OTg4Nw==", "bodyText": "For this case, should we record \"zero\" instead?", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429499887", "createdAt": "2020-05-23T01:02:23Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -899,6 +920,28 @@ public boolean maybePunctuateSystemTime() {\n         return punctuated;\n     }\n \n+    void maybeRecordE2ELatency(final long recordTimestamp, final String nodeName) {\n+        maybeRecordE2ELatency(recordTimestamp, time.milliseconds(), nodeName);\n+    }\n+\n+    private void maybeRecordE2ELatency(final long recordTimestamp, final long now, final String nodeName) {\n+        final Sensor e2eLatencySensor = e2eLatencySensors.get(nodeName);\n+        if (e2eLatencySensor == null) {\n+            throw new IllegalStateException(\"Requested to record e2e latency but could not find sensor for node \" + nodeName);\n+        } else if (e2eLatencySensor.shouldRecord() && e2eLatencySensor.hasMetrics()) {\n+            final long e2eLatency = now - recordTimestamp;\n+            if (e2eLatency >  MAXIMUM_E2E_LATENCY) {\n+                log.warn(\"Skipped recording e2e latency for node {} because {} is higher than maximum allowed latency {}\",\n+                         nodeName, e2eLatency, MAXIMUM_E2E_LATENCY);\n+            } else if (e2eLatency < MINIMUM_E2E_LATENCY) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwNTQ0MQ==", "bodyText": "I was debating this...my thinking here was that a negative value probably means you're processing some records with \"future\" timestamps, for whatever reason, in which case the e2e latency isn't meaningful and they shouldn't affect the statistics.\nOr, your clocks are out of sync. I suppose we could add a separate metric that counts the number of records with negative e2e latency?", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429505441", "createdAt": "2020-05-23T02:15:07Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -899,6 +920,28 @@ public boolean maybePunctuateSystemTime() {\n         return punctuated;\n     }\n \n+    void maybeRecordE2ELatency(final long recordTimestamp, final String nodeName) {\n+        maybeRecordE2ELatency(recordTimestamp, time.milliseconds(), nodeName);\n+    }\n+\n+    private void maybeRecordE2ELatency(final long recordTimestamp, final long now, final String nodeName) {\n+        final Sensor e2eLatencySensor = e2eLatencySensors.get(nodeName);\n+        if (e2eLatencySensor == null) {\n+            throw new IllegalStateException(\"Requested to record e2e latency but could not find sensor for node \" + nodeName);\n+        } else if (e2eLatencySensor.shouldRecord() && e2eLatencySensor.hasMetrics()) {\n+            final long e2eLatency = now - recordTimestamp;\n+            if (e2eLatency >  MAXIMUM_E2E_LATENCY) {\n+                log.warn(\"Skipped recording e2e latency for node {} because {} is higher than maximum allowed latency {}\",\n+                         nodeName, e2eLatency, MAXIMUM_E2E_LATENCY);\n+            } else if (e2eLatency < MINIMUM_E2E_LATENCY) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5OTg4Nw=="}, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4NjA0Mg==", "bodyText": "@ableegoldman I agree with your thinking here. IMO, we should just log the warning for now. If we see that there is a demand for such a metric, we can add it later on.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429886042", "createdAt": "2020-05-25T11:32:17Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -899,6 +920,28 @@ public boolean maybePunctuateSystemTime() {\n         return punctuated;\n     }\n \n+    void maybeRecordE2ELatency(final long recordTimestamp, final String nodeName) {\n+        maybeRecordE2ELatency(recordTimestamp, time.milliseconds(), nodeName);\n+    }\n+\n+    private void maybeRecordE2ELatency(final long recordTimestamp, final long now, final String nodeName) {\n+        final Sensor e2eLatencySensor = e2eLatencySensors.get(nodeName);\n+        if (e2eLatencySensor == null) {\n+            throw new IllegalStateException(\"Requested to record e2e latency but could not find sensor for node \" + nodeName);\n+        } else if (e2eLatencySensor.shouldRecord() && e2eLatencySensor.hasMetrics()) {\n+            final long e2eLatency = now - recordTimestamp;\n+            if (e2eLatency >  MAXIMUM_E2E_LATENCY) {\n+                log.warn(\"Skipped recording e2e latency for node {} because {} is higher than maximum allowed latency {}\",\n+                         nodeName, e2eLatency, MAXIMUM_E2E_LATENCY);\n+            } else if (e2eLatency < MINIMUM_E2E_LATENCY) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5OTg4Nw=="}, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MjQzNw==", "bodyText": "I'm fine with this as well, although I think it makes more sense either to pin to zero and warn or to just record the negative latency and warn. It feels like we're overthinking it. If the clocks are drifting a little and we report small negative numbers, the e2e latency is still low, which is still meaningful information. I really don't see a problem with just naively reporting it and not even bothering with a warning.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430572437", "createdAt": "2020-05-26T17:07:50Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -899,6 +920,28 @@ public boolean maybePunctuateSystemTime() {\n         return punctuated;\n     }\n \n+    void maybeRecordE2ELatency(final long recordTimestamp, final String nodeName) {\n+        maybeRecordE2ELatency(recordTimestamp, time.milliseconds(), nodeName);\n+    }\n+\n+    private void maybeRecordE2ELatency(final long recordTimestamp, final long now, final String nodeName) {\n+        final Sensor e2eLatencySensor = e2eLatencySensors.get(nodeName);\n+        if (e2eLatencySensor == null) {\n+            throw new IllegalStateException(\"Requested to record e2e latency but could not find sensor for node \" + nodeName);\n+        } else if (e2eLatencySensor.shouldRecord() && e2eLatencySensor.hasMetrics()) {\n+            final long e2eLatency = now - recordTimestamp;\n+            if (e2eLatency >  MAXIMUM_E2E_LATENCY) {\n+                log.warn(\"Skipped recording e2e latency for node {} because {} is higher than maximum allowed latency {}\",\n+                         nodeName, e2eLatency, MAXIMUM_E2E_LATENCY);\n+            } else if (e2eLatency < MINIMUM_E2E_LATENCY) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5OTg4Nw=="}, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1NDk3MQ==", "bodyText": "I would not record a negative latency. That seems to be kinda weird. I am fine with skipping and warning, too. Just wanted to clarify.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430754971", "createdAt": "2020-05-26T23:05:53Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -899,6 +920,28 @@ public boolean maybePunctuateSystemTime() {\n         return punctuated;\n     }\n \n+    void maybeRecordE2ELatency(final long recordTimestamp, final String nodeName) {\n+        maybeRecordE2ELatency(recordTimestamp, time.milliseconds(), nodeName);\n+    }\n+\n+    private void maybeRecordE2ELatency(final long recordTimestamp, final long now, final String nodeName) {\n+        final Sensor e2eLatencySensor = e2eLatencySensors.get(nodeName);\n+        if (e2eLatencySensor == null) {\n+            throw new IllegalStateException(\"Requested to record e2e latency but could not find sensor for node \" + nodeName);\n+        } else if (e2eLatencySensor.shouldRecord() && e2eLatencySensor.hasMetrics()) {\n+            final long e2eLatency = now - recordTimestamp;\n+            if (e2eLatency >  MAXIMUM_E2E_LATENCY) {\n+                log.warn(\"Skipped recording e2e latency for node {} because {} is higher than maximum allowed latency {}\",\n+                         nodeName, e2eLatency, MAXIMUM_E2E_LATENCY);\n+            } else if (e2eLatency < MINIMUM_E2E_LATENCY) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ5OTg4Nw=="}, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDkxMzM3OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTowMzozMVrOGZmmag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMzoyMjoxMFrOGazgJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDAxMA==", "bodyText": "Not sure about this. Why do we need a maximum to begin with? And why pick 10 days? Rather arbitrary?", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429500010", "createdAt": "2020-05-23T01:03:31Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "diffHunk": "@@ -149,6 +154,10 @@ public int hashCode() {\n     public static final String RATE_DESCRIPTION_PREFIX = \"The average number of \";\n     public static final String RATE_DESCRIPTION_SUFFIX = \" per second\";\n \n+    public static final int PERCENTILES_SIZE_IN_BYTES = 1000 * 1000;    // 1 MB\n+    public static long MAXIMUM_E2E_LATENCY = 10 * 24 * 60 * 60 * 1000L; // maximum latency is 10 days", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwNTAyOQ==", "bodyText": "10 days was just rounding up from the 7 day default retention limit. The maximum is due to the percentiles calculation which is based on incrementally sized buckets. It's a tradeoff with accuracy\nFor example if I increase it by a factor of 1000, the StreamTask percentiles test is off by almost 20% (p99 is 82.9 instead of 99). This test uses values between 0 and 100, which is probably considerably lower than most e2e latencies will be.If you look at the MetricsTest percentiles test I added, this uses random values up to the max value and can maintain the 10% accuracy up to a higher max value.\nOf course we don't know what the distribution will be, but it seems likely to be somewhere in the middle (not in the 100s of ms, not in the 10s or 1000s of days) so for reasonable accuracy we need to pick a reasonable maximum. We can definitely go higher than 10 days, but I reasoned that if you have records earlier than 10 days you're probably processing historical data and in that case the e2e latency isn't that meaningful.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429505029", "createdAt": "2020-05-23T02:08:43Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "diffHunk": "@@ -149,6 +154,10 @@ public int hashCode() {\n     public static final String RATE_DESCRIPTION_PREFIX = \"The average number of \";\n     public static final String RATE_DESCRIPTION_SUFFIX = \" per second\";\n \n+    public static final int PERCENTILES_SIZE_IN_BYTES = 1000 * 1000;    // 1 MB\n+    public static long MAXIMUM_E2E_LATENCY = 10 * 24 * 60 * 60 * 1000L; // maximum latency is 10 days", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDAxMA=="}, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg4NDIzNQ==", "bodyText": "I understand that we need a maximum due to the way the percentiles are approximated. Since the e2e latency depends on user requirements, it would make sense to consider a config for the max latency. I see two reasons for such a config.\n\n\nWe always think about near-realtime use cases, but there could also be use cases that are allowed to provide a much higher latency but the latency should still be within a certain limit. For example, one were producers are not always online. Admittedly, 10 days is already quite high.\n\n\nOTOH, decreasing the max latency would also make the metric more accurate, AFAIU. That would also be a reason for a config that users can tweak.\n\n\nFor both cases, we could leave it like it is for now and see if there is really the need for such a config. WDYT?", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429884235", "createdAt": "2020-05-25T11:28:12Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "diffHunk": "@@ -149,6 +154,10 @@ public int hashCode() {\n     public static final String RATE_DESCRIPTION_PREFIX = \"The average number of \";\n     public static final String RATE_DESCRIPTION_SUFFIX = \" per second\";\n \n+    public static final int PERCENTILES_SIZE_IN_BYTES = 1000 * 1000;    // 1 MB\n+    public static long MAXIMUM_E2E_LATENCY = 10 * 24 * 60 * 60 * 1000L; // maximum latency is 10 days", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDAxMA=="}, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3NTgyMg==", "bodyText": "This necessity makes me think that our Percentiles metric algorithm needs to be improved. Admittedly, I haven't looked at the math, but it seems like it should be possible to be more adaptive.\nI'm in favor of not adding a config and just leaving it alone for now, so that we can take the option in the future to fix the problem by fixing the algorithm.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430575822", "createdAt": "2020-05-26T17:13:50Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "diffHunk": "@@ -149,6 +154,10 @@ public int hashCode() {\n     public static final String RATE_DESCRIPTION_PREFIX = \"The average number of \";\n     public static final String RATE_DESCRIPTION_SUFFIX = \" per second\";\n \n+    public static final int PERCENTILES_SIZE_IN_BYTES = 1000 * 1000;    // 1 MB\n+    public static long MAXIMUM_E2E_LATENCY = 10 * 24 * 60 * 60 * 1000L; // maximum latency is 10 days", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDAxMA=="}, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3NzA5Mg==", "bodyText": "However, I do not think we should restrict the max value for other metrics than the percentiles one. E.g., there's no reason to restrict the value we record for the max and min metrics. You should be able to update the Percentiles implementation to apply the maximum bound in the metric record method. Otherwise, I'd recommend recording two sensors separately; one for the bounded metrics, and one for the unbounded ones.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430577092", "createdAt": "2020-05-26T17:15:58Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "diffHunk": "@@ -149,6 +154,10 @@ public int hashCode() {\n     public static final String RATE_DESCRIPTION_PREFIX = \"The average number of \";\n     public static final String RATE_DESCRIPTION_SUFFIX = \" per second\";\n \n+    public static final int PERCENTILES_SIZE_IN_BYTES = 1000 * 1000;    // 1 MB\n+    public static long MAXIMUM_E2E_LATENCY = 10 * 24 * 60 * 60 * 1000L; // maximum latency is 10 days", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDAxMA=="}, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1Mzg1Mw==", "bodyText": "Thanks for the details. Avoiding a config for now sounds good to me. This leave the path open to add a config later, or as John suggested to maybe change the algorithm (that might not need a max). I am fine with a hard coded max of 10 days.\nAlso +1 to John's suggestion to split percentiles and min/max to avoid applying the hard coded limed to min/max metric.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430753853", "createdAt": "2020-05-26T23:02:24Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "diffHunk": "@@ -149,6 +154,10 @@ public int hashCode() {\n     public static final String RATE_DESCRIPTION_PREFIX = \"The average number of \";\n     public static final String RATE_DESCRIPTION_SUFFIX = \" per second\";\n \n+    public static final int PERCENTILES_SIZE_IN_BYTES = 1000 * 1000;    // 1 MB\n+    public static long MAXIMUM_E2E_LATENCY = 10 * 24 * 60 * 60 * 1000L; // maximum latency is 10 days", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDAxMA=="}, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1OTk3NA==", "bodyText": "@cadonna @vvcephei @mjsax We have several related discussions going on across this PR so I'm just going to try and summarize here: let me know if I miss anything you still feel is important\nThe plan is to pin large/small values in the percentiles to the min/max for now and just log a warning. Since we're the only users of the Percentiles class, we can just modify it directly and avoid restricting the values for the min/max metrics as John mentioned above. If a user is experiencing small negative e2e latencies it's likely due to clock drift, and approximating as 0 seems reasonable. If they're experiencing large negative e2e latencies, there's clearly something odd going on and the e2e latency percentiles aren't meaningful. But it will still show up in the min metric and alert them to this. Presumably users may be interested to know.\nI'd like to avoid introducing a config in particular because the maximum isn't an inherent mathematical property of percentiles (obviously), it's just an artifact of the existing percentiles algorithm. We can improve this and presumably remove the requirement to set a static max, but I felt the algorithm was \"good enough\" for now (and didn't want to make large scale changes and/or rewrite it entirely right before the 2.6 deadline).\nIn sum I'd say the guiding principle for this PR and the initial metrics was to be useful without being misleadingly wrong. I think pinning the percentiles to the bounds but reporting the min/max as is achieves this, and allows us flexibility in improving the situation later", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430759974", "createdAt": "2020-05-26T23:22:10Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "diffHunk": "@@ -149,6 +154,10 @@ public int hashCode() {\n     public static final String RATE_DESCRIPTION_PREFIX = \"The average number of \";\n     public static final String RATE_DESCRIPTION_SUFFIX = \" per second\";\n \n+    public static final int PERCENTILES_SIZE_IN_BYTES = 1000 * 1000;    // 1 MB\n+    public static long MAXIMUM_E2E_LATENCY = 10 * 24 * 60 * 60 * 1000L; // maximum latency is 10 days", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDAxMA=="}, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzEzNzcxOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/metrics/ProcessorNodeMetricsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODo1MDo0NVrOGZ5zFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwODo1MDo0NVrOGZ5zFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgxNDU0OA==", "bodyText": "req:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    replay(StreamsMetricsImpl.class, streamsMetrics);\n          \n          \n            \n            \n          \n          \n            \n                    final Sensor sensor = ProcessorNodeMetrics.recordE2ELatencySensor(THREAD_ID, TASK_ID, PROCESSOR_NODE_ID, RecordingLevel.INFO, streamsMetrics);\n          \n          \n            \n            \n          \n          \n            \n                    verify(StreamsMetricsImpl.class, streamsMetrics);\n          \n          \n            \n                    assertThat(sensor, is(expectedSensor));\n          \n          \n            \n                    verifySensor(() -> ProcessorNodeMetrics.recordE2ELatencySensor(THREAD_ID, TASK_ID, PROCESSOR_NODE_ID, RecordingLevel.INFO, streamsMetrics));", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429814548", "createdAt": "2020-05-25T08:50:45Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/metrics/ProcessorNodeMetricsTest.java", "diffHunk": "@@ -260,6 +261,43 @@ public void shouldGetProcessAtSourceSensorOrForwardSensor() {\n         }\n     }\n \n+    @Test\n+    public void shouldGetRecordE2ELatencySensor() {\n+        final String operation = \"record-e2e-latency\";\n+        final String recordE2ELatencyMinDescription =\n+            \"The minimum end-to-end latency of a record, measuring by comparing the record timestamp with the \"\n+                + \"system time when it has been fully processed by the node\";\n+        final String recordE2ELatencyMaxDescription =\n+            \"The maximum end-to-end latency of a record, measuring by comparing the record timestamp with the \"\n+                + \"system time when it has been fully processed by the node\";\n+        final String recordE2ELatencyP99Description =\n+            \"The 99th percentile end-to-end latency of a record, measuring by comparing the record timestamp with the \"\n+                + \"system time when it has been fully processed by the node\";\n+        final String recordE2ELatencyP90Description =\n+            \"The 90th percentile end-to-end latency of a record, measuring by comparing the record timestamp with the \"\n+                + \"system time when it has been fully processed by the node\";\n+        expect(streamsMetrics.nodeLevelSensor(THREAD_ID, TASK_ID, PROCESSOR_NODE_ID, operation, RecordingLevel.INFO))\n+            .andReturn(expectedSensor);\n+        expect(streamsMetrics.nodeLevelTagMap(THREAD_ID, TASK_ID, PROCESSOR_NODE_ID)).andReturn(tagMap);\n+        StreamsMetricsImpl.addMinAndMaxAndP99AndP90ToSensor(\n+            expectedSensor,\n+            PROCESSOR_NODE_LEVEL_GROUP,\n+            tagMap,\n+            operation,\n+            recordE2ELatencyMinDescription,\n+            recordE2ELatencyMaxDescription,\n+            recordE2ELatencyP99Description,\n+            recordE2ELatencyP90Description\n+        );\n+\n+        replay(StreamsMetricsImpl.class, streamsMetrics);\n+\n+        final Sensor sensor = ProcessorNodeMetrics.recordE2ELatencySensor(THREAD_ID, TASK_ID, PROCESSOR_NODE_ID, RecordingLevel.INFO, streamsMetrics);\n+\n+        verify(StreamsMetricsImpl.class, streamsMetrics);\n+        assertThat(sensor, is(expectedSensor));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzE4MzI0OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorContextImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwOTowNDozOVrOGZ6O7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMTowNTo1MlrOGawTfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgyMTY3Nw==", "bodyText": "prop: For the sake of readability, could you extract this check to a method named isTerminalNode()? Even better would be to add a method named isTerminalNode() to ProcessorNode and use it here and in ProcessorTopology.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429821677", "createdAt": "2020-05-25T09:04:39Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorContextImpl.java", "diffHunk": "@@ -223,6 +223,9 @@ public StateStore getStateStore(final String name) {\n                                 final V value) {\n         setCurrentNode(child);\n         child.process(key, value);\n+        if (child.children().isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcwNzU4MQ==", "bodyText": "ack", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430707581", "createdAt": "2020-05-26T21:05:52Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorContextImpl.java", "diffHunk": "@@ -223,6 +223,9 @@ public StateStore getStateStore(final String name) {\n                                 final V value) {\n         setCurrentNode(child);\n         child.process(key, value);\n+        if (child.children().isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgyMTY3Nw=="}, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzIyNzU2OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorTopology.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwOToxODo0M1rOGZ6qxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQwOToxODo0M1rOGZ6qxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTgyODgwNg==", "bodyText": "See my comment in ProcessorContextImpl.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429828806", "createdAt": "2020-05-25T09:18:43Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorTopology.java", "diffHunk": "@@ -50,6 +51,13 @@ public ProcessorTopology(final List<ProcessorNode<?, ?>> processorNodes,\n         this.globalStateStores = Collections.unmodifiableList(globalStateStores);\n         this.storeToChangelogTopic = Collections.unmodifiableMap(storeToChangelogTopic);\n         this.repartitionTopics = Collections.unmodifiableSet(repartitionTopics);\n+\n+        this.terminalNodes = new HashSet<>();\n+        for (final ProcessorNode<?, ?> node : processorNodes) {\n+            if (node.children().isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzY3OTYzOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjowNzo0MlrOGZ_Ceg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjowNzo0MlrOGZ_Ceg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkwMDQxMA==", "bodyText": "prop: Take a look into StreamsTestUtils and see what you can re-use there to retrieve specific metrics.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429900410", "createdAt": "2020-05-25T12:07:42Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "diffHunk": "@@ -547,6 +624,28 @@ private KafkaMetric getMetric(final String operation,\n         ));\n     }\n \n+    private KafkaMetric getProcessorMetric(final String operation,\n+                                           final String nameFormat,\n+                                           final String taskId,\n+                                           final String processorNodeId,\n+                                           final String builtInMetricsVersion) {\n+        final String descriptionIsNotVerified = \"\";\n+        return metrics.metrics().get(metrics.metricName(\n+            String.format(nameFormat, operation),\n+            \"stream-processor-node-metrics\",\n+            descriptionIsNotVerified,\n+            mkMap(\n+                mkEntry(\"task-id\", taskId),\n+                mkEntry(\"processor-node-id\", processorNodeId),\n+                mkEntry(\n+                    StreamsConfig.METRICS_LATEST.equals(builtInMetricsVersion) ? THREAD_ID_TAG\n+                        : THREAD_ID_TAG_0100_TO_24,\n+                    Thread.currentThread().getName()\n+                )\n+            )\n+        ));\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NzcwNjg5OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjoxODo0NVrOGZ_ThA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMjoxODo0NVrOGZ_ThA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkwNDc3Mg==", "bodyText": "req: Please add unit tests in StreamsMetricsImplTest.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r429904772", "createdAt": "2020-05-25T12:18:45Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "diffHunk": "@@ -642,6 +651,55 @@ public static void addAvgAndMaxToSensor(final Sensor sensor,\n         );\n     }\n \n+    public static void addMinAndMaxAndP99AndP90ToSensor(final Sensor sensor,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MTg2MTU3OnYy", "diffSide": "RIGHT", "path": "clients/src/test/java/org/apache/kafka/common/metrics/MetricsTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjo1MDozOVrOGana9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMToxMjozOVrOGawgHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2MjAzOA==", "bodyText": "Not sure if it really matters, but this is not a uniform distribution (because MAX_VALUE and MIN_VALUE are not integer multiples of 1000 days. If you wanted a uniform distribution, it looks like you can use the bounded nextInt and cast to long.\nAlso, FYI, Math.abs(Long.MIN_VALUE) == Long.MIN_VALUE (which is a negative number), due to overflow.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430562038", "createdAt": "2020-05-26T16:50:39Z", "author": {"login": "vvcephei"}, "path": "clients/src/test/java/org/apache/kafka/common/metrics/MetricsTest.java", "diffHunk": "@@ -492,6 +493,52 @@ public void testPercentiles() {\n         assertEquals(75, (Double) p75.metricValue(), 1.0);\n     }\n \n+    @Test\n+    public void testPercentilesWithRandomNumbersAndLinearBucketing() {\n+        long seed = new Random().nextLong();\n+        int sizeInBytes = 1000 * 1000;   // 1MB\n+        long maximumValue = 1000 * 24 * 60 * 60 * 1000L; // if values are ms, max is 1000 days\n+\n+        try {\n+            Random prng = new Random(seed);\n+            int numberOfValues = 5000 + prng.nextInt(10_000);  // ranges is [5000, 15000]\n+\n+            Percentiles percs = new Percentiles(sizeInBytes,\n+                                                maximumValue,\n+                                                BucketSizing.LINEAR,\n+                                                new Percentile(metrics.metricName(\"test.p90\", \"grp1\"), 90),\n+                                                new Percentile(metrics.metricName(\"test.p99\", \"grp1\"), 99));\n+            MetricConfig config = new MetricConfig().eventWindow(50).samples(2);\n+            Sensor sensor = metrics.sensor(\"test\", config);\n+            sensor.add(percs);\n+            Metric p90 = this.metrics.metrics().get(metrics.metricName(\"test.p90\", \"grp1\"));\n+            Metric p99 = this.metrics.metrics().get(metrics.metricName(\"test.p99\", \"grp1\"));\n+\n+            final List<Long> values = new ArrayList<>(numberOfValues);\n+            // record two windows worth of sequential values\n+            for (int i = 0; i < numberOfValues; ++i) {\n+                long value = Math.abs(prng.nextLong()) % maximumValue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxMDgxMg==", "bodyText": "I wasn't going for a uniform distribution, just any non-pidgeonholed distribution (see existing testPercentiles for comparison). I was just trying to verify the basic validity and get a rough estimate on the accuracy here in case it turned out to be 5000% off.\nGood point about the overflow though. Pretty annoying that you can't give a bound for nextLong like you can with nextInt :/", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430710812", "createdAt": "2020-05-26T21:12:39Z", "author": {"login": "ableegoldman"}, "path": "clients/src/test/java/org/apache/kafka/common/metrics/MetricsTest.java", "diffHunk": "@@ -492,6 +493,52 @@ public void testPercentiles() {\n         assertEquals(75, (Double) p75.metricValue(), 1.0);\n     }\n \n+    @Test\n+    public void testPercentilesWithRandomNumbersAndLinearBucketing() {\n+        long seed = new Random().nextLong();\n+        int sizeInBytes = 1000 * 1000;   // 1MB\n+        long maximumValue = 1000 * 24 * 60 * 60 * 1000L; // if values are ms, max is 1000 days\n+\n+        try {\n+            Random prng = new Random(seed);\n+            int numberOfValues = 5000 + prng.nextInt(10_000);  // ranges is [5000, 15000]\n+\n+            Percentiles percs = new Percentiles(sizeInBytes,\n+                                                maximumValue,\n+                                                BucketSizing.LINEAR,\n+                                                new Percentile(metrics.metricName(\"test.p90\", \"grp1\"), 90),\n+                                                new Percentile(metrics.metricName(\"test.p99\", \"grp1\"), 99));\n+            MetricConfig config = new MetricConfig().eventWindow(50).samples(2);\n+            Sensor sensor = metrics.sensor(\"test\", config);\n+            sensor.add(percs);\n+            Metric p90 = this.metrics.metrics().get(metrics.metricName(\"test.p90\", \"grp1\"));\n+            Metric p99 = this.metrics.metrics().get(metrics.metricName(\"test.p99\", \"grp1\"));\n+\n+            final List<Long> values = new ArrayList<>(numberOfValues);\n+            // record two windows worth of sequential values\n+            for (int i = 0; i < numberOfValues; ++i) {\n+                long value = Math.abs(prng.nextLong()) % maximumValue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2MjAzOA=="}, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MTk3MDk3OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNzoyMToyMVrOGaoh1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNDoxMzowNlrOGa4z2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU4MDE4Mg==", "bodyText": "If I understand this right, we are recording sink latencies after processing, but source latencies before processing. This nicely avoids the problem with recording non-sink latencies after processing, but is it accurate?", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430580182", "createdAt": "2020-05-26T17:21:21Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -586,6 +606,7 @@ public boolean process(final long wallClockTime) {\n             log.trace(\"Start processing one record [{}]\", record);\n \n             updateProcessorContext(record, currNode, wallClockTime);\n+            maybeRecordE2ELatency(record.timestamp, wallClockTime, currNode.name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNDQ0OQ==", "bodyText": "We discussed this offline, but in case anyone else was wondering:\nYes. We can't record the latency after processing for source nodes due to our recursive DFS approach to processing, as the source node's #process actually doesn't complete until the record has been processed by every other node in the subtopology. And anyways, the intent of the source node metric is to gauge the e2e latency when the record arrives at the subtopology, which is what we are recording here.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430714449", "createdAt": "2020-05-26T21:20:27Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -586,6 +606,7 @@ public boolean process(final long wallClockTime) {\n             log.trace(\"Start processing one record [{}]\", record);\n \n             updateProcessorContext(record, currNode, wallClockTime);\n+            maybeRecordE2ELatency(record.timestamp, wallClockTime, currNode.name());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU4MDE4Mg=="}, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNjI2Mw==", "bodyText": "Thanks, @ableegoldman , I think this is a fine tradeoff. Also helping is the fact that we know all \"source nodes\" are actually instances of SourceNode, which specifically do nothing except forward every record, so whether we measure these nodes before or \"after\" their processing logic should make no practical difference at all.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430716263", "createdAt": "2020-05-26T21:24:10Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -586,6 +606,7 @@ public boolean process(final long wallClockTime) {\n             log.trace(\"Start processing one record [{}]\", record);\n \n             updateProcessorContext(record, currNode, wallClockTime);\n+            maybeRecordE2ELatency(record.timestamp, wallClockTime, currNode.name());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU4MDE4Mg=="}, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1NzI5NA==", "bodyText": "o whether we measure these nodes before or \"after\" their processing logic should make no practical difference at all.\n\nI think it make a big difference, and only recording before processing is what we want (according to what the KIP says). Otherwise, the latency includes the processing time for one or more processors (in the worst case even all processors).", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430757294", "createdAt": "2020-05-26T23:13:07Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -586,6 +606,7 @@ public boolean process(final long wallClockTime) {\n             log.trace(\"Start processing one record [{}]\", record);\n \n             updateProcessorContext(record, currNode, wallClockTime);\n+            maybeRecordE2ELatency(record.timestamp, wallClockTime, currNode.name());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU4MDE4Mg=="}, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0NjkzOQ==", "bodyText": "Sorry for my ambiguity. Please let me clarify my terms. Currently if you wait until the end of the \"process\" method, you wind up including the call to forward, which recursively calls process on all descendents of the source node. This is not what I was talking about. I meant only the time spent just in processing the SourceNode, excluding the time in \"forward\". What shall we call this? Maybe \"actual\", or \"proper\", or \"internal\" processing time?\nSo, my comment was that, given that we know the implementation of SourceNode, we know that it's \"actual\", \"proper\", \"internal\" processing time is going to be very small, probably far less than a single millisecond. So it doesn't make any practical difference whether we measure before the call for just the special case of source nodes, or magically solve the problem of measuring the e2e latency after internal processing, but not including the calls to \"forward\".\nThis is why I think it's fine to measure SourceNodes before the call to process, even though the KIP technically specifies that processors' end-to-end latencies should include processing latency. We're making a simplifying assumption that for source nodes specifically, the processing latency would be << 1, so we can ignore it.", "url": "https://github.com/apache/kafka/pull/8697#discussion_r430846939", "createdAt": "2020-05-27T04:13:06Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -586,6 +606,7 @@ public boolean process(final long wallClockTime) {\n             log.trace(\"Start processing one record [{}]\", record);\n \n             updateProcessorContext(record, currNode, wallClockTime);\n+            maybeRecordE2ELatency(record.timestamp, wallClockTime, currNode.name());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU4MDE4Mg=="}, "originalCommit": {"oid": "a31d4f97d0e11e3842633bbf08deccdf06cc9f97"}, "originalPosition": 59}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2689, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}