{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ0MzA3MDAx", "number": 9780, "title": "KAFKA-10021: Changed Kafka backing stores to use shared admin client to get end offsets and create topics", "bodyText": "The existing Kafka*BackingStore classes used by Connect all use KafkaBasedLog, which needs to frequently get the end offsets for the internal topic to know whether they are caught up. KafkaBasedLog uses its consumer to get the end offsets and to consume the records from the topic.\nHowever, the Connect internal topics are often written very infrequently. This means that when the KafkaBasedLog used in the Kafka*BackingStore classes is already caught up and its last consumer poll is waiting for new records to appear, the call to the consumer to fetch end offsets will block until the consumer returns after a new record is written (unlikely) or the consumer\u2019s fetch.max.wait.ms setting (defaults to 500ms) ends and the consumer returns no more records. IOW, the call to KafkaBasedLog.readToEnd() may block for some period of time even though it\u2019s already caught up to the end.\nInstead, we want the KafkaBasedLog.readToEnd() to always return quickly when the log is already caught up. The best way to do this is to have the KafkaBackingStore use the admin client (rather than the consumer) to fetch end offsets for the internal topic. The consumer and the admin API both use the same ListOffset broker API, so the functionality is ultimately the same but we don't have to block for any ongoing consumer activity.\nEach Connect distributed runtime includes three instances of the Kafka*BackingStore classes, which means we have three instances of KafkaBasedLog. We don't want three instances of the admin client, and should have all three instances of the KafkaBasedLog share a single admin client instance. In fact, each Kafka*BackingStore instance currently creates, uses and closes an admin client instance when it checks and initializes that store's internal topic. If we change Kafka*BackingStores to share one admin client instance, we can change that initialization logic to also reuse the supplied admin client instance.\nThe final challenge is that KafkaBasedLog has been used by projects outside of Apache Kafka. While KafkaBasedLog is definitely not in the public API for Connect, we can make these changes in ways that are backward compatible: create new constructors and deprecate the old constructors. Connect can be changed to only use the new constructors, and this will give time for any downstream users to make changes.\nThese changes are implemented as follows:\n\nAdd a KafkaBasedLog constructor to accept in its parameters a supplier from which it can get an admin instance, and deprecate the old constructor. We need a supplier rather than just passing an instance because KafkaBasedLog is instantiated before Connect starts up, so we need to create the admin instance only when needed. At the same time, we'll change the existing init function parameter from a no-arg function to accept an admin instance as an argument, allowing that init function to reuse the shared admin instance used by the KafkaBasedLog. Note: if no admin supplier is provided (in deprecated constructor that is no longer used in AK), the consumer is still used to get latest offsets.\nAdd to the Kafka*BackingStore classes a new constructor with the same parameters but with an admin supplier, and deprecate the old constructor. When the classes instantiate its KafkaBasedLog instance, it would pass the admin supplier and pass an init function that takes an admin instance.\nCreate a new SharedTopicAdmin that lazily creates the TopicAdmin (and underlying Admin client) when required, and closes the admin objects when the SharedTopicAdmin is closed.\nModify the existing TopicAdmin (used only in Connect) to encapsulate the logic of fetching end offsets using the admin client, simplifying the logic in KafkaBasedLog mentioned in #1 above. Doing this also makes it easier to test that logic.\nChange ConnectDistributed to create a SharedTopicAdmin instance (that is AutoCloseable) before creating the Kafka*BackingStore instances, passing the SharedTopicAdmin (which is an admin supplier) to all three Kafka*BackingStore objects, and finally always closing the SharedTopicAdmin upon termination. (Shutdown of the worker occurs outside of the ConnectDistributed code, so modify DistributedHerder to take in its constructor additional AutoCloseable objects that should be closed when the herder is closed, and then modify ConnectDistributed to pass the SharedTopicAdmin as one of those AutoCloseable instances.)\nChange MirrorMaker similarly to ConnectDistributed.\nChange existing unit tests to no longer use deprecated constructors.\nAdd unit tests for new functionality.\n\nThis change should be backported to fix the bug in recent releases.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-12-22T19:00:59Z", "url": "https://github.com/apache/kafka/pull/9780", "merged": true, "mergeCommit": {"oid": "982ea2f6a471c217c7400a725c9504d9d8348d02"}, "closed": true, "closedAt": "2021-02-09T17:09:42Z", "author": {"login": "rhauch"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdowu79gBqjQxNDE2OTQ3NDQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABd4XCyFgH2gAyNTQ0MzA3MDAxOjU0YTNmMTBiYzdiZTg5OWNiNDdjNjUwMGQ1MWZmMmNlYzNlMWU1NzI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fe6319e90d46b521e16184d8fe997cedf1a709b8", "author": {"user": {"login": "rhauch", "name": "Randall Hauch"}}, "url": "https://github.com/apache/kafka/commit/fe6319e90d46b521e16184d8fe997cedf1a709b8", "committedDate": "2020-12-22T18:58:42Z", "message": "KAFKA-10021: Changed Kafka backing stores to use shared admin client to get end offsets and create topics\n\nThe existing `Kafka*BackingStore` classes used by Connect all use `KafkaBasedLog`, which needs to frequently get the end offsets for the internal topic to know whether they are caught up. `KafkaBasedLog` uses its consumer to get the end offsets and to consume the records from the topic.\n\nHowever, the Connect internal topics are often written very infrequently. This means that when the `KafkaBasedLog` used in the `Kafka*BackingStore` classes is already caught up and its last consumer poll is waiting for new records to appear, the call to the consumer to fetch end offsets will block until the consumer returns after a new record is written (unlikely) or the consumer\u2019s `fetch.max.wait.ms` setting (defaults to 500ms) ends and the consumer returns no more records. IOW, the call to `KafkaBasedLog.readToEnd()` may block for some period of time even though it\u2019s already caught up to the end.\n\nInstead, we want the `KafkaBasedLog.readToEnd()` to always return quickly when the log is already caught up. The best way to do this is to have the `KafkaBackingStore` use the admin client (rather than the consumer) to fetch end offsets for the internal topic. The consumer and the admin API both use the same `ListOffset` broker API, so the functionality is ultimately the same but we don't have to block for any ongoing consumer activity.\n\nEach Connect distributed runtime includes three instances of the `Kafka*BackingStore` classes, which means we have three instances of `KafkaBasedLog`. We don't want three instances of the admin client, and should have all three instances of the `KafkaBasedLog` share a single admin client instance. In fact, each `Kafka*BackingStore` instance currently creates, uses and closes an admin client instance when it checks and initializes that store's internal topic. If we change `Kafka*BackingStores` to share one admin client instance, we can change that initialization logic to also reuse the supplied admin client instance.\n\nThe final challenge is that `KafkaBasedLog` has been used by projects outside of Apache Kafka. While `KafkaBasedLog` is definitely not in the public API for Connect, we can make these changes in ways that are backward compatible: create new constructors and deprecate the old constructors. Connect can be changed to only use the new constructors, and this will give time for any downstream users to make changes.\n\nThese changes are implemented as follows:\n1. Add a `KafkaBasedLog` constructor to accept in its parameters a supplier from which it can get an admin instance, and deprecate the old constructor. We need a supplier rather than just passing an instance because `KafkaBasedLog` is instantiated before Connect starts up, so we need to create the admin instance only when needed. At the same time, we'll change the existing init function parameter from a no-arg function to accept an admin instance as an argument, allowing that init function to reuse the shared admin instance used by the `KafkaBasedLog`. Note: if no admin supplier is provided (in deprecated constructor that is no longer used in AK), the consumer is still used to get latest offsets.\n2. Add to the `Kafka*BackingStore` classes a new constructor with the same parameters but with an admin supplier, and deprecate the old constructor. When the classes instantiate its `KafkaBasedLog` instance, it would pass the admin supplier and pass an init function that takes an admin instance.\n3. Create a new `SharedTopicAdmin` that lazily creates the `TopicAdmin` (and underlying Admin client) when required, and closes the admin objects when the `SharedTopicAdmin` is closed.\n4. Modify the existing `TopicAdmin` (used only in Connect) to encapsulate the logic of fetching end offsets using the admin client, simplifying the logic in `KafkaBasedLog` mentioned in #1 above. Doing this also makes it easier to test that logic.\n5. Change `ConnectDistributed` to create a `SharedTopicAdmin` instance (that is `AutoCloseable`) before creating the `Kafka*BackingStore` instances, passing the `SharedTopicAdmin` (which is an admin supplier) to all three `Kafka*BackingStore objects`, and finally always closing the `SharedTopicAdmin` upon termination. (Shutdown of the worker occurs outside of the `ConnectDistributed` code, so modify `DistributedHerder` to take in its constructor additional `AutoCloseable` objects that should be closed when the herder is closed, and then modify `ConnectDistributed` to pass the `SharedTopicAdmin` as one of those `AutoCloseable` instances.)\n6. Change `MirrorMaker` similarly to `ConnectDistributed`.\n7. Change existing unit tests to no longer use deprecated constructors.\n8. Add unit tests for new functionality."}, "afterCommit": {"oid": "d0fa4da1ba5973ae82de0eb2f16c86cbb8dfbd0b", "author": {"user": {"login": "rhauch", "name": "Randall Hauch"}}, "url": "https://github.com/apache/kafka/commit/d0fa4da1ba5973ae82de0eb2f16c86cbb8dfbd0b", "committedDate": "2020-12-22T20:39:39Z", "message": "KAFKA-10021: Changed Kafka backing stores to use shared admin client to get end offsets and create topics\n\nThe existing `Kafka*BackingStore` classes used by Connect all use `KafkaBasedLog`, which needs to frequently get the end offsets for the internal topic to know whether they are caught up. `KafkaBasedLog` uses its consumer to get the end offsets and to consume the records from the topic.\n\nHowever, the Connect internal topics are often written very infrequently. This means that when the `KafkaBasedLog` used in the `Kafka*BackingStore` classes is already caught up and its last consumer poll is waiting for new records to appear, the call to the consumer to fetch end offsets will block until the consumer returns after a new record is written (unlikely) or the consumer\u2019s `fetch.max.wait.ms` setting (defaults to 500ms) ends and the consumer returns no more records. IOW, the call to `KafkaBasedLog.readToEnd()` may block for some period of time even though it\u2019s already caught up to the end.\n\nInstead, we want the `KafkaBasedLog.readToEnd()` to always return quickly when the log is already caught up. The best way to do this is to have the `KafkaBackingStore` use the admin client (rather than the consumer) to fetch end offsets for the internal topic. The consumer and the admin API both use the same `ListOffset` broker API, so the functionality is ultimately the same but we don't have to block for any ongoing consumer activity.\n\nEach Connect distributed runtime includes three instances of the `Kafka*BackingStore` classes, which means we have three instances of `KafkaBasedLog`. We don't want three instances of the admin client, and should have all three instances of the `KafkaBasedLog` share a single admin client instance. In fact, each `Kafka*BackingStore` instance currently creates, uses and closes an admin client instance when it checks and initializes that store's internal topic. If we change `Kafka*BackingStores` to share one admin client instance, we can change that initialization logic to also reuse the supplied admin client instance.\n\nThe final challenge is that `KafkaBasedLog` has been used by projects outside of Apache Kafka. While `KafkaBasedLog` is definitely not in the public API for Connect, we can make these changes in ways that are backward compatible: create new constructors and deprecate the old constructors. Connect can be changed to only use the new constructors, and this will give time for any downstream users to make changes.\n\nThese changes are implemented as follows:\n1. Add a `KafkaBasedLog` constructor to accept in its parameters a supplier from which it can get an admin instance, and deprecate the old constructor. We need a supplier rather than just passing an instance because `KafkaBasedLog` is instantiated before Connect starts up, so we need to create the admin instance only when needed. At the same time, we'll change the existing init function parameter from a no-arg function to accept an admin instance as an argument, allowing that init function to reuse the shared admin instance used by the `KafkaBasedLog`. Note: if no admin supplier is provided (in deprecated constructor that is no longer used in AK), the consumer is still used to get latest offsets.\n2. Add to the `Kafka*BackingStore` classes a new constructor with the same parameters but with an admin supplier, and deprecate the old constructor. When the classes instantiate its `KafkaBasedLog` instance, it would pass the admin supplier and pass an init function that takes an admin instance.\n3. Create a new `SharedTopicAdmin` that lazily creates the `TopicAdmin` (and underlying Admin client) when required, and closes the admin objects when the `SharedTopicAdmin` is closed.\n4. Modify the existing `TopicAdmin` (used only in Connect) to encapsulate the logic of fetching end offsets using the admin client, simplifying the logic in `KafkaBasedLog` mentioned in #1 above. Doing this also makes it easier to test that logic.\n5. Change `ConnectDistributed` to create a `SharedTopicAdmin` instance (that is `AutoCloseable`) before creating the `Kafka*BackingStore` instances, passing the `SharedTopicAdmin` (which is an admin supplier) to all three `Kafka*BackingStore objects`, and finally always closing the `SharedTopicAdmin` upon termination. (Shutdown of the worker occurs outside of the `ConnectDistributed` code, so modify `DistributedHerder` to take in its constructor additional `AutoCloseable` objects that should be closed when the herder is closed, and then modify `ConnectDistributed` to pass the `SharedTopicAdmin` as one of those `AutoCloseable` instances.)\n6. Change `MirrorMaker` similarly to `ConnectDistributed`.\n7. Change existing unit tests to no longer use deprecated constructors.\n8. Add unit tests for new functionality."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d0fa4da1ba5973ae82de0eb2f16c86cbb8dfbd0b", "author": {"user": {"login": "rhauch", "name": "Randall Hauch"}}, "url": "https://github.com/apache/kafka/commit/d0fa4da1ba5973ae82de0eb2f16c86cbb8dfbd0b", "committedDate": "2020-12-22T20:39:39Z", "message": "KAFKA-10021: Changed Kafka backing stores to use shared admin client to get end offsets and create topics\n\nThe existing `Kafka*BackingStore` classes used by Connect all use `KafkaBasedLog`, which needs to frequently get the end offsets for the internal topic to know whether they are caught up. `KafkaBasedLog` uses its consumer to get the end offsets and to consume the records from the topic.\n\nHowever, the Connect internal topics are often written very infrequently. This means that when the `KafkaBasedLog` used in the `Kafka*BackingStore` classes is already caught up and its last consumer poll is waiting for new records to appear, the call to the consumer to fetch end offsets will block until the consumer returns after a new record is written (unlikely) or the consumer\u2019s `fetch.max.wait.ms` setting (defaults to 500ms) ends and the consumer returns no more records. IOW, the call to `KafkaBasedLog.readToEnd()` may block for some period of time even though it\u2019s already caught up to the end.\n\nInstead, we want the `KafkaBasedLog.readToEnd()` to always return quickly when the log is already caught up. The best way to do this is to have the `KafkaBackingStore` use the admin client (rather than the consumer) to fetch end offsets for the internal topic. The consumer and the admin API both use the same `ListOffset` broker API, so the functionality is ultimately the same but we don't have to block for any ongoing consumer activity.\n\nEach Connect distributed runtime includes three instances of the `Kafka*BackingStore` classes, which means we have three instances of `KafkaBasedLog`. We don't want three instances of the admin client, and should have all three instances of the `KafkaBasedLog` share a single admin client instance. In fact, each `Kafka*BackingStore` instance currently creates, uses and closes an admin client instance when it checks and initializes that store's internal topic. If we change `Kafka*BackingStores` to share one admin client instance, we can change that initialization logic to also reuse the supplied admin client instance.\n\nThe final challenge is that `KafkaBasedLog` has been used by projects outside of Apache Kafka. While `KafkaBasedLog` is definitely not in the public API for Connect, we can make these changes in ways that are backward compatible: create new constructors and deprecate the old constructors. Connect can be changed to only use the new constructors, and this will give time for any downstream users to make changes.\n\nThese changes are implemented as follows:\n1. Add a `KafkaBasedLog` constructor to accept in its parameters a supplier from which it can get an admin instance, and deprecate the old constructor. We need a supplier rather than just passing an instance because `KafkaBasedLog` is instantiated before Connect starts up, so we need to create the admin instance only when needed. At the same time, we'll change the existing init function parameter from a no-arg function to accept an admin instance as an argument, allowing that init function to reuse the shared admin instance used by the `KafkaBasedLog`. Note: if no admin supplier is provided (in deprecated constructor that is no longer used in AK), the consumer is still used to get latest offsets.\n2. Add to the `Kafka*BackingStore` classes a new constructor with the same parameters but with an admin supplier, and deprecate the old constructor. When the classes instantiate its `KafkaBasedLog` instance, it would pass the admin supplier and pass an init function that takes an admin instance.\n3. Create a new `SharedTopicAdmin` that lazily creates the `TopicAdmin` (and underlying Admin client) when required, and closes the admin objects when the `SharedTopicAdmin` is closed.\n4. Modify the existing `TopicAdmin` (used only in Connect) to encapsulate the logic of fetching end offsets using the admin client, simplifying the logic in `KafkaBasedLog` mentioned in #1 above. Doing this also makes it easier to test that logic.\n5. Change `ConnectDistributed` to create a `SharedTopicAdmin` instance (that is `AutoCloseable`) before creating the `Kafka*BackingStore` instances, passing the `SharedTopicAdmin` (which is an admin supplier) to all three `Kafka*BackingStore objects`, and finally always closing the `SharedTopicAdmin` upon termination. (Shutdown of the worker occurs outside of the `ConnectDistributed` code, so modify `DistributedHerder` to take in its constructor additional `AutoCloseable` objects that should be closed when the herder is closed, and then modify `ConnectDistributed` to pass the `SharedTopicAdmin` as one of those `AutoCloseable` instances.)\n6. Change `MirrorMaker` similarly to `ConnectDistributed`.\n7. Change existing unit tests to no longer use deprecated constructors.\n8. Add unit tests for new functionality."}, "afterCommit": {"oid": "1f098220d5c31c5a65f5ef18961ecfade20b1f37", "author": {"user": {"login": "rhauch", "name": "Randall Hauch"}}, "url": "https://github.com/apache/kafka/commit/1f098220d5c31c5a65f5ef18961ecfade20b1f37", "committedDate": "2020-12-23T00:09:46Z", "message": "KAFKA-10021: Changed Kafka backing stores to use shared admin client to get end offsets and create topics\n\nThe existing `Kafka*BackingStore` classes used by Connect all use `KafkaBasedLog`, which needs to frequently get the end offsets for the internal topic to know whether they are caught up. `KafkaBasedLog` uses its consumer to get the end offsets and to consume the records from the topic.\n\nHowever, the Connect internal topics are often written very infrequently. This means that when the `KafkaBasedLog` used in the `Kafka*BackingStore` classes is already caught up and its last consumer poll is waiting for new records to appear, the call to the consumer to fetch end offsets will block until the consumer returns after a new record is written (unlikely) or the consumer\u2019s `fetch.max.wait.ms` setting (defaults to 500ms) ends and the consumer returns no more records. IOW, the call to `KafkaBasedLog.readToEnd()` may block for some period of time even though it\u2019s already caught up to the end.\n\nInstead, we want the `KafkaBasedLog.readToEnd()` to always return quickly when the log is already caught up. The best way to do this is to have the `KafkaBackingStore` use the admin client (rather than the consumer) to fetch end offsets for the internal topic. The consumer and the admin API both use the same `ListOffset` broker API, so the functionality is ultimately the same but we don't have to block for any ongoing consumer activity.\n\nEach Connect distributed runtime includes three instances of the `Kafka*BackingStore` classes, which means we have three instances of `KafkaBasedLog`. We don't want three instances of the admin client, and should have all three instances of the `KafkaBasedLog` share a single admin client instance. In fact, each `Kafka*BackingStore` instance currently creates, uses and closes an admin client instance when it checks and initializes that store's internal topic. If we change `Kafka*BackingStores` to share one admin client instance, we can change that initialization logic to also reuse the supplied admin client instance.\n\nThe final challenge is that `KafkaBasedLog` has been used by projects outside of Apache Kafka. While `KafkaBasedLog` is definitely not in the public API for Connect, we can make these changes in ways that are backward compatible: create new constructors and deprecate the old constructors. Connect can be changed to only use the new constructors, and this will give time for any downstream users to make changes.\n\nThese changes are implemented as follows:\n1. Add a `KafkaBasedLog` constructor to accept in its parameters a supplier from which it can get an admin instance, and deprecate the old constructor. We need a supplier rather than just passing an instance because `KafkaBasedLog` is instantiated before Connect starts up, so we need to create the admin instance only when needed. At the same time, we'll change the existing init function parameter from a no-arg function to accept an admin instance as an argument, allowing that init function to reuse the shared admin instance used by the `KafkaBasedLog`. Note: if no admin supplier is provided (in deprecated constructor that is no longer used in AK), the consumer is still used to get latest offsets.\n2. Add to the `Kafka*BackingStore` classes a new constructor with the same parameters but with an admin supplier, and deprecate the old constructor. When the classes instantiate its `KafkaBasedLog` instance, it would pass the admin supplier and pass an init function that takes an admin instance.\n3. Create a new `SharedTopicAdmin` that lazily creates the `TopicAdmin` (and underlying Admin client) when required, and closes the admin objects when the `SharedTopicAdmin` is closed.\n4. Modify the existing `TopicAdmin` (used only in Connect) to encapsulate the logic of fetching end offsets using the admin client, simplifying the logic in `KafkaBasedLog` mentioned in #1 above. Doing this also makes it easier to test that logic.\n5. Change `ConnectDistributed` to create a `SharedTopicAdmin` instance (that is `AutoCloseable`) before creating the `Kafka*BackingStore` instances, passing the `SharedTopicAdmin` (which is an admin supplier) to all three `Kafka*BackingStore objects`, and finally always closing the `SharedTopicAdmin` upon termination. (Shutdown of the worker occurs outside of the `ConnectDistributed` code, so modify `DistributedHerder` to take in its constructor additional `AutoCloseable` objects that should be closed when the herder is closed, and then modify `ConnectDistributed` to pass the `SharedTopicAdmin` as one of those `AutoCloseable` instances.)\n6. Change `MirrorMaker` similarly to `ConnectDistributed`.\n7. Change existing unit tests to no longer use deprecated constructors.\n8. Add unit tests for new functionality."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1f098220d5c31c5a65f5ef18961ecfade20b1f37", "author": {"user": {"login": "rhauch", "name": "Randall Hauch"}}, "url": "https://github.com/apache/kafka/commit/1f098220d5c31c5a65f5ef18961ecfade20b1f37", "committedDate": "2020-12-23T00:09:46Z", "message": "KAFKA-10021: Changed Kafka backing stores to use shared admin client to get end offsets and create topics\n\nThe existing `Kafka*BackingStore` classes used by Connect all use `KafkaBasedLog`, which needs to frequently get the end offsets for the internal topic to know whether they are caught up. `KafkaBasedLog` uses its consumer to get the end offsets and to consume the records from the topic.\n\nHowever, the Connect internal topics are often written very infrequently. This means that when the `KafkaBasedLog` used in the `Kafka*BackingStore` classes is already caught up and its last consumer poll is waiting for new records to appear, the call to the consumer to fetch end offsets will block until the consumer returns after a new record is written (unlikely) or the consumer\u2019s `fetch.max.wait.ms` setting (defaults to 500ms) ends and the consumer returns no more records. IOW, the call to `KafkaBasedLog.readToEnd()` may block for some period of time even though it\u2019s already caught up to the end.\n\nInstead, we want the `KafkaBasedLog.readToEnd()` to always return quickly when the log is already caught up. The best way to do this is to have the `KafkaBackingStore` use the admin client (rather than the consumer) to fetch end offsets for the internal topic. The consumer and the admin API both use the same `ListOffset` broker API, so the functionality is ultimately the same but we don't have to block for any ongoing consumer activity.\n\nEach Connect distributed runtime includes three instances of the `Kafka*BackingStore` classes, which means we have three instances of `KafkaBasedLog`. We don't want three instances of the admin client, and should have all three instances of the `KafkaBasedLog` share a single admin client instance. In fact, each `Kafka*BackingStore` instance currently creates, uses and closes an admin client instance when it checks and initializes that store's internal topic. If we change `Kafka*BackingStores` to share one admin client instance, we can change that initialization logic to also reuse the supplied admin client instance.\n\nThe final challenge is that `KafkaBasedLog` has been used by projects outside of Apache Kafka. While `KafkaBasedLog` is definitely not in the public API for Connect, we can make these changes in ways that are backward compatible: create new constructors and deprecate the old constructors. Connect can be changed to only use the new constructors, and this will give time for any downstream users to make changes.\n\nThese changes are implemented as follows:\n1. Add a `KafkaBasedLog` constructor to accept in its parameters a supplier from which it can get an admin instance, and deprecate the old constructor. We need a supplier rather than just passing an instance because `KafkaBasedLog` is instantiated before Connect starts up, so we need to create the admin instance only when needed. At the same time, we'll change the existing init function parameter from a no-arg function to accept an admin instance as an argument, allowing that init function to reuse the shared admin instance used by the `KafkaBasedLog`. Note: if no admin supplier is provided (in deprecated constructor that is no longer used in AK), the consumer is still used to get latest offsets.\n2. Add to the `Kafka*BackingStore` classes a new constructor with the same parameters but with an admin supplier, and deprecate the old constructor. When the classes instantiate its `KafkaBasedLog` instance, it would pass the admin supplier and pass an init function that takes an admin instance.\n3. Create a new `SharedTopicAdmin` that lazily creates the `TopicAdmin` (and underlying Admin client) when required, and closes the admin objects when the `SharedTopicAdmin` is closed.\n4. Modify the existing `TopicAdmin` (used only in Connect) to encapsulate the logic of fetching end offsets using the admin client, simplifying the logic in `KafkaBasedLog` mentioned in #1 above. Doing this also makes it easier to test that logic.\n5. Change `ConnectDistributed` to create a `SharedTopicAdmin` instance (that is `AutoCloseable`) before creating the `Kafka*BackingStore` instances, passing the `SharedTopicAdmin` (which is an admin supplier) to all three `Kafka*BackingStore objects`, and finally always closing the `SharedTopicAdmin` upon termination. (Shutdown of the worker occurs outside of the `ConnectDistributed` code, so modify `DistributedHerder` to take in its constructor additional `AutoCloseable` objects that should be closed when the herder is closed, and then modify `ConnectDistributed` to pass the `SharedTopicAdmin` as one of those `AutoCloseable` instances.)\n6. Change `MirrorMaker` similarly to `ConnectDistributed`.\n7. Change existing unit tests to no longer use deprecated constructors.\n8. Add unit tests for new functionality."}, "afterCommit": {"oid": "1916a9649ffd680c90f26b8b9839ef280983c8db", "author": {"user": {"login": "rhauch", "name": "Randall Hauch"}}, "url": "https://github.com/apache/kafka/commit/1916a9649ffd680c90f26b8b9839ef280983c8db", "committedDate": "2021-02-04T16:24:37Z", "message": "KAFKA-10021: Changed Kafka backing stores to use shared admin client to get end offsets and create topics\n\nThe existing `Kafka*BackingStore` classes used by Connect all use `KafkaBasedLog`, which needs to frequently get the end offsets for the internal topic to know whether they are caught up. `KafkaBasedLog` uses its consumer to get the end offsets and to consume the records from the topic.\n\nHowever, the Connect internal topics are often written very infrequently. This means that when the `KafkaBasedLog` used in the `Kafka*BackingStore` classes is already caught up and its last consumer poll is waiting for new records to appear, the call to the consumer to fetch end offsets will block until the consumer returns after a new record is written (unlikely) or the consumer\u2019s `fetch.max.wait.ms` setting (defaults to 500ms) ends and the consumer returns no more records. IOW, the call to `KafkaBasedLog.readToEnd()` may block for some period of time even though it\u2019s already caught up to the end.\n\nInstead, we want the `KafkaBasedLog.readToEnd()` to always return quickly when the log is already caught up. The best way to do this is to have the `KafkaBackingStore` use the admin client (rather than the consumer) to fetch end offsets for the internal topic. The consumer and the admin API both use the same `ListOffset` broker API, so the functionality is ultimately the same but we don't have to block for any ongoing consumer activity.\n\nEach Connect distributed runtime includes three instances of the `Kafka*BackingStore` classes, which means we have three instances of `KafkaBasedLog`. We don't want three instances of the admin client, and should have all three instances of the `KafkaBasedLog` share a single admin client instance. In fact, each `Kafka*BackingStore` instance currently creates, uses and closes an admin client instance when it checks and initializes that store's internal topic. If we change `Kafka*BackingStores` to share one admin client instance, we can change that initialization logic to also reuse the supplied admin client instance.\n\nThe final challenge is that `KafkaBasedLog` has been used by projects outside of Apache Kafka. While `KafkaBasedLog` is definitely not in the public API for Connect, we can make these changes in ways that are backward compatible: create new constructors and deprecate the old constructors. Connect can be changed to only use the new constructors, and this will give time for any downstream users to make changes.\n\nThese changes are implemented as follows:\n1. Add a `KafkaBasedLog` constructor to accept in its parameters a supplier from which it can get an admin instance, and deprecate the old constructor. We need a supplier rather than just passing an instance because `KafkaBasedLog` is instantiated before Connect starts up, so we need to create the admin instance only when needed. At the same time, we'll change the existing init function parameter from a no-arg function to accept an admin instance as an argument, allowing that init function to reuse the shared admin instance used by the `KafkaBasedLog`. Note: if no admin supplier is provided (in deprecated constructor that is no longer used in AK), the consumer is still used to get latest offsets.\n2. Add to the `Kafka*BackingStore` classes a new constructor with the same parameters but with an admin supplier, and deprecate the old constructor. When the classes instantiate its `KafkaBasedLog` instance, it would pass the admin supplier and pass an init function that takes an admin instance.\n3. Create a new `SharedTopicAdmin` that lazily creates the `TopicAdmin` (and underlying Admin client) when required, and closes the admin objects when the `SharedTopicAdmin` is closed.\n4. Modify the existing `TopicAdmin` (used only in Connect) to encapsulate the logic of fetching end offsets using the admin client, simplifying the logic in `KafkaBasedLog` mentioned in #1 above. Doing this also makes it easier to test that logic.\n5. Change `ConnectDistributed` to create a `SharedTopicAdmin` instance (that is `AutoCloseable`) before creating the `Kafka*BackingStore` instances, passing the `SharedTopicAdmin` (which is an admin supplier) to all three `Kafka*BackingStore objects`, and finally always closing the `SharedTopicAdmin` upon termination. (Shutdown of the worker occurs outside of the `ConnectDistributed` code, so modify `DistributedHerder` to take in its constructor additional `AutoCloseable` objects that should be closed when the herder is closed, and then modify `ConnectDistributed` to pass the `SharedTopicAdmin` as one of those `AutoCloseable` instances.)\n6. Change `MirrorMaker` similarly to `ConnectDistributed`.\n7. Change existing unit tests to no longer use deprecated constructors.\n8. Add unit tests for new functionality."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1916a9649ffd680c90f26b8b9839ef280983c8db", "author": {"user": {"login": "rhauch", "name": "Randall Hauch"}}, "url": "https://github.com/apache/kafka/commit/1916a9649ffd680c90f26b8b9839ef280983c8db", "committedDate": "2021-02-04T16:24:37Z", "message": "KAFKA-10021: Changed Kafka backing stores to use shared admin client to get end offsets and create topics\n\nThe existing `Kafka*BackingStore` classes used by Connect all use `KafkaBasedLog`, which needs to frequently get the end offsets for the internal topic to know whether they are caught up. `KafkaBasedLog` uses its consumer to get the end offsets and to consume the records from the topic.\n\nHowever, the Connect internal topics are often written very infrequently. This means that when the `KafkaBasedLog` used in the `Kafka*BackingStore` classes is already caught up and its last consumer poll is waiting for new records to appear, the call to the consumer to fetch end offsets will block until the consumer returns after a new record is written (unlikely) or the consumer\u2019s `fetch.max.wait.ms` setting (defaults to 500ms) ends and the consumer returns no more records. IOW, the call to `KafkaBasedLog.readToEnd()` may block for some period of time even though it\u2019s already caught up to the end.\n\nInstead, we want the `KafkaBasedLog.readToEnd()` to always return quickly when the log is already caught up. The best way to do this is to have the `KafkaBackingStore` use the admin client (rather than the consumer) to fetch end offsets for the internal topic. The consumer and the admin API both use the same `ListOffset` broker API, so the functionality is ultimately the same but we don't have to block for any ongoing consumer activity.\n\nEach Connect distributed runtime includes three instances of the `Kafka*BackingStore` classes, which means we have three instances of `KafkaBasedLog`. We don't want three instances of the admin client, and should have all three instances of the `KafkaBasedLog` share a single admin client instance. In fact, each `Kafka*BackingStore` instance currently creates, uses and closes an admin client instance when it checks and initializes that store's internal topic. If we change `Kafka*BackingStores` to share one admin client instance, we can change that initialization logic to also reuse the supplied admin client instance.\n\nThe final challenge is that `KafkaBasedLog` has been used by projects outside of Apache Kafka. While `KafkaBasedLog` is definitely not in the public API for Connect, we can make these changes in ways that are backward compatible: create new constructors and deprecate the old constructors. Connect can be changed to only use the new constructors, and this will give time for any downstream users to make changes.\n\nThese changes are implemented as follows:\n1. Add a `KafkaBasedLog` constructor to accept in its parameters a supplier from which it can get an admin instance, and deprecate the old constructor. We need a supplier rather than just passing an instance because `KafkaBasedLog` is instantiated before Connect starts up, so we need to create the admin instance only when needed. At the same time, we'll change the existing init function parameter from a no-arg function to accept an admin instance as an argument, allowing that init function to reuse the shared admin instance used by the `KafkaBasedLog`. Note: if no admin supplier is provided (in deprecated constructor that is no longer used in AK), the consumer is still used to get latest offsets.\n2. Add to the `Kafka*BackingStore` classes a new constructor with the same parameters but with an admin supplier, and deprecate the old constructor. When the classes instantiate its `KafkaBasedLog` instance, it would pass the admin supplier and pass an init function that takes an admin instance.\n3. Create a new `SharedTopicAdmin` that lazily creates the `TopicAdmin` (and underlying Admin client) when required, and closes the admin objects when the `SharedTopicAdmin` is closed.\n4. Modify the existing `TopicAdmin` (used only in Connect) to encapsulate the logic of fetching end offsets using the admin client, simplifying the logic in `KafkaBasedLog` mentioned in #1 above. Doing this also makes it easier to test that logic.\n5. Change `ConnectDistributed` to create a `SharedTopicAdmin` instance (that is `AutoCloseable`) before creating the `Kafka*BackingStore` instances, passing the `SharedTopicAdmin` (which is an admin supplier) to all three `Kafka*BackingStore objects`, and finally always closing the `SharedTopicAdmin` upon termination. (Shutdown of the worker occurs outside of the `ConnectDistributed` code, so modify `DistributedHerder` to take in its constructor additional `AutoCloseable` objects that should be closed when the herder is closed, and then modify `ConnectDistributed` to pass the `SharedTopicAdmin` as one of those `AutoCloseable` instances.)\n6. Change `MirrorMaker` similarly to `ConnectDistributed`.\n7. Change existing unit tests to no longer use deprecated constructors.\n8. Add unit tests for new functionality."}, "afterCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17", "author": {"user": {"login": "rhauch", "name": "Randall Hauch"}}, "url": "https://github.com/apache/kafka/commit/acbe90c6e6198de3626598f14c2b172c05106f17", "committedDate": "2021-02-04T17:45:02Z", "message": "KAFKA-10021: Changed Kafka backing stores to use shared admin client to get end offsets and create topics\n\nThe existing `Kafka*BackingStore` classes used by Connect all use `KafkaBasedLog`, which needs to frequently get the end offsets for the internal topic to know whether they are caught up. `KafkaBasedLog` uses its consumer to get the end offsets and to consume the records from the topic.\n\nHowever, the Connect internal topics are often written very infrequently. This means that when the `KafkaBasedLog` used in the `Kafka*BackingStore` classes is already caught up and its last consumer poll is waiting for new records to appear, the call to the consumer to fetch end offsets will block until the consumer returns after a new record is written (unlikely) or the consumer\u2019s `fetch.max.wait.ms` setting (defaults to 500ms) ends and the consumer returns no more records. IOW, the call to `KafkaBasedLog.readToEnd()` may block for some period of time even though it\u2019s already caught up to the end.\n\nInstead, we want the `KafkaBasedLog.readToEnd()` to always return quickly when the log is already caught up. The best way to do this is to have the `KafkaBackingStore` use the admin client (rather than the consumer) to fetch end offsets for the internal topic. The consumer and the admin API both use the same `ListOffset` broker API, so the functionality is ultimately the same but we don't have to block for any ongoing consumer activity.\n\nEach Connect distributed runtime includes three instances of the `Kafka*BackingStore` classes, which means we have three instances of `KafkaBasedLog`. We don't want three instances of the admin client, and should have all three instances of the `KafkaBasedLog` share a single admin client instance. In fact, each `Kafka*BackingStore` instance currently creates, uses and closes an admin client instance when it checks and initializes that store's internal topic. If we change `Kafka*BackingStores` to share one admin client instance, we can change that initialization logic to also reuse the supplied admin client instance.\n\nThe final challenge is that `KafkaBasedLog` has been used by projects outside of Apache Kafka. While `KafkaBasedLog` is definitely not in the public API for Connect, we can make these changes in ways that are backward compatible: create new constructors and deprecate the old constructors. Connect can be changed to only use the new constructors, and this will give time for any downstream users to make changes.\n\nThese changes are implemented as follows:\n1. Add a `KafkaBasedLog` constructor to accept in its parameters a supplier from which it can get an admin instance, and deprecate the old constructor. We need a supplier rather than just passing an instance because `KafkaBasedLog` is instantiated before Connect starts up, so we need to create the admin instance only when needed. At the same time, we'll change the existing init function parameter from a no-arg function to accept an admin instance as an argument, allowing that init function to reuse the shared admin instance used by the `KafkaBasedLog`. Note: if no admin supplier is provided (in deprecated constructor that is no longer used in AK), the consumer is still used to get latest offsets.\n2. Add to the `Kafka*BackingStore` classes a new constructor with the same parameters but with an admin supplier, and deprecate the old constructor. When the classes instantiate its `KafkaBasedLog` instance, it would pass the admin supplier and pass an init function that takes an admin instance.\n3. Create a new `SharedTopicAdmin` that lazily creates the `TopicAdmin` (and underlying Admin client) when required, and closes the admin objects when the `SharedTopicAdmin` is closed.\n4. Modify the existing `TopicAdmin` (used only in Connect) to encapsulate the logic of fetching end offsets using the admin client, simplifying the logic in `KafkaBasedLog` mentioned in #1 above. Doing this also makes it easier to test that logic.\n5. Change `ConnectDistributed` to create a `SharedTopicAdmin` instance (that is `AutoCloseable`) before creating the `Kafka*BackingStore` instances, passing the `SharedTopicAdmin` (which is an admin supplier) to all three `Kafka*BackingStore objects`, and finally always closing the `SharedTopicAdmin` upon termination. (Shutdown of the worker occurs outside of the `ConnectDistributed` code, so modify `DistributedHerder` to take in its constructor additional `AutoCloseable` objects that should be closed when the herder is closed, and then modify `ConnectDistributed` to pass the `SharedTopicAdmin` as one of those `AutoCloseable` instances.)\n6. Change `MirrorMaker` similarly to `ConnectDistributed`.\n7. Change existing unit tests to no longer use deprecated constructors.\n8. Add unit tests for new functionality."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgzODYzOTgw", "url": "https://github.com/apache/kafka/pull/9780#pullrequestreview-583863980", "createdAt": "2021-02-04T22:21:02Z", "commit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMjoyMTowMlrOIgJraA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQyMjo1NzozNVrOIgKxxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU4MzkxMg==", "bodyText": "I think it's better to avoid a variadic argument here.\nParameters tend to get added with new features in such constructors. And if a new parameter is required that is also a list, then we'll have a mix of list args with a variadic in the end.\nSince we transform to list I'd suggest using this type here and pass the single argument with Collections.singletonList in the caller.", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570583912", "createdAt": "2021-02-04T22:21:02Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java", "diffHunk": "@@ -185,16 +188,33 @@\n \n     private final DistributedConfig config;\n \n+    /**\n+     * Create a herder that will form a Connect cluster with other {@link DistributedHerder} instances (in this or other JVMs)\n+     * that have the same group ID.\n+     *\n+     * @param config             the configuration for the worker; may not be null\n+     * @param time               the clock to use; may not be null\n+     * @param worker             the {@link Worker} instance to use; may not be null\n+     * @param kafkaClusterId     the identifier of the Kafka cluster to use for internal topics; may not be null\n+     * @param statusBackingStore the backing store for statuses; may not be null\n+     * @param configBackingStore the backing store for connector configurations; may not be null\n+     * @param restUrl            the URL of this herder's REST API; may not be null\n+     * @param connectorClientConfigOverridePolicy the policy specifying the client configuration properties that may be overridden\n+     *                                            in connector configurations; may not be null\n+     * @param uponShutdown       any {@link AutoCloseable} objects that should be closed when this herder is {@link #stop() stopped},\n+     *                           after all services and resources owned by this herder are stopped\n+     */\n     public DistributedHerder(DistributedConfig config,\n                              Time time,\n                              Worker worker,\n                              String kafkaClusterId,\n                              StatusBackingStore statusBackingStore,\n                              ConfigBackingStore configBackingStore,\n                              String restUrl,\n-                             ConnectorClientConfigOverridePolicy connectorClientConfigOverridePolicy) {\n+                             ConnectorClientConfigOverridePolicy connectorClientConfigOverridePolicy,\n+                             AutoCloseable... uponShutdown) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU4NDAzNg==", "bodyText": "see comment above", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570584036", "createdAt": "2021-02-04T22:21:16Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java", "diffHunk": "@@ -209,7 +229,8 @@ public DistributedHerder(DistributedConfig config,\n                       String restUrl,\n                       ConnectMetrics metrics,\n                       Time time,\n-                      ConnectorClientConfigOverridePolicy connectorClientConfigOverridePolicy) {\n+                      ConnectorClientConfigOverridePolicy connectorClientConfigOverridePolicy,\n+                      AutoCloseable... uponShutdown) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU4NDEzMw==", "bodyText": "nit: extra", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570584133", "createdAt": "2021-02-04T22:21:28Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java", "diffHunk": "@@ -676,6 +698,16 @@ public void halt() {\n         }\n     }\n \n+    @Override\n+    protected void stopServices() {\n+        try {\n+            super.stopServices();\n+        } finally {\n+            this.uponShutdown.stream().forEach(closeable -> Utils.closeQuietly(closeable, closeable != null ? closeable.toString() : \"<unknown>\"));\n+        }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU4NDQyMQ==", "bodyText": "I'd guess stream().forEach can be simplified with forEach only", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570584421", "createdAt": "2021-02-04T22:22:03Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/distributed/DistributedHerder.java", "diffHunk": "@@ -676,6 +698,16 @@ public void halt() {\n         }\n     }\n \n+    @Override\n+    protected void stopServices() {\n+        try {\n+            super.stopServices();\n+        } finally {\n+            this.uponShutdown.stream().forEach(closeable -> Utils.closeQuietly(closeable, closeable != null ? closeable.toString() : \"<unknown>\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU4OTU3Mg==", "bodyText": "see comment above. We'll avoid the array static init too. Tests here but still that's where array lists come handy", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570589572", "createdAt": "2021-02-04T22:32:17Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/runtime/distributed/DistributedHerderTest.java", "diffHunk": "@@ -207,14 +209,16 @@ public void setUp() throws Exception {\n         metrics = new MockConnectMetrics(time);\n         worker = PowerMock.createMock(Worker.class);\n         EasyMock.expect(worker.isSinkConnector(CONN1)).andStubReturn(Boolean.TRUE);\n+        AutoCloseable uponShutdown = () -> shutdownCalled.countDown();\n \n         // Default to the old protocol unless specified otherwise\n         connectProtocolVersion = CONNECT_PROTOCOL_V0;\n \n         herder = PowerMock.createPartialMock(DistributedHerder.class,\n                 new String[]{\"connectorTypeForClass\", \"updateDeletedConnectorStatus\", \"updateDeletedTaskStatus\", \"validateConnectorConfig\"},\n                 new DistributedConfig(HERDER_CONFIG), worker, WORKER_ID, KAFKA_CLUSTER_ID,\n-                statusBackingStore, configBackingStore, member, MEMBER_URL, metrics, time, noneConnectorClientConfigOverridePolicy);\n+                statusBackingStore, configBackingStore, member, MEMBER_URL, metrics, time, noneConnectorClientConfigOverridePolicy,\n+                new AutoCloseable[]{uponShutdown});", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5MDExNw==", "bodyText": "should we call it EMPTY_CONFIG since it won't change?", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570590117", "createdAt": "2021-02-04T22:33:26Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/util/SharedTopicAdminTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.connect.util;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import org.apache.kafka.connect.errors.ConnectException;\n+import org.easymock.EasyMock;\n+import org.easymock.Mock;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.powermock.api.easymock.PowerMock;\n+import org.powermock.core.classloader.annotations.PowerMockIgnore;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest(KafkaBasedLog.class)\n+@PowerMockIgnore(\"javax.management.*\")\n+public class SharedTopicAdminTest {\n+\n+    private static final Map<String, Object> CONFIG = Collections.emptyMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5MjEyNg==", "bodyText": "Is there a specific action on the mock we wish or can verify here instead of implicitly using a aux variable for that?\nReplay, expectation and verify should help us verify the action or its absence. I'd have to check closer what such action could be, if there's any. Maybe you can see that more easily.", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570592126", "createdAt": "2021-02-04T22:37:31Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/util/SharedTopicAdminTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.connect.util;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import org.apache.kafka.connect.errors.ConnectException;\n+import org.easymock.EasyMock;\n+import org.easymock.Mock;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.powermock.api.easymock.PowerMock;\n+import org.powermock.core.classloader.annotations.PowerMockIgnore;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest(KafkaBasedLog.class)\n+@PowerMockIgnore(\"javax.management.*\")\n+public class SharedTopicAdminTest {\n+\n+    private static final Map<String, Object> CONFIG = Collections.emptyMap();\n+\n+    @Mock private TopicAdmin mockTopicAdmin;\n+    private SharedTopicAdmin sharedAdmin;\n+    private int created = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5NTcxMA==", "bodyText": "curious, what is the array symbolizing here now?\nWe used to have 1 value. Is this ISR nodes? Do we even need to add or remove any?", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570595710", "createdAt": "2021-02-04T22:44:55Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/util/TopicAdminTest.java", "diffHunk": "@@ -457,17 +465,273 @@ public void verifyingGettingTopicCleanupPolicies() {\n         }\n     }\n \n+    @Test\n+    public void endOffsetsShouldFailWithNonRetriableWhenAuthorizationFailureOccurs() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        Long offset = null; // response should use error\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithClusterAuthorizationException(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            ConnectException e = assertThrows(ConnectException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"Not authorized to get the end offsets\"));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldFailWithNonRetriableWhenVersionUnsupportedErrorOccurs() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        Long offset = null; // response should use error\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithUnsupportedVersion(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            ConnectException e = assertThrows(ConnectException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"is unsupported on brokers\"));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldFailWithRetriableWhenTimeoutErrorOccurs() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        Long offset = null; // response should use error\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithTimeout(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            RetriableException e = assertThrows(RetriableException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"Timed out while waiting\"));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldFailWithNonRetriableWhenUnknownErrorOccurs() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        Long offset = null; // response should use error\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithUnknownError(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            ConnectException e = assertThrows(ConnectException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"Error while getting end offsets for topic\"));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldReturnEmptyMapWhenPartitionsSetIsNull() {\n+        String topicName = \"myTopic\";\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            Map<TopicPartition, Long> offsets = admin.endOffsets(Collections.emptySet());\n+            assertTrue(offsets.isEmpty());\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldReturnOffsetsForOnePartition() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        long offset = 1000L;\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResult(tp1, offset));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            Map<TopicPartition, Long> offsets = admin.endOffsets(tps);\n+            assertEquals(1, offsets.size());\n+            assertEquals(Long.valueOf(offset), offsets.get(tp1));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldReturnOffsetsForMultiplePartitions() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        TopicPartition tp2 = new TopicPartition(topicName, 1);\n+        Set<TopicPartition> tps = new HashSet<>(Arrays.asList(tp1, tp2));\n+        long offset1 = 1001;\n+        long offset2 = 1002;\n+        Cluster cluster = createCluster(1, topicName, 2);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResult(tp1, offset1, tp2, offset2));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            Map<TopicPartition, Long> offsets = admin.endOffsets(tps);\n+            assertEquals(2, offsets.size());\n+            assertEquals(Long.valueOf(offset1), offsets.get(tp1));\n+            assertEquals(Long.valueOf(offset2), offsets.get(tp2));\n+        }\n+    }\n+\n+    @Test\n+    public void endOffsetsShouldFailWhenAnyTopicPartitionHasError() {\n+        String topicName = \"myTopic\";\n+        TopicPartition tp1 = new TopicPartition(topicName, 0);\n+        Set<TopicPartition> tps = Collections.singleton(tp1);\n+        long offset = 1000;\n+        Cluster cluster = createCluster(1, topicName, 1);\n+        try (AdminClientUnitTestEnv env = new AdminClientUnitTestEnv(new MockTime(), cluster)) {\n+            env.kafkaClient().setNodeApiVersions(NodeApiVersions.create());\n+            env.kafkaClient().prepareResponse(prepareMetadataResponse(cluster, Errors.NONE));\n+            env.kafkaClient().prepareResponse(listOffsetsResultWithClusterAuthorizationException(tp1, null));\n+            TopicAdmin admin = new TopicAdmin(null, env.adminClient());\n+            ConnectException e = assertThrows(ConnectException.class, () -> {\n+                admin.endOffsets(tps);\n+            });\n+            assertTrue(e.getMessage().contains(\"Not authorized to get the end offsets\"));\n+        }\n+    }\n+\n     private Cluster createCluster(int numNodes) {\n+        return createCluster(numNodes, \"unused\", 0);\n+    }\n+\n+    private Cluster createCluster(int numNodes, String topicName, int partitions) {\n+        Node[] nodeArray = new Node[numNodes];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDYwMTkyNg==", "bodyText": "It's not immediately obvious to me what's the advantage compared to a synchronized topicAdmin or even get.\nI see that the value can go back to null. But we already have the guard with the closed to atomically decide whether this is closed or not. Lmk if I'm missing something, but I feel the points of indirection might be a few more than they have to be here (we have no gains in locking, since we'll need to atomically updateAndGet in every get and the advantage vs synchronized should be negligible here).", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570601926", "createdAt": "2021-02-04T22:57:35Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/SharedTopicAdmin.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.connect.util;\n+\n+import java.time.Duration;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.function.UnaryOperator;\n+\n+import org.apache.kafka.clients.admin.AdminClientConfig;\n+import org.apache.kafka.connect.errors.ConnectException;\n+\n+/**\n+ * A holder of a {@link TopicAdmin} object that is lazily and atomically created when needed by multiple callers.\n+ * As soon as one of the getters is called, all getters will return the same shared {@link TopicAdmin}\n+ * instance until this SharedAdmin is closed via {@link #close()} or {@link #close(Duration)}.\n+ *\n+ * <p>The owner of this object is responsible for ensuring that either {@link #close()} or {@link #close(Duration)}\n+ * is called when the {@link TopicAdmin} instance is no longer needed. Consequently, once this\n+ * {@link SharedTopicAdmin} instance has been closed, the {@link #get()} and {@link #topicAdmin()} methods,\n+ * nor any previously returned {@link TopicAdmin} instances may be used.\n+ *\n+ * <p>This class is thread-safe. It also appears as immutable to callers that obtain the {@link TopicAdmin} object,\n+ * until this object is closed, at which point it cannot be used anymore\n+ */\n+public class SharedTopicAdmin implements AutoCloseable, Supplier<TopicAdmin> {\n+\n+    // Visible for testing\n+    static final Duration DEFAULT_CLOSE_DURATION = Duration.ofMillis(Long.MAX_VALUE);\n+\n+    private final Map<String, Object> adminProps;\n+    private final AtomicReference<TopicAdmin> admin = new AtomicReference<>();\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final Function<Map<String, Object>, TopicAdmin> factory;\n+\n+    public SharedTopicAdmin(Map<String, Object> adminProps) {\n+        this(adminProps, TopicAdmin::new);\n+    }\n+\n+    // Visible for testing\n+    SharedTopicAdmin(Map<String, Object> adminProps, Function<Map<String, Object>, TopicAdmin> factory) {\n+        this.adminProps = Objects.requireNonNull(adminProps);\n+        this.factory = Objects.requireNonNull(factory);\n+    }\n+\n+    /**\n+     * Get the shared {@link TopicAdmin} instance.\n+     *\n+     * @return the shared instance; never null\n+     * @throws ConnectException if this object has already been closed\n+     */\n+    @Override\n+    public TopicAdmin get() {\n+        return topicAdmin();\n+    }\n+\n+    /**\n+     * Get the shared {@link TopicAdmin} instance.\n+     *\n+     * @return the shared instance; never null\n+     * @throws ConnectException if this object has already been closed\n+     */\n+    public TopicAdmin topicAdmin() {\n+        return admin.updateAndGet(this::createAdmin);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg0MDUzODM0", "url": "https://github.com/apache/kafka/pull/9780#pullrequestreview-584053834", "createdAt": "2021-02-05T06:28:21Z", "commit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQwNjoyODoyMVrOIgTpeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQwNjoyODoyMVrOIgTpeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDc0NzI1OA==", "bodyText": "I know. It's just that we already use a mocking framework and we could use something like:\nEasyMock.expect(factory.apply(EasyMock.anyObject())).andReturn(mockTopicAdmin).anyTimes();\nif we also defined factory to be a mock as well. That could allow us to evaluate expectations on the mock more accurately (e.g. with a capture if we had to). But sure, if we need something quick and easy we can go with that. It's just that I noticed a mixed use of mocks with this variable that simulates what the mocking framework offers already.", "url": "https://github.com/apache/kafka/pull/9780#discussion_r570747258", "createdAt": "2021-02-05T06:28:21Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/test/java/org/apache/kafka/connect/util/SharedTopicAdminTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.connect.util;\n+\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import org.apache.kafka.connect.errors.ConnectException;\n+import org.easymock.EasyMock;\n+import org.easymock.Mock;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.powermock.api.easymock.PowerMock;\n+import org.powermock.core.classloader.annotations.PowerMockIgnore;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertThrows;\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest(KafkaBasedLog.class)\n+@PowerMockIgnore(\"javax.management.*\")\n+public class SharedTopicAdminTest {\n+\n+    private static final Map<String, Object> CONFIG = Collections.emptyMap();\n+\n+    @Mock private TopicAdmin mockTopicAdmin;\n+    private SharedTopicAdmin sharedAdmin;\n+    private int created = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDU5MjEyNg=="}, "originalCommit": {"oid": "acbe90c6e6198de3626598f14c2b172c05106f17"}, "originalPosition": 47}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec727a5c8b5c801ab7cc8f43379da924ff9f912c", "author": {"user": {"login": "rhauch", "name": "Randall Hauch"}}, "url": "https://github.com/apache/kafka/commit/ec727a5c8b5c801ab7cc8f43379da924ff9f912c", "committedDate": "2021-02-08T17:55:41Z", "message": "KAFKA-10021: Changed Kafka backing stores to use shared admin client to get end offsets and create topics\n\nThe existing `Kafka*BackingStore` classes used by Connect all use `KafkaBasedLog`, which needs to frequently get the end offsets for the internal topic to know whether they are caught up. `KafkaBasedLog` uses its consumer to get the end offsets and to consume the records from the topic.\n\nHowever, the Connect internal topics are often written very infrequently. This means that when the `KafkaBasedLog` used in the `Kafka*BackingStore` classes is already caught up and its last consumer poll is waiting for new records to appear, the call to the consumer to fetch end offsets will block until the consumer returns after a new record is written (unlikely) or the consumer\u2019s `fetch.max.wait.ms` setting (defaults to 500ms) ends and the consumer returns no more records. IOW, the call to `KafkaBasedLog.readToEnd()` may block for some period of time even though it\u2019s already caught up to the end.\n\nInstead, we want the `KafkaBasedLog.readToEnd()` to always return quickly when the log is already caught up. The best way to do this is to have the `KafkaBackingStore` use the admin client (rather than the consumer) to fetch end offsets for the internal topic. The consumer and the admin API both use the same `ListOffset` broker API, so the functionality is ultimately the same but we don't have to block for any ongoing consumer activity.\n\nEach Connect distributed runtime includes three instances of the `Kafka*BackingStore` classes, which means we have three instances of `KafkaBasedLog`. We don't want three instances of the admin client, and should have all three instances of the `KafkaBasedLog` share a single admin client instance. In fact, each `Kafka*BackingStore` instance currently creates, uses and closes an admin client instance when it checks and initializes that store's internal topic. If we change `Kafka*BackingStores` to share one admin client instance, we can change that initialization logic to also reuse the supplied admin client instance.\n\nThe final challenge is that `KafkaBasedLog` has been used by projects outside of Apache Kafka. While `KafkaBasedLog` is definitely not in the public API for Connect, we can make these changes in ways that are backward compatible: create new constructors and deprecate the old constructors. Connect can be changed to only use the new constructors, and this will give time for any downstream users to make changes.\n\nThese changes are implemented as follows:\n1. Add a `KafkaBasedLog` constructor to accept in its parameters a supplier from which it can get an admin instance, and deprecate the old constructor. We need a supplier rather than just passing an instance because `KafkaBasedLog` is instantiated before Connect starts up, so we need to create the admin instance only when needed. At the same time, we'll change the existing init function parameter from a no-arg function to accept an admin instance as an argument, allowing that init function to reuse the shared admin instance used by the `KafkaBasedLog`. Note: if no admin supplier is provided (in deprecated constructor that is no longer used in AK), the consumer is still used to get latest offsets.\n2. Add to the `Kafka*BackingStore` classes a new constructor with the same parameters but with an admin supplier, and deprecate the old constructor. When the classes instantiate its `KafkaBasedLog` instance, it would pass the admin supplier and pass an init function that takes an admin instance.\n3. Create a new `SharedTopicAdmin` that lazily creates the `TopicAdmin` (and underlying Admin client) when required, and closes the admin objects when the `SharedTopicAdmin` is closed.\n4. Modify the existing `TopicAdmin` (used only in Connect) to encapsulate the logic of fetching end offsets using the admin client, simplifying the logic in `KafkaBasedLog` mentioned in #1 above. Doing this also makes it easier to test that logic.\n5. Change `ConnectDistributed` to create a `SharedTopicAdmin` instance (that is `AutoCloseable`) before creating the `Kafka*BackingStore` instances, passing the `SharedTopicAdmin` (which is an admin supplier) to all three `Kafka*BackingStore objects`, and finally always closing the `SharedTopicAdmin` upon termination. (Shutdown of the worker occurs outside of the `ConnectDistributed` code, so modify `DistributedHerder` to take in its constructor additional `AutoCloseable` objects that should be closed when the herder is closed, and then modify `ConnectDistributed` to pass the `SharedTopicAdmin` as one of those `AutoCloseable` instances.)\n6. Change `MirrorMaker` similarly to `ConnectDistributed`.\n7. Change existing unit tests to no longer use deprecated constructors.\n8. Add unit tests for new functionality."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14546ef5bce131d9af87c5744842bb6a794a2181", "author": {"user": {"login": "rhauch", "name": "Randall Hauch"}}, "url": "https://github.com/apache/kafka/commit/14546ef5bce131d9af87c5744842bb6a794a2181", "committedDate": "2021-02-08T17:55:44Z", "message": "Incorporate suggestions from code review"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ceba773d43010074e624a45badfa535c9d2a05fa", "author": {"user": {"login": "rhauch", "name": "Randall Hauch"}}, "url": "https://github.com/apache/kafka/commit/ceba773d43010074e624a45badfa535c9d2a05fa", "committedDate": "2021-02-08T17:53:43Z", "message": "Incorporate suggestions from code review"}, "afterCommit": {"oid": "14546ef5bce131d9af87c5744842bb6a794a2181", "author": {"user": {"login": "rhauch", "name": "Randall Hauch"}}, "url": "https://github.com/apache/kafka/commit/14546ef5bce131d9af87c5744842bb6a794a2181", "committedDate": "2021-02-08T17:55:44Z", "message": "Incorporate suggestions from code review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86b2c92bea3e992447169f8e0277ffad71c24b95", "author": {"user": {"login": "rhauch", "name": "Randall Hauch"}}, "url": "https://github.com/apache/kafka/commit/86b2c92bea3e992447169f8e0277ffad71c24b95", "committedDate": "2021-02-08T22:26:06Z", "message": "Changed test case to use Mockito"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg1OTg2MjUx", "url": "https://github.com/apache/kafka/pull/9780#pullrequestreview-585986251", "createdAt": "2021-02-08T22:33:17Z", "commit": {"oid": "86b2c92bea3e992447169f8e0277ffad71c24b95"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54a3f10bc7be899cb47c6500d51ff2cec3e1e572", "author": {"user": {"login": "rhauch", "name": "Randall Hauch"}}, "url": "https://github.com/apache/kafka/commit/54a3f10bc7be899cb47c6500d51ff2cec3e1e572", "committedDate": "2021-02-09T07:47:51Z", "message": "Correct unchecked conversion in new unit test"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2379, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}