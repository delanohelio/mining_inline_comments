{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMwNDIwNjIx", "number": 8828, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMDoxNToxMFrOEDRhEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMTowOTowNFrOEEgifg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODY4MTc2OnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/AbstractHerder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMDoxNToxMFrOGgMr_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNzoyOToyNVrOGh_RQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQxNTQ4Ng==", "bodyText": "volatile boolean is equivalent to AtomicBoolean and if we are not going to use any of the compare-and-set/get-and-set capabilities of the atomic class, maybe you'd want to consider using volatile instead to avoid the boilerplate of calling get/set on that boolean variable. But of course, the decision is a matter of style too.", "url": "https://github.com/apache/kafka/pull/8828#discussion_r436415486", "createdAt": "2020-06-08T00:15:10Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/AbstractHerder.java", "diffHunk": "@@ -94,6 +95,7 @@\n     protected final StatusBackingStore statusBackingStore;\n     protected final ConfigBackingStore configBackingStore;\n     private final ConnectorClientConfigOverridePolicy connectorClientConfigOverridePolicy;\n+    protected final AtomicBoolean running = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb2f4c323856d0f35c4628df08bdb37d121d4613"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MjgwMw==", "bodyText": "ack", "url": "https://github.com/apache/kafka/pull/8828#discussion_r438292803", "createdAt": "2020-06-10T17:29:25Z", "author": {"login": "rhauch"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/runtime/AbstractHerder.java", "diffHunk": "@@ -94,6 +95,7 @@\n     protected final StatusBackingStore statusBackingStore;\n     protected final ConfigBackingStore configBackingStore;\n     private final ConnectorClientConfigOverridePolicy connectorClientConfigOverridePolicy;\n+    protected final AtomicBoolean running = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQxNTQ4Ng=="}, "originalCommit": {"oid": "eb2f4c323856d0f35c4628df08bdb37d121d4613"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODcyMzE0OnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/storage/KafkaConfigBackingStore.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMToxNDoyOFrOGgNCMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMToxNDoyOFrOGgNCMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMTE2OQ==", "bodyText": "Vararg gives some unintended consequences in naming. Should we stick to singular given that we expect at most a single topic to be created?", "url": "https://github.com/apache/kafka/pull/8828#discussion_r436421169", "createdAt": "2020-06-08T01:14:28Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/storage/KafkaConfigBackingStore.java", "diffHunk": "@@ -492,7 +493,14 @@ public void putSessionKey(SessionKey sessionKey) {\n             public void run() {\n                 log.debug(\"Creating admin client to manage Connect internal config topic\");\n                 try (TopicAdmin admin = new TopicAdmin(adminProps)) {\n-                    admin.createTopics(topicDescription);\n+                    // Create the topic if it doesn't exist\n+                    Set<String> newTopics = admin.createTopics(topicDescription);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb2f4c323856d0f35c4628df08bdb37d121d4613"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODcyNjI3OnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMToxODozMlrOGgNEDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMToxODozMlrOGgNEDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMTY0Nw==", "bodyText": "nit: should we keep 2 tabs alignment for everything?", "url": "https://github.com/apache/kafka/pull/8828#discussion_r436421647", "createdAt": "2020-06-08T01:18:32Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "diffHunk": "@@ -375,6 +383,152 @@ public boolean createTopic(NewTopic topic) {\n         return existingTopics;\n     }\n \n+    /**\n+     * Verify the named topic uses only compaction for the cleanup policy.\n+     *\n+     * @param topic             the name of the topic\n+     * @param workerTopicConfig the name of the worker configuration that specifies the topic name\n+     * @return true if the admin client could be used to verify the topic setting, or false if\n+     *         the verification could not be performed, likely because the admin client principal\n+     *         did not have the required permissions or because the broker was older than 0.11.0.0\n+     * @throws ConfigException if the actual topic setting did not match the required setting\n+     */\n+    public boolean verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig,\n+            String topicPurpose) {\n+        Set<String> cleanupPolicies = topicCleanupPolicy(topic);\n+        if (cleanupPolicies == null || cleanupPolicies.isEmpty()) {\n+            log.debug(\"Unable to use admin client to verify the cleanup policy of '{}' \"\n+                      + \"topic is '{}', either because the broker is an older \"\n+                      + \"version or because the Kafka principal used for Connect \"\n+                      + \"internal topics does not have the required permission to \"\n+                      + \"describe topic configurations.\", topic, TopicConfig.CLEANUP_POLICY_COMPACT);\n+            return false;\n+        }\n+        String cleanupPolicyStr = String.join(\",\", cleanupPolicies);\n+        log.debug(\"Found cleanup policy for '{}' topic is '{}'\", topic, cleanupPolicyStr);\n+        Set<String> expectedPolicies = Collections.singleton(TopicConfig.CLEANUP_POLICY_COMPACT);\n+        String expectedPolicyStr = String.join(\",\", expectedPolicies);\n+        if (cleanupPolicies != null && !cleanupPolicies.equals(expectedPolicies)) {\n+            String msg = String.format(\"Topic '%s' supplied via the '%s' property is required \"\n+                                       + \"to have '%s=%s' to guarantee consistency and durability of \"\n+                                       + \"%s, but found '%s'. \"\n+                                       + \"Correct the topic before restarting Connect.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb2f4c323856d0f35c4628df08bdb37d121d4613"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODcyOTc2OnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMToyMjozNVrOGgNGHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMToyMjozNVrOGgNGHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMjE3Mw==", "bodyText": "I wonder if distinguishing like that, with null and empty pays off.\nWhy not return an empty collection in both cases and simplify the checks on the return values of this method?\nThis method doesn't seem to be the one to use when somebody wants to determine whether a topic exists or not.", "url": "https://github.com/apache/kafka/pull/8828#discussion_r436422173", "createdAt": "2020-06-08T01:22:35Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "diffHunk": "@@ -375,6 +383,152 @@ public boolean createTopic(NewTopic topic) {\n         return existingTopics;\n     }\n \n+    /**\n+     * Verify the named topic uses only compaction for the cleanup policy.\n+     *\n+     * @param topic             the name of the topic\n+     * @param workerTopicConfig the name of the worker configuration that specifies the topic name\n+     * @return true if the admin client could be used to verify the topic setting, or false if\n+     *         the verification could not be performed, likely because the admin client principal\n+     *         did not have the required permissions or because the broker was older than 0.11.0.0\n+     * @throws ConfigException if the actual topic setting did not match the required setting\n+     */\n+    public boolean verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig,\n+            String topicPurpose) {\n+        Set<String> cleanupPolicies = topicCleanupPolicy(topic);\n+        if (cleanupPolicies == null || cleanupPolicies.isEmpty()) {\n+            log.debug(\"Unable to use admin client to verify the cleanup policy of '{}' \"\n+                      + \"topic is '{}', either because the broker is an older \"\n+                      + \"version or because the Kafka principal used for Connect \"\n+                      + \"internal topics does not have the required permission to \"\n+                      + \"describe topic configurations.\", topic, TopicConfig.CLEANUP_POLICY_COMPACT);\n+            return false;\n+        }\n+        String cleanupPolicyStr = String.join(\",\", cleanupPolicies);\n+        log.debug(\"Found cleanup policy for '{}' topic is '{}'\", topic, cleanupPolicyStr);\n+        Set<String> expectedPolicies = Collections.singleton(TopicConfig.CLEANUP_POLICY_COMPACT);\n+        String expectedPolicyStr = String.join(\",\", expectedPolicies);\n+        if (cleanupPolicies != null && !cleanupPolicies.equals(expectedPolicies)) {\n+            String msg = String.format(\"Topic '%s' supplied via the '%s' property is required \"\n+                                       + \"to have '%s=%s' to guarantee consistency and durability of \"\n+                                       + \"%s, but found '%s'. \"\n+                                       + \"Correct the topic before restarting Connect.\",\n+                    topic, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr,\n+                    topicPurpose, cleanupPolicyStr);\n+            throw new ConfigException(msg);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Get the cleanup policy for a topic.\n+     *\n+     * @param topic the name of the topic\n+     * @return the set of cleanup policies set for the topic; may be empty if the topic exists", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb2f4c323856d0f35c4628df08bdb37d121d4613"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODczMjkwOnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMToyNjoxN1rOGgNH0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMToyNjoxN1rOGgNH0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMjYwOA==", "bodyText": "nit: don't we need a space between the varargs type and the variable name? I'm surprised mainly at checkstyle here.", "url": "https://github.com/apache/kafka/pull/8828#discussion_r436422608", "createdAt": "2020-06-08T01:26:17Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "diffHunk": "@@ -375,6 +383,152 @@ public boolean createTopic(NewTopic topic) {\n         return existingTopics;\n     }\n \n+    /**\n+     * Verify the named topic uses only compaction for the cleanup policy.\n+     *\n+     * @param topic             the name of the topic\n+     * @param workerTopicConfig the name of the worker configuration that specifies the topic name\n+     * @return true if the admin client could be used to verify the topic setting, or false if\n+     *         the verification could not be performed, likely because the admin client principal\n+     *         did not have the required permissions or because the broker was older than 0.11.0.0\n+     * @throws ConfigException if the actual topic setting did not match the required setting\n+     */\n+    public boolean verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig,\n+            String topicPurpose) {\n+        Set<String> cleanupPolicies = topicCleanupPolicy(topic);\n+        if (cleanupPolicies == null || cleanupPolicies.isEmpty()) {\n+            log.debug(\"Unable to use admin client to verify the cleanup policy of '{}' \"\n+                      + \"topic is '{}', either because the broker is an older \"\n+                      + \"version or because the Kafka principal used for Connect \"\n+                      + \"internal topics does not have the required permission to \"\n+                      + \"describe topic configurations.\", topic, TopicConfig.CLEANUP_POLICY_COMPACT);\n+            return false;\n+        }\n+        String cleanupPolicyStr = String.join(\",\", cleanupPolicies);\n+        log.debug(\"Found cleanup policy for '{}' topic is '{}'\", topic, cleanupPolicyStr);\n+        Set<String> expectedPolicies = Collections.singleton(TopicConfig.CLEANUP_POLICY_COMPACT);\n+        String expectedPolicyStr = String.join(\",\", expectedPolicies);\n+        if (cleanupPolicies != null && !cleanupPolicies.equals(expectedPolicies)) {\n+            String msg = String.format(\"Topic '%s' supplied via the '%s' property is required \"\n+                                       + \"to have '%s=%s' to guarantee consistency and durability of \"\n+                                       + \"%s, but found '%s'. \"\n+                                       + \"Correct the topic before restarting Connect.\",\n+                    topic, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr,\n+                    topicPurpose, cleanupPolicyStr);\n+            throw new ConfigException(msg);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Get the cleanup policy for a topic.\n+     *\n+     * @param topic the name of the topic\n+     * @return the set of cleanup policies set for the topic; may be empty if the topic exists\n+     *         but has no cleanup policy, or may be null if the topic does not exist\n+     */\n+    public Set<String> topicCleanupPolicy(String topic) {\n+        Config topicConfig = describeTopicConfig(topic);\n+        if (topicConfig == null) {\n+            return null;\n+        }\n+        ConfigEntry entry = topicConfig.get(CLEANUP_POLICY_CONFIG);\n+        if (entry != null && entry.value() != null) {\n+            String policyStr = entry.value();\n+            return Arrays.stream(policyStr.split(\",\"))\n+                         .map(String::trim)\n+                         .map(String::toLowerCase)\n+                         .collect(Collectors.toSet());\n+        }\n+        return Collections.emptySet();\n+    }\n+\n+    /**\n+     * Attempt to fetch the topic configuration for the given topic.\n+     * Apache Kafka added support for describing topic configurations in 0.11.0.0, so this method\n+     * works as expected with that and later versions. With brokers older than 0.11.0.0, this method\n+     * is unable get the topic configurations and always returns a null value.\n+     *\n+     * <p>If the topic does not exist, a null value is returned.\n+     *\n+     * @param topic the name of the topic for which the topic configuration should be obtained\n+     * @return true if the operation was successful, or false if no topics were described\n+     * @throws RetriableException if a retriable error occurs, the operation takes too long, or the\n+     *         thread is interrupted while attempting to perform this operation\n+     * @throws ConnectException if a non retriable error occurs\n+     */\n+    public Config describeTopicConfig(String topic) {\n+        return describeTopicConfigs(topic).get(topic);\n+    }\n+\n+    /**\n+     * Attempt to fetch the topic configurations for the given topics.\n+     * Apache Kafka added support for describing topic configurations in 0.11.0.0, so this method\n+     * works as expected with that and later versions. With brokers older than 0.11.0.0, this method\n+     * is unable get the topic configurations and always returns an empty set.\n+     *\n+     * <p>An entry with a null Config is placed into the resulting map for any topic that does\n+     * not exist on the brokers.\n+     *\n+     * @param topicNames the topics to obtain configurations\n+     * @return true if the operation was successful, or false if no topics were described\n+     * @throws RetriableException if a retriable error occurs, the operation takes too long, or the\n+     *         thread is interrupted while attempting to perform this operation\n+     * @throws ConnectException if a non retriable error occurs\n+     */\n+    public Map<String, Config> describeTopicConfigs(String...topicNames) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb2f4c323856d0f35c4628df08bdb37d121d4613"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMTY0NzA2OnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNzozOTo0N1rOGgpGgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMToyNTo1OFrOGiG3uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTAyNg==", "bodyText": "Is it possible that this will also be true if there isn't a cleanup policy configured on the topic?", "url": "https://github.com/apache/kafka/pull/8828#discussion_r436881026", "createdAt": "2020-06-08T17:39:47Z", "author": {"login": "C0urante"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "diffHunk": "@@ -375,6 +383,152 @@ public boolean createTopic(NewTopic topic) {\n         return existingTopics;\n     }\n \n+    /**\n+     * Verify the named topic uses only compaction for the cleanup policy.\n+     *\n+     * @param topic             the name of the topic\n+     * @param workerTopicConfig the name of the worker configuration that specifies the topic name\n+     * @return true if the admin client could be used to verify the topic setting, or false if\n+     *         the verification could not be performed, likely because the admin client principal\n+     *         did not have the required permissions or because the broker was older than 0.11.0.0\n+     * @throws ConfigException if the actual topic setting did not match the required setting\n+     */\n+    public boolean verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig,\n+            String topicPurpose) {\n+        Set<String> cleanupPolicies = topicCleanupPolicy(topic);\n+        if (cleanupPolicies == null || cleanupPolicies.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb2f4c323856d0f35c4628df08bdb37d121d4613"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5OTQ5NQ==", "bodyText": "Is it even possible to have a blank cleanup.policy? The topic will inherit the broker's log.cleanup.policy, which has a default and which is not allowed to be blank. And it looks like cleanup.policy is required to be either compact or delete or both.", "url": "https://github.com/apache/kafka/pull/8828#discussion_r438299495", "createdAt": "2020-06-10T17:40:40Z", "author": {"login": "rhauch"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "diffHunk": "@@ -375,6 +383,152 @@ public boolean createTopic(NewTopic topic) {\n         return existingTopics;\n     }\n \n+    /**\n+     * Verify the named topic uses only compaction for the cleanup policy.\n+     *\n+     * @param topic             the name of the topic\n+     * @param workerTopicConfig the name of the worker configuration that specifies the topic name\n+     * @return true if the admin client could be used to verify the topic setting, or false if\n+     *         the verification could not be performed, likely because the admin client principal\n+     *         did not have the required permissions or because the broker was older than 0.11.0.0\n+     * @throws ConfigException if the actual topic setting did not match the required setting\n+     */\n+    public boolean verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig,\n+            String topicPurpose) {\n+        Set<String> cleanupPolicies = topicCleanupPolicy(topic);\n+        if (cleanupPolicies == null || cleanupPolicies.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTAyNg=="}, "originalCommit": {"oid": "eb2f4c323856d0f35c4628df08bdb37d121d4613"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMwMzY5OA==", "bodyText": "No kidding... I assumed it was possible to create topics without cleanup policies but it looks like you're right. My bad!", "url": "https://github.com/apache/kafka/pull/8828#discussion_r438303698", "createdAt": "2020-06-10T17:47:45Z", "author": {"login": "C0urante"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "diffHunk": "@@ -375,6 +383,152 @@ public boolean createTopic(NewTopic topic) {\n         return existingTopics;\n     }\n \n+    /**\n+     * Verify the named topic uses only compaction for the cleanup policy.\n+     *\n+     * @param topic             the name of the topic\n+     * @param workerTopicConfig the name of the worker configuration that specifies the topic name\n+     * @return true if the admin client could be used to verify the topic setting, or false if\n+     *         the verification could not be performed, likely because the admin client principal\n+     *         did not have the required permissions or because the broker was older than 0.11.0.0\n+     * @throws ConfigException if the actual topic setting did not match the required setting\n+     */\n+    public boolean verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig,\n+            String topicPurpose) {\n+        Set<String> cleanupPolicies = topicCleanupPolicy(topic);\n+        if (cleanupPolicies == null || cleanupPolicies.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTAyNg=="}, "originalCommit": {"oid": "eb2f4c323856d0f35c4628df08bdb37d121d4613"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxMjMwOA==", "bodyText": "After some testing, I've discovered that even if the topic-specific settings don't explicitly specify the cleanup.policy, the config description for the topic returned by the admin client will still include cleanup.policy=<broker's log.cleanup.policy>. That means if we have permissions and the topic exists, we will always get the cleanup.policy for the topic.\nAnd, I've cleaned up the semantics of the topicCleanupPolicy(...) method to never return a null set. This means that if the set is empty, either the topic doesn't exist or the admin client could not return the topic settings (e.g., old broker, insufficient ACLs, etc.). Either way, this logic gets simplified a bit.\nI hope that helps address your concern/question.", "url": "https://github.com/apache/kafka/pull/8828#discussion_r438412308", "createdAt": "2020-06-10T21:14:50Z", "author": {"login": "rhauch"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "diffHunk": "@@ -375,6 +383,152 @@ public boolean createTopic(NewTopic topic) {\n         return existingTopics;\n     }\n \n+    /**\n+     * Verify the named topic uses only compaction for the cleanup policy.\n+     *\n+     * @param topic             the name of the topic\n+     * @param workerTopicConfig the name of the worker configuration that specifies the topic name\n+     * @return true if the admin client could be used to verify the topic setting, or false if\n+     *         the verification could not be performed, likely because the admin client principal\n+     *         did not have the required permissions or because the broker was older than 0.11.0.0\n+     * @throws ConfigException if the actual topic setting did not match the required setting\n+     */\n+    public boolean verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig,\n+            String topicPurpose) {\n+        Set<String> cleanupPolicies = topicCleanupPolicy(topic);\n+        if (cleanupPolicies == null || cleanupPolicies.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTAyNg=="}, "originalCommit": {"oid": "eb2f4c323856d0f35c4628df08bdb37d121d4613"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxNzMzNw==", "bodyText": "I think my concern was invalid to begin with but your refactoring is certainly an improvement. LGTM \ud83d\udc4d", "url": "https://github.com/apache/kafka/pull/8828#discussion_r438417337", "createdAt": "2020-06-10T21:25:58Z", "author": {"login": "C0urante"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "diffHunk": "@@ -375,6 +383,152 @@ public boolean createTopic(NewTopic topic) {\n         return existingTopics;\n     }\n \n+    /**\n+     * Verify the named topic uses only compaction for the cleanup policy.\n+     *\n+     * @param topic             the name of the topic\n+     * @param workerTopicConfig the name of the worker configuration that specifies the topic name\n+     * @return true if the admin client could be used to verify the topic setting, or false if\n+     *         the verification could not be performed, likely because the admin client principal\n+     *         did not have the required permissions or because the broker was older than 0.11.0.0\n+     * @throws ConfigException if the actual topic setting did not match the required setting\n+     */\n+    public boolean verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig,\n+            String topicPurpose) {\n+        Set<String> cleanupPolicies = topicCleanupPolicy(topic);\n+        if (cleanupPolicies == null || cleanupPolicies.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg4MTAyNg=="}, "originalCommit": {"oid": "eb2f4c323856d0f35c4628df08bdb37d121d4613"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTYyNzU3OnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMTowODoxMlrOGiLMvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMzoyNToxMFrOGiNPcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODI1NQ==", "bodyText": "Should we consider info? It's a one time message right?", "url": "https://github.com/apache/kafka/pull/8828#discussion_r438488255", "createdAt": "2020-06-11T01:08:12Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "diffHunk": "@@ -375,6 +383,162 @@ public boolean createTopic(NewTopic topic) {\n         return existingTopics;\n     }\n \n+    /**\n+     * Verify the named topic uses only compaction for the cleanup policy.\n+     *\n+     * @param topic             the name of the topic\n+     * @param workerTopicConfig the name of the worker configuration that specifies the topic name\n+     * @return true if the admin client could be used to verify the topic setting, or false if\n+     *         the verification could not be performed, likely because the admin client principal\n+     *         did not have the required permissions or because the broker was older than 0.11.0.0\n+     * @throws ConfigException if the actual topic setting did not match the required setting\n+     */\n+    public boolean verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig,\n+            String topicPurpose) {\n+        Set<String> cleanupPolicies = topicCleanupPolicy(topic);\n+        if (cleanupPolicies.isEmpty()) {\n+            log.debug(\"Unable to use admin client to verify the cleanup policy of '{}' \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5612e697fe0a031a10b8d6c53a0bab3f8c2b4de8"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUyMTcxMw==", "bodyText": "I could see changing this to info, because this is important. But the others log messages really are just tracking that we're using the admin client and what we're finding, so I think debug is probably the best there. If the cleanup policy is wrong, then if we're logging that we're also going to fail the worker; if the cleanup policy is acceptable, I don't think it's worth logging it at info.", "url": "https://github.com/apache/kafka/pull/8828#discussion_r438521713", "createdAt": "2020-06-11T03:25:10Z", "author": {"login": "rhauch"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "diffHunk": "@@ -375,6 +383,162 @@ public boolean createTopic(NewTopic topic) {\n         return existingTopics;\n     }\n \n+    /**\n+     * Verify the named topic uses only compaction for the cleanup policy.\n+     *\n+     * @param topic             the name of the topic\n+     * @param workerTopicConfig the name of the worker configuration that specifies the topic name\n+     * @return true if the admin client could be used to verify the topic setting, or false if\n+     *         the verification could not be performed, likely because the admin client principal\n+     *         did not have the required permissions or because the broker was older than 0.11.0.0\n+     * @throws ConfigException if the actual topic setting did not match the required setting\n+     */\n+    public boolean verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig,\n+            String topicPurpose) {\n+        Set<String> cleanupPolicies = topicCleanupPolicy(topic);\n+        if (cleanupPolicies.isEmpty()) {\n+            log.debug(\"Unable to use admin client to verify the cleanup policy of '{}' \"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODI1NQ=="}, "originalCommit": {"oid": "5612e697fe0a031a10b8d6c53a0bab3f8c2b4de8"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTYyODY5OnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMTowOTowMFrOGiLNfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMTowOTowMFrOGiLNfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODQ0NA==", "bodyText": "same question around log level as above", "url": "https://github.com/apache/kafka/pull/8828#discussion_r438488444", "createdAt": "2020-06-11T01:09:00Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "diffHunk": "@@ -375,6 +383,162 @@ public boolean createTopic(NewTopic topic) {\n         return existingTopics;\n     }\n \n+    /**\n+     * Verify the named topic uses only compaction for the cleanup policy.\n+     *\n+     * @param topic             the name of the topic\n+     * @param workerTopicConfig the name of the worker configuration that specifies the topic name\n+     * @return true if the admin client could be used to verify the topic setting, or false if\n+     *         the verification could not be performed, likely because the admin client principal\n+     *         did not have the required permissions or because the broker was older than 0.11.0.0\n+     * @throws ConfigException if the actual topic setting did not match the required setting\n+     */\n+    public boolean verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig,\n+            String topicPurpose) {\n+        Set<String> cleanupPolicies = topicCleanupPolicy(topic);\n+        if (cleanupPolicies.isEmpty()) {\n+            log.debug(\"Unable to use admin client to verify the cleanup policy of '{}' \"\n+                      + \"topic is '{}', either because the broker is an older \"\n+                      + \"version or because the Kafka principal used for Connect \"\n+                      + \"internal topics does not have the required permission to \"\n+                      + \"describe topic configurations.\", topic, TopicConfig.CLEANUP_POLICY_COMPACT);\n+            return false;\n+        }\n+        Set<String> expectedPolicies = Collections.singleton(TopicConfig.CLEANUP_POLICY_COMPACT);\n+        if (!cleanupPolicies.equals(expectedPolicies)) {\n+            String expectedPolicyStr = String.join(\",\", expectedPolicies);\n+            String cleanupPolicyStr = String.join(\",\", cleanupPolicies);\n+            String msg = String.format(\"Topic '%s' supplied via the '%s' property is required \"\n+                    + \"to have '%s=%s' to guarantee consistency and durability of \"\n+                    + \"%s, but found the topic currently has '%s=%s'. Continuing would likely \"\n+                    + \"result in eventually losing %s and problems restarting this Connect \"\n+                    + \"cluster in the future. Change the '%s' property in the \"\n+                    + \"Connect worker configurations to use a topic with '%s=%s'.\",\n+                    topic, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr,\n+                    topicPurpose, TopicConfig.CLEANUP_POLICY_CONFIG, cleanupPolicyStr, topicPurpose,\n+                    workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr);\n+            throw new ConfigException(msg);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Get the cleanup policy for a topic.\n+     *\n+     * @param topic the name of the topic\n+     * @return the set of cleanup policies set for the topic; may be empty if the topic does not\n+     *         exist or the topic's cleanup policy could not be retrieved\n+     */\n+    public Set<String> topicCleanupPolicy(String topic) {\n+        Config topicConfig = describeTopicConfig(topic);\n+        if (topicConfig == null) {\n+            // The topic must not exist\n+            log.debug(\"Unable to find topic '{}' when getting cleanup policy\", topic);\n+            return Collections.emptySet();\n+        }\n+        ConfigEntry entry = topicConfig.get(CLEANUP_POLICY_CONFIG);\n+        if (entry != null && entry.value() != null) {\n+            String policyStr = entry.value();\n+            log.debug(\"Found cleanup.policy={} for topic '{}'\", policyStr, topic);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5612e697fe0a031a10b8d6c53a0bab3f8c2b4de8"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTYyODc4OnYy", "diffSide": "RIGHT", "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMTowOTowNFrOGiLNiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMTowOTowNFrOGiLNiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4ODQ1OQ==", "bodyText": "same question around log level as above", "url": "https://github.com/apache/kafka/pull/8828#discussion_r438488459", "createdAt": "2020-06-11T01:09:04Z", "author": {"login": "kkonstantine"}, "path": "connect/runtime/src/main/java/org/apache/kafka/connect/util/TopicAdmin.java", "diffHunk": "@@ -375,6 +383,162 @@ public boolean createTopic(NewTopic topic) {\n         return existingTopics;\n     }\n \n+    /**\n+     * Verify the named topic uses only compaction for the cleanup policy.\n+     *\n+     * @param topic             the name of the topic\n+     * @param workerTopicConfig the name of the worker configuration that specifies the topic name\n+     * @return true if the admin client could be used to verify the topic setting, or false if\n+     *         the verification could not be performed, likely because the admin client principal\n+     *         did not have the required permissions or because the broker was older than 0.11.0.0\n+     * @throws ConfigException if the actual topic setting did not match the required setting\n+     */\n+    public boolean verifyTopicCleanupPolicyOnlyCompact(String topic, String workerTopicConfig,\n+            String topicPurpose) {\n+        Set<String> cleanupPolicies = topicCleanupPolicy(topic);\n+        if (cleanupPolicies.isEmpty()) {\n+            log.debug(\"Unable to use admin client to verify the cleanup policy of '{}' \"\n+                      + \"topic is '{}', either because the broker is an older \"\n+                      + \"version or because the Kafka principal used for Connect \"\n+                      + \"internal topics does not have the required permission to \"\n+                      + \"describe topic configurations.\", topic, TopicConfig.CLEANUP_POLICY_COMPACT);\n+            return false;\n+        }\n+        Set<String> expectedPolicies = Collections.singleton(TopicConfig.CLEANUP_POLICY_COMPACT);\n+        if (!cleanupPolicies.equals(expectedPolicies)) {\n+            String expectedPolicyStr = String.join(\",\", expectedPolicies);\n+            String cleanupPolicyStr = String.join(\",\", cleanupPolicies);\n+            String msg = String.format(\"Topic '%s' supplied via the '%s' property is required \"\n+                    + \"to have '%s=%s' to guarantee consistency and durability of \"\n+                    + \"%s, but found the topic currently has '%s=%s'. Continuing would likely \"\n+                    + \"result in eventually losing %s and problems restarting this Connect \"\n+                    + \"cluster in the future. Change the '%s' property in the \"\n+                    + \"Connect worker configurations to use a topic with '%s=%s'.\",\n+                    topic, workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr,\n+                    topicPurpose, TopicConfig.CLEANUP_POLICY_CONFIG, cleanupPolicyStr, topicPurpose,\n+                    workerTopicConfig, TopicConfig.CLEANUP_POLICY_CONFIG, expectedPolicyStr);\n+            throw new ConfigException(msg);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Get the cleanup policy for a topic.\n+     *\n+     * @param topic the name of the topic\n+     * @return the set of cleanup policies set for the topic; may be empty if the topic does not\n+     *         exist or the topic's cleanup policy could not be retrieved\n+     */\n+    public Set<String> topicCleanupPolicy(String topic) {\n+        Config topicConfig = describeTopicConfig(topic);\n+        if (topicConfig == null) {\n+            // The topic must not exist\n+            log.debug(\"Unable to find topic '{}' when getting cleanup policy\", topic);\n+            return Collections.emptySet();\n+        }\n+        ConfigEntry entry = topicConfig.get(CLEANUP_POLICY_CONFIG);\n+        if (entry != null && entry.value() != null) {\n+            String policyStr = entry.value();\n+            log.debug(\"Found cleanup.policy={} for topic '{}'\", policyStr, topic);\n+            return Arrays.stream(policyStr.split(\",\"))\n+                         .map(String::trim)\n+                         .filter(s -> !s.isEmpty())\n+                         .map(String::toLowerCase)\n+                         .collect(Collectors.toSet());\n+        }\n+        // This is unexpected, as the topic config should include the cleanup.policy even if\n+        // the topic settings don't override the broker's log.cleanup.policy. But just to be safe.\n+        log.debug(\"Found no cleanup.policy for topic '{}'\", topic);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5612e697fe0a031a10b8d6c53a0bab3f8c2b4de8"}, "originalPosition": 103}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2548, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}