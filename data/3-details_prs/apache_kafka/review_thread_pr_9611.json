{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzMDY1NzM3", "number": 9611, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo0MDozOVrOE9r1GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo1NDo0NlrOE9sJUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTE2Njk3OnYy", "diffSide": "RIGHT", "path": "core/src/main/resources/common/message/TransactionLogKey.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo0MDozOVrOH6gU0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo0MDozOVrOH6gU0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEwOTA3Mw==", "bodyText": "nit: We usually capitalize the first letter. We should do it in both schemas.", "url": "https://github.com/apache/kafka/pull/9611#discussion_r531109073", "createdAt": "2020-11-26T15:40:39Z", "author": {"login": "dajac"}, "path": "core/src/main/resources/common/message/TransactionLogKey.json", "diffHunk": "@@ -0,0 +1,23 @@\n+// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements.  See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//    http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+{\n+  \"type\": \"data\",\n+  \"name\": \"TransactionLogKey\",\n+  \"validVersions\": \"0\",\n+  \"fields\": [\n+    { \"name\": \"transactionalId\", \"type\": \"string\", \"versions\": \"0\"}", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTE5MTE1OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionLog.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo0NzoyMFrOH6gjJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo0NzoyMFrOH6gjJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExMjc0MA==", "bodyText": "nit: We usually have a space after case.", "url": "https://github.com/apache/kafka/pull/9611#discussion_r531112740", "createdAt": "2020-11-26T15:47:20Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionLog.scala", "diffHunk": "@@ -146,38 +70,27 @@ object TransactionLog {\n     * @return value payload bytes\n     */\n   private[transaction] def valueToBytes(txnMetadata: TxnTransitMetadata): Array[Byte] = {\n-    import ValueSchema._\n-    val value = new Struct(Current)\n-    value.set(ProducerIdField, txnMetadata.producerId)\n-    value.set(ProducerEpochField, txnMetadata.producerEpoch)\n-    value.set(TxnTimeoutField, txnMetadata.txnTimeoutMs)\n-    value.set(TxnStatusField, txnMetadata.txnState.byte)\n-    value.set(TxnEntryTimestampField, txnMetadata.txnLastUpdateTimestamp)\n-    value.set(TxnStartTimestampField, txnMetadata.txnStartTimestamp)\n-\n-    if (txnMetadata.txnState == Empty) {\n-      if (txnMetadata.topicPartitions.nonEmpty)\n+    if (txnMetadata.txnState == Empty && txnMetadata.topicPartitions.nonEmpty)\n         throw new IllegalStateException(s\"Transaction is not expected to have any partitions since its state is ${txnMetadata.txnState}: $txnMetadata\")\n \n-      value.set(TxnPartitionsField, null)\n-    } else {\n-      // first group the topic partitions by their topic names\n-      val topicAndPartitions = txnMetadata.topicPartitions.groupBy(_.topic())\n-\n-      val partitionArray = topicAndPartitions.map { case(topic, partitions) =>\n-        val topicPartitionsStruct = value.instance(TxnPartitionsField)\n-        val partitionIds: Array[Integer] = partitions.map(topicPartition => Integer.valueOf(topicPartition.partition())).toArray\n-        topicPartitionsStruct.set(PartitionsTopicField, topic)\n-        topicPartitionsStruct.set(PartitionIdsField, partitionIds)\n-        topicPartitionsStruct\n-      }\n-      value.set(TxnPartitionsField, partitionArray.toArray)\n-    }\n-\n-    val byteBuffer = ByteBuffer.allocate(2 /* version */ + value.sizeOf)\n-    byteBuffer.putShort(CurrentVersion)\n-    value.writeTo(byteBuffer)\n-    byteBuffer.array()\n+      val transactionPartition = if (txnMetadata.txnState == Empty) null\n+      else txnMetadata.topicPartitions\n+        .groupBy(_.topic())\n+        .map { case(topic, partitions) =>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTE5NTIwOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionLog.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo0ODozM1rOH6glyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo0ODozM1rOH6glyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExMzQxOQ==", "bodyText": "nit: Parentheses are not required when accessing an accessor. We could remove them here and in few other places in this file.", "url": "https://github.com/apache/kafka/pull/9611#discussion_r531113419", "createdAt": "2020-11-26T15:48:33Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionLog.scala", "diffHunk": "@@ -146,38 +70,27 @@ object TransactionLog {\n     * @return value payload bytes\n     */\n   private[transaction] def valueToBytes(txnMetadata: TxnTransitMetadata): Array[Byte] = {\n-    import ValueSchema._\n-    val value = new Struct(Current)\n-    value.set(ProducerIdField, txnMetadata.producerId)\n-    value.set(ProducerEpochField, txnMetadata.producerEpoch)\n-    value.set(TxnTimeoutField, txnMetadata.txnTimeoutMs)\n-    value.set(TxnStatusField, txnMetadata.txnState.byte)\n-    value.set(TxnEntryTimestampField, txnMetadata.txnLastUpdateTimestamp)\n-    value.set(TxnStartTimestampField, txnMetadata.txnStartTimestamp)\n-\n-    if (txnMetadata.txnState == Empty) {\n-      if (txnMetadata.topicPartitions.nonEmpty)\n+    if (txnMetadata.txnState == Empty && txnMetadata.topicPartitions.nonEmpty)\n         throw new IllegalStateException(s\"Transaction is not expected to have any partitions since its state is ${txnMetadata.txnState}: $txnMetadata\")\n \n-      value.set(TxnPartitionsField, null)\n-    } else {\n-      // first group the topic partitions by their topic names\n-      val topicAndPartitions = txnMetadata.topicPartitions.groupBy(_.topic())\n-\n-      val partitionArray = topicAndPartitions.map { case(topic, partitions) =>\n-        val topicPartitionsStruct = value.instance(TxnPartitionsField)\n-        val partitionIds: Array[Integer] = partitions.map(topicPartition => Integer.valueOf(topicPartition.partition())).toArray\n-        topicPartitionsStruct.set(PartitionsTopicField, topic)\n-        topicPartitionsStruct.set(PartitionIdsField, partitionIds)\n-        topicPartitionsStruct\n-      }\n-      value.set(TxnPartitionsField, partitionArray.toArray)\n-    }\n-\n-    val byteBuffer = ByteBuffer.allocate(2 /* version */ + value.sizeOf)\n-    byteBuffer.putShort(CurrentVersion)\n-    value.writeTo(byteBuffer)\n-    byteBuffer.array()\n+      val transactionPartition = if (txnMetadata.txnState == Empty) null\n+      else txnMetadata.topicPartitions\n+        .groupBy(_.topic())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTIxMjE2OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionLog.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo1Mjo1N1rOH6gv0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo1Mjo1N1rOH6gv0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExNTk4NQ==", "bodyText": "nit: It may be better to combine map(_.partition()).map(Integer.valueOf) in one map to avoid intermediate collection.", "url": "https://github.com/apache/kafka/pull/9611#discussion_r531115985", "createdAt": "2020-11-26T15:52:57Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionLog.scala", "diffHunk": "@@ -146,38 +70,27 @@ object TransactionLog {\n     * @return value payload bytes\n     */\n   private[transaction] def valueToBytes(txnMetadata: TxnTransitMetadata): Array[Byte] = {\n-    import ValueSchema._\n-    val value = new Struct(Current)\n-    value.set(ProducerIdField, txnMetadata.producerId)\n-    value.set(ProducerEpochField, txnMetadata.producerEpoch)\n-    value.set(TxnTimeoutField, txnMetadata.txnTimeoutMs)\n-    value.set(TxnStatusField, txnMetadata.txnState.byte)\n-    value.set(TxnEntryTimestampField, txnMetadata.txnLastUpdateTimestamp)\n-    value.set(TxnStartTimestampField, txnMetadata.txnStartTimestamp)\n-\n-    if (txnMetadata.txnState == Empty) {\n-      if (txnMetadata.topicPartitions.nonEmpty)\n+    if (txnMetadata.txnState == Empty && txnMetadata.topicPartitions.nonEmpty)\n         throw new IllegalStateException(s\"Transaction is not expected to have any partitions since its state is ${txnMetadata.txnState}: $txnMetadata\")\n \n-      value.set(TxnPartitionsField, null)\n-    } else {\n-      // first group the topic partitions by their topic names\n-      val topicAndPartitions = txnMetadata.topicPartitions.groupBy(_.topic())\n-\n-      val partitionArray = topicAndPartitions.map { case(topic, partitions) =>\n-        val topicPartitionsStruct = value.instance(TxnPartitionsField)\n-        val partitionIds: Array[Integer] = partitions.map(topicPartition => Integer.valueOf(topicPartition.partition())).toArray\n-        topicPartitionsStruct.set(PartitionsTopicField, topic)\n-        topicPartitionsStruct.set(PartitionIdsField, partitionIds)\n-        topicPartitionsStruct\n-      }\n-      value.set(TxnPartitionsField, partitionArray.toArray)\n-    }\n-\n-    val byteBuffer = ByteBuffer.allocate(2 /* version */ + value.sizeOf)\n-    byteBuffer.putShort(CurrentVersion)\n-    value.writeTo(byteBuffer)\n-    byteBuffer.array()\n+      val transactionPartition = if (txnMetadata.txnState == Empty) null\n+      else txnMetadata.topicPartitions\n+        .groupBy(_.topic())\n+        .map { case(topic, partitions) =>\n+          new TransactionLogValue.PartitionsSchema()\n+            .setTopic(topic)\n+            .setPartitionIds(partitions.map(_.partition()).map(Integer.valueOf).toList.asJava)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTIxODczOnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionLog.scala", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo1NDo0NlrOH6gz1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxNTo1NDo0NlrOH6gz1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExNzAxNQ==", "bodyText": "nit: transactionPartition -> transactionPartitions?", "url": "https://github.com/apache/kafka/pull/9611#discussion_r531117015", "createdAt": "2020-11-26T15:54:46Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/coordinator/transaction/TransactionLog.scala", "diffHunk": "@@ -146,38 +70,27 @@ object TransactionLog {\n     * @return value payload bytes\n     */\n   private[transaction] def valueToBytes(txnMetadata: TxnTransitMetadata): Array[Byte] = {\n-    import ValueSchema._\n-    val value = new Struct(Current)\n-    value.set(ProducerIdField, txnMetadata.producerId)\n-    value.set(ProducerEpochField, txnMetadata.producerEpoch)\n-    value.set(TxnTimeoutField, txnMetadata.txnTimeoutMs)\n-    value.set(TxnStatusField, txnMetadata.txnState.byte)\n-    value.set(TxnEntryTimestampField, txnMetadata.txnLastUpdateTimestamp)\n-    value.set(TxnStartTimestampField, txnMetadata.txnStartTimestamp)\n-\n-    if (txnMetadata.txnState == Empty) {\n-      if (txnMetadata.topicPartitions.nonEmpty)\n+    if (txnMetadata.txnState == Empty && txnMetadata.topicPartitions.nonEmpty)\n         throw new IllegalStateException(s\"Transaction is not expected to have any partitions since its state is ${txnMetadata.txnState}: $txnMetadata\")\n \n-      value.set(TxnPartitionsField, null)\n-    } else {\n-      // first group the topic partitions by their topic names\n-      val topicAndPartitions = txnMetadata.topicPartitions.groupBy(_.topic())\n-\n-      val partitionArray = topicAndPartitions.map { case(topic, partitions) =>\n-        val topicPartitionsStruct = value.instance(TxnPartitionsField)\n-        val partitionIds: Array[Integer] = partitions.map(topicPartition => Integer.valueOf(topicPartition.partition())).toArray\n-        topicPartitionsStruct.set(PartitionsTopicField, topic)\n-        topicPartitionsStruct.set(PartitionIdsField, partitionIds)\n-        topicPartitionsStruct\n-      }\n-      value.set(TxnPartitionsField, partitionArray.toArray)\n-    }\n-\n-    val byteBuffer = ByteBuffer.allocate(2 /* version */ + value.sizeOf)\n-    byteBuffer.putShort(CurrentVersion)\n-    value.writeTo(byteBuffer)\n-    byteBuffer.array()\n+      val transactionPartition = if (txnMetadata.txnState == Empty) null\n+      else txnMetadata.topicPartitions\n+        .groupBy(_.topic())\n+        .map { case(topic, partitions) =>\n+          new TransactionLogValue.PartitionsSchema()\n+            .setTopic(topic)\n+            .setPartitionIds(partitions.map(_.partition()).map(Integer.valueOf).toList.asJava)\n+        }.toList.asJava\n+\n+    MessageUtil.toBytes(TransactionLogValue.HIGHEST_SUPPORTED_VERSION,\n+      new TransactionLogValue()\n+        .setProducerId(txnMetadata.producerId)\n+        .setProducerEpoch(txnMetadata.producerEpoch)\n+        .setTransactionTimeoutMs(txnMetadata.txnTimeoutMs)\n+        .setTransactionStatus(txnMetadata.txnState.byte)\n+        .setTransactionLastUpdateTimestampMs(txnMetadata.txnLastUpdateTimestamp)\n+        .setTransactionStartTimestampMs(txnMetadata.txnStartTimestamp)\n+        .setTransactionPartitions(transactionPartition))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 166}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3880, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}