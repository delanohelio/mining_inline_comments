{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxOTIwMTY3", "number": 8714, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDozNzo1N1rOD--UBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDozNzo1N1rOD--UBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MzU5MjM5OnYy", "diffSide": "RIGHT", "path": "core/src/main/scala/kafka/log/Log.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDozNzo1N1rOGZZiNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNDozNzo1N1rOGZZiNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTI4NTk0Mg==", "bodyText": "This doesn't change behavior, but makes the code a bit less weird. Previously, we would special case the log, but rely on the called method to check again if deletable is empty.", "url": "https://github.com/apache/kafka/pull/8714#discussion_r429285942", "createdAt": "2020-05-22T14:37:57Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/log/Log.scala", "diffHunk": "@@ -1694,9 +1694,10 @@ class Log(@volatile private var _dir: File,\n   private def deleteOldSegments(predicate: (LogSegment, Option[LogSegment]) => Boolean, reason: String): Int = {\n     lock synchronized {\n       val deletable = deletableSegments(predicate)\n-      if (deletable.nonEmpty)\n+      if (deletable.nonEmpty) {\n         info(s\"Found deletable segments with base offsets [${deletable.map(_.baseOffset).mkString(\",\")}] due to $reason\")\n-      deleteSegments(deletable)\n+        deleteSegments(deletable)\n+      } else 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbd9df44d6a0fe94e4aca4d21078be4d0815878c"}, "originalPosition": 9}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2716, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}