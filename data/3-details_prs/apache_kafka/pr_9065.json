{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1NzgyNjIw", "number": 9065, "title": "KAFKA-10301: Do not clear Partition#remoteReplicasMap during partition assignment updates", "bodyText": "We would previously update the map by adding the new replicas to the map and then removing the old ones. During a recent refactoring, we changed the logic to first clear the map and then add all the replicas to it.\nWhile this is done in a write lock, not all callers that access the map structure use a lock. It is safer to revert to the previous behavior of showing the intermediate state of the map with extra replicas, rather than an intermediate state of the map with no replicas.", "createdAt": "2020-07-23T15:14:05Z", "url": "https://github.com/apache/kafka/pull/9065", "merged": true, "mergeCommit": {"oid": "fa6e5b892227db24568e2cec0a0a0969bc1ec4b5"}, "closed": true, "closedAt": "2020-07-24T19:03:11Z", "author": {"login": "stanislavkozlovski"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3w7JjAH2gAyNDU1NzgyNjIwOjU2MTFmZDg3MmVlZDk4ZjAyZWE4MDVlYWJhYTE3MGM5YjA5YzgxYTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc4D6JUAFqTQ1NDg3ODUzNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5611fd872eed98f02ea805eabaa170c9b09c81a5", "author": {"user": {"login": "stanislavkozlovski", "name": "Stanislav Kozlovski"}}, "url": "https://github.com/apache/kafka/commit/5611fd872eed98f02ea805eabaa170c9b09c81a5", "committedDate": "2020-07-23T15:11:58Z", "message": "KAFKA-10301: Do not clear Partition#remoteReplicasMap during partition assignment updates"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MjM4ODE2", "url": "https://github.com/apache/kafka/pull/9065#pullrequestreview-454238816", "createdAt": "2020-07-23T15:15:04Z", "commit": {"oid": "5611fd872eed98f02ea805eabaa170c9b09c81a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNToxNTowNFrOG2PTuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNToxNTowNFrOG2PTuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUyNzA5Nw==", "bodyText": "I decided to not get fancy with refactorings - this is literally the old code (\n  \n    \n      kafka/core/src/main/scala/kafka/cluster/Partition.scala\n    \n    \n         Line 657\n      in\n      7f9187f\n    \n    \n    \n    \n\n        \n          \n           removedReplicas.foreach(remoteReplicasMap.remove) \n        \n    \n  \n\n))", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459527097", "createdAt": "2020-07-23T15:15:04Z", "author": {"login": "stanislavkozlovski"}, "path": "core/src/main/scala/kafka/cluster/Partition.scala", "diffHunk": "@@ -678,11 +678,13 @@ class Partition(val topicPartition: TopicPartition,\n                              isr: Set[Int],\n                              addingReplicas: Seq[Int],\n                              removingReplicas: Seq[Int]): Unit = {\n-    remoteReplicasMap.clear()\n+    val replicaSet = assignment.toSet\n+    val removedReplicas = remoteReplicasMap.keys -- replicaSet\n+\n     assignment\n       .filter(_ != localBrokerId)\n       .foreach(id => remoteReplicasMap.getAndMaybePut(id, new Replica(id, topicPartition)))\n-\n+    removedReplicas.foreach(remoteReplicasMap.remove)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5611fd872eed98f02ea805eabaa170c9b09c81a5"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "664b7cdf60377c54cecf8b36b3a81511132ef008", "author": {"user": {"login": "stanislavkozlovski", "name": "Stanislav Kozlovski"}}, "url": "https://github.com/apache/kafka/commit/664b7cdf60377c54cecf8b36b3a81511132ef008", "committedDate": "2020-07-23T15:35:32Z", "message": "Avoid using SetOps -- trait method\n\nThe given method is deprecated in Scala 2.13"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6d93406d7563592f8c516b0b8c8d13c7429c290", "author": {"user": {"login": "stanislavkozlovski", "name": "Stanislav Kozlovski"}}, "url": "https://github.com/apache/kafka/commit/f6d93406d7563592f8c516b0b8c8d13c7429c290", "committedDate": "2020-07-23T17:02:49Z", "message": "Prefer Pool#getAndMaybePut to avoid needless Replica instantiations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12016f1d9ad55482edf89f7315191f131dc1dac6", "author": {"user": {"login": "stanislavkozlovski", "name": "Stanislav Kozlovski"}}, "url": "https://github.com/apache/kafka/commit/12016f1d9ad55482edf89f7315191f131dc1dac6", "committedDate": "2020-07-23T17:04:19Z", "message": "Add test to catch the  race condition"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MzMxMTYx", "url": "https://github.com/apache/kafka/pull/9065#pullrequestreview-454331161", "createdAt": "2020-07-23T17:05:25Z", "commit": {"oid": "12016f1d9ad55482edf89f7315191f131dc1dac6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzowNToyNlrOG2TqZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzowNToyNlrOG2TqZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5ODQzOQ==", "bodyText": "This fails incredibly quickly 100/100 times without the Partition.scala changes.", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459598439", "createdAt": "2020-07-23T17:05:26Z", "author": {"login": "stanislavkozlovski"}, "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -116,6 +117,56 @@ class PartitionLockTest extends Logging {\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n+  /**\n+   * Concurrently calling updateAssignmentAndIsr should always ensure that non-lock access\n+   * to the inner remoteReplicaMap (accessed by getReplica) cannot see an intermediate state\n+   * where replicas present both in the old and new assignment are missing\n+   */\n+  @Test\n+  def testGetReplicaWithUpdateAssignmentAndIsr(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12016f1d9ad55482edf89f7315191f131dc1dac6"}, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21fb575aa28581f5b40953726dc8a9868cc46867", "author": {"user": {"login": "stanislavkozlovski", "name": "Stanislav Kozlovski"}}, "url": "https://github.com/apache/kafka/commit/21fb575aa28581f5b40953726dc8a9868cc46867", "committedDate": "2020-07-23T17:18:28Z", "message": "Introduce Pool#removeAll helper method to improve readability"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MzQyNzk5", "url": "https://github.com/apache/kafka/pull/9065#pullrequestreview-454342799", "createdAt": "2020-07-23T17:20:53Z", "commit": {"oid": "21fb575aa28581f5b40953726dc8a9868cc46867"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoyMDo1M1rOG2UNtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzoyMDo1M1rOG2UNtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYwNzQ3Ng==", "bodyText": "Remove unit.", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459607476", "createdAt": "2020-07-23T17:20:53Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/utils/PoolTest.scala", "diffHunk": "@@ -0,0 +1,41 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package unit.kafka.utils", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21fb575aa28581f5b40953726dc8a9868cc46867"}, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c13e73849e4bb1c322aaa099432a4b34401a8085", "author": {"user": {"login": "stanislavkozlovski", "name": "Stanislav Kozlovski"}}, "url": "https://github.com/apache/kafka/commit/c13e73849e4bb1c322aaa099432a4b34401a8085", "committedDate": "2020-07-23T17:22:33Z", "message": "Move PoolTest to same package as kafka.utils.Pool"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0MzUwMjg4", "url": "https://github.com/apache/kafka/pull/9065#pullrequestreview-454350288", "createdAt": "2020-07-23T17:31:07Z", "commit": {"oid": "c13e73849e4bb1c322aaa099432a4b34401a8085"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzozMTowOFrOG2Uk1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxNzo0MjoyMVrOG2U97Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxMzM5OQ==", "bodyText": "Nit: () is not needed.", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459613399", "createdAt": "2020-07-23T17:31:08Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/utils/Pool.scala", "diffHunk": "@@ -69,6 +69,8 @@ class Pool[K,V](valueFactory: Option[K => V] = None) extends Iterable[(K, V)] {\n \n   def remove(key: K, value: V): Boolean = pool.remove(key, value)\n \n+  def removeAll(keys: Iterable[K]): Unit = pool.keySet().removeAll(keys.asJavaCollection)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c13e73849e4bb1c322aaa099432a4b34401a8085"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxNTM5OQ==", "bodyText": "No need to repeat LeaderAndIsrPartitionState twice.", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459615399", "createdAt": "2020-07-23T17:34:40Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -116,6 +117,56 @@ class PartitionLockTest extends Logging {\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n+  /**\n+   * Concurrently calling updateAssignmentAndIsr should always ensure that non-lock access\n+   * to the inner remoteReplicaMap (accessed by getReplica) cannot see an intermediate state\n+   * where replicas present both in the old and new assignment are missing\n+   */\n+  @Test\n+  def testGetReplicaWithUpdateAssignmentAndIsr(): Unit = {\n+    val active = new AtomicBoolean(true)\n+    val replicaToCheck = 3\n+    val firstReplicaSet = Seq[Integer](3, 4, 5).asJava\n+    val secondReplicaSet = Seq[Integer](1, 2, 3).asJava\n+    def partitionState(replicas: java.util.List[Integer]): LeaderAndIsrPartitionState = new LeaderAndIsrPartitionState()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c13e73849e4bb1c322aaa099432a4b34401a8085"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxNjE1NA==", "bodyText": "Shouldn't this be inside the thread state?", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459616154", "createdAt": "2020-07-23T17:36:03Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -116,6 +117,56 @@ class PartitionLockTest extends Logging {\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n+  /**\n+   * Concurrently calling updateAssignmentAndIsr should always ensure that non-lock access\n+   * to the inner remoteReplicaMap (accessed by getReplica) cannot see an intermediate state\n+   * where replicas present both in the old and new assignment are missing\n+   */\n+  @Test\n+  def testGetReplicaWithUpdateAssignmentAndIsr(): Unit = {\n+    val active = new AtomicBoolean(true)\n+    val replicaToCheck = 3\n+    val firstReplicaSet = Seq[Integer](3, 4, 5).asJava\n+    val secondReplicaSet = Seq[Integer](1, 2, 3).asJava\n+    def partitionState(replicas: java.util.List[Integer]): LeaderAndIsrPartitionState = new LeaderAndIsrPartitionState()\n+      .setControllerEpoch(1)\n+      .setLeader(replicas.get(0))\n+      .setLeaderEpoch(1)\n+      .setIsr(replicas)\n+      .setZkVersion(1)\n+      .setReplicas(replicas)\n+      .setIsNew(true)\n+    val offsetCheckpoints: OffsetCheckpoints = mock(classOf[OffsetCheckpoints])\n+    // Update replica set synchronously first to avoid race conditions\n+    partition.makeLeader(partitionState(secondReplicaSet), offsetCheckpoints)\n+    assertTrue(s\"Expected replica $replicaToCheck to be defined\", partition.getReplica(replicaToCheck).isDefined)\n+\n+    var i = 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c13e73849e4bb1c322aaa099432a4b34401a8085"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxNzI5OA==", "bodyText": "5 seconds is quite a bit. Can it be lower?", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459617298", "createdAt": "2020-07-23T17:37:57Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -116,6 +117,56 @@ class PartitionLockTest extends Logging {\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n+  /**\n+   * Concurrently calling updateAssignmentAndIsr should always ensure that non-lock access\n+   * to the inner remoteReplicaMap (accessed by getReplica) cannot see an intermediate state\n+   * where replicas present both in the old and new assignment are missing\n+   */\n+  @Test\n+  def testGetReplicaWithUpdateAssignmentAndIsr(): Unit = {\n+    val active = new AtomicBoolean(true)\n+    val replicaToCheck = 3\n+    val firstReplicaSet = Seq[Integer](3, 4, 5).asJava\n+    val secondReplicaSet = Seq[Integer](1, 2, 3).asJava\n+    def partitionState(replicas: java.util.List[Integer]): LeaderAndIsrPartitionState = new LeaderAndIsrPartitionState()\n+      .setControllerEpoch(1)\n+      .setLeader(replicas.get(0))\n+      .setLeaderEpoch(1)\n+      .setIsr(replicas)\n+      .setZkVersion(1)\n+      .setReplicas(replicas)\n+      .setIsNew(true)\n+    val offsetCheckpoints: OffsetCheckpoints = mock(classOf[OffsetCheckpoints])\n+    // Update replica set synchronously first to avoid race conditions\n+    partition.makeLeader(partitionState(secondReplicaSet), offsetCheckpoints)\n+    assertTrue(s\"Expected replica $replicaToCheck to be defined\", partition.getReplica(replicaToCheck).isDefined)\n+\n+    var i = 0\n+    val future = executorService.submit((() => {\n+      // Flip assignment between two replica sets\n+      while (active.get) {\n+        val replicas = if (i % 2 == 0) {\n+          firstReplicaSet\n+        } else {\n+          secondReplicaSet\n+        }\n+\n+        partition.makeLeader(partitionState(replicas), offsetCheckpoints)\n+\n+        i += 1\n+        Thread.sleep(1) // just to avoid tight loop\n+      }\n+    }): Runnable)\n+\n+    val deadline = 5.seconds.fromNow", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c13e73849e4bb1c322aaa099432a4b34401a8085"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYxOTgyMQ==", "bodyText": "Nit: space missing after while.", "url": "https://github.com/apache/kafka/pull/9065#discussion_r459619821", "createdAt": "2020-07-23T17:42:21Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/cluster/PartitionLockTest.scala", "diffHunk": "@@ -116,6 +117,56 @@ class PartitionLockTest extends Logging {\n     future.get(15, TimeUnit.SECONDS)\n   }\n \n+  /**\n+   * Concurrently calling updateAssignmentAndIsr should always ensure that non-lock access\n+   * to the inner remoteReplicaMap (accessed by getReplica) cannot see an intermediate state\n+   * where replicas present both in the old and new assignment are missing\n+   */\n+  @Test\n+  def testGetReplicaWithUpdateAssignmentAndIsr(): Unit = {\n+    val active = new AtomicBoolean(true)\n+    val replicaToCheck = 3\n+    val firstReplicaSet = Seq[Integer](3, 4, 5).asJava\n+    val secondReplicaSet = Seq[Integer](1, 2, 3).asJava\n+    def partitionState(replicas: java.util.List[Integer]): LeaderAndIsrPartitionState = new LeaderAndIsrPartitionState()\n+      .setControllerEpoch(1)\n+      .setLeader(replicas.get(0))\n+      .setLeaderEpoch(1)\n+      .setIsr(replicas)\n+      .setZkVersion(1)\n+      .setReplicas(replicas)\n+      .setIsNew(true)\n+    val offsetCheckpoints: OffsetCheckpoints = mock(classOf[OffsetCheckpoints])\n+    // Update replica set synchronously first to avoid race conditions\n+    partition.makeLeader(partitionState(secondReplicaSet), offsetCheckpoints)\n+    assertTrue(s\"Expected replica $replicaToCheck to be defined\", partition.getReplica(replicaToCheck).isDefined)\n+\n+    var i = 0\n+    val future = executorService.submit((() => {\n+      // Flip assignment between two replica sets\n+      while (active.get) {\n+        val replicas = if (i % 2 == 0) {\n+          firstReplicaSet\n+        } else {\n+          secondReplicaSet\n+        }\n+\n+        partition.makeLeader(partitionState(replicas), offsetCheckpoints)\n+\n+        i += 1\n+        Thread.sleep(1) // just to avoid tight loop\n+      }\n+    }): Runnable)\n+\n+    val deadline = 5.seconds.fromNow\n+    while(deadline.hasTimeLeft()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c13e73849e4bb1c322aaa099432a4b34401a8085"}, "originalPosition": 54}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f813d69b07fb5cf8a85587576652e4a55cc7f3b", "author": {"user": {"login": "stanislavkozlovski", "name": "Stanislav Kozlovski"}}, "url": "https://github.com/apache/kafka/commit/0f813d69b07fb5cf8a85587576652e4a55cc7f3b", "committedDate": "2020-07-23T18:27:03Z", "message": "Reduce test timeout and address stylistic comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0ODc4NTM0", "url": "https://github.com/apache/kafka/pull/9065#pullrequestreview-454878534", "createdAt": "2020-07-24T13:19:04Z", "commit": {"oid": "0f813d69b07fb5cf8a85587576652e4a55cc7f3b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1373, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}