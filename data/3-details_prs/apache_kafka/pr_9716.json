{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0ODA3NDAz", "number": 9716, "title": "KAFKA-10826; Ensure raft io thread respects linger timeout", "bodyText": "When there are no pending operations, the raft IO thread can block indefinitely waiting for a network event. We rely on asynchronous wakeups in order to break the blocking wait in order to respond to a scheduled append. The current logic already does this, but only for the case when the linger time has been completed during the call to scheduleAppend. It is possible instead that after making one call to scheduleAppend to start the linger timer, the application does not do any additional appends. In this case, we still need the IO thread to wakeup when the linger timer expires. This patch fixes the problem by ensuring that the IO thread gets woken up after the first append which begins the linger timer.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-12-09T00:10:50Z", "url": "https://github.com/apache/kafka/pull/9716", "merged": true, "mergeCommit": {"oid": "a8b668b37caf9dd8211e97ccebcc70d074a2c646"}, "closed": true, "closedAt": "2020-12-09T21:33:29Z", "author": {"login": "hachikuji"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdkTMXsgH2gAyNTM0ODA3NDAzOmQzYmZjOGNlM2ZiYzRkMmNiM2ZhYjJmMGMzZjYzOWYzYjZkMmQ2YzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdkjAJmgH2gAyNTM0ODA3NDAzOjMwNmM5NTZmNTNkY2U1Yjk4YWNiZjg4MWI5MDIxNjM4NTg3OGI1N2U=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d3bfc8ce3fbc4d2cb3fab2f0c3f639f3b6d2d6c6", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/d3bfc8ce3fbc4d2cb3fab2f0c3f639f3b6d2d6c6", "committedDate": "2020-12-09T00:00:13Z", "message": "KAFKA-10826; Ensure raft io thread respects linger timeout"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3ODI3MDYz", "url": "https://github.com/apache/kafka/pull/9716#pullrequestreview-547827063", "createdAt": "2020-12-09T04:30:09Z", "commit": {"oid": "d3bfc8ce3fbc4d2cb3fab2f0c3f639f3b6d2d6c6"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNDozMDowOVrOICBzLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwNDo1MTo0N1rOICCNlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk5NzU0OQ==", "bodyText": "Nice one.", "url": "https://github.com/apache/kafka/pull/9716#discussion_r538997549", "createdAt": "2020-12-09T04:30:09Z", "author": {"login": "guozhangwang"}, "path": "raft/src/main/java/org/apache/kafka/raft/internals/BatchAccumulator.java", "diffHunk": "@@ -271,22 +272,19 @@ public int epoch() {\n         }\n     }\n \n+    public boolean isEmpty() {\n+        // The linger timer begins running when we have pending batches.\n+        // We use this to infer when the accumulator is empty to avoid the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3bfc8ce3fbc4d2cb3fab2f0c3f639f3b6d2d6c6"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk5OTYwOA==", "bodyText": "Does the javadoc above need updates?", "url": "https://github.com/apache/kafka/pull/9716#discussion_r538999608", "createdAt": "2020-12-09T04:36:49Z", "author": {"login": "guozhangwang"}, "path": "raft/src/main/java/org/apache/kafka/raft/internals/BatchAccumulator.java", "diffHunk": "@@ -271,22 +272,19 @@ public int epoch() {\n         }\n     }\n \n+    public boolean isEmpty() {\n+        // The linger timer begins running when we have pending batches.\n+        // We use this to infer when the accumulator is empty to avoid the\n+        // need to acquire the append lock.\n+        return !lingerTimer.isRunning();\n+    }\n+\n     /**\n      * Get the number of batches including the one that is currently being\n      * written to (if it exists).\n      */\n-    public int count() {\n-        appendLock.lock();\n-        try {\n-            int count = completed.size();\n-            if (currentBatch != null) {\n-                return count + 1;\n-            } else {\n-                return count;\n-            }\n-        } finally {\n-            appendLock.unlock();\n-        }\n+    public int numCompletedBatches() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3bfc8ce3fbc4d2cb3fab2f0c3f639f3b6d2d6c6"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTAwNDMwOA==", "bodyText": "nit: maybe we split 50 to 20/30 to avoid some reading difficulty? :)", "url": "https://github.com/apache/kafka/pull/9716#discussion_r539004308", "createdAt": "2020-12-09T04:51:47Z", "author": {"login": "guozhangwang"}, "path": "raft/src/test/java/org/apache/kafka/raft/KafkaRaftClientTest.java", "diffHunk": "@@ -477,6 +477,74 @@ public void testAccumulatorClearedAfterBecomingUnattached() throws Exception {\n         Mockito.verify(memoryPool).release(buffer);\n     }\n \n+    @Test\n+    public void testChannelWokenUpIfLingerTimeoutReachedWithoutAppend() throws Exception {\n+        // This test verifies that the client will set its poll timeout accounting\n+        // for the lingerMs of a pending append\n+\n+        int localId = 0;\n+        int otherNodeId = 1;\n+        int lingerMs = 50;\n+        Set<Integer> voters = Utils.mkSet(localId, otherNodeId);\n+\n+        RaftClientTestContext context = new RaftClientTestContext.Builder(localId, voters)\n+            .withAppendLingerMs(lingerMs)\n+            .build();\n+\n+        context.becomeLeader();\n+        assertEquals(OptionalInt.of(localId), context.currentLeader());\n+        assertEquals(1L, context.log.endOffset().offset);\n+\n+        int epoch = context.currentEpoch();\n+        assertEquals(1L, context.client.scheduleAppend(epoch, singletonList(\"a\")));\n+        assertTrue(context.channel.wakeupRequested());\n+\n+        context.client.poll();\n+        assertEquals(OptionalLong.of(lingerMs), context.channel.lastReceiveTimeout());\n+\n+        context.time.sleep(25);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3bfc8ce3fbc4d2cb3fab2f0c3f639f3b6d2d6c6"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "306c956f53dce5b98acbf881b90216385878b57e", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/306c956f53dce5b98acbf881b90216385878b57e", "committedDate": "2020-12-09T18:25:21Z", "message": "Address review comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2605, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}