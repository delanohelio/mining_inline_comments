{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ0MTE2NjQ1", "number": 9779, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOFQxMDo0NTozMVrOFnc_2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOFQxMTowNjo0NlrOFndjww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc2OTEzODgyOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOFQxMDo0NTozMVrOI5GMTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxMTo1MTo1M1rOI57tDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Njc0MTE5OQ==", "bodyText": "nit: Could you please use assertThat(iterator.peekNextKey(), is(the Byte)) here?", "url": "https://github.com/apache/kafka/pull/9779#discussion_r596741199", "createdAt": "2021-03-18T10:45:31Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java", "diffHunk": "@@ -243,6 +243,16 @@ public void shouldPeekNextKey() {\n         assertEquals(theByte, iterator.peekNextKey());\n     }\n \n+    @Test\n+    public void shouldPeekNextKeyReverseRange() {\n+        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final Bytes theByte = Bytes.wrap(new byte[]{1});\n+        cache.put(namespace, theByte, dirtyEntry(theByte.get()));\n+        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), theByte);\n+        assertEquals(theByte, iterator.peekNextKey());\n+        assertEquals(theByte, iterator.peekNextKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98b708e45f9a81fe597febf2cba9ca97d3feceaa"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzYxNzkzNQ==", "bodyText": "done", "url": "https://github.com/apache/kafka/pull/9779#discussion_r597617935", "createdAt": "2021-03-19T11:51:53Z", "author": {"login": "vamossagar12"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java", "diffHunk": "@@ -243,6 +243,16 @@ public void shouldPeekNextKey() {\n         assertEquals(theByte, iterator.peekNextKey());\n     }\n \n+    @Test\n+    public void shouldPeekNextKeyReverseRange() {\n+        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final Bytes theByte = Bytes.wrap(new byte[]{1});\n+        cache.put(namespace, theByte, dirtyEntry(theByte.get()));\n+        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), theByte);\n+        assertEquals(theByte, iterator.peekNextKey());\n+        assertEquals(theByte, iterator.peekNextKey());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Njc0MTE5OQ=="}, "originalCommit": {"oid": "98b708e45f9a81fe597febf2cba9ca97d3feceaa"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc2OTE0MTUzOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOFQxMDo0NjowNVrOI5GN2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOFQxMDo0NjowNVrOI5GN2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Njc0MTU5Mg==", "bodyText": "nit: see my comment about assertThat() above.", "url": "https://github.com/apache/kafka/pull/9779#discussion_r596741592", "createdAt": "2021-03-18T10:46:05Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java", "diffHunk": "@@ -252,20 +262,43 @@ public void shouldGetSameKeyAsPeekNext() {\n         assertEquals(iterator.peekNextKey(), iterator.next().key);\n     }\n \n+    @Test\n+    public void shouldGetSameKeyAsPeekNextReverseRange() {\n+        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final Bytes theByte = Bytes.wrap(new byte[]{1});\n+        cache.put(namespace, theByte, dirtyEntry(theByte.get()));\n+        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), theByte);\n+        assertEquals(iterator.peekNextKey(), iterator.next().key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98b708e45f9a81fe597febf2cba9ca97d3feceaa"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc2OTIzMDc1OnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOFQxMTowNjo0NlrOI5HFBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxMTo1MzowNVrOI57vhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Njc1NTcxNw==", "bodyText": "nit: could you try to deduplicate code here and in the other unit tests? Here for example, you could have one method like this:\n    private void shouldThrowIfNoPeekNextKey(final Supplier<MemoryLRUCacheBytesIterator> methodUnderTest) {\n        final ThreadCache.MemoryLRUCacheBytesIterator iterator = methodUnderTest.get();\n        assertThrows(NoSuchElementException.class, iterator::peekNextKey);\n    }\n\nand then two public tests\n    @Test\n    public void shouldThrowIfNoPeekNextKeyRange() {\n        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n        shouldThrowIfNoPeekNextKey(() -> cache.range(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1})));\n    }\n\n    @Test\n    public void shouldThrowIfNoPeekNextKeyReverseRange() {\n        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n        shouldThrowIfNoPeekNextKey(() -> cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1})));\n    }\n\nAdmittedly, in this specific case, we would not win much but for other unit tests in this test class it may be worth. Try and then decide if it is worth or not.", "url": "https://github.com/apache/kafka/pull/9779#discussion_r596755717", "createdAt": "2021-03-18T11:06:46Z", "author": {"login": "cadonna"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java", "diffHunk": "@@ -252,20 +262,43 @@ public void shouldGetSameKeyAsPeekNext() {\n         assertEquals(iterator.peekNextKey(), iterator.next().key);\n     }\n \n+    @Test\n+    public void shouldGetSameKeyAsPeekNextReverseRange() {\n+        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final Bytes theByte = Bytes.wrap(new byte[]{1});\n+        cache.put(namespace, theByte, dirtyEntry(theByte.get()));\n+        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), theByte);\n+        assertEquals(iterator.peekNextKey(), iterator.next().key);\n+    }\n+\n     @Test\n     public void shouldThrowIfNoPeekNextKey() {\n         final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n         final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}));\n         assertThrows(NoSuchElementException.class, iterator::peekNextKey);\n     }\n \n+    @Test\n+    public void shouldThrowIfNoPeekNextKeyReverseRange() {\n+        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}));\n+        assertThrows(NoSuchElementException.class, iterator::peekNextKey);\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98b708e45f9a81fe597febf2cba9ca97d3feceaa"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzYxODU2Ng==", "bodyText": "Done. This made sense. I have also added the logic to generate the ThreadCache in a separate method(setupThreadCache) . That reduced lot of duplicate code from a lot of methods", "url": "https://github.com/apache/kafka/pull/9779#discussion_r597618566", "createdAt": "2021-03-19T11:53:05Z", "author": {"login": "vamossagar12"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/ThreadCacheTest.java", "diffHunk": "@@ -252,20 +262,43 @@ public void shouldGetSameKeyAsPeekNext() {\n         assertEquals(iterator.peekNextKey(), iterator.next().key);\n     }\n \n+    @Test\n+    public void shouldGetSameKeyAsPeekNextReverseRange() {\n+        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final Bytes theByte = Bytes.wrap(new byte[]{1});\n+        cache.put(namespace, theByte, dirtyEntry(theByte.get()));\n+        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), theByte);\n+        assertEquals(iterator.peekNextKey(), iterator.next().key);\n+    }\n+\n     @Test\n     public void shouldThrowIfNoPeekNextKey() {\n         final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n         final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.range(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}));\n         assertThrows(NoSuchElementException.class, iterator::peekNextKey);\n     }\n \n+    @Test\n+    public void shouldThrowIfNoPeekNextKeyReverseRange() {\n+        final ThreadCache cache = new ThreadCache(logContext, 10000L, new MockStreamsMetrics(new Metrics()));\n+        final ThreadCache.MemoryLRUCacheBytesIterator iterator = cache.reverseRange(namespace, Bytes.wrap(new byte[]{0}), Bytes.wrap(new byte[]{1}));\n+        assertThrows(NoSuchElementException.class, iterator::peekNextKey);\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Njc1NTcxNw=="}, "originalCommit": {"oid": "98b708e45f9a81fe597febf2cba9ca97d3feceaa"}, "originalPosition": 121}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3552, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}