{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzOTAwNzMw", "number": 8358, "title": "KAFKA-9756: Process more than one record of one task at a time", "bodyText": "Within a single while loop, process the tasks in AAABBBCCC instead of ABCABCABC. This also helps the follow-up PR to time the per-task processing ratio to record less time, hence less overhead.\n\n\nAdd thread-level process / punctuate / poll / commit ratio metrics.\n\n\nFixed a few issues discovered (inline commented).\n\n\nI am adding metrics test coverage for 2) above in another PR, which added more sensor / metrics.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-03-26T01:01:31Z", "url": "https://github.com/apache/kafka/pull/8358", "merged": true, "mergeCommit": {"oid": "9d9b59fccc1d3a71758dfb7dc6d2325d4fba9955"}, "closed": true, "closedAt": "2020-03-27T05:54:09Z", "author": {"login": "guozhangwang"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcQ8k_tgH2gAyMzkzOTAwNzMwOjcwY2E1NzRmZDhlM2YzYmMyY2E0MmIzYmI1NmRlOGY5MzZlNzdmMDc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcS0XNaAFqTM4NDE5Njk2OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "70ca574fd8e3f3bc2ca42b3bb56de8f936e77f07", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/70ca574fd8e3f3bc2ca42b3bb56de8f936e77f07", "committedDate": "2020-03-25T00:43:35Z", "message": "first pass"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b33c3e798f4f63964df1f961210d0ab0975dc52", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/8b33c3e798f4f63964df1f961210d0ab0975dc52", "committedDate": "2020-03-25T05:02:12Z", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into K9756-loop-tasks-order"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77e475e5ca63a0d57070b49b8366d60857b7b7d2", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/77e475e5ca63a0d57070b49b8366d60857b7b7d2", "committedDate": "2020-03-25T23:15:08Z", "message": "fix unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/d5c743baa264f5cc9ea6c9f48aed24cb8ab72365", "committedDate": "2020-03-26T00:14:28Z", "message": "add unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNjM4NzA0", "url": "https://github.com/apache/kafka/pull/8358#pullrequestreview-381638704", "createdAt": "2020-03-26T01:02:30Z", "commit": {"oid": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwMTowMjozMVrOF7z02A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQwMTowNjo0MFrOF7z5Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI1OTQxNg==", "bodyText": "This is the meat of the PR: measure the total process / punctuate / commit latency, in order to measure the corresponding ratio.", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398259416", "createdAt": "2020-03-26T01:02:31Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -623,63 +642,75 @@ void runOnce() {\n         // if there's no active restoring or standby updating it would not try to fetch any data\n         changelogReader.restore();\n \n-        advanceNowAndComputeLatency();\n+        final long restoreLatency = advanceNowAndComputeLatency();\n \n+        long totalCommitLatency = 0L;\n+        long totalProcessLatency = 0L;\n+        long totalPunctuateLatency = 0L;\n         if (state == State.RUNNING) {\n             /*\n-             * Within an iteration, after N (N initialized as 1 upon start up) round of processing one-record-each on the applicable tasks, check the current time:\n-             *  1. If it is time to commit, do it;\n-             *  2. If it is time to punctuate, do it;\n-             *  3. If elapsed time is close to consumer's max.poll.interval.ms, end the current iteration immediately.\n-             *  4. If none of the the above happens, increment N.\n-             *  5. If one of the above happens, half the value of N.\n+             * Within an iteration, after processing up to N (N initialized as 1 upon start up) records for each applicable tasks, check the current time:\n+             *  1. If it is time to punctuate, do it;\n+             *  2. If it is time to commit, do it, this should be after 1) since punctuate may trigger commit;\n+             *  3. If there's no records processed, end the current iteration immediately;\n+             *  4. If we are close to consumer's next poll deadline, end the current iteration immediately;\n+             *  5. If any of 1), 2) and 4) happens, half N for next iteration;\n+             *  6. Otherwise, increment N.\n              */\n-            int processed = 0;\n-            long timeSinceLastPoll;\n-\n             do {\n-                for (int i = 0; i < numIterations; i++) {\n-                    advanceNowAndComputeLatency();\n-                    processed = taskManager.process(now);\n-\n-                    if (processed > 0) {\n-                        // It makes no difference to the outcome of these metrics when we record \"0\",\n-                        // so we can just avoid the method call when we didn't process anything.\n-                        processRateSensor.record(processed, now);\n-\n-                        // This metric is scaled to represent the _average_ processing time of _each_\n-                        // task. Note, it's hard to interpret this as defined, but we would need a KIP\n-                        // to change it to simply report the overall time spent processing all tasks.\n-                        final long processLatency = advanceNowAndComputeLatency();\n-                        processLatencySensor.record(processLatency / (double) processed, now);\n-\n-                        // commit any tasks that have requested a commit\n-                        final int committed = taskManager.maybeCommitActiveTasksPerUserRequested();\n-\n-                        if (committed > 0) {\n-                            final long commitLatency = advanceNowAndComputeLatency();\n-                            commitSensor.record(commitLatency / (double) committed, now);\n-                        }\n-                    } else {\n-                        // if there is no records to be processed, exit immediately\n-                        break;\n-                    }\n+                final int processed = taskManager.process(numIterations, now);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI1OTc3Mw==", "bodyText": "I removed this call intentionally, and defer that to the end of the current batch. Because if we are in the middle of a rebalance, even upon requested we do not guarantee the commit will happen right after that record of the task is processed anyways, so deferring this user-requested check to reduce overhead.", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398259773", "createdAt": "2020-03-26T01:03:49Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -623,63 +642,75 @@ void runOnce() {\n         // if there's no active restoring or standby updating it would not try to fetch any data\n         changelogReader.restore();\n \n-        advanceNowAndComputeLatency();\n+        final long restoreLatency = advanceNowAndComputeLatency();\n \n+        long totalCommitLatency = 0L;\n+        long totalProcessLatency = 0L;\n+        long totalPunctuateLatency = 0L;\n         if (state == State.RUNNING) {\n             /*\n-             * Within an iteration, after N (N initialized as 1 upon start up) round of processing one-record-each on the applicable tasks, check the current time:\n-             *  1. If it is time to commit, do it;\n-             *  2. If it is time to punctuate, do it;\n-             *  3. If elapsed time is close to consumer's max.poll.interval.ms, end the current iteration immediately.\n-             *  4. If none of the the above happens, increment N.\n-             *  5. If one of the above happens, half the value of N.\n+             * Within an iteration, after processing up to N (N initialized as 1 upon start up) records for each applicable tasks, check the current time:\n+             *  1. If it is time to punctuate, do it;\n+             *  2. If it is time to commit, do it, this should be after 1) since punctuate may trigger commit;\n+             *  3. If there's no records processed, end the current iteration immediately;\n+             *  4. If we are close to consumer's next poll deadline, end the current iteration immediately;\n+             *  5. If any of 1), 2) and 4) happens, half N for next iteration;\n+             *  6. Otherwise, increment N.\n              */\n-            int processed = 0;\n-            long timeSinceLastPoll;\n-\n             do {\n-                for (int i = 0; i < numIterations; i++) {\n-                    advanceNowAndComputeLatency();\n-                    processed = taskManager.process(now);\n-\n-                    if (processed > 0) {\n-                        // It makes no difference to the outcome of these metrics when we record \"0\",\n-                        // so we can just avoid the method call when we didn't process anything.\n-                        processRateSensor.record(processed, now);\n-\n-                        // This metric is scaled to represent the _average_ processing time of _each_\n-                        // task. Note, it's hard to interpret this as defined, but we would need a KIP\n-                        // to change it to simply report the overall time spent processing all tasks.\n-                        final long processLatency = advanceNowAndComputeLatency();\n-                        processLatencySensor.record(processLatency / (double) processed, now);\n-\n-                        // commit any tasks that have requested a commit\n-                        final int committed = taskManager.maybeCommitActiveTasksPerUserRequested();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI1OTg3Mw==", "bodyText": "This func is inlined into runOnce.", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398259873", "createdAt": "2020-03-26T01:04:08Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -765,19 +796,6 @@ private void addRecordsToTasks(final ConsumerRecords<byte[], byte[]> records) {\n         }\n     }\n \n-    /**\n-     * @throws TaskMigratedException if the task producer got fenced (EOS only)\n-     */\n-    private boolean maybePunctuate() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI2MDEwNg==", "bodyText": "This is a minor fix: previously we need to call this because we process standbys AFTER processing actives and hence may be we need to commit again afterwards, but not we process standbys first, then active, so this can be removed.", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398260106", "createdAt": "2020-03-26T01:05:07Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -623,63 +642,75 @@ void runOnce() {\n         // if there's no active restoring or standby updating it would not try to fetch any data\n         changelogReader.restore();\n \n-        advanceNowAndComputeLatency();\n+        final long restoreLatency = advanceNowAndComputeLatency();\n \n+        long totalCommitLatency = 0L;\n+        long totalProcessLatency = 0L;\n+        long totalPunctuateLatency = 0L;\n         if (state == State.RUNNING) {\n             /*\n-             * Within an iteration, after N (N initialized as 1 upon start up) round of processing one-record-each on the applicable tasks, check the current time:\n-             *  1. If it is time to commit, do it;\n-             *  2. If it is time to punctuate, do it;\n-             *  3. If elapsed time is close to consumer's max.poll.interval.ms, end the current iteration immediately.\n-             *  4. If none of the the above happens, increment N.\n-             *  5. If one of the above happens, half the value of N.\n+             * Within an iteration, after processing up to N (N initialized as 1 upon start up) records for each applicable tasks, check the current time:\n+             *  1. If it is time to punctuate, do it;\n+             *  2. If it is time to commit, do it, this should be after 1) since punctuate may trigger commit;\n+             *  3. If there's no records processed, end the current iteration immediately;\n+             *  4. If we are close to consumer's next poll deadline, end the current iteration immediately;\n+             *  5. If any of 1), 2) and 4) happens, half N for next iteration;\n+             *  6. Otherwise, increment N.\n              */\n-            int processed = 0;\n-            long timeSinceLastPoll;\n-\n             do {\n-                for (int i = 0; i < numIterations; i++) {\n-                    advanceNowAndComputeLatency();\n-                    processed = taskManager.process(now);\n-\n-                    if (processed > 0) {\n-                        // It makes no difference to the outcome of these metrics when we record \"0\",\n-                        // so we can just avoid the method call when we didn't process anything.\n-                        processRateSensor.record(processed, now);\n-\n-                        // This metric is scaled to represent the _average_ processing time of _each_\n-                        // task. Note, it's hard to interpret this as defined, but we would need a KIP\n-                        // to change it to simply report the overall time spent processing all tasks.\n-                        final long processLatency = advanceNowAndComputeLatency();\n-                        processLatencySensor.record(processLatency / (double) processed, now);\n-\n-                        // commit any tasks that have requested a commit\n-                        final int committed = taskManager.maybeCommitActiveTasksPerUserRequested();\n-\n-                        if (committed > 0) {\n-                            final long commitLatency = advanceNowAndComputeLatency();\n-                            commitSensor.record(commitLatency / (double) committed, now);\n-                        }\n-                    } else {\n-                        // if there is no records to be processed, exit immediately\n-                        break;\n-                    }\n+                final int processed = taskManager.process(numIterations, now);\n+                if (processed > 0) {\n+                    // It makes no difference to the outcome of these metrics when we record \"0\",\n+                    // so we can just avoid the method call when we didn't process anything.\n+                    processRateSensor.record(processed, now);\n+\n+                    // This metric is scaled to represent the _average_ processing time of _each_\n+                    // task. Note, it's hard to interpret this as defined, but we would need a KIP\n+                    // to change it to simply report the overall time spent processing all tasks.\n+                    final long processLatency = advanceNowAndComputeLatency();\n+                    processLatencySensor.record(processLatency / (double) processed, now);\n+                    totalProcessLatency += processLatency;\n+                }\n+\n+                final int punctuated = taskManager.punctuate();\n+                if (punctuated > 0) {\n+                    final long punctuateLatency = advanceNowAndComputeLatency();\n+                    punctuateSensor.record(punctuateLatency / (double) punctuated, now);\n+                    totalPunctuateLatency += punctuateLatency;\n                 }\n \n-                timeSinceLastPoll = Math.max(now - lastPollMs, 0);\n+                final int committed = maybeCommit();\n+                if (committed > 0) {\n+                    final long commitLatency = advanceNowAndComputeLatency();\n+                    commitSensor.record(commitLatency / (double) committed, now);\n \n-                if (maybePunctuate() || maybeCommit()) {\n-                    numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n-                } else if (timeSinceLastPoll > maxPollTimeMs / 2) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Committed all active tasks {} and standby tasks {} in {}ms\",\n+                            taskManager.activeTaskIds(), taskManager.standbyTaskIds(), commitLatency);\n+                    }\n+\n+                    totalCommitLatency += commitLatency;\n+                }\n+\n+                if (processed == 0) {\n+                    // if there is no records to be processed, exit after punctuate / commit\n+                    break;\n+                } else if (Math.max(now - lastPollMs, 0) > maxPollTimeMs / 2) {\n                     numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n                     break;\n-                } else if (processed > 0) {\n+                } else if (punctuated > 0 || committed > 0) {\n+                    numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n+                } else {\n                     numIterations++;\n                 }\n-            } while (processed > 0);\n-\n-            maybeCommit();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI2MDUwNg==", "bodyText": "There are also a minor fix here: we used to calculate the timeSinceLastPoll before we call maybePunctuate / maybeCommit, which may actually take a lot of time; this would cause us to be mistakenly more aggressive in timeSinceLastPoll > maxPollTimeMs / 2 since timeSinceLastPoll is actually larger than the recorded value, and hence more likely to be kicked out of the group.", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398260506", "createdAt": "2020-03-26T01:06:40Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -623,63 +642,75 @@ void runOnce() {\n         // if there's no active restoring or standby updating it would not try to fetch any data\n         changelogReader.restore();\n \n-        advanceNowAndComputeLatency();\n+        final long restoreLatency = advanceNowAndComputeLatency();\n \n+        long totalCommitLatency = 0L;\n+        long totalProcessLatency = 0L;\n+        long totalPunctuateLatency = 0L;\n         if (state == State.RUNNING) {\n             /*\n-             * Within an iteration, after N (N initialized as 1 upon start up) round of processing one-record-each on the applicable tasks, check the current time:\n-             *  1. If it is time to commit, do it;\n-             *  2. If it is time to punctuate, do it;\n-             *  3. If elapsed time is close to consumer's max.poll.interval.ms, end the current iteration immediately.\n-             *  4. If none of the the above happens, increment N.\n-             *  5. If one of the above happens, half the value of N.\n+             * Within an iteration, after processing up to N (N initialized as 1 upon start up) records for each applicable tasks, check the current time:\n+             *  1. If it is time to punctuate, do it;\n+             *  2. If it is time to commit, do it, this should be after 1) since punctuate may trigger commit;\n+             *  3. If there's no records processed, end the current iteration immediately;\n+             *  4. If we are close to consumer's next poll deadline, end the current iteration immediately;\n+             *  5. If any of 1), 2) and 4) happens, half N for next iteration;\n+             *  6. Otherwise, increment N.\n              */\n-            int processed = 0;\n-            long timeSinceLastPoll;\n-\n             do {\n-                for (int i = 0; i < numIterations; i++) {\n-                    advanceNowAndComputeLatency();\n-                    processed = taskManager.process(now);\n-\n-                    if (processed > 0) {\n-                        // It makes no difference to the outcome of these metrics when we record \"0\",\n-                        // so we can just avoid the method call when we didn't process anything.\n-                        processRateSensor.record(processed, now);\n-\n-                        // This metric is scaled to represent the _average_ processing time of _each_\n-                        // task. Note, it's hard to interpret this as defined, but we would need a KIP\n-                        // to change it to simply report the overall time spent processing all tasks.\n-                        final long processLatency = advanceNowAndComputeLatency();\n-                        processLatencySensor.record(processLatency / (double) processed, now);\n-\n-                        // commit any tasks that have requested a commit\n-                        final int committed = taskManager.maybeCommitActiveTasksPerUserRequested();\n-\n-                        if (committed > 0) {\n-                            final long commitLatency = advanceNowAndComputeLatency();\n-                            commitSensor.record(commitLatency / (double) committed, now);\n-                        }\n-                    } else {\n-                        // if there is no records to be processed, exit immediately\n-                        break;\n-                    }\n+                final int processed = taskManager.process(numIterations, now);\n+                if (processed > 0) {\n+                    // It makes no difference to the outcome of these metrics when we record \"0\",\n+                    // so we can just avoid the method call when we didn't process anything.\n+                    processRateSensor.record(processed, now);\n+\n+                    // This metric is scaled to represent the _average_ processing time of _each_\n+                    // task. Note, it's hard to interpret this as defined, but we would need a KIP\n+                    // to change it to simply report the overall time spent processing all tasks.\n+                    final long processLatency = advanceNowAndComputeLatency();\n+                    processLatencySensor.record(processLatency / (double) processed, now);\n+                    totalProcessLatency += processLatency;\n+                }\n+\n+                final int punctuated = taskManager.punctuate();\n+                if (punctuated > 0) {\n+                    final long punctuateLatency = advanceNowAndComputeLatency();\n+                    punctuateSensor.record(punctuateLatency / (double) punctuated, now);\n+                    totalPunctuateLatency += punctuateLatency;\n                 }\n \n-                timeSinceLastPoll = Math.max(now - lastPollMs, 0);\n+                final int committed = maybeCommit();\n+                if (committed > 0) {\n+                    final long commitLatency = advanceNowAndComputeLatency();\n+                    commitSensor.record(commitLatency / (double) committed, now);\n \n-                if (maybePunctuate() || maybeCommit()) {\n-                    numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n-                } else if (timeSinceLastPoll > maxPollTimeMs / 2) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Committed all active tasks {} and standby tasks {} in {}ms\",\n+                            taskManager.activeTaskIds(), taskManager.standbyTaskIds(), commitLatency);\n+                    }\n+\n+                    totalCommitLatency += commitLatency;\n+                }\n+\n+                if (processed == 0) {\n+                    // if there is no records to be processed, exit after punctuate / commit\n+                    break;\n+                } else if (Math.max(now - lastPollMs, 0) > maxPollTimeMs / 2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365"}, "originalPosition": 151}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMTgxMDI3", "url": "https://github.com/apache/kafka/pull/8358#pullrequestreview-382181027", "createdAt": "2020-03-26T16:23:56Z", "commit": {"oid": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNjoyMzo1N1rOF8POFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNjoyMzo1N1rOF8POFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODcwODI0Nw==", "bodyText": "Note I did not record sensor  for restoration; it is intentional since we will be moving that out of the thread here. Atm the restoration ratio can be inferred by 100% - other four.", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398708247", "createdAt": "2020-03-26T16:23:57Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -623,63 +642,75 @@ void runOnce() {\n         // if there's no active restoring or standby updating it would not try to fetch any data\n         changelogReader.restore();\n \n-        advanceNowAndComputeLatency();\n+        final long restoreLatency = advanceNowAndComputeLatency();\n \n+        long totalCommitLatency = 0L;\n+        long totalProcessLatency = 0L;\n+        long totalPunctuateLatency = 0L;\n         if (state == State.RUNNING) {\n             /*\n-             * Within an iteration, after N (N initialized as 1 upon start up) round of processing one-record-each on the applicable tasks, check the current time:\n-             *  1. If it is time to commit, do it;\n-             *  2. If it is time to punctuate, do it;\n-             *  3. If elapsed time is close to consumer's max.poll.interval.ms, end the current iteration immediately.\n-             *  4. If none of the the above happens, increment N.\n-             *  5. If one of the above happens, half the value of N.\n+             * Within an iteration, after processing up to N (N initialized as 1 upon start up) records for each applicable tasks, check the current time:\n+             *  1. If it is time to punctuate, do it;\n+             *  2. If it is time to commit, do it, this should be after 1) since punctuate may trigger commit;\n+             *  3. If there's no records processed, end the current iteration immediately;\n+             *  4. If we are close to consumer's next poll deadline, end the current iteration immediately;\n+             *  5. If any of 1), 2) and 4) happens, half N for next iteration;\n+             *  6. Otherwise, increment N.\n              */\n-            int processed = 0;\n-            long timeSinceLastPoll;\n-\n             do {\n-                for (int i = 0; i < numIterations; i++) {\n-                    advanceNowAndComputeLatency();\n-                    processed = taskManager.process(now);\n-\n-                    if (processed > 0) {\n-                        // It makes no difference to the outcome of these metrics when we record \"0\",\n-                        // so we can just avoid the method call when we didn't process anything.\n-                        processRateSensor.record(processed, now);\n-\n-                        // This metric is scaled to represent the _average_ processing time of _each_\n-                        // task. Note, it's hard to interpret this as defined, but we would need a KIP\n-                        // to change it to simply report the overall time spent processing all tasks.\n-                        final long processLatency = advanceNowAndComputeLatency();\n-                        processLatencySensor.record(processLatency / (double) processed, now);\n-\n-                        // commit any tasks that have requested a commit\n-                        final int committed = taskManager.maybeCommitActiveTasksPerUserRequested();\n-\n-                        if (committed > 0) {\n-                            final long commitLatency = advanceNowAndComputeLatency();\n-                            commitSensor.record(commitLatency / (double) committed, now);\n-                        }\n-                    } else {\n-                        // if there is no records to be processed, exit immediately\n-                        break;\n-                    }\n+                final int processed = taskManager.process(numIterations, now);\n+                if (processed > 0) {\n+                    // It makes no difference to the outcome of these metrics when we record \"0\",\n+                    // so we can just avoid the method call when we didn't process anything.\n+                    processRateSensor.record(processed, now);\n+\n+                    // This metric is scaled to represent the _average_ processing time of _each_\n+                    // task. Note, it's hard to interpret this as defined, but we would need a KIP\n+                    // to change it to simply report the overall time spent processing all tasks.\n+                    final long processLatency = advanceNowAndComputeLatency();\n+                    processLatencySensor.record(processLatency / (double) processed, now);\n+                    totalProcessLatency += processLatency;\n+                }\n+\n+                final int punctuated = taskManager.punctuate();\n+                if (punctuated > 0) {\n+                    final long punctuateLatency = advanceNowAndComputeLatency();\n+                    punctuateSensor.record(punctuateLatency / (double) punctuated, now);\n+                    totalPunctuateLatency += punctuateLatency;\n                 }\n \n-                timeSinceLastPoll = Math.max(now - lastPollMs, 0);\n+                final int committed = maybeCommit();\n+                if (committed > 0) {\n+                    final long commitLatency = advanceNowAndComputeLatency();\n+                    commitSensor.record(commitLatency / (double) committed, now);\n \n-                if (maybePunctuate() || maybeCommit()) {\n-                    numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n-                } else if (timeSinceLastPoll > maxPollTimeMs / 2) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Committed all active tasks {} and standby tasks {} in {}ms\",\n+                            taskManager.activeTaskIds(), taskManager.standbyTaskIds(), commitLatency);\n+                    }\n+\n+                    totalCommitLatency += commitLatency;\n+                }\n+\n+                if (processed == 0) {\n+                    // if there is no records to be processed, exit after punctuate / commit\n+                    break;\n+                } else if (Math.max(now - lastPollMs, 0) > maxPollTimeMs / 2) {\n                     numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n                     break;\n-                } else if (processed > 0) {\n+                } else if (punctuated > 0 || committed > 0) {\n+                    numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n+                } else {\n                     numIterations++;\n                 }\n-            } while (processed > 0);\n-\n-            maybeCommit();\n+            } while (true);\n         }\n+\n+        final long runOnceLatency = pollLatency + restoreLatency + totalCommitLatency + totalProcessLatency + totalPunctuateLatency;\n+        processRatioSensor.record((double) totalProcessLatency / runOnceLatency);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365"}, "originalPosition": 167}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2982363abcca81fbd64a0b9835ec28b619da1a9", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/b2982363abcca81fbd64a0b9835ec28b619da1a9", "committedDate": "2020-03-26T17:28:50Z", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into K9756-loop-tasks-order"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "153b7417674c9bdc6d4b0aaf9f5684c1a646ff11", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/153b7417674c9bdc6d4b0aaf9f5684c1a646ff11", "committedDate": "2020-03-26T19:07:16Z", "message": "should be INFO"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMjg2NTEw", "url": "https://github.com/apache/kafka/pull/8358#pullrequestreview-382286510", "createdAt": "2020-03-26T18:17:31Z", "commit": {"oid": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxODoxNzozMVrOF8UULQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMTowODo1M1rOF8akSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc5MTcyNQ==", "bodyText": "Just to be sure it's not sliding by unnoticed, there may be some overhead in the taskManager.process call. When we do process some records (process > 0), this overhead is counted in totalProcessLatency, but when we didn't process records (process == 0), the overhead gets counted in totalPunctuateLatency. The \"solution\" would be to move final long processLatency = advanceNowAndComputeLatency(); and totalProcessLatency += processLatency; to immediately after the taskManager.process (i.e., unconditionally account for time spent), although the processLatencySensor recording needs to remain conditional.\nAlso, note there are knock-on implications to this question, since there also may be overhead to punctuate, and if punctuated <= 0, then we also don't account the time for that, and so forth with commit.", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398791725", "createdAt": "2020-03-26T18:17:31Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -623,63 +642,75 @@ void runOnce() {\n         // if there's no active restoring or standby updating it would not try to fetch any data\n         changelogReader.restore();\n \n-        advanceNowAndComputeLatency();\n+        final long restoreLatency = advanceNowAndComputeLatency();\n \n+        long totalCommitLatency = 0L;\n+        long totalProcessLatency = 0L;\n+        long totalPunctuateLatency = 0L;\n         if (state == State.RUNNING) {\n             /*\n-             * Within an iteration, after N (N initialized as 1 upon start up) round of processing one-record-each on the applicable tasks, check the current time:\n-             *  1. If it is time to commit, do it;\n-             *  2. If it is time to punctuate, do it;\n-             *  3. If elapsed time is close to consumer's max.poll.interval.ms, end the current iteration immediately.\n-             *  4. If none of the the above happens, increment N.\n-             *  5. If one of the above happens, half the value of N.\n+             * Within an iteration, after processing up to N (N initialized as 1 upon start up) records for each applicable tasks, check the current time:\n+             *  1. If it is time to punctuate, do it;\n+             *  2. If it is time to commit, do it, this should be after 1) since punctuate may trigger commit;\n+             *  3. If there's no records processed, end the current iteration immediately;\n+             *  4. If we are close to consumer's next poll deadline, end the current iteration immediately;\n+             *  5. If any of 1), 2) and 4) happens, half N for next iteration;\n+             *  6. Otherwise, increment N.\n              */\n-            int processed = 0;\n-            long timeSinceLastPoll;\n-\n             do {\n-                for (int i = 0; i < numIterations; i++) {\n-                    advanceNowAndComputeLatency();\n-                    processed = taskManager.process(now);\n-\n-                    if (processed > 0) {\n-                        // It makes no difference to the outcome of these metrics when we record \"0\",\n-                        // so we can just avoid the method call when we didn't process anything.\n-                        processRateSensor.record(processed, now);\n-\n-                        // This metric is scaled to represent the _average_ processing time of _each_\n-                        // task. Note, it's hard to interpret this as defined, but we would need a KIP\n-                        // to change it to simply report the overall time spent processing all tasks.\n-                        final long processLatency = advanceNowAndComputeLatency();\n-                        processLatencySensor.record(processLatency / (double) processed, now);\n-\n-                        // commit any tasks that have requested a commit\n-                        final int committed = taskManager.maybeCommitActiveTasksPerUserRequested();\n-\n-                        if (committed > 0) {\n-                            final long commitLatency = advanceNowAndComputeLatency();\n-                            commitSensor.record(commitLatency / (double) committed, now);\n-                        }\n-                    } else {\n-                        // if there is no records to be processed, exit immediately\n-                        break;\n-                    }\n+                final int processed = taskManager.process(numIterations, now);\n+                if (processed > 0) {\n+                    // It makes no difference to the outcome of these metrics when we record \"0\",\n+                    // so we can just avoid the method call when we didn't process anything.\n+                    processRateSensor.record(processed, now);\n+\n+                    // This metric is scaled to represent the _average_ processing time of _each_\n+                    // task. Note, it's hard to interpret this as defined, but we would need a KIP\n+                    // to change it to simply report the overall time spent processing all tasks.\n+                    final long processLatency = advanceNowAndComputeLatency();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc5Mzk0MQ==", "bodyText": "Now I'm wondering... why would a user request a commit?", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398793941", "createdAt": "2020-03-26T18:21:06Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -623,63 +642,75 @@ void runOnce() {\n         // if there's no active restoring or standby updating it would not try to fetch any data\n         changelogReader.restore();\n \n-        advanceNowAndComputeLatency();\n+        final long restoreLatency = advanceNowAndComputeLatency();\n \n+        long totalCommitLatency = 0L;\n+        long totalProcessLatency = 0L;\n+        long totalPunctuateLatency = 0L;\n         if (state == State.RUNNING) {\n             /*\n-             * Within an iteration, after N (N initialized as 1 upon start up) round of processing one-record-each on the applicable tasks, check the current time:\n-             *  1. If it is time to commit, do it;\n-             *  2. If it is time to punctuate, do it;\n-             *  3. If elapsed time is close to consumer's max.poll.interval.ms, end the current iteration immediately.\n-             *  4. If none of the the above happens, increment N.\n-             *  5. If one of the above happens, half the value of N.\n+             * Within an iteration, after processing up to N (N initialized as 1 upon start up) records for each applicable tasks, check the current time:\n+             *  1. If it is time to punctuate, do it;\n+             *  2. If it is time to commit, do it, this should be after 1) since punctuate may trigger commit;\n+             *  3. If there's no records processed, end the current iteration immediately;\n+             *  4. If we are close to consumer's next poll deadline, end the current iteration immediately;\n+             *  5. If any of 1), 2) and 4) happens, half N for next iteration;\n+             *  6. Otherwise, increment N.\n              */\n-            int processed = 0;\n-            long timeSinceLastPoll;\n-\n             do {\n-                for (int i = 0; i < numIterations; i++) {\n-                    advanceNowAndComputeLatency();\n-                    processed = taskManager.process(now);\n-\n-                    if (processed > 0) {\n-                        // It makes no difference to the outcome of these metrics when we record \"0\",\n-                        // so we can just avoid the method call when we didn't process anything.\n-                        processRateSensor.record(processed, now);\n-\n-                        // This metric is scaled to represent the _average_ processing time of _each_\n-                        // task. Note, it's hard to interpret this as defined, but we would need a KIP\n-                        // to change it to simply report the overall time spent processing all tasks.\n-                        final long processLatency = advanceNowAndComputeLatency();\n-                        processLatencySensor.record(processLatency / (double) processed, now);\n-\n-                        // commit any tasks that have requested a commit\n-                        final int committed = taskManager.maybeCommitActiveTasksPerUserRequested();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI1OTc3Mw=="}, "originalCommit": {"oid": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg2ODcyNQ==", "bodyText": "Not sure about this. I think the motivation is reasonable, if we're going to change the metric, then it creates unnecessary thrashing to introduce it here.\nOTOH, even if we move restoration to another thread, that thread will still have a name, so the metric name itself wouldn't actually change, just the value of the thread name, which changes between every instance run anyway.", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398868725", "createdAt": "2020-03-26T20:25:27Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -623,63 +642,75 @@ void runOnce() {\n         // if there's no active restoring or standby updating it would not try to fetch any data\n         changelogReader.restore();\n \n-        advanceNowAndComputeLatency();\n+        final long restoreLatency = advanceNowAndComputeLatency();\n \n+        long totalCommitLatency = 0L;\n+        long totalProcessLatency = 0L;\n+        long totalPunctuateLatency = 0L;\n         if (state == State.RUNNING) {\n             /*\n-             * Within an iteration, after N (N initialized as 1 upon start up) round of processing one-record-each on the applicable tasks, check the current time:\n-             *  1. If it is time to commit, do it;\n-             *  2. If it is time to punctuate, do it;\n-             *  3. If elapsed time is close to consumer's max.poll.interval.ms, end the current iteration immediately.\n-             *  4. If none of the the above happens, increment N.\n-             *  5. If one of the above happens, half the value of N.\n+             * Within an iteration, after processing up to N (N initialized as 1 upon start up) records for each applicable tasks, check the current time:\n+             *  1. If it is time to punctuate, do it;\n+             *  2. If it is time to commit, do it, this should be after 1) since punctuate may trigger commit;\n+             *  3. If there's no records processed, end the current iteration immediately;\n+             *  4. If we are close to consumer's next poll deadline, end the current iteration immediately;\n+             *  5. If any of 1), 2) and 4) happens, half N for next iteration;\n+             *  6. Otherwise, increment N.\n              */\n-            int processed = 0;\n-            long timeSinceLastPoll;\n-\n             do {\n-                for (int i = 0; i < numIterations; i++) {\n-                    advanceNowAndComputeLatency();\n-                    processed = taskManager.process(now);\n-\n-                    if (processed > 0) {\n-                        // It makes no difference to the outcome of these metrics when we record \"0\",\n-                        // so we can just avoid the method call when we didn't process anything.\n-                        processRateSensor.record(processed, now);\n-\n-                        // This metric is scaled to represent the _average_ processing time of _each_\n-                        // task. Note, it's hard to interpret this as defined, but we would need a KIP\n-                        // to change it to simply report the overall time spent processing all tasks.\n-                        final long processLatency = advanceNowAndComputeLatency();\n-                        processLatencySensor.record(processLatency / (double) processed, now);\n-\n-                        // commit any tasks that have requested a commit\n-                        final int committed = taskManager.maybeCommitActiveTasksPerUserRequested();\n-\n-                        if (committed > 0) {\n-                            final long commitLatency = advanceNowAndComputeLatency();\n-                            commitSensor.record(commitLatency / (double) committed, now);\n-                        }\n-                    } else {\n-                        // if there is no records to be processed, exit immediately\n-                        break;\n-                    }\n+                final int processed = taskManager.process(numIterations, now);\n+                if (processed > 0) {\n+                    // It makes no difference to the outcome of these metrics when we record \"0\",\n+                    // so we can just avoid the method call when we didn't process anything.\n+                    processRateSensor.record(processed, now);\n+\n+                    // This metric is scaled to represent the _average_ processing time of _each_\n+                    // task. Note, it's hard to interpret this as defined, but we would need a KIP\n+                    // to change it to simply report the overall time spent processing all tasks.\n+                    final long processLatency = advanceNowAndComputeLatency();\n+                    processLatencySensor.record(processLatency / (double) processed, now);\n+                    totalProcessLatency += processLatency;\n+                }\n+\n+                final int punctuated = taskManager.punctuate();\n+                if (punctuated > 0) {\n+                    final long punctuateLatency = advanceNowAndComputeLatency();\n+                    punctuateSensor.record(punctuateLatency / (double) punctuated, now);\n+                    totalPunctuateLatency += punctuateLatency;\n                 }\n \n-                timeSinceLastPoll = Math.max(now - lastPollMs, 0);\n+                final int committed = maybeCommit();\n+                if (committed > 0) {\n+                    final long commitLatency = advanceNowAndComputeLatency();\n+                    commitSensor.record(commitLatency / (double) committed, now);\n \n-                if (maybePunctuate() || maybeCommit()) {\n-                    numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n-                } else if (timeSinceLastPoll > maxPollTimeMs / 2) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Committed all active tasks {} and standby tasks {} in {}ms\",\n+                            taskManager.activeTaskIds(), taskManager.standbyTaskIds(), commitLatency);\n+                    }\n+\n+                    totalCommitLatency += commitLatency;\n+                }\n+\n+                if (processed == 0) {\n+                    // if there is no records to be processed, exit after punctuate / commit\n+                    break;\n+                } else if (Math.max(now - lastPollMs, 0) > maxPollTimeMs / 2) {\n                     numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n                     break;\n-                } else if (processed > 0) {\n+                } else if (punctuated > 0 || committed > 0) {\n+                    numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n+                } else {\n                     numIterations++;\n                 }\n-            } while (processed > 0);\n-\n-            maybeCommit();\n+            } while (true);\n         }\n+\n+        final long runOnceLatency = pollLatency + restoreLatency + totalCommitLatency + totalProcessLatency + totalPunctuateLatency;\n+        processRatioSensor.record((double) totalProcessLatency / runOnceLatency);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODcwODI0Nw=="}, "originalCommit": {"oid": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4MjI4Mg==", "bodyText": "Can you elaborate on the need for this? Sensor#record already checks shouldRecord before doing anything. It's also already a no-op if you have nothing registered and no parents, although it does incur synchronization overhead in that case. However, it seems like that synchronization is necessary in the current Sensor implementation.", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398882282", "createdAt": "2020-03-26T20:48:51Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "diffHunk": "@@ -807,6 +807,12 @@ public static void maybeMeasureLatency(final Runnable actionToMeasure,\n         }\n     }\n \n+    public static void maybeMeasureLatency(final double elapsedNs, final Sensor sensor) {\n+        if (sensor.shouldRecord() && sensor.hasMetrics()) {\n+            sensor.record(elapsedNs);\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4Mzc4Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \"The fraction of time stream thread is spending on processing active tasks.\";\n          \n          \n            \n                    \"The fraction of time the thread spent on processing active tasks.\";\n          \n      \n    \n    \n  \n\n(also applies to the others)", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398883783", "createdAt": "2020-03-26T20:51:42Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/ThreadMetrics.java", "diffHunk": "@@ -83,6 +86,14 @@ private ThreadMetrics() {}\n         \"The average commit latency over all tasks assigned to one stream thread\";\n     private static final String COMMIT_OVER_TASKS_MAX_LATENCY_DESCRIPTION =\n         \"The maximum commit latency over all tasks assigned to one stream thread\";\n+    private static final String PROCESS_RATIO_DESCRIPTION =\n+        \"The fraction of time stream thread is spending on processing active tasks.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg4NDU5Nw==", "bodyText": "I'm suspicious of summing the various latencies, rather than just measuring the time from the start of the method until now, since it would hide any unexpected sources of overhead.", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398884597", "createdAt": "2020-03-26T20:53:13Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamThread.java", "diffHunk": "@@ -623,63 +642,75 @@ void runOnce() {\n         // if there's no active restoring or standby updating it would not try to fetch any data\n         changelogReader.restore();\n \n-        advanceNowAndComputeLatency();\n+        final long restoreLatency = advanceNowAndComputeLatency();\n \n+        long totalCommitLatency = 0L;\n+        long totalProcessLatency = 0L;\n+        long totalPunctuateLatency = 0L;\n         if (state == State.RUNNING) {\n             /*\n-             * Within an iteration, after N (N initialized as 1 upon start up) round of processing one-record-each on the applicable tasks, check the current time:\n-             *  1. If it is time to commit, do it;\n-             *  2. If it is time to punctuate, do it;\n-             *  3. If elapsed time is close to consumer's max.poll.interval.ms, end the current iteration immediately.\n-             *  4. If none of the the above happens, increment N.\n-             *  5. If one of the above happens, half the value of N.\n+             * Within an iteration, after processing up to N (N initialized as 1 upon start up) records for each applicable tasks, check the current time:\n+             *  1. If it is time to punctuate, do it;\n+             *  2. If it is time to commit, do it, this should be after 1) since punctuate may trigger commit;\n+             *  3. If there's no records processed, end the current iteration immediately;\n+             *  4. If we are close to consumer's next poll deadline, end the current iteration immediately;\n+             *  5. If any of 1), 2) and 4) happens, half N for next iteration;\n+             *  6. Otherwise, increment N.\n              */\n-            int processed = 0;\n-            long timeSinceLastPoll;\n-\n             do {\n-                for (int i = 0; i < numIterations; i++) {\n-                    advanceNowAndComputeLatency();\n-                    processed = taskManager.process(now);\n-\n-                    if (processed > 0) {\n-                        // It makes no difference to the outcome of these metrics when we record \"0\",\n-                        // so we can just avoid the method call when we didn't process anything.\n-                        processRateSensor.record(processed, now);\n-\n-                        // This metric is scaled to represent the _average_ processing time of _each_\n-                        // task. Note, it's hard to interpret this as defined, but we would need a KIP\n-                        // to change it to simply report the overall time spent processing all tasks.\n-                        final long processLatency = advanceNowAndComputeLatency();\n-                        processLatencySensor.record(processLatency / (double) processed, now);\n-\n-                        // commit any tasks that have requested a commit\n-                        final int committed = taskManager.maybeCommitActiveTasksPerUserRequested();\n-\n-                        if (committed > 0) {\n-                            final long commitLatency = advanceNowAndComputeLatency();\n-                            commitSensor.record(commitLatency / (double) committed, now);\n-                        }\n-                    } else {\n-                        // if there is no records to be processed, exit immediately\n-                        break;\n-                    }\n+                final int processed = taskManager.process(numIterations, now);\n+                if (processed > 0) {\n+                    // It makes no difference to the outcome of these metrics when we record \"0\",\n+                    // so we can just avoid the method call when we didn't process anything.\n+                    processRateSensor.record(processed, now);\n+\n+                    // This metric is scaled to represent the _average_ processing time of _each_\n+                    // task. Note, it's hard to interpret this as defined, but we would need a KIP\n+                    // to change it to simply report the overall time spent processing all tasks.\n+                    final long processLatency = advanceNowAndComputeLatency();\n+                    processLatencySensor.record(processLatency / (double) processed, now);\n+                    totalProcessLatency += processLatency;\n+                }\n+\n+                final int punctuated = taskManager.punctuate();\n+                if (punctuated > 0) {\n+                    final long punctuateLatency = advanceNowAndComputeLatency();\n+                    punctuateSensor.record(punctuateLatency / (double) punctuated, now);\n+                    totalPunctuateLatency += punctuateLatency;\n                 }\n \n-                timeSinceLastPoll = Math.max(now - lastPollMs, 0);\n+                final int committed = maybeCommit();\n+                if (committed > 0) {\n+                    final long commitLatency = advanceNowAndComputeLatency();\n+                    commitSensor.record(commitLatency / (double) committed, now);\n \n-                if (maybePunctuate() || maybeCommit()) {\n-                    numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n-                } else if (timeSinceLastPoll > maxPollTimeMs / 2) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Committed all active tasks {} and standby tasks {} in {}ms\",\n+                            taskManager.activeTaskIds(), taskManager.standbyTaskIds(), commitLatency);\n+                    }\n+\n+                    totalCommitLatency += commitLatency;\n+                }\n+\n+                if (processed == 0) {\n+                    // if there is no records to be processed, exit after punctuate / commit\n+                    break;\n+                } else if (Math.max(now - lastPollMs, 0) > maxPollTimeMs / 2) {\n                     numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n                     break;\n-                } else if (processed > 0) {\n+                } else if (punctuated > 0 || committed > 0) {\n+                    numIterations = numIterations > 1 ? numIterations / 2 : numIterations;\n+                } else {\n                     numIterations++;\n                 }\n-            } while (processed > 0);\n-\n-            maybeCommit();\n+            } while (true);\n         }\n+\n+        final long runOnceLatency = pollLatency + restoreLatency + totalCommitLatency + totalProcessLatency + totalPunctuateLatency;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg5NDE1Mw==", "bodyText": "Not sure if there's a better way to put it, but I was a little surprised to see \"we would stop early\". I guess it didn't even occur to me that the task manager would block or something if there's no records to process.", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398894153", "createdAt": "2020-03-26T21:08:53Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -1804,25 +1805,52 @@ public void shouldMaybeCommitAllActiveTasksThatNeedCommit() {\n     @Test\n     public void shouldProcessActiveTasks() {\n         final StateMachineTask task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n+        final StateMachineTask task01 = new StateMachineTask(taskId01, taskId01Partitions, true);\n+\n+        final Map<TaskId, Set<TopicPartition>> assignment = new HashMap<>();\n+        assignment.put(taskId00, taskId00Partitions);\n+        assignment.put(taskId01, taskId01Partitions);\n \n         expectRestoreToBeCompleted(consumer, changeLogReader);\n-        expect(activeTaskCreator.createTasks(anyObject(), eq(taskId00Assignment)))\n-            .andReturn(singletonList(task00)).anyTimes();\n+        expect(activeTaskCreator.createTasks(anyObject(), eq(assignment)))\n+            .andReturn(Arrays.asList(task00, task01)).anyTimes();\n \n         replay(activeTaskCreator, consumer, changeLogReader);\n \n-        taskManager.handleAssignment(taskId00Assignment, emptyMap());\n+        taskManager.handleAssignment(assignment, emptyMap());\n         assertThat(taskManager.tryToCompleteRestoration(), is(true));\n \n         assertThat(task00.state(), is(Task.State.RUNNING));\n+        assertThat(task01.state(), is(Task.State.RUNNING));\n \n-        final TopicPartition partition = taskId00Partitions.iterator().next();\n         task00.addRecords(\n-            partition,\n-            singletonList(new ConsumerRecord<>(partition.topic(), partition.partition(), 0L, null, null))\n+            t1p0,\n+            Arrays.asList(\n+                getConsumerRecord(t1p0, 0L),\n+                getConsumerRecord(t1p0, 1L),\n+                getConsumerRecord(t1p0, 2L),\n+                getConsumerRecord(t1p0, 3L),\n+                getConsumerRecord(t1p0, 4L),\n+                getConsumerRecord(t1p0, 5L)\n+            )\n         );\n+        task01.addRecords(\n+            t1p1,\n+            Arrays.asList(\n+                getConsumerRecord(t1p1, 0L),\n+                getConsumerRecord(t1p1, 1L),\n+                getConsumerRecord(t1p1, 2L),\n+                getConsumerRecord(t1p1, 3L),\n+                getConsumerRecord(t1p1, 4L)\n+            )\n+        );\n+\n+        // check that we should be processing at most max num records\n+        assertThat(taskManager.process(3, 0L), is(6));\n \n-        assertThat(taskManager.process(0L), is(1));\n+        // check that if there's no records proccssible, we would stop early", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5c743baa264f5cc9ea6c9f48aed24cb8ab72365"}, "originalPosition": 62}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7431c1ab6aa5182e734d70f51b38b53b469e3081", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/7431c1ab6aa5182e734d70f51b38b53b469e3081", "committedDate": "2020-03-26T23:12:59Z", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into K9756-loop-tasks-order"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0286037701fdc8a2993a9953549974baa8f22b85", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/0286037701fdc8a2993a9953549974baa8f22b85", "committedDate": "2020-03-26T23:39:50Z", "message": "github comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyNDkyODY1", "url": "https://github.com/apache/kafka/pull/8358#pullrequestreview-382492865", "createdAt": "2020-03-26T23:40:34Z", "commit": {"oid": "0286037701fdc8a2993a9953549974baa8f22b85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMzo0MDozNFrOF8eTZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMzo0MDozNFrOF8eTZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1NTM2Nw==", "bodyText": "Just realized it should be INFO not DEBUG.", "url": "https://github.com/apache/kafka/pull/8358#discussion_r398955367", "createdAt": "2020-03-26T23:40:34Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/ThreadMetrics.java", "diffHunk": "@@ -220,6 +231,70 @@ public static Sensor commitOverTasksSensor(final String threadId,\n         return commitOverTasksSensor;\n     }\n \n+    public static Sensor processRatioSensor(final String threadId,\n+                                            final StreamsMetricsImpl streamsMetrics) {\n+        final Sensor sensor =\n+            streamsMetrics.threadLevelSensor(threadId, PROCESS + RATIO_SUFFIX, Sensor.RecordingLevel.INFO);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0286037701fdc8a2993a9953549974baa8f22b85"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyNTY3OTM4", "url": "https://github.com/apache/kafka/pull/8358#pullrequestreview-382567938", "createdAt": "2020-03-27T04:04:44Z", "commit": {"oid": "0286037701fdc8a2993a9953549974baa8f22b85"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "990ec8a34eb22dd13b0120c288f4161007f6ae46", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/990ec8a34eb22dd13b0120c288f4161007f6ae46", "committedDate": "2020-03-27T05:51:28Z", "message": "minor fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MTk2OTY4", "url": "https://github.com/apache/kafka/pull/8358#pullrequestreview-384196968", "createdAt": "2020-03-30T20:17:08Z", "commit": {"oid": "990ec8a34eb22dd13b0120c288f4161007f6ae46"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMDoxNzowOFrOF96kmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMDoxNzowOFrOF96kmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ2NzA5OA==", "bodyText": "Could you please add unit tests for the new sensors and metrics?", "url": "https://github.com/apache/kafka/pull/8358#discussion_r400467098", "createdAt": "2020-03-30T20:17:08Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/ThreadMetrics.java", "diffHunk": "@@ -220,6 +231,70 @@ public static Sensor commitOverTasksSensor(final String threadId,\n         return commitOverTasksSensor;\n     }\n \n+    public static Sensor processRatioSensor(final String threadId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "990ec8a34eb22dd13b0120c288f4161007f6ae46"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1678, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}