{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyMTA3Mzkw", "number": 9332, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwNjoxNTo1MFrOEm45QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwNjoxOTowMFrOEm48FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MjEzNTA0OnYy", "diffSide": "RIGHT", "path": "raft/src/test/java/org/apache/kafka/raft/MockLog.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwNjoxNTo1MFrOHXLLDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNzozNjowMlrOHXlidw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA2MjM0OQ==", "bodyText": "So the idea is to wipe out the older epoch (as epoch - 1)'s end offset, and the search for (epoch - 1) would give (epoch - 2) end offset? In the case where we put leader change message in mock log, this should never happen right?", "url": "https://github.com/apache/kafka/pull/9332#discussion_r494062349", "createdAt": "2020-09-24T06:15:50Z", "author": {"login": "abbccdda"}, "path": "raft/src/test/java/org/apache/kafka/raft/MockLog.java", "diffHunk": "@@ -310,10 +310,10 @@ public LogFetchInfo read(long startOffset, Isolation isolation) {\n     }\n \n     @Override\n-    public void assignEpochStartOffset(int epoch, long startOffset) {\n-        if (startOffset != endOffset().offset)\n-            throw new IllegalArgumentException(\n-                \"Can only assign epoch for the end offset \" + endOffset().offset + \", but get offset \" + startOffset);\n+    public void initializeLeaderEpoch(int epoch) {\n+        long startOffset = endOffset().offset;\n+        epochStartOffsets.removeIf(epochStartOffset ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14e0cab5e335b2619d8f17c999aac6a1c648b465"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5NDMyNw==", "bodyText": "There's no guarantee that the leader change message ever gets committed. It is even possible for the leadership to change multiple times before a leader change message can be committed. There is no correctness problem with the current implementation. I just wanted the behavior to be consistent with LeaderEpochFileCache.", "url": "https://github.com/apache/kafka/pull/9332#discussion_r494494327", "createdAt": "2020-09-24T17:36:02Z", "author": {"login": "hachikuji"}, "path": "raft/src/test/java/org/apache/kafka/raft/MockLog.java", "diffHunk": "@@ -310,10 +310,10 @@ public LogFetchInfo read(long startOffset, Isolation isolation) {\n     }\n \n     @Override\n-    public void assignEpochStartOffset(int epoch, long startOffset) {\n-        if (startOffset != endOffset().offset)\n-            throw new IllegalArgumentException(\n-                \"Can only assign epoch for the end offset \" + endOffset().offset + \", but get offset \" + startOffset);\n+    public void initializeLeaderEpoch(int epoch) {\n+        long startOffset = endOffset().offset;\n+        epochStartOffsets.removeIf(epochStartOffset ->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA2MjM0OQ=="}, "originalCommit": {"oid": "14e0cab5e335b2619d8f17c999aac6a1c648b465"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MjEzNzA3OnYy", "diffSide": "RIGHT", "path": "raft/src/test/java/org/apache/kafka/raft/MockLogTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwNjoxNjo0NlrOHXLMVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNzozNjo1MVrOHXlkTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA2MjY3Ng==", "bodyText": "I thought this is a test for end offset?", "url": "https://github.com/apache/kafka/pull/9332#discussion_r494062676", "createdAt": "2020-09-24T06:16:46Z", "author": {"login": "abbccdda"}, "path": "raft/src/test/java/org/apache/kafka/raft/MockLogTest.java", "diffHunk": "@@ -370,6 +365,23 @@ public void testReadOutOfRangeOffset() {\n             Isolation.UNCOMMITTED));\n     }\n \n+    @Test\n+    public void testMonotonicEpochStartOffset() {\n+        appendBatch(5, 1);\n+        assertEquals(5L, log.endOffset().offset);\n+\n+        log.initializeLeaderEpoch(2);\n+        assertEquals(Optional.of(new OffsetAndEpoch(5L, 1)), log.endOffsetForEpoch(1));\n+        assertEquals(Optional.of(new OffsetAndEpoch(5L, 2)), log.endOffsetForEpoch(2));\n+\n+        // Initialize a new epoch at the same end offset. The epoch cache ensures\n+        // that the start offset of each retained epoch increases monotonically.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14e0cab5e335b2619d8f17c999aac6a1c648b465"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5NDc5Nw==", "bodyText": "The epoch cache tracks tuples of (epoch, start offset). The start offset of a new leader epoch is the current log end offset.", "url": "https://github.com/apache/kafka/pull/9332#discussion_r494494797", "createdAt": "2020-09-24T17:36:51Z", "author": {"login": "hachikuji"}, "path": "raft/src/test/java/org/apache/kafka/raft/MockLogTest.java", "diffHunk": "@@ -370,6 +365,23 @@ public void testReadOutOfRangeOffset() {\n             Isolation.UNCOMMITTED));\n     }\n \n+    @Test\n+    public void testMonotonicEpochStartOffset() {\n+        appendBatch(5, 1);\n+        assertEquals(5L, log.endOffset().offset);\n+\n+        log.initializeLeaderEpoch(2);\n+        assertEquals(Optional.of(new OffsetAndEpoch(5L, 1)), log.endOffsetForEpoch(1));\n+        assertEquals(Optional.of(new OffsetAndEpoch(5L, 2)), log.endOffsetForEpoch(2));\n+\n+        // Initialize a new epoch at the same end offset. The epoch cache ensures\n+        // that the start offset of each retained epoch increases monotonically.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA2MjY3Ng=="}, "originalCommit": {"oid": "14e0cab5e335b2619d8f17c999aac6a1c648b465"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MjE0MjI4OnYy", "diffSide": "LEFT", "path": "raft/src/test/java/org/apache/kafka/raft/RaftEventSimulationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQwNjoxOTowMFrOHXLPfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxNzo0MzozN1rOHXlztQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA2MzQ4NA==", "bodyText": "So the reason that this is safe is because we no longer try assigning offset other than the end offset?", "url": "https://github.com/apache/kafka/pull/9332#discussion_r494063484", "createdAt": "2020-09-24T06:19:00Z", "author": {"login": "abbccdda"}, "path": "raft/src/test/java/org/apache/kafka/raft/RaftEventSimulationTest.java", "diffHunk": "@@ -712,11 +712,6 @@ void initializeElection(ElectionState election) {\n \n             nodes.values().forEach(state -> {\n                 state.store.writeElectionState(election);\n-                if (election.hasLeader()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "14e0cab5e335b2619d8f17c999aac6a1c648b465"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQ5ODc0MQ==", "bodyText": "Oh, I think this was just unnecessary. The purpose of this logic is to initialize a certain election state prior to starting the simulation. But the code already initializes the epoch state on startup, so we didn't need this.", "url": "https://github.com/apache/kafka/pull/9332#discussion_r494498741", "createdAt": "2020-09-24T17:43:37Z", "author": {"login": "hachikuji"}, "path": "raft/src/test/java/org/apache/kafka/raft/RaftEventSimulationTest.java", "diffHunk": "@@ -712,11 +712,6 @@ void initializeElection(ElectionState election) {\n \n             nodes.values().forEach(state -> {\n                 state.store.writeElectionState(election);\n-                if (election.hasLeader()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDA2MzQ4NA=="}, "originalCommit": {"oid": "14e0cab5e335b2619d8f17c999aac6a1c648b465"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1861, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}