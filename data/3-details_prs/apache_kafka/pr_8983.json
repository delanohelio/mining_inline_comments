{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0NDg3NDg2", "number": 8983, "title": "KAFKA-8398: Prevent NPE in `forceUnmap`", "bodyText": "Without this change, we would catch the NPE and log it.\nThis was misleading and could cause excessive log\nvolume.\nThe NPE can happen after AlterReplicaLogDirs completes\nsuccessfully and when unmapping older regions. Example\nstacktrace:\n[2019-05-20 14:08:13,999] ERROR Error unmapping index /tmp/kafka-logs/test-0.567a0d8ff88b45ab95794020d0b2e66f-delete/00000000000000000000.index (kafka.log.OffsetIndex)\njava.lang.NullPointerException\nat org.apache.kafka.common.utils.MappedByteBuffers.unmap(MappedByteBuffers.java:73)\nat kafka.log.AbstractIndex.forceUnmap(AbstractIndex.scala:318)\nat kafka.log.AbstractIndex.safeForceUnmap(AbstractIndex.scala:308)\nat kafka.log.AbstractIndex.$anonfun$closeHandler$1(AbstractIndex.scala:257)\nat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\nat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:251)\nat kafka.log.AbstractIndex.closeHandler(AbstractIndex.scala:257)\nat kafka.log.AbstractIndex.deleteIfExists(AbstractIndex.scala:226)\nat kafka.log.LogSegment.$anonfun$deleteIfExists$6(LogSegment.scala:597)\nat kafka.log.LogSegment.delete$1(LogSegment.scala:585)\nat kafka.log.LogSegment.$anonfun$deleteIfExists$5(LogSegment.scala:597)\nat kafka.utils.CoreUtils$.$anonfun$tryAll$1(CoreUtils.scala:115)\nat kafka.utils.CoreUtils$.$anonfun$tryAll$1$adapted(CoreUtils.scala:114)\nat scala.collection.immutable.List.foreach(List.scala:392)\nat kafka.utils.CoreUtils$.tryAll(CoreUtils.scala:114)\nat kafka.log.LogSegment.deleteIfExists(LogSegment.scala:599)\nat kafka.log.Log.$anonfun$delete$3(Log.scala:1762)\nat kafka.log.Log.$anonfun$delete$3$adapted(Log.scala:1762)\nat scala.collection.Iterator.foreach(Iterator.scala:941)\nat scala.collection.Iterator.foreach$(Iterator.scala:941)\nat scala.collection.AbstractIterator.foreach(Iterator.scala:1429)\nat scala.collection.IterableLike.foreach(IterableLike.scala:74)\nat scala.collection.IterableLike.foreach$(IterableLike.scala:73)\nat scala.collection.AbstractIterable.foreach(Iterable.scala:56)\nat kafka.log.Log.$anonfun$delete$2(Log.scala:1762)\nat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\nat kafka.log.Log.maybeHandleIOException(Log.scala:2013)\nat kafka.log.Log.delete(Log.scala:1759)\nat kafka.log.LogManager.deleteLogs(LogManager.scala:761)\nat kafka.log.LogManager.$anonfun$deleteLogs$6(LogManager.scala:775)\nat kafka.utils.KafkaScheduler.$anonfun$schedule$2(KafkaScheduler.scala:114)\nat kafka.utils.CoreUtils$$anon$1.run(CoreUtils.scala:63)\nat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\nat java.util.concurrent.FutureTask.run(FutureTask.java:266)\nat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\nat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\nat java.lang.Thread.run(Thread.java:748)\n\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-07-06T00:57:31Z", "url": "https://github.com/apache/kafka/pull/8983", "merged": true, "mergeCommit": {"oid": "8a24da376b801c6eb6522ad4861b83f5beb5826c"}, "closed": true, "closedAt": "2020-07-06T18:34:37Z", "author": {"login": "ijuma"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcyGeuQgH2gAyNDQ0NDg3NDg2OmEzN2FkN2NkZTkwYTNjMGJlNmJhOTM2Y2E2ZTQxODBiMTQxOGVmODE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcyUykhAFqTQ0MzI3OTY5MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a37ad7cde90a3c0be6ba936ca6e4180b1418ef81", "author": {"user": {"login": "jaikiran", "name": "Jaikiran"}}, "url": "https://github.com/apache/kafka/commit/a37ad7cde90a3c0be6ba936ca6e4180b1418ef81", "committedDate": "2020-07-06T00:55:17Z", "message": "KAFKA-8398: Prevent NPE in `forceUnmap`\n\nWithout this change, we would catch the NPE and log it.\nThis was misleading and could cause excessive log\nvolume.\n\nThe NPE can happen after `AlterReplicaLogDirs` completes\nsuccessfully and when unmapping older regions. Example\nstacktrace:\n\n```text\n[2019-05-20 14:08:13,999] ERROR Error unmapping index /tmp/kafka-logs/test-0.567a0d8ff88b45ab95794020d0b2e66f-delete/00000000000000000000.index (kafka.log.OffsetIndex)\njava.lang.NullPointerException\nat org.apache.kafka.common.utils.MappedByteBuffers.unmap(MappedByteBuffers.java:73)\nat kafka.log.AbstractIndex.forceUnmap(AbstractIndex.scala:318)\nat kafka.log.AbstractIndex.safeForceUnmap(AbstractIndex.scala:308)\nat kafka.log.AbstractIndex.$anonfun$closeHandler$1(AbstractIndex.scala:257)\nat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\nat kafka.utils.CoreUtils$.inLock(CoreUtils.scala:251)\nat kafka.log.AbstractIndex.closeHandler(AbstractIndex.scala:257)\nat kafka.log.AbstractIndex.deleteIfExists(AbstractIndex.scala:226)\nat kafka.log.LogSegment.$anonfun$deleteIfExists$6(LogSegment.scala:597)\nat kafka.log.LogSegment.delete$1(LogSegment.scala:585)\nat kafka.log.LogSegment.$anonfun$deleteIfExists$5(LogSegment.scala:597)\nat kafka.utils.CoreUtils$.$anonfun$tryAll$1(CoreUtils.scala:115)\nat kafka.utils.CoreUtils$.$anonfun$tryAll$1$adapted(CoreUtils.scala:114)\nat scala.collection.immutable.List.foreach(List.scala:392)\nat kafka.utils.CoreUtils$.tryAll(CoreUtils.scala:114)\nat kafka.log.LogSegment.deleteIfExists(LogSegment.scala:599)\nat kafka.log.Log.$anonfun$delete$3(Log.scala:1762)\nat kafka.log.Log.$anonfun$delete$3$adapted(Log.scala:1762)\nat scala.collection.Iterator.foreach(Iterator.scala:941)\nat scala.collection.Iterator.foreach$(Iterator.scala:941)\nat scala.collection.AbstractIterator.foreach(Iterator.scala:1429)\nat scala.collection.IterableLike.foreach(IterableLike.scala:74)\nat scala.collection.IterableLike.foreach$(IterableLike.scala:73)\nat scala.collection.AbstractIterable.foreach(Iterable.scala:56)\nat kafka.log.Log.$anonfun$delete$2(Log.scala:1762)\nat scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:23)\nat kafka.log.Log.maybeHandleIOException(Log.scala:2013)\nat kafka.log.Log.delete(Log.scala:1759)\nat kafka.log.LogManager.deleteLogs(LogManager.scala:761)\nat kafka.log.LogManager.$anonfun$deleteLogs$6(LogManager.scala:775)\nat kafka.utils.KafkaScheduler.$anonfun$schedule$2(KafkaScheduler.scala:114)\nat kafka.utils.CoreUtils$$anon$1.run(CoreUtils.scala:63)\nat java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)\nat java.util.concurrent.FutureTask.run(FutureTask.java:266)\nat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.access$201(ScheduledThreadPoolExecutor.java:180)\nat java.util.concurrent.ScheduledThreadPoolExecutor$ScheduledFutureTask.run(ScheduledThreadPoolExecutor.java:293)\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)\nat java.lang.Thread.run(Thread.java:748)\n```"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyNzYwNjM0", "url": "https://github.com/apache/kafka/pull/8983#pullrequestreview-442760634", "createdAt": "2020-07-06T03:58:25Z", "commit": {"oid": "a37ad7cde90a3c0be6ba936ca6e4180b1418ef81"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwMzo1ODoyNVrOGtIGoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQwMzo1ODoyNVrOGtIGoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk3MTg3Mg==", "bodyText": "#7387 added null check to forceUnmap rather than safeForceUnmap. Which one makes sense? For another, forceUnmap is used by safeForceUnmap only. We can merge them so above question gets resolved.", "url": "https://github.com/apache/kafka/pull/8983#discussion_r449971872", "createdAt": "2020-07-06T03:58:25Z", "author": {"login": "chia7712"}, "path": "core/src/main/scala/kafka/log/AbstractIndex.scala", "diffHunk": "@@ -311,9 +311,11 @@ abstract class AbstractIndex(@volatile private var _file: File, val baseOffset:\n   }\n \n   protected def safeForceUnmap(): Unit = {\n-    try forceUnmap()\n-    catch {\n-      case t: Throwable => error(s\"Error unmapping index $file\", t)\n+    if (mmap != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a37ad7cde90a3c0be6ba936ca6e4180b1418ef81"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyNzYwNjQ5", "url": "https://github.com/apache/kafka/pull/8983#pullrequestreview-442760649", "createdAt": "2020-07-06T03:58:30Z", "commit": {"oid": "a37ad7cde90a3c0be6ba936ca6e4180b1418ef81"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMjc5Njkx", "url": "https://github.com/apache/kafka/pull/8983#pullrequestreview-443279691", "createdAt": "2020-07-06T17:35:38Z", "commit": {"oid": "a37ad7cde90a3c0be6ba936ca6e4180b1418ef81"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1168, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}