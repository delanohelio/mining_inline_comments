{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwNTc5OTYw", "number": 8312, "title": "KAFKA-9432 automated protocol for DescribeConfigs", "bodyText": "Change the DescribeConfigs request and response to use the generated protocol messages.", "createdAt": "2020-03-18T17:47:52Z", "url": "https://github.com/apache/kafka/pull/8312", "merged": true, "mergeCommit": {"oid": "9a4f00f78bf37041006ae8b6432d194f603ac6cc"}, "closed": true, "closedAt": "2020-06-12T20:19:36Z", "author": {"login": "tombentley"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcPisGKgBqjMxNDk5MjA2Mjk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcqsq8lAFqTQzMDA5ODYwOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE2ODMzMDE4", "url": "https://github.com/apache/kafka/pull/8312#pullrequestreview-416833018", "createdAt": "2020-05-22T11:14:36Z", "commit": null, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMToxNDozNlrOGZThoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMjoxNToxNVrOGZU_Yg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE4NzQ4OA==", "bodyText": "I wonder if it would read better if unifiedRequestResources was instead a List<DescribeConfigsResource> and we were creating the DescribeConfigsRequestData object and calling all its setters here. WDYT?", "url": "https://github.com/apache/kafka/pull/8312#discussion_r429187488", "createdAt": "2020-05-22T11:14:36Z", "author": {"login": "mimaison"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java", "diffHunk": "@@ -1912,53 +1915,51 @@ public DescribeConfigsResult describeConfigs(Collection<ConfigResource> configRe\n \n         // The non-BROKER resources which we want to describe.  These resources can be described by a\n         // single, unified DescribeConfigs request.\n-        final Collection<ConfigResource> unifiedRequestResources = new ArrayList<>(configResources.size());\n+        final DescribeConfigsRequestData unifiedRequestResources = new DescribeConfigsRequestData();\n \n         for (ConfigResource resource : configResources) {\n             if (dependsOnSpecificNode(resource)) {\n                 brokerFutures.put(resource, new KafkaFutureImpl<>());\n                 brokerResources.add(resource);\n             } else {\n                 unifiedRequestFutures.put(resource, new KafkaFutureImpl<>());\n-                unifiedRequestResources.add(resource);\n+                unifiedRequestResources.resources().add(new DescribeConfigsResource()\n+                        .setResourceName(resource.name())\n+                        .setResourceType(resource.type().id()));\n             }\n         }\n \n         final long now = time.milliseconds();\n-        if (!unifiedRequestResources.isEmpty()) {\n+        if (!unifiedRequestResources.resources().isEmpty()) {\n             runnable.call(new Call(\"describeConfigs\", calcDeadlineMs(now, options.timeoutMs()),\n                 new LeastLoadedNodeProvider()) {\n \n                 @Override\n                 DescribeConfigsRequest.Builder createRequest(int timeoutMs) {\n-                    return new DescribeConfigsRequest.Builder(unifiedRequestResources)\n-                            .includeSynonyms(options.includeSynonyms());\n+                    return new DescribeConfigsRequest.Builder(unifiedRequestResources.setIncludeSynoyms(options.includeSynonyms()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE5NjU3Mg==", "bodyText": "Can we move that line to the top?", "url": "https://github.com/apache/kafka/pull/8312#discussion_r429196572", "createdAt": "2020-05-22T11:37:52Z", "author": {"login": "mimaison"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/DescribeConfigsRequest.java", "diffHunk": "@@ -92,85 +48,43 @@ public Builder(Collection<ConfigResource> resources) {\n \n         @Override\n         public DescribeConfigsRequest build(short version) {\n-            return new DescribeConfigsRequest(version, resourceToConfigNames, includeSynonyms);\n+            return new DescribeConfigsRequest(data, version);\n         }\n     }\n \n-    private final Map<ConfigResource, Collection<String>> resourceToConfigNames;\n-    private final boolean includeSynonyms;\n+    private final DescribeConfigsRequestData data;\n \n-    public DescribeConfigsRequest(short version, Map<ConfigResource, Collection<String>> resourceToConfigNames, boolean includeSynonyms) {\n+    public DescribeConfigsRequest(DescribeConfigsRequestData data, short version) {\n         super(ApiKeys.DESCRIBE_CONFIGS, version);\n-        this.resourceToConfigNames = Objects.requireNonNull(resourceToConfigNames, \"resourceToConfigNames\");\n-        this.includeSynonyms = includeSynonyms;\n+        this.data = data;\n     }\n \n     public DescribeConfigsRequest(Struct struct, short version) {\n         super(ApiKeys.DESCRIBE_CONFIGS, version);\n-        Object[] resourcesArray = struct.getArray(RESOURCES_KEY_NAME);\n-        resourceToConfigNames = new HashMap<>(resourcesArray.length);\n-        for (Object resourceObj : resourcesArray) {\n-            Struct resourceStruct = (Struct) resourceObj;\n-            ConfigResource.Type resourceType = ConfigResource.Type.forId(resourceStruct.getByte(RESOURCE_TYPE_KEY_NAME));\n-            String resourceName = resourceStruct.getString(RESOURCE_NAME_KEY_NAME);\n-\n-            Object[] configNamesArray = resourceStruct.getArray(CONFIG_NAMES_KEY_NAME);\n-            List<String> configNames = null;\n-            if (configNamesArray != null) {\n-                configNames = new ArrayList<>(configNamesArray.length);\n-                for (Object configNameObj : configNamesArray)\n-                    configNames.add((String) configNameObj);\n-            }\n-\n-            resourceToConfigNames.put(new ConfigResource(resourceType, resourceName), configNames);\n-        }\n-        this.includeSynonyms = struct.hasField(INCLUDE_SYNONYMS) ? struct.getBoolean(INCLUDE_SYNONYMS) : false;\n-    }\n-\n-    public Collection<ConfigResource> resources() {\n-        return resourceToConfigNames.keySet();\n+        this.data = new DescribeConfigsRequestData(struct, version);\n     }\n \n-    /**\n-     * Return null if all config names should be returned.\n-     */\n-    public Collection<String> configNames(ConfigResource resource) {\n-        return resourceToConfigNames.get(resource);\n-    }\n-\n-    public boolean includeSynonyms() {\n-        return includeSynonyms;\n+    public DescribeConfigsRequestData data() {\n+        return data;\n     }\n \n     @Override\n     protected Struct toStruct() {\n-        Struct struct = new Struct(ApiKeys.DESCRIBE_CONFIGS.requestSchema(version()));\n-        List<Struct> resourceStructs = new ArrayList<>(resources().size());\n-        for (Map.Entry<ConfigResource, Collection<String>> entry : resourceToConfigNames.entrySet()) {\n-            ConfigResource resource = entry.getKey();\n-            Struct resourceStruct = struct.instance(RESOURCES_KEY_NAME);\n-            resourceStruct.set(RESOURCE_TYPE_KEY_NAME, resource.type().id());\n-            resourceStruct.set(RESOURCE_NAME_KEY_NAME, resource.name());\n-\n-            String[] configNames = entry.getValue() == null ? null : entry.getValue().toArray(new String[0]);\n-            resourceStruct.set(CONFIG_NAMES_KEY_NAME, configNames);\n-\n-            resourceStructs.add(resourceStruct);\n-        }\n-        struct.set(RESOURCES_KEY_NAME, resourceStructs.toArray(new Struct[0]));\n-        struct.setIfExists(INCLUDE_SYNONYMS, includeSynonyms);\n-        return struct;\n+        return data.toStruct(version());\n     }\n \n     @Override\n     public DescribeConfigsResponse getErrorResponse(int throttleTimeMs, Throwable e) {\n-        ApiError error = ApiError.fromThrowable(e);\n-        Map<ConfigResource, DescribeConfigsResponse.Config> errors = new HashMap<>(resources().size());\n-        DescribeConfigsResponse.Config config = new DescribeConfigsResponse.Config(error,\n-                Collections.emptyList());\n-        for (ConfigResource resource : resources())\n-            errors.put(resource, config);\n-        return new DescribeConfigsResponse(throttleTimeMs, errors);\n+        return new DescribeConfigsResponse(new DescribeConfigsResponseData()\n+                .setThrottleTimeMs(throttleTimeMs)\n+                .setResults(data.resources().stream().map(r -> {\n+                    Errors error = Errors.forException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE5Nzg0Mw==", "bodyText": "Let's give that variable a better name, what about config?", "url": "https://github.com/apache/kafka/pull/8312#discussion_r429197843", "createdAt": "2020-05-22T11:41:20Z", "author": {"login": "mimaison"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/DescribeConfigsResponse.java", "diffHunk": "@@ -220,145 +153,66 @@ public ConfigSource source() {\n         }\n     }\n \n+    public Map<ConfigResource, DescribeConfigsResponseData.DescribeConfigsResult> resultMap() {\n+        return data().results().stream().collect(Collectors.toMap(\n+            configsResult ->\n+                    new ConfigResource(ConfigResource.Type.forId(configsResult.resourceType()),\n+                            configsResult.resourceName()),\n+            Function.identity()));\n+    }\n \n-    private final int throttleTimeMs;\n-    private final Map<ConfigResource, Config> configs;\n+    private final DescribeConfigsResponseData data;\n \n-    public DescribeConfigsResponse(int throttleTimeMs, Map<ConfigResource, Config> configs) {\n-        this.throttleTimeMs = throttleTimeMs;\n-        this.configs = Objects.requireNonNull(configs, \"configs\");\n+    public DescribeConfigsResponse(DescribeConfigsResponseData data) {\n+        this.data = data;\n     }\n \n-    public DescribeConfigsResponse(Struct struct) {\n-        throttleTimeMs = struct.get(THROTTLE_TIME_MS);\n-        Object[] resourcesArray = struct.getArray(RESOURCES_KEY_NAME);\n-        configs = new HashMap<>(resourcesArray.length);\n-        for (Object resourceObj : resourcesArray) {\n-            Struct resourceStruct = (Struct) resourceObj;\n-\n-            ApiError error = new ApiError(resourceStruct);\n-            ConfigResource.Type resourceType = ConfigResource.Type.forId(resourceStruct.getByte(RESOURCE_TYPE_KEY_NAME));\n-            String resourceName = resourceStruct.getString(RESOURCE_NAME_KEY_NAME);\n-            ConfigResource resource = new ConfigResource(resourceType, resourceName);\n-\n-            Object[] configEntriesArray = resourceStruct.getArray(CONFIG_ENTRIES_KEY_NAME);\n-            List<ConfigEntry> configEntries = new ArrayList<>(configEntriesArray.length);\n-            for (Object configEntriesObj: configEntriesArray) {\n-                Struct configEntriesStruct = (Struct) configEntriesObj;\n-                String configName = configEntriesStruct.getString(CONFIG_NAME_KEY_NAME);\n-                String configValue = configEntriesStruct.getString(CONFIG_VALUE_KEY_NAME);\n-                boolean isSensitive = configEntriesStruct.getBoolean(IS_SENSITIVE_KEY_NAME);\n-                ConfigSource configSource;\n-                if (configEntriesStruct.hasField(CONFIG_SOURCE_KEY_NAME))\n-                    configSource = ConfigSource.forId(configEntriesStruct.getByte(CONFIG_SOURCE_KEY_NAME));\n-                else if (configEntriesStruct.hasField(IS_DEFAULT_KEY_NAME)) {\n-                    if (configEntriesStruct.getBoolean(IS_DEFAULT_KEY_NAME))\n-                        configSource = ConfigSource.DEFAULT_CONFIG;\n-                    else {\n-                        switch (resourceType) {\n-                            case BROKER:\n-                                configSource = ConfigSource.STATIC_BROKER_CONFIG;\n-                                break;\n-                            case TOPIC:\n-                                configSource = ConfigSource.TOPIC_CONFIG;\n-                                break;\n-                            default:\n-                                configSource = ConfigSource.UNKNOWN_CONFIG;\n-                                break;\n+    public DescribeConfigsResponse(Struct struct, short version) {\n+        this.data = new DescribeConfigsResponseData(struct, version);\n+        if (version == 0) {\n+            for (DescribeConfigsResult result : data.results()) {\n+                for (DescribeConfigsResponseData.DescribeConfigsResourceResult x : result.configs()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwMDY1Ng==", "bodyText": "We can use Errors.NONE.code() directly. Same below", "url": "https://github.com/apache/kafka/pull/8312#discussion_r429200656", "createdAt": "2020-05-22T11:48:06Z", "author": {"login": "mimaison"}, "path": "clients/src/test/java/org/apache/kafka/common/requests/RequestResponseTest.java", "diffHunk": "@@ -1845,34 +1857,59 @@ private DeleteAclsResponse createDeleteAclsResponse() {\n     }\n \n     private DescribeConfigsRequest createDescribeConfigsRequest(int version) {\n-        return new DescribeConfigsRequest.Builder(asList(\n-                new ConfigResource(ConfigResource.Type.BROKER, \"0\"),\n-                new ConfigResource(ConfigResource.Type.TOPIC, \"topic\")))\n-                .build((short) version);\n+        return new DescribeConfigsRequest.Builder(new DescribeConfigsRequestData().setResources(asList(\n+                new DescribeConfigsRequestData.DescribeConfigsResource()\n+                        .setResourceType(ConfigResource.Type.BROKER.id())\n+                        .setResourceName(\"0\"),\n+                new DescribeConfigsRequestData.DescribeConfigsResource()\n+                        .setResourceType(ConfigResource.Type.TOPIC.id())\n+                        .setResourceName(\"topic\"))))\n+            .build((short) version);\n     }\n \n     private DescribeConfigsRequest createDescribeConfigsRequestWithConfigEntries(int version) {\n-        Map<ConfigResource, Collection<String>> resources = new HashMap<>();\n-        resources.put(new ConfigResource(ConfigResource.Type.BROKER, \"0\"), asList(\"foo\", \"bar\"));\n-        resources.put(new ConfigResource(ConfigResource.Type.TOPIC, \"topic\"), null);\n-        resources.put(new ConfigResource(ConfigResource.Type.TOPIC, \"topic a\"), emptyList());\n-        return new DescribeConfigsRequest.Builder(resources).build((short) version);\n-    }\n-\n-    private DescribeConfigsResponse createDescribeConfigsResponse() {\n-        Map<ConfigResource, DescribeConfigsResponse.Config> configs = new HashMap<>();\n-        List<DescribeConfigsResponse.ConfigSynonym> synonyms = emptyList();\n-        List<DescribeConfigsResponse.ConfigEntry> configEntries = asList(\n-                new DescribeConfigsResponse.ConfigEntry(\"config_name\", \"config_value\",\n-                        DescribeConfigsResponse.ConfigSource.DYNAMIC_BROKER_CONFIG, true, false, synonyms),\n-                new DescribeConfigsResponse.ConfigEntry(\"another_name\", \"another value\",\n-                        DescribeConfigsResponse.ConfigSource.DEFAULT_CONFIG, false, true, synonyms)\n+        return new DescribeConfigsRequest.Builder(new DescribeConfigsRequestData().setResources(asList(\n+                new DescribeConfigsRequestData.DescribeConfigsResource()\n+                        .setResourceType(ConfigResource.Type.BROKER.id())\n+                        .setResourceName(\"0\")\n+                        .setConfigurationKeys(asList(\"foo\", \"bar\")),\n+                new DescribeConfigsRequestData.DescribeConfigsResource()\n+                        .setResourceType(ConfigResource.Type.TOPIC.id())\n+                        .setResourceName(\"topic\")\n+                        .setConfigurationKeys(null),\n+                new DescribeConfigsRequestData.DescribeConfigsResource()\n+                        .setResourceType(ConfigResource.Type.TOPIC.id())\n+                        .setResourceName(\"topic a\")\n+                        .setConfigurationKeys(Collections.emptyList()))))\n+                .build((short) version);\n+    }\n+\n+    private DescribeConfigsResponse createDescribeConfigsResponse(int version) {\n+        List<DescribeConfigsSynonym> synonyms = Collections.emptyList();\n+        List<DescribeConfigsResourceResult> configEntries = asList(\n+                new DescribeConfigsResourceResult().setName(\"config_name\").setValue(\"config_value\")\n+                .setConfigSource(version == 0 ? -1 : DescribeConfigsResponse.ConfigSource.DYNAMIC_BROKER_CONFIG.id)\n+                        .setIsDefault(false)\n+                        .setIsSensitive(true).setReadOnly(false).setSynonyms(synonyms),\n+                new DescribeConfigsResourceResult().setName(\"another_name\").setValue(\"another_value\")\n+                        .setIsDefault(false)\n+                        .setConfigSource(version == 0 ? -1 : DescribeConfigsResponse.ConfigSource.DEFAULT_CONFIG.id)\n+                        .setIsSensitive(false).setReadOnly(true).setSynonyms(synonyms)\n         );\n-        configs.put(new ConfigResource(ConfigResource.Type.BROKER, \"0\"), new DescribeConfigsResponse.Config(\n-                ApiError.NONE, configEntries));\n-        configs.put(new ConfigResource(ConfigResource.Type.TOPIC, \"topic\"), new DescribeConfigsResponse.Config(\n-                ApiError.NONE, Collections.<DescribeConfigsResponse.ConfigEntry>emptyList()));\n-        return new DescribeConfigsResponse(200, configs);\n+        List<DescribeConfigsResult> configs = asList(\n+                new DescribeConfigsResult()\n+                        .setResourceType(ConfigResource.Type.BROKER.id())\n+                        .setResourceName(\"0\")\n+                        .setErrorCode(ApiError.NONE.error().code())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwMTAwMA==", "bodyText": "We can use Errors.NONE.code directly", "url": "https://github.com/apache/kafka/pull/8312#discussion_r429201000", "createdAt": "2020-05-22T11:49:04Z", "author": {"login": "mimaison"}, "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -347,59 +346,62 @@ class AdminManager(val config: KafkaConfig,\n     }\n   }\n \n-  def describeConfigs(resourceToConfigNames: Map[ConfigResource, Option[Set[String]]], includeSynonyms: Boolean): Map[ConfigResource, DescribeConfigsResponse.Config] = {\n-    resourceToConfigNames.map { case (resource, configNames) =>\n+  def describeConfigs(resourceToConfigNames: List[DescribeConfigsResource], includeSynonyms: Boolean): List[DescribeConfigsResponseData.DescribeConfigsResult] = {\n+    resourceToConfigNames.map { case (resource) =>\n \n       def allConfigs(config: AbstractConfig) = {\n         config.originals.asScala.filter(_._2 != null) ++ config.values.asScala\n       }\n       def createResponseConfig(configs: Map[String, Any],\n-                               createConfigEntry: (String, Any) => DescribeConfigsResponse.ConfigEntry): DescribeConfigsResponse.Config = {\n+                               createConfigEntry: (String, Any) => DescribeConfigsResponseData.DescribeConfigsResourceResult): DescribeConfigsResponseData.DescribeConfigsResult = {\n         val filteredConfigPairs = configs.filter { case (configName, _) =>\n           /* Always returns true if configNames is None */\n-          configNames.forall(_.contains(configName))\n+          resource.configurationKeys.asScala.forall(_.contains(configName))\n         }.toBuffer\n \n         val configEntries = filteredConfigPairs.map { case (name, value) => createConfigEntry(name, value) }\n-        new DescribeConfigsResponse.Config(ApiError.NONE, configEntries.asJava)\n+        new DescribeConfigsResponseData.DescribeConfigsResult().setErrorCode(ApiError.NONE.error().code())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwMTcxNw==", "bodyText": "No need for the brackets after id", "url": "https://github.com/apache/kafka/pull/8312#discussion_r429201717", "createdAt": "2020-05-22T11:50:52Z", "author": {"login": "mimaison"}, "path": "core/src/main/scala/kafka/server/AdminManager.scala", "diffHunk": "@@ -707,11 +718,12 @@ class AdminManager(val config: KafkaConfig,\n       case _ => ConfigDef.convertToString(value, configEntryType.orNull)\n     }\n     val allSynonyms = configSynonyms(name, allNames, isSensitive)\n-        .filter(perBrokerConfig || _.source == ConfigSource.DYNAMIC_DEFAULT_BROKER_CONFIG)\n+        .filter(perBrokerConfig || _.source == ConfigSource.DYNAMIC_DEFAULT_BROKER_CONFIG.id())", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwMjIxMQ==", "bodyText": "We can remove the brackets here. Same a few lines below after resourceName", "url": "https://github.com/apache/kafka/pull/8312#discussion_r429202211", "createdAt": "2020-05-22T11:52:01Z", "author": {"login": "mimaison"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -2561,25 +2561,32 @@ class KafkaApis(val requestChannel: RequestChannel,\n \n   def handleDescribeConfigsRequest(request: RequestChannel.Request): Unit = {\n     val describeConfigsRequest = request.body[DescribeConfigsRequest]\n-    val (authorizedResources, unauthorizedResources) = describeConfigsRequest.resources.asScala.toBuffer.partition { resource =>\n-      resource.`type` match {\n+    val (authorizedResources, unauthorizedResources) = describeConfigsRequest.data.resources.asScala.toBuffer.partition { resource =>\n+      ConfigResource.Type.forId(resource.resourceType) match {\n         case ConfigResource.Type.BROKER | ConfigResource.Type.BROKER_LOGGER =>\n           authorize(request.context, DESCRIBE_CONFIGS, CLUSTER, CLUSTER_NAME)\n         case ConfigResource.Type.TOPIC =>\n-          authorize(request.context, DESCRIBE_CONFIGS, TOPIC, resource.name)\n-        case rt => throw new InvalidRequestException(s\"Unexpected resource type $rt for resource ${resource.name}\")\n+          authorize(request.context, DESCRIBE_CONFIGS, TOPIC, resource.resourceName)\n+        case rt => throw new InvalidRequestException(s\"Unexpected resource type $rt for resource ${resource.resourceName}\")\n       }\n     }\n-    val authorizedConfigs = adminManager.describeConfigs(authorizedResources.map { resource =>\n-      resource -> Option(describeConfigsRequest.configNames(resource)).map(_.asScala.toSet)\n-    }.toMap, describeConfigsRequest.includeSynonyms)\n+    val authorizedConfigs = adminManager.describeConfigs(authorizedResources.toList, describeConfigsRequest.data.includeSynoyms)\n     val unauthorizedConfigs = unauthorizedResources.map { resource =>\n-      val error = configsAuthorizationApiError(resource)\n-      resource -> new DescribeConfigsResponse.Config(error, util.Collections.emptyList[DescribeConfigsResponse.ConfigEntry])\n+      val error = ConfigResource.Type.forId(resource.resourceType()) match {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwMzAwNw==", "bodyText": "Let's also fix the field name", "url": "https://github.com/apache/kafka/pull/8312#discussion_r429203007", "createdAt": "2020-05-22T11:54:03Z", "author": {"login": "mimaison"}, "path": "clients/src/main/resources/common/message/DescribeConfigsRequest.json", "diffHunk": "@@ -17,7 +17,7 @@\n   \"apiKey\": 32,\n   \"type\": \"request\",\n   \"name\": \"DescribeConfigsRequest\",\n-  // Version 1 adds IncludeSynoyms.\n+  // Version 1 adds IncludeSynonyms.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwNzgxOQ==", "bodyText": "It looks like we are not calling configSynonyms() anymore, so we can remove that private method", "url": "https://github.com/apache/kafka/pull/8312#discussion_r429207819", "createdAt": "2020-05-22T12:06:02Z", "author": {"login": "mimaison"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java", "diffHunk": "@@ -2017,6 +2016,18 @@ void handleFailure(Throwable throwable) {\n         return new DescribeConfigsResult(allFutures);\n     }\n \n+    private Config describeConfigResult(DescribeConfigsResponseData.DescribeConfigsResult describeConfigsResult) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwODc2NA==", "bodyText": "We are not using resultData in this loop. Is that expected?", "url": "https://github.com/apache/kafka/pull/8312#discussion_r429208764", "createdAt": "2020-05-22T12:08:17Z", "author": {"login": "mimaison"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java", "diffHunk": "@@ -1912,53 +1915,51 @@ public DescribeConfigsResult describeConfigs(Collection<ConfigResource> configRe\n \n         // The non-BROKER resources which we want to describe.  These resources can be described by a\n         // single, unified DescribeConfigs request.\n-        final Collection<ConfigResource> unifiedRequestResources = new ArrayList<>(configResources.size());\n+        final DescribeConfigsRequestData unifiedRequestResources = new DescribeConfigsRequestData();\n \n         for (ConfigResource resource : configResources) {\n             if (dependsOnSpecificNode(resource)) {\n                 brokerFutures.put(resource, new KafkaFutureImpl<>());\n                 brokerResources.add(resource);\n             } else {\n                 unifiedRequestFutures.put(resource, new KafkaFutureImpl<>());\n-                unifiedRequestResources.add(resource);\n+                unifiedRequestResources.resources().add(new DescribeConfigsResource()\n+                        .setResourceName(resource.name())\n+                        .setResourceType(resource.type().id()));\n             }\n         }\n \n         final long now = time.milliseconds();\n-        if (!unifiedRequestResources.isEmpty()) {\n+        if (!unifiedRequestResources.resources().isEmpty()) {\n             runnable.call(new Call(\"describeConfigs\", calcDeadlineMs(now, options.timeoutMs()),\n                 new LeastLoadedNodeProvider()) {\n \n                 @Override\n                 DescribeConfigsRequest.Builder createRequest(int timeoutMs) {\n-                    return new DescribeConfigsRequest.Builder(unifiedRequestResources)\n-                            .includeSynonyms(options.includeSynonyms());\n+                    return new DescribeConfigsRequest.Builder(unifiedRequestResources.setIncludeSynoyms(options.includeSynonyms()));\n                 }\n \n                 @Override\n                 void handleResponse(AbstractResponse abstractResponse) {\n                     DescribeConfigsResponse response = (DescribeConfigsResponse) abstractResponse;\n+                    Map<ConfigResource, DescribeConfigsResponseData.DescribeConfigsResult> configResponseMap = response.resultMap();\n                     for (Map.Entry<ConfigResource, KafkaFutureImpl<Config>> entry : unifiedRequestFutures.entrySet()) {\n                         ConfigResource configResource = entry.getKey();\n                         KafkaFutureImpl<Config> future = entry.getValue();\n-                        DescribeConfigsResponse.Config config = response.config(configResource);\n-                        if (config == null) {\n-                            future.completeExceptionally(new UnknownServerException(\n-                                \"Malformed broker response: missing config for \" + configResource));\n-                            continue;\n-                        }\n-                        if (config.error().isFailure()) {\n-                            future.completeExceptionally(config.error().exception());\n-                            continue;\n-                        }\n-                        List<ConfigEntry> configEntries = new ArrayList<>();\n-                        for (DescribeConfigsResponse.ConfigEntry configEntry : config.entries()) {\n-                            configEntries.add(new ConfigEntry(configEntry.name(),\n-                                    configEntry.value(), configSource(configEntry.source()),\n-                                    configEntry.isSensitive(), configEntry.isReadOnly(),\n-                                    configSynonyms(configEntry)));\n+\n+                        for (DescribeConfigsResponseData.DescribeConfigsResult resultData : response.data().results()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwOTMzMQ==", "bodyText": "As we remove the other constructors, toResourceToConfigNames is not called anymore. Let's delete it", "url": "https://github.com/apache/kafka/pull/8312#discussion_r429209331", "createdAt": "2020-05-22T12:09:43Z", "author": {"login": "mimaison"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/DescribeConfigsRequest.java", "diffHunk": "@@ -17,70 +17,26 @@\n package org.apache.kafka.common.requests;\n \n import org.apache.kafka.common.config.ConfigResource;\n+import org.apache.kafka.common.message.DescribeConfigsRequestData;\n+import org.apache.kafka.common.message.DescribeConfigsResponseData;\n import org.apache.kafka.common.protocol.ApiKeys;\n-import org.apache.kafka.common.protocol.types.ArrayOf;\n-import org.apache.kafka.common.protocol.types.Field;\n-import org.apache.kafka.common.protocol.types.Schema;\n+import org.apache.kafka.common.protocol.Errors;\n import org.apache.kafka.common.protocol.types.Struct;\n \n import java.nio.ByteBuffer;\n-import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.Collections;\n import java.util.HashMap;\n-import java.util.List;\n import java.util.Map;\n-import java.util.Objects;\n-\n-import static org.apache.kafka.common.protocol.types.Type.BOOLEAN;\n-import static org.apache.kafka.common.protocol.types.Type.INT8;\n-import static org.apache.kafka.common.protocol.types.Type.STRING;\n+import java.util.stream.Collectors;\n \n public class DescribeConfigsRequest extends AbstractRequest {\n \n-    private static final String RESOURCES_KEY_NAME = \"resources\";\n-    private static final String INCLUDE_SYNONYMS = \"include_synonyms\";\n-    private static final String RESOURCE_TYPE_KEY_NAME = \"resource_type\";\n-    private static final String RESOURCE_NAME_KEY_NAME = \"resource_name\";\n-    private static final String CONFIG_NAMES_KEY_NAME = \"config_names\";\n-\n-    private static final Schema DESCRIBE_CONFIGS_REQUEST_RESOURCE_V0 = new Schema(\n-            new Field(RESOURCE_TYPE_KEY_NAME, INT8),\n-            new Field(RESOURCE_NAME_KEY_NAME, STRING),\n-            new Field(CONFIG_NAMES_KEY_NAME, ArrayOf.nullable(STRING)));\n-\n-    private static final Schema DESCRIBE_CONFIGS_REQUEST_V0 = new Schema(\n-            new Field(RESOURCES_KEY_NAME, new ArrayOf(DESCRIBE_CONFIGS_REQUEST_RESOURCE_V0), \"An array of config resources to be returned.\"));\n-\n-    private static final Schema DESCRIBE_CONFIGS_REQUEST_V1 = new Schema(\n-            new Field(RESOURCES_KEY_NAME, new ArrayOf(DESCRIBE_CONFIGS_REQUEST_RESOURCE_V0), \"An array of config resources to be returned.\"),\n-            new Field(INCLUDE_SYNONYMS, BOOLEAN));\n-\n-    /**\n-     * The version number is bumped to indicate that on quota violation brokers send out responses before throttling.\n-     */\n-    private static final Schema DESCRIBE_CONFIGS_REQUEST_V2 = DESCRIBE_CONFIGS_REQUEST_V1;\n-\n-    public static Schema[] schemaVersions() {\n-        return new Schema[]{DESCRIBE_CONFIGS_REQUEST_V0, DESCRIBE_CONFIGS_REQUEST_V1, DESCRIBE_CONFIGS_REQUEST_V2};\n-    }\n-\n     public static class Builder extends AbstractRequest.Builder<DescribeConfigsRequest> {\n-        private final Map<ConfigResource, Collection<String>> resourceToConfigNames;\n-        private boolean includeSynonyms;\n+        private final DescribeConfigsRequestData data;\n \n-        public Builder(Map<ConfigResource, Collection<String>> resourceToConfigNames) {\n+        public Builder(DescribeConfigsRequestData data) {\n             super(ApiKeys.DESCRIBE_CONFIGS);\n-            this.resourceToConfigNames = Objects.requireNonNull(resourceToConfigNames, \"resourceToConfigNames\");\n-        }\n-\n-        public Builder includeSynonyms(boolean includeSynonyms) {\n-            this.includeSynonyms = includeSynonyms;\n-            return this;\n-        }\n-\n-        public Builder(Collection<ConfigResource> resources) {\n-            this(toResourceToConfigNames(resources));\n+            this.data = data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIxMTQ5MA==", "bodyText": "It's unfortunate the public enum cannot do the mapping and we have to keep a copy here. Could we maybe rename this one so this looks less crazy? WDYT?", "url": "https://github.com/apache/kafka/pull/8312#discussion_r429211490", "createdAt": "2020-05-22T12:15:15Z", "author": {"login": "mimaison"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/DescribeConfigsResponse.java", "diffHunk": "@@ -174,19 +97,25 @@ public boolean isReadOnly() {\n     }\n \n     public enum ConfigSource {\n-        UNKNOWN_CONFIG((byte) 0),\n-        TOPIC_CONFIG((byte) 1),\n-        DYNAMIC_BROKER_CONFIG((byte) 2),\n-        DYNAMIC_DEFAULT_BROKER_CONFIG((byte) 3),\n-        STATIC_BROKER_CONFIG((byte) 4),\n-        DEFAULT_CONFIG((byte) 5),\n-        DYNAMIC_BROKER_LOGGER_CONFIG((byte) 6);\n+        UNKNOWN_CONFIG((byte) 0, org.apache.kafka.clients.admin.ConfigEntry.ConfigSource.UNKNOWN),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 115}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "141ca726f6c57470a5792f201177d6ad2d1ba4ec", "author": {"user": {"login": "tombentley", "name": "Tom Bentley"}}, "url": "https://github.com/apache/kafka/commit/141ca726f6c57470a5792f201177d6ad2d1ba4ec", "committedDate": "2020-06-08T10:42:20Z", "message": "KAFKA-9432 automated protocol for DescribeConfigs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca2e5e83c96d35a34a383101bcf50e3dff688f64", "author": {"user": {"login": "tombentley", "name": "Tom Bentley"}}, "url": "https://github.com/apache/kafka/commit/ca2e5e83c96d35a34a383101bcf50e3dff688f64", "committedDate": "2020-06-08T10:42:20Z", "message": "rebase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2962bf7dacb5e7e55ebd905d3134965bdf94fde0", "author": {"user": {"login": "tombentley", "name": "Tom Bentley"}}, "url": "https://github.com/apache/kafka/commit/2962bf7dacb5e7e55ebd905d3134965bdf94fde0", "committedDate": "2020-06-08T10:42:20Z", "message": "Review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55783db555de04aed2b949bc0787099490c55567", "author": {"user": {"login": "tombentley", "name": "Tom Bentley"}}, "url": "https://github.com/apache/kafka/commit/55783db555de04aed2b949bc0787099490c55567", "committedDate": "2020-06-08T15:20:12Z", "message": "Fix rebase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c89ec9691b4438d904b89146f8ab851642100d6d", "author": {"user": {"login": "tombentley", "name": "Tom Bentley"}}, "url": "https://github.com/apache/kafka/commit/c89ec9691b4438d904b89146f8ab851642100d6d", "committedDate": "2020-06-08T15:20:12Z", "message": "Better test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5b300656a63cd53238be781d6d93d4149401083", "author": {"user": {"login": "tombentley", "name": "Tom Bentley"}}, "url": "https://github.com/apache/kafka/commit/b5b300656a63cd53238be781d6d93d4149401083", "committedDate": "2020-06-08T15:20:12Z", "message": "Use single request when getting BROKER & BROKER_LOGGER from same broker"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "b5b300656a63cd53238be781d6d93d4149401083", "author": {"user": {"login": "tombentley", "name": "Tom Bentley"}}, "url": "https://github.com/apache/kafka/commit/b5b300656a63cd53238be781d6d93d4149401083", "committedDate": "2020-06-08T15:20:12Z", "message": "Use single request when getting BROKER & BROKER_LOGGER from same broker"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NzM3MTEw", "url": "https://github.com/apache/kafka/pull/8312#pullrequestreview-428737110", "createdAt": "2020-06-11T09:19:39Z", "commit": {"oid": "b5b300656a63cd53238be781d6d93d4149401083"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwOToxOTozOVrOGiVUnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMTowNzozMlrOGiYpHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1NDEwOA==", "bodyText": "It looks like configType() is not used anymore. Can we delete it?", "url": "https://github.com/apache/kafka/pull/8312#discussion_r438654108", "createdAt": "2020-06-11T09:19:39Z", "author": {"login": "mimaison"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java", "diffHunk": "@@ -1916,129 +1917,96 @@ void handleFailure(Throwable throwable) {\n \n     @Override\n     public DescribeConfigsResult describeConfigs(Collection<ConfigResource> configResources, final DescribeConfigsOptions options) {\n-        final Map<ConfigResource, KafkaFutureImpl<Config>> unifiedRequestFutures = new HashMap<>();\n-        final Map<ConfigResource, KafkaFutureImpl<Config>> brokerFutures = new HashMap<>(configResources.size());\n-\n-        // The BROKER resources which we want to describe.  We must make a separate DescribeConfigs\n-        // request for every BROKER resource we want to describe.\n-        final Collection<ConfigResource> brokerResources = new ArrayList<>();\n-\n-        // The non-BROKER resources which we want to describe.  These resources can be described by a\n-        // single, unified DescribeConfigs request.\n-        final Collection<ConfigResource> unifiedRequestResources = new ArrayList<>(configResources.size());\n+        // Partition the requested config resources based on which broker they must be sent to with the\n+        // null broker being used for config resources which can be obtained from any broker\n+        final Map<Integer, Map<ConfigResource, KafkaFutureImpl<Config>>> brokerFutures = new HashMap<>(configResources.size());\n \n         for (ConfigResource resource : configResources) {\n-            if (dependsOnSpecificNode(resource)) {\n-                brokerFutures.put(resource, new KafkaFutureImpl<>());\n-                brokerResources.add(resource);\n-            } else {\n-                unifiedRequestFutures.put(resource, new KafkaFutureImpl<>());\n-                unifiedRequestResources.add(resource);\n-            }\n+            Integer broker = nodeFor(resource);\n+            brokerFutures.compute(broker, (key, value) -> {\n+                if (value == null) {\n+                    // Only BROKER and BROKER_LOGGER configs are broker-specific\n+                    value = new HashMap<>(broker != null ? 2 : 16);\n+                }\n+                value.put(resource, new KafkaFutureImpl<>());\n+                return value;\n+            });\n         }\n \n         final long now = time.milliseconds();\n-        if (!unifiedRequestResources.isEmpty()) {\n+        for (Map.Entry<Integer, Map<ConfigResource, KafkaFutureImpl<Config>>> entry : brokerFutures.entrySet()) {\n+            Integer broker = entry.getKey();\n+            Map<ConfigResource, KafkaFutureImpl<Config>> unified = entry.getValue();\n+\n             runnable.call(new Call(\"describeConfigs\", calcDeadlineMs(now, options.timeoutMs()),\n-                new LeastLoadedNodeProvider()) {\n+                broker != null ? new ConstantNodeIdProvider(broker) : new LeastLoadedNodeProvider()) {\n \n                 @Override\n                 DescribeConfigsRequest.Builder createRequest(int timeoutMs) {\n-                    return new DescribeConfigsRequest.Builder(unifiedRequestResources)\n-                            .includeSynonyms(options.includeSynonyms())\n-                            .includeDocumentation(options.includeDocumentation());\n+                    return new DescribeConfigsRequest.Builder(new DescribeConfigsRequestData()\n+                        .setResources(unified.keySet().stream()\n+                            .map(config ->\n+                                new DescribeConfigsRequestData.DescribeConfigsResource()\n+                                    .setResourceName(config.name())\n+                                    .setResourceType(config.type().id()))\n+                            .collect(Collectors.toList()))\n+                        .setIncludeSynonyms(options.includeSynonyms())\n+                        .setIncludeDocumentation(options.includeDocumentation()));\n                 }\n \n                 @Override\n                 void handleResponse(AbstractResponse abstractResponse) {\n                     DescribeConfigsResponse response = (DescribeConfigsResponse) abstractResponse;\n-                    for (Map.Entry<ConfigResource, KafkaFutureImpl<Config>> entry : unifiedRequestFutures.entrySet()) {\n+                    for (Map.Entry<ConfigResource, DescribeConfigsResponseData.DescribeConfigsResult> entry : response.resultMap().entrySet()) {\n                         ConfigResource configResource = entry.getKey();\n-                        KafkaFutureImpl<Config> future = entry.getValue();\n-                        DescribeConfigsResponse.Config config = response.config(configResource);\n-                        if (config == null) {\n-                            future.completeExceptionally(new UnknownServerException(\n-                                \"Malformed broker response: missing config for \" + configResource));\n-                            continue;\n-                        }\n-                        if (config.error().isFailure()) {\n-                            future.completeExceptionally(config.error().exception());\n-                            continue;\n-                        }\n-                        List<ConfigEntry> configEntries = new ArrayList<>();\n-                        for (DescribeConfigsResponse.ConfigEntry configEntry : config.entries()) {\n-                            configEntries.add(new ConfigEntry(configEntry.name(),\n-                                    configEntry.value(), configSource(configEntry.source()),\n-                                    configEntry.isSensitive(), configEntry.isReadOnly(),\n-                                    configSynonyms(configEntry), configType(configEntry.type()),\n-                                    configEntry.documentation()));\n+                        DescribeConfigsResponseData.DescribeConfigsResult describeConfigsResult = entry.getValue();\n+                        KafkaFutureImpl<Config> future = unified.get(configResource);\n+                        if (future == null) {\n+                            if (broker != null) {\n+                                log.warn(\"The config {} in the response from broker {} is not in the request\",\n+                                        configResource, broker);\n+                            } else {\n+                                log.warn(\"The config {} in the response from the least loaded broker is not in the request\",\n+                                        configResource);\n+                            }\n+                        } else {\n+                            if (describeConfigsResult.errorCode() != Errors.NONE.code()) {\n+                                future.completeExceptionally(Errors.forCode(describeConfigsResult.errorCode())\n+                                        .exception(describeConfigsResult.errorMessage()));\n+                            } else {\n+                                future.complete(describeConfigResult(describeConfigsResult));\n+                            }\n                         }\n-                        future.complete(new Config(configEntries));\n                     }\n+                    completeUnrealizedFutures(\n+                        unified.entrySet().stream(),\n+                        configResource -> \"The broker response did not contain a result for config resource \" + configResource);\n                 }\n \n                 @Override\n                 void handleFailure(Throwable throwable) {\n-                    completeAllExceptionally(unifiedRequestFutures.values(), throwable);\n+                    completeAllExceptionally(unified.values(), throwable);\n                 }\n             }, now);\n         }\n \n-        for (Map.Entry<ConfigResource, KafkaFutureImpl<Config>> entry : brokerFutures.entrySet()) {\n-            final KafkaFutureImpl<Config> brokerFuture = entry.getValue();\n-            final ConfigResource resource = entry.getKey();\n-            final int nodeId = Integer.parseInt(resource.name());\n-            runnable.call(new Call(\"describeBrokerConfigs\", calcDeadlineMs(now, options.timeoutMs()),\n-                    new ConstantNodeIdProvider(nodeId)) {\n-\n-                @Override\n-                DescribeConfigsRequest.Builder createRequest(int timeoutMs) {\n-                    return new DescribeConfigsRequest.Builder(Collections.singleton(resource))\n-                            .includeSynonyms(options.includeSynonyms())\n-                            .includeDocumentation(options.includeDocumentation());\n-                }\n-\n-                @Override\n-                void handleResponse(AbstractResponse abstractResponse) {\n-                    DescribeConfigsResponse response = (DescribeConfigsResponse) abstractResponse;\n-                    DescribeConfigsResponse.Config config = response.configs().get(resource);\n-\n-                    if (config == null) {\n-                        brokerFuture.completeExceptionally(new UnknownServerException(\n-                            \"Malformed broker response: missing config for \" + resource));\n-                        return;\n-                    }\n-                    if (config.error().isFailure())\n-                        brokerFuture.completeExceptionally(config.error().exception());\n-                    else {\n-                        List<ConfigEntry> configEntries = new ArrayList<>();\n-                        for (DescribeConfigsResponse.ConfigEntry configEntry : config.entries()) {\n-                            configEntries.add(new ConfigEntry(configEntry.name(), configEntry.value(),\n-                                configSource(configEntry.source()), configEntry.isSensitive(), configEntry.isReadOnly(),\n-                                configSynonyms(configEntry), configType(configEntry.type()), configEntry.documentation()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5b300656a63cd53238be781d6d93d4149401083"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODY1OTI5Mg==", "bodyText": "We can drop util here, we are importing import java.util.{Collections, Optional}", "url": "https://github.com/apache/kafka/pull/8312#discussion_r438659292", "createdAt": "2020-06-11T09:29:00Z", "author": {"login": "mimaison"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -2568,25 +2568,32 @@ class KafkaApis(val requestChannel: RequestChannel,\n \n   def handleDescribeConfigsRequest(request: RequestChannel.Request): Unit = {\n     val describeConfigsRequest = request.body[DescribeConfigsRequest]\n-    val (authorizedResources, unauthorizedResources) = describeConfigsRequest.resources.asScala.toBuffer.partition { resource =>\n-      resource.`type` match {\n+    val (authorizedResources, unauthorizedResources) = describeConfigsRequest.data.resources.asScala.toBuffer.partition { resource =>\n+      ConfigResource.Type.forId(resource.resourceType) match {\n         case ConfigResource.Type.BROKER | ConfigResource.Type.BROKER_LOGGER =>\n           authorize(request.context, DESCRIBE_CONFIGS, CLUSTER, CLUSTER_NAME)\n         case ConfigResource.Type.TOPIC =>\n-          authorize(request.context, DESCRIBE_CONFIGS, TOPIC, resource.name)\n-        case rt => throw new InvalidRequestException(s\"Unexpected resource type $rt for resource ${resource.name}\")\n+          authorize(request.context, DESCRIBE_CONFIGS, TOPIC, resource.resourceName)\n+        case rt => throw new InvalidRequestException(s\"Unexpected resource type $rt for resource ${resource.resourceName}\")\n       }\n     }\n-    val authorizedConfigs = adminManager.describeConfigs(authorizedResources.map { resource =>\n-      resource -> Option(describeConfigsRequest.configNames(resource)).map(_.asScala.toSet)\n-    }.toMap, describeConfigsRequest.includeSynonyms, describeConfigsRequest.includeDocumentation)\n+    val authorizedConfigs = adminManager.describeConfigs(authorizedResources.toList, describeConfigsRequest.data.includeSynonyms, describeConfigsRequest.data.includeDocumentation)\n     val unauthorizedConfigs = unauthorizedResources.map { resource =>\n-      val error = configsAuthorizationApiError(resource)\n-      resource -> new DescribeConfigsResponse.Config(error, util.Collections.emptyList[DescribeConfigsResponse.ConfigEntry])\n+      val error = ConfigResource.Type.forId(resource.resourceType) match {\n+        case ConfigResource.Type.BROKER | ConfigResource.Type.BROKER_LOGGER => Errors.CLUSTER_AUTHORIZATION_FAILED\n+        case ConfigResource.Type.TOPIC => Errors.TOPIC_AUTHORIZATION_FAILED\n+        case rt => throw new InvalidRequestException(s\"Unexpected resource type $rt for resource ${resource.resourceName}\")\n+      }\n+      new DescribeConfigsResponseData.DescribeConfigsResult().setErrorCode(error.code)\n+        .setErrorMessage(error.message)\n+        .setConfigs(util.Collections.emptyList[DescribeConfigsResponseData.DescribeConfigsResourceResult])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5b300656a63cd53238be781d6d93d4149401083"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcwODUxMQ==", "bodyText": "I wonder if we can just get a Map with the default size. I don't expect this code path to be very hot", "url": "https://github.com/apache/kafka/pull/8312#discussion_r438708511", "createdAt": "2020-06-11T11:07:32Z", "author": {"login": "mimaison"}, "path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java", "diffHunk": "@@ -1916,129 +1917,96 @@ void handleFailure(Throwable throwable) {\n \n     @Override\n     public DescribeConfigsResult describeConfigs(Collection<ConfigResource> configResources, final DescribeConfigsOptions options) {\n-        final Map<ConfigResource, KafkaFutureImpl<Config>> unifiedRequestFutures = new HashMap<>();\n-        final Map<ConfigResource, KafkaFutureImpl<Config>> brokerFutures = new HashMap<>(configResources.size());\n-\n-        // The BROKER resources which we want to describe.  We must make a separate DescribeConfigs\n-        // request for every BROKER resource we want to describe.\n-        final Collection<ConfigResource> brokerResources = new ArrayList<>();\n-\n-        // The non-BROKER resources which we want to describe.  These resources can be described by a\n-        // single, unified DescribeConfigs request.\n-        final Collection<ConfigResource> unifiedRequestResources = new ArrayList<>(configResources.size());\n+        // Partition the requested config resources based on which broker they must be sent to with the\n+        // null broker being used for config resources which can be obtained from any broker\n+        final Map<Integer, Map<ConfigResource, KafkaFutureImpl<Config>>> brokerFutures = new HashMap<>(configResources.size());\n \n         for (ConfigResource resource : configResources) {\n-            if (dependsOnSpecificNode(resource)) {\n-                brokerFutures.put(resource, new KafkaFutureImpl<>());\n-                brokerResources.add(resource);\n-            } else {\n-                unifiedRequestFutures.put(resource, new KafkaFutureImpl<>());\n-                unifiedRequestResources.add(resource);\n-            }\n+            Integer broker = nodeFor(resource);\n+            brokerFutures.compute(broker, (key, value) -> {\n+                if (value == null) {\n+                    // Only BROKER and BROKER_LOGGER configs are broker-specific\n+                    value = new HashMap<>(broker != null ? 2 : 16);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5b300656a63cd53238be781d6d93d4149401083"}, "originalPosition": 47}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a9c778df4037bde613452293667fd9053fdbe7d", "author": {"user": {"login": "tombentley", "name": "Tom Bentley"}}, "url": "https://github.com/apache/kafka/commit/5a9c778df4037bde613452293667fd9053fdbe7d", "committedDate": "2020-06-11T18:15:43Z", "message": "Review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMDEzNDEx", "url": "https://github.com/apache/kafka/pull/8312#pullrequestreview-430013411", "createdAt": "2020-06-12T20:17:12Z", "commit": {"oid": "5a9c778df4037bde613452293667fd9053fdbe7d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMDk4NjA5", "url": "https://github.com/apache/kafka/pull/8312#pullrequestreview-430098609", "createdAt": "2020-06-13T00:53:37Z", "commit": {"oid": "5a9c778df4037bde613452293667fd9053fdbe7d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDo1MzozN1rOGjUvCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDo1MzozN1rOGjUvCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5MzA2NA==", "bodyText": "Hey @mimaison @tombentley, removing this constructor seems to have broken the build (it was used in TopicAdminTest). Can we get a hotfix for this to unblock other PRs?\nedit: nevermind, a PR was just opened for it (pull/8866)", "url": "https://github.com/apache/kafka/pull/8312#discussion_r439693064", "createdAt": "2020-06-13T00:53:37Z", "author": {"login": "ableegoldman"}, "path": "clients/src/main/java/org/apache/kafka/common/requests/DescribeConfigsResponse.java", "diffHunk": "@@ -293,158 +208,66 @@ public ConfigSource source() {\n         }\n     }\n \n+    public Map<ConfigResource, DescribeConfigsResponseData.DescribeConfigsResult> resultMap() {\n+        return data().results().stream().collect(Collectors.toMap(\n+            configsResult ->\n+                    new ConfigResource(ConfigResource.Type.forId(configsResult.resourceType()),\n+                            configsResult.resourceName()),\n+            Function.identity()));\n+    }\n \n-    private final int throttleTimeMs;\n-    private final Map<ConfigResource, Config> configs;\n+    private final DescribeConfigsResponseData data;\n \n-    public DescribeConfigsResponse(int throttleTimeMs, Map<ConfigResource, Config> configs) {\n-        this.throttleTimeMs = throttleTimeMs;\n-        this.configs = Objects.requireNonNull(configs, \"configs\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a9c778df4037bde613452293667fd9053fdbe7d"}, "originalPosition": 245}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 310, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}