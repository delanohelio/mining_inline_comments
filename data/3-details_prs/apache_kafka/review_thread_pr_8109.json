{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1MDE0ODg3", "number": 8109, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMDoxMzo0MFrODfvdAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNjo0NDo0NVrODf863Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0NjA5OTIyOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMDoxMzo0MFrOFpn71A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMDo1Mzo1MlrOFqDYLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MDIyOA==", "bodyText": "Can you elaborate a bit on this fix? Do you mean one task is subscribed to a pattern that matches multiple topics, or to two different patterns? I'm not sure I understand why either case would cause containsAll to fail.", "url": "https://github.com/apache/kafka/pull/8109#discussion_r379190228", "createdAt": "2020-02-14T00:13:40Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -257,9 +257,11 @@ void handleRevocation(final Collection<TopicPartition> revokedPartitions) {\n         final Set<TopicPartition> remainingPartitions = new HashSet<>(revokedPartitions);\n \n         for (final Task task : tasks.values()) {\n-            if (remainingPartitions.containsAll(task.inputPartitions())) {\n-                revokedTasks.add(task.id());\n-                remainingPartitions.removeAll(task.inputPartitions());\n+            for (final TopicPartition topicPartition : task.inputPartitions()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff59b3a0aa289b06b90398ab3f2807a206ab67a4"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI3MzQ0Mg==", "bodyText": "What I mean here is that if one of the partitions this task owns is removed, but not all, then the old logic will not catch the revoked task by containsAll.\njava.lang.IllegalStateException: Some revoked partitions that do not belong to any tasks remain: [TEST-TOPIC-A-0]\n\tat org.apache.kafka.streams.processor.internals.TaskManager.handleRevocation(TaskManager.java:267)\n\tat org.apache.kafka.streams.processor.internals.StreamsRebalanceListener.onPartitionsRevoked(StreamsRebalanceListener.java:72)\n\tat org.apache.kafka.streams.integration.RegexSourceIntegrationTest$TheConsumerRebalanceListener.onPartitionsRevoked(RegexSourceIntegrationTest.java:422)\n\tat org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.invokePartitionsRevoked(ConsumerCoordinator.java:297)\n\tat org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.onJoinPrepare(ConsumerCoordinator.java:681)\n\tat org.apache.kafka.clients.consumer.internals.AbstractCoordinator.joinGroupIfNeeded(AbstractCoordinator.java:414)\n\tat org.apache.kafka.clients.consumer.internals.AbstractCoordinator.ensureActiveGroup(AbstractCoordinator.java:358)\n\tat org.apache.kafka.clients.consumer.internals.ConsumerCoordinator.poll(ConsumerCoordinator.java:477)\n\tat org.apache.kafka.clients.consumer.KafkaConsumer.updateAssignmentMetadataIfNeeded(KafkaConsumer.java:1275)```", "url": "https://github.com/apache/kafka/pull/8109#discussion_r379273442", "createdAt": "2020-02-14T06:50:23Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -257,9 +257,11 @@ void handleRevocation(final Collection<TopicPartition> revokedPartitions) {\n         final Set<TopicPartition> remainingPartitions = new HashSet<>(revokedPartitions);\n \n         for (final Task task : tasks.values()) {\n-            if (remainingPartitions.containsAll(task.inputPartitions())) {\n-                revokedTasks.add(task.id());\n-                remainingPartitions.removeAll(task.inputPartitions());\n+            for (final TopicPartition topicPartition : task.inputPartitions()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MDIyOA=="}, "originalCommit": {"oid": "ff59b3a0aa289b06b90398ab3f2807a206ab67a4"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzNDY4NQ==", "bodyText": "Hmm.. why it's possible that only part of the partitions of a task is revoked? We do assignment at the granularity of tasks so this check is to verify specifically that all partitions should be included if a task is going to be removed right?", "url": "https://github.com/apache/kafka/pull/8109#discussion_r379534685", "createdAt": "2020-02-14T16:46:18Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -257,9 +257,11 @@ void handleRevocation(final Collection<TopicPartition> revokedPartitions) {\n         final Set<TopicPartition> remainingPartitions = new HashSet<>(revokedPartitions);\n \n         for (final Task task : tasks.values()) {\n-            if (remainingPartitions.containsAll(task.inputPartitions())) {\n-                revokedTasks.add(task.id());\n-                remainingPartitions.removeAll(task.inputPartitions());\n+            for (final TopicPartition topicPartition : task.inputPartitions()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MDIyOA=="}, "originalCommit": {"oid": "ff59b3a0aa289b06b90398ab3f2807a206ab67a4"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYzOTg1NQ==", "bodyText": "I think now I understand the reason that part of the partitions can be removed here.\nIf a task is indeed being removed, it should be triggered in the TaskManager#onAssignment; here TaskManager#onRevocation is triggered after the previous call so the tasks map should have been updated --- i.e. the task would not be inside task-manager anymore, and if it is due to regex pattern (like this test) the current condition is okay: we should not suspend the task unless all its input-partitions are included. Otherwise, we can just update the input partition of that task --- right now it is final so we cannot update it, but I think that\u2019s fine since we would no longer pipe any records to that task and there will be no committed offsets for that partition either --- in either case, we can remove it from the remainingPartitions.", "url": "https://github.com/apache/kafka/pull/8109#discussion_r379639855", "createdAt": "2020-02-14T20:53:52Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -257,9 +257,11 @@ void handleRevocation(final Collection<TopicPartition> revokedPartitions) {\n         final Set<TopicPartition> remainingPartitions = new HashSet<>(revokedPartitions);\n \n         for (final Task task : tasks.values()) {\n-            if (remainingPartitions.containsAll(task.inputPartitions())) {\n-                revokedTasks.add(task.id());\n-                remainingPartitions.removeAll(task.inputPartitions());\n+            for (final TopicPartition topicPartition : task.inputPartitions()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MDIyOA=="}, "originalCommit": {"oid": "ff59b3a0aa289b06b90398ab3f2807a206ab67a4"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0ODMwNTU3OnYy", "diffSide": "LEFT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopologyBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNjo0NDo0NVrOFp86gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNjo0NDo0NVrOFp86gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzMzk1NQ==", "bodyText": "This function is called by two callers: xxxFromMetadata and xxxFromAssignment. For the former we do not maintain the old topics but just replace with the passed in value, for the latter we still maintain the  old topics -- this it to take care if the leader did not assign all tasks / partitions due to assignment error. We should still keep that logic here.", "url": "https://github.com/apache/kafka/pull/8109#discussion_r379533955", "createdAt": "2020-02-14T16:44:45Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/InternalTopologyBuilder.java", "diffHunk": "@@ -1887,8 +1887,6 @@ private void updateSubscribedTopics(final Set<String> topics, final String logPr\n         final Collection<String> existingTopics = subscriptionUpdates();\n \n         if  (!existingTopics.equals(topics)) {\n-            topics.addAll(existingTopics);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff59b3a0aa289b06b90398ab3f2807a206ab67a4"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4288, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}