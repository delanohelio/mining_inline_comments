{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0NzM5MDEz", "number": 9141, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODo0NTozMFrOEWUXVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMTo1MTo0NFrOEW-gVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxODM3NzgzOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/CogroupedStreamAggregateBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODo0NTozMVrOG9kQoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxOTowMDo1MVrOG9ksKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxMDQwMA==", "bodyText": "WDYT about naming this just build? It's not as clear, but I think it's in line with the naming conventions elsewhere. For example we have KStreamWindowAggregate and KStreamAggregate (then maybe we can come up with a more descriptive name for the method currently called build", "url": "https://github.com/apache/kafka/pull/9141#discussion_r467210400", "createdAt": "2020-08-07T18:45:31Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/CogroupedStreamAggregateBuilder.java", "diffHunk": "@@ -47,18 +47,96 @@\n     CogroupedStreamAggregateBuilder(final InternalStreamsBuilder builder) {\n         this.builder = builder;\n     }\n-\n-    <KR, VIn, W extends Window> KTable<KR, VOut> build(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n+    <KR, VIn, W extends Window> KTable<KR, VOut> buildNotWindowed(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8783058e2833ab07c2adf66f9badfb02f501768f"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxNzQ1MQ==", "bodyText": "Also you can remove the Vin and W extends Window generics on this method", "url": "https://github.com/apache/kafka/pull/9141#discussion_r467217451", "createdAt": "2020-08-07T19:00:51Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/CogroupedStreamAggregateBuilder.java", "diffHunk": "@@ -47,18 +47,96 @@\n     CogroupedStreamAggregateBuilder(final InternalStreamsBuilder builder) {\n         this.builder = builder;\n     }\n-\n-    <KR, VIn, W extends Window> KTable<KR, VOut> build(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n+    <KR, VIn, W extends Window> KTable<KR, VOut> buildNotWindowed(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxMDQwMA=="}, "originalCommit": {"oid": "8783058e2833ab07c2adf66f9badfb02f501768f"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxODM4NjczOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/CogroupedStreamAggregateBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODo0ODo0MlrOG9kV7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODo0ODo0MlrOG9kV7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxMTc1Nw==", "bodyText": "We can remove the <W extends Window> now, right? Also it looks like the initializer input isn't needed anymore either", "url": "https://github.com/apache/kafka/pull/9141#discussion_r467211757", "createdAt": "2020-08-07T18:48:42Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/CogroupedStreamAggregateBuilder.java", "diffHunk": "@@ -85,68 +163,39 @@\n         groupedStreams.remove(kGrouped);\n         kGrouped.ensureCopartitionWith(groupedStreams);\n \n-        final Collection<StreamsGraphNode> processors = new ArrayList<>();\n-        boolean stateCreated = false;\n-        int counter = 0;\n-        for (final Entry<KGroupedStreamImpl<K, ?>, Aggregator<? super K, Object, VOut>> kGroupedStream : groupPatterns.entrySet()) {\n-            final StatefulProcessorNode<K, ?> statefulProcessorNode = getStatefulProcessorNode(\n-                kGroupedStream.getValue(),\n-                initializer,\n-                named.suffixWithOrElseGet(\n-                    \"-cogroup-agg-\" + counter++,\n-                    builder,\n-                    CogroupedKStreamImpl.AGGREGATE_NAME),\n-                stateCreated,\n-                storeBuilder,\n-                windows,\n-                sessionWindows,\n-                sessionMerger);\n-            stateCreated = true;\n-            processors.add(statefulProcessorNode);\n-            builder.addGraphNode(parentNodes.get(kGroupedStream.getKey()), statefulProcessorNode);\n-        }\n+    }\n+\n+    <KR, VIn, W extends Window> KTable<KR, VOut> createTable(final Collection<StreamsGraphNode> processors,\n+                                                             final NamedInternal named,\n+                                                             final Serde<KR> keySerde,\n+                                                             final Serde<VOut> valueSerde,\n+                                                             final String queryableName) {\n         final String mergeProcessorName = named.suffixWithOrElseGet(\n-            \"-cogroup-merge\",\n-            builder,\n-            CogroupedKStreamImpl.MERGE_NAME);\n+                \"-cogroup-merge\",\n+                builder,\n+                CogroupedKStreamImpl.MERGE_NAME);\n         final ProcessorSupplier<K, VOut> passThrough = new PassThrough<>();\n         final ProcessorGraphNode<K, VOut> mergeNode =\n-            new ProcessorGraphNode<>(mergeProcessorName, new ProcessorParameters<>(passThrough, mergeProcessorName));\n+                new ProcessorGraphNode<>(mergeProcessorName, new ProcessorParameters<>(passThrough, mergeProcessorName));\n \n         builder.addGraphNode(processors, mergeNode);\n \n         return new KTableImpl<KR, VIn, VOut>(\n-            mergeProcessorName,\n-            keySerde,\n-            valueSerde,\n-            Collections.singleton(mergeNode.nodeName()),\n-            queryableName,\n-            passThrough,\n-            mergeNode,\n-            builder);\n+                mergeProcessorName,\n+                keySerde,\n+                valueSerde,\n+                Collections.singleton(mergeNode.nodeName()),\n+                queryableName,\n+                passThrough,\n+                mergeNode,\n+                builder);\n     }\n \n-    private <W extends Window> StatefulProcessorNode<K, ?> getStatefulProcessorNode(final Aggregator<? super K, Object, VOut> aggregator,\n-                                                                                    final Initializer<VOut> initializer,\n+    private <W extends Window> StatefulProcessorNode<K, ?> getStatefulProcessorNode(final Initializer<VOut> initializer,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8783058e2833ab07c2adf66f9badfb02f501768f"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxODQxMjU2OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/CogroupedStreamAggregateBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODo1NzowNFrOG9klbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxOTo0NDowNlrOG9l08Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxNTcyNQ==", "bodyText": "Can we call this something like ensureCopartitioning or processRepartitions or something? My take is that the copartitioning is the main point of this method so that's probably good to include in the name", "url": "https://github.com/apache/kafka/pull/9141#discussion_r467215725", "createdAt": "2020-08-07T18:57:04Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/CogroupedStreamAggregateBuilder.java", "diffHunk": "@@ -47,18 +47,96 @@\n     CogroupedStreamAggregateBuilder(final InternalStreamsBuilder builder) {\n         this.builder = builder;\n     }\n-\n-    <KR, VIn, W extends Window> KTable<KR, VOut> build(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n+    <KR, VIn, W extends Window> KTable<KR, VOut> buildNotWindowed(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n                                                        final Initializer<VOut> initializer,\n                                                        final NamedInternal named,\n                                                        final StoreBuilder<?> storeBuilder,\n                                                        final Serde<KR> keySerde,\n                                                        final Serde<VOut> valueSerde,\n-                                                       final String queryableName,\n-                                                       final Windows<W> windows,\n-                                                       final SessionWindows sessionWindows,\n-                                                       final Merger<? super K, VOut> sessionMerger) {\n+                                                       final String queryableName) {\n+        build(groupPatterns, storeBuilder);\n+        final Collection<StreamsGraphNode> processors = new ArrayList<>();\n+        boolean stateCreated = false;\n+        int counter = 0;\n+        for (final Entry<KGroupedStreamImpl<K, ?>, Aggregator<? super K, Object, VOut>> kGroupedStream : groupPatterns.entrySet()) {\n+            final StatefulProcessorNode<K, ?> statefulProcessorNode = getStatefulProcessorNode(\n+                    initializer,\n+                    named.suffixWithOrElseGet(\n+                            \"-cogroup-agg-\" + counter++,\n+                            builder,\n+                            CogroupedKStreamImpl.AGGREGATE_NAME),\n+                    stateCreated,\n+                    storeBuilder,\n+                    new KStreamAggregate<>(storeBuilder.name(), initializer, kGroupedStream.getValue()));\n+            stateCreated = true;\n+            processors.add(statefulProcessorNode);\n+            builder.addGraphNode(parentNodes.get(kGroupedStream.getKey()), statefulProcessorNode);\n+        }\n+        return createTable(processors, named, keySerde, valueSerde, queryableName);\n+    }\n+\n+    <KR, VIn, W extends Window> KTable<KR, VOut> buildTimeWindows(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n+                                                              final Initializer<VOut> initializer,\n+                                                              final NamedInternal named,\n+                                                              final StoreBuilder<?> storeBuilder,\n+                                                              final Serde<KR> keySerde,\n+                                                              final Serde<VOut> valueSerde,\n+                                                              final String queryableName,\n+                                                                  final Windows<W> windows) {\n+        build(groupPatterns, storeBuilder);\n \n+        final Collection<StreamsGraphNode> processors = new ArrayList<>();\n+        boolean stateCreated = false;\n+        int counter = 0;\n+        for (final Entry<KGroupedStreamImpl<K, ?>, Aggregator<? super K, Object, VOut>> kGroupedStream : groupPatterns.entrySet()) {\n+            final StatefulProcessorNode<K, ?> statefulProcessorNode = getStatefulProcessorNode(\n+                    initializer,\n+                    named.suffixWithOrElseGet(\n+                            \"-cogroup-agg-\" + counter++,\n+                            builder,\n+                            CogroupedKStreamImpl.AGGREGATE_NAME),\n+                    stateCreated,\n+                    storeBuilder,\n+                    new KStreamWindowAggregate<>(windows, storeBuilder.name(), initializer, kGroupedStream.getValue()));\n+            stateCreated = true;\n+            processors.add(statefulProcessorNode);\n+            builder.addGraphNode(parentNodes.get(kGroupedStream.getKey()), statefulProcessorNode);\n+        }\n+        return createTable(processors, named, keySerde, valueSerde, queryableName);\n+    }\n+\n+    <KR, VIn, W extends Window> KTable<KR, VOut> buildSessionWindows(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n+                                                                  final Initializer<VOut> initializer,\n+                                                                  final NamedInternal named,\n+                                                                  final StoreBuilder<?> storeBuilder,\n+                                                                  final Serde<KR> keySerde,\n+                                                                  final Serde<VOut> valueSerde,\n+                                                                  final String queryableName,\n+                                                                  final SessionWindows sessionWindows,\n+                                                                     final Merger<? super K, VOut> sessionMerger) {\n+        build(groupPatterns, storeBuilder);\n+        final Collection<StreamsGraphNode> processors = new ArrayList<>();\n+        boolean stateCreated = false;\n+        int counter = 0;\n+        for (final Entry<KGroupedStreamImpl<K, ?>, Aggregator<? super K, Object, VOut>> kGroupedStream : groupPatterns.entrySet()) {\n+            final StatefulProcessorNode<K, ?> statefulProcessorNode = getStatefulProcessorNode(\n+                    initializer,\n+                    named.suffixWithOrElseGet(\n+                            \"-cogroup-agg-\" + counter++,\n+                            builder,\n+                            CogroupedKStreamImpl.AGGREGATE_NAME),\n+                    stateCreated,\n+                    storeBuilder,\n+                    new KStreamSessionWindowAggregate<>(sessionWindows, storeBuilder.name(), initializer, kGroupedStream.getValue(), sessionMerger));\n+            stateCreated = true;\n+            processors.add(statefulProcessorNode);\n+            builder.addGraphNode(parentNodes.get(kGroupedStream.getKey()), statefulProcessorNode);\n+        }\n+        return createTable(processors, named, keySerde, valueSerde, queryableName);\n+    }\n+\n+    private void build(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n+                                                       final StoreBuilder<?> storeBuilder) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8783058e2833ab07c2adf66f9badfb02f501768f"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIzNjA4MQ==", "bodyText": "I went with processRepartitions and then updated all the other methods to just be build with different parameters since that seems cleaner", "url": "https://github.com/apache/kafka/pull/9141#discussion_r467236081", "createdAt": "2020-08-07T19:44:06Z", "author": {"login": "lct45"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/CogroupedStreamAggregateBuilder.java", "diffHunk": "@@ -47,18 +47,96 @@\n     CogroupedStreamAggregateBuilder(final InternalStreamsBuilder builder) {\n         this.builder = builder;\n     }\n-\n-    <KR, VIn, W extends Window> KTable<KR, VOut> build(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n+    <KR, VIn, W extends Window> KTable<KR, VOut> buildNotWindowed(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n                                                        final Initializer<VOut> initializer,\n                                                        final NamedInternal named,\n                                                        final StoreBuilder<?> storeBuilder,\n                                                        final Serde<KR> keySerde,\n                                                        final Serde<VOut> valueSerde,\n-                                                       final String queryableName,\n-                                                       final Windows<W> windows,\n-                                                       final SessionWindows sessionWindows,\n-                                                       final Merger<? super K, VOut> sessionMerger) {\n+                                                       final String queryableName) {\n+        build(groupPatterns, storeBuilder);\n+        final Collection<StreamsGraphNode> processors = new ArrayList<>();\n+        boolean stateCreated = false;\n+        int counter = 0;\n+        for (final Entry<KGroupedStreamImpl<K, ?>, Aggregator<? super K, Object, VOut>> kGroupedStream : groupPatterns.entrySet()) {\n+            final StatefulProcessorNode<K, ?> statefulProcessorNode = getStatefulProcessorNode(\n+                    initializer,\n+                    named.suffixWithOrElseGet(\n+                            \"-cogroup-agg-\" + counter++,\n+                            builder,\n+                            CogroupedKStreamImpl.AGGREGATE_NAME),\n+                    stateCreated,\n+                    storeBuilder,\n+                    new KStreamAggregate<>(storeBuilder.name(), initializer, kGroupedStream.getValue()));\n+            stateCreated = true;\n+            processors.add(statefulProcessorNode);\n+            builder.addGraphNode(parentNodes.get(kGroupedStream.getKey()), statefulProcessorNode);\n+        }\n+        return createTable(processors, named, keySerde, valueSerde, queryableName);\n+    }\n+\n+    <KR, VIn, W extends Window> KTable<KR, VOut> buildTimeWindows(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n+                                                              final Initializer<VOut> initializer,\n+                                                              final NamedInternal named,\n+                                                              final StoreBuilder<?> storeBuilder,\n+                                                              final Serde<KR> keySerde,\n+                                                              final Serde<VOut> valueSerde,\n+                                                              final String queryableName,\n+                                                                  final Windows<W> windows) {\n+        build(groupPatterns, storeBuilder);\n \n+        final Collection<StreamsGraphNode> processors = new ArrayList<>();\n+        boolean stateCreated = false;\n+        int counter = 0;\n+        for (final Entry<KGroupedStreamImpl<K, ?>, Aggregator<? super K, Object, VOut>> kGroupedStream : groupPatterns.entrySet()) {\n+            final StatefulProcessorNode<K, ?> statefulProcessorNode = getStatefulProcessorNode(\n+                    initializer,\n+                    named.suffixWithOrElseGet(\n+                            \"-cogroup-agg-\" + counter++,\n+                            builder,\n+                            CogroupedKStreamImpl.AGGREGATE_NAME),\n+                    stateCreated,\n+                    storeBuilder,\n+                    new KStreamWindowAggregate<>(windows, storeBuilder.name(), initializer, kGroupedStream.getValue()));\n+            stateCreated = true;\n+            processors.add(statefulProcessorNode);\n+            builder.addGraphNode(parentNodes.get(kGroupedStream.getKey()), statefulProcessorNode);\n+        }\n+        return createTable(processors, named, keySerde, valueSerde, queryableName);\n+    }\n+\n+    <KR, VIn, W extends Window> KTable<KR, VOut> buildSessionWindows(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n+                                                                  final Initializer<VOut> initializer,\n+                                                                  final NamedInternal named,\n+                                                                  final StoreBuilder<?> storeBuilder,\n+                                                                  final Serde<KR> keySerde,\n+                                                                  final Serde<VOut> valueSerde,\n+                                                                  final String queryableName,\n+                                                                  final SessionWindows sessionWindows,\n+                                                                     final Merger<? super K, VOut> sessionMerger) {\n+        build(groupPatterns, storeBuilder);\n+        final Collection<StreamsGraphNode> processors = new ArrayList<>();\n+        boolean stateCreated = false;\n+        int counter = 0;\n+        for (final Entry<KGroupedStreamImpl<K, ?>, Aggregator<? super K, Object, VOut>> kGroupedStream : groupPatterns.entrySet()) {\n+            final StatefulProcessorNode<K, ?> statefulProcessorNode = getStatefulProcessorNode(\n+                    initializer,\n+                    named.suffixWithOrElseGet(\n+                            \"-cogroup-agg-\" + counter++,\n+                            builder,\n+                            CogroupedKStreamImpl.AGGREGATE_NAME),\n+                    stateCreated,\n+                    storeBuilder,\n+                    new KStreamSessionWindowAggregate<>(sessionWindows, storeBuilder.name(), initializer, kGroupedStream.getValue(), sessionMerger));\n+            stateCreated = true;\n+            processors.add(statefulProcessorNode);\n+            builder.addGraphNode(parentNodes.get(kGroupedStream.getKey()), statefulProcessorNode);\n+        }\n+        return createTable(processors, named, keySerde, valueSerde, queryableName);\n+    }\n+\n+    private void build(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n+                                                       final StoreBuilder<?> storeBuilder) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxNTcyNQ=="}, "originalCommit": {"oid": "8783058e2833ab07c2adf66f9badfb02f501768f"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxODQxNjE0OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/CogroupedStreamAggregateBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODo1ODoxOVrOG9knnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODo1ODoxOVrOG9knnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxNjI4NA==", "bodyText": "Can remove the W extends Window generic", "url": "https://github.com/apache/kafka/pull/9141#discussion_r467216284", "createdAt": "2020-08-07T18:58:19Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/CogroupedStreamAggregateBuilder.java", "diffHunk": "@@ -85,68 +163,39 @@\n         groupedStreams.remove(kGrouped);\n         kGrouped.ensureCopartitionWith(groupedStreams);\n \n-        final Collection<StreamsGraphNode> processors = new ArrayList<>();\n-        boolean stateCreated = false;\n-        int counter = 0;\n-        for (final Entry<KGroupedStreamImpl<K, ?>, Aggregator<? super K, Object, VOut>> kGroupedStream : groupPatterns.entrySet()) {\n-            final StatefulProcessorNode<K, ?> statefulProcessorNode = getStatefulProcessorNode(\n-                kGroupedStream.getValue(),\n-                initializer,\n-                named.suffixWithOrElseGet(\n-                    \"-cogroup-agg-\" + counter++,\n-                    builder,\n-                    CogroupedKStreamImpl.AGGREGATE_NAME),\n-                stateCreated,\n-                storeBuilder,\n-                windows,\n-                sessionWindows,\n-                sessionMerger);\n-            stateCreated = true;\n-            processors.add(statefulProcessorNode);\n-            builder.addGraphNode(parentNodes.get(kGroupedStream.getKey()), statefulProcessorNode);\n-        }\n+    }\n+\n+    <KR, VIn, W extends Window> KTable<KR, VOut> createTable(final Collection<StreamsGraphNode> processors,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8783058e2833ab07c2adf66f9badfb02f501768f"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxODQxOTMzOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/CogroupedStreamAggregateBuilder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODo1OToyMVrOG9kplg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxOTowNjozM1rOG9k3yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxNjc5MA==", "bodyText": "Don't need Vin here", "url": "https://github.com/apache/kafka/pull/9141#discussion_r467216790", "createdAt": "2020-08-07T18:59:21Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/CogroupedStreamAggregateBuilder.java", "diffHunk": "@@ -47,18 +47,96 @@\n     CogroupedStreamAggregateBuilder(final InternalStreamsBuilder builder) {\n         this.builder = builder;\n     }\n-\n-    <KR, VIn, W extends Window> KTable<KR, VOut> build(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n+    <KR, VIn, W extends Window> KTable<KR, VOut> buildNotWindowed(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n                                                        final Initializer<VOut> initializer,\n                                                        final NamedInternal named,\n                                                        final StoreBuilder<?> storeBuilder,\n                                                        final Serde<KR> keySerde,\n                                                        final Serde<VOut> valueSerde,\n-                                                       final String queryableName,\n-                                                       final Windows<W> windows,\n-                                                       final SessionWindows sessionWindows,\n-                                                       final Merger<? super K, VOut> sessionMerger) {\n+                                                       final String queryableName) {\n+        build(groupPatterns, storeBuilder);\n+        final Collection<StreamsGraphNode> processors = new ArrayList<>();\n+        boolean stateCreated = false;\n+        int counter = 0;\n+        for (final Entry<KGroupedStreamImpl<K, ?>, Aggregator<? super K, Object, VOut>> kGroupedStream : groupPatterns.entrySet()) {\n+            final StatefulProcessorNode<K, ?> statefulProcessorNode = getStatefulProcessorNode(\n+                    initializer,\n+                    named.suffixWithOrElseGet(\n+                            \"-cogroup-agg-\" + counter++,\n+                            builder,\n+                            CogroupedKStreamImpl.AGGREGATE_NAME),\n+                    stateCreated,\n+                    storeBuilder,\n+                    new KStreamAggregate<>(storeBuilder.name(), initializer, kGroupedStream.getValue()));\n+            stateCreated = true;\n+            processors.add(statefulProcessorNode);\n+            builder.addGraphNode(parentNodes.get(kGroupedStream.getKey()), statefulProcessorNode);\n+        }\n+        return createTable(processors, named, keySerde, valueSerde, queryableName);\n+    }\n+\n+    <KR, VIn, W extends Window> KTable<KR, VOut> buildTimeWindows(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8783058e2833ab07c2adf66f9badfb02f501768f"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIyMDQyNw==", "bodyText": "Honestly I think it's fine to just name all three of these build, since they accept different parameters and it should be pretty clear from the context whether it's windowed or not. But being more descriptive is never a bad thing either. Your call \ud83d\ude42", "url": "https://github.com/apache/kafka/pull/9141#discussion_r467220427", "createdAt": "2020-08-07T19:06:33Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/CogroupedStreamAggregateBuilder.java", "diffHunk": "@@ -47,18 +47,96 @@\n     CogroupedStreamAggregateBuilder(final InternalStreamsBuilder builder) {\n         this.builder = builder;\n     }\n-\n-    <KR, VIn, W extends Window> KTable<KR, VOut> build(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n+    <KR, VIn, W extends Window> KTable<KR, VOut> buildNotWindowed(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n                                                        final Initializer<VOut> initializer,\n                                                        final NamedInternal named,\n                                                        final StoreBuilder<?> storeBuilder,\n                                                        final Serde<KR> keySerde,\n                                                        final Serde<VOut> valueSerde,\n-                                                       final String queryableName,\n-                                                       final Windows<W> windows,\n-                                                       final SessionWindows sessionWindows,\n-                                                       final Merger<? super K, VOut> sessionMerger) {\n+                                                       final String queryableName) {\n+        build(groupPatterns, storeBuilder);\n+        final Collection<StreamsGraphNode> processors = new ArrayList<>();\n+        boolean stateCreated = false;\n+        int counter = 0;\n+        for (final Entry<KGroupedStreamImpl<K, ?>, Aggregator<? super K, Object, VOut>> kGroupedStream : groupPatterns.entrySet()) {\n+            final StatefulProcessorNode<K, ?> statefulProcessorNode = getStatefulProcessorNode(\n+                    initializer,\n+                    named.suffixWithOrElseGet(\n+                            \"-cogroup-agg-\" + counter++,\n+                            builder,\n+                            CogroupedKStreamImpl.AGGREGATE_NAME),\n+                    stateCreated,\n+                    storeBuilder,\n+                    new KStreamAggregate<>(storeBuilder.name(), initializer, kGroupedStream.getValue()));\n+            stateCreated = true;\n+            processors.add(statefulProcessorNode);\n+            builder.addGraphNode(parentNodes.get(kGroupedStream.getKey()), statefulProcessorNode);\n+        }\n+        return createTable(processors, named, keySerde, valueSerde, queryableName);\n+    }\n+\n+    <KR, VIn, W extends Window> KTable<KR, VOut> buildTimeWindows(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxNjc5MA=="}, "originalCommit": {"oid": "8783058e2833ab07c2adf66f9badfb02f501768f"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxODQyMTk3OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/CogroupedStreamAggregateBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxOTowMDoxN1rOG9krOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxOTowMDoxN1rOG9krOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIxNzIxMA==", "bodyText": "Don't need Vin and W extends Window here", "url": "https://github.com/apache/kafka/pull/9141#discussion_r467217210", "createdAt": "2020-08-07T19:00:17Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/CogroupedStreamAggregateBuilder.java", "diffHunk": "@@ -47,18 +47,96 @@\n     CogroupedStreamAggregateBuilder(final InternalStreamsBuilder builder) {\n         this.builder = builder;\n     }\n-\n-    <KR, VIn, W extends Window> KTable<KR, VOut> build(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n+    <KR, VIn, W extends Window> KTable<KR, VOut> buildNotWindowed(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n                                                        final Initializer<VOut> initializer,\n                                                        final NamedInternal named,\n                                                        final StoreBuilder<?> storeBuilder,\n                                                        final Serde<KR> keySerde,\n                                                        final Serde<VOut> valueSerde,\n-                                                       final String queryableName,\n-                                                       final Windows<W> windows,\n-                                                       final SessionWindows sessionWindows,\n-                                                       final Merger<? super K, VOut> sessionMerger) {\n+                                                       final String queryableName) {\n+        build(groupPatterns, storeBuilder);\n+        final Collection<StreamsGraphNode> processors = new ArrayList<>();\n+        boolean stateCreated = false;\n+        int counter = 0;\n+        for (final Entry<KGroupedStreamImpl<K, ?>, Aggregator<? super K, Object, VOut>> kGroupedStream : groupPatterns.entrySet()) {\n+            final StatefulProcessorNode<K, ?> statefulProcessorNode = getStatefulProcessorNode(\n+                    initializer,\n+                    named.suffixWithOrElseGet(\n+                            \"-cogroup-agg-\" + counter++,\n+                            builder,\n+                            CogroupedKStreamImpl.AGGREGATE_NAME),\n+                    stateCreated,\n+                    storeBuilder,\n+                    new KStreamAggregate<>(storeBuilder.name(), initializer, kGroupedStream.getValue()));\n+            stateCreated = true;\n+            processors.add(statefulProcessorNode);\n+            builder.addGraphNode(parentNodes.get(kGroupedStream.getKey()), statefulProcessorNode);\n+        }\n+        return createTable(processors, named, keySerde, valueSerde, queryableName);\n+    }\n+\n+    <KR, VIn, W extends Window> KTable<KR, VOut> buildTimeWindows(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n+                                                              final Initializer<VOut> initializer,\n+                                                              final NamedInternal named,\n+                                                              final StoreBuilder<?> storeBuilder,\n+                                                              final Serde<KR> keySerde,\n+                                                              final Serde<VOut> valueSerde,\n+                                                              final String queryableName,\n+                                                                  final Windows<W> windows) {\n+        build(groupPatterns, storeBuilder);\n \n+        final Collection<StreamsGraphNode> processors = new ArrayList<>();\n+        boolean stateCreated = false;\n+        int counter = 0;\n+        for (final Entry<KGroupedStreamImpl<K, ?>, Aggregator<? super K, Object, VOut>> kGroupedStream : groupPatterns.entrySet()) {\n+            final StatefulProcessorNode<K, ?> statefulProcessorNode = getStatefulProcessorNode(\n+                    initializer,\n+                    named.suffixWithOrElseGet(\n+                            \"-cogroup-agg-\" + counter++,\n+                            builder,\n+                            CogroupedKStreamImpl.AGGREGATE_NAME),\n+                    stateCreated,\n+                    storeBuilder,\n+                    new KStreamWindowAggregate<>(windows, storeBuilder.name(), initializer, kGroupedStream.getValue()));\n+            stateCreated = true;\n+            processors.add(statefulProcessorNode);\n+            builder.addGraphNode(parentNodes.get(kGroupedStream.getKey()), statefulProcessorNode);\n+        }\n+        return createTable(processors, named, keySerde, valueSerde, queryableName);\n+    }\n+\n+    <KR, VIn, W extends Window> KTable<KR, VOut> buildSessionWindows(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8783058e2833ab07c2adf66f9badfb02f501768f"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxODQ4MjI2OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/CogroupedStreamAggregateBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxOToyMToyOVrOG9lQrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxOToyMToyOVrOG9lQrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzIyNjc5Nw==", "bodyText": "This is all the same for all three methods except for the KStreamAggregate/KStreamWindowAggregate/etc right? I think if you wanted to further deduplicate things you could factor this  out into a method that accepts a Function< KGroupedStreamImpl, KStreamAggProcessorSupplier>, and then each of the build methods can just pass in a function that returns new KStreamWindowAggregate or so on.\nI'm not sure it's really worth it or not, but  it can be done in case you were wondering. Up to you whether you want to do it", "url": "https://github.com/apache/kafka/pull/9141#discussion_r467226797", "createdAt": "2020-08-07T19:21:29Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/CogroupedStreamAggregateBuilder.java", "diffHunk": "@@ -47,18 +47,96 @@\n     CogroupedStreamAggregateBuilder(final InternalStreamsBuilder builder) {\n         this.builder = builder;\n     }\n-\n-    <KR, VIn, W extends Window> KTable<KR, VOut> build(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n+    <KR, VIn, W extends Window> KTable<KR, VOut> buildNotWindowed(final Map<KGroupedStreamImpl<K, ?>, Aggregator<? super K, ? super Object, VOut>> groupPatterns,\n                                                        final Initializer<VOut> initializer,\n                                                        final NamedInternal named,\n                                                        final StoreBuilder<?> storeBuilder,\n                                                        final Serde<KR> keySerde,\n                                                        final Serde<VOut> valueSerde,\n-                                                       final String queryableName,\n-                                                       final Windows<W> windows,\n-                                                       final SessionWindows sessionWindows,\n-                                                       final Merger<? super K, VOut> sessionMerger) {\n+                                                       final String queryableName) {\n+        build(groupPatterns, storeBuilder);\n+        final Collection<StreamsGraphNode> processors = new ArrayList<>();\n+        boolean stateCreated = false;\n+        int counter = 0;\n+        for (final Entry<KGroupedStreamImpl<K, ?>, Aggregator<? super K, Object, VOut>> kGroupedStream : groupPatterns.entrySet()) {\n+            final StatefulProcessorNode<K, ?> statefulProcessorNode = getStatefulProcessorNode(\n+                    initializer,\n+                    named.suffixWithOrElseGet(\n+                            \"-cogroup-agg-\" + counter++,\n+                            builder,\n+                            CogroupedKStreamImpl.AGGREGATE_NAME),\n+                    stateCreated,\n+                    storeBuilder,\n+                    new KStreamAggregate<>(storeBuilder.name(), initializer, kGroupedStream.getValue()));\n+            stateCreated = true;\n+            processors.add(statefulProcessorNode);\n+            builder.addGraphNode(parentNodes.get(kGroupedStream.getKey()), statefulProcessorNode);\n+        }\n+        return createTable(processors, named, keySerde, valueSerde, queryableName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8783058e2833ab07c2adf66f9badfb02f501768f"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTI4MjE1OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/CogroupedStreamAggregateBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMTo1MTo0NFrOG-hDfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMTo1MTo0NFrOG-hDfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIwNjQ2Mw==", "bodyText": "It seems like your indentation is set to 8 spaces instead of 4.", "url": "https://github.com/apache/kafka/pull/9141#discussion_r468206463", "createdAt": "2020-08-10T21:51:44Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/CogroupedStreamAggregateBuilder.java", "diffHunk": "@@ -85,68 +160,38 @@\n         groupedStreams.remove(kGrouped);\n         kGrouped.ensureCopartitionWith(groupedStreams);\n \n-        final Collection<StreamsGraphNode> processors = new ArrayList<>();\n-        boolean stateCreated = false;\n-        int counter = 0;\n-        for (final Entry<KGroupedStreamImpl<K, ?>, Aggregator<? super K, Object, VOut>> kGroupedStream : groupPatterns.entrySet()) {\n-            final StatefulProcessorNode<K, ?> statefulProcessorNode = getStatefulProcessorNode(\n-                kGroupedStream.getValue(),\n-                initializer,\n-                named.suffixWithOrElseGet(\n-                    \"-cogroup-agg-\" + counter++,\n-                    builder,\n-                    CogroupedKStreamImpl.AGGREGATE_NAME),\n-                stateCreated,\n-                storeBuilder,\n-                windows,\n-                sessionWindows,\n-                sessionMerger);\n-            stateCreated = true;\n-            processors.add(statefulProcessorNode);\n-            builder.addGraphNode(parentNodes.get(kGroupedStream.getKey()), statefulProcessorNode);\n-        }\n+    }\n+\n+    <KR, VIn> KTable<KR, VOut> createTable(final Collection<StreamsGraphNode> processors,\n+                                           final NamedInternal named,\n+                                           final Serde<KR> keySerde,\n+                                           final Serde<VOut> valueSerde,\n+                                           final String queryableName) {\n         final String mergeProcessorName = named.suffixWithOrElseGet(\n-            \"-cogroup-merge\",\n-            builder,\n-            CogroupedKStreamImpl.MERGE_NAME);\n+                \"-cogroup-merge\",\n+                builder,\n+                CogroupedKStreamImpl.MERGE_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b3ef492cd07797b29aac3d3bc20d355f7e276ae"}, "originalPosition": 141}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2126, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}