{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA4NDgxNzc0", "number": 9482, "title": "KAFKA-10632; Raft client should push all committed data to state machines", "bodyText": "In #9418, we add a listener to the RaftClient interface. In that patch, we used it only to send commit notifications for writes from the leader. In this PR, we extend the handleCommit API to accept all committed data and we remove the pull-based read API. Additionally, we add two new callbacks to the listener interface in order to notify the state machine when the raft client has claimed or resigned leadership.\nFinally, this patch allows the RaftClient to support multiple listeners. This is necessary for KIP-500 because we will have one listener for the controller role and one for the broker role.\nNote this patch builds on top of #9418. Once merged, I will rebase this patch and remove draft status.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-10-22T18:32:33Z", "url": "https://github.com/apache/kafka/pull/9482", "merged": true, "mergeCommit": {"oid": "21a65e10436fc81cac0518dd4babb9612eeaf667"}, "closed": true, "closedAt": "2020-11-02T23:06:58Z", "author": {"login": "hachikuji"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdVHZstgFqTUxNTAyNTg2Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdYpO3pAH2gAyNTA4NDgxNzc0OjY1NDk0NzcxYmU1ODE5MDIxNGQ2N2QyZDI3YmRkM2Y4NTNmZGFhNmM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MDI1ODYy", "url": "https://github.com/apache/kafka/pull/9482#pullrequestreview-515025862", "createdAt": "2020-10-22T18:53:38Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxODo1MzozOFrOHmvdTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxOTo0NDoxN1rOHmxJvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4NTQ4Ng==", "bodyText": "I would remove this comment. We ca file an issue and fix it if this becomes a performance issue.", "url": "https://github.com/apache/kafka/pull/9482#discussion_r510385486", "createdAt": "2020-10-22T18:53:38Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -206,30 +234,77 @@ private void updateLeaderEndOffsetAndTimestamp(\n         final LogOffsetMetadata endOffsetMetadata = log.endOffset();\n \n         if (state.updateLocalState(currentTimeMs, endOffsetMetadata)) {\n-            updateHighWatermark(state, currentTimeMs);\n+            onUpdateLeaderHighWatermark(state, currentTimeMs);\n         }\n \n-        LogOffset endOffset = new LogOffset(endOffsetMetadata.offset, Isolation.UNCOMMITTED);\n-        fetchPurgatory.maybeComplete(endOffset, currentTimeMs);\n+        fetchPurgatory.maybeComplete(endOffsetMetadata.offset, currentTimeMs);\n     }\n \n-    private void updateHighWatermark(\n-        EpochState state,\n+    private void onUpdateLeaderHighWatermark(\n+        LeaderState state,\n         long currentTimeMs\n     ) {\n         state.highWatermark().ifPresent(highWatermark -> {\n-            logger.debug(\"High watermark updated to {}\", highWatermark);\n+            logger.debug(\"Leader high watermark updated to {}\", highWatermark);\n             log.updateHighWatermark(highWatermark);\n-\n-            LogOffset offset = new LogOffset(highWatermark.offset, Isolation.COMMITTED);\n-            appendPurgatory.maybeComplete(offset, currentTimeMs);\n-            fetchPurgatory.maybeComplete(offset, currentTimeMs);\n+            appendPurgatory.maybeComplete(highWatermark.offset, currentTimeMs);\n+            maybeFireHandleCommit(highWatermark.offset);\n         });\n     }\n \n-    @Override\n-    public LeaderAndEpoch currentLeaderAndEpoch() {\n-        return quorum.leaderAndEpoch();\n+    private void maybeFireHandleCommit(long highWatermark) {\n+        maybeFireHandleCommit(listenerContexts, highWatermark);\n+    }\n+\n+    private void maybeFireHandleCommit(List<ListenerContext> listenerContexts, long highWatermark) {\n+        // TODO: When there are multiple listeners, we can cache reads to save some work", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4NzU5Nw==", "bodyText": "Why a return? Did you mean to use continue? If this is suppose to be a continue then maybe we can Optional.ifPresent.\nSame comment for one of the other overloaded maybeFireHandleCommit.", "url": "https://github.com/apache/kafka/pull/9482#discussion_r510387597", "createdAt": "2020-10-22T18:57:15Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -206,30 +234,77 @@ private void updateLeaderEndOffsetAndTimestamp(\n         final LogOffsetMetadata endOffsetMetadata = log.endOffset();\n \n         if (state.updateLocalState(currentTimeMs, endOffsetMetadata)) {\n-            updateHighWatermark(state, currentTimeMs);\n+            onUpdateLeaderHighWatermark(state, currentTimeMs);\n         }\n \n-        LogOffset endOffset = new LogOffset(endOffsetMetadata.offset, Isolation.UNCOMMITTED);\n-        fetchPurgatory.maybeComplete(endOffset, currentTimeMs);\n+        fetchPurgatory.maybeComplete(endOffsetMetadata.offset, currentTimeMs);\n     }\n \n-    private void updateHighWatermark(\n-        EpochState state,\n+    private void onUpdateLeaderHighWatermark(\n+        LeaderState state,\n         long currentTimeMs\n     ) {\n         state.highWatermark().ifPresent(highWatermark -> {\n-            logger.debug(\"High watermark updated to {}\", highWatermark);\n+            logger.debug(\"Leader high watermark updated to {}\", highWatermark);\n             log.updateHighWatermark(highWatermark);\n-\n-            LogOffset offset = new LogOffset(highWatermark.offset, Isolation.COMMITTED);\n-            appendPurgatory.maybeComplete(offset, currentTimeMs);\n-            fetchPurgatory.maybeComplete(offset, currentTimeMs);\n+            appendPurgatory.maybeComplete(highWatermark.offset, currentTimeMs);\n+            maybeFireHandleCommit(highWatermark.offset);\n         });\n     }\n \n-    @Override\n-    public LeaderAndEpoch currentLeaderAndEpoch() {\n-        return quorum.leaderAndEpoch();\n+    private void maybeFireHandleCommit(long highWatermark) {\n+        maybeFireHandleCommit(listenerContexts, highWatermark);\n+    }\n+\n+    private void maybeFireHandleCommit(List<ListenerContext> listenerContexts, long highWatermark) {\n+        // TODO: When there are multiple listeners, we can cache reads to save some work\n+        for (ListenerContext listenerContext : listenerContexts) {\n+            OptionalLong nextExpectedOffsetOpt = listenerContext.nextExpectedOffset();\n+            if (!nextExpectedOffsetOpt.isPresent()) {\n+                return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5NzE3OQ==", "bodyText": "Interesting. It is good to hide this logic from the state machine. Looking at the epoch and not at the LEO is okay because at this point we guarantee that the only records with that epoch are control records (e.g. LeaderChangedMessage).\nI am wondering if the state machine may want to know this before it can process state machine requests. Maybe this is okay because the brokers/replicas will learn about the new leader through the Fetch and BeginQuorum protocol and not from the state machine (Kafka Controller) itself.\nIt is possible that the leader will receive Kafka Controller message from replicas/broker before it knows that it is leader. Most likely the Kafka Controller will reject them but the replicas/brokers need to keep retrying. This is specially important for heartbeat messages.", "url": "https://github.com/apache/kafka/pull/9482#discussion_r510397179", "createdAt": "2020-10-22T19:13:59Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -206,30 +234,77 @@ private void updateLeaderEndOffsetAndTimestamp(\n         final LogOffsetMetadata endOffsetMetadata = log.endOffset();\n \n         if (state.updateLocalState(currentTimeMs, endOffsetMetadata)) {\n-            updateHighWatermark(state, currentTimeMs);\n+            onUpdateLeaderHighWatermark(state, currentTimeMs);\n         }\n \n-        LogOffset endOffset = new LogOffset(endOffsetMetadata.offset, Isolation.UNCOMMITTED);\n-        fetchPurgatory.maybeComplete(endOffset, currentTimeMs);\n+        fetchPurgatory.maybeComplete(endOffsetMetadata.offset, currentTimeMs);\n     }\n \n-    private void updateHighWatermark(\n-        EpochState state,\n+    private void onUpdateLeaderHighWatermark(\n+        LeaderState state,\n         long currentTimeMs\n     ) {\n         state.highWatermark().ifPresent(highWatermark -> {\n-            logger.debug(\"High watermark updated to {}\", highWatermark);\n+            logger.debug(\"Leader high watermark updated to {}\", highWatermark);\n             log.updateHighWatermark(highWatermark);\n-\n-            LogOffset offset = new LogOffset(highWatermark.offset, Isolation.COMMITTED);\n-            appendPurgatory.maybeComplete(offset, currentTimeMs);\n-            fetchPurgatory.maybeComplete(offset, currentTimeMs);\n+            appendPurgatory.maybeComplete(highWatermark.offset, currentTimeMs);\n+            maybeFireHandleCommit(highWatermark.offset);\n         });\n     }\n \n-    @Override\n-    public LeaderAndEpoch currentLeaderAndEpoch() {\n-        return quorum.leaderAndEpoch();\n+    private void maybeFireHandleCommit(long highWatermark) {\n+        maybeFireHandleCommit(listenerContexts, highWatermark);\n+    }\n+\n+    private void maybeFireHandleCommit(List<ListenerContext> listenerContexts, long highWatermark) {\n+        // TODO: When there are multiple listeners, we can cache reads to save some work\n+        for (ListenerContext listenerContext : listenerContexts) {\n+            OptionalLong nextExpectedOffsetOpt = listenerContext.nextExpectedOffset();\n+            if (!nextExpectedOffsetOpt.isPresent()) {\n+                return;\n+            }\n+\n+            long nextExpectedOffset = nextExpectedOffsetOpt.getAsLong();\n+            if (nextExpectedOffset < highWatermark) {\n+                LogFetchInfo readInfo = log.read(nextExpectedOffset, Isolation.COMMITTED);\n+                listenerContext.fireHandleCommit(nextExpectedOffset, readInfo.records);\n+            }\n+        }\n+    }\n+\n+    private void maybeFireHandleCommit(long baseOffset, int epoch, List<T> records) {\n+        for (ListenerContext listenerContext : listenerContexts) {\n+            OptionalLong nextExpectedOffsetOpt = listenerContext.nextExpectedOffset();\n+            if (!nextExpectedOffsetOpt.isPresent()) {\n+                return;\n+            }\n+\n+            long nextExpectedOffset = nextExpectedOffsetOpt.getAsLong();\n+            if (nextExpectedOffset == baseOffset) {\n+                listenerContext.fireHandleCommit(baseOffset, epoch, records);\n+            }\n+        }\n+    }\n+\n+    private void maybeFireHandleClaim(LeaderState state) {\n+        for (ListenerContext listenerContext : listenerContexts) {\n+            int leaderEpoch = state.epoch();\n+\n+            // We can fire `handleClaim` as soon as the listener has caught\n+            // up to the start of the leader epoch. This guarantees that the\n+            // state machine has seen the full committed state before it becomes\n+            // leader and begins writing to the log.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5ODkwMg==", "bodyText": "Incomplete sentence.", "url": "https://github.com/apache/kafka/pull/9482#discussion_r510398902", "createdAt": "2020-10-22T19:17:12Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -975,12 +1029,9 @@ private boolean handleFetchResponse(\n                 log.truncateToEndOffset(divergingOffsetAndEpoch).ifPresent(truncationOffset -> {\n                     logger.info(\"Truncated to offset {} from Fetch response from leader {}\",\n                         truncationOffset, quorum.leaderIdOrNil());\n-\n-                    // Since the end offset has been updated, we should complete any delayed\n-                    // reads at the end offset.\n-                    fetchPurgatory.maybeComplete(\n-                        new LogOffset(Long.MAX_VALUE, Isolation.UNCOMMITTED),\n-                        currentTimeMs);\n+                    // After truncation, we complete all pending reads in order to\n+                    // ensure that fetches account for the", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 467}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwNDU5Ng==", "bodyText": "Does this mean that in practice, follower will have at most two batches in flight?\n\nThe one that they are currently processing\nIf they read the last message/record in the batch then the next batch in the log?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r510404596", "createdAt": "2020-10-22T19:28:11Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1757,35 +1809,86 @@ public void complete() {\n         }\n     }\n \n-    private static class UnwrittenAppend {\n-        private final Records records;\n-        private final long createTimeMs;\n-        private final long requestTimeoutMs;\n-        private final AckMode ackMode;\n-        private final CompletableFuture<OffsetAndEpoch> future;\n+    private final class ListenerContext implements CloseListener<BatchReader<T>> {\n+        private final RaftClient.Listener<T> listener;\n+        private BatchReader<T> lastSent = null;\n+        private long lastAckedOffset = 0;\n+        private int claimedEpoch = 0;\n+\n+        private ListenerContext(Listener<T> listener) {\n+            this.listener = listener;\n+        }\n+\n+        /**\n+         * Get the last acked offset, which is one greater than the offset of the\n+         * last record which was acked by the state machine.\n+         */\n+        public synchronized long lastAckedOffset() {\n+            return lastAckedOffset;\n+        }\n+\n+        /**\n+         * Get the next expected offset, which might be larger than the last acked\n+         * offset if there are inflight batches which have not been acked yet.\n+         * Note that when fetching from disk, we may not know the last offset of\n+         * inflight data until it has been processed by the state machine. In this case,\n+         * we delay sending additional data until the state machine has read to the\n+         * end and the last offset is determined.", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 754}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwODM2Mg==", "bodyText": "What is \"this\" in this sentence? epochStartOffset?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r510408362", "createdAt": "2020-10-22T19:35:08Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/QuorumState.java", "diffHunk": "@@ -369,6 +379,17 @@ public void transitionToLeader(long epochStartOffset) throws IOException {\n         if (!candidateState.isVoteGranted())\n             throw new IllegalStateException(\"Cannot become leader without majority votes granted\");\n \n+        // Note that the leader does not retain the high watermark that was known\n+        // in the previous state. The purpose of this is to protect the monotonicity", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQwOTA2Mw==", "bodyText": "nit: \"... must be iterated and closed\".", "url": "https://github.com/apache/kafka/pull/9482#discussion_r510409063", "createdAt": "2020-10-22T19:36:29Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/RaftClient.java", "diffHunk": "@@ -16,57 +16,75 @@\n  */\n package org.apache.kafka.raft;\n \n-import org.apache.kafka.common.record.Records;\n-\n import java.io.IOException;\n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n \n-public interface RaftClient {\n+public interface RaftClient<T> {\n+\n+    interface Listener<T> {\n+        /**\n+         * Callback which is invoked for all records committed to the log.\n+         * It is the responsibility of the caller to invoke {@link BatchReader#close()}\n+         * after consuming the reader.\n+         *\n+         * Note that there is not a one-to-one correspondence between writes through\n+         * {@link #scheduleAppend(int, List)} and this callback. The Raft implementation\n+         * is free to batch together the records from multiple append calls provided\n+         * that batch boundaries are respected. This means that each batch specified\n+         * through {@link #scheduleAppend(int, List)} is guaranteed to be a subset of\n+         * a batch provided by the {@link BatchReader}.\n+         *\n+         * @param reader reader instance which must be iterated", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMTYwMw==", "bodyText": "We should also mention that MAX_VALUE is return if the RaftClient is not the leader.", "url": "https://github.com/apache/kafka/pull/9482#discussion_r510411603", "createdAt": "2020-10-22T19:41:11Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/RaftClient.java", "diffHunk": "@@ -16,57 +16,75 @@\n  */\n package org.apache.kafka.raft;\n \n-import org.apache.kafka.common.record.Records;\n-\n import java.io.IOException;\n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n \n-public interface RaftClient {\n+public interface RaftClient<T> {\n+\n+    interface Listener<T> {\n+        /**\n+         * Callback which is invoked for all records committed to the log.\n+         * It is the responsibility of the caller to invoke {@link BatchReader#close()}\n+         * after consuming the reader.\n+         *\n+         * Note that there is not a one-to-one correspondence between writes through\n+         * {@link #scheduleAppend(int, List)} and this callback. The Raft implementation\n+         * is free to batch together the records from multiple append calls provided\n+         * that batch boundaries are respected. This means that each batch specified\n+         * through {@link #scheduleAppend(int, List)} is guaranteed to be a subset of\n+         * a batch provided by the {@link BatchReader}.\n+         *\n+         * @param reader reader instance which must be iterated\n+         */\n+        void handleCommit(BatchReader<T> reader);\n+\n+        /**\n+         * Invoked after this node has become a leader. This is only called after\n+         * all commits up to the start of the leader's epoch have been sent to\n+         * {@link #handleCommit(BatchReader)}.\n+         *\n+         * After becoming a leader, the client is eligible to write to the log\n+         * using {@link #scheduleAppend(int, List)}.\n+         *\n+         * @param epoch the claimed leader epoch\n+         */\n+        default void handleClaim(int epoch) {}\n+\n+        /**\n+         * Invoked after a leader has stepped down. This callback may or may not\n+         * fire before the next leader has been elected.\n+         */\n+        default void handleResign() {}\n+    }\n \n     /**\n-     * Initialize the client. This should only be called once and it must be\n-     * called before any of the other APIs can be invoked.\n+     * Initialize the client. This should only be called once on startup.\n      *\n      * @throws IOException For any IO errors during initialization\n      */\n     void initialize() throws IOException;\n \n     /**\n-     * Append a new entry to the log. The client must be in the leader state to\n-     * accept an append: it is up to the state machine implementation\n-     * to ensure this using {@link #currentLeaderAndEpoch()}.\n-     *\n-     * TODO: One improvement we can make here is to allow the caller to specify\n-     * the current leader epoch in the record set. That would ensure that each\n-     * leader change must be \"observed\" by the state machine before new appends\n-     * are accepted.\n-     *\n-     * @param records The records to append to the log\n-     * @param timeoutMs Maximum time to wait for the append to complete\n-     * @return A future containing the last offset and epoch of the appended records (if successful)\n-     */\n-    CompletableFuture<OffsetAndEpoch> append(Records records, AckMode ackMode, long timeoutMs);\n-\n-    /**\n-     * Read a set of records from the log. Note that it is the responsibility of the state machine\n-     * to filter control records added by the Raft client itself.\n-     *\n-     * If the fetch offset is no longer valid, then the future will be completed exceptionally\n-     * with a {@link LogTruncationException}.\n+     * Register a listener to get commit/leader notifications.\n      *\n-     * @param position The position to fetch from\n-     * @param isolation The isolation level to apply to the read\n-     * @param maxWaitTimeMs The maximum time to wait for new data to become available before completion\n-     * @return The record set, which may be empty if fetching from the end of the log\n+     * @param listener the listener\n      */\n-    CompletableFuture<Records> read(OffsetAndEpoch position, Isolation isolation, long maxWaitTimeMs);\n+    void register(Listener<T> listener);\n \n     /**\n-     * Get the current leader (if known) and the current epoch.\n+     * Append a list of records to the log. The write will be scheduled for some time\n+     * in the future. There is no guarantee that appended records will be written to\n+     * the log and eventually committed. However, it is guaranteed that if any of the\n+     * records become committed, then all of them will be.\n      *\n-     * @return Current leader and epoch information\n+     * @param epoch the current leader epoch\n+     * @param records the list of records to append\n+     * @return the offset within the current epoch that the log entries will be appended,\n+     *         or null if the leader was unable to accept the write (e.g. due to memory\n+     *         being reached).", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMjUwNQ==", "bodyText": "I think it is okay as the fix may be non-trivial but technically scheduleAppend will accept records even if no Listener has received a handleClaim.", "url": "https://github.com/apache/kafka/pull/9482#discussion_r510412505", "createdAt": "2020-10-22T19:43:01Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/RaftClient.java", "diffHunk": "@@ -16,57 +16,75 @@\n  */\n package org.apache.kafka.raft;\n \n-import org.apache.kafka.common.record.Records;\n-\n import java.io.IOException;\n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n \n-public interface RaftClient {\n+public interface RaftClient<T> {\n+\n+    interface Listener<T> {\n+        /**\n+         * Callback which is invoked for all records committed to the log.\n+         * It is the responsibility of the caller to invoke {@link BatchReader#close()}\n+         * after consuming the reader.\n+         *\n+         * Note that there is not a one-to-one correspondence between writes through\n+         * {@link #scheduleAppend(int, List)} and this callback. The Raft implementation\n+         * is free to batch together the records from multiple append calls provided\n+         * that batch boundaries are respected. This means that each batch specified\n+         * through {@link #scheduleAppend(int, List)} is guaranteed to be a subset of\n+         * a batch provided by the {@link BatchReader}.\n+         *\n+         * @param reader reader instance which must be iterated\n+         */\n+        void handleCommit(BatchReader<T> reader);\n+\n+        /**\n+         * Invoked after this node has become a leader. This is only called after\n+         * all commits up to the start of the leader's epoch have been sent to\n+         * {@link #handleCommit(BatchReader)}.\n+         *\n+         * After becoming a leader, the client is eligible to write to the log\n+         * using {@link #scheduleAppend(int, List)}.\n+         *\n+         * @param epoch the claimed leader epoch\n+         */\n+        default void handleClaim(int epoch) {}\n+\n+        /**\n+         * Invoked after a leader has stepped down. This callback may or may not\n+         * fire before the next leader has been elected.\n+         */\n+        default void handleResign() {}\n+    }\n \n     /**\n-     * Initialize the client. This should only be called once and it must be\n-     * called before any of the other APIs can be invoked.\n+     * Initialize the client. This should only be called once on startup.\n      *\n      * @throws IOException For any IO errors during initialization\n      */\n     void initialize() throws IOException;\n \n     /**\n-     * Append a new entry to the log. The client must be in the leader state to\n-     * accept an append: it is up to the state machine implementation\n-     * to ensure this using {@link #currentLeaderAndEpoch()}.\n-     *\n-     * TODO: One improvement we can make here is to allow the caller to specify\n-     * the current leader epoch in the record set. That would ensure that each\n-     * leader change must be \"observed\" by the state machine before new appends\n-     * are accepted.\n-     *\n-     * @param records The records to append to the log\n-     * @param timeoutMs Maximum time to wait for the append to complete\n-     * @return A future containing the last offset and epoch of the appended records (if successful)\n-     */\n-    CompletableFuture<OffsetAndEpoch> append(Records records, AckMode ackMode, long timeoutMs);\n-\n-    /**\n-     * Read a set of records from the log. Note that it is the responsibility of the state machine\n-     * to filter control records added by the Raft client itself.\n-     *\n-     * If the fetch offset is no longer valid, then the future will be completed exceptionally\n-     * with a {@link LogTruncationException}.\n+     * Register a listener to get commit/leader notifications.\n      *\n-     * @param position The position to fetch from\n-     * @param isolation The isolation level to apply to the read\n-     * @param maxWaitTimeMs The maximum time to wait for new data to become available before completion\n-     * @return The record set, which may be empty if fetching from the end of the log\n+     * @param listener the listener\n      */\n-    CompletableFuture<Records> read(OffsetAndEpoch position, Isolation isolation, long maxWaitTimeMs);\n+    void register(Listener<T> listener);\n \n     /**\n-     * Get the current leader (if known) and the current epoch.\n+     * Append a list of records to the log. The write will be scheduled for some time\n+     * in the future. There is no guarantee that appended records will be written to\n+     * the log and eventually committed. However, it is guaranteed that if any of the\n+     * records become committed, then all of them will be.\n      *\n-     * @return Current leader and epoch information\n+     * @param epoch the current leader epoch\n+     * @param records the list of records to append\n+     * @return the offset within the current epoch that the log entries will be appended,\n+     *         or null if the leader was unable to accept the write (e.g. due to memory\n+     *         being reached).\n      */\n-    LeaderAndEpoch currentLeaderAndEpoch();\n+    Long scheduleAppend(int epoch, List<T> records);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQxMzI0NA==", "bodyText": "TODO: missing comments.", "url": "https://github.com/apache/kafka/pull/9482#discussion_r510413244", "createdAt": "2020-10-22T19:44:17Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/RecordSerde.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.raft;\n+\n+import org.apache.kafka.common.protocol.DataOutputStreamWritable;\n+import org.apache.kafka.common.protocol.Readable;\n+\n+public interface RecordSerde<T> {\n+    /**\n+     * Create a new context object for to be used when serializing a batch of records.\n+     * This allows for state to be shared between {@link #recordSize(Object, Object)}\n+     * and {@link #write(Object, Object, DataOutputStreamWritable)}, which is useful\n+     * in order to avoid redundant work (see e.g.\n+     * {@link org.apache.kafka.common.protocol.ObjectSerializationCache}).\n+     *\n+     * @return context object or null if none is needed\n+     */\n+    default Object newWriteContext() {\n+        return null;\n+    }\n+\n+    /**\n+     * Get the size of a record.\n+     *\n+     * @param data the record that will be serialized\n+     * @param context context object created by {@link #newWriteContext()}\n+     * @return the size in bytes of the serialized record\n+     */\n+    int recordSize(T data, Object context);\n+\n+\n+    /**\n+     * Write the record to the output stream.\n+     *\n+     * @param data the record to serialize and write\n+     * @param context context object created by {@link #newWriteContext()}\n+     * @param out the output stream to write the record to\n+     */\n+    void write(T data, Object context, DataOutputStreamWritable out);\n+\n+    /**\n+     *\n+     * @param input\n+     * @param size\n+     * @return\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 60}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "348a14bb40f9d3db022e68f01b607c49270e48cf", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/348a14bb40f9d3db022e68f01b607c49270e48cf", "committedDate": "2020-10-27T23:20:25Z", "message": "KAFKA-10632; Raft client should push all committed data to state machine"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "348a14bb40f9d3db022e68f01b607c49270e48cf", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/348a14bb40f9d3db022e68f01b607c49270e48cf", "committedDate": "2020-10-27T23:20:25Z", "message": "KAFKA-10632; Raft client should push all committed data to state machine"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84cfc2fed4c6fe488ce68ad8ebd3c5cf0b447b39", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/84cfc2fed4c6fe488ce68ad8ebd3c5cf0b447b39", "committedDate": "2020-10-27T23:25:52Z", "message": "Remove unused `DataInputReadable`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a7dced63aac4b8db2165ff186c577d714a2c936", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/9a7dced63aac4b8db2165ff186c577d714a2c936", "committedDate": "2020-10-28T00:51:08Z", "message": "Ensure supplied buffers are released by `RecordsBatchReader`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "62eac1a0b20805cd1fad3be9901e68db0590bfea", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/62eac1a0b20805cd1fad3be9901e68db0590bfea", "committedDate": "2020-10-28T00:58:42Z", "message": "Add missing license header"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba8994d20aea177086c089a01f20fcef290ff44b", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/ba8994d20aea177086c089a01f20fcef290ff44b", "committedDate": "2020-10-28T01:22:50Z", "message": "tweak shutdown error message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d8134ea7de896ed804dca8fa8b25216f1c4323f", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/6d8134ea7de896ed804dca8fa8b25216f1c4323f", "committedDate": "2020-10-28T01:30:55Z", "message": "Fix metric names in `TestRaftServer`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/1345f566ff9265c4072f2129bf6c477946c4407c", "committedDate": "2020-10-28T03:23:13Z", "message": "Use kafka metrics in workload generator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MzMzMDEz", "url": "https://github.com/apache/kafka/pull/9482#pullrequestreview-518333013", "createdAt": "2020-10-28T05:26:00Z", "commit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwNToyNjowMFrOHpaiUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODowNjoxOFrOHqoYjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE4ODQzMw==", "bodyText": "Why do we change these values to debug?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513188433", "createdAt": "2020-10-28T05:26:00Z", "author": {"login": "abbccdda"}, "path": "clients/src/main/java/org/apache/kafka/common/metrics/stats/Percentiles.java", "diffHunk": "@@ -113,11 +113,11 @@ protected HistogramSample newSample(long timeMs) {\n     protected void update(Sample sample, MetricConfig config, double value, long timeMs) {\n         final double boundedValue;\n         if (value > max) {\n-            log.warn(\"Received value {} which is greater than max recordable value {}, will be pinned to the max value\",\n+            log.debug(\"Received value {} which is greater than max recordable value {}, will be pinned to the max value\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIwMDAxMA==", "bodyText": "nit: we could refactor out the try-catch logic.", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513200010", "createdAt": "2020-10-28T06:06:18Z", "author": {"login": "abbccdda"}, "path": "clients/src/main/java/org/apache/kafka/common/protocol/DataInputStreamReadable.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.protocol;\n+\n+import org.apache.kafka.common.utils.ByteUtils;\n+\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+public class DataInputStreamReadable implements Readable, Closeable {\n+    protected final DataInputStream input;\n+\n+    public DataInputStreamReadable(DataInputStream input) {\n+        this.input = input;\n+    }\n+\n+    @Override\n+    public byte readByte() {\n+        try {\n+            return input.readByte();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public short readShort() {\n+        try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIwMDE0OA==", "bodyText": "Why do we wrap the IO exception here?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513200148", "createdAt": "2020-10-28T06:06:49Z", "author": {"login": "abbccdda"}, "path": "clients/src/main/java/org/apache/kafka/common/protocol/DataInputStreamReadable.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.protocol;\n+\n+import org.apache.kafka.common.utils.ByteUtils;\n+\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+public class DataInputStreamReadable implements Readable, Closeable {\n+    protected final DataInputStream input;\n+\n+    public DataInputStreamReadable(DataInputStream input) {\n+        this.input = input;\n+    }\n+\n+    @Override\n+    public byte readByte() {\n+        try {\n+            return input.readByte();\n+        } catch (IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIwNjEyOA==", "bodyText": "We couldn't be sure whether the records could be read as string?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513206128", "createdAt": "2020-10-28T06:26:51Z", "author": {"login": "abbccdda"}, "path": "raft/src/main/java/org/apache/kafka/raft/BatchReader.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.raft;\n+\n+import java.io.Closeable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.OptionalLong;\n+\n+/**\n+ * This interface is used to send committed data from the {@link RaftClient}\n+ * down to registered {@link RaftClient.Listener} instances.\n+ *\n+ * The advantage of hiding the consumption of committed batches behind an interface\n+ * is that it allows us to push blocking operations such as reads from disk outside\n+ * of the Raft IO thread. This helps to ensure that a slow state machine will not\n+ * affect replication.\n+ *\n+ * @param <T> record type (see {@link org.apache.kafka.raft.RecordSerde})\n+ */\n+public interface BatchReader<T> extends Iterator<BatchReader.Batch<T>>, Closeable {\n+\n+    /**\n+     * Get the base offset of the readable batches. Note that this value is a constant\n+     * which is defined when the {@link BatchReader} instance is constructed. It does\n+     * not change based on reader progress.\n+     *\n+     * @return the base offset\n+     */\n+    long baseOffset();\n+\n+    /**\n+     * Get the last offset of the batch if it is known. When reading from disk, we may\n+     * not know the last offset of a set of records until it has been read from disk.\n+     * In this case, the state machine cannot advance to the next committed data until\n+     * all batches from the {@link BatchReader} instance have been consumed.\n+     *\n+     * @return optional last offset\n+     */\n+    OptionalLong lastOffset();\n+\n+    /**\n+     * Close this reader. It is the responsibility of the {@link RaftClient.Listener}\n+     * to close each reader passed to {@link RaftClient.Listener#handleCommit(BatchReader)}.\n+     */\n+    @Override\n+    void close();\n+\n+    class Batch<T> {\n+        private final long baseOffset;\n+        private final int epoch;\n+        private final List<T> records;\n+\n+        public Batch(long baseOffset, int epoch, List<T> records) {\n+            this.baseOffset = baseOffset;\n+            this.epoch = epoch;\n+            this.records = records;\n+        }\n+\n+        public long lastOffset() {\n+            return baseOffset + records.size() - 1;\n+        }\n+\n+        public long baseOffset() {\n+            return baseOffset;\n+        }\n+\n+        public List<T> records() {\n+            return records;\n+        }\n+\n+        public int epoch() {\n+            return epoch;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Batch(\" +\n+                \"baseOffset=\" + baseOffset +\n+                \", epoch=\" + epoch +\n+                \", records=\" + records +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIwNjk4Mw==", "bodyText": "Do we compare the value or the address of records?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513206983", "createdAt": "2020-10-28T06:29:33Z", "author": {"login": "abbccdda"}, "path": "raft/src/main/java/org/apache/kafka/raft/BatchReader.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.raft;\n+\n+import java.io.Closeable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.OptionalLong;\n+\n+/**\n+ * This interface is used to send committed data from the {@link RaftClient}\n+ * down to registered {@link RaftClient.Listener} instances.\n+ *\n+ * The advantage of hiding the consumption of committed batches behind an interface\n+ * is that it allows us to push blocking operations such as reads from disk outside\n+ * of the Raft IO thread. This helps to ensure that a slow state machine will not\n+ * affect replication.\n+ *\n+ * @param <T> record type (see {@link org.apache.kafka.raft.RecordSerde})\n+ */\n+public interface BatchReader<T> extends Iterator<BatchReader.Batch<T>>, Closeable {\n+\n+    /**\n+     * Get the base offset of the readable batches. Note that this value is a constant\n+     * which is defined when the {@link BatchReader} instance is constructed. It does\n+     * not change based on reader progress.\n+     *\n+     * @return the base offset\n+     */\n+    long baseOffset();\n+\n+    /**\n+     * Get the last offset of the batch if it is known. When reading from disk, we may\n+     * not know the last offset of a set of records until it has been read from disk.\n+     * In this case, the state machine cannot advance to the next committed data until\n+     * all batches from the {@link BatchReader} instance have been consumed.\n+     *\n+     * @return optional last offset\n+     */\n+    OptionalLong lastOffset();\n+\n+    /**\n+     * Close this reader. It is the responsibility of the {@link RaftClient.Listener}\n+     * to close each reader passed to {@link RaftClient.Listener#handleCommit(BatchReader)}.\n+     */\n+    @Override\n+    void close();\n+\n+    class Batch<T> {\n+        private final long baseOffset;\n+        private final int epoch;\n+        private final List<T> records;\n+\n+        public Batch(long baseOffset, int epoch, List<T> records) {\n+            this.baseOffset = baseOffset;\n+            this.epoch = epoch;\n+            this.records = records;\n+        }\n+\n+        public long lastOffset() {\n+            return baseOffset + records.size() - 1;\n+        }\n+\n+        public long baseOffset() {\n+            return baseOffset;\n+        }\n+\n+        public List<T> records() {\n+            return records;\n+        }\n+\n+        public int epoch() {\n+            return epoch;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Batch(\" +\n+                \"baseOffset=\" + baseOffset +\n+                \", epoch=\" + epoch +\n+                \", records=\" + records +\n+                ')';\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Batch<?> batch = (Batch<?>) o;\n+            return baseOffset == batch.baseOffset &&\n+                epoch == batch.epoch &&\n+                Objects.equals(records, batch.records);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIwNzg4MA==", "bodyText": "after the provided timeout passes if it is not completed/ if not completed within the provided time limit", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513207880", "createdAt": "2020-10-28T06:32:32Z", "author": {"login": "abbccdda"}, "path": "raft/src/main/java/org/apache/kafka/raft/ExpirationService.java", "diffHunk": "@@ -16,11 +16,17 @@\n  */\n package org.apache.kafka.raft;\n \n-import org.apache.kafka.common.KafkaException;\n+import java.util.concurrent.CompletableFuture;\n \n-public class LogTruncationException extends KafkaException {\n-\n-    public LogTruncationException(String message) {\n-        super(message);\n-    }\n+public interface ExpirationService {\n+    /**\n+     * Get a new completable future which will automatically expire with a\n+     * {@link org.apache.kafka.common.errors.TimeoutException} after the provided\n+     * timeout passes if it is not completed before then through some other means.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIxMDQ0OQ==", "bodyText": "it does not could be removed.", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513210449", "createdAt": "2020-10-28T06:40:23Z", "author": {"login": "abbccdda"}, "path": "raft/src/main/java/org/apache/kafka/raft/QuorumState.java", "diffHunk": "@@ -369,6 +379,17 @@ public void transitionToLeader(long epochStartOffset) throws IOException {\n         if (!candidateState.isVoteGranted())\n             throw new IllegalStateException(\"Cannot become leader without majority votes granted\");\n \n+        // Note that the leader does not retain the high watermark that was known\n+        // in the previous state. The reason it does not is to protect the monotonicity", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMDg5NA==", "bodyText": "Should we add description to the exception?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513630894", "createdAt": "2020-10-28T17:27:17Z", "author": {"login": "abbccdda"}, "path": "raft/src/main/java/org/apache/kafka/raft/internals/MemoryBatchReader.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.raft.internals;\n+\n+import org.apache.kafka.raft.BatchReader;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.OptionalLong;\n+\n+public class MemoryBatchReader<T> implements BatchReader<T> {\n+    private final CloseListener<BatchReader<T>> closeListener;\n+    private final Iterator<Batch<T>> iterator;\n+    private final long baseOffset;\n+    private final long lastOffset;\n+\n+    public MemoryBatchReader(\n+        List<Batch<T>> batches,\n+        CloseListener<BatchReader<T>> closeListener\n+    ) {\n+        if (batches.isEmpty()) {\n+            throw new IllegalArgumentException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMjM5Mg==", "bodyText": "How do we decide to use either record batch reader or memory batch reader?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513632392", "createdAt": "2020-10-28T17:29:24Z", "author": {"login": "abbccdda"}, "path": "raft/src/main/java/org/apache/kafka/raft/internals/RecordsBatchReader.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.raft.internals;\n+\n+import org.apache.kafka.common.protocol.DataInputStreamReadable;\n+import org.apache.kafka.common.protocol.Readable;\n+import org.apache.kafka.common.record.BufferSupplier;\n+import org.apache.kafka.common.record.DefaultRecordBatch;\n+import org.apache.kafka.common.record.FileRecords;\n+import org.apache.kafka.common.record.MemoryRecords;\n+import org.apache.kafka.common.record.MutableRecordBatch;\n+import org.apache.kafka.common.record.Records;\n+import org.apache.kafka.raft.BatchReader;\n+import org.apache.kafka.raft.RecordSerde;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.OptionalLong;\n+\n+public class RecordsBatchReader<T> implements BatchReader<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkyMjc1MA==", "bodyText": "Do we have other types of threshold than Long?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r513922750", "createdAt": "2020-10-29T03:36:01Z", "author": {"login": "abbccdda"}, "path": "raft/src/main/java/org/apache/kafka/raft/internals/ThresholdPurgatory.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.raft.internals;\n+\n+import org.apache.kafka.raft.ExpirationService;\n+\n+import java.util.NavigableMap;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentNavigableMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class ThresholdPurgatory<T extends Comparable<T>> implements FuturePurgatory<T> {\n+    private final AtomicLong idGenerator = new AtomicLong(0);\n+    private final ExpirationService expirationService;\n+    private final ConcurrentNavigableMap<ThresholdKey<T>, CompletableFuture<Long>> thresholdMap =\n+        new ConcurrentSkipListMap<>();\n+\n+    public ThresholdPurgatory(ExpirationService expirationService) {\n+        this.expirationService = expirationService;\n+    }\n+\n+    @Override\n+    public CompletableFuture<Long> await(T threshold, long maxWaitTimeMs) {\n+        ThresholdKey<T> key = new ThresholdKey<>(idGenerator.incrementAndGet(), threshold);\n+        CompletableFuture<Long> future = expirationService.await(maxWaitTimeMs);\n+        thresholdMap.put(key, future);\n+        future.whenComplete((timeMs, exception) -> thresholdMap.remove(key));\n+        return future;\n+    }\n+\n+    @Override\n+    public void maybeComplete(T value, long currentTimeMs) {\n+        ThresholdKey<T> maxKey = new ThresholdKey<>(Long.MAX_VALUE, value);\n+        NavigableMap<ThresholdKey<T>, CompletableFuture<Long>> submap = thresholdMap.headMap(maxKey);\n+        for (CompletableFuture<Long> completion : submap.values()) {\n+            completion.complete(currentTimeMs);\n+        }\n+    }\n+\n+    @Override\n+    public void completeAll(long currentTimeMs) {\n+        for (CompletableFuture<Long> completion : thresholdMap.values()) {\n+            completion.complete(currentTimeMs);\n+        }\n+    }\n+\n+    @Override\n+    public void completeAllExceptionally(Throwable exception) {\n+        for (CompletableFuture<Long> completion : thresholdMap.values()) {\n+            completion.completeExceptionally(exception);\n+        }\n+    }\n+\n+    @Override\n+    public int numWaiting() {\n+        return thresholdMap.size();\n+    }\n+\n+    private static class ThresholdKey<T extends Comparable<T>> implements Comparable<ThresholdKey<T>> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDAyNzAxNQ==", "bodyText": "Why do we need to repeatedly get leader epoch?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514027015", "createdAt": "2020-10-29T06:43:19Z", "author": {"login": "abbccdda"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -228,35 +234,81 @@ private void updateLeaderEndOffsetAndTimestamp(\n         final LogOffsetMetadata endOffsetMetadata = log.endOffset();\n \n         if (state.updateLocalState(currentTimeMs, endOffsetMetadata)) {\n-            updateHighWatermark(state, currentTimeMs);\n+            onUpdateLeaderHighWatermark(state, currentTimeMs);\n         }\n \n-        LogOffset endOffset = new LogOffset(endOffsetMetadata.offset, Isolation.UNCOMMITTED);\n-        fetchPurgatory.maybeComplete(endOffset, currentTimeMs);\n+        fetchPurgatory.maybeComplete(endOffsetMetadata.offset, currentTimeMs);\n     }\n \n-    private void updateHighWatermark(\n-        EpochState state,\n+    private void onUpdateLeaderHighWatermark(\n+        LeaderState state,\n         long currentTimeMs\n     ) {\n         state.highWatermark().ifPresent(highWatermark -> {\n-            logger.debug(\"High watermark updated to {}\", highWatermark);\n+            logger.debug(\"Leader high watermark updated to {}\", highWatermark);\n             log.updateHighWatermark(highWatermark);\n-\n-            LogOffset offset = new LogOffset(highWatermark.offset, Isolation.COMMITTED);\n-            appendPurgatory.maybeComplete(offset, currentTimeMs);\n-            fetchPurgatory.maybeComplete(offset, currentTimeMs);\n+            appendPurgatory.maybeComplete(highWatermark.offset, currentTimeMs);\n+            maybeFireHandleCommit(highWatermark.offset);\n         });\n     }\n \n-    @Override\n-    public LeaderAndEpoch currentLeaderAndEpoch() {\n-        return quorum.leaderAndEpoch();\n+    private void maybeFireHandleCommit(long highWatermark) {\n+        maybeFireHandleCommit(listenerContexts, highWatermark);\n+    }\n+\n+    private void maybeFireHandleCommit(List<ListenerContext> listenerContexts, long highWatermark) {\n+        // TODO: When there are multiple listeners, we can cache reads to save some work\n+        for (ListenerContext listenerContext : listenerContexts) {\n+            OptionalLong nextExpectedOffsetOpt = listenerContext.nextExpectedOffset();\n+            if (!nextExpectedOffsetOpt.isPresent()) {\n+                continue;\n+            }\n+\n+            long nextExpectedOffset = nextExpectedOffsetOpt.getAsLong();\n+            if (nextExpectedOffset < highWatermark) {\n+                LogFetchInfo readInfo = log.read(nextExpectedOffset, Isolation.COMMITTED);\n+                listenerContext.fireHandleCommit(nextExpectedOffset, readInfo.records);\n+            }\n+        }\n+    }\n+\n+    private void maybeFireHandleCommit(long baseOffset, int epoch, List<T> records) {\n+        for (ListenerContext listenerContext : listenerContexts) {\n+            OptionalLong nextExpectedOffsetOpt = listenerContext.nextExpectedOffset();\n+            if (!nextExpectedOffsetOpt.isPresent()) {\n+                continue;\n+            }\n+\n+            long nextExpectedOffset = nextExpectedOffsetOpt.getAsLong();\n+            if (nextExpectedOffset == baseOffset) {\n+                listenerContext.fireHandleCommit(baseOffset, epoch, records);\n+            }\n+        }\n+    }\n+\n+    private void maybeFireHandleClaim(LeaderState state) {\n+        for (ListenerContext listenerContext : listenerContexts) {\n+            int leaderEpoch = state.epoch();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1MjE0MA==", "bodyText": "It looks a bit weird to have two versions of fire handle commit, could we name them differently or comment about their distinctive logics for determining when to fire commit callback?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514452140", "createdAt": "2020-10-29T17:48:13Z", "author": {"login": "abbccdda"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -228,35 +234,81 @@ private void updateLeaderEndOffsetAndTimestamp(\n         final LogOffsetMetadata endOffsetMetadata = log.endOffset();\n \n         if (state.updateLocalState(currentTimeMs, endOffsetMetadata)) {\n-            updateHighWatermark(state, currentTimeMs);\n+            onUpdateLeaderHighWatermark(state, currentTimeMs);\n         }\n \n-        LogOffset endOffset = new LogOffset(endOffsetMetadata.offset, Isolation.UNCOMMITTED);\n-        fetchPurgatory.maybeComplete(endOffset, currentTimeMs);\n+        fetchPurgatory.maybeComplete(endOffsetMetadata.offset, currentTimeMs);\n     }\n \n-    private void updateHighWatermark(\n-        EpochState state,\n+    private void onUpdateLeaderHighWatermark(\n+        LeaderState state,\n         long currentTimeMs\n     ) {\n         state.highWatermark().ifPresent(highWatermark -> {\n-            logger.debug(\"High watermark updated to {}\", highWatermark);\n+            logger.debug(\"Leader high watermark updated to {}\", highWatermark);\n             log.updateHighWatermark(highWatermark);\n-\n-            LogOffset offset = new LogOffset(highWatermark.offset, Isolation.COMMITTED);\n-            appendPurgatory.maybeComplete(offset, currentTimeMs);\n-            fetchPurgatory.maybeComplete(offset, currentTimeMs);\n+            appendPurgatory.maybeComplete(highWatermark.offset, currentTimeMs);\n+            maybeFireHandleCommit(highWatermark.offset);\n         });\n     }\n \n-    @Override\n-    public LeaderAndEpoch currentLeaderAndEpoch() {\n-        return quorum.leaderAndEpoch();\n+    private void maybeFireHandleCommit(long highWatermark) {\n+        maybeFireHandleCommit(listenerContexts, highWatermark);\n+    }\n+\n+    private void maybeFireHandleCommit(List<ListenerContext> listenerContexts, long highWatermark) {\n+        // TODO: When there are multiple listeners, we can cache reads to save some work\n+        for (ListenerContext listenerContext : listenerContexts) {\n+            OptionalLong nextExpectedOffsetOpt = listenerContext.nextExpectedOffset();\n+            if (!nextExpectedOffsetOpt.isPresent()) {\n+                continue;\n+            }\n+\n+            long nextExpectedOffset = nextExpectedOffsetOpt.getAsLong();\n+            if (nextExpectedOffset < highWatermark) {\n+                LogFetchInfo readInfo = log.read(nextExpectedOffset, Isolation.COMMITTED);\n+                listenerContext.fireHandleCommit(nextExpectedOffset, readInfo.records);\n+            }\n+        }\n+    }\n+\n+    private void maybeFireHandleCommit(long baseOffset, int epoch, List<T> records) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1NjMzMQ==", "bodyText": "Why would this work? If the flush wasn't successful, could the fetched records be invalidated later?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514456331", "createdAt": "2020-10-29T17:54:30Z", "author": {"login": "abbccdda"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -329,8 +387,9 @@ private void appendLeaderChangeMessage(LeaderState state, long currentTimeMs) {\n     }\n \n     private void flushLeaderLog(LeaderState state, long currentTimeMs) {\n-        log.flush();\n+        // We update the end offset before flushing so that parked fetches can return sooner", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1OTUzNA==", "bodyText": "Do we anticipate use cases to add listeners on the fly? Right now I could only see one case in static context from test raft server.", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514459534", "createdAt": "2020-10-29T17:59:30Z", "author": {"login": "abbccdda"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1688,14 +1694,39 @@ private long pollCurrentState(long currentTimeMs) throws IOException {\n         }\n     }\n \n+    private void pollListeners() {\n+        // Register any listeners added since the last poll\n+        while (!pendingListeners.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "originalPosition": 422}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ2MzIzMQ==", "bodyText": "Should we call pollListeners after pollCurrentState to get more recent updates quicker?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514463231", "createdAt": "2020-10-29T18:05:17Z", "author": {"login": "abbccdda"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1688,14 +1694,39 @@ private long pollCurrentState(long currentTimeMs) throws IOException {\n         }\n     }\n \n+    private void pollListeners() {\n+        // Register any listeners added since the last poll\n+        while (!pendingListeners.isEmpty()) {\n+            Listener<T> listener = pendingListeners.poll();\n+            listenerContexts.add(new ListenerContext(listener));\n+        }\n+\n+        // Check listener progress to see if reads are expected\n+        quorum.highWatermark().ifPresent(highWatermarkMetadata -> {\n+            long highWatermark = highWatermarkMetadata.offset;\n+\n+            List<ListenerContext> listenersToUpdate = listenerContexts.stream()\n+                .filter(listenerContext -> {\n+                    OptionalLong nextExpectedOffset = listenerContext.nextExpectedOffset();\n+                    return nextExpectedOffset.isPresent() && nextExpectedOffset.getAsLong() < highWatermark;\n+                })\n+                .collect(Collectors.toList());\n+\n+            maybeFireHandleCommit(listenersToUpdate, highWatermarkMetadata.offset);\n+        });\n+    }\n+\n     public void poll() throws IOException {\n         GracefulShutdown gracefulShutdown = shutdown.get();\n         if (gracefulShutdown != null) {\n             pollShutdown(gracefulShutdown);\n         } else {\n+            pollListeners();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "originalPosition": 447}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ2Mzg4NQ==", "bodyText": "What about just name as handleBecomeLeader?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514463885", "createdAt": "2020-10-29T18:06:18Z", "author": {"login": "abbccdda"}, "path": "raft/src/main/java/org/apache/kafka/raft/RaftClient.java", "diffHunk": "@@ -26,30 +24,53 @@\n \n     interface Listener<T> {\n         /**\n-         * Callback which is invoked when records written through {@link #scheduleAppend(int, List)}\n-         * become committed.\n+         * Callback which is invoked for all records committed to the log.\n+         * It is the responsibility of the caller to invoke {@link BatchReader#close()}\n+         * after consuming the reader.\n          *\n          * Note that there is not a one-to-one correspondence between writes through\n          * {@link #scheduleAppend(int, List)} and this callback. The Raft implementation\n          * is free to batch together the records from multiple append calls provided\n          * that batch boundaries are respected. This means that each batch specified\n          * through {@link #scheduleAppend(int, List)} is guaranteed to be a subset of\n-         * a batch passed to {@link #handleCommit(int, long, List)}.\n+         * a batch provided by the {@link BatchReader}.\n+         *\n+         * @param reader reader instance which must be iterated and closed\n+         */\n+        void handleCommit(BatchReader<T> reader);\n+\n+        /**\n+         * Invoked after this node has become a leader. This is only called after\n+         * all commits up to the start of the leader's epoch have been sent to\n+         * {@link #handleCommit(BatchReader)}.\n+         *\n+         * After becoming a leader, the client is eligible to write to the log\n+         * using {@link #scheduleAppend(int, List)}.\n          *\n-         * @param epoch the epoch in which the write was accepted\n-         * @param lastOffset the offset of the last record in the record list\n-         * @param records the set of records that were committed\n+         * @param epoch the claimed leader epoch\n          */\n-        void handleCommit(int epoch, long lastOffset, List<T> records);\n+        default void handleClaim(int epoch) {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5OTY1NTA5", "url": "https://github.com/apache/kafka/pull/9482#pullrequestreview-519965509", "createdAt": "2020-10-29T18:36:19Z", "commit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODozNjoxOVrOHqphdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxODozNjoxOVrOHqphdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ4MjU1MQ==", "bodyText": "Could we make 200L a constant?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r514482551", "createdAt": "2020-10-29T18:36:19Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/raft/TimingWheelExpirationService.scala", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.raft\n+\n+import java.util.concurrent.CompletableFuture\n+\n+import kafka.raft.TimingWheelExpirationService.TimerTaskCompletableFuture\n+import kafka.utils.ShutdownableThread\n+import kafka.utils.timer.{Timer, TimerTask}\n+import org.apache.kafka.common.errors.TimeoutException\n+import org.apache.kafka.raft.ExpirationService\n+\n+object TimingWheelExpirationService {\n+  class TimerTaskCompletableFuture[T](override val delayMs: Long) extends CompletableFuture[T] with TimerTask {\n+    override def run(): Unit = {\n+      completeExceptionally(new TimeoutException(\n+        s\"Future failed to be completed before timeout of $delayMs ms was reached\"))\n+    }\n+  }\n+}\n+\n+class TimingWheelExpirationService(timer: Timer) extends ExpirationService {\n+  private val expirationReaper = new ExpiredOperationReaper()\n+\n+  expirationReaper.start()\n+\n+  override def await[T](timeoutMs: Long): CompletableFuture[T] = {\n+    val future = new TimerTaskCompletableFuture[T](timeoutMs)\n+    future.whenComplete { (_, _) =>\n+      future.cancel()\n+    }\n+    timer.add(future)\n+    future\n+  }\n+\n+  private class ExpiredOperationReaper extends ShutdownableThread(\n+    name = \"raft-expiration-reaper\", isInterruptible = false) {\n+\n+    override def doWork(): Unit = {\n+      timer.advanceClock(200L)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "originalPosition": 54}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c4b31ad898e083a354ebf648f334ac7db7e59a6", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/7c4b31ad898e083a354ebf648f334ac7db7e59a6", "committedDate": "2020-10-29T21:45:59Z", "message": "Address Boyang's comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "867650fa2344497ac3f3505bd5058f2eae0cc0c4", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/867650fa2344497ac3f3505bd5058f2eae0cc0c4", "committedDate": "2020-10-29T22:11:17Z", "message": "Fix unused import in `TimingWheelExpirationService`"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMDc4MTE3", "url": "https://github.com/apache/kafka/pull/9482#pullrequestreview-521078117", "createdAt": "2020-10-30T23:01:45Z", "commit": {"oid": "867650fa2344497ac3f3505bd5058f2eae0cc0c4"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMzowMTo0NVrOHrij8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMVQwMToyMTozOFrOHrj5JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQxNzA3Mg==", "bodyText": "How about extending java.lang.Iterable<...> instead of Iterator? This will allow the user to use BatchReader::forEach.", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515417072", "createdAt": "2020-10-30T23:01:45Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/BatchReader.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.raft;\n+\n+import java.io.Closeable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.OptionalLong;\n+\n+/**\n+ * This interface is used to send committed data from the {@link RaftClient}\n+ * down to registered {@link RaftClient.Listener} instances.\n+ *\n+ * The advantage of hiding the consumption of committed batches behind an interface\n+ * is that it allows us to push blocking operations such as reads from disk outside\n+ * of the Raft IO thread. This helps to ensure that a slow state machine will not\n+ * affect replication.\n+ *\n+ * @param <T> record type (see {@link org.apache.kafka.raft.RecordSerde})\n+ */\n+public interface BatchReader<T> extends Iterator<BatchReader.Batch<T>>, Closeable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "867650fa2344497ac3f3505bd5058f2eae0cc0c4"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQxNzU3MA==", "bodyText": "If we are overriding close to not throw an IOException, then maybe extending java.lang.AutoCloseable instead of java.io.Closeable is better.", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515417570", "createdAt": "2020-10-30T23:04:07Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/BatchReader.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.raft;\n+\n+import java.io.Closeable;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.OptionalLong;\n+\n+/**\n+ * This interface is used to send committed data from the {@link RaftClient}\n+ * down to registered {@link RaftClient.Listener} instances.\n+ *\n+ * The advantage of hiding the consumption of committed batches behind an interface\n+ * is that it allows us to push blocking operations such as reads from disk outside\n+ * of the Raft IO thread. This helps to ensure that a slow state machine will not\n+ * affect replication.\n+ *\n+ * @param <T> record type (see {@link org.apache.kafka.raft.RecordSerde})\n+ */\n+public interface BatchReader<T> extends Iterator<BatchReader.Batch<T>>, Closeable {\n+\n+    /**\n+     * Get the base offset of the readable batches. Note that this value is a constant\n+     * which is defined when the {@link BatchReader} instance is constructed. It does\n+     * not change based on reader progress.\n+     *\n+     * @return the base offset\n+     */\n+    long baseOffset();\n+\n+    /**\n+     * Get the last offset of the batch if it is known. When reading from disk, we may\n+     * not know the last offset of a set of records until it has been read from disk.\n+     * In this case, the state machine cannot advance to the next committed data until\n+     * all batches from the {@link BatchReader} instance have been consumed.\n+     *\n+     * @return optional last offset\n+     */\n+    OptionalLong lastOffset();\n+\n+    /**\n+     * Close this reader. It is the responsibility of the {@link RaftClient.Listener}\n+     * to close each reader passed to {@link RaftClient.Listener#handleCommit(BatchReader)}.\n+     */\n+    @Override\n+    void close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "867650fa2344497ac3f3505bd5058f2eae0cc0c4"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQyMzI0MQ==", "bodyText": "Yeah. You want to force an epoch change in the case that the old leader stays leader and partially replicated data was lost. This would force followers to truncate to the new leader's log state.", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515423241", "createdAt": "2020-10-30T23:31:36Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -329,8 +387,9 @@ private void appendLeaderChangeMessage(LeaderState state, long currentTimeMs) {\n     }\n \n     private void flushLeaderLog(LeaderState state, long currentTimeMs) {\n-        log.flush();\n+        // We update the end offset before flushing so that parked fetches can return sooner", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ1NjMzMQ=="}, "originalCommit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQyNzAxOQ==", "bodyText": "With the new Listener when is this not a noop? Looking at the code, we only add entries to fetchPurgatorywhen the replica is a leader and it receives a Fetch request.\nIn previous read based implementation we needed this because I think the fetchPurgatory contained both reads and Fetch.\nI think the part that is missing is that the old leader should fetchPurgatory.completeAll when it loses leadership.\nWhat do you think?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515427019", "createdAt": "2020-10-30T23:52:15Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1017,12 +1028,9 @@ private boolean handleFetchResponse(\n                 log.truncateToEndOffset(divergingOffsetAndEpoch).ifPresent(truncationOffset -> {\n                     logger.info(\"Truncated to offset {} from Fetch response from leader {}\",\n                         truncationOffset, quorum.leaderIdOrNil());\n-\n-                    // Since the end offset has been updated, we should complete any delayed\n-                    // reads at the end offset.\n-                    fetchPurgatory.maybeComplete(\n-                        new LogOffset(Long.MAX_VALUE, Isolation.UNCOMMITTED),\n-                        currentTimeMs);\n+                    // After truncation, we complete all pending reads in order to\n+                    // ensure that fetches account for the updated log end offset\n+                    fetchPurgatory.completeAll(currentTimeMs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "867650fa2344497ac3f3505bd5058f2eae0cc0c4"}, "originalPosition": 368}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzMDAyOQ==", "bodyText": "Is this needed because users of KafkaRaftClient can call ::register before ::initizalize? When else would this result on a call to Listener::handleCommit?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515430029", "createdAt": "2020-10-31T00:10:50Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -228,35 +234,80 @@ private void updateLeaderEndOffsetAndTimestamp(\n         final LogOffsetMetadata endOffsetMetadata = log.endOffset();\n \n         if (state.updateLocalState(currentTimeMs, endOffsetMetadata)) {\n-            updateHighWatermark(state, currentTimeMs);\n+            onUpdateLeaderHighWatermark(state, currentTimeMs);\n         }\n \n-        LogOffset endOffset = new LogOffset(endOffsetMetadata.offset, Isolation.UNCOMMITTED);\n-        fetchPurgatory.maybeComplete(endOffset, currentTimeMs);\n+        fetchPurgatory.maybeComplete(endOffsetMetadata.offset, currentTimeMs);\n     }\n \n-    private void updateHighWatermark(\n-        EpochState state,\n+    private void onUpdateLeaderHighWatermark(\n+        LeaderState state,\n         long currentTimeMs\n     ) {\n         state.highWatermark().ifPresent(highWatermark -> {\n-            logger.debug(\"High watermark updated to {}\", highWatermark);\n+            logger.debug(\"Leader high watermark updated to {}\", highWatermark);\n             log.updateHighWatermark(highWatermark);\n-\n-            LogOffset offset = new LogOffset(highWatermark.offset, Isolation.COMMITTED);\n-            appendPurgatory.maybeComplete(offset, currentTimeMs);\n-            fetchPurgatory.maybeComplete(offset, currentTimeMs);\n+            appendPurgatory.maybeComplete(highWatermark.offset, currentTimeMs);\n+            maybeFireHandleCommit(highWatermark.offset);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "867650fa2344497ac3f3505bd5058f2eae0cc0c4"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzMTMyOQ==", "bodyText": "Never mind. I think this can happens when the replica changes state from follower to leader.\nI was having an issue if doing this would cause both appendPurgatory.maybeComplete and maybeFireHandleCommit to fire Listener.handleCommit for the same listener.\nI don't think this can happened based on how ListenerContext is managing the nextExpectedOffset. If appendPurgator.maybeComplete fires then that means that nextExpectedOffset is greater that the high watermark. Since the nextExpectedOffset is greater than the high watermark then maybeFireHandleCommit will not fire.\nI actually think that this order is important. Should we write a comment on the code explaining this if you agree with my analysis?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515431329", "createdAt": "2020-10-31T00:19:44Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -228,35 +234,80 @@ private void updateLeaderEndOffsetAndTimestamp(\n         final LogOffsetMetadata endOffsetMetadata = log.endOffset();\n \n         if (state.updateLocalState(currentTimeMs, endOffsetMetadata)) {\n-            updateHighWatermark(state, currentTimeMs);\n+            onUpdateLeaderHighWatermark(state, currentTimeMs);\n         }\n \n-        LogOffset endOffset = new LogOffset(endOffsetMetadata.offset, Isolation.UNCOMMITTED);\n-        fetchPurgatory.maybeComplete(endOffset, currentTimeMs);\n+        fetchPurgatory.maybeComplete(endOffsetMetadata.offset, currentTimeMs);\n     }\n \n-    private void updateHighWatermark(\n-        EpochState state,\n+    private void onUpdateLeaderHighWatermark(\n+        LeaderState state,\n         long currentTimeMs\n     ) {\n         state.highWatermark().ifPresent(highWatermark -> {\n-            logger.debug(\"High watermark updated to {}\", highWatermark);\n+            logger.debug(\"Leader high watermark updated to {}\", highWatermark);\n             log.updateHighWatermark(highWatermark);\n-\n-            LogOffset offset = new LogOffset(highWatermark.offset, Isolation.COMMITTED);\n-            appendPurgatory.maybeComplete(offset, currentTimeMs);\n-            fetchPurgatory.maybeComplete(offset, currentTimeMs);\n+            appendPurgatory.maybeComplete(highWatermark.offset, currentTimeMs);\n+            maybeFireHandleCommit(highWatermark.offset);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzMDAyOQ=="}, "originalCommit": {"oid": "867650fa2344497ac3f3505bd5058f2eae0cc0c4"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzMzY4Ng==", "bodyText": "That looks correct to me with the clarification that \"in response to a request\" has two cases:\n\nThe leader handles a fetch request. This implementation calls \"update high watermark\nThe follower handle a fetch response. This implementation calls \"update high watermark\"\n\nI think that pollListeners should only fire a Listener::handleCommit for new listeners in pendingListeners.", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515433686", "createdAt": "2020-10-31T00:36:35Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1688,14 +1694,39 @@ private long pollCurrentState(long currentTimeMs) throws IOException {\n         }\n     }\n \n+    private void pollListeners() {\n+        // Register any listeners added since the last poll\n+        while (!pendingListeners.isEmpty()) {\n+            Listener<T> listener = pendingListeners.poll();\n+            listenerContexts.add(new ListenerContext(listener));\n+        }\n+\n+        // Check listener progress to see if reads are expected\n+        quorum.highWatermark().ifPresent(highWatermarkMetadata -> {\n+            long highWatermark = highWatermarkMetadata.offset;\n+\n+            List<ListenerContext> listenersToUpdate = listenerContexts.stream()\n+                .filter(listenerContext -> {\n+                    OptionalLong nextExpectedOffset = listenerContext.nextExpectedOffset();\n+                    return nextExpectedOffset.isPresent() && nextExpectedOffset.getAsLong() < highWatermark;\n+                })\n+                .collect(Collectors.toList());\n+\n+            maybeFireHandleCommit(listenersToUpdate, highWatermarkMetadata.offset);\n+        });\n+    }\n+\n     public void poll() throws IOException {\n         GracefulShutdown gracefulShutdown = shutdown.get();\n         if (gracefulShutdown != null) {\n             pollShutdown(gracefulShutdown);\n         } else {\n+            pollListeners();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ2MzIzMQ=="}, "originalCommit": {"oid": "1345f566ff9265c4072f2129bf6c477946c4407c"}, "originalPosition": 447}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzNDY3NA==", "bodyText": "I would document that synchronized is protecting lastSent and lastAckedOffset.\nclaimedEpoch is okay because it is only used by the thread calling RaftClient::poll.", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515434674", "createdAt": "2020-10-31T00:44:13Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1778,4 +1808,98 @@ public void complete() {\n         }\n     }\n \n+    private final class ListenerContext implements CloseListener<BatchReader<T>> {\n+        private final RaftClient.Listener<T> listener;\n+        private BatchReader<T> lastSent = null;\n+        private long lastAckedOffset = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "867650fa2344497ac3f3505bd5058f2eae0cc0c4"}, "originalPosition": 462}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzNTE5Mg==", "bodyText": "Interesting that Java let's the outer class (KafkaRaftClient) access this private method. This makes reasoning about the concurrency non-trivial.", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515435192", "createdAt": "2020-10-31T00:48:16Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1778,4 +1808,98 @@ public void complete() {\n         }\n     }\n \n+    private final class ListenerContext implements CloseListener<BatchReader<T>> {\n+        private final RaftClient.Listener<T> listener;\n+        private BatchReader<T> lastSent = null;\n+        private long lastAckedOffset = 0;\n+        private int claimedEpoch = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "867650fa2344497ac3f3505bd5058f2eae0cc0c4"}, "originalPosition": 463}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzNjk3Mg==", "bodyText": "How about failAfter?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515436972", "createdAt": "2020-10-31T01:03:40Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/ExpirationService.java", "diffHunk": "@@ -16,11 +16,17 @@\n  */\n package org.apache.kafka.raft;\n \n-import org.apache.kafka.common.KafkaException;\n+import java.util.concurrent.CompletableFuture;\n \n-public class LogTruncationException extends KafkaException {\n-\n-    public LogTruncationException(String message) {\n-        super(message);\n-    }\n+public interface ExpirationService {\n+    /**\n+     * Get a new completable future which will automatically fail exceptionally with a\n+     * {@link org.apache.kafka.common.errors.TimeoutException} if not completed before\n+     * the provided time limit expires.\n+     *\n+     * @param timeoutMs the duration in milliseconds before the future is completed exceptionally\n+     * @param <T> arbitrary future type (the service must set no expectation on the this type)\n+     * @return the completable future\n+     */\n+    <T> CompletableFuture<T> await(long timeoutMs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "867650fa2344497ac3f3505bd5058f2eae0cc0c4"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQzODg4NA==", "bodyText": "This applies to all of the listener.handle... on this file.\nWhat are your thoughts on the Listener throwing an exception? I think with this implementation it will unwind all the way until KafakRaftClient::poll. Should we catch all non-fatal exceptions here and log an error instead?", "url": "https://github.com/apache/kafka/pull/9482#discussion_r515438884", "createdAt": "2020-10-31T01:21:38Z", "author": {"login": "jsancio"}, "path": "raft/src/main/java/org/apache/kafka/raft/KafkaRaftClient.java", "diffHunk": "@@ -1778,4 +1808,98 @@ public void complete() {\n         }\n     }\n \n+    private final class ListenerContext implements CloseListener<BatchReader<T>> {\n+        private final RaftClient.Listener<T> listener;\n+        private BatchReader<T> lastSent = null;\n+        private long lastAckedOffset = 0;\n+        private int claimedEpoch = 0;\n+\n+        private ListenerContext(Listener<T> listener) {\n+            this.listener = listener;\n+        }\n+\n+        /**\n+         * Get the last acked offset, which is one greater than the offset of the\n+         * last record which was acked by the state machine.\n+         */\n+        public synchronized long lastAckedOffset() {\n+            return lastAckedOffset;\n+        }\n+\n+        /**\n+         * Get the next expected offset, which might be larger than the last acked\n+         * offset if there are inflight batches which have not been acked yet.\n+         * Note that when fetching from disk, we may not know the last offset of\n+         * inflight data until it has been processed by the state machine. In this case,\n+         * we delay sending additional data until the state machine has read to the\n+         * end and the last offset is determined.\n+         */\n+        public synchronized OptionalLong nextExpectedOffset() {\n+            if (lastSent != null) {\n+                OptionalLong lastSentOffset = lastSent.lastOffset();\n+                if (lastSentOffset.isPresent()) {\n+                    return OptionalLong.of(lastSentOffset.getAsLong() + 1);\n+                } else {\n+                    return OptionalLong.empty();\n+                }\n+            } else {\n+                return OptionalLong.of(lastAckedOffset);\n+            }\n+        }\n+\n+        /**\n+         * This API is used for committed records that have been received through\n+         * replication. In general, followers will write new data to disk before they\n+         * know whether it has been committed. Rather than retaining the uncommitted\n+         * data in memory, we let the state machine read the records from disk.\n+         */\n+        public void fireHandleCommit(long baseOffset, Records records) {\n+            BufferSupplier bufferSupplier = BufferSupplier.create();\n+            RecordsBatchReader<T> reader = new RecordsBatchReader<>(baseOffset, records,\n+                serde, bufferSupplier, this);\n+            fireHandleCommit(reader);\n+        }\n+\n+        /**\n+         * This API is used for committed records originating from {@link #scheduleAppend(int, List)}\n+         * on this instance. In this case, we are able to save the original record objects,\n+         * which saves the need to read them back from disk. This is a nice optimization\n+         * for the leader which is typically doing more work than all of the followers.\n+         */\n+        public void fireHandleCommit(long baseOffset, int epoch, List<T> records) {\n+            BatchReader.Batch<T> batch = new BatchReader.Batch<>(baseOffset, epoch, records);\n+            MemoryBatchReader<T> reader = new MemoryBatchReader<>(Collections.singletonList(batch), this);\n+            fireHandleCommit(reader);\n+        }\n+\n+        private void fireHandleCommit(BatchReader<T> reader) {\n+            synchronized (this) {\n+                this.lastSent = reader;\n+            }\n+            listener.handleCommit(reader);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "867650fa2344497ac3f3505bd5058f2eae0cc0c4"}, "originalPosition": 527}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMTk1MTA2", "url": "https://github.com/apache/kafka/pull/9482#pullrequestreview-521195106", "createdAt": "2020-11-01T05:59:49Z", "commit": {"oid": "867650fa2344497ac3f3505bd5058f2eae0cc0c4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e3600e16a72c139cd89ef194b4e503983b47cdb", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/7e3600e16a72c139cd89ef194b4e503983b47cdb", "committedDate": "2020-11-02T18:26:05Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc30f4f97055c8b3f543560205f1fe597107116a", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/dc30f4f97055c8b3f543560205f1fe597107116a", "committedDate": "2020-11-02T18:39:46Z", "message": "Add basic test case for mock expiration service"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "dc30f4f97055c8b3f543560205f1fe597107116a", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/dc30f4f97055c8b3f543560205f1fe597107116a", "committedDate": "2020-11-02T18:39:46Z", "message": "Add basic test case for mock expiration service"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65494771be58190214d67d2d27bdd3f853fdaa6c", "author": {"user": {"login": "hachikuji", "name": "Jason Gustafson"}}, "url": "https://github.com/apache/kafka/commit/65494771be58190214d67d2d27bdd3f853fdaa6c", "committedDate": "2020-11-02T18:53:46Z", "message": "Fix typo in comment"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2849, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}