{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0MjQxODM0", "number": 8364, "title": "MINOR: Partition is under reassignment when adding and removing", "bodyText": "A partition is under reassignment if the either the set of adding\nreplicas or set removing replicas is non-empty.\nFix the test assertion such that it prints stdout on failure.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-03-26T15:28:15Z", "url": "https://github.com/apache/kafka/pull/8364", "merged": true, "mergeCommit": {"oid": "d63eaaaa0181bb7b9b4f5ed088abc00d7b32aeb0"}, "closed": true, "closedAt": "2020-04-26T02:31:41Z", "author": {"login": "jsancio"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRyMkzgFqTM4Mjk0NzU5OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABca5Fy_AFqTQwMDMwMjM4MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTQ3NTk4", "url": "https://github.com/apache/kafka/pull/8364#pullrequestreview-382947598", "createdAt": "2020-03-27T15:11:46Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNToxMTo0NlrOF81jJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNToxMTo0NlrOF81jJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzNjIzMQ==", "bodyText": "Why would we have URPs in the first place? Reassignment should not cause URPs now, right?", "url": "https://github.com/apache/kafka/pull/8364#discussion_r399336231", "createdAt": "2020-03-27T15:11:46Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/admin/TopicCommandWithAdminClientTest.scala", "diffHunk": "@@ -680,9 +680,14 @@ class TopicCommandWithAdminClientTest extends KafkaServerTestHarness with Loggin\n     assertTrue(simpleDescribeOutputRows(0).startsWith(s\"Topic: $testTopicName\"))\n     assertEquals(2, simpleDescribeOutputRows.size)\n \n-    val underReplicatedOutput = TestUtils.grabConsoleOutput(\n-      topicService.describeTopic(new TopicCommandOptions(Array(\"--under-replicated-partitions\"))))\n-    assertEquals(\"--under-replicated-partitions shouldn't return anything\", \"\", underReplicatedOutput)\n+    TestUtils.waitUntilTrue(\n+      () => {\n+        val underReplicatedOutput = TestUtils.grabConsoleOutput(\n+          topicService.describeTopic(new TopicCommandOptions(Array(\"--under-replicated-partitions\"))))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 10}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MjM4Njgw", "url": "https://github.com/apache/kafka/pull/8364#pullrequestreview-384238680", "createdAt": "2020-03-30T21:19:20Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMToxOToyMVrOF98n4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMToxOToyMVrOF98n4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUwMDcwNg==", "bodyText": "Nit: Int.unbox -> _.intValue?", "url": "https://github.com/apache/kafka/pull/8364#discussion_r400500706", "createdAt": "2020-03-30T21:19:21Z", "author": {"login": "ijuma"}, "path": "core/src/main/scala/kafka/admin/TopicCommand.scala", "diffHunk": "@@ -563,10 +563,10 @@ object TopicCommand extends Logging {\n     // It is possible for a reassignment to complete between the time we have fetched its state and the time\n     // we fetch partition metadata. In ths case, we ignore the reassignment when determining replication factor.\n     def isReassignmentInProgress(ra: PartitionReassignment): Boolean = {\n-      // Reassignment is still in progress as long as the removing replicas are still present\n+      // Reassignment is still in progress as long as the removing and adding replicas are still present\n       val allReplicaIds = tpi.replicas.asScala.map(_.id).toSet\n-      val removingReplicaIds = ra.removingReplicas.asScala.map(Int.unbox).toSet\n-      allReplicaIds.exists(removingReplicaIds.contains)\n+      val changingReplicaIds = ra.removingReplicas.asScala.map(Int.unbox).toSet ++ ra.addingReplicas.asScala.map(Int.unbox).toSet", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MTI5NDc4", "url": "https://github.com/apache/kafka/pull/8364#pullrequestreview-385129478", "createdAt": "2020-03-31T21:48:50Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTo0ODo1MFrOF-pfPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTo0ODo1MFrOF-pfPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzNTc3NA==", "bodyText": "This file was actually moved/renamed to core/src/test/scala/unit/kafka/admin/TopicCommandWithZKClientTest.scala", "url": "https://github.com/apache/kafka/pull/8364#discussion_r401235774", "createdAt": "2020-03-31T21:48:50Z", "author": {"login": "jsancio"}, "path": "core/src/test/scala/unit/kafka/admin/TopicCommandTest.scala", "diffHunk": "@@ -16,585 +16,41 @@\n  */", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MTI5OTIz", "url": "https://github.com/apache/kafka/pull/8364#pullrequestreview-385129923", "createdAt": "2020-03-31T21:49:37Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTo0OTozN1rOF-pg2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMTo0OTozN1rOF-pg2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIzNjE4NA==", "bodyText": "This test fails against trunk\nkafka.admin.TopicCommandTest > testIsNotUnderReplicatedWhenAdding FAILED\n    java.lang.AssertionError\n        at org.junit.Assert.fail(Assert.java:87)\n        at org.junit.Assert.assertTrue(Assert.java:42)\n        at org.junit.Assert.assertFalse(Assert.java:65)\n        at org.junit.Assert.assertFalse(Assert.java:75)\n        at kafka.admin.TopicCommandTest.testIsNotUnderReplicatedWhenAdding(TopicCommandTest.scala:54)\n\n1 test completed, 1 failed", "url": "https://github.com/apache/kafka/pull/8364#discussion_r401236184", "createdAt": "2020-03-31T21:49:37Z", "author": {"login": "jsancio"}, "path": "core/src/test/scala/unit/kafka/admin/TopicCommandTest.scala", "diffHunk": "@@ -16,585 +16,41 @@\n  */\n package kafka.admin\n \n-import kafka.admin.TopicCommand.{TopicCommandOptions, ZookeeperTopicService}\n-import kafka.server.ConfigType\n-import kafka.utils.{Logging, TestUtils}\n-import kafka.zk.{ConfigEntityChangeNotificationZNode, DeleteTopicsTopicZNode, ZooKeeperTestHarness}\n-import org.apache.kafka.common.TopicPartition\n-import org.apache.kafka.common.config.{ConfigException, ConfigResource}\n-import org.apache.kafka.common.errors.{InvalidPartitionsException, InvalidReplicationFactorException, TopicExistsException}\n-import org.apache.kafka.common.internals.Topic\n+import kafka.admin.TopicCommand.PartitionDescription\n+import org.apache.kafka.clients.admin.PartitionReassignment\n+import org.apache.kafka.common.Node\n+import org.apache.kafka.common.TopicPartitionInfo\n import org.junit.Assert._\n-import org.junit.rules.TestName\n-import org.junit.{After, Before, Rule, Test}\n-import org.scalatest.Assertions.intercept\n-\n-import scala.util.Random\n-\n-class TopicCommandTest extends ZooKeeperTestHarness with Logging with RackAwareTest {\n-\n-  private var topicService: ZookeeperTopicService = _\n-  private var testTopicName: String = _\n-\n-  private val _testName = new TestName\n-  @Rule def testName = _testName\n-\n-  @Before\n-  def setup(): Unit = {\n-    topicService = ZookeeperTopicService(zkClient)\n-    testTopicName = s\"${testName.getMethodName}-${Random.alphanumeric.take(10).mkString}\"\n-  }\n-\n-  @After\n-  def teardown(): Unit = {\n-    if (topicService != null)\n-      topicService.close()\n-  }\n-\n-  @Test\n-  def testCreate(): Unit = {\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    topicService.createTopic(new TopicCommandOptions(\n-      Array(\"--partitions\", \"2\", \"--replication-factor\", \"1\", \"--topic\", testTopicName)))\n-\n-    assertTrue(zkClient.getAllTopicsInCluster().contains(testTopicName))\n-  }\n-\n-  @Test\n-  def testCreateWithConfigs(): Unit = {\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    val configResource = new ConfigResource(ConfigResource.Type.TOPIC, testTopicName)\n-    topicService.createTopic(new TopicCommandOptions(\n-      Array(\"--partitions\", \"2\", \"--replication-factor\", \"2\", \"--topic\", configResource.name(), \"--config\", \"delete.retention.ms=1000\")))\n-\n-    val configs = zkClient.getEntityConfigs(ConfigType.Topic, testTopicName)\n-    assertEquals(1000, Integer.valueOf(configs.getProperty(\"delete.retention.ms\")))\n-  }\n-\n-  @Test\n-  def testCreateIfNotExists(): Unit = {\n-    // create brokers\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    val numPartitions = 1\n-\n-    // create the topic\n-    val createOpts = new TopicCommandOptions(\n-      Array(\"--partitions\", numPartitions.toString, \"--replication-factor\", \"1\", \"--topic\", testTopicName))\n-    topicService.createTopic(createOpts)\n-\n-    // try to re-create the topic without --if-not-exists\n-    intercept[TopicExistsException] {\n-      topicService.createTopic(createOpts)\n-    }\n-\n-    // try to re-create the topic with --if-not-exists\n-    val createNotExistsOpts = new TopicCommandOptions(\n-      Array(\"--partitions\", numPartitions.toString, \"--replication-factor\", \"1\", \"--topic\", testTopicName, \"--if-not-exists\"))\n-    topicService.createTopic(createNotExistsOpts)\n-  }\n-\n-  @Test\n-  def testCreateWithReplicaAssignment(): Unit = {\n-    // create the topic\n-    val createOpts = new TopicCommandOptions(\n-      Array(\"--replica-assignment\", \"5:4,3:2,1:0\", \"--topic\", testTopicName))\n-    topicService.createTopic(createOpts)\n-\n-    val replicas0 = zkClient.getReplicasForPartition(new TopicPartition(testTopicName, 0))\n-    assertEquals(List(5, 4), replicas0)\n-    val replicas1 = zkClient.getReplicasForPartition(new TopicPartition(testTopicName, 1))\n-    assertEquals(List(3, 2), replicas1)\n-    val replicas2 = zkClient.getReplicasForPartition(new TopicPartition(testTopicName, 2))\n-    assertEquals(List(1, 0), replicas2)\n-  }\n-\n-  @Test\n-  def testCreateWithInvalidReplicationFactor(): Unit = {\n-    val brokers = List(0)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    intercept[InvalidReplicationFactorException] {\n-      topicService.createTopic(new TopicCommandOptions(\n-        Array(\"--partitions\", \"2\", \"--replication-factor\", (Short.MaxValue+1).toString, \"--topic\", testTopicName)))\n-    }\n-  }\n-\n-  @Test\n-  def testCreateWithNegativeReplicationFactor(): Unit = {\n-    val brokers = List(0)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    intercept[InvalidReplicationFactorException] {\n-      topicService.createTopic(new TopicCommandOptions(\n-        Array(\"--partitions\", \"2\", \"--replication-factor\", \"-1\", \"--topic\", testTopicName)))\n-    }\n-  }\n-\n-  @Test\n-  def testCreateWithNegativePartitionCount(): Unit = {\n-    val brokers = List(0)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    intercept[InvalidPartitionsException] {\n-      topicService.createTopic(new TopicCommandOptions(\n-        Array(\"--partitions\", \"-1\", \"--replication-factor\", \"1\", \"--topic\", testTopicName)))\n-    }\n-  }\n-\n-  @Test\n-  def testInvalidTopicLevelConfig(): Unit = {\n-    val brokers = List(0)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    val createOpts = new TopicCommandOptions(\n-      Array(\"--partitions\", \"1\", \"--replication-factor\", \"1\", \"--topic\", testTopicName,\n-        \"--config\", \"message.timestamp.type=boom\"))\n-    intercept[ConfigException] {\n-      topicService.createTopic(createOpts)\n-    }\n-\n-    // try to create the topic with another invalid config\n-    val createOpts2 = new TopicCommandOptions(\n-      Array(\"--partitions\", \"1\", \"--replication-factor\", \"1\", \"--topic\", testTopicName,\n-        \"--config\", \"message.format.version=boom\"))\n-    intercept[ConfigException] {\n-      topicService.createTopic(createOpts2)\n-    }\n-  }\n-\n-  @Test\n-  def testListTopics(): Unit = {\n-    val brokers = List(0)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    topicService.createTopic(new TopicCommandOptions(\n-      Array(\"--partitions\", \"1\", \"--replication-factor\", \"1\", \"--topic\", testTopicName)))\n-\n-    val output = TestUtils.grabConsoleOutput(\n-      topicService.listTopics(new TopicCommandOptions(Array())))\n-\n-    assertTrue(output.contains(testTopicName))\n-  }\n-\n-  @Test\n-  def testListTopicsWithWhitelist(): Unit = {\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    val topic1 = \"kafka.testTopic1\"\n-    val topic2 = \"kafka.testTopic2\"\n-    val topic3 = \"oooof.testTopic1\"\n-    adminZkClient.createTopic(topic1, 2, 2)\n-    adminZkClient.createTopic(topic2, 2, 2)\n-    adminZkClient.createTopic(topic3, 2, 2)\n-\n-    val output = TestUtils.grabConsoleOutput(\n-      topicService.listTopics(new TopicCommandOptions(Array(\"--topic\", \"kafka.*\"))))\n-\n-    assertTrue(output.contains(topic1))\n-    assertTrue(output.contains(topic2))\n-    assertFalse(output.contains(topic3))\n-  }\n-\n-  @Test\n-  def testListTopicsWithExcludeInternal(): Unit = {\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    adminZkClient.createTopic(testTopicName, 2, 2)\n-    adminZkClient.createTopic(Topic.GROUP_METADATA_TOPIC_NAME, 2, 2)\n-\n-    val output = TestUtils.grabConsoleOutput(\n-      topicService.listTopics(new TopicCommandOptions(Array(\"--exclude-internal\"))))\n-\n-    assertTrue(output.contains(testTopicName))\n-    assertFalse(output.contains(Topic.GROUP_METADATA_TOPIC_NAME))\n-  }\n-\n-  @Test\n-  def testAlterPartitionCount(): Unit = {\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    adminZkClient.createTopic(testTopicName, 2, 2)\n-\n-    topicService.alterTopic(new TopicCommandOptions(\n-      Array(\"--topic\", testTopicName, \"--partitions\", \"3\")))\n-\n-    assertEquals(3, zkClient.getPartitionsForTopics(Set(testTopicName))(testTopicName).size)\n-  }\n-\n-  @Test\n-  def testAlterAssignment(): Unit = {\n-    val brokers = List(0, 1, 2, 3, 4, 5)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    adminZkClient.createTopic(testTopicName, 2, 2)\n-\n-    topicService.alterTopic(new TopicCommandOptions(\n-      Array(\"--topic\", testTopicName, \"--replica-assignment\", \"5:3,3:1,4:2\", \"--partitions\", \"3\")))\n-\n-    val replicas0 = zkClient.getReplicasForPartition(new TopicPartition(testTopicName, 2))\n-    assertEquals(3, zkClient.getPartitionsForTopics(Set(testTopicName))(testTopicName).size)\n-    assertEquals(List(4,2), replicas0)\n-  }\n-\n-  @Test\n-  def testAlterWithInvalidPartitionCount(): Unit = {\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    topicService.createTopic(new TopicCommandOptions(\n-      Array(\"--partitions\", \"1\", \"--replication-factor\", \"1\", \"--topic\", testTopicName)))\n-\n-    intercept[InvalidPartitionsException] {\n-      topicService.alterTopic(new TopicCommandOptions(\n-        Array(\"--partitions\", \"-1\", \"--topic\", testTopicName)))\n-    }\n-  }\n-\n-  @Test\n-  def testAlterIfExists(): Unit = {\n-    // create brokers\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    // alter a topic that does not exist without --if-exists\n-    val alterOpts = new TopicCommandOptions(Array(\"--topic\", testTopicName, \"--partitions\", \"1\"))\n-    intercept[IllegalArgumentException] {\n-      topicService.alterTopic(alterOpts)\n-    }\n-\n-    // alter a topic that does not exist with --if-exists\n-    val alterExistsOpts = new TopicCommandOptions(Array(\"--topic\", testTopicName, \"--partitions\", \"1\", \"--if-exists\"))\n-    topicService.alterTopic(alterExistsOpts)\n-  }\n-\n-  @Test\n-  def testAlterConfigs(): Unit = {\n-    // create brokers\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    topicService.createTopic(new TopicCommandOptions(\n-      Array(\"--partitions\", \"1\", \"--replication-factor\", \"1\", \"--topic\", testTopicName)))\n-\n-    topicService.alterTopic(new TopicCommandOptions(\n-      Array(\"--topic\", testTopicName, \"--config\", \"cleanup.policy=compact\")))\n-\n-    val output = TestUtils.grabConsoleOutput(\n-      topicService.describeTopic(new TopicCommandOptions(Array(\"--topic\", testTopicName))))\n-    assertTrue(\"The output should contain the modified config\", output.contains(\"Configs: cleanup.policy=compact\"))\n-\n-    topicService.alterTopic(new TopicCommandOptions(\n-      Array(\"--topic\", testTopicName, \"--config\", \"cleanup.policy=delete\")))\n-\n-    val output2 = TestUtils.grabConsoleOutput(\n-      topicService.describeTopic(new TopicCommandOptions(Array(\"--topic\", testTopicName))))\n-    assertTrue(\"The output should contain the modified config\", output2.contains(\"Configs: cleanup.policy=delete\"))\n-  }\n-\n-  @Test\n-  def testConfigPreservationAcrossPartitionAlteration(): Unit = {\n-    val numPartitionsOriginal = 1\n-    val cleanupKey = \"cleanup.policy\"\n-    val cleanupVal = \"compact\"\n-    // create brokers\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-    // create the topic\n-    val createOpts = new TopicCommandOptions(Array(\"--partitions\", numPartitionsOriginal.toString,\n-      \"--replication-factor\", \"1\",\n-      \"--config\", cleanupKey + \"=\" + cleanupVal,\n-      \"--topic\", testTopicName))\n-    topicService.createTopic(createOpts)\n-    val props = adminZkClient.fetchEntityConfig(ConfigType.Topic, testTopicName)\n-    assertTrue(\"Properties after creation don't contain \" + cleanupKey, props.containsKey(cleanupKey))\n-    assertTrue(\"Properties after creation have incorrect value\", props.getProperty(cleanupKey).equals(cleanupVal))\n-\n-    // pre-create the topic config changes path to avoid a NoNodeException\n-    zkClient.makeSurePersistentPathExists(ConfigEntityChangeNotificationZNode.path)\n-\n-    // modify the topic to add new partitions\n-    val numPartitionsModified = 3\n-    val alterOpts = new TopicCommandOptions(Array(\"--partitions\", numPartitionsModified.toString, \"--topic\", testTopicName))\n-    topicService.alterTopic(alterOpts)\n-    val newProps = adminZkClient.fetchEntityConfig(ConfigType.Topic, testTopicName)\n-    assertTrue(\"Updated properties do not contain \" + cleanupKey, newProps.containsKey(cleanupKey))\n-    assertTrue(\"Updated properties have incorrect value\", newProps.getProperty(cleanupKey).equals(cleanupVal))\n-  }\n-\n-  @Test\n-  def testTopicDeletion(): Unit = {\n-\n-    val numPartitionsOriginal = 1\n-\n-    // create brokers\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    // create the NormalTopic\n-    val createOpts = new TopicCommandOptions(Array(\"--partitions\", numPartitionsOriginal.toString,\n-      \"--replication-factor\", \"1\",\n-      \"--topic\", testTopicName))\n-    topicService.createTopic(createOpts)\n-\n-    // delete the NormalTopic\n-    val deleteOpts = new TopicCommandOptions(Array(\"--topic\", testTopicName))\n-    val deletePath = DeleteTopicsTopicZNode.path(testTopicName)\n-    assertFalse(\"Delete path for topic shouldn't exist before deletion.\", zkClient.pathExists(deletePath))\n-    topicService.deleteTopic(deleteOpts)\n-    assertTrue(\"Delete path for topic should exist after deletion.\", zkClient.pathExists(deletePath))\n-\n-    // create the offset topic\n-    val createOffsetTopicOpts = new TopicCommandOptions(Array(\"--partitions\", numPartitionsOriginal.toString,\n-      \"--replication-factor\", \"1\",\n-      \"--topic\", Topic.GROUP_METADATA_TOPIC_NAME))\n-    topicService.createTopic(createOffsetTopicOpts)\n-\n-    // try to delete the Topic.GROUP_METADATA_TOPIC_NAME and make sure it doesn't\n-    val deleteOffsetTopicOpts = new TopicCommandOptions(Array(\"--topic\", Topic.GROUP_METADATA_TOPIC_NAME))\n-    val deleteOffsetTopicPath = DeleteTopicsTopicZNode.path(Topic.GROUP_METADATA_TOPIC_NAME)\n-    assertFalse(\"Delete path for topic shouldn't exist before deletion.\", zkClient.pathExists(deleteOffsetTopicPath))\n-    intercept[AdminOperationException] {\n-      topicService.deleteTopic(deleteOffsetTopicOpts)\n-    }\n-    assertFalse(\"Delete path for topic shouldn't exist after deletion.\", zkClient.pathExists(deleteOffsetTopicPath))\n-  }\n-\n-  @Test\n-  def testDeleteIfExists(): Unit = {\n-    // create brokers\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    // delete a topic that does not exist without --if-exists\n-    val deleteOpts = new TopicCommandOptions(Array(\"--topic\", testTopicName))\n-    intercept[IllegalArgumentException] {\n-      topicService.deleteTopic(deleteOpts)\n-    }\n-\n-    // delete a topic that does not exist with --if-exists\n-    val deleteExistsOpts = new TopicCommandOptions(Array(\"--topic\", testTopicName, \"--if-exists\"))\n-    topicService.deleteTopic(deleteExistsOpts)\n-  }\n-\n-  @Test\n-  def testDeleteInternalTopic(): Unit = {\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    // create the offset topic\n-    val createOffsetTopicOpts = new TopicCommandOptions(Array(\"--partitions\", \"1\",\n-      \"--replication-factor\", \"1\",\n-      \"--topic\", Topic.GROUP_METADATA_TOPIC_NAME))\n-    topicService.createTopic(createOffsetTopicOpts)\n-\n-    val deleteOffsetTopicOpts = new TopicCommandOptions(Array(\"--topic\", Topic.GROUP_METADATA_TOPIC_NAME))\n-    val deleteOffsetTopicPath = DeleteTopicsTopicZNode.path(Topic.GROUP_METADATA_TOPIC_NAME)\n-    assertFalse(\"Delete path for topic shouldn't exist before deletion.\", zkClient.pathExists(deleteOffsetTopicPath))\n-    intercept[AdminOperationException] {\n-      topicService.deleteTopic(deleteOffsetTopicOpts)\n-    }\n-  }\n-\n-  @Test\n-  def testDescribeIfTopicNotExists(): Unit = {\n-    // create brokers\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    // describe topic that does not exist\n-    val describeOpts = new TopicCommandOptions(Array(\"--topic\", testTopicName))\n-    intercept[IllegalArgumentException] {\n-      topicService.describeTopic(describeOpts)\n-    }\n-\n-    // describe all topics\n-    val describeOptsAllTopics = new TopicCommandOptions(Array())\n-    // should not throw any error\n-    topicService.describeTopic(describeOptsAllTopics)\n-\n-    // describe topic that does not exist with --if-exists\n-    val describeOptsWithExists = new TopicCommandOptions(Array(\"--topic\", testTopicName, \"--if-exists\"))\n-    // should not throw any error\n-    topicService.describeTopic(describeOptsWithExists)\n-  }\n-\n-  @Test\n-  def testCreateAlterTopicWithRackAware(): Unit = {\n-    val rackInfo = Map(0 -> \"rack1\", 1 -> \"rack2\", 2 -> \"rack2\", 3 -> \"rack1\", 4 -> \"rack3\", 5 -> \"rack3\")\n-    TestUtils.createBrokersInZk(toBrokerMetadata(rackInfo), zkClient)\n-\n-    val numPartitions = 18\n-    val replicationFactor = 3\n-    val createOpts = new TopicCommandOptions(Array(\n-      \"--partitions\", numPartitions.toString,\n-      \"--replication-factor\", replicationFactor.toString,\n-      \"--topic\", testTopicName))\n-    topicService.createTopic(createOpts)\n-\n-    var assignment = zkClient.getReplicaAssignmentForTopics(Set(testTopicName)).map { case (tp, replicas) =>\n-      tp.partition -> replicas\n-    }\n-    checkReplicaDistribution(assignment, rackInfo, rackInfo.size, numPartitions, replicationFactor)\n-\n-    val alteredNumPartitions = 36\n-    // verify that adding partitions will also be rack aware\n-    val alterOpts = new TopicCommandOptions(Array(\n-      \"--partitions\", alteredNumPartitions.toString,\n-      \"--topic\", testTopicName))\n-    topicService.alterTopic(alterOpts)\n-    assignment = zkClient.getReplicaAssignmentForTopics(Set(testTopicName)).map { case (tp, replicas) =>\n-      tp.partition -> replicas\n-    }\n-    checkReplicaDistribution(assignment, rackInfo, rackInfo.size, alteredNumPartitions, replicationFactor)\n-  }\n-\n-  @Test\n-  def testDescribe(): Unit = {\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    adminZkClient.createTopic(testTopicName, 2, 2)\n-    val output = TestUtils.grabConsoleOutput(\n-      topicService.describeTopic(new TopicCommandOptions(Array(\"--topic\", testTopicName))))\n-    val rows = output.split(\"\\n\")\n-    assertEquals(3, rows.size)\n-    rows(0).startsWith(\"Topic:testTopic\\tPartitionCount:2\")\n-  }\n-\n-  @Test\n-  def testDescribeReportOverriddenConfigs(): Unit = {\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    val config = \"file.delete.delay.ms=1000\"\n-    val configResource = new ConfigResource(ConfigResource.Type.TOPIC, testTopicName)\n-    topicService.createTopic(new TopicCommandOptions(\n-      Array(\"--partitions\", \"2\", \"--replication-factor\", \"2\", \"--topic\", configResource.name(), \"--config\", config)))\n-    val output = TestUtils.grabConsoleOutput(\n-      topicService.describeTopic(new TopicCommandOptions(Array())))\n-    assertTrue(output.contains(config))\n-  }\n-\n-  @Test\n-  def testDescribeAndListTopicsMarkedForDeletion(): Unit = {\n-    val brokers = List(0)\n-    val markedForDeletionDescribe = \"MarkedForDeletion\"\n-    val markedForDeletionList = \"marked for deletion\"\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    val createOpts = new TopicCommandOptions(Array(\"--partitions\", \"1\", \"--replication-factor\", \"1\", \"--topic\", testTopicName))\n-    topicService.createTopic(createOpts)\n-\n-    // delete the broker first, so when we attempt to delete the topic it gets into \"marked for deletion\"\n-    TestUtils.deleteBrokersInZk(zkClient, brokers)\n-    topicService.deleteTopic(new TopicCommandOptions(Array(\"--topic\", testTopicName)))\n-\n-    // Test describe topics\n-    def describeTopicsWithConfig(): Unit = {\n-      topicService.describeTopic(new TopicCommandOptions(Array(\"--describe\")))\n-    }\n-    val outputWithConfig = TestUtils.grabConsoleOutput(describeTopicsWithConfig())\n-    assertTrue(outputWithConfig.contains(testTopicName) && outputWithConfig.contains(markedForDeletionDescribe))\n-\n-    def describeTopicsNoConfig(): Unit = {\n-      topicService.describeTopic(new TopicCommandOptions(Array(\"--describe\", \"--unavailable-partitions\")))\n-    }\n-    val outputNoConfig = TestUtils.grabConsoleOutput(describeTopicsNoConfig())\n-    assertTrue(outputNoConfig.contains(testTopicName) && outputNoConfig.contains(markedForDeletionDescribe))\n-\n-    // Test list topics\n-    def listTopics(): Unit = {\n-      topicService.listTopics(new TopicCommandOptions(Array(\"--list\")))\n-    }\n-    val output = TestUtils.grabConsoleOutput(listTopics())\n-    assertTrue(output.contains(testTopicName) && output.contains(markedForDeletionList))\n-  }\n-\n-  @Test\n-  def testDescribeAndListTopicsWithoutInternalTopics(): Unit = {\n-    val brokers = List(0)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    topicService.createTopic(\n-      new TopicCommandOptions(Array(\"--partitions\", \"1\", \"--replication-factor\", \"1\", \"--topic\", testTopicName)))\n-    // create a internal topic\n-    topicService.createTopic(\n-      new TopicCommandOptions(Array(\"--partitions\", \"1\", \"--replication-factor\", \"1\", \"--topic\", Topic.GROUP_METADATA_TOPIC_NAME)))\n-\n-    // test describe\n-    var output = TestUtils.grabConsoleOutput(topicService.describeTopic(\n-      new TopicCommandOptions(Array(\"--describe\", \"--exclude-internal\"))))\n-    assertTrue(output.contains(testTopicName))\n-    assertFalse(output.contains(Topic.GROUP_METADATA_TOPIC_NAME))\n-\n-    // test list\n-    output = TestUtils.grabConsoleOutput(topicService.listTopics(\n-      new TopicCommandOptions(Array(\"--list\", \"--exclude-internal\"))))\n-    assertTrue(output.contains(testTopicName))\n-    assertFalse(output.contains(Topic.GROUP_METADATA_TOPIC_NAME))\n-  }\n-\n-  @Test\n-  def testTopicOperationsWithRegexSymbolInTopicName(): Unit = {\n-    val topic1 = \"test.topic\"\n-    val topic2 = \"test-topic\"\n-    val escapedTopic = \"\\\"test\\\\.topic\\\"\"\n-    val unescapedTopic = \"test.topic\"\n-    val numPartitionsOriginal = 1\n-\n-    // create brokers\n-    val brokers = List(0, 1, 2)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-\n-    // create the topics\n-    val createOpts = new TopicCommandOptions(Array(\"--partitions\", numPartitionsOriginal.toString,\n-      \"--replication-factor\", \"1\", \"--topic\", topic1))\n-    topicService.createTopic(createOpts)\n-    val createOpts2 = new TopicCommandOptions(Array(\"--partitions\", numPartitionsOriginal.toString,\n-      \"--replication-factor\", \"1\", \"--topic\", topic2))\n-    topicService.createTopic(createOpts2)\n-\n-    val escapedCommandOpts = new TopicCommandOptions(Array(\"--topic\", escapedTopic))\n-    val unescapedCommandOpts = new TopicCommandOptions(Array(\"--topic\", unescapedTopic))\n-\n-    // topic actions with escaped regex do not affect 'test-topic'\n-    // topic actions with unescaped topic affect 'test-topic'\n-\n-    assertFalse(TestUtils.grabConsoleOutput(topicService.describeTopic(escapedCommandOpts)).contains(topic2))\n-    assertTrue(TestUtils.grabConsoleOutput(topicService.describeTopic(unescapedCommandOpts)).contains(topic2))\n-\n-    assertFalse(TestUtils.grabConsoleOutput(topicService.deleteTopic(escapedCommandOpts)).contains(topic2))\n-    assertTrue(TestUtils.grabConsoleOutput(topicService.deleteTopic(unescapedCommandOpts)).contains(topic2))\n-  }\n-\n-  @Test\n-  def testAlterInternalTopicPartitionCount(): Unit = {\n-    val brokers = List(0)\n-    TestUtils.createBrokersInZk(zkClient, brokers)\n-    \n-    // create internal topics\n-    adminZkClient.createTopic(Topic.GROUP_METADATA_TOPIC_NAME, 1, 1)\n-    adminZkClient.createTopic(Topic.TRANSACTION_STATE_TOPIC_NAME, 1, 1)\n-\n-    def expectAlterInternalTopicPartitionCountFailed(topic: String): Unit = {\n-      try {\n-        topicService.alterTopic(new TopicCommandOptions(\n-          Array(\"--topic\", topic, \"--partitions\", \"2\")))\n-        fail(\"Should have thrown an IllegalArgumentException\")\n-      } catch {\n-        case _: IllegalArgumentException => // expected\n-      }\n-    }\n-    expectAlterInternalTopicPartitionCountFailed(Topic.GROUP_METADATA_TOPIC_NAME)\n-    expectAlterInternalTopicPartitionCountFailed(Topic.TRANSACTION_STATE_TOPIC_NAME)\n+import org.junit.Test\n+import scala.collection.JavaConverters._\n+\n+final class TopicCommandTest { \n+  @Test\n+  def testIsNotUnderReplicatedWhenAdding(): Unit = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 593}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb0bc802928ad0d4a44966a42a0abacf69d9358c", "author": {"user": {"login": "jsancio", "name": "Jos\u00e9 Armando Garc\u00eda Sancio"}}, "url": "https://github.com/apache/kafka/commit/eb0bc802928ad0d4a44966a42a0abacf69d9358c", "committedDate": "2020-04-01T19:51:59Z", "message": "MINOR: Parition is under reassignment when adding and removing\n\nA partition is under reassignment if the either the set of adding\nreplicas or set removing replicas is non-empty.\n\nFix the test assertion such that it prints stdout on failure."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7d69ce0899117265666d65baa81555538c9a410", "author": {"user": {"login": "jsancio", "name": "Jos\u00e9 Armando Garc\u00eda Sancio"}}, "url": "https://github.com/apache/kafka/commit/a7d69ce0899117265666d65baa81555538c9a410", "committedDate": "2020-04-01T19:51:59Z", "message": "Use intValue instead of unbox"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f276d286e7c15679430eaee5c4504e7c213694b5", "author": {"user": {"login": "jsancio", "name": "Jos\u00e9 Armando Garc\u00eda Sancio"}}, "url": "https://github.com/apache/kafka/commit/f276d286e7c15679430eaee5c4504e7c213694b5", "committedDate": "2020-04-01T19:58:50Z", "message": "Unit test for false URP when adding"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "f276d286e7c15679430eaee5c4504e7c213694b5", "author": {"user": {"login": "jsancio", "name": "Jos\u00e9 Armando Garc\u00eda Sancio"}}, "url": "https://github.com/apache/kafka/commit/f276d286e7c15679430eaee5c4504e7c213694b5", "committedDate": "2020-04-01T19:58:50Z", "message": "Unit test for false URP when adding"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1OTA2OTM0", "url": "https://github.com/apache/kafka/pull/8364#pullrequestreview-385906934", "createdAt": "2020-04-01T20:01:04Z", "commit": {"oid": "f276d286e7c15679430eaee5c4504e7c213694b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDowMTowNFrOF_Qf1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMDowMTowNFrOF_Qf1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg3NDkwMA==", "bodyText": "I forgot to rename class with the previous git mv.", "url": "https://github.com/apache/kafka/pull/8364#discussion_r401874900", "createdAt": "2020-04-01T20:01:04Z", "author": {"login": "jsancio"}, "path": "core/src/test/scala/unit/kafka/admin/TopicCommandWithZKClientTest.scala", "diffHunk": "@@ -31,7 +31,7 @@ import org.scalatest.Assertions.intercept\n \n import scala.util.Random\n \n-class TopicCommandTest extends ZooKeeperTestHarness with Logging with RackAwareTest {\n+final class TopicCommandWithZKClientTest extends ZooKeeperTestHarness with Logging with RackAwareTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f276d286e7c15679430eaee5c4504e7c213694b5"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5OTE3MTQ0", "url": "https://github.com/apache/kafka/pull/8364#pullrequestreview-399917144", "createdAt": "2020-04-24T12:51:44Z", "commit": {"oid": "f276d286e7c15679430eaee5c4504e7c213694b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjo1MTo0NFrOGLWN_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxMjo1MTo0NFrOGLWN_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDU1MTU0OQ==", "bodyText": "This needs to be changed to CollectionConverters and the branch needs to be rebased from master.", "url": "https://github.com/apache/kafka/pull/8364#discussion_r414551549", "createdAt": "2020-04-24T12:51:44Z", "author": {"login": "ijuma"}, "path": "core/src/test/scala/unit/kafka/admin/TopicCommandTest.scala", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package kafka.admin\n+\n+import kafka.admin.TopicCommand.PartitionDescription\n+import org.apache.kafka.clients.admin.PartitionReassignment\n+import org.apache.kafka.common.Node\n+import org.apache.kafka.common.TopicPartitionInfo\n+import org.junit.Assert._\n+import org.junit.Test\n+import scala.collection.JavaConverters._", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f276d286e7c15679430eaee5c4504e7c213694b5"}, "originalPosition": 25}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82afaccc0fb977e35acac4842bc700e38199be14", "author": {"user": {"login": "jsancio", "name": "Jos\u00e9 Armando Garc\u00eda Sancio"}}, "url": "https://github.com/apache/kafka/commit/82afaccc0fb977e35acac4842bc700e38199be14", "committedDate": "2020-04-24T21:46:03Z", "message": "Merge remote-tracking branch 'upstream/trunk' into minor-under-replicated-test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4e2760c25867cd26ab27f12c45cd95ce0101243", "author": {"user": {"login": "jsancio", "name": "Jos\u00e9 Armando Garc\u00eda Sancio"}}, "url": "https://github.com/apache/kafka/commit/e4e2760c25867cd26ab27f12c45cd95ce0101243", "committedDate": "2020-04-24T22:04:11Z", "message": "Use CollectionConverters"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "e4e2760c25867cd26ab27f12c45cd95ce0101243", "author": {"user": {"login": "jsancio", "name": "Jos\u00e9 Armando Garc\u00eda Sancio"}}, "url": "https://github.com/apache/kafka/commit/e4e2760c25867cd26ab27f12c45cd95ce0101243", "committedDate": "2020-04-24T22:04:11Z", "message": "Use CollectionConverters"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMzAyMzgx", "url": "https://github.com/apache/kafka/pull/8364#pullrequestreview-400302381", "createdAt": "2020-04-24T22:19:02Z", "commit": {"oid": "e4e2760c25867cd26ab27f12c45cd95ce0101243"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1688, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}