{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1NjU5Njcx", "number": 9157, "title": "KAFKA-5636: Update for KIP-450 to handle early records", "bodyText": "Handles records that fall between 0 and the timeDifference that would normally create negative windows. This puts a new record that falls into this range in a window from [0, timeDifference] and creates the record's right windows as later records fall into it.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-08-10T18:26:27Z", "url": "https://github.com/apache/kafka/pull/9157", "merged": true, "mergeCommit": {"oid": "dd2b9eca5d6eee507d3c5baaf0647554e201fe18"}, "closed": true, "closedAt": "2020-09-09T19:02:20Z", "author": {"login": "lct45"}, "timelineItems": {"totalCount": 59, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc11xOMAH2gAyNDY1NjU5NjcxOjFiMmI3NTgzYzQ4MWE3ZmJkM2RlZGMzNWM4MzhlM2Q5ODYwM2UxNmQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdHASpEAH2gAyNDY1NjU5NjcxOjdkNGNhNmEzYjllYTg5OWFmYTY4MGVjODUyZmRmZGZiNWUyZjNkNTg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1b2b7583c481a7fbd3dedc35c838e3d98603e16d", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/1b2b7583c481a7fbd3dedc35c838e3d98603e16d", "committedDate": "2020-07-17T15:42:48Z", "message": "Initial classes for SlidingWindows, changes to processors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ee045a49a0c5e6478112af400e57c277b38f312", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/3ee045a49a0c5e6478112af400e57c277b38f312", "committedDate": "2020-07-17T18:31:10Z", "message": "updates to processor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff6ca4f62482d32f2f22a45647448727cfb67980", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/ff6ca4f62482d32f2f22a45647448727cfb67980", "committedDate": "2020-07-17T20:19:34Z", "message": "updated for grace period checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56a86f1718ba74e6ce4b808cb205ecf71a3d0b16", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/56a86f1718ba74e6ce4b808cb205ecf71a3d0b16", "committedDate": "2020-07-20T14:17:03Z", "message": "fixes for checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a3d6d490f0894ad128d4f981f9d7f87cf165f7d", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/0a3d6d490f0894ad128d4f981f9d7f87cf165f7d", "committedDate": "2020-07-20T14:20:42Z", "message": "fixes for checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6d358dfb62d09f4e8f406487b1f887c3db49267", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/c6d358dfb62d09f4e8f406487b1f887c3db49267", "committedDate": "2020-07-27T22:19:10Z", "message": "update algorithm, KIP changes, test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c1541ab543d2cfa0cb5e1e5288d39ec86187317", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/0c1541ab543d2cfa0cb5e1e5288d39ec86187317", "committedDate": "2020-07-27T22:27:14Z", "message": "Merge remote-tracking branch 'upstream/trunk' into slidingwindows"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f1b886f9da1f0ee5d84806875f93088c7b3c4d8", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/7f1b886f9da1f0ee5d84806875f93088c7b3c4d8", "committedDate": "2020-07-28T16:36:31Z", "message": "updates for windowedBy and associated processors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de89fe07b9ac515a0c430274200c39cadddbf64b", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/de89fe07b9ac515a0c430274200c39cadddbf64b", "committedDate": "2020-07-29T17:10:05Z", "message": "test fixes, updating algorithms"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35e637d6c0d932129d69b50072d2d1b412af7d10", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/35e637d6c0d932129d69b50072d2d1b412af7d10", "committedDate": "2020-07-31T19:59:41Z", "message": ":review updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc2f65f711a54e995094a1885df1dc728c479b1b", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/dc2f65f711a54e995094a1885df1dc728c479b1b", "committedDate": "2020-08-05T00:09:33Z", "message": "review updates, test additions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cca939e7b54f60cbbf0fc8abdd0f94fbbe19f45", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/9cca939e7b54f60cbbf0fc8abdd0f94fbbe19f45", "committedDate": "2020-08-05T14:20:20Z", "message": "sophie's reviews"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5a0d4b4a60f55d2ee7f412486ed8b567d493e25", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/e5a0d4b4a60f55d2ee7f412486ed8b567d493e25", "committedDate": "2020-08-05T15:37:05Z", "message": "cleaning up pr"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0afd88e97047c97e91e6d6273eb909e76eb782f4", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/0afd88e97047c97e91e6d6273eb909e76eb782f4", "committedDate": "2020-08-05T18:54:34Z", "message": "Merge branch 'trunk' of github.com:apache/kafka into slidingwindows"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24d91d8c33d3d3660f548623d6bcc7ef727d0862", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/24d91d8c33d3d3660f548623d6bcc7ef727d0862", "committedDate": "2020-08-05T19:43:05Z", "message": "updated tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65231139fb27f8e380d8bf6552a31c09f5fd28ff", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/65231139fb27f8e380d8bf6552a31c09f5fd28ff", "committedDate": "2020-08-07T15:17:24Z", "message": "grouped k stream and suppression tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34b3f5a2f6dee16a514698f39187eddcfab134bc", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/34b3f5a2f6dee16a514698f39187eddcfab134bc", "committedDate": "2020-08-07T20:41:17Z", "message": "removing reverse iterator, to be implemented later"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1071098d77ebda24f4a5791ca449efbb0cdabd48", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/1071098d77ebda24f4a5791ca449efbb0cdabd48", "committedDate": "2020-08-12T15:54:25Z", "message": "sophie's comments and testing updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "824f8702114bff71944a2004cf8eadbd7144c785", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/824f8702114bff71944a2004cf8eadbd7144c785", "committedDate": "2020-08-17T14:38:32Z", "message": "trunk updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1163c2faa84d3bb05c178ce67ecb047a92b9a054", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/1163c2faa84d3bb05c178ce67ecb047a92b9a054", "committedDate": "2020-08-17T14:44:58Z", "message": "cogrouped builder updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "296a6c3035f7eda71729d5cec7e16778383b7fad", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/296a6c3035f7eda71729d5cec7e16778383b7fad", "committedDate": "2020-08-19T18:12:59Z", "message": "test updates and clean up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb609a89ec7543943d03a1939e61f8208847ce8e", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/bb609a89ec7543943d03a1939e61f8208847ce8e", "committedDate": "2020-08-24T17:07:55Z", "message": "randomized and small test improvements"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyODIyMTU3", "url": "https://github.com/apache/kafka/pull/9157#pullrequestreview-472822157", "createdAt": "2020-08-21T21:12:14Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMjoyMzoxMlrOHF4Tqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwMDowNzowN1rOHF70sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyNzQ2Nw==", "bodyText": "This is really just the timestamp of the previous record, right? Can we call it something that reflects that", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475927467", "createdAt": "2020-08-24T22:23:12Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -183,7 +188,8 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n \n             //create right window for previous record\n             if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n+                final long leftWindowEnd = latestLeftTypeWindow.key.window().end();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyOTM2OQ==", "bodyText": "We need to make sure the fetch bounds don't go into the negative. We only call processEarly if the record's timestamp is within the timeDifferenceMs, but here we search starting at timestamp - 2*timeDifferenceMs", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475929369", "createdAt": "2020-08-24T22:28:08Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -148,7 +153,7 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             boolean rightWinAlreadyCreated = false;\n \n             // keep the left type window closest to the record\n-            Window latestLeftTypeWindow = null;\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> latestLeftTypeWindow = null;\n             try (\n                     final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkzMjg1Mw==", "bodyText": "I think this fetch might break if you go into the negatives, should just fetch starting from 0", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475932853", "createdAt": "2020-08-24T22:38:03Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -211,6 +217,67 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n         }\n \n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final HashSet<Long> windowStartTimes = new HashSet<Long>();\n+\n+            try (\n+                    final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                            key,\n+                            key,\n+                            timestamp - 2 * windows.timeDifferenceMs(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0NzM5NA==", "bodyText": "This is just a window from [0, timeDifferenceMs] that stores the aggregation of all the \"early\" records, right? I can't really think of a more descriptive name so can we just leave a comment explaining what it's for", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475947394", "createdAt": "2020-08-24T23:13:19Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -210,6 +216,66 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n         }\n \n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk2ODA1NA==", "bodyText": "It took me a second to get this -- can we explicitly check if startTime == timestamp + 1 instead of falling back to else and implicitly relying on the fetch bounds? You can just get rid of the else altogether or throw an IllegalStateException if none of the specific conditions are met and the else is reached, whatever makes sense to you", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475968054", "createdAt": "2020-08-24T23:42:28Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -210,6 +216,66 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n         }\n \n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final HashSet<Long> windowStartTimes = new HashSet<Long>();\n+\n+            try (\n+                    final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                            key,\n+                            key,\n+                            timestamp - 2 * windows.timeDifferenceMs(),\n+                            // to catch the current record's right window, if it exists, without more calls to the store\n+                            timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime == windows.timeDifferenceMs()) {\n+                        combinedWindow = next;\n+                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk2OTc3Nw==", "bodyText": "nit: can we make this if startTime == 0 ? That seems slightly easier to understand, and then all the conditionals can be in terms of startTime which is a bit more intuitive since that's what we're iterating over. Context switching between startTime and endTime kind of makes me lose my train of thought", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475969777", "createdAt": "2020-08-24T23:44:52Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -210,6 +216,66 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n         }\n \n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final HashSet<Long> windowStartTimes = new HashSet<Long>();\n+\n+            try (\n+                    final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                            key,\n+                            key,\n+                            timestamp - 2 * windows.timeDifferenceMs(),\n+                            // to catch the current record's right window, if it exists, without more calls to the store\n+                            timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime == windows.timeDifferenceMs()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk3MzA2Ng==", "bodyText": "most recent max timestamp\n\nHuh? I think I know what you're trying to say here but it seems like two different phrases got a bit mixed up here", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475973066", "createdAt": "2020-08-24T23:49:43Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -210,6 +216,66 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n         }\n \n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final HashSet<Long> windowStartTimes = new HashSet<Long>();\n+\n+            try (\n+                    final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                            key,\n+                            key,\n+                            timestamp - 2 * windows.timeDifferenceMs(),\n+                            // to catch the current record's right window, if it exists, without more calls to the store\n+                            timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime == windows.timeDifferenceMs()) {\n+                        combinedWindow = next;\n+                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the most recent max timestamp in the combined window", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk3NDE0MQ==", "bodyText": "This name keeps throwing me off...right window of what? Is it like previousRecordRightWindow?", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475974141", "createdAt": "2020-08-24T23:51:11Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -210,6 +216,66 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n         }\n \n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final HashSet<Long> windowStartTimes = new HashSet<Long>();\n+\n+            try (\n+                    final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                            key,\n+                            key,\n+                            timestamp - 2 * windows.timeDifferenceMs(),\n+                            // to catch the current record's right window, if it exists, without more calls to the store\n+                            timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime == windows.timeDifferenceMs()) {\n+                        combinedWindow = next;\n+                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the most recent max timestamp in the combined window\n+                final long rightWinStart = combinedWindow.value.timestamp() + 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk4MDkwMw==", "bodyText": "It's not immediately obvious why this is correct/captures all possible cases so we should leave a comment, or better yet factor out this condition into a descriptively named method (or best yet, do both)\nI was concerned about out-of-order records, since in that case the previous record would obviously not be the one with the maximum timestamp in the combined window. But I realized that we actually never need to create a previous record's right window for out-of-order early records, since there's no way for a full timeDifferenceMs to fit between the previous record and whatever the max record in the combined window is. So, all we need to do is make sure we only try to create the previous record's right window if the current window is the maximum record within the combined window, ie the combinedWindow.value.timestamp() < timestamp\nBut that's a very long and pretty ineloquent comment to leave in the code. Hopefully you can come up with a more concise explanation", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475980903", "createdAt": "2020-08-25T00:00:57Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -210,6 +216,66 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n         }\n \n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final HashSet<Long> windowStartTimes = new HashSet<Long>();\n+\n+            try (\n+                    final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                            key,\n+                            key,\n+                            timestamp - 2 * windows.timeDifferenceMs(),\n+                            // to catch the current record's right window, if it exists, without more calls to the store\n+                            timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime == windows.timeDifferenceMs()) {\n+                        combinedWindow = next;\n+                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the most recent max timestamp in the combined window\n+                final long rightWinStart = combinedWindow.value.timestamp() + 1;\n+                if (!windowStartTimes.contains(rightWinStart) && combinedWindow.value.timestamp() < timestamp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk4MTE2Nw==", "bodyText": "nit: aggregated -> aggregate", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475981167", "createdAt": "2020-08-25T00:01:18Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -210,6 +216,66 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             }\n         }\n \n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final HashSet<Long> windowStartTimes = new HashSet<Long>();\n+\n+            try (\n+                    final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                            key,\n+                            key,\n+                            timestamp - 2 * windows.timeDifferenceMs(),\n+                            // to catch the current record's right window, if it exists, without more calls to the store\n+                            timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime == windows.timeDifferenceMs()) {\n+                        combinedWindow = next;\n+                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the most recent max timestamp in the combined window\n+                final long rightWinStart = combinedWindow.value.timestamp() + 1;\n+                if (!windowStartTimes.contains(rightWinStart) && combinedWindow.value.timestamp() < timestamp) {\n+                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+                //update the combined window with the new aggregated", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk4NTA3Mw==", "bodyText": "Can we add maybe one or two more tests? I think at the least we should have one test that processes only early records, and one test that covers input(s) with the same timestamp.", "url": "https://github.com/apache/kafka/pull/9157#discussion_r475985073", "createdAt": "2020-08-25T00:07:07Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "diffHunk": "@@ -328,6 +328,68 @@ public void testAggregateLargeInput() {\n         );\n     }\n \n+    @Test\n+    public void testEarlyRecords() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64d4cbbdec80580a91c13a57e4d091efebf749d7", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/64d4cbbdec80580a91c13a57e4d091efebf749d7", "committedDate": "2020-08-26T16:30:45Z", "message": "testing clean up"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2MTk4NzQz", "url": "https://github.com/apache/kafka/pull/9157#pullrequestreview-476198743", "createdAt": "2020-08-27T00:20:26Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwMDoyMDoyN1rOHHn82A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwMTo0MDo1NVrOHHv46g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzc1NjYzMg==", "bodyText": "This comment kind of comes out of nowhere since there's no concept of the \"combined window\" outside of processEarly. Maybe you can just add a quick mention of what it is and that it's for early records", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477756632", "createdAt": "2020-08-27T00:20:27Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -160,11 +160,18 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n \n                     if (endTime < timestamp) {\n                         leftWinAgg = next.value;\n+                        // store the combined window if it is found so that a right window can be created for\n+                        // the combined window's max record, as needed", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzc4NDA4NA==", "bodyText": "We only need to check if the previous right window needs to be created if the current record's left window was not previously a left-type window, ie the max_timestamp < timestamp. Otherwise, we'd have already created any windows since that implies we processed a record with this exact timestamp already.\nSo then why do we set latestLeftTypeWindow = next ? It seems like it's possible that this actually isn't a left-type window, in which case we shouldn't overwrite any existing value for latestLeftTypeWindow.\nOn the other hand, if it actually is a left type window, then that means we don't need to create the previous record's right window so we should just set it to null. But that seems to apply regardless of whether this is the early record combined window or not?", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477784084", "createdAt": "2020-08-27T00:35:09Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -160,11 +160,18 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n \n                     if (endTime < timestamp) {\n                         leftWinAgg = next.value;\n+                        // store the combined window if it is found so that a right window can be created for\n+                        // the combined window's max record, as needed\n                         if (isLeftWindow(next) || endTime == windows.timeDifferenceMs()) {\n                             latestLeftTypeWindow = next;\n                         }\n                     } else if (endTime == timestamp) {\n                         leftWinAlreadyCreated = true;\n+                        // if current record's left window is the combined window, need to check later if there is a\n+                        // record that needs a right window within the combined window\n+                        if (endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzc4NTg0OA==", "bodyText": "Parameter alignment is off. Also the naming here isn't very clear about what it's for/what it means. Don't have great suggestions but maybe previousRightWindowMustBeCreated or even just previousRecordIsWithinMaxTimeDifferenceFromCurrentRecord and then a quick comment saying that this means we will have to create a right window for the previous record.\nAlso shouldn't rightWindowStart <= currentRecordTimestamp always be true?", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477785848", "createdAt": "2020-08-27T00:36:02Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream.internals;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.common.metrics.Sensor;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.kstream.Aggregator;\n+import org.apache.kafka.streams.kstream.Initializer;\n+import org.apache.kafka.streams.kstream.Window;\n+import org.apache.kafka.streams.kstream.Windowed;\n+import org.apache.kafka.streams.kstream.SlidingWindows;\n+import org.apache.kafka.streams.processor.AbstractProcessor;\n+import org.apache.kafka.streams.processor.Processor;\n+import org.apache.kafka.streams.processor.ProcessorContext;\n+import org.apache.kafka.streams.processor.internals.InternalProcessorContext;\n+import org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.TimestampedWindowStore;\n+import org.apache.kafka.streams.state.ValueAndTimestamp;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.apache.kafka.streams.processor.internals.metrics.TaskMetrics.droppedRecordsSensorOrLateRecordDropSensor;\n+import static org.apache.kafka.streams.processor.internals.metrics.TaskMetrics.droppedRecordsSensorOrSkippedRecordsSensor;\n+import static org.apache.kafka.streams.state.ValueAndTimestamp.getValueOrNull;\n+\n+public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProcessorSupplier<K, Windowed<K>, V, Agg> {\n+    private final Logger log = LoggerFactory.getLogger(getClass());\n+\n+    private final String storeName;\n+    private final SlidingWindows windows;\n+    private final Initializer<Agg> initializer;\n+    private final Aggregator<? super K, ? super V, Agg> aggregator;\n+\n+    private boolean sendOldValues = false;\n+\n+    public KStreamSlidingWindowAggregate(final SlidingWindows windows,\n+                                         final String storeName,\n+                                         final Initializer<Agg> initializer,\n+                                         final Aggregator<? super K, ? super V, Agg> aggregator) {\n+        this.windows = windows;\n+        this.storeName = storeName;\n+        this.initializer = initializer;\n+        this.aggregator = aggregator;\n+    }\n+\n+    @Override\n+    public Processor<K, V> get() {\n+        return new KStreamSlidingWindowAggregateProcessor();\n+    }\n+\n+    public SlidingWindows windows() {\n+        return windows;\n+    }\n+\n+    @Override\n+    public void enableSendingOldValues() {\n+        sendOldValues = true;\n+    }\n+\n+    private class KStreamSlidingWindowAggregateProcessor extends AbstractProcessor<K, V> {\n+        private TimestampedWindowStore<K, Agg> windowStore;\n+        private TimestampedTupleForwarder<Windowed<K>, Agg> tupleForwarder;\n+        private StreamsMetricsImpl metrics;\n+        private InternalProcessorContext internalProcessorContext;\n+        private Sensor lateRecordDropSensor;\n+        private Sensor droppedRecordsSensor;\n+        private long observedStreamTime = ConsumerRecord.NO_TIMESTAMP;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public void init(final ProcessorContext context) {\n+            super.init(context);\n+            internalProcessorContext = (InternalProcessorContext) context;\n+            metrics = internalProcessorContext.metrics();\n+            final String threadId = Thread.currentThread().getName();\n+            lateRecordDropSensor = droppedRecordsSensorOrLateRecordDropSensor(\n+                threadId,\n+                context.taskId().toString(),\n+                internalProcessorContext.currentNode().name(),\n+                metrics\n+            );\n+            droppedRecordsSensor = droppedRecordsSensorOrSkippedRecordsSensor(threadId, context.taskId().toString(), metrics);\n+            windowStore = (TimestampedWindowStore<K, Agg>) context.getStateStore(storeName);\n+            tupleForwarder = new TimestampedTupleForwarder<>(\n+                windowStore,\n+                context,\n+                new TimestampedCacheFlushListener<>(context),\n+                sendOldValues);\n+        }\n+\n+        @Override\n+        public void process(final K key, final V value) {\n+            if (key == null || value == null) {\n+                log.warn(\n+                    \"Skipping record due to null key or value. value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n+                    value, context().topic(), context().partition(), context().offset()\n+                );\n+                droppedRecordsSensor.record();\n+                return;\n+            }\n+\n+            final long timestamp = context().timestamp();\n+            processInOrder(key, value, timestamp);\n+        }\n+\n+        public void processInOrder(final K key, final V value, final long timestamp) {\n+\n+            observedStreamTime = Math.max(observedStreamTime, timestamp);\n+            final long closeTime = observedStreamTime - windows.gracePeriodMs();\n+\n+            if (timestamp < windows.timeDifferenceMs()) {\n+                processEarly(key, value, timestamp, closeTime);\n+                return;\n+            }\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            // keep the left type window closest to the record\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> latestLeftTypeWindow = null;\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime < timestamp) {\n+                        leftWinAgg = next.value;\n+                        // store the combined window if it is found so that a right window can be created for\n+                        // the combined window's max record, as needed\n+                        if (isLeftWindow(next) || endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }\n+                    } else if (endTime == timestamp) {\n+                        leftWinAlreadyCreated = true;\n+                        // if current record's left window is the combined window, need to check later if there is a\n+                        // record that needs a right window within the combined window\n+                        if (endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+            //create right window for previous record\n+            if (latestLeftTypeWindow != null) {\n+                final long previousRecord = latestLeftTypeWindow.key.window().end();\n+                final long rightWinStart = previousRecord == windows.timeDifferenceMs() ? latestLeftTypeWindow.value.timestamp() + 1 : previousRecord + 1;\n+                if (!windowStartTimes.contains(rightWinStart) && previousRightWindowPossible(rightWinStart, timestamp)) {\n+                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+            }\n+\n+            //create left window for new record\n+            if (!leftWinAlreadyCreated) {\n+                final ValueAndTimestamp<Agg> valueAndTime;\n+                // if there's a right window that the new record could create --> new record's left window is not empty\n+                if (latestLeftTypeWindow != null && previousRightWindowPossible(latestLeftTypeWindow.value.timestamp(), timestamp)) {\n+                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n+                } else {\n+                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                }\n+                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                    } else if (endTime >= timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window iwll go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the combined window's max record before the current record was added\n+                final long maxRightWindowStart = combinedWindow.value.timestamp() + 1;\n+                //only create the right window if new record falls within it and it does not already exist\n+                if (!windowStartTimes.contains(maxRightWindowStart) && previousRightWindowPossible(maxRightWindowStart, timestamp)) {\n+                    final TimeWindow window = new TimeWindow(maxRightWindowStart, maxRightWindowStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+        }\n+\n+        private boolean previousRightWindowPossible(\n+            final long rightWindowStart,\n+            final long currentRecordTimestamp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzgwNTYzMg==", "bodyText": "I'm having trouble wrapping my head around this line. Why would we create a right window at latestLeftTypeWindow.maxTimestamp + 1 if the previous record was at timeDifferenceMs? Wouldn't we have created the right window for whatever is at latestLeftTypeWindow.maxTimestamp + 1 when we processed the previousRecord?", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477805632", "createdAt": "2020-08-27T00:46:28Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -174,12 +181,11 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n                     }\n                 }\n             }\n-\n             //create right window for previous record\n             if (latestLeftTypeWindow != null) {\n-                final long leftWindowEnd = latestLeftTypeWindow.key.window().end();\n-                final long rightWinStart = leftWindowEnd == windows.timeDifferenceMs() ? latestLeftTypeWindow.value.timestamp() + 1 : leftWindowEnd + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n+                final long previousRecord = latestLeftTypeWindow.key.window().end();\n+                final long rightWinStart = previousRecord == windows.timeDifferenceMs() ? latestLeftTypeWindow.value.timestamp() + 1 : previousRecord + 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzgzNzM3OQ==", "bodyText": "Not sure I understand the || endTime == windows.timeDifferenceMs(), is that left over from the 1st PR? It seems important to enforce that the window latestLeftTypeWindow points to is actually a left window", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477837379", "createdAt": "2020-08-27T01:03:42Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -160,11 +160,18 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n \n                     if (endTime < timestamp) {\n                         leftWinAgg = next.value;\n+                        // store the combined window if it is found so that a right window can be created for\n+                        // the combined window's max record, as needed\n                         if (isLeftWindow(next) || endTime == windows.timeDifferenceMs()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg2Njg4MA==", "bodyText": "Now that I think about it, this isn't exactly true -- you could have the previous record at 10 and the current record at 21 (size is 10), then you'd have to create a right window for [11, 21] but the left window is also [11, 21] which is empty (except for the current record of course).So you'd want to check that previousRecord >= currentRecord - timeDifference which is actually technically what previousRightWindowPossible(rightWindow, timestamp) returns but it took me a long time to figure all that out because we're sort of passing in the wrong parameters here. In this call we pass in latestLeftTypeWindow.value.timestamp which is equivalent to previousRecord.timestamp which is not conceptually the same as the rightWindowStart . I know the logic works out the way you intended but it's pretty hard to untangle. You should update the comment and create a separate method for this case which you can name more accurately for this specific scenario", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477866880", "createdAt": "2020-08-27T01:23:21Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -189,8 +195,8 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create --> new record's left window is not empty", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg3MDIzNA==", "bodyText": "Actually, do we even need the endTime >= timestamp part of the condition? We're really just iterating over the single dimension of the startTime from 0 to timestamp + 1", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477870234", "createdAt": "2020-08-27T01:26:34Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -232,40 +239,54 @@ private void processEarly(final K key, final V value, final long timestamp, fina\n                     final long startTime = next.key.window().start();\n                     final long endTime = startTime + windows.timeDifferenceMs();\n \n-                    if (endTime == windows.timeDifferenceMs()) {\n+                    if (startTime == 0) {\n                         combinedWindow = next;\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                    } else if (endTime >= timestamp && startTime <= timestamp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg3MTA3OQ==", "bodyText": "iwll \ud83d\ude42", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477871079", "createdAt": "2020-08-27T01:27:25Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -232,40 +239,54 @@ private void processEarly(final K key, final V value, final long timestamp, fina\n                     final long startTime = next.key.window().start();\n                     final long endTime = startTime + windows.timeDifferenceMs();\n \n-                    if (endTime == windows.timeDifferenceMs()) {\n+                    if (startTime == 0) {\n                         combinedWindow = next;\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                    } else if (endTime >= timestamp && startTime <= timestamp) {\n                         rightWinAgg = next.value;\n                         putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                    } else if (startTime == timestamp + 1) {\n                         rightWinAlreadyCreated = true;\n                     }\n                 }\n             }\n \n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window iwll go in the new record's right window", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg4MDMyOQ==", "bodyText": "Ok, I see that rightWindowStart <= currentRecordTimestamp isn't necessarily true when you call this from processEarly but I think you're kind of abusing this poor method \ud83d\ude1c . I would keep things simple here and make sure the parameters always mean exactly the same thing when you call this, ie rightWindowStart should always mean that \"the start time of the right window for the record which is previous to the current record\" . If that means some duplicated boolean checks here and there, so be it.", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477880329", "createdAt": "2020-08-27T01:36:22Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream.internals;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.common.metrics.Sensor;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.kstream.Aggregator;\n+import org.apache.kafka.streams.kstream.Initializer;\n+import org.apache.kafka.streams.kstream.Window;\n+import org.apache.kafka.streams.kstream.Windowed;\n+import org.apache.kafka.streams.kstream.SlidingWindows;\n+import org.apache.kafka.streams.processor.AbstractProcessor;\n+import org.apache.kafka.streams.processor.Processor;\n+import org.apache.kafka.streams.processor.ProcessorContext;\n+import org.apache.kafka.streams.processor.internals.InternalProcessorContext;\n+import org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.TimestampedWindowStore;\n+import org.apache.kafka.streams.state.ValueAndTimestamp;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.apache.kafka.streams.processor.internals.metrics.TaskMetrics.droppedRecordsSensorOrLateRecordDropSensor;\n+import static org.apache.kafka.streams.processor.internals.metrics.TaskMetrics.droppedRecordsSensorOrSkippedRecordsSensor;\n+import static org.apache.kafka.streams.state.ValueAndTimestamp.getValueOrNull;\n+\n+public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProcessorSupplier<K, Windowed<K>, V, Agg> {\n+    private final Logger log = LoggerFactory.getLogger(getClass());\n+\n+    private final String storeName;\n+    private final SlidingWindows windows;\n+    private final Initializer<Agg> initializer;\n+    private final Aggregator<? super K, ? super V, Agg> aggregator;\n+\n+    private boolean sendOldValues = false;\n+\n+    public KStreamSlidingWindowAggregate(final SlidingWindows windows,\n+                                         final String storeName,\n+                                         final Initializer<Agg> initializer,\n+                                         final Aggregator<? super K, ? super V, Agg> aggregator) {\n+        this.windows = windows;\n+        this.storeName = storeName;\n+        this.initializer = initializer;\n+        this.aggregator = aggregator;\n+    }\n+\n+    @Override\n+    public Processor<K, V> get() {\n+        return new KStreamSlidingWindowAggregateProcessor();\n+    }\n+\n+    public SlidingWindows windows() {\n+        return windows;\n+    }\n+\n+    @Override\n+    public void enableSendingOldValues() {\n+        sendOldValues = true;\n+    }\n+\n+    private class KStreamSlidingWindowAggregateProcessor extends AbstractProcessor<K, V> {\n+        private TimestampedWindowStore<K, Agg> windowStore;\n+        private TimestampedTupleForwarder<Windowed<K>, Agg> tupleForwarder;\n+        private StreamsMetricsImpl metrics;\n+        private InternalProcessorContext internalProcessorContext;\n+        private Sensor lateRecordDropSensor;\n+        private Sensor droppedRecordsSensor;\n+        private long observedStreamTime = ConsumerRecord.NO_TIMESTAMP;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public void init(final ProcessorContext context) {\n+            super.init(context);\n+            internalProcessorContext = (InternalProcessorContext) context;\n+            metrics = internalProcessorContext.metrics();\n+            final String threadId = Thread.currentThread().getName();\n+            lateRecordDropSensor = droppedRecordsSensorOrLateRecordDropSensor(\n+                threadId,\n+                context.taskId().toString(),\n+                internalProcessorContext.currentNode().name(),\n+                metrics\n+            );\n+            droppedRecordsSensor = droppedRecordsSensorOrSkippedRecordsSensor(threadId, context.taskId().toString(), metrics);\n+            windowStore = (TimestampedWindowStore<K, Agg>) context.getStateStore(storeName);\n+            tupleForwarder = new TimestampedTupleForwarder<>(\n+                windowStore,\n+                context,\n+                new TimestampedCacheFlushListener<>(context),\n+                sendOldValues);\n+        }\n+\n+        @Override\n+        public void process(final K key, final V value) {\n+            if (key == null || value == null) {\n+                log.warn(\n+                    \"Skipping record due to null key or value. value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n+                    value, context().topic(), context().partition(), context().offset()\n+                );\n+                droppedRecordsSensor.record();\n+                return;\n+            }\n+\n+            final long timestamp = context().timestamp();\n+            processInOrder(key, value, timestamp);\n+        }\n+\n+        public void processInOrder(final K key, final V value, final long timestamp) {\n+\n+            observedStreamTime = Math.max(observedStreamTime, timestamp);\n+            final long closeTime = observedStreamTime - windows.gracePeriodMs();\n+\n+            if (timestamp < windows.timeDifferenceMs()) {\n+                processEarly(key, value, timestamp, closeTime);\n+                return;\n+            }\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            // keep the left type window closest to the record\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> latestLeftTypeWindow = null;\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime < timestamp) {\n+                        leftWinAgg = next.value;\n+                        // store the combined window if it is found so that a right window can be created for\n+                        // the combined window's max record, as needed\n+                        if (isLeftWindow(next) || endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }\n+                    } else if (endTime == timestamp) {\n+                        leftWinAlreadyCreated = true;\n+                        // if current record's left window is the combined window, need to check later if there is a\n+                        // record that needs a right window within the combined window\n+                        if (endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+            //create right window for previous record\n+            if (latestLeftTypeWindow != null) {\n+                final long previousRecord = latestLeftTypeWindow.key.window().end();\n+                final long rightWinStart = previousRecord == windows.timeDifferenceMs() ? latestLeftTypeWindow.value.timestamp() + 1 : previousRecord + 1;\n+                if (!windowStartTimes.contains(rightWinStart) && previousRightWindowPossible(rightWinStart, timestamp)) {\n+                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+            }\n+\n+            //create left window for new record\n+            if (!leftWinAlreadyCreated) {\n+                final ValueAndTimestamp<Agg> valueAndTime;\n+                // if there's a right window that the new record could create --> new record's left window is not empty\n+                if (latestLeftTypeWindow != null && previousRightWindowPossible(latestLeftTypeWindow.value.timestamp(), timestamp)) {\n+                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n+                } else {\n+                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                }\n+                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                    } else if (endTime >= timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window iwll go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the combined window's max record before the current record was added\n+                final long maxRightWindowStart = combinedWindow.value.timestamp() + 1;\n+                //only create the right window if new record falls within it and it does not already exist\n+                if (!windowStartTimes.contains(maxRightWindowStart) && previousRightWindowPossible(maxRightWindowStart, timestamp)) {\n+                    final TimeWindow window = new TimeWindow(maxRightWindowStart, maxRightWindowStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+        }\n+\n+        private boolean previousRightWindowPossible(\n+            final long rightWindowStart,\n+            final long currentRecordTimestamp) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzc4NTg0OA=="}, "originalCommit": null, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg4NDA4OA==", "bodyText": "Also, cool,  I think I understand the concept here but some of the details are a bit fuzzy. Basically if we don't find a right window agg that means we didn't find any windows (besides the combined window), which in turn means that there can only be a single record in the combined window (otherwise you'd get a right window for the earlier record).\nSo we need to use the combined window agg for the current record's right window.  But we should only do that if the one record is actually after the current record, right? I think you actually do implicitly check that is the case below but it's pretty subtle: basically in previousRightWindowPossible you would return false if rightWindowStart > currentRecordTimestamp. But we can check that right here and make it explicit, so that rightWinAgg only ever means the aggregate that we will actually put in the current record's right window. Then we can also clean up previousRightWindowPossible", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477884088", "createdAt": "2020-08-27T01:39:02Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -232,40 +239,54 @@ private void processEarly(final K key, final V value, final long timestamp, fina\n                     final long startTime = next.key.window().start();\n                     final long endTime = startTime + windows.timeDifferenceMs();\n \n-                    if (endTime == windows.timeDifferenceMs()) {\n+                    if (startTime == 0) {\n                         combinedWindow = next;\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                    } else if (endTime >= timestamp && startTime <= timestamp) {\n                         rightWinAgg = next.value;\n                         putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                    } else if (startTime == timestamp + 1) {\n                         rightWinAlreadyCreated = true;\n                     }\n                 }\n             }\n \n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window iwll go in the new record's right window", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg3MTA3OQ=="}, "originalCommit": null, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg4NjY5OA==", "bodyText": "See above: we shouldn't rely on previousRightWindow here. Actually I don't think we need it at all? (assuming we move the check in it to the condition above where we use the combined window agg)", "url": "https://github.com/apache/kafka/pull/9157#discussion_r477886698", "createdAt": "2020-08-27T01:40:55Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -232,40 +239,54 @@ private void processEarly(final K key, final V value, final long timestamp, fina\n                     final long startTime = next.key.window().start();\n                     final long endTime = startTime + windows.timeDifferenceMs();\n \n-                    if (endTime == windows.timeDifferenceMs()) {\n+                    if (startTime == 0) {\n                         combinedWindow = next;\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                    } else if (endTime >= timestamp && startTime <= timestamp) {\n                         rightWinAgg = next.value;\n                         putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                    } else if (startTime == timestamp + 1) {\n                         rightWinAlreadyCreated = true;\n                     }\n                 }\n             }\n \n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window iwll go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n             if (combinedWindow == null) {\n                 final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n                 final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n \n             } else {\n-                //create the right window for the most recent max timestamp in the combined window\n-                final long rightWinStart = combinedWindow.value.timestamp() + 1;\n-                if (!windowStartTimes.contains(rightWinStart) && combinedWindow.value.timestamp() < timestamp) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n+                //create the right window for the combined window's max record before the current record was added\n+                final long maxRightWindowStart = combinedWindow.value.timestamp() + 1;\n+                //only create the right window if new record falls within it and it does not already exist\n+                if (!windowStartTimes.contains(maxRightWindowStart) && previousRightWindowPossible(maxRightWindowStart, timestamp)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 118}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MTYyOTc0", "url": "https://github.com/apache/kafka/pull/9157#pullrequestreview-477162974", "createdAt": "2020-08-28T00:13:36Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMDoxMzozNlrOHIlUpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMDoxMzozNlrOHIlUpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2MjE1MQ==", "bodyText": "Alignment is still off, the first parameter should be on the same line as the method declaration. Also, if this method is only ever used in deciding whether to create the previous record's right window, then let's name the parameter previousRecordRightWindowStart or something. Of course, you could also just pass in the previousRecordTimestamp now that we have that, and then do the math in here. Whatever you think makes the most sense", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478762151", "createdAt": "2020-08-28T00:13:36Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream.internals;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.common.metrics.Sensor;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.kstream.Aggregator;\n+import org.apache.kafka.streams.kstream.Initializer;\n+import org.apache.kafka.streams.kstream.Window;\n+import org.apache.kafka.streams.kstream.Windowed;\n+import org.apache.kafka.streams.kstream.SlidingWindows;\n+import org.apache.kafka.streams.processor.AbstractProcessor;\n+import org.apache.kafka.streams.processor.Processor;\n+import org.apache.kafka.streams.processor.ProcessorContext;\n+import org.apache.kafka.streams.processor.internals.InternalProcessorContext;\n+import org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.TimestampedWindowStore;\n+import org.apache.kafka.streams.state.ValueAndTimestamp;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.apache.kafka.streams.processor.internals.metrics.TaskMetrics.droppedRecordsSensorOrLateRecordDropSensor;\n+import static org.apache.kafka.streams.processor.internals.metrics.TaskMetrics.droppedRecordsSensorOrSkippedRecordsSensor;\n+import static org.apache.kafka.streams.state.ValueAndTimestamp.getValueOrNull;\n+\n+public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProcessorSupplier<K, Windowed<K>, V, Agg> {\n+    private final Logger log = LoggerFactory.getLogger(getClass());\n+\n+    private final String storeName;\n+    private final SlidingWindows windows;\n+    private final Initializer<Agg> initializer;\n+    private final Aggregator<? super K, ? super V, Agg> aggregator;\n+\n+    private boolean sendOldValues = false;\n+\n+    public KStreamSlidingWindowAggregate(final SlidingWindows windows,\n+                                         final String storeName,\n+                                         final Initializer<Agg> initializer,\n+                                         final Aggregator<? super K, ? super V, Agg> aggregator) {\n+        this.windows = windows;\n+        this.storeName = storeName;\n+        this.initializer = initializer;\n+        this.aggregator = aggregator;\n+    }\n+\n+    @Override\n+    public Processor<K, V> get() {\n+        return new KStreamSlidingWindowAggregateProcessor();\n+    }\n+\n+    public SlidingWindows windows() {\n+        return windows;\n+    }\n+\n+    @Override\n+    public void enableSendingOldValues() {\n+        sendOldValues = true;\n+    }\n+\n+    private class KStreamSlidingWindowAggregateProcessor extends AbstractProcessor<K, V> {\n+        private TimestampedWindowStore<K, Agg> windowStore;\n+        private TimestampedTupleForwarder<Windowed<K>, Agg> tupleForwarder;\n+        private StreamsMetricsImpl metrics;\n+        private InternalProcessorContext internalProcessorContext;\n+        private Sensor lateRecordDropSensor;\n+        private Sensor droppedRecordsSensor;\n+        private long observedStreamTime = ConsumerRecord.NO_TIMESTAMP;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public void init(final ProcessorContext context) {\n+            super.init(context);\n+            internalProcessorContext = (InternalProcessorContext) context;\n+            metrics = internalProcessorContext.metrics();\n+            final String threadId = Thread.currentThread().getName();\n+            lateRecordDropSensor = droppedRecordsSensorOrLateRecordDropSensor(\n+                threadId,\n+                context.taskId().toString(),\n+                internalProcessorContext.currentNode().name(),\n+                metrics\n+            );\n+            droppedRecordsSensor = droppedRecordsSensorOrSkippedRecordsSensor(threadId, context.taskId().toString(), metrics);\n+            windowStore = (TimestampedWindowStore<K, Agg>) context.getStateStore(storeName);\n+            tupleForwarder = new TimestampedTupleForwarder<>(\n+                windowStore,\n+                context,\n+                new TimestampedCacheFlushListener<>(context),\n+                sendOldValues);\n+        }\n+\n+        @Override\n+        public void process(final K key, final V value) {\n+            if (key == null || value == null) {\n+                log.warn(\n+                    \"Skipping record due to null key or value. value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n+                    value, context().topic(), context().partition(), context().offset()\n+                );\n+                droppedRecordsSensor.record();\n+                return;\n+            }\n+\n+            final long timestamp = context().timestamp();\n+            processInOrder(key, value, timestamp);\n+        }\n+\n+        public void processInOrder(final K key, final V value, final long timestamp) {\n+\n+            observedStreamTime = Math.max(observedStreamTime, timestamp);\n+            final long closeTime = observedStreamTime - windows.gracePeriodMs();\n+\n+            if (timestamp < windows.timeDifferenceMs()) {\n+                processEarly(key, value, timestamp, closeTime);\n+                return;\n+            }\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            // keep the left type window closest to the record\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> latestLeftTypeWindow = null;\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime < timestamp) {\n+                        leftWinAgg = next.value;\n+                        // store the combined window (window from [0,timeDifference] that contains any early records)\n+                        // if it is found so that a right window can be created for the combined window's max record, as needed\n+                        if (isLeftWindow(next) || endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }\n+                    } else if (endTime == timestamp) {\n+                        leftWinAlreadyCreated = true;\n+                        // if current record's left window is the combined window, need to check later if there is a\n+                        // record that needs a right window within the combined window\n+                        if (endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+            //create right window for previous record\n+            if (latestLeftTypeWindow != null) {\n+                final long previousWindowEnd = latestLeftTypeWindow.key.window().end();\n+                final long rightWinStart = previousWindowEnd == windows.timeDifferenceMs() ? latestLeftTypeWindow.value.timestamp() + 1 : previousWindowEnd + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, rightWinStart, timestamp)) {\n+                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+            }\n+\n+            //create left window for new record\n+            if (!leftWinAlreadyCreated) {\n+                final ValueAndTimestamp<Agg> valueAndTime;\n+                // if there's a right window that the new record could create && max record falls within left window --> new record's left window is not empty\n+                if (latestLeftTypeWindow != null && recordFallsWithinCurrentRecordsLeftWindow(latestLeftTypeWindow.value.timestamp(), timestamp)) {\n+                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n+                } else {\n+                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                }\n+                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the combined window's max record before the current record was added\n+                final long maxRightWindowStart = combinedWindow.value.timestamp() + 1;\n+                //only create the previous record's right window if the new record falls within it and it does not already exist\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, maxRightWindowStart, timestamp)) {\n+                    final TimeWindow window = new TimeWindow(maxRightWindowStart, maxRightWindowStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+        }\n+\n+        private boolean recordFallsWithinCurrentRecordsLeftWindow(final long previousTimestamp, final long currentTimestamp) {\n+            return currentTimestamp - windows.timeDifferenceMs() <= previousTimestamp;\n+        }\n+\n+        // previous record's right window does not already exist and current record falls within previous record's right window\n+        private boolean rightWindowNecessaryAndPossible(\n+                                                    final Set<Long> windowStartTimes,\n+                                                    final long rightWindowStart,\n+                                                    final long currentRecordTimestamp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 292}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MTY5ODYy", "url": "https://github.com/apache/kafka/pull/9157#pullrequestreview-477169862", "createdAt": "2020-08-28T00:38:39Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMDozODo0MFrOHIlszw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMDozODo0MFrOHIlszw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2ODMzNQ==", "bodyText": "This is also kind of unclear (what is a max right window?), but I get that we can't call it previousRecordRightWindow since we don't know that it is a previous record or not at this point. I think yet again, just keeping track of the previous record's timestamp as we iterate through the windows, will be the most clear; if previousRecordTimestamp is still null by this point, we know right away that we don't have to create a previous right window. And then we can actually drop the rightWindowNecessaryAndPossible check altogether, since we know the current record has to be in range of the right window of the previous record (since we're in processEarly). The one exception is if the previous record and current record are on the same timestamp, so we can actually skip the previous right window creation if previousRecordTimestamp  is null OR equal to timestamp", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478768335", "createdAt": "2020-08-28T00:38:40Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream.internals;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.common.metrics.Sensor;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.kstream.Aggregator;\n+import org.apache.kafka.streams.kstream.Initializer;\n+import org.apache.kafka.streams.kstream.Window;\n+import org.apache.kafka.streams.kstream.Windowed;\n+import org.apache.kafka.streams.kstream.SlidingWindows;\n+import org.apache.kafka.streams.processor.AbstractProcessor;\n+import org.apache.kafka.streams.processor.Processor;\n+import org.apache.kafka.streams.processor.ProcessorContext;\n+import org.apache.kafka.streams.processor.internals.InternalProcessorContext;\n+import org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.TimestampedWindowStore;\n+import org.apache.kafka.streams.state.ValueAndTimestamp;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.apache.kafka.streams.processor.internals.metrics.TaskMetrics.droppedRecordsSensorOrLateRecordDropSensor;\n+import static org.apache.kafka.streams.processor.internals.metrics.TaskMetrics.droppedRecordsSensorOrSkippedRecordsSensor;\n+import static org.apache.kafka.streams.state.ValueAndTimestamp.getValueOrNull;\n+\n+public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProcessorSupplier<K, Windowed<K>, V, Agg> {\n+    private final Logger log = LoggerFactory.getLogger(getClass());\n+\n+    private final String storeName;\n+    private final SlidingWindows windows;\n+    private final Initializer<Agg> initializer;\n+    private final Aggregator<? super K, ? super V, Agg> aggregator;\n+\n+    private boolean sendOldValues = false;\n+\n+    public KStreamSlidingWindowAggregate(final SlidingWindows windows,\n+                                         final String storeName,\n+                                         final Initializer<Agg> initializer,\n+                                         final Aggregator<? super K, ? super V, Agg> aggregator) {\n+        this.windows = windows;\n+        this.storeName = storeName;\n+        this.initializer = initializer;\n+        this.aggregator = aggregator;\n+    }\n+\n+    @Override\n+    public Processor<K, V> get() {\n+        return new KStreamSlidingWindowAggregateProcessor();\n+    }\n+\n+    public SlidingWindows windows() {\n+        return windows;\n+    }\n+\n+    @Override\n+    public void enableSendingOldValues() {\n+        sendOldValues = true;\n+    }\n+\n+    private class KStreamSlidingWindowAggregateProcessor extends AbstractProcessor<K, V> {\n+        private TimestampedWindowStore<K, Agg> windowStore;\n+        private TimestampedTupleForwarder<Windowed<K>, Agg> tupleForwarder;\n+        private StreamsMetricsImpl metrics;\n+        private InternalProcessorContext internalProcessorContext;\n+        private Sensor lateRecordDropSensor;\n+        private Sensor droppedRecordsSensor;\n+        private long observedStreamTime = ConsumerRecord.NO_TIMESTAMP;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public void init(final ProcessorContext context) {\n+            super.init(context);\n+            internalProcessorContext = (InternalProcessorContext) context;\n+            metrics = internalProcessorContext.metrics();\n+            final String threadId = Thread.currentThread().getName();\n+            lateRecordDropSensor = droppedRecordsSensorOrLateRecordDropSensor(\n+                threadId,\n+                context.taskId().toString(),\n+                internalProcessorContext.currentNode().name(),\n+                metrics\n+            );\n+            droppedRecordsSensor = droppedRecordsSensorOrSkippedRecordsSensor(threadId, context.taskId().toString(), metrics);\n+            windowStore = (TimestampedWindowStore<K, Agg>) context.getStateStore(storeName);\n+            tupleForwarder = new TimestampedTupleForwarder<>(\n+                windowStore,\n+                context,\n+                new TimestampedCacheFlushListener<>(context),\n+                sendOldValues);\n+        }\n+\n+        @Override\n+        public void process(final K key, final V value) {\n+            if (key == null || value == null) {\n+                log.warn(\n+                    \"Skipping record due to null key or value. value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n+                    value, context().topic(), context().partition(), context().offset()\n+                );\n+                droppedRecordsSensor.record();\n+                return;\n+            }\n+\n+            final long timestamp = context().timestamp();\n+            processInOrder(key, value, timestamp);\n+        }\n+\n+        public void processInOrder(final K key, final V value, final long timestamp) {\n+\n+            observedStreamTime = Math.max(observedStreamTime, timestamp);\n+            final long closeTime = observedStreamTime - windows.gracePeriodMs();\n+\n+            if (timestamp < windows.timeDifferenceMs()) {\n+                processEarly(key, value, timestamp, closeTime);\n+                return;\n+            }\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            // keep the left type window closest to the record\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> latestLeftTypeWindow = null;\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime < timestamp) {\n+                        leftWinAgg = next.value;\n+                        // store the combined window (window from [0,timeDifference] that contains any early records)\n+                        // if it is found so that a right window can be created for the combined window's max record, as needed\n+                        if (isLeftWindow(next) || endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }\n+                    } else if (endTime == timestamp) {\n+                        leftWinAlreadyCreated = true;\n+                        // if current record's left window is the combined window, need to check later if there is a\n+                        // record that needs a right window within the combined window\n+                        if (endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+            //create right window for previous record\n+            if (latestLeftTypeWindow != null) {\n+                final long previousWindowEnd = latestLeftTypeWindow.key.window().end();\n+                final long rightWinStart = previousWindowEnd == windows.timeDifferenceMs() ? latestLeftTypeWindow.value.timestamp() + 1 : previousWindowEnd + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, rightWinStart, timestamp)) {\n+                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+            }\n+\n+            //create left window for new record\n+            if (!leftWinAlreadyCreated) {\n+                final ValueAndTimestamp<Agg> valueAndTime;\n+                // if there's a right window that the new record could create && max record falls within left window --> new record's left window is not empty\n+                if (latestLeftTypeWindow != null && recordFallsWithinCurrentRecordsLeftWindow(latestLeftTypeWindow.value.timestamp(), timestamp)) {\n+                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n+                } else {\n+                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                }\n+                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the combined window's max record before the current record was added\n+                final long maxRightWindowStart = combinedWindow.value.timestamp() + 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 266}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MTcwNTM4", "url": "https://github.com/apache/kafka/pull/9157#pullrequestreview-477170538", "createdAt": "2020-08-28T00:41:16Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMDo0MToxNlrOHIlvbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMDo0MToxNlrOHIlvbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2OTAwNA==", "bodyText": "Is this the same as in the non-early process? Maybe we can factor it out into  its own createRightWindowIfNeeded(or whatever)  method.", "url": "https://github.com/apache/kafka/pull/9157#discussion_r478769004", "createdAt": "2020-08-28T00:41:16Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.kstream.internals;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.common.metrics.Sensor;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.kstream.Aggregator;\n+import org.apache.kafka.streams.kstream.Initializer;\n+import org.apache.kafka.streams.kstream.Window;\n+import org.apache.kafka.streams.kstream.Windowed;\n+import org.apache.kafka.streams.kstream.SlidingWindows;\n+import org.apache.kafka.streams.processor.AbstractProcessor;\n+import org.apache.kafka.streams.processor.Processor;\n+import org.apache.kafka.streams.processor.ProcessorContext;\n+import org.apache.kafka.streams.processor.internals.InternalProcessorContext;\n+import org.apache.kafka.streams.processor.internals.metrics.StreamsMetricsImpl;\n+import org.apache.kafka.streams.state.KeyValueIterator;\n+import org.apache.kafka.streams.state.TimestampedWindowStore;\n+import org.apache.kafka.streams.state.ValueAndTimestamp;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.apache.kafka.streams.processor.internals.metrics.TaskMetrics.droppedRecordsSensorOrLateRecordDropSensor;\n+import static org.apache.kafka.streams.processor.internals.metrics.TaskMetrics.droppedRecordsSensorOrSkippedRecordsSensor;\n+import static org.apache.kafka.streams.state.ValueAndTimestamp.getValueOrNull;\n+\n+public class KStreamSlidingWindowAggregate<K, V, Agg> implements KStreamAggProcessorSupplier<K, Windowed<K>, V, Agg> {\n+    private final Logger log = LoggerFactory.getLogger(getClass());\n+\n+    private final String storeName;\n+    private final SlidingWindows windows;\n+    private final Initializer<Agg> initializer;\n+    private final Aggregator<? super K, ? super V, Agg> aggregator;\n+\n+    private boolean sendOldValues = false;\n+\n+    public KStreamSlidingWindowAggregate(final SlidingWindows windows,\n+                                         final String storeName,\n+                                         final Initializer<Agg> initializer,\n+                                         final Aggregator<? super K, ? super V, Agg> aggregator) {\n+        this.windows = windows;\n+        this.storeName = storeName;\n+        this.initializer = initializer;\n+        this.aggregator = aggregator;\n+    }\n+\n+    @Override\n+    public Processor<K, V> get() {\n+        return new KStreamSlidingWindowAggregateProcessor();\n+    }\n+\n+    public SlidingWindows windows() {\n+        return windows;\n+    }\n+\n+    @Override\n+    public void enableSendingOldValues() {\n+        sendOldValues = true;\n+    }\n+\n+    private class KStreamSlidingWindowAggregateProcessor extends AbstractProcessor<K, V> {\n+        private TimestampedWindowStore<K, Agg> windowStore;\n+        private TimestampedTupleForwarder<Windowed<K>, Agg> tupleForwarder;\n+        private StreamsMetricsImpl metrics;\n+        private InternalProcessorContext internalProcessorContext;\n+        private Sensor lateRecordDropSensor;\n+        private Sensor droppedRecordsSensor;\n+        private long observedStreamTime = ConsumerRecord.NO_TIMESTAMP;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public void init(final ProcessorContext context) {\n+            super.init(context);\n+            internalProcessorContext = (InternalProcessorContext) context;\n+            metrics = internalProcessorContext.metrics();\n+            final String threadId = Thread.currentThread().getName();\n+            lateRecordDropSensor = droppedRecordsSensorOrLateRecordDropSensor(\n+                threadId,\n+                context.taskId().toString(),\n+                internalProcessorContext.currentNode().name(),\n+                metrics\n+            );\n+            droppedRecordsSensor = droppedRecordsSensorOrSkippedRecordsSensor(threadId, context.taskId().toString(), metrics);\n+            windowStore = (TimestampedWindowStore<K, Agg>) context.getStateStore(storeName);\n+            tupleForwarder = new TimestampedTupleForwarder<>(\n+                windowStore,\n+                context,\n+                new TimestampedCacheFlushListener<>(context),\n+                sendOldValues);\n+        }\n+\n+        @Override\n+        public void process(final K key, final V value) {\n+            if (key == null || value == null) {\n+                log.warn(\n+                    \"Skipping record due to null key or value. value=[{}] topic=[{}] partition=[{}] offset=[{}]\",\n+                    value, context().topic(), context().partition(), context().offset()\n+                );\n+                droppedRecordsSensor.record();\n+                return;\n+            }\n+\n+            final long timestamp = context().timestamp();\n+            processInOrder(key, value, timestamp);\n+        }\n+\n+        public void processInOrder(final K key, final V value, final long timestamp) {\n+\n+            observedStreamTime = Math.max(observedStreamTime, timestamp);\n+            final long closeTime = observedStreamTime - windows.gracePeriodMs();\n+\n+            if (timestamp < windows.timeDifferenceMs()) {\n+                processEarly(key, value, timestamp, closeTime);\n+                return;\n+            }\n+\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            // aggregate that will go in the current record\u2019s left/right window (if needed)\n+            ValueAndTimestamp<Agg> leftWinAgg = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+\n+            //if current record's left/right windows already exist\n+            boolean leftWinAlreadyCreated = false;\n+            boolean rightWinAlreadyCreated = false;\n+\n+            // keep the left type window closest to the record\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> latestLeftTypeWindow = null;\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (endTime < timestamp) {\n+                        leftWinAgg = next.value;\n+                        // store the combined window (window from [0,timeDifference] that contains any early records)\n+                        // if it is found so that a right window can be created for the combined window's max record, as needed\n+                        if (isLeftWindow(next) || endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }\n+                    } else if (endTime == timestamp) {\n+                        leftWinAlreadyCreated = true;\n+                        // if current record's left window is the combined window, need to check later if there is a\n+                        // record that needs a right window within the combined window\n+                        if (endTime == windows.timeDifferenceMs()) {\n+                            latestLeftTypeWindow = next;\n+                        }\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (endTime > timestamp && startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+            //create right window for previous record\n+            if (latestLeftTypeWindow != null) {\n+                final long previousWindowEnd = latestLeftTypeWindow.key.window().end();\n+                final long rightWinStart = previousWindowEnd == windows.timeDifferenceMs() ? latestLeftTypeWindow.value.timestamp() + 1 : previousWindowEnd + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, rightWinStart, timestamp)) {\n+                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+            }\n+\n+            //create left window for new record\n+            if (!leftWinAlreadyCreated) {\n+                final ValueAndTimestamp<Agg> valueAndTime;\n+                // if there's a right window that the new record could create && max record falls within left window --> new record's left window is not empty\n+                if (latestLeftTypeWindow != null && recordFallsWithinCurrentRecordsLeftWindow(latestLeftTypeWindow.value.timestamp(), timestamp)) {\n+                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n+                } else {\n+                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                }\n+                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long endTime = startTime + windows.timeDifferenceMs();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the combined window's max record before the current record was added\n+                final long maxRightWindowStart = combinedWindow.value.timestamp() + 1;\n+                //only create the previous record's right window if the new record falls within it and it does not already exist\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, maxRightWindowStart, timestamp)) {\n+                    final TimeWindow window = new TimeWindow(maxRightWindowStart, maxRightWindowStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 280}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48328f651602f2078add6f780bb42199cd2c0316", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/48328f651602f2078add6f780bb42199cd2c0316", "committedDate": "2020-08-28T15:04:32Z", "message": "udpates wtih john's comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdfb1cde038e3750bb6d8c3900558bacc18feabc", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/fdfb1cde038e3750bb6d8c3900558bacc18feabc", "committedDate": "2020-08-28T15:42:10Z", "message": "udpates wtih john's comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ce06f9321e8c74eeb0c80daaf1acb0ca70f8bd8", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/1ce06f9321e8c74eeb0c80daaf1acb0ca70f8bd8", "committedDate": "2020-08-28T15:43:54Z", "message": "Merge branch 'slidingwindows' of github.com:lct45/kafka into slidingwindows"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd8c4e431479ce88ce3e95a5fe3ba288e5741ce8", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/dd8c4e431479ce88ce3e95a5fe3ba288e5741ce8", "committedDate": "2020-08-31T14:33:17Z", "message": "fixes for early records"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c7e736d6b0b7c9d40e946375065ac976428742b", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/8c7e736d6b0b7c9d40e946375065ac976428742b", "committedDate": "2020-08-31T14:33:17Z", "message": "working updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e1d23504ad4c733718fe1f491e0c95bb28e732e", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/8e1d23504ad4c733718fe1f491e0c95bb28e732e", "committedDate": "2020-08-31T14:33:17Z", "message": "algorithm and test updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c061076d72e51ed0ab056a8dc808566398cbf0d2", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/c061076d72e51ed0ab056a8dc808566398cbf0d2", "committedDate": "2020-08-31T14:33:17Z", "message": "updates from sophie's comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7663e7673f470ed74429440689904d92a7132d8", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/b7663e7673f470ed74429440689904d92a7132d8", "committedDate": "2020-08-31T15:17:44Z", "message": "PreviousRecord updates, method streamlining"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "b7663e7673f470ed74429440689904d92a7132d8", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/b7663e7673f470ed74429440689904d92a7132d8", "committedDate": "2020-08-31T15:17:44Z", "message": "PreviousRecord updates, method streamlining"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/8f75a48dcda6b2eed7c7a07e50436c8bc31ae783", "committedDate": "2020-08-31T22:49:05Z", "message": "rebase with sliding windows pr"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5OTk1MzA5", "url": "https://github.com/apache/kafka/pull/9157#pullrequestreview-479995309", "createdAt": "2020-09-01T18:08:24Z", "commit": {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxODowODoyNFrOHLCY6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxODo1NDo0OVrOHLD_VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMzNTUyOA==", "bodyText": "Seems like we should move this above into the top-level process instead of first calling processInOrder and then calling processEarly.  For one thing, since we actually do need to iterate the full range for the early records, we can just call processEarly without having to decide between processInOrder and processReverse", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481335528", "createdAt": "2020-09-01T18:08:24Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -135,7 +127,11 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             observedStreamTime = Math.max(observedStreamTime, timestamp);\n             final long closeTime = observedStreamTime - windows.gracePeriodMs();\n \n-            //store start times of windows we find\n+            if (timestamp < windows.timeDifferenceMs()) {\n+                processEarly(key, value, timestamp, closeTime);\n+                return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMzNTg0OA==", "bodyText": "Use previousRecordTimestamp like in processEarly.  You can probably remove the comment then", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481335848", "createdAt": "2020-09-01T18:09:01Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -146,13 +142,14 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             boolean leftWinAlreadyCreated = false;\n             boolean rightWinAlreadyCreated = false;\n \n-            // keep the left type window closest to the record\n-            Window latestLeftTypeWindow = null;\n+            // Store the previous record\n+            Long previousRecord = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMzODAzMA==", "bodyText": "This comment doesn't really add anything, it just describes what the code says. Also, don't we need to check that   windowMaxTimestamp > previousRecordTimestamp before updating previousRecordTimestamp (where windowMaxTimestamp = next.value.timestamp -- it would be nice to assign this to a variable with an explicit name to make it clear what next.value.timestamp actually means).\nSame goes for the below, I guess you could just put the check in a maybeUpdatePreviousRecordTimestamp() method and call it from both places", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481338030", "createdAt": "2020-09-01T18:13:09Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -164,11 +161,13 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n \n                     if (endTime < timestamp) {\n                         leftWinAgg = next.value;\n-                        if (isLeftWindow(next)) {\n-                            latestLeftTypeWindow = next.key.window();\n-                        }\n+                        // update to store the previous record", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0MTQ0Ng==", "bodyText": "This doesn't look right..why would we need to pass in the key and value to createRightWindow ? The distinguishing feature of the current record's right window is that it doesn't  include the current record at all. I see that createRightWindow ultimately calls putAndForward which takes a key and value, but that just seems misleading. I think we should either pass in null to putAndForward for things we don't need, or better yet (imo) don't use putAndForward for the right window creation and just have a clean separation between creation of the right window and everything else", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481341446", "createdAt": "2020-09-01T18:19:17Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0MjA4Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n          \n          \n            \n                     * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481342082", "createdAt": "2020-09-01T18:20:20Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0MjM5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n          \n          \n            \n                     * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481342393", "createdAt": "2020-09-01T18:20:57Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0MjU2MQ==", "bodyText": "update, or create? (or both?)", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481342561", "createdAt": "2020-09-01T18:21:16Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0MzIyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        //window from [0,timeDifference] that holds all early records\n          \n          \n            \n                        // A window from [0, timeDifferenceMs] that holds all early records\n          \n      \n    \n    \n  \n\nAlso I'd suggest putting the combinedWindow declaration (and comment) above rightWinAgg to avoid ambiguity in what the comment refers to", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481343220", "createdAt": "2020-09-01T18:22:31Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0NDk0NQ==", "bodyText": "I think we should always assign the next.value.timestamp value to a variable with an explicit name, eg windowMaxRecordTimestamp, because it's pretty non-obvious what it means and easy to forget", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481344945", "createdAt": "2020-09-01T18:25:44Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (next.value.timestamp() < timestamp) {\n+                            previousRecordTimestamp = next.value.timestamp();\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM0ODM4Nw==", "bodyText": "I think we should add a comment somewhere clarifying some things about how we set the previousRecordTimestamp in processEarly:\nBasically, we only need to check and maybe set it when we're on the combined window, because if it's still null when we're past the combined window then we know there was a record greater than the current record in the combined window already, and in that case we must have already created the right window for the actual previous record. Hopefully you can find a better & more concise way to explain that \ud83d\ude04", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481348387", "createdAt": "2020-09-01T18:32:01Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (next.value.timestamp() < timestamp) {\n+                            previousRecordTimestamp = next.value.timestamp();\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1NTk3Mw==", "bodyText": "Just leaving a note to the next reviewer, and making sure I understand this myself:\nIf we didn't find a right window agg that either means\n\nthere were no other windows with startTime <= timestamp, which means there are no records earlier than the current one, and no records later than timeDifference (but within range of the current record). We take that to mean that whatever is in the combined window is an aggregate of records that are all to the right of the current record. Note that there could be a record at the same timestamp as the current record, but we will check for that before actually creating the right window below (by checking !rightWinAlreadyCreated)\nThere is just a single record in the combined window that is earlier than the current record. We check for that with the combinedWindow.value.timestamp() > timestamp condition and in that case create no right window\n\nBy the way, can we move the creation of the right window to just after this block, to keep all the relevant logic together?", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481355973", "createdAt": "2020-09-01T18:46:20Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (next.value.timestamp() < timestamp) {\n+                            previousRecordTimestamp = next.value.timestamp();\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MDY3Mw==", "bodyText": "It's pretty weird to have to pass in key and value when they're not used to create the right window. I notice they're used in the log message for dropped late windows actually, but it seems odd that we should ever end up dropping the right window of the current record. If the record itself is that old, we should just drop it before even processing it, right?\nAssuming you do that, then it feels a lot more reasonable to not call putAndForward from createRightWindow at all, and just do the actual putting and forwarding for the right window case inline.", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481360673", "createdAt": "2020-09-01T18:53:58Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (next.value.timestamp() < timestamp) {\n+                            previousRecordTimestamp = next.value.timestamp();\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+                if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                    final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n             }\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createRightWindow(final long timestamp,\n+                                       final ValueAndTimestamp<Agg> rightWinAgg,\n+                                       final K key,\n+                                       final V value,\n+                                       final long closeTime) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+            putAndForward(window, valueAndTime, key, value, closeTime, timestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MTQ4NQ==", "bodyText": "This isn't used anymore, right?", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481361485", "createdAt": "2020-09-01T18:54:35Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (next.value.timestamp() < timestamp) {\n+                            previousRecordTimestamp = next.value.timestamp();\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+                if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                    final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n             }\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createRightWindow(final long timestamp,\n+                                       final ValueAndTimestamp<Agg> rightWinAgg,\n+                                       final K key,\n+                                       final V value,\n+                                       final long closeTime) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+            putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+        }\n+\n+        private boolean leftWindowNotEmpty(final long previousTimestamp, final long currentTimestamp) {\n+            return currentTimestamp - windows.timeDifferenceMs() <= previousTimestamp;\n         }\n \n-        private boolean isLeftWindow(final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> window) {\n-            return window.key.window().end() == window.value.timestamp();\n+        // previous record's right window does not already exist and current record falls within previous record's right window\n+        private boolean rightWindowNecessaryAndPossible(final Set<Long> windowStartTimes,\n+                                                        final long previousRightWindowStart,\n+                                                        final long currentRecordTimestamp) {\n+            return !windowStartTimes.contains(previousRightWindowStart) && previousRightWindowStart + windows.timeDifferenceMs() >= currentRecordTimestamp;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MTc0OQ==", "bodyText": "nit: remove this added line", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481361749", "createdAt": "2020-09-01T18:54:49Z", "author": {"login": "ableegoldman"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KGroupedStreamImplTest.java", "diffHunk": "@@ -239,6 +239,7 @@ private void doCountSlidingWindows(final  MockProcessorSupplier<Windowed<String>\n             inputTopic.pipeInput(\"2\", \"B\", 1000L);\n             inputTopic.pipeInput(\"3\", \"C\", 600L);\n         }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779", "committedDate": "2020-09-01T20:40:54Z", "message": "Method clean-up"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMTUyMzkx", "url": "https://github.com/apache/kafka/pull/9157#pullrequestreview-480152391", "createdAt": "2020-09-01T22:10:52Z", "commit": {"oid": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjoxMDo1M1rOHLKAvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQyMjozMzozMVrOHLKiXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2MDQxMw==", "bodyText": "Sorry, I think my previous comment was a bit unclear. I meant that we should move this block up to where we set the rightWinAgg right after the loop, since this is what we actually use the rightWinAgg for.\nI think the \"create right window for previous record\" logic is fine wherever", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481460413", "createdAt": "2020-09-01T22:10:53Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +190,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2MzMzMw==", "bodyText": "I think you mean  processInOrder, not  processEarly (this is correct in the code, it's just the latest comment that doesn't match up)", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481463333", "createdAt": "2020-09-01T22:17:57Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (next.value.timestamp() < timestamp) {\n+                            previousRecordTimestamp = next.value.timestamp();\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+                if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                    final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n             }\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createRightWindow(final long timestamp,\n+                                       final ValueAndTimestamp<Agg> rightWinAgg,\n+                                       final K key,\n+                                       final V value,\n+                                       final long closeTime) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+            putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+        }\n+\n+        private boolean leftWindowNotEmpty(final long previousTimestamp, final long currentTimestamp) {\n+            return currentTimestamp - windows.timeDifferenceMs() <= previousTimestamp;\n         }\n \n-        private boolean isLeftWindow(final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> window) {\n-            return window.key.window().end() == window.value.timestamp();\n+        // previous record's right window does not already exist and current record falls within previous record's right window\n+        private boolean rightWindowNecessaryAndPossible(final Set<Long> windowStartTimes,\n+                                                        final long previousRightWindowStart,\n+                                                        final long currentRecordTimestamp) {\n+            return !windowStartTimes.contains(previousRightWindowStart) && previousRightWindowStart + windows.timeDifferenceMs() >= currentRecordTimestamp;\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MTQ4NQ=="}, "originalCommit": {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2NTI2Mg==", "bodyText": "Do we need to use getValueOrNull here? It seems like rightWinAgg should never be null if we are using it to create a right window", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481465262", "createdAt": "2020-09-01T22:22:52Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -254,35 +257,43 @@ private void processEarly(final K key, final V value, final long timestamp, fina\n                 rightWinAgg = combinedWindow.value;\n             }\n \n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+\n             if (combinedWindow == null) {\n                 final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n                 final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n \n             } else {\n-                //create the right window for the previous record if the previous record exists and the window hasn't already been created\n-                if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n-                    final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n-                }\n                 //update the combined window with the new aggregate\n                 putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n             }\n             //create right window for new record if needed\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n             }\n         }\n \n-        private void createRightWindow(final long timestamp,\n-                                       final ValueAndTimestamp<Agg> rightWinAgg,\n-                                       final K key,\n-                                       final V value,\n-                                       final long closeTime) {\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n             final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n-            putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), rightWinAgg.timestamp());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2NzA1Ng==", "bodyText": "Same here, can this ever be null? It doesn't seem like it, even if it's a new window we still pass in the initializer value so valueAndTime won't ever be null. ...right?", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481467056", "createdAt": "2020-09-01T22:27:44Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -311,13 +322,8 @@ private void putAndForward(final Window window,\n             if (windowEnd > closeTime) {\n                 //get aggregate from existing window\n                 final Agg oldAgg = getValueOrNull(valueAndTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2OTAyMQ==", "bodyText": "Oh good point, we definitely need the key. But I think separating them turned out well", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481469021", "createdAt": "2020-09-01T22:33:31Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (next.value.timestamp() < timestamp) {\n+                            previousRecordTimestamp = next.value.timestamp();\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+                if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                    final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                }\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n             }\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createRightWindow(final long timestamp,\n+                                       final ValueAndTimestamp<Agg> rightWinAgg,\n+                                       final K key,\n+                                       final V value,\n+                                       final long closeTime) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+            putAndForward(window, valueAndTime, key, value, closeTime, timestamp);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MDY3Mw=="}, "originalCommit": {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783"}, "originalPosition": 182}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwMjMwMzk0", "url": "https://github.com/apache/kafka/pull/9157#pullrequestreview-480230394", "createdAt": "2020-09-02T00:50:35Z", "commit": {"oid": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMDo1MDozNlrOHLNLxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwMDo1MDozNlrOHLNLxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMjM4OA==", "bodyText": "By the way, I think we should also check if the record is so old that even the latest window it could possibly create/affect would be dropped, and then not process the record at all. (ie basically check if the current record's right window would be dropped) We can record on the lateRecordDropSensor and log the message using the current record's left window.", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481512388", "createdAt": "2020-09-02T00:50:36Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -118,24 +118,20 @@ public void process(final K key, final V value) {\n             }\n \n             final long timestamp = context().timestamp();\n-            //don't process records that don't fall within a full sliding window\n+            final long closeTime = observedStreamTime - windows.gracePeriodMs();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99507f5d005023eec78a21b6c52cb4e228ee1434", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/99507f5d005023eec78a21b6c52cb4e228ee1434", "committedDate": "2020-09-02T15:20:45Z", "message": "Sliding Windows structural updates"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "99507f5d005023eec78a21b6c52cb4e228ee1434", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/99507f5d005023eec78a21b6c52cb4e228ee1434", "committedDate": "2020-09-02T15:20:45Z", "message": "Sliding Windows structural updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0461645e135237553a65ab7f43750b3f3ee8e5a", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/c0461645e135237553a65ab7f43750b3f3ee8e5a", "committedDate": "2020-09-02T17:34:44Z", "message": "add testing for early records"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTY4Nzg3", "url": "https://github.com/apache/kafka/pull/9157#pullrequestreview-481168787", "createdAt": "2020-09-02T18:45:08Z", "commit": {"oid": "c0461645e135237553a65ab7f43750b3f3ee8e5a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxODo0NTowOVrOHL9HRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQxODo0NTowOVrOHL9HRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI5NzY2OQ==", "bodyText": "Wait...what's going on here? Aren't we just creating a new ValueAndTimestamp that's identical to the rightWinAgg? We don't need to make a copy, I assume", "url": "https://github.com/apache/kafka/pull/9157#discussion_r482297669", "createdAt": "2020-09-02T18:45:09Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,127 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n+            }\n+\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(rightWinAgg.value(), rightWinAgg.timestamp());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0461645e135237553a65ab7f43750b3f3ee8e5a"}, "originalPosition": 218}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b250d7dc49daf1c98b307cd3367b0088b1952e5a", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/b250d7dc49daf1c98b307cd3367b0088b1952e5a", "committedDate": "2020-09-02T19:13:54Z", "message": "Simplify creating current right window"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgwNTA5MTE5", "url": "https://github.com/apache/kafka/pull/9157#pullrequestreview-480509119", "createdAt": "2020-09-02T06:09:47Z", "commit": {"oid": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMlQwNjowOTo0OFrOHLckJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMjozNjoxM1rOHM5pew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc2NDM5MQ==", "bodyText": "nit: next is not a great name; maybe existingWindow instead?", "url": "https://github.com/apache/kafka/pull/9157#discussion_r481764391", "createdAt": "2020-09-02T06:09:48Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -161,29 +157,31 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n                     windowStartTimes.add(next.key.window().start());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7eab7796055a7e7e3ccb5b4ec8c818ef6cf42779"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3MzA1Ng==", "bodyText": "Not sure how this change relates to \"early records\"?", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483073056", "createdAt": "2020-09-03T15:37:47Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -228,13 +345,8 @@ private void putAndForward(final Window window,\n             if (windowEnd > closeTime) {\n                 //get aggregate from existing window\n                 final Agg oldAgg = getValueOrNull(valueAndTime);\n-                final Agg newAgg;\n-                // keep old aggregate if adding a right window, else add new record's value\n-                if (windowStart == timestamp + 1) {\n-                    newAgg = oldAgg;\n-                } else {\n-                    newAgg = aggregator.apply(key, value, oldAgg);\n-                }\n+                final Agg newAgg = aggregator.apply(key, value, oldAgg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b250d7dc49daf1c98b307cd3367b0088b1952e5a"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NDAwOQ==", "bodyText": "Why do we need to check the timestamp?", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483074009", "createdAt": "2020-09-03T15:39:10Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n             }\n+\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            windowStore.put(\n+                key,\n+                rightWinAgg,\n+                window.start());\n+            tupleForwarder.maybeForward(\n+                new Windowed<>(key, window),\n+                rightWinAgg.value(),\n+                null,\n+                rightWinAgg.timestamp());\n+        }\n+\n+        private boolean leftWindowNotEmpty(final long previousTimestamp, final long currentTimestamp) {\n+            return currentTimestamp - windows.timeDifferenceMs() <= previousTimestamp;\n+        }\n+\n+        // previous record's right window does not already exist and current record falls within previous record's right window\n+        private boolean rightWindowNecessaryAndPossible(final Set<Long> windowStartTimes,\n+                                                        final long previousRightWindowStart,\n+                                                        final long currentRecordTimestamp) {\n+            return !windowStartTimes.contains(previousRightWindowStart) && previousRightWindowStart + windows.timeDifferenceMs() >= currentRecordTimestamp;\n         }\n \n-        private boolean isLeftWindow(final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> window) {\n-            return window.key.window().end() == window.value.timestamp();\n+        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n+            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b250d7dc49daf1c98b307cd3367b0088b1952e5a"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NzIzOA==", "bodyText": "q: Should we rename currentTimestamp -> timestamp for consistency? (or maybe, rename timestamp to inputRecordTimestamp all over the place?", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483077238", "createdAt": "2020-09-03T15:43:54Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n             }\n+\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            windowStore.put(\n+                key,\n+                rightWinAgg,\n+                window.start());\n+            tupleForwarder.maybeForward(\n+                new Windowed<>(key, window),\n+                rightWinAgg.value(),\n+                null,\n+                rightWinAgg.timestamp());\n+        }\n+\n+        private boolean leftWindowNotEmpty(final long previousTimestamp, final long currentTimestamp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b250d7dc49daf1c98b307cd3367b0088b1952e5a"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3ODAxOA==", "bodyText": "Why do we do this check based on timestamps?", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483078018", "createdAt": "2020-09-03T15:44:59Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n             }\n+\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            windowStore.put(\n+                key,\n+                rightWinAgg,\n+                window.start());\n+            tupleForwarder.maybeForward(\n+                new Windowed<>(key, window),\n+                rightWinAgg.value(),\n+                null,\n+                rightWinAgg.timestamp());\n+        }\n+\n+        private boolean leftWindowNotEmpty(final long previousTimestamp, final long currentTimestamp) {\n+            return currentTimestamp - windows.timeDifferenceMs() <= previousTimestamp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b250d7dc49daf1c98b307cd3367b0088b1952e5a"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3OTIyOQ==", "bodyText": "Same question as above about currentRecordTimestamp (It seems best to me, to use the same variable name for the same think throughout all methods.)", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483079229", "createdAt": "2020-09-03T15:46:40Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+\n+            //create the right window for the previous record if the previous record exists and the window hasn't already been created\n+            if (previousRecordTimestamp != null && !windowStartTimes.contains(previousRecordTimestamp + 1)) {\n+                final TimeWindow window = new TimeWindow(previousRecordTimestamp + 1, previousRecordTimestamp + 1 + windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            }\n+\n+            if (combinedWindow == null) {\n+                final TimeWindow window = new TimeWindow(0, windows.timeDifferenceMs());\n+                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+\n+            } else {\n+                //update the combined window with the new aggregate\n+                putAndForward(combinedWindow.key.window(), combinedWindow.value, key, value, closeTime, timestamp);\n             }\n+\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        private void createCurrentRecordRightWindow(final long timestamp,\n+                                                    final ValueAndTimestamp<Agg> rightWinAgg,\n+                                                    final K key) {\n+            final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n+            windowStore.put(\n+                key,\n+                rightWinAgg,\n+                window.start());\n+            tupleForwarder.maybeForward(\n+                new Windowed<>(key, window),\n+                rightWinAgg.value(),\n+                null,\n+                rightWinAgg.timestamp());\n+        }\n+\n+        private boolean leftWindowNotEmpty(final long previousTimestamp, final long currentTimestamp) {\n+            return currentTimestamp - windows.timeDifferenceMs() <= previousTimestamp;\n+        }\n+\n+        // previous record's right window does not already exist and current record falls within previous record's right window\n+        private boolean rightWindowNecessaryAndPossible(final Set<Long> windowStartTimes,\n+                                                        final long previousRightWindowStart,\n+                                                        final long currentRecordTimestamp) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b250d7dc49daf1c98b307cd3367b0088b1952e5a"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA4MjA2MA==", "bodyText": "nit: Instead, they will fall within the [0, timeDifferenceMs] -> Instead, we will put them into the [0, timeDifferenceMs] window as a \"workaround\",", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483082060", "createdAt": "2020-09-03T15:50:56Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b250d7dc49daf1c98b307cd3367b0088b1952e5a"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA4NTA2Mw==", "bodyText": "nit: flip both lines:\nfinal long startTime = next.key.window().start();\nwindowStartTimes.add(startTime);", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483085063", "createdAt": "2020-09-03T15:55:27Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b250d7dc49daf1c98b307cd3367b0088b1952e5a"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNTE2OA==", "bodyText": "Not sure if I understand the last sentence: This will always be true for early records, as they all fall within [0, timeDifferenceMs]?\nAlso not sure how this comment relates to setting previousRecordTimestamp ?", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483205168", "createdAt": "2020-09-03T19:25:49Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b250d7dc49daf1c98b307cd3367b0088b1952e5a"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIwNzEwNg==", "bodyText": "nit: should we rename putAndForward to updateWindowAndForward?", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483207106", "createdAt": "2020-09-03T19:29:55Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b250d7dc49daf1c98b307cd3367b0088b1952e5a"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxMDkxMg==", "bodyText": "Seem this can be a simple else? No need to verify the condition? (Maybe it's helpful to add a comment instead?)", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483210912", "createdAt": "2020-09-03T19:37:52Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            // If maxRecordTimestamp > timestamp, the current record is out-of-order, meaning that the\n+                            // previous record's right window would have been created already by other records. This\n+                            // will always be true for early records, as they all fall within [0, timeDifferenceMs].\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b250d7dc49daf1c98b307cd3367b0088b1952e5a"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzIxNDgwNQ==", "bodyText": "Given, that we call processEarly only if 0 < timestamp < timeDifferenceMs, we know that timestamp - 2 * windows.timeDifferenceMs() would always be negative? Thus, we can just pass in zero here?\nIf this is correct, we might want to add a check at the beginning of this method:\nif (timestamp < 0 || timestamp >= timeDifferenceMs) {\n  throw new IllegalArgumentException(\"...\");\n}", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483214805", "createdAt": "2020-09-03T19:45:54Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +213,125 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecordTimestamp != null && leftWindowNotEmpty(previousRecordTimestamp, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createCurrentRecordRightWindow(timestamp, rightWinAgg, key);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records where 0 < timestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifferenceMs]\n+         * window, and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b250d7dc49daf1c98b307cd3367b0088b1952e5a"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI4NTQ5Ng==", "bodyText": "Not sure if I can follow. If combinedWindow.value.timestamp() > timestamp this seems to imply that the current record is out-of-order? Above, you state that for the out-of-order case, the right window would always exist already though? So why do we need this additional check?", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483285496", "createdAt": "2020-09-03T22:24:08Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -192,29 +191,113 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (previousRecord != null && leftWindowNotEmpty(previousRecord, timestamp)) {\n                     valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n                 } else {\n                     valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n                 }\n                 final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n                 putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n             }\n-            //create right window for new record\n             if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n+                createRightWindow(timestamp, rightWinAgg, key, value, closeTime);\n+            }\n+        }\n+\n+        /**\n+         * Created to handle records that have a timestamp > 0 but < timeDifference. These records would create\n+         * windows with negative start times, which is not supported. Instead, they will fall within the [0, timeDifference]\n+         * window, and we will update their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long timestamp, final long closeTime) {\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            //window from [0,timeDifference] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    Math.max(0, timestamp - 2 * windows.timeDifferenceMs()),\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    timestamp + 1)\n+            ) {\n+                KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next;\n+                while (iterator.hasNext()) {\n+                    next = iterator.next();\n+                    windowStartTimes.add(next.key.window().start());\n+                    final long startTime = next.key.window().start();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = next;\n+                        if (next.value.timestamp() < timestamp) {\n+                            previousRecordTimestamp = next.value.timestamp();\n+                        }\n+\n+                    } else if (startTime <= timestamp) {\n+                        rightWinAgg = next.value;\n+                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n+                    } else if (startTime == timestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    }\n+                }\n+            }\n+\n+            // if there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > timestamp) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM1NTk3Mw=="}, "originalCommit": {"oid": "8f75a48dcda6b2eed7c7a07e50436c8bc31ae783"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI4OTQ2Nw==", "bodyText": "Seems we don't need the if as this is the only valid case? Adding a comment might be helpful.\nIf you want to keep the if as a sanity check, we should add a final:\n} else {\n  throw new IllegalStateException(...):\n}", "url": "https://github.com/apache/kafka/pull/9157#discussion_r483289467", "createdAt": "2020-09-03T22:36:13Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -161,29 +180,31 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n                     windowStartTimes.add(next.key.window().start());\n                     final long startTime = next.key.window().start();\n                     final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = next.value.timestamp();\n \n                     if (endTime < timestamp) {\n                         leftWinAgg = next.value;\n-                        if (isLeftWindow(next)) {\n-                            latestLeftTypeWindow = next.key.window();\n-                        }\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n                     } else if (endTime == timestamp) {\n                         leftWinAlreadyCreated = true;\n+                        if (windowMaxRecordTimestamp < timestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n                         putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n                     } else if (endTime > timestamp && startTime <= timestamp) {\n                         rightWinAgg = next.value;\n                         putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                    } else if (startTime == timestamp + 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b250d7dc49daf1c98b307cd3367b0088b1952e5a"}, "originalPosition": 94}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f1c0158a11beab28c5cbae7fb65e2e45e3f6159", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/6f1c0158a11beab28c5cbae7fb65e2e45e3f6159", "committedDate": "2020-09-04T17:15:14Z", "message": "Matthias's updates"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "586621302e59977d8b6eb3ddf15714cc39c0df3b", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/586621302e59977d8b6eb3ddf15714cc39c0df3b", "committedDate": "2020-09-08T16:35:39Z", "message": "updated comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6821e92e2cfd4ee8d763cdf2569578682db6d463", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/6821e92e2cfd4ee8d763cdf2569578682db6d463", "committedDate": "2020-09-08T16:40:56Z", "message": "Merge branch 'trunk' of github.com:apache/kafka into early-records"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDA5NzY5", "url": "https://github.com/apache/kafka/pull/9157#pullrequestreview-484409769", "createdAt": "2020-09-08T18:54:25Z", "commit": {"oid": "6821e92e2cfd4ee8d763cdf2569578682db6d463"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxODo1NDoyNVrOHOp9fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxOTozMjo0OVrOHOrLyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyOTU5OQ==", "bodyText": "nit: 1 -> 1L", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485129599", "createdAt": "2020-09-08T18:54:25Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -117,25 +117,44 @@ public void process(final K key, final V value) {\n                 return;\n             }\n \n-            final long timestamp = context().timestamp();\n-            //don't process records that don't fall within a full sliding window\n-            if (timestamp < windows.timeDifferenceMs()) {\n+            final long inputRecordTimestamp = context().timestamp();\n+            observedStreamTime = Math.max(observedStreamTime, inputRecordTimestamp);\n+            final long closeTime = observedStreamTime - windows.gracePeriodMs();\n+\n+            if (inputRecordTimestamp + 1 + windows.timeDifferenceMs() <= closeTime) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6821e92e2cfd4ee8d763cdf2569578682db6d463"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MTIwMQ==", "bodyText": "nit: fall between 0 < inputRecordTimestamp -> fall between 0 <= inputRecordTimestamp", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485141201", "createdAt": "2020-09-08T19:16:26Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -146,96 +165,203 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             boolean leftWinAlreadyCreated = false;\n             boolean rightWinAlreadyCreated = false;\n \n-            // keep the left type window closest to the record\n-            Window latestLeftTypeWindow = null;\n+            Long previousRecordTimestamp = null;\n+\n             try (\n                 final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n                     key,\n                     key,\n-                    timestamp - 2 * windows.timeDifferenceMs(),\n+                    Math.max(0, inputRecordTimestamp - 2 * windows.timeDifferenceMs()),\n                     // to catch the current record's right window, if it exists, without more calls to the store\n-                    timestamp + 1)\n+                    inputRecordTimestamp + 1)\n             ) {\n                 while (iterator.hasNext()) {\n-                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n-                    windowStartTimes.add(next.key.window().start());\n-                    final long startTime = next.key.window().start();\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n                     final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n \n-                    if (endTime < timestamp) {\n-                        leftWinAgg = next.value;\n-                        if (isLeftWindow(next)) {\n-                            latestLeftTypeWindow = next.key.window();\n-                        }\n-                    } else if (endTime == timestamp) {\n+                    if (endTime < inputRecordTimestamp) {\n+                        leftWinAgg = windowBeingProcessed.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                    } else if (endTime == inputRecordTimestamp) {\n                         leftWinAlreadyCreated = true;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n-                        rightWinAgg = next.value;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                        if (windowMaxRecordTimestamp < inputRecordTimestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (endTime > inputRecordTimestamp && startTime <= inputRecordTimestamp) {\n+                        rightWinAgg = windowBeingProcessed.value;\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (startTime == inputRecordTimestamp + 1) {\n                         rightWinAlreadyCreated = true;\n+                    } else {\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n                     }\n                 }\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n+                    final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (leftWindowNotEmpty(previousRecordTimestamp, inputRecordTimestamp)) {\n+                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), inputRecordTimestamp);\n                 } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n                 }\n-                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                final TimeWindow window = new TimeWindow(inputRecordTimestamp - windows.timeDifferenceMs(), inputRecordTimestamp);\n+                updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n             }\n-            //create right window for new record\n-            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, inputRecordTimestamp)) {\n+                createCurrentRecordRightWindow(inputRecordTimestamp, rightWinAgg, key);\n             }\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        /**\n+         * Created to handle records where 0 < inputRecordTimestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, we will put them into the [0, timeDifferenceMs]\n+         * window as a \"workaround\", and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long inputRecordTimestamp, final long closeTime) {\n+            if (inputRecordTimestamp < 0 || inputRecordTimestamp >= windows.timeDifferenceMs()) {\n+                throw new IllegalArgumentException(\"Early record for sliding windows must fall between 0 < inputRecordTimestamp < timeDifferenceMs\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6821e92e2cfd4ee8d763cdf2569578682db6d463"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MTg5Mg==", "bodyText": "nit: maxRecordTimestamp > timestamp -> maxRecordTimestamp >= timestamp\nnit: missing space: // We", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485141892", "createdAt": "2020-09-08T19:17:55Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -146,96 +165,203 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             boolean leftWinAlreadyCreated = false;\n             boolean rightWinAlreadyCreated = false;\n \n-            // keep the left type window closest to the record\n-            Window latestLeftTypeWindow = null;\n+            Long previousRecordTimestamp = null;\n+\n             try (\n                 final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n                     key,\n                     key,\n-                    timestamp - 2 * windows.timeDifferenceMs(),\n+                    Math.max(0, inputRecordTimestamp - 2 * windows.timeDifferenceMs()),\n                     // to catch the current record's right window, if it exists, without more calls to the store\n-                    timestamp + 1)\n+                    inputRecordTimestamp + 1)\n             ) {\n                 while (iterator.hasNext()) {\n-                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n-                    windowStartTimes.add(next.key.window().start());\n-                    final long startTime = next.key.window().start();\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n                     final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n \n-                    if (endTime < timestamp) {\n-                        leftWinAgg = next.value;\n-                        if (isLeftWindow(next)) {\n-                            latestLeftTypeWindow = next.key.window();\n-                        }\n-                    } else if (endTime == timestamp) {\n+                    if (endTime < inputRecordTimestamp) {\n+                        leftWinAgg = windowBeingProcessed.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                    } else if (endTime == inputRecordTimestamp) {\n                         leftWinAlreadyCreated = true;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n-                        rightWinAgg = next.value;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                        if (windowMaxRecordTimestamp < inputRecordTimestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (endTime > inputRecordTimestamp && startTime <= inputRecordTimestamp) {\n+                        rightWinAgg = windowBeingProcessed.value;\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (startTime == inputRecordTimestamp + 1) {\n                         rightWinAlreadyCreated = true;\n+                    } else {\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n                     }\n                 }\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n+                    final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (leftWindowNotEmpty(previousRecordTimestamp, inputRecordTimestamp)) {\n+                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), inputRecordTimestamp);\n                 } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n                 }\n-                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                final TimeWindow window = new TimeWindow(inputRecordTimestamp - windows.timeDifferenceMs(), inputRecordTimestamp);\n+                updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n             }\n-            //create right window for new record\n-            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, inputRecordTimestamp)) {\n+                createCurrentRecordRightWindow(inputRecordTimestamp, rightWinAgg, key);\n             }\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        /**\n+         * Created to handle records where 0 < inputRecordTimestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, we will put them into the [0, timeDifferenceMs]\n+         * window as a \"workaround\", and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long inputRecordTimestamp, final long closeTime) {\n+            if (inputRecordTimestamp < 0 || inputRecordTimestamp >= windows.timeDifferenceMs()) {\n+                throw new IllegalArgumentException(\"Early record for sliding windows must fall between 0 < inputRecordTimestamp < timeDifferenceMs\");\n+            }\n+\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    0,\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    inputRecordTimestamp + 1)\n+            ) {\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = windowBeingProcessed;\n+                        //We don't need to store previousRecordTimestamp if maxRecordTimestamp > timestamp", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6821e92e2cfd4ee8d763cdf2569578682db6d463"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0OTY0MQ==", "bodyText": "Why do we need to suppress?", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485149641", "createdAt": "2020-09-08T19:32:49Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregateTest.java", "diffHunk": "@@ -439,6 +442,185 @@ public void testJoin() {\n         }\n     }\n \n+    @SuppressWarnings(\"unchecked\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6821e92e2cfd4ee8d763cdf2569578682db6d463"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NTIyODQ0", "url": "https://github.com/apache/kafka/pull/9157#pullrequestreview-484522844", "createdAt": "2020-09-08T22:03:54Z", "commit": {"oid": "6821e92e2cfd4ee8d763cdf2569578682db6d463"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjowMzo1NFrOHOvivA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjowMzo1NFrOHOvivA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMTA1Mg==", "bodyText": "nit: log an error and include the relevant info (eg windowStart and inputRecordTimestamp at least). Same for the IllegalStateException in processEarly", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485221052", "createdAt": "2020-09-08T22:03:54Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -146,96 +165,203 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             boolean leftWinAlreadyCreated = false;\n             boolean rightWinAlreadyCreated = false;\n \n-            // keep the left type window closest to the record\n-            Window latestLeftTypeWindow = null;\n+            Long previousRecordTimestamp = null;\n+\n             try (\n                 final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n                     key,\n                     key,\n-                    timestamp - 2 * windows.timeDifferenceMs(),\n+                    Math.max(0, inputRecordTimestamp - 2 * windows.timeDifferenceMs()),\n                     // to catch the current record's right window, if it exists, without more calls to the store\n-                    timestamp + 1)\n+                    inputRecordTimestamp + 1)\n             ) {\n                 while (iterator.hasNext()) {\n-                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n-                    windowStartTimes.add(next.key.window().start());\n-                    final long startTime = next.key.window().start();\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n                     final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n \n-                    if (endTime < timestamp) {\n-                        leftWinAgg = next.value;\n-                        if (isLeftWindow(next)) {\n-                            latestLeftTypeWindow = next.key.window();\n-                        }\n-                    } else if (endTime == timestamp) {\n+                    if (endTime < inputRecordTimestamp) {\n+                        leftWinAgg = windowBeingProcessed.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                    } else if (endTime == inputRecordTimestamp) {\n                         leftWinAlreadyCreated = true;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n-                        rightWinAgg = next.value;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                        if (windowMaxRecordTimestamp < inputRecordTimestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (endTime > inputRecordTimestamp && startTime <= inputRecordTimestamp) {\n+                        rightWinAgg = windowBeingProcessed.value;\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (startTime == inputRecordTimestamp + 1) {\n                         rightWinAlreadyCreated = true;\n+                    } else {\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6821e92e2cfd4ee8d763cdf2569578682db6d463"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NTI1MjA3", "url": "https://github.com/apache/kafka/pull/9157#pullrequestreview-484525207", "createdAt": "2020-09-08T22:09:09Z", "commit": {"oid": "6821e92e2cfd4ee8d763cdf2569578682db6d463"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjowOTowOVrOHOvqVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjowOTowOVrOHOvqVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyMjk5Ng==", "bodyText": "nit: this code is pretty self-explanatory now, so the comment isn't really adding anything", "url": "https://github.com/apache/kafka/pull/9157#discussion_r485222996", "createdAt": "2020-09-08T22:09:09Z", "author": {"login": "ableegoldman"}, "path": "streams/src/main/java/org/apache/kafka/streams/kstream/internals/KStreamSlidingWindowAggregate.java", "diffHunk": "@@ -146,96 +165,203 @@ public void processInOrder(final K key, final V value, final long timestamp) {\n             boolean leftWinAlreadyCreated = false;\n             boolean rightWinAlreadyCreated = false;\n \n-            // keep the left type window closest to the record\n-            Window latestLeftTypeWindow = null;\n+            Long previousRecordTimestamp = null;\n+\n             try (\n                 final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n                     key,\n                     key,\n-                    timestamp - 2 * windows.timeDifferenceMs(),\n+                    Math.max(0, inputRecordTimestamp - 2 * windows.timeDifferenceMs()),\n                     // to catch the current record's right window, if it exists, without more calls to the store\n-                    timestamp + 1)\n+                    inputRecordTimestamp + 1)\n             ) {\n                 while (iterator.hasNext()) {\n-                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> next = iterator.next();\n-                    windowStartTimes.add(next.key.window().start());\n-                    final long startTime = next.key.window().start();\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n                     final long endTime = startTime + windows.timeDifferenceMs();\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n \n-                    if (endTime < timestamp) {\n-                        leftWinAgg = next.value;\n-                        if (isLeftWindow(next)) {\n-                            latestLeftTypeWindow = next.key.window();\n-                        }\n-                    } else if (endTime == timestamp) {\n+                    if (endTime < inputRecordTimestamp) {\n+                        leftWinAgg = windowBeingProcessed.value;\n+                        previousRecordTimestamp = windowMaxRecordTimestamp;\n+                    } else if (endTime == inputRecordTimestamp) {\n                         leftWinAlreadyCreated = true;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else if (endTime > timestamp && startTime <= timestamp) {\n-                        rightWinAgg = next.value;\n-                        putAndForward(next.key.window(), next.value, key, value, closeTime, timestamp);\n-                    } else {\n+                        if (windowMaxRecordTimestamp < inputRecordTimestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (endTime > inputRecordTimestamp && startTime <= inputRecordTimestamp) {\n+                        rightWinAgg = windowBeingProcessed.value;\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (startTime == inputRecordTimestamp + 1) {\n                         rightWinAlreadyCreated = true;\n+                    } else {\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n                     }\n                 }\n             }\n \n             //create right window for previous record\n-            if (latestLeftTypeWindow != null) {\n-                final long rightWinStart = latestLeftTypeWindow.end() + 1;\n-                if (!windowStartTimes.contains(rightWinStart)) {\n-                    final TimeWindow window = new TimeWindow(rightWinStart, rightWinStart + windows.timeDifferenceMs());\n-                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n-                    putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (previousRecordTimestamp != null) {\n+                final long previousRightWinStart = previousRecordTimestamp + 1;\n+                if (rightWindowNecessaryAndPossible(windowStartTimes, previousRightWinStart, inputRecordTimestamp)) {\n+                    final TimeWindow window = new TimeWindow(previousRightWinStart, previousRightWinStart + windows.timeDifferenceMs());\n+                    final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n+                    updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n                 }\n             }\n \n             //create left window for new record\n             if (!leftWinAlreadyCreated) {\n                 final ValueAndTimestamp<Agg> valueAndTime;\n-                //there's a right window that the new record could create --> new record's left window is not empty\n-                if (latestLeftTypeWindow != null) {\n-                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), timestamp);\n+                // if there's a right window that the new record could create && previous record falls within left window -> new record's left window is not empty\n+                if (leftWindowNotEmpty(previousRecordTimestamp, inputRecordTimestamp)) {\n+                    valueAndTime = ValueAndTimestamp.make(leftWinAgg.value(), inputRecordTimestamp);\n                 } else {\n-                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), timestamp);\n+                    valueAndTime = ValueAndTimestamp.make(initializer.apply(), inputRecordTimestamp);\n                 }\n-                final TimeWindow window = new TimeWindow(timestamp - windows.timeDifferenceMs(), timestamp);\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+                final TimeWindow window = new TimeWindow(inputRecordTimestamp - windows.timeDifferenceMs(), inputRecordTimestamp);\n+                updateWindowAndForward(window, valueAndTime, key, value, closeTime, inputRecordTimestamp);\n             }\n-            //create right window for new record\n-            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, timestamp)) {\n-                final TimeWindow window = new TimeWindow(timestamp + 1, timestamp + 1 + windows.timeDifferenceMs());\n-                final ValueAndTimestamp<Agg> valueAndTime = ValueAndTimestamp.make(getValueOrNull(rightWinAgg), Math.max(rightWinAgg.timestamp(), timestamp));\n-                putAndForward(window, valueAndTime, key, value, closeTime, timestamp);\n+            if (!rightWinAlreadyCreated && rightWindowIsNotEmpty(rightWinAgg, inputRecordTimestamp)) {\n+                createCurrentRecordRightWindow(inputRecordTimestamp, rightWinAgg, key);\n             }\n         }\n \n-        private boolean rightWindowIsNotEmpty(final ValueAndTimestamp<Agg> rightWinAgg, final long timestamp) {\n-            return rightWinAgg != null && rightWinAgg.timestamp() > timestamp;\n+        /**\n+         * Created to handle records where 0 < inputRecordTimestamp < timeDifferenceMs. These records would create\n+         * windows with negative start times, which is not supported. Instead, we will put them into the [0, timeDifferenceMs]\n+         * window as a \"workaround\", and we will update or create their right windows as new records come in later\n+         */\n+        private void processEarly(final K key, final V value, final long inputRecordTimestamp, final long closeTime) {\n+            if (inputRecordTimestamp < 0 || inputRecordTimestamp >= windows.timeDifferenceMs()) {\n+                throw new IllegalArgumentException(\"Early record for sliding windows must fall between 0 < inputRecordTimestamp < timeDifferenceMs\");\n+            }\n+\n+            // A window from [0, timeDifferenceMs] that holds all early records\n+            KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> combinedWindow = null;\n+            ValueAndTimestamp<Agg> rightWinAgg = null;\n+            boolean rightWinAlreadyCreated = false;\n+            final Set<Long> windowStartTimes = new HashSet<>();\n+\n+            Long previousRecordTimestamp = null;\n+\n+            try (\n+                final KeyValueIterator<Windowed<K>, ValueAndTimestamp<Agg>> iterator = windowStore.fetch(\n+                    key,\n+                    key,\n+                    0,\n+                    // to catch the current record's right window, if it exists, without more calls to the store\n+                    inputRecordTimestamp + 1)\n+            ) {\n+                while (iterator.hasNext()) {\n+                    final KeyValue<Windowed<K>, ValueAndTimestamp<Agg>> windowBeingProcessed = iterator.next();\n+                    final long startTime = windowBeingProcessed.key.window().start();\n+                    windowStartTimes.add(startTime);\n+                    final long windowMaxRecordTimestamp = windowBeingProcessed.value.timestamp();\n+\n+                    if (startTime == 0) {\n+                        combinedWindow = windowBeingProcessed;\n+                        //We don't need to store previousRecordTimestamp if maxRecordTimestamp > timestamp\n+                        // because the previous record's right window (if there is a previous record)\n+                        // would have already been created by maxRecordTimestamp\n+                        if (windowMaxRecordTimestamp < inputRecordTimestamp) {\n+                            previousRecordTimestamp = windowMaxRecordTimestamp;\n+                        }\n+\n+                    } else if (startTime <= inputRecordTimestamp) {\n+                        rightWinAgg = windowBeingProcessed.value;\n+                        updateWindowAndForward(windowBeingProcessed.key.window(), windowBeingProcessed.value, key, value, closeTime, inputRecordTimestamp);\n+                    } else if (startTime == inputRecordTimestamp + 1) {\n+                        rightWinAlreadyCreated = true;\n+                    } else {\n+                        throw new IllegalStateException(\"Unexpected window found when processing sliding windows\");\n+                    }\n+                }\n+            }\n+\n+            // If there wasn't a right window agg found and we need a right window for our new record,\n+            // the current aggregate in the combined window will go in the new record's right window. We can be sure that the combined\n+            // window only holds records that fall into the current record's right window for two reasons:\n+            // 1. If there were records earlier than the current record AND later than the current record, there would be a right window found\n+            // when we looked for right window agg.\n+            // 2. If there was only a record before the current record, we wouldn't need a right window for the current record and wouldn't update the\n+            // rightWinAgg value here, as the combinedWindow.value.timestamp() < inputRecordTimestamp\n+            if (rightWinAgg == null && combinedWindow != null && combinedWindow.value.timestamp() > inputRecordTimestamp) {\n+                rightWinAgg = combinedWindow.value;\n+            }\n+\n+            //create right window for new record if needed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6821e92e2cfd4ee8d763cdf2569578682db6d463"}, "originalPosition": 225}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6580b9f9670ac77220eeb29fd50733c73a532f2a", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/6580b9f9670ac77220eeb29fd50733c73a532f2a", "committedDate": "2020-09-08T23:06:42Z", "message": "Nit fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NTYxMjkx", "url": "https://github.com/apache/kafka/pull/9157#pullrequestreview-484561291", "createdAt": "2020-09-08T23:32:30Z", "commit": {"oid": "6580b9f9670ac77220eeb29fd50733c73a532f2a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d4ca6a3b9ea899afa680ec852fdfdfb5e2f3d58", "author": {"user": {"login": "lct45", "name": "leah"}}, "url": "https://github.com/apache/kafka/commit/7d4ca6a3b9ea899afa680ec852fdfdfb5e2f3d58", "committedDate": "2020-09-08T23:35:04Z", "message": "log fixes"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1123, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}