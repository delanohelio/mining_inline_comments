{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzNDEyMzg4", "number": 8221, "title": "KAFKA-9561: update task input partitions after rebalance", "bodyText": "update input partitions of task and topology when rebalance occured\nSummary of testing strategy (including rationale)\nfor the feature or bug fix. Unit and/or integration\ntests are expected for any behaviour change and\nsystem tests should be considered for larger changes.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-03-04T08:43:06Z", "url": "https://github.com/apache/kafka/pull/8221", "merged": true, "mergeCommit": {"oid": "99115cba00ae35f19ae4ba8bbd77b471d7e33ac4"}, "closed": true, "closedAt": "2020-05-27T17:40:42Z", "author": {"login": "avalsa"}, "timelineItems": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcL7DFYgBqjMxMDk5Mzk5ODk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABclHTReAH2gAyMzgzNDEyMzg4OmRjODVhNDY5NGQ2NjNhZDEzZDc1NjgxZDI4Mzk4ZDRiNjFhNGY0ODI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNzgxNzYy", "url": "https://github.com/apache/kafka/pull/8221#pullrequestreview-370781762", "createdAt": "2020-03-07T18:34:40Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QxODozNDo0MVrOFzRJJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjo0MTo0MlrOFzwdig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMjU2Ng==", "bodyText": "nit: remove empty line", "url": "https://github.com/apache/kafka/pull/8221#discussion_r389302566", "createdAt": "2020-03-07T18:34:41Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/AbstractTask.java", "diffHunk": "@@ -100,4 +105,14 @@ final void transitionTo(final Task.State newState) {\n             throw new IllegalStateException(\"Invalid transition from \" + oldState + \" to \" + newState);\n         }\n     }\n+\n+    @Override\n+    public ProcessorTopology getProcessorTopology() {\n+        return topology;\n+    }\n+\n+    public void setProcessorTopology(final ProcessorTopology topology) {\n+        this.topology = topology;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMjU4OQ==", "bodyText": "Remove commented out line", "url": "https://github.com/apache/kafka/pull/8221#discussion_r389302589", "createdAt": "2020-03-07T18:35:13Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamThreadTest.java", "diffHunk": "@@ -161,6 +164,7 @@ private Properties configProps(final boolean enableEoS) {\n             mkEntry(StreamsConfig.PROCESSING_GUARANTEE_CONFIG, enableEoS ? StreamsConfig.EXACTLY_ONCE : StreamsConfig.AT_LEAST_ONCE)\n         ));\n     }\n+    //mkEntry(ProducerConfig.TRANSACTIONAL_ID_CONFIG, APPLICATION_ID + \"-1\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwODMxNQ==", "bodyText": "nit: space after //", "url": "https://github.com/apache/kafka/pull/8221#discussion_r389808315", "createdAt": "2020-03-09T16:30:15Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/SourceNode.java", "diffHunk": "@@ -128,4 +129,9 @@ public String toString(final String indent) {\n     public TimestampExtractor getTimestampExtractor() {\n         return timestampExtractor;\n     }\n+\n+    //for test purposes only", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwOTkyMQ==", "bodyText": "We could just call inputPartitions on L170", "url": "https://github.com/apache/kafka/pull/8221#discussion_r389809921", "createdAt": "2020-03-09T16:32:23Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -146,15 +148,25 @@ public StreamTask(final TaskId id,\n         // initialize the consumed and committed offset cache\n         consumedOffsets = new HashMap<>();\n \n-        // create queues for each assigned partition and associate them\n-        // to corresponding source nodes in the processor topology\n-        final Map<TopicPartition, RecordQueue> partitionQueues = new HashMap<>();\n+        defaultTimestampExtractor = config.defaultTimestampExtractor();\n+        defaultDeserializationExceptionHandler = config.defaultDeserializationExceptionHandler();\n \n         // initialize the topology with its own context\n         processorContext = new ProcessorContextImpl(id, this, config, this.recordCollector, stateMgr, streamsMetrics, cache);\n \n-        final TimestampExtractor defaultTimestampExtractor = config.defaultTimestampExtractor();\n-        final DeserializationExceptionHandler defaultDeserializationExceptionHandler = config.defaultDeserializationExceptionHandler();\n+        recordInfo = new PartitionGroup.RecordInfo();\n+        partitionGroup = new PartitionGroup(createPartitionQueues(logContext),\n+                                            TaskMetrics.recordLatenessSensor(threadId, taskId, streamsMetrics));\n+\n+        stateMgr.registerGlobalStateStores(topology.globalStateStores());\n+    }\n+\n+    // create queues for each assigned partition and associate them\n+    // to corresponding source nodes in the processor topology\n+    private Map<TopicPartition, RecordQueue> createPartitionQueues(final LogContext logContext) {\n+        final Set<TopicPartition> partitions = inputPartitions();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgxMDgyMA==", "bodyText": "remove", "url": "https://github.com/apache/kafka/pull/8221#discussion_r389810820", "createdAt": "2020-03-09T16:33:47Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -284,6 +291,7 @@ public void resume() {\n             case SUSPENDED:\n                 // just transit the state without any logical changes: suspended and restoring states\n                 // are not actually any different for inner modules\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgxNTY5MA==", "bodyText": "Let's log more context here, for example:\nlog.trace(\"Update task {} inputPartitions: current {}, new {}\", task,  task. inputPartitions(), topicPartitions);", "url": "https://github.com/apache/kafka/pull/8221#discussion_r389815690", "createdAt": "2020-03-09T16:41:42Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/TaskManager.java", "diffHunk": "@@ -244,14 +247,25 @@ public void handleAssignment(final Map<TaskId, Set<TopicPartition>> activeTasks,\n             }\n         }\n \n-        builder.addSubscribedTopicsFromAssignment(\n-            activeTasks.values().stream().flatMap(Collection::stream).collect(Collectors.toList()),\n-            logPrefix\n-        );\n-\n         changelogReader.transitToRestoreActive();\n     }\n \n+    private void updateInputPartitionsAndResume(final Task task, final Set<TopicPartition> topicPartitions) {\n+        final boolean requiresUpdate = !task.inputPartitions().equals(topicPartitions);\n+        if (requiresUpdate) {\n+            log.trace(\"update inputPartitions {} {}\", task, topicPartitions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 39}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczMTcxMzM0", "url": "https://github.com/apache/kafka/pull/8221#pullrequestreview-373171334", "createdAt": "2020-03-11T22:31:46Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjozMTo0NlrOF1LhsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo1MDowM1rOF1L6kA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwNzY5Nw==", "bodyText": "We should unit test this function", "url": "https://github.com/apache/kafka/pull/8221#discussion_r391307697", "createdAt": "2020-03-11T22:31:46Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +93,11 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    void updatePartitions(final Map<TopicPartition, RecordQueue> partitionQueues) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwOTAwNQ==", "bodyText": "Let's move the updatePartitions logic out of initializeTopology, instead just call it inside resume", "url": "https://github.com/apache/kafka/pull/8221#discussion_r391309005", "createdAt": "2020-03-11T22:35:24Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -679,10 +689,13 @@ private void initializeTaskTime(final Map<TopicPartition, OffsetAndMetadata> off\n         return purgableConsumedOffsets;\n     }\n \n-    private void initializeTopology() {\n+    private void initializeTopology(final boolean updatePartitionQueues) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwOTg0Ng==", "bodyText": "Why do we need this helper function? Shouldn't it be protected?", "url": "https://github.com/apache/kafka/pull/8221#discussion_r391309846", "createdAt": "2020-03-11T22:37:42Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/AbstractTask.java", "diffHunk": "@@ -116,4 +121,13 @@ static void executeAndMaybeSwallow(final boolean clean,\n             }\n         }\n     }\n+\n+    @Override\n+    public ProcessorTopology getProcessorTopology() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMTY1NQ==", "bodyText": "nit: we could put topic2 initialization before L196", "url": "https://github.com/apache/kafka/pull/8221#discussion_r391311655", "createdAt": "2020-03-11T22:42:56Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/RegexSourceIntegrationTest.java", "diffHunk": "@@ -178,6 +178,44 @@ public void subscribe(final Pattern topics, final ConsumerRebalanceListener list\n \n         TestUtils.waitForCondition(() -> assignedTopics.equals(expectedSecondAssignment), STREAM_TASKS_NOT_UPDATED);\n \n+        CLUSTER.deleteTopicsAndWait(\"TEST-TOPIC-1\", \"TEST-TOPIC-2\");\n+    }\n+\n+    @Test\n+    public void testRegexRecordsAreProcessedAfterReassignment() throws Exception {\n+        final String topic1 = \"TEST-TOPIC-1\";\n+        final String topic2 = \"TEST-TOPIC-2\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMjQ5OA==", "bodyText": "Could we also add a test case for when we call task.resume(true)?", "url": "https://github.com/apache/kafka/pull/8221#discussion_r391312498", "createdAt": "2020-03-11T22:45:24Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "diffHunk": "@@ -1103,7 +1103,7 @@ public void shouldNotReInitializeTopologyWhenResuming() throws IOException {\n         assertFalse(source1.initialized);\n         assertFalse(source2.initialized);\n \n-        task.resume();\n+        task.resume(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMjk4OA==", "bodyText": "Could we also verify consumer and changeLogReader?", "url": "https://github.com/apache/kafka/pull/8221#discussion_r391312988", "createdAt": "2020-03-11T22:46:48Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -342,6 +343,31 @@ public void shouldAddNonResumedSuspendedTasks() {\n         verify(activeTaskCreator);\n     }\n \n+    @Test\n+    public void shouldAddNonResumedSuspendedTasks2() {\n+        final Task task00 = new StateMachineTask(taskId00, taskId00Partitions, true);\n+\n+        expectRestoreToBeCompleted(consumer, changeLogReader);\n+        // expect these calls twice (because we're going to tryToCompleteRestoration twice)\n+        expectRestoreToBeCompleted(consumer, changeLogReader);\n+        expect(activeTaskCreator.createTasks(anyObject(), eq(taskId00Assignment))).andReturn(singletonList(task00));\n+        replay(activeTaskCreator, consumer, changeLogReader);\n+\n+\n+        taskManager.handleAssignment(taskId00Assignment, emptyMap());\n+        assertThat(taskManager.tryToCompleteRestoration(), is(true));\n+        assertThat(task00.state(), is(Task.State.RUNNING));\n+\n+        final Set<TopicPartition> newPartitionsSet = mkSet(t1p1);\n+        final Map<TaskId, Set<TopicPartition>> taskIdSetMap = singletonMap(taskId00, newPartitionsSet);\n+        taskManager.handleAssignment(taskIdSetMap, emptyMap());\n+        assertThat(taskManager.tryToCompleteRestoration(), is(true));\n+        assertThat(task00.state(), is(Task.State.RUNNING));\n+        assertEquals(newPartitionsSet, task00.inputPartitions());\n+        assertEquals(task00, taskManager.taskForInputPartition(t1p1));\n+        verify(activeTaskCreator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNDA2NA==", "bodyText": "What does Task2 mean?", "url": "https://github.com/apache/kafka/pull/8221#discussion_r391314064", "createdAt": "2020-03-11T22:50:03Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/TaskManagerTest.java", "diffHunk": "@@ -342,6 +343,31 @@ public void shouldAddNonResumedSuspendedTasks() {\n         verify(activeTaskCreator);\n     }\n \n+    @Test\n+    public void shouldAddNonResumedSuspendedTasks2() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NjI5NDUx", "url": "https://github.com/apache/kafka/pull/8221#pullrequestreview-374629451", "createdAt": "2020-03-13T21:27:52Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMToyODoyOVrOF2Tsbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMTo0OTo1NFrOF2Ub6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5MDA5NA==", "bodyText": "nit: let's put iterator initialization closer to the start of while loop", "url": "https://github.com/apache/kafka/pull/8221#discussion_r392490094", "createdAt": "2020-03-13T21:28:29Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +96,33 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    // creates queues for new partitions, removes old queues, saves cached records for previously assigned partitions\n+    void updatePartitions(final Set<TopicPartition> newInputPartitions, final Function<TopicPartition, RecordQueue> recordQueueCreator) {\n+        final Iterator<Map.Entry<TopicPartition, RecordQueue>> queuesIterator = partitionQueues.entrySet().iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5MjM2OQ==", "bodyText": "nit: this seems unnecessary", "url": "https://github.com/apache/kafka/pull/8221#discussion_r392492369", "createdAt": "2020-03-13T21:32:18Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -55,6 +55,7 @@\n import java.util.Set;\n import java.util.function.Function;\n import java.util.stream.Collectors;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ5MzQ1Nw==", "bodyText": "This is nice!", "url": "https://github.com/apache/kafka/pull/8221#discussion_r392493457", "createdAt": "2020-03-13T21:34:10Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -952,4 +952,32 @@ int numBuffered() {\n     long streamTime() {\n         return partitionGroup.streamTime();\n     }\n+\n+    private class RecordQueueCreator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUwMjI1MA==", "bodyText": "What's the reasoning for resetting streamTime here?", "url": "https://github.com/apache/kafka/pull/8221#discussion_r392502250", "createdAt": "2020-03-13T21:49:54Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +96,33 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    // creates queues for new partitions, removes old queues, saves cached records for previously assigned partitions\n+    void updatePartitions(final Set<TopicPartition> newInputPartitions, final Function<TopicPartition, RecordQueue> recordQueueCreator) {\n+        final Iterator<Map.Entry<TopicPartition, RecordQueue>> queuesIterator = partitionQueues.entrySet().iterator();\n+        final Set<TopicPartition> removedPartitions = new HashSet<>();\n+        streamTime = RecordQueue.UNKNOWN;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0MTMwMjY0", "url": "https://github.com/apache/kafka/pull/8221#pullrequestreview-384130264", "createdAt": "2020-03-30T18:41:39Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxODo0MTozOVrOF93N8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxODo0MTozOVrOF93N8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxMjE0Nw==", "bodyText": "Could we move the comment to next line?", "url": "https://github.com/apache/kafka/pull/8221#discussion_r400412147", "createdAt": "2020-03-30T18:41:39Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +96,33 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    // creates queues for new partitions, removes old queues, saves cached records for previously assigned partitions\n+    void updatePartitions(final Set<TopicPartition> newInputPartitions, final Function<TopicPartition, RecordQueue> recordQueueCreator) {\n+        final Set<TopicPartition> removedPartitions = new HashSet<>();\n+        streamTime = RecordQueue.UNKNOWN;\n+        final Iterator<Map.Entry<TopicPartition, RecordQueue>> queuesIterator = partitionQueues.entrySet().iterator();\n+        while (queuesIterator.hasNext()) {\n+            final Map.Entry<TopicPartition, RecordQueue> queueEntry = queuesIterator.next();\n+            final TopicPartition topicPartition = queueEntry.getKey();\n+            if (newInputPartitions.contains(topicPartition)) { // if partition is left should save it's queue", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MzE2MjA0", "url": "https://github.com/apache/kafka/pull/8221#pullrequestreview-394316204", "createdAt": "2020-04-16T05:51:35Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNTo1MTozNVrOGGVjbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNTo1MTozNVrOGGVjbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTI5Nzc3Mg==", "bodyText": "Thanks for the added tests. Have you verified the test would fail with current trunk?\nAlso this test takes one minute for me on local, could you take a look and see whether it takes so long?", "url": "https://github.com/apache/kafka/pull/8221#discussion_r409297772", "createdAt": "2020-04-16T05:51:35Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/RegexSourceIntegrationTest.java", "diffHunk": "@@ -179,6 +179,44 @@ public void subscribe(final Pattern topics, final ConsumerRebalanceListener list\n \n         TestUtils.waitForCondition(() -> assignedTopics.equals(expectedSecondAssignment), STREAM_TASKS_NOT_UPDATED);\n \n+        CLUSTER.deleteTopicsAndWait(\"TEST-TOPIC-1\", \"TEST-TOPIC-2\");\n+    }\n+\n+    @Test\n+    public void testRegexRecordsAreProcessedAfterReassignment() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MzE4OTkx", "url": "https://github.com/apache/kafka/pull/8221#pullrequestreview-394318991", "createdAt": "2020-04-16T05:58:53Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNTo1ODo1M1rOGGVtZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNTo1ODo1M1rOGGVtZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwMDMyNA==", "bodyText": "The map itself should still be final", "url": "https://github.com/apache/kafka/pull/8221#discussion_r409300324", "createdAt": "2020-04-16T05:58:53Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -50,7 +53,7 @@\n  */\n public class PartitionGroup {\n \n-    private final Map<TopicPartition, RecordQueue> partitionQueues;\n+    private Map<TopicPartition, RecordQueue> partitionQueues;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MzIwMTQ5", "url": "https://github.com/apache/kafka/pull/8221#pullrequestreview-394320149", "createdAt": "2020-04-16T06:02:00Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjowMjowMFrOGGVxRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjowMjowMFrOGGVxRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwMTMxOQ==", "bodyText": "remove should be a no-op if the topicPartition doesn't exist. Might be able to rephrase:\nif (!newInputPartitions.contains(topicPartition)) {\n   totalBuffered -= queueEntry.getValue().size();\n   queuesIterator.remove();\n   removedPartitions.add(topicPartition);\n}\nnewInputPartitions.remove(topicPartition);", "url": "https://github.com/apache/kafka/pull/8221#discussion_r409301319", "createdAt": "2020-04-16T06:02:00Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +96,29 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    // creates queues for new partitions, removes old queues, saves cached records for previously assigned partitions\n+    void updatePartitions(final Set<TopicPartition> newInputPartitions, final Function<TopicPartition, RecordQueue> recordQueueCreator) {\n+        final Set<TopicPartition> removedPartitions = new HashSet<>();\n+        final Iterator<Map.Entry<TopicPartition, RecordQueue>> queuesIterator = partitionQueues.entrySet().iterator();\n+        while (queuesIterator.hasNext()) {\n+            final Map.Entry<TopicPartition, RecordQueue> queueEntry = queuesIterator.next();\n+            final TopicPartition topicPartition = queueEntry.getKey();\n+            if (newInputPartitions.contains(topicPartition)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MzIxMzcz", "url": "https://github.com/apache/kafka/pull/8221#pullrequestreview-394321373", "createdAt": "2020-04-16T06:05:05Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjowNTowNlrOGGV1iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjowNTowNlrOGGV1iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwMjQwOA==", "bodyText": "IIUC we are trying to avoid calling the initializeTopology twice, I'm thinking whether this optimization is necessary, as the guarantee to call  initializeTopology in RESTORING state is weak, which might be implicitly changed in the future, cc @guozhangwang", "url": "https://github.com/apache/kafka/pull/8221#discussion_r409302408", "createdAt": "2020-04-16T06:05:06Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -305,6 +297,12 @@ public void resume() {\n             default:\n                 throw new IllegalStateException(\"Illegal state \" + state() + \" while resuming active task \" + id);\n         }\n+        if (requiresUpdate) {\n+            partitionGroup.updatePartitions(inputPartitions(), recordQueueCreator::createQueue);\n+            if (state() != State.RESTORING) { // if task is RESTORING then topology will be initialized in completeRestoration", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MzIxOTg3", "url": "https://github.com/apache/kafka/pull/8221#pullrequestreview-394321987", "createdAt": "2020-04-16T06:06:33Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjowNjozM1rOGGV3jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjowNjozM1rOGGV3jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwMjkyNw==", "bodyText": "s/WithFalseFlag/WhenRequireUpdate", "url": "https://github.com/apache/kafka/pull/8221#discussion_r409302927", "createdAt": "2020-04-16T06:06:33Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/processor/internals/StreamTaskTest.java", "diffHunk": "@@ -1127,7 +1127,7 @@ public void shouldReadCommittedOffsetAndRethrowTimeoutWhenCompleteRestoration()\n     }\n \n     @Test\n-    public void shouldNotReInitializeTopologyWhenResuming() throws IOException {\n+    public void shouldNotReInitializeTopologyWhenResumingWithFalseFlag() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MzIyNTU1", "url": "https://github.com/apache/kafka/pull/8221#pullrequestreview-394322555", "createdAt": "2020-04-16T06:08:06Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjowODowNlrOGGV5ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNlQwNjowODowNlrOGGV5ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTMwMzQ1NA==", "bodyText": "Why do we use third-person singular instead of calling the flag requireUpdate? I feel updateInputPartitions is more explicit here.", "url": "https://github.com/apache/kafka/pull/8221#discussion_r409303454", "createdAt": "2020-04-16T06:08:06Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -115,7 +115,7 @@ public void suspend() {\n     }\n \n     @Override\n-    public void resume() {\n+    public void resume(final boolean requiresUpdate) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NzAzNDYz", "url": "https://github.com/apache/kafka/pull/8221#pullrequestreview-408703463", "createdAt": "2020-05-10T04:33:26Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQwNDozMzoyNlrOGTAa7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQwNDozNToxMlrOGTAbVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4MzAyMw==", "bodyText": "If the state was RUNNING then we would effectively call initializeTopology twice. Is that intentional?", "url": "https://github.com/apache/kafka/pull/8221#discussion_r422583023", "createdAt": "2020-05-10T04:33:26Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -429,6 +421,15 @@ public void closeDirty() {\n         log.info(\"Closed dirty\");\n     }\n \n+    @Override\n+    public void updateInputPartitions(final Set<TopicPartition> topicPartitions) {\n+        super.updateInputPartitions(topicPartitions);\n+        partitionGroup.updatePartitions(topicPartitions, recordQueueCreator::createQueue);\n+        if (state() != State.RESTORING) { // if task is RESTORING then topology will be initialized in completeRestoration", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU4MzEyNw==", "bodyText": "These two newly added functions are always called at the same time, I'd suggest we merge them into a single function, e.g. named update(topicPartitions, topology).", "url": "https://github.com/apache/kafka/pull/8221#discussion_r422583127", "createdAt": "2020-05-10T04:35:12Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/Task.java", "diffHunk": "@@ -170,6 +170,8 @@ public boolean isValidTransition(final State newState) {\n      */\n     void closeDirty();\n \n+    void updateInputPartitions(final Set<TopicPartition> topicPartitions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMjgxNDYz", "url": "https://github.com/apache/kafka/pull/8221#pullrequestreview-413281463", "createdAt": "2020-05-18T05:33:25Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNTozMzoyNlrOGWoCpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQwNjowMzoyM1rOGWojFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3Nzg5NA==", "bodyText": "nit: could we add some comments for this function?", "url": "https://github.com/apache/kafka/pull/8221#discussion_r426377894", "createdAt": "2020-05-18T05:33:26Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/Task.java", "diffHunk": "@@ -170,6 +170,8 @@ public boolean isValidTransition(final State newState) {\n      */\n     void closeDirty();\n \n+    void update(final Set<TopicPartition> topicPartitions, final ProcessorTopology processorTopology);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4NjEyOQ==", "bodyText": "nit: allBuffered &= newInputPartitions.isEmpty();", "url": "https://github.com/apache/kafka/pull/8221#discussion_r426386129", "createdAt": "2020-05-18T06:03:10Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +96,28 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    // creates queues for new partitions, removes old queues, saves cached records for previously assigned partitions\n+    void updatePartitions(final Set<TopicPartition> newInputPartitions, final Function<TopicPartition, RecordQueue> recordQueueCreator) {\n+        final Set<TopicPartition> removedPartitions = new HashSet<>();\n+        final Iterator<Map.Entry<TopicPartition, RecordQueue>> queuesIterator = partitionQueues.entrySet().iterator();\n+        while (queuesIterator.hasNext()) {\n+            final Map.Entry<TopicPartition, RecordQueue> queueEntry = queuesIterator.next();\n+            final TopicPartition topicPartition = queueEntry.getKey();\n+            if (!newInputPartitions.contains(topicPartition)) {\n+                // if partition is removed should delete it's queue\n+                totalBuffered -= queueEntry.getValue().size();\n+                queuesIterator.remove();\n+                removedPartitions.add(topicPartition);\n+            }\n+            newInputPartitions.remove(topicPartition);\n+        }\n+        for (final TopicPartition newInputPartition : newInputPartitions) {\n+            partitionQueues.put(newInputPartition, recordQueueCreator.apply(newInputPartition));\n+        }\n+        nonEmptyQueuesByTime.removeIf(q -> removedPartitions.contains(q.partition()));\n+        allBuffered = allBuffered && newInputPartitions.isEmpty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4NjE5OQ==", "bodyText": "s/it's/its", "url": "https://github.com/apache/kafka/pull/8221#discussion_r426386199", "createdAt": "2020-05-18T06:03:23Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/PartitionGroup.java", "diffHunk": "@@ -93,6 +96,28 @@ long partitionTimestamp(final TopicPartition partition) {\n         return queue.partitionTime();\n     }\n \n+    // creates queues for new partitions, removes old queues, saves cached records for previously assigned partitions\n+    void updatePartitions(final Set<TopicPartition> newInputPartitions, final Function<TopicPartition, RecordQueue> recordQueueCreator) {\n+        final Set<TopicPartition> removedPartitions = new HashSet<>();\n+        final Iterator<Map.Entry<TopicPartition, RecordQueue>> queuesIterator = partitionQueues.entrySet().iterator();\n+        while (queuesIterator.hasNext()) {\n+            final Map.Entry<TopicPartition, RecordQueue> queueEntry = queuesIterator.next();\n+            final TopicPartition topicPartition = queueEntry.getKey();\n+            if (!newInputPartitions.contains(topicPartition)) {\n+                // if partition is removed should delete it's queue", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecf6ba2c244f181b862a9bcf2f51f829946c490a", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/ecf6ba2c244f181b862a9bcf2f51f829946c490a", "committedDate": "2020-05-18T09:40:32Z", "message": "KAFKA-9561: update task input partitions after rebalance"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "ecf6ba2c244f181b862a9bcf2f51f829946c490a", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/ecf6ba2c244f181b862a9bcf2f51f829946c490a", "committedDate": "2020-05-18T09:40:32Z", "message": "KAFKA-9561: update task input partitions after rebalance"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc85a4694d663ad13d75681d28398d4b61a4f482", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/dc85a4694d663ad13d75681d28398d4b61a4f482", "committedDate": "2020-05-26T16:31:40Z", "message": "fix spotbug"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 382, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}