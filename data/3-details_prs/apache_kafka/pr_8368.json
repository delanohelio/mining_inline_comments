{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0NDQzMDE1", "number": 8368, "title": "KAFKA-9770: Close underlying state store also when flush throws", "bodyText": "When a caching state store is closed it calls its flush() method.\nIf flush() throws an exception the underlying state store is not closed.\nThis commit ensures that state stores underlying a caching state store\nare closed even when flush() throws.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-03-26T21:53:15Z", "url": "https://github.com/apache/kafka/pull/8368", "merged": true, "mergeCommit": {"oid": "c595470713be1fd2daf93816a5dbf0e245a707a0"}, "closed": true, "closedAt": "2020-03-28T01:36:11Z", "author": {"login": "cadonna"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRjU-dgH2gAyMzk0NDQzMDE1OjRmNDYzZmI0ZjVkNDQyYWI1M2Y3YzU5ZGY2OWQwZjExNzllOTNlOGU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcR65cdAH2gAyMzk0NDQzMDE1OjlkNjdmMWE5YjM5YWI0MTg3NGMyYzcwMmViNGNjZTAxMWFmYzI1NjA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4f463fb4f5d442ab53f7c59df69d0f1179e93e8e", "author": {"user": {"login": "cadonna", "name": "Bruno Cadonna"}}, "url": "https://github.com/apache/kafka/commit/4f463fb4f5d442ab53f7c59df69d0f1179e93e8e", "committedDate": "2020-03-26T21:52:23Z", "message": "KAFKA-9770: Close underlying state store also when flush throws\n\nWhen a caching state store is closed it calls its flush() method.\nIf flush() throws an exception the underlying state store is not closed.\n\nThis commit ensures that state stores underlying a caching state store\nare closed even when flush() throws."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyNDY0NDYx", "url": "https://github.com/apache/kafka/pull/8368#pullrequestreview-382464461", "createdAt": "2020-03-26T22:27:05Z", "commit": {"oid": "4f463fb4f5d442ab53f7c59df69d0f1179e93e8e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMjoyNzowNVrOF8cvyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMjoyNzowNVrOF8cvyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyOTg2NQ==", "bodyText": "Why did you change the order of super.close() vs cache.close() ?", "url": "https://github.com/apache/kafka/pull/8368#discussion_r398929865", "createdAt": "2020-03-26T22:27:05Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingSessionStore.java", "diffHunk": "@@ -232,9 +232,15 @@ public void flush() {\n     }\n \n     public void close() {\n-        flush();\n-        cache.close(cacheName);\n-        super.close();\n+        try {\n+            flush();\n+        } finally {\n+            try {\n+                super.close();\n+            } finally {\n+                cache.close(cacheName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f463fb4f5d442ab53f7c59df69d0f1179e93e8e"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyNDY1MjU0", "url": "https://github.com/apache/kafka/pull/8368#pullrequestreview-382465254", "createdAt": "2020-03-26T22:28:57Z", "commit": {"oid": "4f463fb4f5d442ab53f7c59df69d0f1179e93e8e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMjoyODo1N1rOF8cyfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMjoyODo1N1rOF8cyfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkzMDU1Ng==", "bodyText": "Nit: Why not import Bytes?", "url": "https://github.com/apache/kafka/pull/8368#discussion_r398930556", "createdAt": "2020-03-26T22:28:57Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CachingSessionStoreTest.java", "diffHunk": "@@ -67,27 +70,30 @@\n     private static final int MAX_CACHE_SIZE_BYTES = 600;\n     private static final Long DEFAULT_TIMESTAMP = 10L;\n     private static final long SEGMENT_INTERVAL = 100L;\n+    private static final String TOPIC = \"topic\";\n+    private static final String CACHE_NAMESPACE = \"0_0-store-name\";\n+\n     private final Bytes keyA = Bytes.wrap(\"a\".getBytes());\n     private final Bytes keyAA = Bytes.wrap(\"aa\".getBytes());\n     private final Bytes keyB = Bytes.wrap(\"b\".getBytes());\n \n+    private SessionStore<org.apache.kafka.common.utils.Bytes, byte[]> sessionStore =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f463fb4f5d442ab53f7c59df69d0f1179e93e8e"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyNDY3OTAw", "url": "https://github.com/apache/kafka/pull/8368#pullrequestreview-382467900", "createdAt": "2020-03-26T22:35:08Z", "commit": {"oid": "4f463fb4f5d442ab53f7c59df69d0f1179e93e8e"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMjozNTowOFrOF8c76w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMjo0OTozNFrOF8dQnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkzMjk3MQ==", "bodyText": "Should we verify regardless of the NPE?", "url": "https://github.com/apache/kafka/pull/8368#discussion_r398932971", "createdAt": "2020-03-26T22:35:08Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CachingKeyValueStoreTest.java", "diffHunk": "@@ -107,32 +108,98 @@ public void shouldSetFlushListener() {\n     public void shouldAvoidFlushingDeletionsWithoutDirtyKeys() {\n         final int added = addItemsToCache();\n         // all dirty entries should have been flushed\n-        assertEquals(added, underlyingStore.approximateNumEntries());\n+        assertEquals(added, keyValueStore.approximateNumEntries());\n         assertEquals(added, cacheFlushListener.forwarded.size());\n \n         store.put(bytesKey(\"key\"), bytesValue(\"value\"));\n-        assertEquals(added, underlyingStore.approximateNumEntries());\n+        assertEquals(added, keyValueStore.approximateNumEntries());\n         assertEquals(added, cacheFlushListener.forwarded.size());\n \n         store.put(bytesKey(\"key\"), null);\n         store.flush();\n-        assertEquals(added, underlyingStore.approximateNumEntries());\n+        assertEquals(added, keyValueStore.approximateNumEntries());\n         assertEquals(added, cacheFlushListener.forwarded.size());\n     }\n \n+    @Test\n+    public void shouldCloseWrappedStoreAfterErrorDuringCacheFlush() {\n+        setUpCloseTests();\n+        cache.flush(CACHE_NAMESPACE);\n+        EasyMock.expectLastCall().andThrow(new NullPointerException(\"Simulating an error on flush\"));\n+        EasyMock.replay(cache);\n+        EasyMock.reset(keyValueStore);\n+        keyValueStore.close();\n+        EasyMock.replay(keyValueStore);\n+\n+        try {\n+            store.close();\n+        } catch (final NullPointerException npe) {\n+            EasyMock.verify(keyValueStore);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f463fb4f5d442ab53f7c59df69d0f1179e93e8e"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkzMzQxNQ==", "bodyText": "Not sure about this variable rename, since the CachingKeyValueStore is also a \"keyValueStore\". I.e., the important thing about the one we're declaring here is that it's the \"underlying\" one.", "url": "https://github.com/apache/kafka/pull/8368#discussion_r398933415", "createdAt": "2020-03-26T22:36:20Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CachingKeyValueStoreTest.java", "diffHunk": "@@ -56,25 +57,25 @@\n \n public class CachingKeyValueStoreTest extends AbstractKeyValueStoreTest {\n \n+    private final static String TOPIC = \"topic\";\n+    private static final String CACHE_NAMESPACE = \"0_0-store-name\";\n     private final int maxCacheSizeBytes = 150;\n     private InternalMockProcessorContext context;\n     private CachingKeyValueStore store;\n-    private InMemoryKeyValueStore underlyingStore;\n+    private KeyValueStore<Bytes, byte[]> keyValueStore;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f463fb4f5d442ab53f7c59df69d0f1179e93e8e"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkzODI3MQ==", "bodyText": "Looking at the implementation, I don't think the order matters. But IIRC, it's dubious to throw exceptions in a finally block because it creates ambiguity about which exception should ultimately get thrown.\nPerhaps we could instead just capture the exceptions like:\nfinal List<RuntimeException> suppressed = new LinkedList();\ncapture(this::flush, suppressed);\ncapture(() -> cache.close(cacheName), suppressed);\ncapture(wrapped::close, suppressed);\nif (suppressed.isEmpty()) {\n  return;\nelse {\n  final RuntimeException toThrow = new RuntimeException(\"Caught an exception while closing \" + storeName);\n  for(final RuntimeException e : suppressed) {\n    toThrow.addSuppressed(e);\n  }\n  throw toThrow;\n}\nWDYT?", "url": "https://github.com/apache/kafka/pull/8368#discussion_r398938271", "createdAt": "2020-03-26T22:49:34Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingSessionStore.java", "diffHunk": "@@ -232,9 +232,15 @@ public void flush() {\n     }\n \n     public void close() {\n-        flush();\n-        cache.close(cacheName);\n-        super.close();\n+        try {\n+            flush();\n+        } finally {\n+            try {\n+                super.close();\n+            } finally {\n+                cache.close(cacheName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkyOTg2NQ=="}, "originalCommit": {"oid": "4f463fb4f5d442ab53f7c59df69d0f1179e93e8e"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyNDUxOTcw", "url": "https://github.com/apache/kafka/pull/8368#pullrequestreview-382451970", "createdAt": "2020-03-26T22:01:10Z", "commit": {"oid": "4f463fb4f5d442ab53f7c59df69d0f1179e93e8e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMjowMToxMFrOF8cFbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMjowMToxMFrOF8cFbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODkxOTAyMg==", "bodyText": "@guozhangwang  proposed just to call cache.flush() instead of flush(). I have not done that because in some caching state stores flush() is either synchronized or it contains locks or it neither the one nor the other. I wanted first to clarify on that before I make this change. So I guess flush() needs to be synchronized because of Interactive Queries on the underlying state store, right? Does the cache also need to be synchronized?", "url": "https://github.com/apache/kafka/pull/8368#discussion_r398919022", "createdAt": "2020-03-26T22:01:10Z", "author": {"login": "cadonna"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingSessionStore.java", "diffHunk": "@@ -232,9 +232,15 @@ public void flush() {\n     }\n \n     public void close() {\n-        flush();\n-        cache.close(cacheName);\n-        super.close();\n+        try {\n+            flush();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4f463fb4f5d442ab53f7c59df69d0f1179e93e8e"}, "originalPosition": 8}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31115b7dcdfc67dc23703a5884d19f74cad5e52f", "author": {"user": {"login": "cadonna", "name": "Bruno Cadonna"}}, "url": "https://github.com/apache/kafka/commit/31115b7dcdfc67dc23703a5884d19f74cad5e52f", "committedDate": "2020-03-27T10:34:48Z", "message": "Include feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMDMyNjAy", "url": "https://github.com/apache/kafka/pull/8368#pullrequestreview-383032602", "createdAt": "2020-03-27T16:49:54Z", "commit": {"oid": "31115b7dcdfc67dc23703a5884d19f74cad5e52f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjo0OTo1NVrOF85qWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNjo0OTo1NVrOF85qWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQwMzYxMQ==", "bodyText": "As we discussed offline, I think here we can just call cache.flush(cacheName) instead of this.flush right?", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399403611", "createdAt": "2020-03-27T16:49:55Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingKeyValueStore.java", "diffHunk": "@@ -278,14 +279,17 @@ public void flush() {\n \n     @Override\n     public void close() {\n-        try {\n-            flush();\n-        } finally {\n-            try {\n-                super.close();\n-            } finally {\n-                cache.close(cacheName);\n+        final List<RuntimeException> suppressed = new ArrayList<>();\n+        captureException(this::flush, suppressed);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31115b7dcdfc67dc23703a5884d19f74cad5e52f"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMTcxMjgx", "url": "https://github.com/apache/kafka/pull/8368#pullrequestreview-383171281", "createdAt": "2020-03-27T20:14:51Z", "commit": {"oid": "31115b7dcdfc67dc23703a5884d19f74cad5e52f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMDoxNDo1MVrOF9AeyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMDoxNDo1MVrOF9AeyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUxNTMzNw==", "bodyText": "Should we have a \"global utility\" class that unifies all helper methods we use throughout the whole code base? (Not in this PR thought, but as a follow up)", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399515337", "createdAt": "2020-03-27T20:14:51Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/WrappedStateStore.java", "diffHunk": "@@ -92,4 +94,12 @@ public void close() {\n     public S wrapped() {\n         return wrapped;\n     }\n+\n+    protected static void captureException(final Runnable action, final List<RuntimeException> suppressed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31115b7dcdfc67dc23703a5884d19f74cad5e52f"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cde84b2b86b21259e27516fc7c4bdf010206108f", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/cde84b2b86b21259e27516fc7c4bdf010206108f", "committedDate": "2020-03-27T22:32:46Z", "message": "CR comments and also fix and test bug for Metered stores"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c51b89b829dbd9f306f9c94e085f978155cc1eb3", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/c51b89b829dbd9f306f9c94e085f978155cc1eb3", "committedDate": "2020-03-27T22:52:04Z", "message": "null check"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMjM4Mjg4", "url": "https://github.com/apache/kafka/pull/8368#pullrequestreview-383238288", "createdAt": "2020-03-27T22:41:07Z", "commit": {"oid": "cde84b2b86b21259e27516fc7c4bdf010206108f"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMjo0MTowN1rOF9D0MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMjo1Mzo0N1rOF9EBkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU2OTk2OA==", "bodyText": "I did this because I was trying to debug the \"remove all sensors\" method, and I needed to debug this method, but was unable to. I left the change here for the same reason.", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399569968", "createdAt": "2020-03-27T22:41:07Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "diffHunk": "@@ -402,11 +402,13 @@ public final Sensor storeLevelSensor(final String threadId,\n         final String key = storeSensorPrefix(threadId, taskId, storeName);\n         synchronized (storeLevelSensors) {\n             final String fullSensorName = key + SENSOR_NAME_DELIMITER + sensorName;\n-            return Optional.ofNullable(metrics.getSensor(fullSensorName))\n-                .orElseGet(() -> {\n-                    storeLevelSensors.computeIfAbsent(key, ignored -> new LinkedList<>()).push(fullSensorName);\n-                    return metrics.sensor(fullSensorName, recordingLevel, parents);\n-                });\n+            final Sensor sensor = metrics.getSensor(fullSensorName);\n+            if (sensor == null) {\n+                storeLevelSensors.computeIfAbsent(key, ignored -> new LinkedList<>()).push(fullSensorName);\n+                return metrics.sensor(fullSensorName, recordingLevel, parents);\n+            } else {\n+                return sensor;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cde84b2b86b21259e27516fc7c4bdf010206108f"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MDU1OQ==", "bodyText": "We need to check again after we grab the lock, otherwise the store might get closed after we check but before we grab the lock. Once we get the lock, we're guaranteed that this block is serialized wrt close(). But we can still check beforehand to avoid grabbing the lock if it is closed.", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399570559", "createdAt": "2020-03-27T22:43:26Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingKeyValueStore.java", "diffHunk": "@@ -119,6 +123,7 @@ public void put(final Bytes key,\n         validateStoreOpen();\n         lock.writeLock().lock();\n         try {\n+            validateStoreOpen();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cde84b2b86b21259e27516fc7c4bdf010206108f"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MDg5OQ==", "bodyText": "They do the same thing, but the majority of calls are on wrapped().", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399570899", "createdAt": "2020-03-27T22:44:28Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingKeyValueStore.java", "diffHunk": "@@ -267,25 +277,32 @@ public long approximateNumEntries() {\n \n     @Override\n     public void flush() {\n+        validateStoreOpen();\n         lock.writeLock().lock();\n         try {\n+            validateStoreOpen();\n             cache.flush(cacheName);\n-            super.flush();\n+            wrapped().flush();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cde84b2b86b21259e27516fc7c4bdf010206108f"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTEwNw==", "bodyText": "This check means we don't have to construct the exception message string if we're not going to throw.", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399571107", "createdAt": "2020-03-27T22:45:20Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingKeyValueStore.java", "diffHunk": "@@ -267,25 +277,32 @@ public long approximateNumEntries() {\n \n     @Override\n     public void flush() {\n+        validateStoreOpen();\n         lock.writeLock().lock();\n         try {\n+            validateStoreOpen();\n             cache.flush(cacheName);\n-            super.flush();\n+            wrapped().flush();\n         } finally {\n             lock.writeLock().unlock();\n         }\n     }\n \n     @Override\n     public void close() {\n+        lock.writeLock().lock();\n         try {\n-            flush();\n-        } finally {\n-            try {\n-                super.close();\n-            } finally {\n-                cache.close(cacheName);\n+            final LinkedList<RuntimeException> suppressed = executeAll(\n+                () -> cache.flush(cacheName),\n+                () -> cache.close(cacheName),\n+                wrapped()::close\n+            );\n+            if (suppressed != null && !suppressed.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cde84b2b86b21259e27516fc7c4bdf010206108f"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTIzMw==", "bodyText": "This is what @guozhangwang was asking for.", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399571233", "createdAt": "2020-03-27T22:45:47Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingKeyValueStore.java", "diffHunk": "@@ -267,25 +277,32 @@ public long approximateNumEntries() {\n \n     @Override\n     public void flush() {\n+        validateStoreOpen();\n         lock.writeLock().lock();\n         try {\n+            validateStoreOpen();\n             cache.flush(cacheName);\n-            super.flush();\n+            wrapped().flush();\n         } finally {\n             lock.writeLock().unlock();\n         }\n     }\n \n     @Override\n     public void close() {\n+        lock.writeLock().lock();\n         try {\n-            flush();\n-        } finally {\n-            try {\n-                super.close();\n-            } finally {\n-                cache.close(cacheName);\n+            final LinkedList<RuntimeException> suppressed = executeAll(\n+                () -> cache.flush(cacheName),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cde84b2b86b21259e27516fc7c4bdf010206108f"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTU0Nw==", "bodyText": "I just plunked this class where it was needed right now; we can move it later if we want to use it elsewhere.", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399571547", "createdAt": "2020-03-27T22:47:04Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/ExceptionUtils.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.state.internals;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cde84b2b86b21259e27516fc7c4bdf010206108f"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTYzNg==", "bodyText": "The first exception will be the \"cause\"", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399571636", "createdAt": "2020-03-27T22:47:27Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/ExceptionUtils.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.state.internals;\n+\n+import java.util.LinkedList;\n+\n+final class ExceptionUtils {\n+    private ExceptionUtils() {}\n+\n+    static LinkedList<RuntimeException> executeAll(final Runnable... actions) {\n+        LinkedList<RuntimeException> suppressed = null;\n+        for (final Runnable action : actions) {\n+            try {\n+                action.run();\n+            } catch (final RuntimeException exception) {\n+                if (suppressed == null) {\n+                    suppressed = new LinkedList<>();\n+                }\n+                suppressed.add(exception);\n+            }\n+        }\n+        return suppressed;\n+    }\n+\n+    static void throwSuppressed(final String message, final LinkedList<RuntimeException> suppressed) {\n+        if (suppressed != null && !suppressed.isEmpty()) {\n+            final RuntimeException firstCause = suppressed.pollFirst();\n+            final RuntimeException toThrow = new RuntimeException(message, firstCause);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cde84b2b86b21259e27516fc7c4bdf010206108f"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MTc1OQ==", "bodyText": "The rest of the exceptions are listed as \"suppressed by\" the exception we're throwing.", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399571759", "createdAt": "2020-03-27T22:47:50Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/ExceptionUtils.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.state.internals;\n+\n+import java.util.LinkedList;\n+\n+final class ExceptionUtils {\n+    private ExceptionUtils() {}\n+\n+    static LinkedList<RuntimeException> executeAll(final Runnable... actions) {\n+        LinkedList<RuntimeException> suppressed = null;\n+        for (final Runnable action : actions) {\n+            try {\n+                action.run();\n+            } catch (final RuntimeException exception) {\n+                if (suppressed == null) {\n+                    suppressed = new LinkedList<>();\n+                }\n+                suppressed.add(exception);\n+            }\n+        }\n+        return suppressed;\n+    }\n+\n+    static void throwSuppressed(final String message, final LinkedList<RuntimeException> suppressed) {\n+        if (suppressed != null && !suppressed.isEmpty()) {\n+            final RuntimeException firstCause = suppressed.pollFirst();\n+            final RuntimeException toThrow = new RuntimeException(message, firstCause);\n+            for (final RuntimeException e : suppressed) {\n+                toThrow.addSuppressed(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cde84b2b86b21259e27516fc7c4bdf010206108f"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MjE5Nw==", "bodyText": "This is a related bug I fixed. It's basically the same thing, but for Metered store. There's no need to use the new util when we're just dealing with one potentially-throwing operation.", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399572197", "createdAt": "2020-03-27T22:49:32Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/MeteredKeyValueStore.java", "diffHunk": "@@ -199,8 +199,11 @@ public long approximateNumEntries() {\n \n     @Override\n     public void close() {\n-        super.close();\n-        streamsMetrics.removeAllStoreLevelSensors(threadId, taskId, name());\n+        try {\n+            wrapped().close();\n+        } finally {\n+            streamsMetrics.removeAllStoreLevelSensors(threadId, taskId, name());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cde84b2b86b21259e27516fc7c4bdf010206108f"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MzI5MA==", "bodyText": "These tests were missing, so I added them.", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399573290", "createdAt": "2020-03-27T22:53:24Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/MeteredKeyValueStoreTest.java", "diffHunk": "@@ -311,8 +311,44 @@ public void shouldNotSetFlushListenerOnWrappedNoneCachingStore() {\n         assertFalse(metered.setFlushListener(null, false));\n     }\n \n+    @Test\n+    public void shouldRemoveMetricsOnClose() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b89b829dbd9f306f9c94e085f978155cc1eb3"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MzM5NQ==", "bodyText": "These tests are the ones that cover the bug I fixed.", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399573395", "createdAt": "2020-03-27T22:53:47Z", "author": {"login": "vvcephei"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/MeteredKeyValueStoreTest.java", "diffHunk": "@@ -311,8 +311,44 @@ public void shouldNotSetFlushListenerOnWrappedNoneCachingStore() {\n         assertFalse(metered.setFlushListener(null, false));\n     }\n \n+    @Test\n+    public void shouldRemoveMetricsOnClose() {\n+        inner.close();\n+        expectLastCall();\n+        init(); // replays \"inner\"\n+\n+        // There's always a \"count\" metric registered\n+        assertThat(storeMetrics(), not(empty()));\n+        metered.close();\n+        assertThat(storeMetrics(), empty());\n+        verify(inner);\n+    }\n+\n+    @Test\n+    public void shouldRemoveMetricsEvenIfWrappedStoreThrowsOnClose() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b89b829dbd9f306f9c94e085f978155cc1eb3"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMjQxMzE5", "url": "https://github.com/apache/kafka/pull/8368#pullrequestreview-383241319", "createdAt": "2020-03-27T22:51:31Z", "commit": {"oid": "cde84b2b86b21259e27516fc7c4bdf010206108f"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMjo1MTozMVrOF9D_AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMjo1ODo0OFrOF9EGqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3MjczNw==", "bodyText": "Why this rewrite?", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399572737", "createdAt": "2020-03-27T22:51:31Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/metrics/StreamsMetricsImpl.java", "diffHunk": "@@ -402,11 +402,13 @@ public final Sensor storeLevelSensor(final String threadId,\n         final String key = storeSensorPrefix(threadId, taskId, storeName);\n         synchronized (storeLevelSensors) {\n             final String fullSensorName = key + SENSOR_NAME_DELIMITER + sensorName;\n-            return Optional.ofNullable(metrics.getSensor(fullSensorName))\n-                .orElseGet(() -> {\n-                    storeLevelSensors.computeIfAbsent(key, ignored -> new LinkedList<>()).push(fullSensorName);\n-                    return metrics.sensor(fullSensorName, recordingLevel, parents);\n-                });\n+            final Sensor sensor = metrics.getSensor(fullSensorName);\n+            if (sensor == null) {\n+                storeLevelSensors.computeIfAbsent(key, ignored -> new LinkedList<>()).push(fullSensorName);\n+                return metrics.sensor(fullSensorName, recordingLevel, parents);\n+            } else {\n+                return sensor;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cde84b2b86b21259e27516fc7c4bdf010206108f"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3Mjk0Mg==", "bodyText": "Why do we  call this a second time? Also, it seems to be a very generic pattern for all method calls -- can we extract this in some private helper method ?", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399572942", "createdAt": "2020-03-27T22:52:16Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingKeyValueStore.java", "diffHunk": "@@ -119,6 +123,7 @@ public void put(final Bytes key,\n         validateStoreOpen();\n         lock.writeLock().lock();\n         try {\n+            validateStoreOpen();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cde84b2b86b21259e27516fc7c4bdf010206108f"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3Mzg2NA==", "bodyText": "Isn't this the same thing?", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399573864", "createdAt": "2020-03-27T22:55:34Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingKeyValueStore.java", "diffHunk": "@@ -267,25 +277,32 @@ public long approximateNumEntries() {\n \n     @Override\n     public void flush() {\n+        validateStoreOpen();\n         lock.writeLock().lock();\n         try {\n+            validateStoreOpen();\n             cache.flush(cacheName);\n-            super.flush();\n+            wrapped().flush();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b89b829dbd9f306f9c94e085f978155cc1eb3"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3NDAxOA==", "bodyText": "Compare my comment below. We should avoid returning null to avoid the necessity of a null check.", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399574018", "createdAt": "2020-03-27T22:56:10Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingKeyValueStore.java", "diffHunk": "@@ -267,25 +277,32 @@ public long approximateNumEntries() {\n \n     @Override\n     public void flush() {\n+        validateStoreOpen();\n         lock.writeLock().lock();\n         try {\n+            validateStoreOpen();\n             cache.flush(cacheName);\n-            super.flush();\n+            wrapped().flush();\n         } finally {\n             lock.writeLock().unlock();\n         }\n     }\n \n     @Override\n     public void close() {\n+        lock.writeLock().lock();\n         try {\n-            flush();\n-        } finally {\n-            try {\n-                super.close();\n-            } finally {\n-                cache.close(cacheName);\n+            final LinkedList<RuntimeException> suppressed = executeAll(\n+                () -> cache.flush(cacheName),\n+                () -> cache.close(cacheName),\n+                wrapped()::close\n+            );\n+            if (suppressed != null && !suppressed.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b89b829dbd9f306f9c94e085f978155cc1eb3"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3NDMwMg==", "bodyText": "Why not make it final and return an empty list? It seems better to avoid using null if possible", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399574302", "createdAt": "2020-03-27T22:57:15Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/ExceptionUtils.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.state.internals;\n+\n+import java.util.LinkedList;\n+\n+final class ExceptionUtils {\n+    private ExceptionUtils() {}\n+\n+    static LinkedList<RuntimeException> executeAll(final Runnable... actions) {\n+        LinkedList<RuntimeException> suppressed = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b89b829dbd9f306f9c94e085f978155cc1eb3"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3NDY5OQ==", "bodyText": "Same here: can we avoid potential null values?", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399574699", "createdAt": "2020-03-27T22:58:48Z", "author": {"login": "mjsax"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/ExceptionUtils.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.state.internals;\n+\n+import java.util.LinkedList;\n+\n+final class ExceptionUtils {\n+    private ExceptionUtils() {}\n+\n+    static LinkedList<RuntimeException> executeAll(final Runnable... actions) {\n+        LinkedList<RuntimeException> suppressed = null;\n+        for (final Runnable action : actions) {\n+            try {\n+                action.run();\n+            } catch (final RuntimeException exception) {\n+                if (suppressed == null) {\n+                    suppressed = new LinkedList<>();\n+                }\n+                suppressed.add(exception);\n+            }\n+        }\n+        return suppressed;\n+    }\n+\n+    static void throwSuppressed(final String message, final LinkedList<RuntimeException> suppressed) {\n+        if (suppressed != null && !suppressed.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b89b829dbd9f306f9c94e085f978155cc1eb3"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMjQ3OTc0", "url": "https://github.com/apache/kafka/pull/8368#pullrequestreview-383247974", "createdAt": "2020-03-27T23:16:27Z", "commit": {"oid": "c51b89b829dbd9f306f9c94e085f978155cc1eb3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMzoxNjoyN1rOF9EW7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMzoxNjoyN1rOF9EW7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3ODg2MA==", "bodyText": "Why not throw a general RuntimeException but a NPE?", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399578860", "createdAt": "2020-03-27T23:16:27Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CachingKeyValueStoreTest.java", "diffHunk": "@@ -121,21 +122,71 @@ public void shouldAvoidFlushingDeletionsWithoutDirtyKeys() {\n     }\n \n     @Test\n-    public void shouldCloseAfterErrorWithFlush() {\n+    public void shouldCloseWrappedStoreAfterErrorDuringCacheFlush() {\n+        setUpCloseTests();\n+        cache.flush(CACHE_NAMESPACE);\n+        EasyMock.expectLastCall().andThrow(new NullPointerException(\"Simulating an error on flush\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b89b829dbd9f306f9c94e085f978155cc1eb3"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMjQ4MTU1", "url": "https://github.com/apache/kafka/pull/8368#pullrequestreview-383248155", "createdAt": "2020-03-27T23:17:13Z", "commit": {"oid": "c51b89b829dbd9f306f9c94e085f978155cc1eb3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMzoxNzoxM1rOF9EXkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMzoxNzoxM1rOF9EXkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU3OTAyNA==", "bodyText": "Why not use assertThrows ?", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399579024", "createdAt": "2020-03-27T23:17:13Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CachingKeyValueStoreTest.java", "diffHunk": "@@ -121,21 +122,71 @@ public void shouldAvoidFlushingDeletionsWithoutDirtyKeys() {\n     }\n \n     @Test\n-    public void shouldCloseAfterErrorWithFlush() {\n+    public void shouldCloseWrappedStoreAfterErrorDuringCacheFlush() {\n+        setUpCloseTests();\n+        cache.flush(CACHE_NAMESPACE);\n+        EasyMock.expectLastCall().andThrow(new NullPointerException(\"Simulating an error on flush\"));\n+        EasyMock.replay(cache);\n+        EasyMock.reset(underlyingStore);\n+        underlyingStore.close();\n+        EasyMock.replay(underlyingStore);\n+\n+        try {\n+            store.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b89b829dbd9f306f9c94e085f978155cc1eb3"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMjQ5Mzk1", "url": "https://github.com/apache/kafka/pull/8368#pullrequestreview-383249395", "createdAt": "2020-03-27T23:21:54Z", "commit": {"oid": "c51b89b829dbd9f306f9c94e085f978155cc1eb3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMzoyMTo1NFrOF9EcFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMzoyMTo1NFrOF9EcFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU4MDE4MQ==", "bodyText": "What do we actually test here? Closing the underlying store is the last thing we do, so it does not affect the happy path of flushing/closing the cache (what we verify at the end). Not sure what the value of this test is?", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399580181", "createdAt": "2020-03-27T23:21:54Z", "author": {"login": "mjsax"}, "path": "streams/src/test/java/org/apache/kafka/streams/state/internals/CachingKeyValueStoreTest.java", "diffHunk": "@@ -121,21 +122,71 @@ public void shouldAvoidFlushingDeletionsWithoutDirtyKeys() {\n     }\n \n     @Test\n-    public void shouldCloseAfterErrorWithFlush() {\n+    public void shouldCloseWrappedStoreAfterErrorDuringCacheFlush() {\n+        setUpCloseTests();\n+        cache.flush(CACHE_NAMESPACE);\n+        EasyMock.expectLastCall().andThrow(new NullPointerException(\"Simulating an error on flush\"));\n+        EasyMock.replay(cache);\n+        EasyMock.reset(underlyingStore);\n+        underlyingStore.close();\n+        EasyMock.replay(underlyingStore);\n+\n+        try {\n+            store.close();\n+        } catch (final RuntimeException exception) {\n+            EasyMock.verify(underlyingStore);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldCloseWrappedStoreAfterErrorDuringCacheClose() {\n+        setUpCloseTests();\n+        cache.flush(CACHE_NAMESPACE);\n+        cache.close(CACHE_NAMESPACE);\n+        EasyMock.expectLastCall().andThrow(new NullPointerException(\"Simulating an error on close\"));\n+        EasyMock.replay(cache);\n+        EasyMock.reset(underlyingStore);\n+        underlyingStore.close();\n+        EasyMock.replay(underlyingStore);\n+\n         try {\n-            cache = EasyMock.niceMock(ThreadCache.class);\n-            context = new InternalMockProcessorContext(null, null, null, null, cache);\n-            context.setRecordContext(new ProcessorRecordContext(10, 0, 0, topic, null));\n-            store.init(context, null);\n-            cache.flush(\"0_0-store\");\n-            EasyMock.expectLastCall().andThrow(new NullPointerException(\"Simulating an error on flush\"));\n-            EasyMock.replay(cache);\n             store.close();\n-        } catch (final NullPointerException npe) {\n-            assertFalse(underlyingStore.isOpen());\n+        } catch (final RuntimeException exception) {\n+            EasyMock.verify(underlyingStore);\n         }\n     }\n \n+    @Test\n+    public void shouldCloseCacheAfterErrorDuringStateStoreClose() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b89b829dbd9f306f9c94e085f978155cc1eb3"}, "originalPosition": 84}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMjUxMDg4", "url": "https://github.com/apache/kafka/pull/8368#pullrequestreview-383251088", "createdAt": "2020-03-27T23:28:48Z", "commit": {"oid": "c51b89b829dbd9f306f9c94e085f978155cc1eb3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMjU1MDE3", "url": "https://github.com/apache/kafka/pull/8368#pullrequestreview-383255017", "createdAt": "2020-03-27T23:46:34Z", "commit": {"oid": "c51b89b829dbd9f306f9c94e085f978155cc1eb3"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMzo0NjozNFrOF9Ew8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QyMzo0ODoyMFrOF9EyXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU4NTUyMw==", "bodyText": "Do we need to validate twice before grabbing the lock? Maybe only the validation at line 283 is sufficient.", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399585523", "createdAt": "2020-03-27T23:46:34Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingKeyValueStore.java", "diffHunk": "@@ -267,25 +277,32 @@ public long approximateNumEntries() {\n \n     @Override\n     public void flush() {\n+        validateStoreOpen();\n         lock.writeLock().lock();\n         try {\n+            validateStoreOpen();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b89b829dbd9f306f9c94e085f978155cc1eb3"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTU4NTg4NQ==", "bodyText": "If an exception is thrown in cache flush / close, it means we would not trigger wrapper#close, which is different from the current trunk. Is that intentional?", "url": "https://github.com/apache/kafka/pull/8368#discussion_r399585885", "createdAt": "2020-03-27T23:48:20Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/state/internals/CachingKeyValueStore.java", "diffHunk": "@@ -267,25 +277,32 @@ public long approximateNumEntries() {\n \n     @Override\n     public void flush() {\n+        validateStoreOpen();\n         lock.writeLock().lock();\n         try {\n+            validateStoreOpen();\n             cache.flush(cacheName);\n-            super.flush();\n+            wrapped().flush();\n         } finally {\n             lock.writeLock().unlock();\n         }\n     }\n \n     @Override\n     public void close() {\n+        lock.writeLock().lock();\n         try {\n-            flush();\n-        } finally {\n-            try {\n-                super.close();\n-            } finally {\n-                cache.close(cacheName);\n+            final LinkedList<RuntimeException> suppressed = executeAll(\n+                () -> cache.flush(cacheName),\n+                () -> cache.close(cacheName),\n+                wrapped()::close", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b89b829dbd9f306f9c94e085f978155cc1eb3"}, "originalPosition": 94}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d67f1a9b39ab41874c2c702eb4cce011afc2560", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/9d67f1a9b39ab41874c2c702eb4cce011afc2560", "committedDate": "2020-03-28T01:20:02Z", "message": "cr feedback"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1699, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}