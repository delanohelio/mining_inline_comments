{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyMzAxNDA1", "number": 9114, "title": "KAFKA-10162; Use Token Bucket algorithm for controller mutation quota (KIP-599, Part III)", "bodyText": "Based on the discussion in #9072, I have put together an alternative way. This one does the following:\n\nInstead of changing the implementation of the Rate to behave like a Token Bucket, it actually use two different metrics: the regular Rate and a new Token Bucket. The latter is used to enforce the quota.\nThe Token Bucket algorithm uses the rate of the quota as the refill rate for the credits and compute the burst based on the number of samples and their length (# samples * sample length * quota).\nThe Token Bucket algorithm used can go under zero in order to handle unlimited burst (e.g. create topic with a number of partitions higher than the burst). Throttling kicks in when the number of credits is under zero.\nThe throttle time is computed as credits under zero / refill rate (or quota).\nOnly the controller mutation uses it for now.\nThe remaining number of credits in the bucket is exposed with the tokens metrics per user/clientId.\n\nThe code can be improved and refactored. I just wanted to get out quickly to get feedback about the approach.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-08-03T17:22:52Z", "url": "https://github.com/apache/kafka/pull/9114", "merged": true, "mergeCommit": {"oid": "b5f90daf13b4945305951ca0eecdb454a4dcafc2"}, "closed": true, "closedAt": "2020-08-06T16:11:57Z", "author": {"login": "dajac"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc7VWPngH2gAyNDYyMzAxNDA1OjIyOWViODI1NDExMzkzNTg2NWQ0NjQ2NjA1YzVhMDJiOTY1MDk4Yzk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc8Jn6qgFqTQ2MjIxMzk1Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "229eb8254113935865d4646605c5a02b965098c9", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/229eb8254113935865d4646605c5a02b965098c9", "committedDate": "2020-08-03T17:19:55Z", "message": "KAFKA-10162; Make the rate based quota behave more like a Token Bucket (KIP-599, Part III)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNDEyNzIw", "url": "https://github.com/apache/kafka/pull/9114#pullrequestreview-460412720", "createdAt": "2020-08-04T00:04:37Z", "commit": {"oid": "229eb8254113935865d4646605c5a02b965098c9"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwMDowNDozN1rOG7MhOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwMDozMDo1NlrOG7M-nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyNDI4MQ==", "bodyText": "Should burst be computed from #samples or #samples - 1 ?", "url": "https://github.com/apache/kafka/pull/9114#discussion_r464724281", "createdAt": "2020-08-04T00:04:37Z", "author": {"login": "junrao"}, "path": "clients/src/main/java/org/apache/kafka/common/metrics/stats/TokenBucket.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics.stats;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.MeasurableStat;\n+import org.apache.kafka.common.metrics.MetricConfig;\n+\n+public class TokenBucket implements MeasurableStat {\n+    private final TimeUnit unit;\n+    private double credits;\n+    private long lastUpdateMs;\n+\n+    public TokenBucket() {\n+        this(TimeUnit.SECONDS);\n+    }\n+\n+    public TokenBucket(TimeUnit unit) {\n+        this.unit = unit;\n+        this.credits = 0;\n+        this.lastUpdateMs = 0;\n+    }\n+\n+    @Override\n+    public double measure(final MetricConfig config, final long timeMs) {\n+        if (config.quota() == null)\n+            return Long.MAX_VALUE;\n+        final double quota = config.quota().bound();\n+        final double burst = (config.samples() - 1) * convert(config.timeWindowMs()) * quota;\n+        refill(quota, burst, timeMs);\n+        return this.credits;\n+    }\n+\n+    @Override\n+    public void record(final MetricConfig config, final double value, final long timeMs) {\n+        if (config.quota() == null)\n+            return;\n+        final double quota = config.quota().bound();\n+        final double burst = (config.samples() - 1) * convert(config.timeWindowMs()) * quota;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "229eb8254113935865d4646605c5a02b965098c9"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDcyOTUxMw==", "bodyText": "Hmm, assuming bound is the per sec rate, it seems that the throttleTimeMs should be -e.value() / e.bound * 1000?", "url": "https://github.com/apache/kafka/pull/9114#discussion_r464729513", "createdAt": "2020-08-04T00:23:08Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -131,6 +133,16 @@ class PermissiveControllerMutationQuota(private val time: Time,\n \n object ControllerMutationQuotaManager {\n   val QuotaControllerMutationDefault = Int.MaxValue.toDouble\n+\n+  def throttleTime(e: QuotaViolationException, timeMs: Long): Long = {\n+    e.metric().measurable() match {\n+      case _: TokenBucket => Math.round(-e.value() * e.bound())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "229eb8254113935865d4646605c5a02b965098c9"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczMTgwNA==", "bodyText": "Should we start with 0 credit or the full burst credits? The benefit of the latter is that during initialization, the requests won't be throttled as much due to a cold start.", "url": "https://github.com/apache/kafka/pull/9114#discussion_r464731804", "createdAt": "2020-08-04T00:30:56Z", "author": {"login": "junrao"}, "path": "clients/src/main/java/org/apache/kafka/common/metrics/stats/TokenBucket.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics.stats;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.MeasurableStat;\n+import org.apache.kafka.common.metrics.MetricConfig;\n+\n+public class TokenBucket implements MeasurableStat {\n+    private final TimeUnit unit;\n+    private double credits;\n+    private long lastUpdateMs;\n+\n+    public TokenBucket() {\n+        this(TimeUnit.SECONDS);\n+    }\n+\n+    public TokenBucket(TimeUnit unit) {\n+        this.unit = unit;\n+        this.credits = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "229eb8254113935865d4646605c5a02b965098c9"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNTA0ODQy", "url": "https://github.com/apache/kafka/pull/9114#pullrequestreview-460504842", "createdAt": "2020-08-04T05:26:47Z", "commit": {"oid": "229eb8254113935865d4646605c5a02b965098c9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwNToyNjo0N1rOG7RmKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwNToyNjo0N1rOG7RmKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgwNzQ2Nw==", "bodyText": "we probably just want value < 0 check here, right? Otherwise the throttle time will be 0 anyways.", "url": "https://github.com/apache/kafka/pull/9114#discussion_r464807467", "createdAt": "2020-08-04T05:26:47Z", "author": {"login": "apovzner"}, "path": "clients/src/main/java/org/apache/kafka/common/metrics/Sensor.java", "diffHunk": "@@ -223,8 +229,14 @@ public void checkQuotas(long timeMs) {\n                 Quota quota = config.quota();\n                 if (quota != null) {\n                     double value = metric.measurableValue(timeMs);\n-                    if (!quota.acceptable(value)) {\n-                        throw new QuotaViolationException(metric, value, quota.bound());\n+                    if (metric.measurable() instanceof TokenBucket) {\n+                        if (value <= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "229eb8254113935865d4646605c5a02b965098c9"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73ab2a074b3063eb9b049dca0f2000090c045e3a", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/73ab2a074b3063eb9b049dca0f2000090c045e3a", "committedDate": "2020-08-04T13:06:46Z", "message": "refactor, add tests, address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTQ4Njk1", "url": "https://github.com/apache/kafka/pull/9114#pullrequestreview-461148695", "createdAt": "2020-08-04T20:27:42Z", "commit": {"oid": "73ab2a074b3063eb9b049dca0f2000090c045e3a"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMDoyNzo0M1rOG7wT9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMjoyNzoxMlrOG7zo4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMxMDcxMA==", "bodyText": "Could we add a high level description of the class?", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465310710", "createdAt": "2020-08-04T20:27:43Z", "author": {"login": "junrao"}, "path": "clients/src/main/java/org/apache/kafka/common/metrics/stats/TokenBucket.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics.stats;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.MeasurableStat;\n+import org.apache.kafka.common.metrics.MetricConfig;\n+\n+public class TokenBucket implements MeasurableStat {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ab2a074b3063eb9b049dca0f2000090c045e3a"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMxMjUxOQ==", "bodyText": "Rate actually allows the windowSize to be close to the full samples * perSampleWindow. The logic around config.samples() - 1 is just to make sure the windowSize contains at least that many full windows. So, to match that behavior, it seems that burst should use config.samples().", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465312519", "createdAt": "2020-08-04T20:31:03Z", "author": {"login": "junrao"}, "path": "clients/src/main/java/org/apache/kafka/common/metrics/stats/TokenBucket.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics.stats;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.MeasurableStat;\n+import org.apache.kafka.common.metrics.MetricConfig;\n+\n+public class TokenBucket implements MeasurableStat {\n+    private final TimeUnit unit;\n+    private double tokens;\n+    private long lastUpdateMs;\n+\n+    public TokenBucket() {\n+        this(TimeUnit.SECONDS);\n+    }\n+\n+    public TokenBucket(TimeUnit unit) {\n+        this.unit = unit;\n+        this.tokens = 0;\n+        this.lastUpdateMs = 0;\n+    }\n+\n+    @Override\n+    public double measure(final MetricConfig config, final long timeMs) {\n+        if (config.quota() == null)\n+            return Long.MAX_VALUE;\n+        final double quota = config.quota().bound();\n+        final double burst = burst(config);\n+        refill(quota, burst, timeMs);\n+        return this.tokens;\n+    }\n+\n+    @Override\n+    public void record(final MetricConfig config, final double value, final long timeMs) {\n+        if (config.quota() == null)\n+            return;\n+        final double quota = config.quota().bound();\n+        final double burst = burst(config);\n+        refill(quota, burst, timeMs);\n+        this.tokens = Math.min(burst, this.tokens - value);\n+    }\n+\n+    private void refill(final double quota, final double burst, final long timeMs) {\n+        this.tokens = Math.min(burst, this.tokens + quota * convert(timeMs - lastUpdateMs));\n+        this.lastUpdateMs = timeMs;\n+    }\n+\n+    private double burst(final MetricConfig config) {\n+        return (config.samples() - 1) * convert(config.timeWindowMs()) * config.quota().bound();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ab2a074b3063eb9b049dca0f2000090c045e3a"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMxNDMzMQ==", "bodyText": "This code is duplicated from Rate. Could we reuse it somehow?", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465314331", "createdAt": "2020-08-04T20:34:38Z", "author": {"login": "junrao"}, "path": "clients/src/main/java/org/apache/kafka/common/metrics/stats/TokenBucket.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics.stats;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.MeasurableStat;\n+import org.apache.kafka.common.metrics.MetricConfig;\n+\n+public class TokenBucket implements MeasurableStat {\n+    private final TimeUnit unit;\n+    private double tokens;\n+    private long lastUpdateMs;\n+\n+    public TokenBucket() {\n+        this(TimeUnit.SECONDS);\n+    }\n+\n+    public TokenBucket(TimeUnit unit) {\n+        this.unit = unit;\n+        this.tokens = 0;\n+        this.lastUpdateMs = 0;\n+    }\n+\n+    @Override\n+    public double measure(final MetricConfig config, final long timeMs) {\n+        if (config.quota() == null)\n+            return Long.MAX_VALUE;\n+        final double quota = config.quota().bound();\n+        final double burst = burst(config);\n+        refill(quota, burst, timeMs);\n+        return this.tokens;\n+    }\n+\n+    @Override\n+    public void record(final MetricConfig config, final double value, final long timeMs) {\n+        if (config.quota() == null)\n+            return;\n+        final double quota = config.quota().bound();\n+        final double burst = burst(config);\n+        refill(quota, burst, timeMs);\n+        this.tokens = Math.min(burst, this.tokens - value);\n+    }\n+\n+    private void refill(final double quota, final double burst, final long timeMs) {\n+        this.tokens = Math.min(burst, this.tokens + quota * convert(timeMs - lastUpdateMs));\n+        this.lastUpdateMs = timeMs;\n+    }\n+\n+    private double burst(final MetricConfig config) {\n+        return (config.samples() - 1) * convert(config.timeWindowMs()) * config.quota().bound();\n+    }\n+\n+    private double convert(final long timeMs) {\n+        switch (unit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ab2a074b3063eb9b049dca0f2000090c045e3a"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM1OTE1Ng==", "bodyText": "throttleTime => throttleTimeMs ?", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465359156", "createdAt": "2020-08-04T22:12:08Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -131,6 +133,22 @@ class PermissiveControllerMutationQuota(private val time: Time,\n \n object ControllerMutationQuotaManager {\n   val QuotaControllerMutationDefault = Int.MaxValue.toDouble\n+\n+  /**\n+   * This calculates the amount of time needed to bring the TokenBucket within quota\n+   * assuming that no new metrics are recorded.\n+   *\n+   * Basically, if a value < 0 is observed, the time required to bring it to zero is\n+   * -value / refill rate (quota bound) * 1000.\n+   */\n+  def throttleTime(e: QuotaViolationException, timeMs: Long): Long = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ab2a074b3063eb9b049dca0f2000090c045e3a"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2MDQ2OQ==", "bodyText": "Could this be private?", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465360469", "createdAt": "2020-08-04T22:14:42Z", "author": {"login": "junrao"}, "path": "core/src/main/scala/kafka/server/ControllerMutationQuotaManager.scala", "diffHunk": "@@ -156,6 +174,24 @@ class ControllerMutationQuotaManager(private val config: ClientQuotaManagerConfi\n       quotaMetricTags.asJava)\n   }\n \n+  protected def clientTokenBucketMetricName(quotaMetricTags: Map[String, String]): MetricName = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ab2a074b3063eb9b049dca0f2000090c045e3a"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2MzI2MQ==", "bodyText": "sensor.record() always calls checkQuotas(). Why do we need to call it explicitly here?", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465363261", "createdAt": "2020-08-04T22:21:46Z", "author": {"login": "junrao"}, "path": "clients/src/test/java/org/apache/kafka/common/metrics/SensorTest.java", "diffHunk": "@@ -209,4 +212,95 @@ public void shouldReturnPresenceOfMetrics() {\n \n         assertThat(sensor.hasMetrics(), is(true));\n     }\n+\n+    @Test\n+    public void testStrictQuotaEnforcementWithRate() {\n+        final Time time = new MockTime(0, System.currentTimeMillis(), 0);\n+        final Metrics metrics = new Metrics(time);\n+        final Sensor sensor = metrics.sensor(\"sensor\", new MetricConfig()\n+            .quota(Quota.upperBound(2))\n+            .timeWindow(1, TimeUnit.SECONDS)\n+            .samples(11));\n+        final MetricName metricName = metrics.metricName(\"rate\", \"test-group\");\n+        assertTrue(sensor.add(metricName, new Rate()));\n+        final KafkaMetric rateMetric = metrics.metric(metricName);\n+\n+        // Recording a first value at T+0 to bring the avg rate to 3 which is already\n+        // above the quota.\n+        strictRecord(sensor, 30, time.milliseconds());\n+        assertEquals(3, rateMetric.measurableValue(time.milliseconds()), 0.1);\n+\n+        // Theoretically, we should wait 5s to bring back the avg rate to the define quota:\n+        // ((30 / 10) - 2) / 2 * 10 = 5s\n+        time.sleep(5000);\n+\n+        // But, recording a second value is rejected because the avg rate is still equal\n+        // to 3 after 5s.\n+        assertEquals(3, rateMetric.measurableValue(time.milliseconds()), 0.1);\n+        assertThrows(QuotaViolationException.class, () -> strictRecord(sensor, 30, time.milliseconds()));\n+\n+        metrics.close();\n+    }\n+\n+    @Test\n+    public void testStrictQuotaEnforcementWithTokenBucket() {\n+        final Time time = new MockTime(0, System.currentTimeMillis(), 0);\n+        final Metrics metrics = new Metrics(time);\n+        final Sensor sensor = metrics.sensor(\"sensor\", new MetricConfig()\n+            .quota(Quota.upperBound(2))\n+            .timeWindow(1, TimeUnit.SECONDS)\n+            .samples(11));\n+        final MetricName metricName = metrics.metricName(\"credits\", \"test-group\");\n+        assertTrue(sensor.add(metricName, new TokenBucket()));\n+        final KafkaMetric tkMetric = metrics.metric(metricName);\n+\n+        // Recording a first value at T+0 to bring the remaining credits below zero\n+        strictRecord(sensor, 30, time.milliseconds());\n+        assertEquals(-10, tkMetric.measurableValue(time.milliseconds()), 0.1);\n+\n+        // Theoretically, we should wait 5s to bring back the avg rate to the define quota:\n+        // 10 / 2 = 5s\n+        time.sleep(5000);\n+\n+        // Unlike the default rate based on a windowed sum, it works as expected.\n+        assertEquals(0, tkMetric.measurableValue(time.milliseconds()), 0.1);\n+        strictRecord(sensor, 30, time.milliseconds());\n+        assertEquals(-30, tkMetric.measurableValue(time.milliseconds()), 0.1);\n+\n+        metrics.close();\n+    }\n+\n+    private void strictRecord(Sensor sensor, double value, long timeMs) {\n+        synchronized (sensor) {\n+            sensor.checkQuotas(timeMs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ab2a074b3063eb9b049dca0f2000090c045e3a"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2NDAyNQ==", "bodyText": "Here, we are just verifying there is no quota exception?", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465364025", "createdAt": "2020-08-04T22:23:56Z", "author": {"login": "junrao"}, "path": "clients/src/test/java/org/apache/kafka/common/metrics/SensorTest.java", "diffHunk": "@@ -209,4 +212,95 @@ public void shouldReturnPresenceOfMetrics() {\n \n         assertThat(sensor.hasMetrics(), is(true));\n     }\n+\n+    @Test\n+    public void testStrictQuotaEnforcementWithRate() {\n+        final Time time = new MockTime(0, System.currentTimeMillis(), 0);\n+        final Metrics metrics = new Metrics(time);\n+        final Sensor sensor = metrics.sensor(\"sensor\", new MetricConfig()\n+            .quota(Quota.upperBound(2))\n+            .timeWindow(1, TimeUnit.SECONDS)\n+            .samples(11));\n+        final MetricName metricName = metrics.metricName(\"rate\", \"test-group\");\n+        assertTrue(sensor.add(metricName, new Rate()));\n+        final KafkaMetric rateMetric = metrics.metric(metricName);\n+\n+        // Recording a first value at T+0 to bring the avg rate to 3 which is already\n+        // above the quota.\n+        strictRecord(sensor, 30, time.milliseconds());\n+        assertEquals(3, rateMetric.measurableValue(time.milliseconds()), 0.1);\n+\n+        // Theoretically, we should wait 5s to bring back the avg rate to the define quota:\n+        // ((30 / 10) - 2) / 2 * 10 = 5s\n+        time.sleep(5000);\n+\n+        // But, recording a second value is rejected because the avg rate is still equal\n+        // to 3 after 5s.\n+        assertEquals(3, rateMetric.measurableValue(time.milliseconds()), 0.1);\n+        assertThrows(QuotaViolationException.class, () -> strictRecord(sensor, 30, time.milliseconds()));\n+\n+        metrics.close();\n+    }\n+\n+    @Test\n+    public void testStrictQuotaEnforcementWithTokenBucket() {\n+        final Time time = new MockTime(0, System.currentTimeMillis(), 0);\n+        final Metrics metrics = new Metrics(time);\n+        final Sensor sensor = metrics.sensor(\"sensor\", new MetricConfig()\n+            .quota(Quota.upperBound(2))\n+            .timeWindow(1, TimeUnit.SECONDS)\n+            .samples(11));\n+        final MetricName metricName = metrics.metricName(\"credits\", \"test-group\");\n+        assertTrue(sensor.add(metricName, new TokenBucket()));\n+        final KafkaMetric tkMetric = metrics.metric(metricName);\n+\n+        // Recording a first value at T+0 to bring the remaining credits below zero\n+        strictRecord(sensor, 30, time.milliseconds());\n+        assertEquals(-10, tkMetric.measurableValue(time.milliseconds()), 0.1);\n+\n+        // Theoretically, we should wait 5s to bring back the avg rate to the define quota:\n+        // 10 / 2 = 5s\n+        time.sleep(5000);\n+\n+        // Unlike the default rate based on a windowed sum, it works as expected.\n+        assertEquals(0, tkMetric.measurableValue(time.milliseconds()), 0.1);\n+        strictRecord(sensor, 30, time.milliseconds());\n+        assertEquals(-30, tkMetric.measurableValue(time.milliseconds()), 0.1);\n+\n+        metrics.close();\n+    }\n+\n+    private void strictRecord(Sensor sensor, double value, long timeMs) {\n+        synchronized (sensor) {\n+            sensor.checkQuotas(timeMs);\n+            sensor.record(value, timeMs, false);\n+        }\n+    }\n+\n+    @Test\n+    public void testRecordAndCheckQuotaUseMetricConfigOfEachStat() {\n+        final Time time = new MockTime(0, System.currentTimeMillis(), 0);\n+        final Metrics metrics = new Metrics(time);\n+        final Sensor sensor = metrics.sensor(\"sensor\");\n+\n+        final MeasurableStat stat1 = Mockito.mock(MeasurableStat.class);\n+        final MetricName stat1Name = metrics.metricName(\"stat1\", \"test-group\");\n+        final MetricConfig stat1Config = new MetricConfig().quota(Quota.upperBound(5));\n+        sensor.add(stat1Name, stat1, stat1Config);\n+\n+        final MeasurableStat stat2 = Mockito.mock(MeasurableStat.class);\n+        final MetricName stat2Name = metrics.metricName(\"stat2\", \"test-group\");\n+        final MetricConfig stat2Config = new MetricConfig().quota(Quota.upperBound(10));\n+        sensor.add(stat2Name, stat2, stat2Config);\n+\n+        sensor.record(10, 1);\n+        Mockito.verify(stat1).record(stat1Config, 10, 1);\n+        Mockito.verify(stat2).record(stat2Config, 10, 1);\n+\n+        Mockito.when(stat1.measure(stat1Config, 2)).thenReturn(2.0);\n+        Mockito.when(stat2.measure(stat2Config, 2)).thenReturn(2.0);\n+        sensor.checkQuotas(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ab2a074b3063eb9b049dca0f2000090c045e3a"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2NTE5Mg==", "bodyText": "We are recording -60.", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465365192", "createdAt": "2020-08-04T22:27:06Z", "author": {"login": "junrao"}, "path": "clients/src/test/java/org/apache/kafka/common/metrics/TokenBucketTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.stats.TokenBucket;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.common.utils.Time;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class TokenBucketTest {\n+    Time time;\n+\n+    @Before\n+    public void setup() {\n+        time = new MockTime(0, System.currentTimeMillis(), System.nanoTime());\n+    }\n+\n+    @Test\n+    public void testRecord() {\n+        // Rate  = 5 unit / sec\n+        // Burst = 2 * (11 - 1) = 20 units\n+        MetricConfig config = new MetricConfig()\n+            .quota(Quota.upperBound(5))\n+            .timeWindow(2, TimeUnit.SECONDS)\n+            .samples(11);\n+\n+        TokenBucket tk = new TokenBucket();\n+\n+        // Expect 100 credits at T\n+        assertEquals(100, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Record 60 at T, expect 13 credits\n+        tk.record(config, 60, time.milliseconds());\n+        assertEquals(40, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Advance by 2s, record 5, expect 45 credits\n+        time.sleep(2000);\n+        tk.record(config, 5, time.milliseconds());\n+        assertEquals(45, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Advance by 2s, record 60, expect -5 credits\n+        time.sleep(2000);\n+        tk.record(config, 60, time.milliseconds());\n+        assertEquals(-5, tk.measure(config, time.milliseconds()), 0.1);\n+    }\n+\n+    @Test\n+    public void testUnrecord() {\n+        // Rate  = 5 unit / sec\n+        // Burst = 2 * (11 - 1) = 20 units\n+        MetricConfig config = new MetricConfig()\n+            .quota(Quota.upperBound(5))\n+            .timeWindow(2, TimeUnit.SECONDS)\n+            .samples(11);\n+\n+        TokenBucket tk = new TokenBucket();\n+\n+        // Expect 100 credits at T\n+        assertEquals(100, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Record 60 at T, expect 100 credits", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ab2a074b3063eb9b049dca0f2000090c045e3a"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM2NTIxNw==", "bodyText": "We are recording -60.", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465365217", "createdAt": "2020-08-04T22:27:12Z", "author": {"login": "junrao"}, "path": "clients/src/test/java/org/apache/kafka/common/metrics/TokenBucketTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.stats.TokenBucket;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.common.utils.Time;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class TokenBucketTest {\n+    Time time;\n+\n+    @Before\n+    public void setup() {\n+        time = new MockTime(0, System.currentTimeMillis(), System.nanoTime());\n+    }\n+\n+    @Test\n+    public void testRecord() {\n+        // Rate  = 5 unit / sec\n+        // Burst = 2 * (11 - 1) = 20 units\n+        MetricConfig config = new MetricConfig()\n+            .quota(Quota.upperBound(5))\n+            .timeWindow(2, TimeUnit.SECONDS)\n+            .samples(11);\n+\n+        TokenBucket tk = new TokenBucket();\n+\n+        // Expect 100 credits at T\n+        assertEquals(100, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Record 60 at T, expect 13 credits\n+        tk.record(config, 60, time.milliseconds());\n+        assertEquals(40, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Advance by 2s, record 5, expect 45 credits\n+        time.sleep(2000);\n+        tk.record(config, 5, time.milliseconds());\n+        assertEquals(45, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Advance by 2s, record 60, expect -5 credits\n+        time.sleep(2000);\n+        tk.record(config, 60, time.milliseconds());\n+        assertEquals(-5, tk.measure(config, time.milliseconds()), 0.1);\n+    }\n+\n+    @Test\n+    public void testUnrecord() {\n+        // Rate  = 5 unit / sec\n+        // Burst = 2 * (11 - 1) = 20 units\n+        MetricConfig config = new MetricConfig()\n+            .quota(Quota.upperBound(5))\n+            .timeWindow(2, TimeUnit.SECONDS)\n+            .samples(11);\n+\n+        TokenBucket tk = new TokenBucket();\n+\n+        // Expect 100 credits at T\n+        assertEquals(100, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Record 60 at T, expect 100 credits\n+        tk.record(config, -60, time.milliseconds());\n+        assertEquals(100, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Advance by 2s, record 60, expect 40 credits\n+        time.sleep(2000);\n+        tk.record(config, 60, time.milliseconds());\n+        assertEquals(40, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Advance by 2s, record 60, expect 100 credits", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73ab2a074b3063eb9b049dca0f2000090c045e3a"}, "originalPosition": 88}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a000782bb8e9e9c95b707b713dfb7c890eda2f1", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/5a000782bb8e9e9c95b707b713dfb7c890eda2f1", "committedDate": "2020-08-05T17:55:04Z", "message": "Address Jun's comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxOTE4MDYz", "url": "https://github.com/apache/kafka/pull/9114#pullrequestreview-461918063", "createdAt": "2020-08-05T18:27:17Z", "commit": {"oid": "5a000782bb8e9e9c95b707b713dfb7c890eda2f1"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODoyNzoxN1rOG8Vi4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODoyOTowNVrOG8Vmrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyMDczNg==", "bodyText": "Could we document how this quota behaves differently from existing quota?", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465920736", "createdAt": "2020-08-05T18:27:17Z", "author": {"login": "junrao"}, "path": "clients/src/main/java/org/apache/kafka/common/metrics/stats/TokenBucket.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics.stats;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.MeasurableStat;\n+import org.apache.kafka.common.metrics.MetricConfig;\n+import org.apache.kafka.common.metrics.Quota;\n+\n+import static org.apache.kafka.common.metrics.internals.MetricsUtils.convert;\n+\n+/**\n+ * The {@link TokenBucket} is a {@link MeasurableStat} implementing a token bucket algorithm\n+ * that is usable within a {@link org.apache.kafka.common.metrics.Sensor}.\n+ *\n+ * The {@link Quota#bound()} defined the refill rate of the bucket while the maximum burst or\n+ * the maximum number of credits of the bucket is defined by\n+ * {@link MetricConfig#samples() * MetricConfig#timeWindowMs() * Quota#bound()}.\n+ *\n+ * The quota is considered as exhausted when the amount of remaining credits in the bucket", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a000782bb8e9e9c95b707b713dfb7c890eda2f1"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyMDkxOA==", "bodyText": "we have 10 samples now.", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465920918", "createdAt": "2020-08-05T18:27:34Z", "author": {"login": "junrao"}, "path": "clients/src/test/java/org/apache/kafka/common/metrics/TokenBucketTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.stats.TokenBucket;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.common.utils.Time;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class TokenBucketTest {\n+    Time time;\n+\n+    @Before\n+    public void setup() {\n+        time = new MockTime(0, System.currentTimeMillis(), System.nanoTime());\n+    }\n+\n+    @Test\n+    public void testRecord() {\n+        // Rate  = 5 unit / sec\n+        // Burst = 2 * (11 - 1) = 20 units", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a000782bb8e9e9c95b707b713dfb7c890eda2f1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyMTAwMQ==", "bodyText": "we have 10 samples now.", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465921001", "createdAt": "2020-08-05T18:27:44Z", "author": {"login": "junrao"}, "path": "clients/src/test/java/org/apache/kafka/common/metrics/TokenBucketTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.stats.TokenBucket;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.common.utils.Time;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class TokenBucketTest {\n+    Time time;\n+\n+    @Before\n+    public void setup() {\n+        time = new MockTime(0, System.currentTimeMillis(), System.nanoTime());\n+    }\n+\n+    @Test\n+    public void testRecord() {\n+        // Rate  = 5 unit / sec\n+        // Burst = 2 * (11 - 1) = 20 units\n+        MetricConfig config = new MetricConfig()\n+            .quota(Quota.upperBound(5))\n+            .timeWindow(2, TimeUnit.SECONDS)\n+            .samples(10);\n+\n+        TokenBucket tk = new TokenBucket();\n+\n+        // Expect 100 credits at T\n+        assertEquals(100, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Record 60 at T, expect 13 credits\n+        tk.record(config, 60, time.milliseconds());\n+        assertEquals(40, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Advance by 2s, record 5, expect 45 credits\n+        time.sleep(2000);\n+        tk.record(config, 5, time.milliseconds());\n+        assertEquals(45, tk.measure(config, time.milliseconds()), 0.1);\n+\n+        // Advance by 2s, record 60, expect -5 credits\n+        time.sleep(2000);\n+        tk.record(config, 60, time.milliseconds());\n+        assertEquals(-5, tk.measure(config, time.milliseconds()), 0.1);\n+    }\n+\n+    @Test\n+    public void testUnrecord() {\n+        // Rate  = 5 unit / sec\n+        // Burst = 2 * (11 - 1) = 20 units", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a000782bb8e9e9c95b707b713dfb7c890eda2f1"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyMTcxMA==", "bodyText": "Is the test based on 10 samples?", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465921710", "createdAt": "2020-08-05T18:29:05Z", "author": {"login": "junrao"}, "path": "clients/src/test/java/org/apache/kafka/common/metrics/SensorTest.java", "diffHunk": "@@ -209,4 +212,95 @@ public void shouldReturnPresenceOfMetrics() {\n \n         assertThat(sensor.hasMetrics(), is(true));\n     }\n+\n+    @Test\n+    public void testStrictQuotaEnforcementWithRate() {\n+        final Time time = new MockTime(0, System.currentTimeMillis(), 0);\n+        final Metrics metrics = new Metrics(time);\n+        final Sensor sensor = metrics.sensor(\"sensor\", new MetricConfig()\n+            .quota(Quota.upperBound(2))\n+            .timeWindow(1, TimeUnit.SECONDS)\n+            .samples(11));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5a000782bb8e9e9c95b707b713dfb7c890eda2f1"}, "originalPosition": 35}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1295d63a8600ca22cc598a3ae3d28bea41267f2", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/e1295d63a8600ca22cc598a3ae3d28bea41267f2", "committedDate": "2020-08-05T19:54:57Z", "message": "address Jun's comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyMDA2MTQ1", "url": "https://github.com/apache/kafka/pull/9114#pullrequestreview-462006145", "createdAt": "2020-08-05T20:38:48Z", "commit": {"oid": "e1295d63a8600ca22cc598a3ae3d28bea41267f2"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDozODo0OFrOG8ZwqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDozOTozNlrOG8ZyHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4OTgwMA==", "bodyText": "\"this until it is\" doesn't quite parse.", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465989800", "createdAt": "2020-08-05T20:38:48Z", "author": {"login": "junrao"}, "path": "clients/src/main/java/org/apache/kafka/common/metrics/stats/TokenBucket.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics.stats;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.MeasurableStat;\n+import org.apache.kafka.common.metrics.MetricConfig;\n+import org.apache.kafka.common.metrics.Quota;\n+\n+import static org.apache.kafka.common.metrics.internals.MetricsUtils.convert;\n+\n+/**\n+ * The {@link TokenBucket} is a {@link MeasurableStat} implementing a token bucket algorithm\n+ * that is usable within a {@link org.apache.kafka.common.metrics.Sensor}.\n+ *\n+ * The {@link Quota#bound()} defined the refill rate of the bucket while the maximum burst or\n+ * the maximum number of credits of the bucket is defined by\n+ * {@link MetricConfig#samples() * MetricConfig#timeWindowMs() * Quota#bound()}.\n+ *\n+ * The quota is considered as exhausted when the amount of remaining credits in the bucket\n+ * is below zero. The enforcement is done by the {@link org.apache.kafka.common.metrics.Sensor}.\n+ *\n+ * Token Bucket vs Rate based Quota:\n+ * The current sampled rate based quota does not cope well with bursty workloads. The issue is\n+ * that a unique and large sample can hold the average above the quota and this until it is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1295d63a8600ca22cc598a3ae3d28bea41267f2"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5MDE3NQ==", "bodyText": "\"The throttle time \" : I guess this is the expected throttle time?", "url": "https://github.com/apache/kafka/pull/9114#discussion_r465990175", "createdAt": "2020-08-05T20:39:36Z", "author": {"login": "junrao"}, "path": "clients/src/main/java/org/apache/kafka/common/metrics/stats/TokenBucket.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.common.metrics.stats;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.apache.kafka.common.metrics.MeasurableStat;\n+import org.apache.kafka.common.metrics.MetricConfig;\n+import org.apache.kafka.common.metrics.Quota;\n+\n+import static org.apache.kafka.common.metrics.internals.MetricsUtils.convert;\n+\n+/**\n+ * The {@link TokenBucket} is a {@link MeasurableStat} implementing a token bucket algorithm\n+ * that is usable within a {@link org.apache.kafka.common.metrics.Sensor}.\n+ *\n+ * The {@link Quota#bound()} defined the refill rate of the bucket while the maximum burst or\n+ * the maximum number of credits of the bucket is defined by\n+ * {@link MetricConfig#samples() * MetricConfig#timeWindowMs() * Quota#bound()}.\n+ *\n+ * The quota is considered as exhausted when the amount of remaining credits in the bucket\n+ * is below zero. The enforcement is done by the {@link org.apache.kafka.common.metrics.Sensor}.\n+ *\n+ * Token Bucket vs Rate based Quota:\n+ * The current sampled rate based quota does not cope well with bursty workloads. The issue is\n+ * that a unique and large sample can hold the average above the quota and this until it is\n+ * discarded. Practically, when this happens, one must wait until the sample is expired to\n+ * bring the rate below the quota even though less time would be theoretically required. As an\n+ * examples, let's imagine that we have:\n+ * - Quota (Q)   = 5\n+ * - Samples (S) = 100\n+ * - Window (W)  = 1s\n+ * A burst of 560 brings the average rate (R) to 5.6 (560 / 100). The throttle time is computed as", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1295d63a8600ca22cc598a3ae3d28bea41267f2"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "feb0dade0e9caf1794fb4f687e324bad7806d213", "author": {"user": {"login": "dajac", "name": "David Jacot"}}, "url": "https://github.com/apache/kafka/commit/feb0dade0e9caf1794fb4f687e324bad7806d213", "committedDate": "2020-08-05T20:53:06Z", "message": "fixup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyMDIyNDI1", "url": "https://github.com/apache/kafka/pull/9114#pullrequestreview-462022425", "createdAt": "2020-08-05T21:04:13Z", "commit": {"oid": "feb0dade0e9caf1794fb4f687e324bad7806d213"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyMjEzOTU3", "url": "https://github.com/apache/kafka/pull/9114#pullrequestreview-462213957", "createdAt": "2020-08-06T06:14:17Z", "commit": {"oid": "feb0dade0e9caf1794fb4f687e324bad7806d213"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1041, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}