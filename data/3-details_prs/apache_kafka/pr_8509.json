{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1NDMwMzk1", "number": 8509, "title": "KAFKA-9839: Broker should accept control requests with newer broker epoch", "bodyText": "A broker throws IllegalStateException if the broker epoch in the LeaderAndIsr/UpdateMetadataRequest/StopReplicaRequest is larger than its current broker epoch. However, there is no guarantee that the broker would receive the latest broker epoch before the controller: When the broker registers with ZK, there are few more instructions to process before this broker \"knows\" about its epoch, while the controller may already get notified and send UPDATE_METADATA request (as an example) with the new epoch. This will result in clients getting stale metadata from this broker.\nWith this PR, a broker accepts LeaderAndIsr/UpdateMetadataRequest/StopReplicaRequest if the broker epoch is newer than the current epoch.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-04-18T02:23:17Z", "url": "https://github.com/apache/kafka/pull/8509", "merged": true, "mergeCommit": {"oid": "bd17085ec10c767bc82e6b19a3016cf5d50dad92"}, "closed": true, "closedAt": "2020-04-27T19:41:31Z", "author": {"login": "apovzner"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcYr-RaAH2gAyNDA1NDMwMzk1OjBjOWQwMTVmMzMxM2Y4ZDcyNTEzNGU0ODExMWU2ZjkzNzhkY2I5MjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcajlUQgH2gAyNDA1NDMwMzk1OmQ5NTI4NTQwMThiMjg2MmY0OGQyM2RjY2U5ZGI2ODJhMTY5MjNhYjA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0c9d015f3313f8d725134e48111e6f9378dcb920", "author": {"user": {"login": "apovzner", "name": "Anna Povzner"}}, "url": "https://github.com/apache/kafka/commit/0c9d015f3313f8d725134e48111e6f9378dcb920", "committedDate": "2020-04-18T01:54:12Z", "message": "KAFKA-9839: Broker should accept control requests with newer broker epoch"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1OTE2NDAz", "url": "https://github.com/apache/kafka/pull/8509#pullrequestreview-395916403", "createdAt": "2020-04-18T14:01:54Z", "commit": {"oid": "0c9d015f3313f8d725134e48111e6f9378dcb920"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8604ede27d47a3a4bd016d70d7a1c7438445a00", "author": {"user": {"login": "apovzner", "name": "Anna Povzner"}}, "url": "https://github.com/apache/kafka/commit/d8604ede27d47a3a4bd016d70d7a1c7438445a00", "committedDate": "2020-04-22T03:19:54Z", "message": "added KafkaApisTest unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3OTkwODk5", "url": "https://github.com/apache/kafka/pull/8509#pullrequestreview-397990899", "createdAt": "2020-04-22T09:06:10Z", "commit": {"oid": "d8604ede27d47a3a4bd016d70d7a1c7438445a00"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTowNjoxMVrOGJrw0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwOTowOTowOVrOGJr48A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwNzM3Nw==", "bodyText": "This and the two above should use testStopReplicaRequest instead of testUpdateMetadataRequest.", "url": "https://github.com/apache/kafka/pull/8509#discussion_r412807377", "createdAt": "2020-04-22T09:06:11Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -1553,6 +1552,179 @@ class KafkaApisTest {\n     assertEquals(Errors.INVALID_REQUEST, response.error)\n   }\n \n+  @Test\n+  def testUpdateMetadataRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testUpdateMetadataRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val updateMetadataRequest = createBasicMetadataRequest(\"topicA\", 1, brokerEpochInRequest)\n+    val request = buildRequest(updateMetadataRequest)\n+\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.maybeUpdateMetadataCache(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      Seq()\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleUpdateMetadataRequest(request)\n+    val updateMetadataResponse = readResponse(ApiKeys.UPDATE_METADATA, updateMetadataRequest, capturedResponse)\n+      .asInstanceOf[UpdateMetadataResponse]\n+    assertEquals(expectedError, updateMetadataResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testLeaderAndIsrRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val controllerId = 2\n+    val controllerEpoch = 6\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+    val partitionStates = Seq(\n+      new LeaderAndIsrRequestData.LeaderAndIsrPartitionState()\n+        .setTopicName(\"topicW\")\n+        .setPartitionIndex(1)\n+        .setControllerEpoch(1)\n+        .setLeader(0)\n+        .setLeaderEpoch(1)\n+        .setIsr(asList(0, 1))\n+        .setZkVersion(2)\n+        .setReplicas(asList(0, 1, 2))\n+        .setIsNew(false)\n+    ).asJava\n+    val leaderAndIsrRequest = new LeaderAndIsrRequest.Builder(\n+      ApiKeys.LEADER_AND_ISR.latestVersion,\n+      controllerId,\n+      controllerEpoch,\n+      brokerEpochInRequest,\n+      partitionStates,\n+      asList(new Node(0, \"host0\", 9090), new Node(1, \"host1\", 9091))\n+    ).build()\n+    val request = buildRequest(leaderAndIsrRequest)\n+    val response = new LeaderAndIsrResponse(new LeaderAndIsrResponseData()\n+      .setErrorCode(Errors.NONE.code)\n+      .setPartitionErrors(asList()))\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.becomeLeaderOrFollower(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject(),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      response\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleLeaderAndIsrRequest(request)\n+    val leaderAndIsrResponse = readResponse(ApiKeys.LEADER_AND_ISR, leaderAndIsrRequest, capturedResponse)\n+      .asInstanceOf[LeaderAndIsrResponse]\n+    assertEquals(expectedError, leaderAndIsrResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8604ede27d47a3a4bd016d70d7a1c7438445a00"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwOTAxOQ==", "bodyText": "brokerEpoch is not necessary, I suppose.", "url": "https://github.com/apache/kafka/pull/8509#discussion_r412809019", "createdAt": "2020-04-22T09:08:33Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -1553,6 +1552,179 @@ class KafkaApisTest {\n     assertEquals(Errors.INVALID_REQUEST, response.error)\n   }\n \n+  @Test\n+  def testUpdateMetadataRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testUpdateMetadataRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val updateMetadataRequest = createBasicMetadataRequest(\"topicA\", 1, brokerEpochInRequest)\n+    val request = buildRequest(updateMetadataRequest)\n+\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.maybeUpdateMetadataCache(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      Seq()\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleUpdateMetadataRequest(request)\n+    val updateMetadataResponse = readResponse(ApiKeys.UPDATE_METADATA, updateMetadataRequest, capturedResponse)\n+      .asInstanceOf[UpdateMetadataResponse]\n+    assertEquals(expectedError, updateMetadataResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testLeaderAndIsrRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val controllerId = 2\n+    val controllerEpoch = 6\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+    val partitionStates = Seq(\n+      new LeaderAndIsrRequestData.LeaderAndIsrPartitionState()\n+        .setTopicName(\"topicW\")\n+        .setPartitionIndex(1)\n+        .setControllerEpoch(1)\n+        .setLeader(0)\n+        .setLeaderEpoch(1)\n+        .setIsr(asList(0, 1))\n+        .setZkVersion(2)\n+        .setReplicas(asList(0, 1, 2))\n+        .setIsNew(false)\n+    ).asJava\n+    val leaderAndIsrRequest = new LeaderAndIsrRequest.Builder(\n+      ApiKeys.LEADER_AND_ISR.latestVersion,\n+      controllerId,\n+      controllerEpoch,\n+      brokerEpochInRequest,\n+      partitionStates,\n+      asList(new Node(0, \"host0\", 9090), new Node(1, \"host1\", 9091))\n+    ).build()\n+    val request = buildRequest(leaderAndIsrRequest)\n+    val response = new LeaderAndIsrResponse(new LeaderAndIsrResponseData()\n+      .setErrorCode(Errors.NONE.code)\n+      .setPartitionErrors(asList()))\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.becomeLeaderOrFollower(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject(),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      response\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleLeaderAndIsrRequest(request)\n+    val leaderAndIsrResponse = readResponse(ApiKeys.LEADER_AND_ISR, leaderAndIsrRequest, capturedResponse)\n+      .asInstanceOf[LeaderAndIsrResponse]\n+    assertEquals(expectedError, leaderAndIsrResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testStopReplicaRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val controllerId = 0\n+    val controllerEpoch = 5\n+    val brokerEpoch = 230498320L", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8604ede27d47a3a4bd016d70d7a1c7438445a00"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwOTQ1Ng==", "bodyText": "This should rely on brokerEpochInRequest.", "url": "https://github.com/apache/kafka/pull/8509#discussion_r412809456", "createdAt": "2020-04-22T09:09:09Z", "author": {"login": "dajac"}, "path": "core/src/test/scala/unit/kafka/server/KafkaApisTest.scala", "diffHunk": "@@ -1553,6 +1552,179 @@ class KafkaApisTest {\n     assertEquals(Errors.INVALID_REQUEST, response.error)\n   }\n \n+  @Test\n+  def testUpdateMetadataRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testUpdateMetadataRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testUpdateMetadataRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val updateMetadataRequest = createBasicMetadataRequest(\"topicA\", 1, brokerEpochInRequest)\n+    val request = buildRequest(updateMetadataRequest)\n+\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.maybeUpdateMetadataCache(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      Seq()\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleUpdateMetadataRequest(request)\n+    val updateMetadataResponse = readResponse(ApiKeys.UPDATE_METADATA, updateMetadataRequest, capturedResponse)\n+      .asInstanceOf[UpdateMetadataResponse]\n+    assertEquals(expectedError, updateMetadataResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testLeaderAndIsrRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testLeaderAndIsrRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testLeaderAndIsrRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val controllerId = 2\n+    val controllerEpoch = 6\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+    val partitionStates = Seq(\n+      new LeaderAndIsrRequestData.LeaderAndIsrPartitionState()\n+        .setTopicName(\"topicW\")\n+        .setPartitionIndex(1)\n+        .setControllerEpoch(1)\n+        .setLeader(0)\n+        .setLeaderEpoch(1)\n+        .setIsr(asList(0, 1))\n+        .setZkVersion(2)\n+        .setReplicas(asList(0, 1, 2))\n+        .setIsNew(false)\n+    ).asJava\n+    val leaderAndIsrRequest = new LeaderAndIsrRequest.Builder(\n+      ApiKeys.LEADER_AND_ISR.latestVersion,\n+      controllerId,\n+      controllerEpoch,\n+      brokerEpochInRequest,\n+      partitionStates,\n+      asList(new Node(0, \"host0\", 9090), new Node(1, \"host1\", 9091))\n+    ).build()\n+    val request = buildRequest(leaderAndIsrRequest)\n+    val response = new LeaderAndIsrResponse(new LeaderAndIsrResponseData()\n+      .setErrorCode(Errors.NONE.code)\n+      .setPartitionErrors(asList()))\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.becomeLeaderOrFollower(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.anyObject(),\n+      EasyMock.anyObject()\n+    )).andStubReturn(\n+      response\n+    )\n+\n+    EasyMock.expect(requestChannel.sendResponse(EasyMock.capture(capturedResponse)))\n+    EasyMock.replay(replicaManager, controller, requestChannel)\n+\n+    createKafkaApis().handleLeaderAndIsrRequest(request)\n+    val leaderAndIsrResponse = readResponse(ApiKeys.LEADER_AND_ISR, leaderAndIsrRequest, capturedResponse)\n+      .asInstanceOf[LeaderAndIsrResponse]\n+    assertEquals(expectedError, leaderAndIsrResponse.error())\n+    EasyMock.verify(replicaManager)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithCurrentBrokerEpoch(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithNewerBrokerEpochIsValid(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch + 1, Errors.NONE)\n+  }\n+\n+  @Test\n+  def testStopReplicaRequestWithStaleBrokerEpochIsRejected(): Unit = {\n+    val currentBrokerEpoch = 1239875L\n+    testUpdateMetadataRequest(currentBrokerEpoch, currentBrokerEpoch - 1, Errors.STALE_BROKER_EPOCH)\n+  }\n+\n+  def testStopReplicaRequest(currentBrokerEpoch: Long, brokerEpochInRequest: Long, expectedError: Errors): Unit = {\n+    val controllerId = 0\n+    val controllerEpoch = 5\n+    val brokerEpoch = 230498320L\n+    val capturedResponse: Capture[RequestChannel.Response] = EasyMock.newCapture()\n+    val fooPartition = new TopicPartition(\"foo\", 0)\n+    val topicStates = Seq(\n+      new StopReplicaTopicState()\n+        .setTopicName(fooPartition.topic())\n+        .setPartitionStates(Seq(new StopReplicaPartitionState()\n+          .setPartitionIndex(fooPartition.partition())\n+          .setLeaderEpoch(1)\n+          .setDeletePartition(false)).asJava)\n+    ).asJava\n+    val stopReplicaRequest = new StopReplicaRequest.Builder(\n+      ApiKeys.STOP_REPLICA.latestVersion,\n+      controllerId,\n+      controllerEpoch,\n+      brokerEpochInRequest,\n+      false,\n+      topicStates\n+    ).build()\n+    val request = buildRequest(stopReplicaRequest)\n+\n+    EasyMock.expect(controller.brokerEpoch).andStubReturn(currentBrokerEpoch)\n+    EasyMock.expect(replicaManager.stopReplicas(\n+      EasyMock.eq(request.context.correlationId),\n+      EasyMock.eq(controllerId),\n+      EasyMock.eq(controllerEpoch),\n+      EasyMock.eq(brokerEpoch + 1),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8604ede27d47a3a4bd016d70d7a1c7438445a00"}, "originalPosition": 214}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4MzE5MTA2", "url": "https://github.com/apache/kafka/pull/8509#pullrequestreview-398319106", "createdAt": "2020-04-22T15:37:30Z", "commit": {"oid": "d8604ede27d47a3a4bd016d70d7a1c7438445a00"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNTozNzozMFrOGJ9E3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxNTozNzozMFrOGJ9E3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5MTAzNw==", "bodyText": "Short comment here may be helpful about the case where the controller sees the epoch bump first.", "url": "https://github.com/apache/kafka/pull/8509#discussion_r413091037", "createdAt": "2020-04-22T15:37:30Z", "author": {"login": "hachikuji"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -3084,12 +3084,7 @@ class KafkaApis(val requestChannel: RequestChannel,\n     // Broker epoch in LeaderAndIsr/UpdateMetadata/StopReplica request is unknown\n     // if the controller hasn't been upgraded to use KIP-380\n     if (brokerEpochInRequest == AbstractControlRequest.UNKNOWN_BROKER_EPOCH) false\n-    else {\n-      val curBrokerEpoch = controller.brokerEpoch\n-      if (brokerEpochInRequest < curBrokerEpoch) true\n-      else if (brokerEpochInRequest == curBrokerEpoch) false\n-      else throw new IllegalStateException(s\"Epoch $brokerEpochInRequest larger than current broker epoch $curBrokerEpoch\")\n-    }\n+    else brokerEpochInRequest < controller.brokerEpoch", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8604ede27d47a3a4bd016d70d7a1c7438445a00"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "062c787a6a34246ac25026ebb6d3cfeec3515d20", "author": {"user": {"login": "apovzner", "name": "Anna Povzner"}}, "url": "https://github.com/apache/kafka/commit/062c787a6a34246ac25026ebb6d3cfeec3515d20", "committedDate": "2020-04-22T21:13:25Z", "message": "fixed testStopReplicaRequestXXX unit tests and added a comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NzkwNzcy", "url": "https://github.com/apache/kafka/pull/8509#pullrequestreview-398790772", "createdAt": "2020-04-23T06:24:16Z", "commit": {"oid": "062c787a6a34246ac25026ebb6d3cfeec3515d20"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjoyNDoxNlrOGKYjOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjoyNDoxNlrOGKYjOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzU0MTE3Nw==", "bodyText": "nit: Alignment of the comment looks a bit weird. I would align it with the if/else.", "url": "https://github.com/apache/kafka/pull/8509#discussion_r413541177", "createdAt": "2020-04-23T06:24:16Z", "author": {"login": "dajac"}, "path": "core/src/main/scala/kafka/server/KafkaApis.scala", "diffHunk": "@@ -3084,12 +3084,9 @@ class KafkaApis(val requestChannel: RequestChannel,\n     // Broker epoch in LeaderAndIsr/UpdateMetadata/StopReplica request is unknown\n     // if the controller hasn't been upgraded to use KIP-380\n     if (brokerEpochInRequest == AbstractControlRequest.UNKNOWN_BROKER_EPOCH) false\n-    else {\n-      val curBrokerEpoch = controller.brokerEpoch\n-      if (brokerEpochInRequest < curBrokerEpoch) true\n-      else if (brokerEpochInRequest == curBrokerEpoch) false\n-      else throw new IllegalStateException(s\"Epoch $brokerEpochInRequest larger than current broker epoch $curBrokerEpoch\")\n-    }\n+      // brokerEpochInRequest > controller.brokerEpoch is possible in rare scenarios where the controller gets notified\n+      // about the new broker epoch and sends a control request with this epoch before the broker learns about it", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "062c787a6a34246ac25026ebb6d3cfeec3515d20"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NDcwMDc3", "url": "https://github.com/apache/kafka/pull/8509#pullrequestreview-399470077", "createdAt": "2020-04-23T20:56:43Z", "commit": {"oid": "062c787a6a34246ac25026ebb6d3cfeec3515d20"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d952854018b2862f48d23dcce9db682a16923ab0", "author": {"user": {"login": "apovzner", "name": "Anna Povzner"}}, "url": "https://github.com/apache/kafka/commit/d952854018b2862f48d23dcce9db682a16923ab0", "committedDate": "2020-04-23T21:15:33Z", "message": "adjusted comment alignment"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1562, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}