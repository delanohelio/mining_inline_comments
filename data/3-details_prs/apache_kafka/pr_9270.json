{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyNjcyMjE2", "number": 9270, "title": "KAFKA-10284: Group membership update due to static member rejoin should be persisted", "bodyText": "Committer Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-09-09T08:53:03Z", "url": "https://github.com/apache/kafka/pull/9270", "merged": true, "mergeCommit": {"oid": "7ca299b8c0f2f3256c40b694078e422350c20d19"}, "closed": true, "closedAt": "2020-10-22T14:55:53Z", "author": {"login": "feyman2016"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdHIAQ3AH2gAyNDgyNjcyMjE2OjA1OGFhMWQ5ZjE3Y2NlNmEzZjdmZmY5MDIzZWJmNDJiOGY0ZjY0MmU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdUu1KIgH2gAyNDgyNjcyMjE2OmM5ZjM1OGQ2YjhlYWYxNGU1ZDVkYTIzMmJhN2Y1Y2EwMjRmMGVmN2E=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "058aa1d9f17cce6a3f7fff9023ebf42b8f4f642e", "author": {"user": {"login": "feyman2016", "name": null}}, "url": "https://github.com/apache/kafka/commit/058aa1d9f17cce6a3f7fff9023ebf42b8f4f642e", "committedDate": "2020-09-09T08:34:14Z", "message": "KAFKA-10284: Group membership update due to static member rejoin should be persisted"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7466bcd4086646c7e0dfa1906adca42610a6f601", "author": {"user": {"login": "feyman2016", "name": null}}, "url": "https://github.com/apache/kafka/commit/7466bcd4086646c7e0dfa1906adca42610a6f601", "committedDate": "2020-09-09T13:23:48Z", "message": "formatting"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNjcyOTY2", "url": "https://github.com/apache/kafka/pull/9270#pullrequestreview-493672966", "createdAt": "2020-09-22T17:05:00Z", "commit": {"oid": "7466bcd4086646c7e0dfa1906adca42610a6f601"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNzowNTowMFrOHWEC5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQxNzoxMDowOFrOHWEPgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg5Njk5Nw==", "bodyText": "nit: alignment", "url": "https://github.com/apache/kafka/pull/9270#discussion_r492896997", "createdAt": "2020-09-22T17:05:00Z", "author": {"login": "abbccdda"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -3882,6 +3942,21 @@ class GroupCoordinatorTest {\n     Await.result(responseFuture, Duration(rebalanceTimeout + 100, TimeUnit.MILLISECONDS))\n   }\n \n+  private def staticJoinGroupWithPersistence(groupId: String,\n+                                 memberId: String,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7466bcd4086646c7e0dfa1906adca42610a6f601"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg5OTQxMA==", "bodyText": "Should we reply join failure if the persistence of the group metadata failed?", "url": "https://github.com/apache/kafka/pull/9270#discussion_r492899410", "createdAt": "2020-09-22T17:08:49Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -1040,21 +1040,36 @@ class GroupCoordinator(val brokerId: Int,\n \n     group.currentState match {\n       case Stable =>\n-        info(s\"Static member joins during Stable stage will not trigger rebalance.\")\n-        group.maybeInvokeJoinCallback(member, JoinGroupResult(\n-          members = List.empty,\n-          memberId = newMemberId,\n-          generationId = group.generationId,\n-          protocolType = group.protocolType,\n-          protocolName = group.protocolName,\n-          // We want to avoid current leader performing trivial assignment while the group\n-          // is in stable stage, because the new assignment in leader's next sync call\n-          // won't be broadcast by a stable group. This could be guaranteed by\n-          // always returning the old leader id so that the current leader won't assume itself\n-          // as a leader based on the returned message, since the new member.id won't match\n-          // returned leader id, therefore no assignment will be performed.\n-          leaderId = currentLeader,\n-          error = Errors.NONE))\n+        // check if group's selectedProtocol of next generation will change, if not, simply store group to persist the\n+        // updated static member, if yes, rebalance should be triggered to let the group's assignment and selectProtocol consistent\n+        val selectedProtocolOfNextGeneration = group.selectProtocol\n+        if (group.protocolName.contains(selectedProtocolOfNextGeneration)) {\n+          info(s\"Static member which joins during Stable stage and doesn't affect selectProtocol will not trigger rebalance.\")\n+          val groupAssignment: Map[String, Array[Byte]] = group.allMemberMetadata.map(member => member.memberId -> member.assignment).toMap\n+          groupManager.storeGroup(group, groupAssignment, error => {\n+            group.inLock {\n+              if (error != Errors.NONE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7466bcd4086646c7e0dfa1906adca42610a6f601"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkwMDIyNw==", "bodyText": "Could you elaborate why this case is possible? We do have checks for !group.supportsProtocols(protocolType, MemberMetadata.plainProtocolSet(protocols) in the caller, so if the group protocol is incompatible, won't we just reject the rejoin?", "url": "https://github.com/apache/kafka/pull/9270#discussion_r492900227", "createdAt": "2020-09-22T17:10:08Z", "author": {"login": "abbccdda"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -1040,21 +1040,36 @@ class GroupCoordinator(val brokerId: Int,\n \n     group.currentState match {\n       case Stable =>\n-        info(s\"Static member joins during Stable stage will not trigger rebalance.\")\n-        group.maybeInvokeJoinCallback(member, JoinGroupResult(\n-          members = List.empty,\n-          memberId = newMemberId,\n-          generationId = group.generationId,\n-          protocolType = group.protocolType,\n-          protocolName = group.protocolName,\n-          // We want to avoid current leader performing trivial assignment while the group\n-          // is in stable stage, because the new assignment in leader's next sync call\n-          // won't be broadcast by a stable group. This could be guaranteed by\n-          // always returning the old leader id so that the current leader won't assume itself\n-          // as a leader based on the returned message, since the new member.id won't match\n-          // returned leader id, therefore no assignment will be performed.\n-          leaderId = currentLeader,\n-          error = Errors.NONE))\n+        // check if group's selectedProtocol of next generation will change, if not, simply store group to persist the\n+        // updated static member, if yes, rebalance should be triggered to let the group's assignment and selectProtocol consistent\n+        val selectedProtocolOfNextGeneration = group.selectProtocol\n+        if (group.protocolName.contains(selectedProtocolOfNextGeneration)) {\n+          info(s\"Static member which joins during Stable stage and doesn't affect selectProtocol will not trigger rebalance.\")\n+          val groupAssignment: Map[String, Array[Byte]] = group.allMemberMetadata.map(member => member.memberId -> member.assignment).toMap\n+          groupManager.storeGroup(group, groupAssignment, error => {\n+            group.inLock {\n+              if (error != Errors.NONE) {\n+                warn(s\"Failed to persist metadata for group ${group.groupId}: ${error.message}\")\n+              }\n+            }\n+          })\n+          group.maybeInvokeJoinCallback(member, JoinGroupResult(\n+            members = List.empty,\n+            memberId = newMemberId,\n+            generationId = group.generationId,\n+            protocolType = group.protocolType,\n+            protocolName = group.protocolName,\n+            // We want to avoid current leader performing trivial assignment while the group\n+            // is in stable stage, because the new assignment in leader's next sync call\n+            // won't be broadcast by a stable group. This could be guaranteed by\n+            // always returning the old leader id so that the current leader won't assume itself\n+            // as a leader based on the returned message, since the new member.id won't match\n+            // returned leader id, therefore no assignment will be performed.\n+            leaderId = currentLeader,\n+            error = Errors.NONE))\n+        } else {\n+          maybePrepareRebalance(group, s\"Group's selectedProtocol will change because static member ${member.memberId} with instance id $groupInstanceId joined with change of protocol\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7466bcd4086646c7e0dfa1906adca42610a6f601"}, "originalPosition": 47}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee2adcec557223c56def176096d88527a629eb9c", "author": {"user": {"login": "feyman2016", "name": null}}, "url": "https://github.com/apache/kafka/commit/ee2adcec557223c56def176096d88527a629eb9c", "committedDate": "2020-09-24T15:47:05Z", "message": "fix format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b743e83192649deb56b772c1d132b7f5b701be1", "author": {"user": {"login": "feyman2016", "name": null}}, "url": "https://github.com/apache/kafka/commit/6b743e83192649deb56b772c1d132b7f5b701be1", "committedDate": "2020-10-15T02:39:01Z", "message": "update persistence failure handling logic"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5NjE3NDc2", "url": "https://github.com/apache/kafka/pull/9270#pullrequestreview-509617476", "createdAt": "2020-10-15T17:37:25Z", "commit": {"oid": "6b743e83192649deb56b772c1d132b7f5b701be1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzozNzoyNlrOHiSzzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzozNzoyNlrOHiSzzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyMTgwNw==", "bodyText": "Seems the helper only gets called once?", "url": "https://github.com/apache/kafka/pull/9270#discussion_r505721807", "createdAt": "2020-10-15T17:37:26Z", "author": {"login": "abbccdda"}, "path": "core/src/test/scala/unit/kafka/coordinator/group/GroupCoordinatorTest.scala", "diffHunk": "@@ -3789,6 +3844,41 @@ class GroupCoordinatorTest {\n                             requireKnownMemberId: Boolean = false): Future[JoinGroupResult] = {\n     val (responseFuture, responseCallback) = setupJoinGroupCallback\n \n+    EasyMock.expect(replicaManager.getMagic(EasyMock.anyObject())).andReturn(Some(RecordBatch.MAGIC_VALUE_V1)).anyTimes()\n+    EasyMock.replay(replicaManager)\n+\n+    groupCoordinator.handleJoinGroup(groupId, memberId, groupInstanceId,\n+      requireKnownMemberId, \"clientId\", \"clientHost\", rebalanceTimeout, sessionTimeout, protocolType, protocols, responseCallback)\n+    responseFuture\n+  }\n+\n+  private def sendStaticJoinGroupWithPersistence(groupId: String,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b743e83192649deb56b772c1d132b7f5b701be1"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEwNTgzNDA0", "url": "https://github.com/apache/kafka/pull/9270#pullrequestreview-510583404", "createdAt": "2020-10-16T15:35:19Z", "commit": {"oid": "6b743e83192649deb56b772c1d132b7f5b701be1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNTozNToyMFrOHjFdXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxNTozNToyMFrOHjFdXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU1MTY0Nw==", "bodyText": "Hey @feyman2016 ,\nI'm still wondering if this block should be inside the callback of storeGroup. Otherwise, we would already have sent the response to the client before the storeGroup completes, and the client will never see the error response on L1058.\nOr did we specifically decide to make the storeGroup call best effort?\n(cc @abbccdda )", "url": "https://github.com/apache/kafka/pull/9270#discussion_r506551647", "createdAt": "2020-10-16T15:35:20Z", "author": {"login": "vvcephei"}, "path": "core/src/main/scala/kafka/coordinator/group/GroupCoordinator.scala", "diffHunk": "@@ -1037,24 +1037,52 @@ class GroupCoordinator(val brokerId: Int,\n \n     val knownStaticMember = group.get(newMemberId)\n     group.updateMember(knownStaticMember, protocols, responseCallback)\n+    val oldProtocols = knownStaticMember.supportedProtocols\n \n     group.currentState match {\n       case Stable =>\n-        info(s\"Static member joins during Stable stage will not trigger rebalance.\")\n-        group.maybeInvokeJoinCallback(member, JoinGroupResult(\n-          members = List.empty,\n-          memberId = newMemberId,\n-          generationId = group.generationId,\n-          protocolType = group.protocolType,\n-          protocolName = group.protocolName,\n-          // We want to avoid current leader performing trivial assignment while the group\n-          // is in stable stage, because the new assignment in leader's next sync call\n-          // won't be broadcast by a stable group. This could be guaranteed by\n-          // always returning the old leader id so that the current leader won't assume itself\n-          // as a leader based on the returned message, since the new member.id won't match\n-          // returned leader id, therefore no assignment will be performed.\n-          leaderId = currentLeader,\n-          error = Errors.NONE))\n+        // check if group's selectedProtocol of next generation will change, if not, simply store group to persist the\n+        // updated static member, if yes, rebalance should be triggered to let the group's assignment and selectProtocol consistent\n+        val selectedProtocolOfNextGeneration = group.selectProtocol\n+        if (group.protocolName.contains(selectedProtocolOfNextGeneration)) {\n+          info(s\"Static member which joins during Stable stage and doesn't affect selectProtocol will not trigger rebalance.\")\n+          val groupAssignment: Map[String, Array[Byte]] = group.allMemberMetadata.map(member => member.memberId -> member.assignment).toMap\n+          groupManager.storeGroup(group, groupAssignment, error => {\n+            if (error != Errors.NONE) {\n+              warn(s\"Failed to persist metadata for group ${group.groupId}: ${error.message}\")\n+\n+              // Failed to persist member.id of the given static member, revert the update of the static member in the group.\n+              group.updateMember(knownStaticMember, oldProtocols, null)\n+              val oldMember = group.replaceGroupInstance(newMemberId, oldMemberId, groupInstanceId)\n+              completeAndScheduleNextHeartbeatExpiration(group, oldMember)\n+              responseCallback(JoinGroupResult(\n+                List.empty,\n+                memberId = JoinGroupRequest.UNKNOWN_MEMBER_ID,\n+                generationId = group.generationId,\n+                protocolType = group.protocolType,\n+                protocolName = group.protocolName,\n+                leaderId = currentLeader,\n+                error = error\n+              ))\n+            }\n+          })\n+          group.maybeInvokeJoinCallback(member, JoinGroupResult(\n+            members = List.empty,\n+            memberId = newMemberId,\n+            generationId = group.generationId,\n+            protocolType = group.protocolType,\n+            protocolName = group.protocolName,\n+            // We want to avoid current leader performing trivial assignment while the group\n+            // is in stable stage, because the new assignment in leader's next sync call\n+            // won't be broadcast by a stable group. This could be guaranteed by\n+            // always returning the old leader id so that the current leader won't assume itself\n+            // as a leader based on the returned message, since the new member.id won't match\n+            // returned leader id, therefore no assignment will be performed.\n+            leaderId = currentLeader,\n+            error = Errors.NONE))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b743e83192649deb56b772c1d132b7f5b701be1"}, "originalPosition": 61}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c982b7dc0797370530f0c9d5c565c6a955d3d46", "author": {"user": {"login": "feyman2016", "name": null}}, "url": "https://github.com/apache/kafka/commit/3c982b7dc0797370530f0c9d5c565c6a955d3d46", "committedDate": "2020-10-20T04:25:31Z", "message": "revise callback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzMDcyNDc3", "url": "https://github.com/apache/kafka/pull/9270#pullrequestreview-513072477", "createdAt": "2020-10-20T19:41:05Z", "commit": {"oid": "3c982b7dc0797370530f0c9d5c565c6a955d3d46"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9f358d6b8eaf14e5d5da232ba7f5ca024f0ef7a", "author": {"user": null}, "url": "https://github.com/apache/kafka/commit/c9f358d6b8eaf14e5d5da232ba7f5ca024f0ef7a", "committedDate": "2020-10-21T15:09:25Z", "message": "Merge remote-tracking branch 'apache/trunk' into KAFKA-10284"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 584, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}