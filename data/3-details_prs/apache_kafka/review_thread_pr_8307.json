{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5NjE0ODM1", "number": 8307, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNDozNzoxMlrODolKHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxOTowMjowMFrODp-7bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzODc4NDMxOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNDozNzoxMlrOF3Nt2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMTozNDoxMlrOF3u3wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ0MDcyOQ==", "bodyText": "fix 3", "url": "https://github.com/apache/kafka/pull/8307#discussion_r393440729", "createdAt": "2020-03-17T04:37:12Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -798,10 +798,12 @@ public void remove(final Collection<TopicPartition> revokedChangelogs) {\n \n         for (final TopicPartition partition : revokedChangelogs) {\n             final ChangelogMetadata changelogMetadata = changelogs.remove(partition);\n-            if (changelogMetadata.state() != ChangelogState.REGISTERED) {\n-                revokedInitializedChangelogs.add(partition);\n+            if (changelogMetadata != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk4MzkzOA==", "bodyText": "Nice catch, this is indeed possible.", "url": "https://github.com/apache/kafka/pull/8307#discussion_r393983938", "createdAt": "2020-03-17T21:34:12Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StoreChangelogReader.java", "diffHunk": "@@ -798,10 +798,12 @@ public void remove(final Collection<TopicPartition> revokedChangelogs) {\n \n         for (final TopicPartition partition : revokedChangelogs) {\n             final ChangelogMetadata changelogMetadata = changelogs.remove(partition);\n-            if (changelogMetadata.state() != ChangelogState.REGISTERED) {\n-                revokedInitializedChangelogs.add(partition);\n+            if (changelogMetadata != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ0MDcyOQ=="}, "originalCommit": null, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzODc4NDQxOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNDozNzoxOVrOF3Nt5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMToyNzozMlrOF3urxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ0MDc0Mw==", "bodyText": "fix 1", "url": "https://github.com/apache/kafka/pull/8307#discussion_r393440743", "createdAt": "2020-03-17T04:37:19Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -179,11 +181,12 @@ private void close(final boolean clean) {\n                 transitionTo(State.CLOSING);\n             }\n \n-            if (state() == State.CLOSING) {\n-                executeAndMaybeSwallow(clean, () -> {\n-                    StateManagerUtil.closeStateManager(log, logPrefix, clean,\n-                        false, stateMgr, stateDirectory, TaskType.STANDBY);\n-                }, \"state manager close\", log);\n+            if (state() == State.CLOSING || state() == State.RESTORING) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk4MDg2OQ==", "bodyText": "Standby task should never be in RESTORING since we always transit from CREATED -> RUNNING -> RESTORING in one call. Did you observe this was not the case from failed system tests? Even in unclean close case you described I did not see why it could be possible..", "url": "https://github.com/apache/kafka/pull/8307#discussion_r393980869", "createdAt": "2020-03-17T21:27:32Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -179,11 +181,12 @@ private void close(final boolean clean) {\n                 transitionTo(State.CLOSING);\n             }\n \n-            if (state() == State.CLOSING) {\n-                executeAndMaybeSwallow(clean, () -> {\n-                    StateManagerUtil.closeStateManager(log, logPrefix, clean,\n-                        false, stateMgr, stateDirectory, TaskType.STANDBY);\n-                }, \"state manager close\", log);\n+            if (state() == State.CLOSING || state() == State.RESTORING) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ0MDc0Mw=="}, "originalCommit": null, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzODc4NDU0OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNDozNzoyNVrOF3Nt_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QyMToyODowNlrOF3us2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ0MDc2NQ==", "bodyText": "fix 2", "url": "https://github.com/apache/kafka/pull/8307#discussion_r393440765", "createdAt": "2020-03-17T04:37:25Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -179,11 +181,12 @@ private void close(final boolean clean) {\n                 transitionTo(State.CLOSING);\n             }\n \n-            if (state() == State.CLOSING) {\n-                executeAndMaybeSwallow(clean, () -> {\n-                    StateManagerUtil.closeStateManager(log, logPrefix, clean,\n-                        false, stateMgr, stateDirectory, TaskType.STANDBY);\n-                }, \"state manager close\", log);\n+            if (state() == State.CLOSING || state() == State.RESTORING) {\n+                // see StreamTask.close() for the explanation\n+                final boolean wipeStateStore = !clean && !eosDisabled;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk4MTE0Ng==", "bodyText": "I think this is what the below TODO (191) was added for, Thanks :) Please feel free to remove that TODO marker then.", "url": "https://github.com/apache/kafka/pull/8307#discussion_r393981146", "createdAt": "2020-03-17T21:28:06Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -179,11 +181,12 @@ private void close(final boolean clean) {\n                 transitionTo(State.CLOSING);\n             }\n \n-            if (state() == State.CLOSING) {\n-                executeAndMaybeSwallow(clean, () -> {\n-                    StateManagerUtil.closeStateManager(log, logPrefix, clean,\n-                        false, stateMgr, stateDirectory, TaskType.STANDBY);\n-                }, \"state manager close\", log);\n+            if (state() == State.CLOSING || state() == State.RESTORING) {\n+                // see StreamTask.close() for the explanation\n+                final boolean wipeStateStore = !clean && !eosDisabled;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ0MDc2NQ=="}, "originalCommit": null, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzQ3NTI1OnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODo1NjoyM1rOF5fwLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODo1NjoyM1rOF5fwLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzMzM4OA==", "bodyText": "Not for this PR: we can clean up the task-manager code to not pass in the checkpoint at all.", "url": "https://github.com/apache/kafka/pull/8307#discussion_r395833388", "createdAt": "2020-03-20T18:56:23Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StandbyTask.java", "diffHunk": "@@ -187,50 +189,41 @@ private void prepareClose(final boolean clean) {\n     @Override\n     public void closeClean(final Map<TopicPartition, Long> checkpoint) {\n         Objects.requireNonNull(checkpoint);\n-        close(true, checkpoint);\n+        close(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f4cfd7503c0959ed2453e88ee9f1c98d280ca71"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzQ4MDAyOnYy", "diffSide": "RIGHT", "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODo1Nzo1NFrOF5fzTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDoxMDo0NVrOF5hz-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNDE4OQ==", "bodyText": "This part will have some conflicts with @mjsax 's PR, just a note.", "url": "https://github.com/apache/kafka/pull/8307#discussion_r395834189", "createdAt": "2020-03-20T18:57:54Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -120,7 +120,7 @@ public StreamTask(final TaskId id,\n \n         this.time = time;\n         this.recordCollector = recordCollector;\n-        eosDisabled = !StreamsConfig.EXACTLY_ONCE.equals(config.getString(StreamsConfig.PROCESSING_GUARANTEE_CONFIG));\n+        eosEnabled = StreamsConfig.EXACTLY_ONCE.equals(config.getString(StreamsConfig.PROCESSING_GUARANTEE_CONFIG));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f4cfd7503c0959ed2453e88ee9f1c98d280ca71"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2NzEzMA==", "bodyText": "Yea, one of us probably needs to rebase", "url": "https://github.com/apache/kafka/pull/8307#discussion_r395867130", "createdAt": "2020-03-20T20:10:45Z", "author": {"login": "abbccdda"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -120,7 +120,7 @@ public StreamTask(final TaskId id,\n \n         this.time = time;\n         this.recordCollector = recordCollector;\n-        eosDisabled = !StreamsConfig.EXACTLY_ONCE.equals(config.getString(StreamsConfig.PROCESSING_GUARANTEE_CONFIG));\n+        eosEnabled = StreamsConfig.EXACTLY_ONCE.equals(config.getString(StreamsConfig.PROCESSING_GUARANTEE_CONFIG));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNDE4OQ=="}, "originalCommit": {"oid": "3f4cfd7503c0959ed2453e88ee9f1c98d280ca71"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzQ5MjMxOnYy", "diffSide": "RIGHT", "path": "streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxOTowMjowMFrOF5f7Sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMDoxMDoyOFrOF5hzcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNjIzNA==", "bodyText": "For my own education: before the fix, this integration test will fail when instance-2 is started?", "url": "https://github.com/apache/kafka/pull/8307#discussion_r395836234", "createdAt": "2020-03-20T19:02:00Z", "author": {"login": "guozhangwang"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.integration;\n+\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.integration.utils.EmbeddedKafkaCluster;\n+import org.apache.kafka.streams.integration.utils.IntegrationTestUtils;\n+import org.apache.kafka.streams.kstream.Consumed;\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.StateDirectory;\n+import org.apache.kafka.streams.state.internals.OffsetCheckpoint;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Properties;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.kafka.test.TestUtils.waitForCondition;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * An integration test to verify the conversion of a dirty-closed EOS\n+ * task towards a standby task is safe across restarts of the application.\n+ */\n+public class StandbyTaskEOSIntegrationTest {\n+\n+    private final String inputTopic = \"input\";\n+\n+    @ClassRule\n+    public static final EmbeddedKafkaCluster CLUSTER = new EmbeddedKafkaCluster(3);\n+\n+    @Before\n+    public void createTopics() throws Exception {\n+        CLUSTER.createTopic(inputTopic, 1, 3);\n+    }\n+\n+    @Test\n+    public void surviveWithOneTaskAsStandby() throws ExecutionException, InterruptedException, IOException {\n+        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n+            inputTopic,\n+            Collections.singletonList(\n+                new KeyValue<>(0, 0)),\n+            TestUtils.producerConfig(\n+                CLUSTER.bootstrapServers(),\n+                IntegerSerializer.class,\n+                IntegerSerializer.class,\n+                new Properties()),\n+            10L);\n+\n+        final String appId = \"eos-test-app\";\n+        final String stateDirPath = TestUtils.tempDirectory(appId).getPath();\n+\n+        final CountDownLatch instanceLatch = new CountDownLatch(1);\n+\n+        final String stateDirPathOne = stateDirPath + \"/\" + appId + \"-1/\";\n+        final KafkaStreams streamInstanceOne =\n+            buildStreamWithDirtyStateDir(appId, stateDirPathOne, instanceLatch);\n+\n+        final String stateDirPathTwo = stateDirPath + \"/\" + appId + \"-2/\";\n+        final KafkaStreams streamInstanceTwo =\n+            buildStreamWithDirtyStateDir(appId, stateDirPathTwo, instanceLatch);\n+\n+        streamInstanceOne.start();\n+\n+        streamInstanceTwo.start();\n+\n+        // Wait for the record to be processed\n+        assertTrue(instanceLatch.await(15, TimeUnit.SECONDS));\n+\n+        waitForCondition(() -> streamInstanceOne.state().equals(KafkaStreams.State.RUNNING),\n+            \"Stream instance one should be up and running by now\");\n+        waitForCondition(() -> streamInstanceTwo.state().equals(KafkaStreams.State.RUNNING),\n+            \"Stream instance one should be up and running by now\");\n+\n+        streamInstanceOne.close(Duration.ofSeconds(30));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f4cfd7503c0959ed2453e88ee9f1c98d280ca71"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg2Njk5Mw==", "bodyText": "Yes, actually either instance-1 or instance-2 would fail, depending on which box gets standby assignment. There would be a IllegalState + NPE exception sequence happening.", "url": "https://github.com/apache/kafka/pull/8307#discussion_r395866993", "createdAt": "2020-03-20T20:10:28Z", "author": {"login": "abbccdda"}, "path": "streams/src/test/java/org/apache/kafka/streams/integration/StandbyTaskEOSIntegrationTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.kafka.streams.integration;\n+\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+import org.apache.kafka.common.TopicPartition;\n+import org.apache.kafka.common.serialization.IntegerSerializer;\n+import org.apache.kafka.common.serialization.Serdes;\n+import org.apache.kafka.common.utils.MockTime;\n+import org.apache.kafka.streams.KafkaStreams;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.StreamsBuilder;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.apache.kafka.streams.integration.utils.EmbeddedKafkaCluster;\n+import org.apache.kafka.streams.integration.utils.IntegrationTestUtils;\n+import org.apache.kafka.streams.kstream.Consumed;\n+import org.apache.kafka.streams.processor.TaskId;\n+import org.apache.kafka.streams.processor.internals.StateDirectory;\n+import org.apache.kafka.streams.state.internals.OffsetCheckpoint;\n+import org.apache.kafka.test.TestUtils;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.Properties;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.kafka.test.TestUtils.waitForCondition;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * An integration test to verify the conversion of a dirty-closed EOS\n+ * task towards a standby task is safe across restarts of the application.\n+ */\n+public class StandbyTaskEOSIntegrationTest {\n+\n+    private final String inputTopic = \"input\";\n+\n+    @ClassRule\n+    public static final EmbeddedKafkaCluster CLUSTER = new EmbeddedKafkaCluster(3);\n+\n+    @Before\n+    public void createTopics() throws Exception {\n+        CLUSTER.createTopic(inputTopic, 1, 3);\n+    }\n+\n+    @Test\n+    public void surviveWithOneTaskAsStandby() throws ExecutionException, InterruptedException, IOException {\n+        IntegrationTestUtils.produceKeyValuesSynchronouslyWithTimestamp(\n+            inputTopic,\n+            Collections.singletonList(\n+                new KeyValue<>(0, 0)),\n+            TestUtils.producerConfig(\n+                CLUSTER.bootstrapServers(),\n+                IntegerSerializer.class,\n+                IntegerSerializer.class,\n+                new Properties()),\n+            10L);\n+\n+        final String appId = \"eos-test-app\";\n+        final String stateDirPath = TestUtils.tempDirectory(appId).getPath();\n+\n+        final CountDownLatch instanceLatch = new CountDownLatch(1);\n+\n+        final String stateDirPathOne = stateDirPath + \"/\" + appId + \"-1/\";\n+        final KafkaStreams streamInstanceOne =\n+            buildStreamWithDirtyStateDir(appId, stateDirPathOne, instanceLatch);\n+\n+        final String stateDirPathTwo = stateDirPath + \"/\" + appId + \"-2/\";\n+        final KafkaStreams streamInstanceTwo =\n+            buildStreamWithDirtyStateDir(appId, stateDirPathTwo, instanceLatch);\n+\n+        streamInstanceOne.start();\n+\n+        streamInstanceTwo.start();\n+\n+        // Wait for the record to be processed\n+        assertTrue(instanceLatch.await(15, TimeUnit.SECONDS));\n+\n+        waitForCondition(() -> streamInstanceOne.state().equals(KafkaStreams.State.RUNNING),\n+            \"Stream instance one should be up and running by now\");\n+        waitForCondition(() -> streamInstanceTwo.state().equals(KafkaStreams.State.RUNNING),\n+            \"Stream instance one should be up and running by now\");\n+\n+        streamInstanceOne.close(Duration.ofSeconds(30));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNjIzNA=="}, "originalCommit": {"oid": "3f4cfd7503c0959ed2453e88ee9f1c98d280ca71"}, "originalPosition": 105}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3346, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}