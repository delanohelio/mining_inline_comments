{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwNTcwNzk4", "number": 8180, "title": "MINOR: Check store directory empty to decide whether throw task corrupted exception with EOS", "bodyText": "Before we register the stores (and hence create the store dirs), we check if the task dir is empty except the lock / checkpoint files. Then later when loading the checkpoint files if we do not find the offsets AND the store dirs are not empty, meaning that the stores may be not empty, we treat it as task corrupted.\nCommitter Checklist (excluded from commit message)\n\n Verify design and implementation\n Verify test coverage and CI build status\n Verify documentation (including upgrade notes)", "createdAt": "2020-02-27T00:11:49Z", "url": "https://github.com/apache/kafka/pull/8180", "merged": true, "mergeCommit": {"oid": "d3c067f35d184ca75e8cc59bedd56689cbc8269b"}, "closed": true, "closedAt": "2020-03-06T23:38:56Z", "author": {"login": "guozhangwang"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIP4HqgH2gAyMzgwNTcwNzk4OmVmNmQxMTE1ZWIxMWMyNmE3ZjE0ZmRhOWQ3MTRhNGNkNDI5N2RjOTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcLI1wEAH2gAyMzgwNTcwNzk4OmQxYmVhMTcwYmJiZjIwOWFkMjBlNTQ5M2FlODMyZmQyNDdlYmZjM2Q=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ef6d1115eb11c26a7f14fda9d714a4cd4297dc95", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/ef6d1115eb11c26a7f14fda9d714a4cd4297dc95", "committedDate": "2020-02-27T00:07:21Z", "message": "the TODO is actually not needed"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzM1MzQ5", "url": "https://github.com/apache/kafka/pull/8180#pullrequestreview-365335349", "createdAt": "2020-02-27T00:12:36Z", "commit": {"oid": "ef6d1115eb11c26a7f14fda9d714a4cd4297dc95"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDoxMjozNlrOFvA_hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMDoxMjozNlrOFvA_hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0MzY1Mg==", "bodyText": "Here I just re-arranged the parameter orders and below I use the log-prefix from the log-context rather than creating a new string, no critical changes here.", "url": "https://github.com/apache/kafka/pull/8180#discussion_r384843652", "createdAt": "2020-02-27T00:12:36Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorStateManager.java", "diffHunk": "@@ -161,19 +161,19 @@ public static String storeChangelogTopic(final String applicationId,\n      * @throws ProcessorStateException if the task directory does not exist and could not be created\n      */\n     public ProcessorStateManager(final TaskId taskId,\n-                                 final Collection<TopicPartition> sources,\n                                  final TaskType taskType,\n+                                 final LogContext logContext,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef6d1115eb11c26a7f14fda9d714a4cd4297dc95"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzM1NDAw", "url": "https://github.com/apache/kafka/pull/8180#pullrequestreview-365335400", "createdAt": "2020-02-27T00:12:45Z", "commit": {"oid": "ef6d1115eb11c26a7f14fda9d714a4cd4297dc95"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MDUwODMw", "url": "https://github.com/apache/kafka/pull/8180#pullrequestreview-366050830", "createdAt": "2020-02-27T22:39:02Z", "commit": {"oid": "ef6d1115eb11c26a7f14fda9d714a4cd4297dc95"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMjozOTowM1rOFvju7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMjozOTowM1rOFvju7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxMjg0Ng==", "bodyText": "If I understand this reasoning, it's predicated on the previous run doing something during shutdown. I'm not sure we can rely on any such assumptions. For example, what if the previous run got kill -9ed instead of requested to shutdown? What if that happened during a normal shutdown? What if the machine crashed, the filesystem got corrupted, and fsck replayed the journal to an arbitrary state during recovery?\nI think that we used to delete the checkpoint file as soon as we started processing under EOS, but I can't find that anymore in the code. Is that still the case? If that were true, then this assumption I'm concerned about wouldn't apply, since the checkpoint file wouldn't exist unless it were consistent with the store.", "url": "https://github.com/apache/kafka/pull/8180#discussion_r385412846", "createdAt": "2020-02-27T22:39:03Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorStateManager.java", "diffHunk": "@@ -211,7 +211,15 @@ void initializeStoreOffsetsFromCheckpoint() {\n                         log.debug(\"State store {} initialized from checkpoint with offset {} at changelog {}\",\n                             store.stateStore.name(), store.offset, store.changelogPartition);\n                     } else {\n-                        // TODO K9113: for EOS when there's no checkpointed offset, we should treat it as TaskCorrupted\n+                        // with EOS, if the previous run did not shutdown gracefully, we would always close\n+                        // all tasks as dirty before complete the shutdown which will already wipe out the local\n+                        // stores including the checkpoint store. That means, here if the checkpoint file does not\n+                        // contain the corresponding offset, there are only two possibilities:\n+                        //\n+                        // 1. the local state store is also empty, in which case it is safe to restore from scratch.\n+                        // 2. the local state store is not empty but it only contains committed records (i.e. only\n+                        //    the checkpoint file when corrupted), in which case it is safe to restore and overwrite\n+                        //    from scratch too.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef6d1115eb11c26a7f14fda9d714a4cd4297dc95"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NjUzNTAz", "url": "https://github.com/apache/kafka/pull/8180#pullrequestreview-366653503", "createdAt": "2020-02-28T20:04:20Z", "commit": {"oid": "ef6d1115eb11c26a7f14fda9d714a4cd4297dc95"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMDowNDoyMFrOFwBUfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMDowNDoyMFrOFwBUfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NzU5Ng==", "bodyText": "Thanks @guozhangwang ,\nIn that case, I'm not understanding the above comment. It says that if the previous shutdown didn't complete gracefully, then we'd delete the store and checkpoint file, but it sounds like in actuality, the checkpoint file wouldn't exist at all in that case, and therefore not be \"deleted\" on unclean shutdown. In fact, the two conclusions you listed seem to follow from what I just said, so maybe it's just the first part of the comment that I found confusing.\nCarry on :)", "url": "https://github.com/apache/kafka/pull/8180#discussion_r385897596", "createdAt": "2020-02-28T20:04:20Z", "author": {"login": "vvcephei"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/ProcessorStateManager.java", "diffHunk": "@@ -211,7 +211,15 @@ void initializeStoreOffsetsFromCheckpoint() {\n                         log.debug(\"State store {} initialized from checkpoint with offset {} at changelog {}\",\n                             store.stateStore.name(), store.offset, store.changelogPartition);\n                     } else {\n-                        // TODO K9113: for EOS when there's no checkpointed offset, we should treat it as TaskCorrupted\n+                        // with EOS, if the previous run did not shutdown gracefully, we would always close\n+                        // all tasks as dirty before complete the shutdown which will already wipe out the local\n+                        // stores including the checkpoint store. That means, here if the checkpoint file does not\n+                        // contain the corresponding offset, there are only two possibilities:\n+                        //\n+                        // 1. the local state store is also empty, in which case it is safe to restore from scratch.\n+                        // 2. the local state store is not empty but it only contains committed records (i.e. only\n+                        //    the checkpoint file when corrupted), in which case it is safe to restore and overwrite\n+                        //    from scratch too.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxMjg0Ng=="}, "originalCommit": {"oid": "ef6d1115eb11c26a7f14fda9d714a4cd4297dc95"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7d8c783b8f5de108d8493841cba002c954eecee", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/f7d8c783b8f5de108d8493841cba002c954eecee", "committedDate": "2020-02-28T22:21:48Z", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into KMinor-eos-task-corrupted"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MjI0NDA3", "url": "https://github.com/apache/kafka/pull/8180#pullrequestreview-368224407", "createdAt": "2020-03-03T18:35:21Z", "commit": {"oid": "ef6d1115eb11c26a7f14fda9d714a4cd4297dc95"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29614dc0b5cc6dad4478557460db041cc9d2e4e5", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/29614dc0b5cc6dad4478557460db041cc9d2e4e5", "committedDate": "2020-03-04T00:05:15Z", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into KMinor-eos-task-corrupted"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46b136544d154e25e512b9849d0dcb9e04005163", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/46b136544d154e25e512b9849d0dcb9e04005163", "committedDate": "2020-03-04T16:54:58Z", "message": "add back eosEnabled flag"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "123a28cda8172d327aeb0adea974692286daee34", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/123a28cda8172d327aeb0adea974692286daee34", "committedDate": "2020-03-05T02:14:24Z", "message": "rebase from trunk"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2502956d38a7762c497e5523833bde763a809afe", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/2502956d38a7762c497e5523833bde763a809afe", "committedDate": "2020-03-06T00:22:34Z", "message": "rebase from trunk"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d277f630ce166a318fb83f039763887a32ea5520", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/d277f630ce166a318fb83f039763887a32ea5520", "committedDate": "2020-03-06T17:33:28Z", "message": "revert the change to check empty store dirs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNTA1NjI5", "url": "https://github.com/apache/kafka/pull/8180#pullrequestreview-370505629", "createdAt": "2020-03-06T17:39:23Z", "commit": {"oid": "d277f630ce166a318fb83f039763887a32ea5520"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzozOToyM1rOFzBedw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNzo0MDo1MFrOFzBiIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0NTg3OQ==", "bodyText": "This is an improvement I want to add along with the PR: since we delete the checkpoint file after completed loading, and before we initialize to RESTORING if there's an exception we could lose that checkpoint. So here in Restoring / Created state upon closing I also added the checkpoint logic here.", "url": "https://github.com/apache/kafka/pull/8180#discussion_r389045879", "createdAt": "2020-03-06T17:39:23Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -413,48 +413,50 @@ public void closeDirty() {\n      */\n     private void close(final boolean clean) {\n         if (state() == State.CREATED) {\n-            // the task is created and not initialized, do nothing\n-            transitionTo(State.CLOSING);\n-        } else {\n-            if (state() == State.RUNNING) {\n-                closeTopology(clean);\n+            // the task is created and not initialized, just re-write the checkpoint file\n+            executeAndMaybeSwallow(clean, () -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d277f630ce166a318fb83f039763887a32ea5520"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0NjgxOA==", "bodyText": "We could have added the stores, but then before transiting to RESTORING an exception happens; hence here I always call closeStateManager which would just be an no-op if the lock is not grabbed / stores not added.", "url": "https://github.com/apache/kafka/pull/8180#discussion_r389046818", "createdAt": "2020-03-06T17:40:50Z", "author": {"login": "guozhangwang"}, "path": "streams/src/main/java/org/apache/kafka/streams/processor/internals/StreamTask.java", "diffHunk": "@@ -413,48 +413,50 @@ public void closeDirty() {\n      */\n     private void close(final boolean clean) {\n         if (state() == State.CREATED) {\n-            // the task is created and not initialized, do nothing\n-            transitionTo(State.CLOSING);\n-        } else {\n-            if (state() == State.RUNNING) {\n-                closeTopology(clean);\n+            // the task is created and not initialized, just re-write the checkpoint file\n+            executeAndMaybeSwallow(clean, () -> {\n+                stateMgr.checkpoint(Collections.emptyMap());\n+            }, \"state manager checkpoint\");\n \n-                if (clean) {\n-                    commitState();\n-                    // whenever we have successfully committed state, it is safe to checkpoint\n-                    // the state as well no matter if EOS is enabled or not\n-                    stateMgr.checkpoint(checkpointableOffsets());\n-                } else {\n-                    executeAndMaybeSwallow(false, stateMgr::flush, \"state manager flush\");\n-                }\n+            transitionTo(State.CLOSING);\n+        } else if (state() == State.RUNNING) {\n+            closeTopology(clean);\n \n-                transitionTo(State.CLOSING);\n-            } else if (state() == State.RESTORING) {\n-                executeAndMaybeSwallow(clean, () -> {\n-                    stateMgr.flush();\n-                    stateMgr.checkpoint(Collections.emptyMap());\n-                }, \"state manager flush and checkpoint\");\n-\n-                transitionTo(State.CLOSING);\n-            } else if (state() == State.SUSPENDED) {\n-                // do not need to commit / checkpoint, since when suspending we've already committed the state\n-                transitionTo(State.CLOSING);\n+            if (clean) {\n+                commitState();\n+                // whenever we have successfully committed state, it is safe to checkpoint\n+                // the state as well no matter if EOS is enabled or not\n+                stateMgr.checkpoint(checkpointableOffsets());\n+            } else {\n+                executeAndMaybeSwallow(false, stateMgr::flush, \"state manager flush\");\n             }\n \n-            if (state() == State.CLOSING) {\n-                // if EOS is enabled, we wipe out the whole state store for unclean close\n-                // since they are invalid to use anymore\n-                final boolean wipeStateStore = !clean && !eosDisabled;\n+            transitionTo(State.CLOSING);\n+        } else if (state() == State.RESTORING) {\n+            executeAndMaybeSwallow(clean, () -> {\n+                stateMgr.flush();\n+                stateMgr.checkpoint(Collections.emptyMap());\n+            }, \"state manager flush and checkpoint\");\n \n-                // first close state manager (which is idempotent) then close the record collector (which could throw),\n-                // if the latter throws and we re-close dirty which would close the state manager again.\n-                StateManagerUtil.closeStateManager(log, logPrefix, clean,\n-                    wipeStateStore, stateMgr, stateDirectory, TaskType.ACTIVE);\n+            transitionTo(State.CLOSING);\n+        } else if (state() == State.SUSPENDED) {\n+            // do not need to commit / checkpoint, since when suspending we've already committed the state\n+            transitionTo(State.CLOSING);\n+        }\n \n-                executeAndMaybeSwallow(clean, recordCollector::close, \"record collector close\");\n-            } else {\n-                throw new IllegalStateException(\"Illegal state \" + state() + \" while closing active task \" + id);\n-            }\n+        if (state() == State.CLOSING) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d277f630ce166a318fb83f039763887a32ea5520"}, "originalPosition": 71}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8057d8ea5f095a30fea81ad05789dbbfda044344", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/8057d8ea5f095a30fea81ad05789dbbfda044344", "committedDate": "2020-03-06T17:43:56Z", "message": "nit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24ada914ec418815f4608e50bbe052db2b38a128", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/24ada914ec418815f4608e50bbe052db2b38a128", "committedDate": "2020-03-06T21:55:07Z", "message": "Merge branch 'trunk' of https://github.com/apache/kafka into KMinor-eos-task-corrupted"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNjU0NDcz", "url": "https://github.com/apache/kafka/pull/8180#pullrequestreview-370654473", "createdAt": "2020-03-06T22:03:25Z", "commit": {"oid": "8057d8ea5f095a30fea81ad05789dbbfda044344"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "59ebd0d40ac5069f9dc1a4f1ccdbc52485595fc8", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/59ebd0d40ac5069f9dc1a4f1ccdbc52485595fc8", "committedDate": "2020-03-06T23:12:27Z", "message": "add more unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNjg2Mzg2", "url": "https://github.com/apache/kafka/pull/8180#pullrequestreview-370686386", "createdAt": "2020-03-06T23:30:45Z", "commit": {"oid": "59ebd0d40ac5069f9dc1a4f1ccdbc52485595fc8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1bea170bbbf209ad20e5493ae832fd247ebfc3d", "author": {"user": {"login": "guozhangwang", "name": "Guozhang Wang"}}, "url": "https://github.com/apache/kafka/commit/d1bea170bbbf209ad20e5493ae832fd247ebfc3d", "committedDate": "2020-03-06T23:37:12Z", "message": "checkstyle"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1598, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}