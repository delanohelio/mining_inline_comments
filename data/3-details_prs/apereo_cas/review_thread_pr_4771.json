{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyNTgyNTUw", "number": 4771, "reviewThreads": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNzo1NDo0MFrODqrUWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwODoxNzoxN1rODsj3vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDc2NTA1OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/validator/token/OAuth20RevocationRequestValidator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNzo1NDo0MFrOF6kZdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNzo1NDo0MFrOF6kZdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk1ODA2OQ==", "bodyText": "Include the client-id in the log message please", "url": "https://github.com/apereo/cas/pull/4771#discussion_r396958069", "createdAt": "2020-03-24T07:54:40Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/validator/token/OAuth20RevocationRequestValidator.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package org.apereo.cas.support.oauth.validator.token;\n+\n+import org.apereo.cas.services.ServicesManager;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.springframework.core.Ordered;\n+\n+/**\n+ * This is {@link OAuth20RevocationRequestValidator}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@RequiredArgsConstructor\n+@Slf4j\n+@Getter\n+@Setter\n+public class OAuth20RevocationRequestValidator implements OAuth20TokenRequestValidator {\n+    private final ServicesManager servicesManager;\n+\n+    private int order = Ordered.LOWEST_PRECEDENCE;\n+\n+    @Override\n+    public boolean validate(final JEEContext context) {\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = OAuth20Utils.getRegisteredOAuthServiceByClientId(this.servicesManager, clientId);\n+\n+        if (registeredService == null) {\n+            LOGGER.warn(\"Provided client id cannot be matched against a service definition\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDc2OTQ5OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNzo1NjoxOFrOF6kcRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMzozMjozOVrOF7G8qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk1ODc4OA==", "bodyText": "Missing \"?\".\nAlso, it's best to describe exactly what a \"public\" client is, since the implementation here does not visibly provide a clue API-wise. Something as simple as, a \"public client is one that does not define a secret\", etc.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r396958788", "createdAt": "2020-03-24T07:56:18Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "diffHunk": "@@ -48,6 +54,32 @@ public boolean preHandle(final HttpServletRequest request, final HttpServletResp\n         return !isAuthorizationRequest(request, response) || requiresAuthenticationAuthorizeInterceptor.preHandle(request, response, handler);\n     }\n \n+    /**\n+    * Is the client requesting is a OAuth \"public\" client.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNDEzNg==", "bodyText": "Done", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397524136", "createdAt": "2020-03-24T23:32:39Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "diffHunk": "@@ -48,6 +54,32 @@ public boolean preHandle(final HttpServletRequest request, final HttpServletResp\n         return !isAuthorizationRequest(request, response) || requiresAuthenticationAuthorizeInterceptor.preHandle(request, response, handler);\n     }\n \n+    /**\n+    * Is the client requesting is a OAuth \"public\" client.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk1ODc4OA=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDc2OTg0OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNzo1NjoyNlrOF6kcfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMzo0MDo0MVrOF7HHZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk1ODg0Nw==", "bodyText": "StringUtils.isNotBlank()", "url": "https://github.com/apereo/cas/pull/4771#discussion_r396958847", "createdAt": "2020-03-24T07:56:26Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "diffHunk": "@@ -48,6 +54,32 @@ public boolean preHandle(final HttpServletRequest request, final HttpServletResp\n         return !isAuthorizationRequest(request, response) || requiresAuthenticationAuthorizeInterceptor.preHandle(request, response, handler);\n     }\n \n+    /**\n+    * Is the client requesting is a OAuth \"public\" client.\n+    * @param request the request\n+    * @param response the response\n+    * @return the boolean\n+    */\n+    protected boolean clientNeedAuthentication(final HttpServletRequest request, final HttpServletResponse response) {\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(new JEEContext(request, response)).getLeft();\n+        val registeredService = OAuth20Utils.getRegisteredOAuthServiceByClientId(servicesManager, clientId);\n+        if (clientId.isEmpty() || registeredService == null) {\n+            return true;\n+        }\n+        return !StringUtils.isBlank(registeredService.getClientSecret());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNjg4Ng==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397526886", "createdAt": "2020-03-24T23:40:41Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "diffHunk": "@@ -48,6 +54,32 @@ public boolean preHandle(final HttpServletRequest request, final HttpServletResp\n         return !isAuthorizationRequest(request, response) || requiresAuthenticationAuthorizeInterceptor.preHandle(request, response, handler);\n     }\n \n+    /**\n+    * Is the client requesting is a OAuth \"public\" client.\n+    * @param request the request\n+    * @param response the response\n+    * @return the boolean\n+    */\n+    protected boolean clientNeedAuthentication(final HttpServletRequest request, final HttpServletResponse response) {\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(new JEEContext(request, response)).getLeft();\n+        val registeredService = OAuth20Utils.getRegisteredOAuthServiceByClientId(servicesManager, clientId);\n+        if (clientId.isEmpty() || registeredService == null) {\n+            return true;\n+        }\n+        return !StringUtils.isBlank(registeredService.getClientSecret());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk1ODg0Nw=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDc3MTg3OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNzo1NzowOFrOF6kduQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMzozMjo1NFrOF7G89g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk1OTE2MQ==", "bodyText": "Unnecessary else here.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r396959161", "createdAt": "2020-03-24T07:57:08Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "diffHunk": "@@ -84,7 +116,11 @@ protected boolean isDeviceTokenRequest(final HttpServletRequest request, final H\n      */\n     protected boolean requestRequiresAuthentication(final HttpServletRequest request, final HttpServletResponse response) {\n         val accessTokenRequest = isAccessTokenRequest(request, response);\n-        if (!accessTokenRequest) {\n+        val revokeTokenRequest = isRevokeTokenRequest(request, response);\n+\n+        if (revokeTokenRequest) {\n+            return clientNeedAuthentication(request, response);\n+        } else if (!accessTokenRequest) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNDIxNA==", "bodyText": "Done", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397524214", "createdAt": "2020-03-24T23:32:54Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "diffHunk": "@@ -84,7 +116,11 @@ protected boolean isDeviceTokenRequest(final HttpServletRequest request, final H\n      */\n     protected boolean requestRequiresAuthentication(final HttpServletRequest request, final HttpServletResponse response) {\n         val accessTokenRequest = isAccessTokenRequest(request, response);\n-        if (!accessTokenRequest) {\n+        val revokeTokenRequest = isRevokeTokenRequest(request, response);\n+\n+        if (revokeTokenRequest) {\n+            return clientNeedAuthentication(request, response);\n+        } else if (!accessTokenRequest) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk1OTE2MQ=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDc3MzE4OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNzo1Nzo0MFrOF6kepw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNDo1MzozOFrOF9SYow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk1OTM5OQ==", "bodyText": "How and what is the session store created with new JEEContext(request, response)?", "url": "https://github.com/apereo/cas/pull/4771#discussion_r396959399", "createdAt": "2020-03-24T07:57:40Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "diffHunk": "@@ -48,6 +54,32 @@ public boolean preHandle(final HttpServletRequest request, final HttpServletResp\n         return !isAuthorizationRequest(request, response) || requiresAuthenticationAuthorizeInterceptor.preHandle(request, response, handler);\n     }\n \n+    /**\n+    * Is the client requesting is a OAuth \"public\" client.\n+    * @param request the request\n+    * @param response the response\n+    * @return the boolean\n+    */\n+    protected boolean clientNeedAuthentication(final HttpServletRequest request, final HttpServletResponse response) {\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(new JEEContext(request, response)).getLeft();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2MTg4OA==", "bodyText": "Need it to get the clientId with client_secret_basic or client_secret_post. I used getClientIdAndClientSecret to avoir duplicated code. Any other way exists ?", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397461888", "createdAt": "2020-03-24T21:08:13Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "diffHunk": "@@ -48,6 +54,32 @@ public boolean preHandle(final HttpServletRequest request, final HttpServletResp\n         return !isAuthorizationRequest(request, response) || requiresAuthenticationAuthorizeInterceptor.preHandle(request, response, handler);\n     }\n \n+    /**\n+    * Is the client requesting is a OAuth \"public\" client.\n+    * @param request the request\n+    * @param response the response\n+    * @return the boolean\n+    */\n+    protected boolean clientNeedAuthentication(final HttpServletRequest request, final HttpServletResponse response) {\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(new JEEContext(request, response)).getLeft();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk1OTM5OQ=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzYzMTk0OQ==", "bodyText": "Sorry, let me clarify.\nWhen you use new JEEContext(request, response), there is a session-store used inside a JEEContext by default and that store is not one used or created by CAS. Is the session-store inside JEEContext used anywhere? Should JEEContext use the session-store that is created and used by CAS?\nThe CAS session-store is either one that is based on J2E or one that is distributed based on the ticket-registry, depending on configuration.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397631949", "createdAt": "2020-03-25T06:27:18Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "diffHunk": "@@ -48,6 +54,32 @@ public boolean preHandle(final HttpServletRequest request, final HttpServletResp\n         return !isAuthorizationRequest(request, response) || requiresAuthenticationAuthorizeInterceptor.preHandle(request, response, handler);\n     }\n \n+    /**\n+    * Is the client requesting is a OAuth \"public\" client.\n+    * @param request the request\n+    * @param response the response\n+    * @return the boolean\n+    */\n+    protected boolean clientNeedAuthentication(final HttpServletRequest request, final HttpServletResponse response) {\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(new JEEContext(request, response)).getLeft();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk1OTM5OQ=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgwODY3NQ==", "bodyText": "Ok, got it. Sorry.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r399808675", "createdAt": "2020-03-29T14:53:38Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "diffHunk": "@@ -48,6 +54,32 @@ public boolean preHandle(final HttpServletRequest request, final HttpServletResp\n         return !isAuthorizationRequest(request, response) || requiresAuthenticationAuthorizeInterceptor.preHandle(request, response, handler);\n     }\n \n+    /**\n+    * Is the client requesting is a OAuth \"public\" client.\n+    * @param request the request\n+    * @param response the response\n+    * @return the boolean\n+    */\n+    protected boolean clientNeedAuthentication(final HttpServletRequest request, final HttpServletResponse response) {\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(new JEEContext(request, response)).getLeft();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk1OTM5OQ=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDc3NDc2OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNzo1ODowOFrOF6kfoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMTowOToxM1rOF7DLmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk1OTY0OA==", "bodyText": "Add ? at the end of all question-like statements.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r396959648", "createdAt": "2020-03-24T07:58:08Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "diffHunk": "@@ -48,6 +54,32 @@ public boolean preHandle(final HttpServletRequest request, final HttpServletResp\n         return !isAuthorizationRequest(request, response) || requiresAuthenticationAuthorizeInterceptor.preHandle(request, response, handler);\n     }\n \n+    /**\n+    * Is the client requesting is a OAuth \"public\" client.\n+    * @param request the request\n+    * @param response the response\n+    * @return the boolean\n+    */\n+    protected boolean clientNeedAuthentication(final HttpServletRequest request, final HttpServletResponse response) {\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(new JEEContext(request, response)).getLeft();\n+        val registeredService = OAuth20Utils.getRegisteredOAuthServiceByClientId(servicesManager, clientId);\n+        if (clientId.isEmpty() || registeredService == null) {\n+            return true;\n+        }\n+        return !StringUtils.isBlank(registeredService.getClientSecret());\n+    }\n+\n+    /**\n+     * Is revoke token request request.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2MjQyNA==", "bodyText": "Even on the methods that I didn't created?", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397462424", "createdAt": "2020-03-24T21:09:13Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "diffHunk": "@@ -48,6 +54,32 @@ public boolean preHandle(final HttpServletRequest request, final HttpServletResp\n         return !isAuthorizationRequest(request, response) || requiresAuthenticationAuthorizeInterceptor.preHandle(request, response, handler);\n     }\n \n+    /**\n+    * Is the client requesting is a OAuth \"public\" client.\n+    * @param request the request\n+    * @param response the response\n+    * @return the boolean\n+    */\n+    protected boolean clientNeedAuthentication(final HttpServletRequest request, final HttpServletResponse response) {\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(new JEEContext(request, response)).getLeft();\n+        val registeredService = OAuth20Utils.getRegisteredOAuthServiceByClientId(servicesManager, clientId);\n+        if (clientId.isEmpty() || registeredService == null) {\n+            return true;\n+        }\n+        return !StringUtils.isBlank(registeredService.getClientSecret());\n+    }\n+\n+    /**\n+     * Is revoke token request request.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk1OTY0OA=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDc3ODA0OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNzo1OToxMVrOF6khnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMzozNTo0NlrOF7HBBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MDE1Nw==", "bodyText": "doesServiceNeedAuthentication()", "url": "https://github.com/apereo/cas/pull/4771#discussion_r396960157", "createdAt": "2020-03-24T07:59:11Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNTI1NQ==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397525255", "createdAt": "2020-03-24T23:35:46Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MDE1Nw=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDc4MDI5OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNzo1OTo1M1rOF6ki9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMzozNjoxMFrOF7HBnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MDUwMA==", "bodyText": "Not sure what isAsupportedTokenType is?", "url": "https://github.com/apereo/cas/pull/4771#discussion_r396960500", "createdAt": "2020-03-24T07:59:53Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2MzU3OQ==", "bodyText": "Either a refreshToken or a AccessToken. Main goal is to avoid to process requests on unsupported token types (code etc...) or on invalid token id.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397463579", "createdAt": "2020-03-24T21:11:25Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MDUwMA=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNTQwNw==", "bodyText": "Or to revoke a OAuth Code etc.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397525407", "createdAt": "2020-03-24T23:36:10Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MDUwMA=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDc4MzE4OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODowMDo0OFrOF6kkpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMzozNjoxOVrOF7HByA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MDkzMw==", "bodyText": "Rename to clientId, and mark method as protected.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r396960933", "createdAt": "2020-03-24T08:00:48Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {\n+            return generateRevocationResponse(token, clientId, response);\n+        }\n+        return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param client the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    private ModelAndView generateRevocationResponse(final String token,\n+                                                    final String client,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNTQ0OA==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397525448", "createdAt": "2020-03-24T23:36:19Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {\n+            return generateRevocationResponse(token, clientId, response);\n+        }\n+        return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param client the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    private ModelAndView generateRevocationResponse(final String token,\n+                                                    final String client,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MDkzMw=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDc4NTc2OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODowMTozNVrOF6kmNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMzozNjo0N1rOF7HCgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MTMzNQ==", "bodyText": "This sort of thing can never pass. Comparing ticket ids by prefixes is generally a malpractice and should be avoided.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r396961335", "createdAt": "2020-03-24T08:01:35Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {\n+            return generateRevocationResponse(token, clientId, response);\n+        }\n+        return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param client the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    private ModelAndView generateRevocationResponse(final String token,\n+                                                    final String client,\n+                                                    final HttpServletResponse response) {\n+\n+        if (token.startsWith(OAuth20RefreshToken.PREFIX)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2MzkwMw==", "bodyText": "Ok, sorry about that.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397463903", "createdAt": "2020-03-24T21:11:58Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {\n+            return generateRevocationResponse(token, clientId, response);\n+        }\n+        return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param client the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    private ModelAndView generateRevocationResponse(final String token,\n+                                                    final String client,\n+                                                    final HttpServletResponse response) {\n+\n+        if (token.startsWith(OAuth20RefreshToken.PREFIX)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MTMzNQ=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNTYzMw==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397525633", "createdAt": "2020-03-24T23:36:47Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {\n+            return generateRevocationResponse(token, clientId, response);\n+        }\n+        return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param client the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    private ModelAndView generateRevocationResponse(final String token,\n+                                                    final String client,\n+                                                    final HttpServletResponse response) {\n+\n+        if (token.startsWith(OAuth20RefreshToken.PREFIX)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MTMzNQ=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDc4ODgxOnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODowMjo0MFrOF6koNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODowMjo0MFrOF6koNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MTg0Nw==", "bodyText": "Switch type to OAuth20Token instead.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r396961847", "createdAt": "2020-03-24T08:02:40Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {\n+            return generateRevocationResponse(token, clientId, response);\n+        }\n+        return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param client the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    private ModelAndView generateRevocationResponse(final String token,\n+                                                    final String client,\n+                                                    final HttpServletResponse response) {\n+\n+        if (token.startsWith(OAuth20RefreshToken.PREFIX)) {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20RefreshToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        } else {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20AccessToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        }\n+\n+        val mv = new ModelAndView(new MappingJackson2JsonView());\n+        mv.setStatus(HttpStatus.OK);\n+        return mv;\n+    }\n+\n+    /**\n+     * Revoke the provided Refresh Token and it's related Access Tokens.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final OAuth20RefreshToken token) {\n+        LOGGER.debug(\"Revoking token [{}]\", token);\n+        getOAuthConfigurationContext().getTicketRegistry().deleteTicket(token);\n+\n+        token.getAccessTokens().forEach(item-> {\n+            LOGGER.debug(\"Revoking Access Token [{}] related to Refresh Token [{}]\", item, token);\n+            getOAuthConfigurationContext().getTicketRegistry().deleteTicket(item);\n+        });\n+    }\n+\n+    /**\n+     * Revoke the provided Access Token.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final OAuth20AccessToken token) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDc4OTQ2OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODowMjo1M1rOF6kolw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMzozNzoxOVrOF7HDTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MTk0Mw==", "bodyText": "Remove log line, Call revokeToken instead in a lambda to avoid duplicate code.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r396961943", "createdAt": "2020-03-24T08:02:53Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {\n+            return generateRevocationResponse(token, clientId, response);\n+        }\n+        return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param client the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    private ModelAndView generateRevocationResponse(final String token,\n+                                                    final String client,\n+                                                    final HttpServletResponse response) {\n+\n+        if (token.startsWith(OAuth20RefreshToken.PREFIX)) {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20RefreshToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        } else {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20AccessToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        }\n+\n+        val mv = new ModelAndView(new MappingJackson2JsonView());\n+        mv.setStatus(HttpStatus.OK);\n+        return mv;\n+    }\n+\n+    /**\n+     * Revoke the provided Refresh Token and it's related Access Tokens.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final OAuth20RefreshToken token) {\n+        LOGGER.debug(\"Revoking token [{}]\", token);\n+        getOAuthConfigurationContext().getTicketRegistry().deleteTicket(token);\n+\n+        token.getAccessTokens().forEach(item-> {\n+            LOGGER.debug(\"Revoking Access Token [{}] related to Refresh Token [{}]\", item, token);\n+            getOAuthConfigurationContext().getTicketRegistry().deleteTicket(item);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNTgzNw==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397525837", "createdAt": "2020-03-24T23:37:19Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {\n+            return generateRevocationResponse(token, clientId, response);\n+        }\n+        return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param client the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    private ModelAndView generateRevocationResponse(final String token,\n+                                                    final String client,\n+                                                    final HttpServletResponse response) {\n+\n+        if (token.startsWith(OAuth20RefreshToken.PREFIX)) {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20RefreshToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        } else {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20AccessToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        }\n+\n+        val mv = new ModelAndView(new MappingJackson2JsonView());\n+        mv.setStatus(HttpStatus.OK);\n+        return mv;\n+    }\n+\n+    /**\n+     * Revoke the provided Refresh Token and it's related Access Tokens.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final OAuth20RefreshToken token) {\n+        LOGGER.debug(\"Revoking token [{}]\", token);\n+        getOAuthConfigurationContext().getTicketRegistry().deleteTicket(token);\n+\n+        token.getAccessTokens().forEach(item-> {\n+            LOGGER.debug(\"Revoking Access Token [{}] related to Refresh Token [{}]\", item, token);\n+            getOAuthConfigurationContext().getTicketRegistry().deleteTicket(item);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MTk0Mw=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDc5MTk1OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODowMzo0MVrOF6kqFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMzo0MDoyNlrOF7HHAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MjMyNQ==", "bodyText": "All of this is duplicate code. You should simply fetch OAuth20Token from the registry as the type, and then attempt to cast where necessary to the right type.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r396962325", "createdAt": "2020-03-24T08:03:41Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {\n+            return generateRevocationResponse(token, clientId, response);\n+        }\n+        return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param client the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    private ModelAndView generateRevocationResponse(final String token,\n+                                                    final String client,\n+                                                    final HttpServletResponse response) {\n+\n+        if (token.startsWith(OAuth20RefreshToken.PREFIX)) {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20RefreshToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        } else {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20AccessToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNjcwOQ==", "bodyText": "Sorry about that...\nI'm still beginning with Java and still not comfortable with some of it's concepts... Hopefully work on CAS helped me a lot and still does ! :)", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397526709", "createdAt": "2020-03-24T23:40:10Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {\n+            return generateRevocationResponse(token, clientId, response);\n+        }\n+        return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param client the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    private ModelAndView generateRevocationResponse(final String token,\n+                                                    final String client,\n+                                                    final HttpServletResponse response) {\n+\n+        if (token.startsWith(OAuth20RefreshToken.PREFIX)) {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20RefreshToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        } else {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20AccessToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MjMyNQ=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNjc4Nw==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397526787", "createdAt": "2020-03-24T23:40:26Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {\n+            return generateRevocationResponse(token, clientId, response);\n+        }\n+        return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param client the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    private ModelAndView generateRevocationResponse(final String token,\n+                                                    final String client,\n+                                                    final HttpServletResponse response) {\n+\n+        if (token.startsWith(OAuth20RefreshToken.PREFIX)) {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20RefreshToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        } else {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20AccessToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MjMyNQ=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDc5MjU5OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODowMzo1NFrOF6kqfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMzozMzoyMlrOF7G9qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MjQzMA==", "bodyText": "cast to refresh-token.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r396962430", "createdAt": "2020-03-24T08:03:54Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {\n+            return generateRevocationResponse(token, clientId, response);\n+        }\n+        return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param client the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    private ModelAndView generateRevocationResponse(final String token,\n+                                                    final String client,\n+                                                    final HttpServletResponse response) {\n+\n+        if (token.startsWith(OAuth20RefreshToken.PREFIX)) {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20RefreshToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        } else {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20AccessToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        }\n+\n+        val mv = new ModelAndView(new MappingJackson2JsonView());\n+        mv.setStatus(HttpStatus.OK);\n+        return mv;\n+    }\n+\n+    /**\n+     * Revoke the provided Refresh Token and it's related Access Tokens.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final OAuth20RefreshToken token) {\n+        LOGGER.debug(\"Revoking token [{}]\", token);\n+        getOAuthConfigurationContext().getTicketRegistry().deleteTicket(token);\n+\n+        token.getAccessTokens().forEach(item-> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNDM5Mw==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397524393", "createdAt": "2020-03-24T23:33:22Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {\n+            return generateRevocationResponse(token, clientId, response);\n+        }\n+        return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param client the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    private ModelAndView generateRevocationResponse(final String token,\n+                                                    final String client,\n+                                                    final HttpServletResponse response) {\n+\n+        if (token.startsWith(OAuth20RefreshToken.PREFIX)) {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20RefreshToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        } else {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20AccessToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        }\n+\n+        val mv = new ModelAndView(new MappingJackson2JsonView());\n+        mv.setStatus(HttpStatus.OK);\n+        return mv;\n+    }\n+\n+    /**\n+     * Revoke the provided Refresh Token and it's related Access Tokens.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final OAuth20RefreshToken token) {\n+        LOGGER.debug(\"Revoking token [{}]\", token);\n+        getOAuthConfigurationContext().getTicketRegistry().deleteTicket(token);\n+\n+        token.getAccessTokens().forEach(item-> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MjQzMA=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDc5NDQxOnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODowNDozNlrOF6krrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMzozMzo0NFrOF7G-Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MjczNQ==", "bodyText": "Also not a good idea. See above. Metadata about what a ticket can or cannot do or support should be attached to the ticket definition itself, if necessary. (Don't think it is, in this case).", "url": "https://github.com/apereo/cas/pull/4771#discussion_r396962735", "createdAt": "2020-03-24T08:04:36Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {\n+            return generateRevocationResponse(token, clientId, response);\n+        }\n+        return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param client the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    private ModelAndView generateRevocationResponse(final String token,\n+                                                    final String client,\n+                                                    final HttpServletResponse response) {\n+\n+        if (token.startsWith(OAuth20RefreshToken.PREFIX)) {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20RefreshToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        } else {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20AccessToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        }\n+\n+        val mv = new ModelAndView(new MappingJackson2JsonView());\n+        mv.setStatus(HttpStatus.OK);\n+        return mv;\n+    }\n+\n+    /**\n+     * Revoke the provided Refresh Token and it's related Access Tokens.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final OAuth20RefreshToken token) {\n+        LOGGER.debug(\"Revoking token [{}]\", token);\n+        getOAuthConfigurationContext().getTicketRegistry().deleteTicket(token);\n+\n+        token.getAccessTokens().forEach(item-> {\n+            LOGGER.debug(\"Revoking Access Token [{}] related to Refresh Token [{}]\", item, token);\n+            getOAuthConfigurationContext().getTicketRegistry().deleteTicket(item);\n+        });\n+    }\n+\n+    /**\n+     * Revoke the provided Access Token.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final OAuth20AccessToken token) {\n+        LOGGER.debug(\"Revoking token [{}]\", token);\n+        getOAuthConfigurationContext().getTicketRegistry().deleteTicket(token);\n+    }\n+\n+    /**\n+     * Verify if the request related token type is supported.\n+     *\n+     * @param token the token\n+     * @return whether the token type is supported\n+     */\n+    private boolean isAsupportedTokenType(final String token) {\n+        return token.startsWith(OAuth20RefreshToken.PREFIX) || token.startsWith(OAuth20AccessToken.PREFIX);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNDUzNA==", "bodyText": "removed it.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397524534", "createdAt": "2020-03-24T23:33:44Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {\n+            return generateRevocationResponse(token, clientId, response);\n+        }\n+        return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param client the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    private ModelAndView generateRevocationResponse(final String token,\n+                                                    final String client,\n+                                                    final HttpServletResponse response) {\n+\n+        if (token.startsWith(OAuth20RefreshToken.PREFIX)) {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20RefreshToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        } else {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20AccessToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        }\n+\n+        val mv = new ModelAndView(new MappingJackson2JsonView());\n+        mv.setStatus(HttpStatus.OK);\n+        return mv;\n+    }\n+\n+    /**\n+     * Revoke the provided Refresh Token and it's related Access Tokens.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final OAuth20RefreshToken token) {\n+        LOGGER.debug(\"Revoking token [{}]\", token);\n+        getOAuthConfigurationContext().getTicketRegistry().deleteTicket(token);\n+\n+        token.getAccessTokens().forEach(item-> {\n+            LOGGER.debug(\"Revoking Access Token [{}] related to Refresh Token [{}]\", item, token);\n+            getOAuthConfigurationContext().getTicketRegistry().deleteTicket(item);\n+        });\n+    }\n+\n+    /**\n+     * Revoke the provided Access Token.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final OAuth20AccessToken token) {\n+        LOGGER.debug(\"Revoking token [{}]\", token);\n+        getOAuthConfigurationContext().getTicketRegistry().deleteTicket(token);\n+    }\n+\n+    /**\n+     * Verify if the request related token type is supported.\n+     *\n+     * @param token the token\n+     * @return whether the token type is supported\n+     */\n+    private boolean isAsupportedTokenType(final String token) {\n+        return token.startsWith(OAuth20RefreshToken.PREFIX) || token.startsWith(OAuth20AccessToken.PREFIX);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MjczNQ=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDc5ODQzOnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODowNTo0OVrOF6kuKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMzozNDowNlrOF7G-uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MzM2OA==", "bodyText": "Duplicate code? Move to OAuthUtils, etc. And switch to isNotBlank", "url": "https://github.com/apereo/cas/pull/4771#discussion_r396963368", "createdAt": "2020-03-24T08:05:49Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {\n+            return generateRevocationResponse(token, clientId, response);\n+        }\n+        return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param client the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    private ModelAndView generateRevocationResponse(final String token,\n+                                                    final String client,\n+                                                    final HttpServletResponse response) {\n+\n+        if (token.startsWith(OAuth20RefreshToken.PREFIX)) {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20RefreshToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        } else {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20AccessToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        }\n+\n+        val mv = new ModelAndView(new MappingJackson2JsonView());\n+        mv.setStatus(HttpStatus.OK);\n+        return mv;\n+    }\n+\n+    /**\n+     * Revoke the provided Refresh Token and it's related Access Tokens.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final OAuth20RefreshToken token) {\n+        LOGGER.debug(\"Revoking token [{}]\", token);\n+        getOAuthConfigurationContext().getTicketRegistry().deleteTicket(token);\n+\n+        token.getAccessTokens().forEach(item-> {\n+            LOGGER.debug(\"Revoking Access Token [{}] related to Refresh Token [{}]\", item, token);\n+            getOAuthConfigurationContext().getTicketRegistry().deleteTicket(item);\n+        });\n+    }\n+\n+    /**\n+     * Revoke the provided Access Token.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final OAuth20AccessToken token) {\n+        LOGGER.debug(\"Revoking token [{}]\", token);\n+        getOAuthConfigurationContext().getTicketRegistry().deleteTicket(token);\n+    }\n+\n+    /**\n+     * Verify if the request related token type is supported.\n+     *\n+     * @param token the token\n+     * @return whether the token type is supported\n+     */\n+    private boolean isAsupportedTokenType(final String token) {\n+        return token.startsWith(OAuth20RefreshToken.PREFIX) || token.startsWith(OAuth20AccessToken.PREFIX);\n+    }\n+\n+    /**\n+     * Gets registered service by client id.\n+     *\n+     * @param clientId the client id\n+     * @return the registered service by client id\n+     */\n+    private OAuthRegisteredService getRegisteredServiceByClientId(final String clientId) {\n+        return OAuth20Utils.getRegisteredOAuthServiceByClientId(getOAuthConfigurationContext().getServicesManager(), clientId);\n+    }\n+\n+    /**\n+     * Verify if the request related service must be authenticated.\n+     *\n+     * @param registeredService the registered service\n+     * @return whether the service need authentication\n+     */\n+    private boolean isServiceNeedAuthentication(final OAuthRegisteredService registeredService) {\n+        return !StringUtils.isBlank(registeredService.getClientSecret());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNDY2NQ==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397524665", "createdAt": "2020-03-24T23:34:06Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (isServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        if (isAsupportedTokenType(token)) {\n+            return generateRevocationResponse(token, clientId, response);\n+        }\n+        return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param client the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    private ModelAndView generateRevocationResponse(final String token,\n+                                                    final String client,\n+                                                    final HttpServletResponse response) {\n+\n+        if (token.startsWith(OAuth20RefreshToken.PREFIX)) {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20RefreshToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        } else {\n+            val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20AccessToken.class);\n+\n+            if (registryToken == null) {\n+                LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+            } else {\n+                if (!StringUtils.equals(client, registryToken.getClientId())) {\n+                    LOGGER.error(\"Provided token [{}] is not related with the service [{}]\", token, client);\n+                    return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+                }\n+                revokeToken(registryToken);\n+            }\n+        }\n+\n+        val mv = new ModelAndView(new MappingJackson2JsonView());\n+        mv.setStatus(HttpStatus.OK);\n+        return mv;\n+    }\n+\n+    /**\n+     * Revoke the provided Refresh Token and it's related Access Tokens.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final OAuth20RefreshToken token) {\n+        LOGGER.debug(\"Revoking token [{}]\", token);\n+        getOAuthConfigurationContext().getTicketRegistry().deleteTicket(token);\n+\n+        token.getAccessTokens().forEach(item-> {\n+            LOGGER.debug(\"Revoking Access Token [{}] related to Refresh Token [{}]\", item, token);\n+            getOAuthConfigurationContext().getTicketRegistry().deleteTicket(item);\n+        });\n+    }\n+\n+    /**\n+     * Revoke the provided Access Token.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final OAuth20AccessToken token) {\n+        LOGGER.debug(\"Revoking token [{}]\", token);\n+        getOAuthConfigurationContext().getTicketRegistry().deleteTicket(token);\n+    }\n+\n+    /**\n+     * Verify if the request related token type is supported.\n+     *\n+     * @param token the token\n+     * @return whether the token type is supported\n+     */\n+    private boolean isAsupportedTokenType(final String token) {\n+        return token.startsWith(OAuth20RefreshToken.PREFIX) || token.startsWith(OAuth20AccessToken.PREFIX);\n+    }\n+\n+    /**\n+     * Gets registered service by client id.\n+     *\n+     * @param clientId the client id\n+     * @return the registered service by client id\n+     */\n+    private OAuthRegisteredService getRegisteredServiceByClientId(final String clientId) {\n+        return OAuth20Utils.getRegisteredOAuthServiceByClientId(getOAuthConfigurationContext().getServicesManager(), clientId);\n+    }\n+\n+    /**\n+     * Verify if the request related service must be authenticated.\n+     *\n+     * @param registeredService the registered service\n+     * @return whether the service need authentication\n+     */\n+    private boolean isServiceNeedAuthentication(final OAuthRegisteredService registeredService) {\n+        return !StringUtils.isBlank(registeredService.getClientSecret());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MzM2OA=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDgwMDE0OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth/src/main/java/org/apereo/cas/config/CasOAuth20Configuration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODowNjoyNFrOF6kvRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQyMzozNDoxN1rOF7G_Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MzY1NQ==", "bodyText": "oauthRevocationController.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r396963655", "createdAt": "2020-03-24T08:06:24Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth/src/main/java/org/apereo/cas/config/CasOAuth20Configuration.java", "diffHunk": "@@ -529,6 +531,15 @@ public OAuth20UserProfileEndpointController profileController() {\n         return new OAuth20UserProfileEndpointController(context);\n     }\n \n+    @ConditionalOnMissingBean(name = \"revocationController\")\n+    @Bean\n+    public OAuth20RevocationEndpointController revocationController() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzUyNDczOQ==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397524739", "createdAt": "2020-03-24T23:34:17Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth/src/main/java/org/apereo/cas/config/CasOAuth20Configuration.java", "diffHunk": "@@ -529,6 +531,15 @@ public OAuth20UserProfileEndpointController profileController() {\n         return new OAuth20UserProfileEndpointController(context);\n     }\n \n+    @ConditionalOnMissingBean(name = \"revocationController\")\n+    @Bean\n+    public OAuth20RevocationEndpointController revocationController() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2MzY1NQ=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDgwNDI5OnYy", "diffSide": "LEFT", "path": "support/cas-server-support-oidc-core-api/src/main/java/org/apereo/cas/oidc/web/controllers/token/OidcRevocationEndpointController.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwODowNzo1MlrOF6kx8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQxNDoyOToyNVrOF9SMrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2NDMzOQ==", "bodyText": "I dont see any of these changes in the OAuth20 variant?", "url": "https://github.com/apereo/cas/pull/4771#discussion_r396964339", "createdAt": "2020-03-24T08:07:52Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oidc-core-api/src/main/java/org/apereo/cas/oidc/web/controllers/token/OidcRevocationEndpointController.java", "diffHunk": "@@ -24,52 +18,17 @@\n  * @author Misagh Moayyed\n  * @since 5.2.0\n  */\n-@Slf4j\n-public class OidcRevocationEndpointController extends BaseOAuth20Controller {\n-    public OidcRevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n-        super(oAuthConfigurationContext);\n-    }\n-\n-    /**\n-     * Handle request for revocation.\n-     *\n-     * @param request  the request\n-     * @param response the response\n-     * @return the jwk set\n-     */\n-    @PostMapping(value = '/' + OidcConstants.BASE_OIDC_URL + '/' + OidcConstants.REVOCATION_URL)\n-    public ResponseEntity<String> handleRequestInternal(final HttpServletRequest request,\n-                                                        final HttpServletResponse response) {\n-        try {\n-            val authExtractor = new BasicAuthExtractor();\n-            val credentialsResult = authExtractor.extract(new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore()));\n-            if (credentialsResult.isEmpty()) {\n-                throw new IllegalArgumentException(\"No credentials are provided to verify revocation of the token\");\n-            }\n+public class OidcRevocationEndpointController extends OAuth20RevocationEndpointController {\n \n-            val credentials = credentialsResult.get();\n-            val registeredService = OAuth20Utils.getRegisteredOAuthServiceByClientId(\n-                getOAuthConfigurationContext().getServicesManager(),\n-                credentials.getUsername());\n-            val service = getOAuthConfigurationContext().getWebApplicationServiceServiceFactory().createService(registeredService.getServiceId());\n-\n-            val audit = AuditableContext.builder()\n-                .service(service)\n-                .registeredService(registeredService)\n-                .build();\n-            val accessResult = getOAuthConfigurationContext().getRegisteredServiceAccessStrategyEnforcer().execute(audit);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQ2NTEyOA==", "bodyText": "You're right I forgot the audit, will add it soon.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r397465128", "createdAt": "2020-03-24T21:14:23Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oidc-core-api/src/main/java/org/apereo/cas/oidc/web/controllers/token/OidcRevocationEndpointController.java", "diffHunk": "@@ -24,52 +18,17 @@\n  * @author Misagh Moayyed\n  * @since 5.2.0\n  */\n-@Slf4j\n-public class OidcRevocationEndpointController extends BaseOAuth20Controller {\n-    public OidcRevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n-        super(oAuthConfigurationContext);\n-    }\n-\n-    /**\n-     * Handle request for revocation.\n-     *\n-     * @param request  the request\n-     * @param response the response\n-     * @return the jwk set\n-     */\n-    @PostMapping(value = '/' + OidcConstants.BASE_OIDC_URL + '/' + OidcConstants.REVOCATION_URL)\n-    public ResponseEntity<String> handleRequestInternal(final HttpServletRequest request,\n-                                                        final HttpServletResponse response) {\n-        try {\n-            val authExtractor = new BasicAuthExtractor();\n-            val credentialsResult = authExtractor.extract(new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore()));\n-            if (credentialsResult.isEmpty()) {\n-                throw new IllegalArgumentException(\"No credentials are provided to verify revocation of the token\");\n-            }\n+public class OidcRevocationEndpointController extends OAuth20RevocationEndpointController {\n \n-            val credentials = credentialsResult.get();\n-            val registeredService = OAuth20Utils.getRegisteredOAuthServiceByClientId(\n-                getOAuthConfigurationContext().getServicesManager(),\n-                credentials.getUsername());\n-            val service = getOAuthConfigurationContext().getWebApplicationServiceServiceFactory().createService(registeredService.getServiceId());\n-\n-            val audit = AuditableContext.builder()\n-                .service(service)\n-                .registeredService(registeredService)\n-                .build();\n-            val accessResult = getOAuthConfigurationContext().getRegisteredServiceAccessStrategyEnforcer().execute(audit);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2NDMzOQ=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgwNTYxMw==", "bodyText": "Just added it for public/passwordless clients only because this \"RegisteredServiceAccessStrategyEnforcer\" kind of audit log is already added for confidential clients by the OAuth20ClientIdClientSecretAuthenticator.\nI think we could add a RevocationTokenResponseAuditResourceResolver or something like that in a future evolution ?", "url": "https://github.com/apereo/cas/pull/4771#discussion_r399805613", "createdAt": "2020-03-29T14:29:25Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oidc-core-api/src/main/java/org/apereo/cas/oidc/web/controllers/token/OidcRevocationEndpointController.java", "diffHunk": "@@ -24,52 +18,17 @@\n  * @author Misagh Moayyed\n  * @since 5.2.0\n  */\n-@Slf4j\n-public class OidcRevocationEndpointController extends BaseOAuth20Controller {\n-    public OidcRevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n-        super(oAuthConfigurationContext);\n-    }\n-\n-    /**\n-     * Handle request for revocation.\n-     *\n-     * @param request  the request\n-     * @param response the response\n-     * @return the jwk set\n-     */\n-    @PostMapping(value = '/' + OidcConstants.BASE_OIDC_URL + '/' + OidcConstants.REVOCATION_URL)\n-    public ResponseEntity<String> handleRequestInternal(final HttpServletRequest request,\n-                                                        final HttpServletResponse response) {\n-        try {\n-            val authExtractor = new BasicAuthExtractor();\n-            val credentialsResult = authExtractor.extract(new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore()));\n-            if (credentialsResult.isEmpty()) {\n-                throw new IllegalArgumentException(\"No credentials are provided to verify revocation of the token\");\n-            }\n+public class OidcRevocationEndpointController extends OAuth20RevocationEndpointController {\n \n-            val credentials = credentialsResult.get();\n-            val registeredService = OAuth20Utils.getRegisteredOAuthServiceByClientId(\n-                getOAuthConfigurationContext().getServicesManager(),\n-                credentials.getUsername());\n-            val service = getOAuthConfigurationContext().getWebApplicationServiceServiceFactory().createService(registeredService.getServiceId());\n-\n-            val audit = AuditableContext.builder()\n-                .service(service)\n-                .registeredService(registeredService)\n-                .build();\n-            val accessResult = getOAuthConfigurationContext().getRegisteredServiceAccessStrategyEnforcer().execute(audit);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njk2NDMzOQ=="}, "originalCommit": {"oid": "fcc81e75d0d81d31b73a7434ce54accb38ca448a"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDQ0OTE5OnYy", "diffSide": "RIGHT", "path": "docs/cas-server-documentation/installation/OAuth-OpenId-Authentication.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNzo1OTozNlrOF9dy5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzowMDowOVrOF9zXlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk5NTYyMg==", "bodyText": "This does not belong here. The page is for OAUTH support.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r399995622", "createdAt": "2020-03-30T07:59:36Z", "author": {"login": "mmoayyed"}, "path": "docs/cas-server-documentation/installation/OAuth-OpenId-Authentication.md", "diffHunk": "@@ -45,10 +45,11 @@ After enabling OAuth support, the following endpoints will be available:\n | `/oauth2.0/profile`       | Get the authenticated user profile in JSON via `access_token` parameter.    | `GET`\n | `/oauth2.0/introspect`    | Query CAS to detect the status of a given access token via [introspection](https://tools.ietf.org/html/rfc7662).  | `POST`\n | `/oauth2.0/device`        | Approve device user codes via the [device flow protocol](https://tools.ietf.org/html/draft-denniss-oauth-device-flow). | `POST`\n+| `/oidc/revoke`            | [Revoke](https://tools.ietf.org/html/rfc7009) access or refresh tokens.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA1MzgyOA==", "bodyText": "Oops... typo. Sorry.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400053828", "createdAt": "2020-03-30T09:34:30Z", "author": {"login": "julienhuon"}, "path": "docs/cas-server-documentation/installation/OAuth-OpenId-Authentication.md", "diffHunk": "@@ -45,10 +45,11 @@ After enabling OAuth support, the following endpoints will be available:\n | `/oauth2.0/profile`       | Get the authenticated user profile in JSON via `access_token` parameter.    | `GET`\n | `/oauth2.0/introspect`    | Query CAS to detect the status of a given access token via [introspection](https://tools.ietf.org/html/rfc7662).  | `POST`\n | `/oauth2.0/device`        | Approve device user codes via the [device flow protocol](https://tools.ietf.org/html/draft-denniss-oauth-device-flow). | `POST`\n+| `/oidc/revoke`            | [Revoke](https://tools.ietf.org/html/rfc7009) access or refresh tokens.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk5NTYyMg=="}, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM0OTA3OA==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400349078", "createdAt": "2020-03-30T17:00:09Z", "author": {"login": "julienhuon"}, "path": "docs/cas-server-documentation/installation/OAuth-OpenId-Authentication.md", "diffHunk": "@@ -45,10 +45,11 @@ After enabling OAuth support, the following endpoints will be available:\n | `/oauth2.0/profile`       | Get the authenticated user profile in JSON via `access_token` parameter.    | `GET`\n | `/oauth2.0/introspect`    | Query CAS to detect the status of a given access token via [introspection](https://tools.ietf.org/html/rfc7662).  | `POST`\n | `/oauth2.0/device`        | Approve device user codes via the [device flow protocol](https://tools.ietf.org/html/draft-denniss-oauth-device-flow). | `POST`\n+| `/oidc/revoke`            | [Revoke](https://tools.ietf.org/html/rfc7009) access or refresh tokens.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk5NTYyMg=="}, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDQ2Mjc3OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/OAuth20Constants.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwODowMzoyNVrOF9d7Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzowMDoyM1rOF9zYMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk5NzcxMA==", "bodyText": "Move the constant next to all other URLs; Keep a consistent order as much as possible, and help the next reader.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r399997710", "createdAt": "2020-03-30T08:03:25Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/OAuth20Constants.java", "diffHunk": "@@ -345,4 +345,8 @@\n      */\n     String UNAUTHORIZED_CLIENT = \"unauthorized_client\";\n \n+    /**\n+     * The revocation url.\n+     */\n+    String REVOCATION_URL = \"revoke\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM0OTIzMg==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400349232", "createdAt": "2020-03-30T17:00:23Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/OAuth20Constants.java", "diffHunk": "@@ -345,4 +345,8 @@\n      */\n     String UNAUTHORIZED_CLIENT = \"unauthorized_client\";\n \n+    /**\n+     * The revocation url.\n+     */\n+    String REVOCATION_URL = \"revoke\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk5NzcxMA=="}, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDQ2NjQ1OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/validator/token/OAuth20RevocationRequestValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwODowNDoyNVrOF9d9MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzowMDozMlrOF9zYng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk5ODI1Ng==", "bodyText": "If the token is blank you don't need to check/fetch the client-id. Return false immediately, and marginally help with performance.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r399998256", "createdAt": "2020-03-30T08:04:25Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/validator/token/OAuth20RevocationRequestValidator.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package org.apereo.cas.support.oauth.validator.token;\n+\n+import org.apereo.cas.services.ServicesManager;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.springframework.core.Ordered;\n+\n+/**\n+ * This is {@link OAuth20RevocationRequestValidator}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@RequiredArgsConstructor\n+@Slf4j\n+@Getter\n+@Setter\n+public class OAuth20RevocationRequestValidator implements OAuth20TokenRequestValidator {\n+    private final ServicesManager servicesManager;\n+\n+    private int order = Ordered.LOWEST_PRECEDENCE;\n+\n+    @Override\n+    public boolean validate(final JEEContext context) {\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = OAuth20Utils.getRegisteredOAuthServiceByClientId(this.servicesManager, clientId);\n+\n+        if (registeredService == null) {\n+            LOGGER.warn(\"Provided client id [{}] cannot be matched against a service definition\", clientId);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean supports(final JEEContext context) {\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM0OTM0Mg==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400349342", "createdAt": "2020-03-30T17:00:32Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/validator/token/OAuth20RevocationRequestValidator.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package org.apereo.cas.support.oauth.validator.token;\n+\n+import org.apereo.cas.services.ServicesManager;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.springframework.core.Ordered;\n+\n+/**\n+ * This is {@link OAuth20RevocationRequestValidator}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@RequiredArgsConstructor\n+@Slf4j\n+@Getter\n+@Setter\n+public class OAuth20RevocationRequestValidator implements OAuth20TokenRequestValidator {\n+    private final ServicesManager servicesManager;\n+\n+    private int order = Ordered.LOWEST_PRECEDENCE;\n+\n+    @Override\n+    public boolean validate(final JEEContext context) {\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = OAuth20Utils.getRegisteredOAuthServiceByClientId(this.servicesManager, clientId);\n+\n+        if (registeredService == null) {\n+            LOGGER.warn(\"Provided client id [{}] cannot be matched against a service definition\", clientId);\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean supports(final JEEContext context) {\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk5ODI1Ng=="}, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDQ2OTkxOnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwODowNToyNlrOF9d_Yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzowMDo0NVrOF9zZLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk5ODgxOA==", "bodyText": "If client-id is undefined, return immediately and do not look up the service in registry.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r399998818", "createdAt": "2020-03-30T08:05:26Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "diffHunk": "@@ -48,6 +56,34 @@ public boolean preHandle(final HttpServletRequest request, final HttpServletResp\n         return !isAuthorizationRequest(request, response) || requiresAuthenticationAuthorizeInterceptor.preHandle(request, response, handler);\n     }\n \n+    /**\n+    * Is the client requesting is a OAuth \"public\" client?\n+    * An OAuth \"public\" client is one that does not define a secret like a mobile application.\n+    *\n+    * @param request the request\n+    * @param response the response\n+    * @return the boolean\n+    */\n+    protected boolean clientNeedAuthentication(final HttpServletRequest request, final HttpServletResponse response) {\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(new JEEContext(request, response, sessionStore)).getLeft();\n+        val registeredService = OAuth20Utils.getRegisteredOAuthServiceByClientId(servicesManager, clientId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM0OTQ4Ng==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400349486", "createdAt": "2020-03-30T17:00:45Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "diffHunk": "@@ -48,6 +56,34 @@ public boolean preHandle(final HttpServletRequest request, final HttpServletResp\n         return !isAuthorizationRequest(request, response) || requiresAuthenticationAuthorizeInterceptor.preHandle(request, response, handler);\n     }\n \n+    /**\n+    * Is the client requesting is a OAuth \"public\" client?\n+    * An OAuth \"public\" client is one that does not define a secret like a mobile application.\n+    *\n+    * @param request the request\n+    * @param response the response\n+    * @return the boolean\n+    */\n+    protected boolean clientNeedAuthentication(final HttpServletRequest request, final HttpServletResponse response) {\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(new JEEContext(request, response, sessionStore)).getLeft();\n+        val registeredService = OAuth20Utils.getRegisteredOAuthServiceByClientId(servicesManager, clientId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk5ODgxOA=="}, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDQ3NDc5OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwODowNjo1MlrOF9eCeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzowMDo1MlrOF9zZcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk5OTYwOQ==", "bodyText": "This likely should be a warn.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r399999609", "createdAt": "2020-03-30T08:06:52Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.audit.AuditableContext;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.OAuth20Token;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (OAuth20Utils.doesServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM0OTU1Mg==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400349552", "createdAt": "2020-03-30T17:00:52Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.audit.AuditableContext;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.OAuth20Token;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (OAuth20Utils.doesServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTk5OTYwOQ=="}, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDQ3ODE4OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwODowNzo0M1rOF9eEbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMDowMDoxM1rOF96Afw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwMDEwOQ==", "bodyText": "Audit checks should always execute. Don't think you need to put these lines in an else clause.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400000109", "createdAt": "2020-03-30T08:07:43Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.audit.AuditableContext;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.OAuth20Token;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (OAuth20Utils.doesServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        } else {\n+            val service = getOAuthConfigurationContext().getWebApplicationServiceServiceFactory().createService(registeredService.getServiceId());\n+\n+            val audit = AuditableContext.builder()\n+                .service(service)\n+                .registeredService(registeredService)\n+                .build();\n+\n+            val accessResult = getOAuthConfigurationContext().getRegisteredServiceAccessStrategyEnforcer().execute(audit);\n+            if (accessResult.isExecutionFailure()) {\n+                return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA1ODU4OQ==", "bodyText": "When the request is executed by a confidential client, the exact same audit log is provided by the OAuth20ClientIdClientSecret Authenticator.\nSo I don't think I should remove it form the else. But it's up to you.\nI think we could add a RevocationTokenResponseAuditResourceResolver or something like that in a future evolution ?", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400058589", "createdAt": "2020-03-30T09:42:39Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.audit.AuditableContext;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.OAuth20Token;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (OAuth20Utils.doesServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        } else {\n+            val service = getOAuthConfigurationContext().getWebApplicationServiceServiceFactory().createService(registeredService.getServiceId());\n+\n+            val audit = AuditableContext.builder()\n+                .service(service)\n+                .registeredService(registeredService)\n+                .build();\n+\n+            val accessResult = getOAuthConfigurationContext().getRegisteredServiceAccessStrategyEnforcer().execute(audit);\n+            if (accessResult.isExecutionFailure()) {\n+                return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwMDEwOQ=="}, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ1Nzg1NQ==", "bodyText": "Makes sense, sure.\nAnd yes, sure; RevocationTokenResponseAuditResourceResolver would be a good idea in the next PR.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400457855", "createdAt": "2020-03-30T20:00:13Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.audit.AuditableContext;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.OAuth20Token;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (OAuth20Utils.doesServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        } else {\n+            val service = getOAuthConfigurationContext().getWebApplicationServiceServiceFactory().createService(registeredService.getServiceId());\n+\n+            val audit = AuditableContext.builder()\n+                .service(service)\n+                .registeredService(registeredService)\n+                .build();\n+\n+            val accessResult = getOAuthConfigurationContext().getRegisteredServiceAccessStrategyEnforcer().execute(audit);\n+            if (accessResult.isExecutionFailure()) {\n+                return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwMDEwOQ=="}, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDQ4MTE1OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth/src/test/java/org/apereo/cas/support/oauth/validator/token/OAuth20RevocationRequestValidatorTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwODowODoyN1rOF9eGLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzoxMjo0MlrOF9z1ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwMDU1Ng==", "bodyText": "Replace all with HttpUtils#createBasicAuthHeaders", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400000556", "createdAt": "2020-03-30T08:08:27Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth/src/test/java/org/apereo/cas/support/oauth/validator/token/OAuth20RevocationRequestValidatorTests.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package org.apereo.cas.support.oauth.validator.token;\n+\n+import org.apereo.cas.services.RegisteredServiceTestUtils;\n+import org.apereo.cas.services.ServicesManager;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.OAuth20GrantTypes;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+import org.apereo.cas.ticket.registry.TicketRegistry;\n+import org.apereo.cas.util.CollectionUtils;\n+import org.apereo.cas.util.EncodingUtils;\n+\n+import lombok.val;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.pac4j.core.context.JEEContext;\n+import org.springframework.mock.web.MockHttpServletRequest;\n+import org.springframework.mock.web.MockHttpServletResponse;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * This is {@link OAuth20RevocationRequestValidatorTests}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Tag(\"OAuth\")\n+public class OAuth20RevocationRequestValidatorTests {\n+    private static final String SUPPORTING_SERVICE_TICKET = \"RT-SUPPORTING\";\n+\n+    private TicketRegistry ticketRegistry;\n+    private OAuth20TokenRequestValidator validator;\n+\n+    private void registerTicket(final String name) {\n+        val oauthCode = mock(OAuth20RefreshToken.class);\n+        when(oauthCode.getId()).thenReturn(name);\n+        when(oauthCode.isExpired()).thenReturn(false);\n+        when(oauthCode.getAuthentication()).thenReturn(RegisteredServiceTestUtils.getAuthentication());\n+        when(ticketRegistry.getTicket(eq(name))).thenReturn(oauthCode);\n+    }\n+\n+    @BeforeEach\n+    public void before() {\n+        val servicesManager = mock(ServicesManager.class);\n+\n+        val supportingService = RequestValidatorTestUtils.getService(\n+            RegisteredServiceTestUtils.CONST_TEST_URL,\n+            RequestValidatorTestUtils.SUPPORTING_CLIENT_ID,\n+            RequestValidatorTestUtils.SUPPORTING_CLIENT_ID,\n+            RequestValidatorTestUtils.SHARED_SECRET,\n+            CollectionUtils.wrapSet(OAuth20GrantTypes.REFRESH_TOKEN));\n+        when(servicesManager.getAllServices()).thenReturn(CollectionUtils.wrapList(supportingService));\n+\n+        this.ticketRegistry = mock(TicketRegistry.class);\n+\n+        registerTicket(SUPPORTING_SERVICE_TICKET);\n+\n+        this.validator = new OAuth20RevocationRequestValidator(servicesManager);\n+    }\n+\n+    @Test\n+    public void verifyOperationClientSecretPost() {\n+        val request = new MockHttpServletRequest();\n+        val response = new MockHttpServletResponse();\n+\n+        request.setParameter(OAuth20Constants.CLIENT_ID, RequestValidatorTestUtils.SUPPORTING_CLIENT_ID);\n+        request.setParameter(OAuth20Constants.CLIENT_SECRET, RequestValidatorTestUtils.SHARED_SECRET);\n+        request.setParameter(OAuth20Constants.TOKEN, SUPPORTING_SERVICE_TICKET);\n+\n+        assertTrue(this.validator.validate(new JEEContext(request, response)));\n+\n+        request.removeAllParameters();\n+        request.setParameter(OAuth20Constants.CLIENT_ID, RequestValidatorTestUtils.SUPPORTING_CLIENT_ID);\n+        request.setParameter(OAuth20Constants.CLIENT_SECRET, RequestValidatorTestUtils.SHARED_SECRET);\n+        assertFalse(this.validator.supports(new JEEContext(request, response)));\n+\n+        request.removeAllParameters();\n+        request.setParameter(OAuth20Constants.CLIENT_ID, RequestValidatorTestUtils.NON_SUPPORTING_CLIENT_ID);\n+        request.setParameter(OAuth20Constants.CLIENT_SECRET, RequestValidatorTestUtils.SHARED_SECRET);\n+        request.setParameter(OAuth20Constants.TOKEN, SUPPORTING_SERVICE_TICKET);\n+        assertFalse(this.validator.validate(new JEEContext(request, response)));\n+    }\n+\n+    @Test\n+    public void verifyOperationClientSecretBasic() {\n+        val request = new MockHttpServletRequest();\n+        val response = new MockHttpServletResponse();\n+\n+        request.addHeader(\"Authorization\",\n+                          \"Basic \" + EncodingUtils.encodeBase64(RequestValidatorTestUtils.SUPPORTING_CLIENT_ID + \":\" + RequestValidatorTestUtils.SHARED_SECRET));\n+        request.setParameter(OAuth20Constants.TOKEN, SUPPORTING_SERVICE_TICKET);\n+        assertTrue(this.validator.validate(new JEEContext(request, response)));\n+\n+\n+        request.removeHeader(\"Authorization\");\n+        request.removeAllParameters();\n+        request.addHeader(\"Authorization\",\n+                          \"Basic \" + EncodingUtils.encodeBase64(RequestValidatorTestUtils.SUPPORTING_CLIENT_ID + \":\" + RequestValidatorTestUtils.SHARED_SECRET));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1NjcwOA==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400356708", "createdAt": "2020-03-30T17:12:42Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth/src/test/java/org/apereo/cas/support/oauth/validator/token/OAuth20RevocationRequestValidatorTests.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package org.apereo.cas.support.oauth.validator.token;\n+\n+import org.apereo.cas.services.RegisteredServiceTestUtils;\n+import org.apereo.cas.services.ServicesManager;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.OAuth20GrantTypes;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+import org.apereo.cas.ticket.registry.TicketRegistry;\n+import org.apereo.cas.util.CollectionUtils;\n+import org.apereo.cas.util.EncodingUtils;\n+\n+import lombok.val;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.pac4j.core.context.JEEContext;\n+import org.springframework.mock.web.MockHttpServletRequest;\n+import org.springframework.mock.web.MockHttpServletResponse;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+/**\n+ * This is {@link OAuth20RevocationRequestValidatorTests}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Tag(\"OAuth\")\n+public class OAuth20RevocationRequestValidatorTests {\n+    private static final String SUPPORTING_SERVICE_TICKET = \"RT-SUPPORTING\";\n+\n+    private TicketRegistry ticketRegistry;\n+    private OAuth20TokenRequestValidator validator;\n+\n+    private void registerTicket(final String name) {\n+        val oauthCode = mock(OAuth20RefreshToken.class);\n+        when(oauthCode.getId()).thenReturn(name);\n+        when(oauthCode.isExpired()).thenReturn(false);\n+        when(oauthCode.getAuthentication()).thenReturn(RegisteredServiceTestUtils.getAuthentication());\n+        when(ticketRegistry.getTicket(eq(name))).thenReturn(oauthCode);\n+    }\n+\n+    @BeforeEach\n+    public void before() {\n+        val servicesManager = mock(ServicesManager.class);\n+\n+        val supportingService = RequestValidatorTestUtils.getService(\n+            RegisteredServiceTestUtils.CONST_TEST_URL,\n+            RequestValidatorTestUtils.SUPPORTING_CLIENT_ID,\n+            RequestValidatorTestUtils.SUPPORTING_CLIENT_ID,\n+            RequestValidatorTestUtils.SHARED_SECRET,\n+            CollectionUtils.wrapSet(OAuth20GrantTypes.REFRESH_TOKEN));\n+        when(servicesManager.getAllServices()).thenReturn(CollectionUtils.wrapList(supportingService));\n+\n+        this.ticketRegistry = mock(TicketRegistry.class);\n+\n+        registerTicket(SUPPORTING_SERVICE_TICKET);\n+\n+        this.validator = new OAuth20RevocationRequestValidator(servicesManager);\n+    }\n+\n+    @Test\n+    public void verifyOperationClientSecretPost() {\n+        val request = new MockHttpServletRequest();\n+        val response = new MockHttpServletResponse();\n+\n+        request.setParameter(OAuth20Constants.CLIENT_ID, RequestValidatorTestUtils.SUPPORTING_CLIENT_ID);\n+        request.setParameter(OAuth20Constants.CLIENT_SECRET, RequestValidatorTestUtils.SHARED_SECRET);\n+        request.setParameter(OAuth20Constants.TOKEN, SUPPORTING_SERVICE_TICKET);\n+\n+        assertTrue(this.validator.validate(new JEEContext(request, response)));\n+\n+        request.removeAllParameters();\n+        request.setParameter(OAuth20Constants.CLIENT_ID, RequestValidatorTestUtils.SUPPORTING_CLIENT_ID);\n+        request.setParameter(OAuth20Constants.CLIENT_SECRET, RequestValidatorTestUtils.SHARED_SECRET);\n+        assertFalse(this.validator.supports(new JEEContext(request, response)));\n+\n+        request.removeAllParameters();\n+        request.setParameter(OAuth20Constants.CLIENT_ID, RequestValidatorTestUtils.NON_SUPPORTING_CLIENT_ID);\n+        request.setParameter(OAuth20Constants.CLIENT_SECRET, RequestValidatorTestUtils.SHARED_SECRET);\n+        request.setParameter(OAuth20Constants.TOKEN, SUPPORTING_SERVICE_TICKET);\n+        assertFalse(this.validator.validate(new JEEContext(request, response)));\n+    }\n+\n+    @Test\n+    public void verifyOperationClientSecretBasic() {\n+        val request = new MockHttpServletRequest();\n+        val response = new MockHttpServletResponse();\n+\n+        request.addHeader(\"Authorization\",\n+                          \"Basic \" + EncodingUtils.encodeBase64(RequestValidatorTestUtils.SUPPORTING_CLIENT_ID + \":\" + RequestValidatorTestUtils.SHARED_SECRET));\n+        request.setParameter(OAuth20Constants.TOKEN, SUPPORTING_SERVICE_TICKET);\n+        assertTrue(this.validator.validate(new JEEContext(request, response)));\n+\n+\n+        request.removeHeader(\"Authorization\");\n+        request.removeAllParameters();\n+        request.addHeader(\"Authorization\",\n+                          \"Basic \" + EncodingUtils.encodeBase64(RequestValidatorTestUtils.SUPPORTING_CLIENT_ID + \":\" + RequestValidatorTestUtils.SHARED_SECRET));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwMDU1Ng=="}, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDQ4NjA1OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwODowOToyOVrOF9eI5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzoxNDowM1rOF9z40g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwMTI1NA==", "bodyText": "Fix typo.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400001254", "createdAt": "2020-03-30T08:09:29Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "diffHunk": "@@ -48,6 +56,34 @@ public boolean preHandle(final HttpServletRequest request, final HttpServletResp\n         return !isAuthorizationRequest(request, response) || requiresAuthenticationAuthorizeInterceptor.preHandle(request, response, handler);\n     }\n \n+    /**\n+    * Is the client requesting is a OAuth \"public\" client?\n+    * An OAuth \"public\" client is one that does not define a secret like a mobile application.\n+    *\n+    * @param request the request\n+    * @param response the response\n+    * @return the boolean\n+    */\n+    protected boolean clientNeedAuthentication(final HttpServletRequest request, final HttpServletResponse response) {\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(new JEEContext(request, response, sessionStore)).getLeft();\n+        val registeredService = OAuth20Utils.getRegisteredOAuthServiceByClientId(servicesManager, clientId);\n+        if (clientId.isEmpty() || registeredService == null) {\n+            return true;\n+        }\n+        return OAuth20Utils.doesServiceNeedAuthentication(registeredService);\n+    }\n+\n+    /**\n+     * Is revoke token request request?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1NzU4Ng==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400357586", "createdAt": "2020-03-30T17:14:03Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "diffHunk": "@@ -48,6 +56,34 @@ public boolean preHandle(final HttpServletRequest request, final HttpServletResp\n         return !isAuthorizationRequest(request, response) || requiresAuthenticationAuthorizeInterceptor.preHandle(request, response, handler);\n     }\n \n+    /**\n+    * Is the client requesting is a OAuth \"public\" client?\n+    * An OAuth \"public\" client is one that does not define a secret like a mobile application.\n+    *\n+    * @param request the request\n+    * @param response the response\n+    * @return the boolean\n+    */\n+    protected boolean clientNeedAuthentication(final HttpServletRequest request, final HttpServletResponse response) {\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(new JEEContext(request, response, sessionStore)).getLeft();\n+        val registeredService = OAuth20Utils.getRegisteredOAuthServiceByClientId(servicesManager, clientId);\n+        if (clientId.isEmpty() || registeredService == null) {\n+            return true;\n+        }\n+        return OAuth20Utils.doesServiceNeedAuthentication(registeredService);\n+    }\n+\n+    /**\n+     * Is revoke token request request?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwMTI1NA=="}, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDQ4ODk3OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwODoxMDowOFrOF9eKhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzoxNzoxNFrOF90Auw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwMTY3MQ==", "bodyText": "Move this call down to around like 128.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400001671", "createdAt": "2020-03-30T08:10:08Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "diffHunk": "@@ -84,6 +120,12 @@ protected boolean isDeviceTokenRequest(final HttpServletRequest request, final H\n      */\n     protected boolean requestRequiresAuthentication(final HttpServletRequest request, final HttpServletResponse response) {\n         val accessTokenRequest = isAccessTokenRequest(request, response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1OTYxMQ==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400359611", "createdAt": "2020-03-30T17:17:14Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/OAuth20HandlerInterceptorAdapter.java", "diffHunk": "@@ -84,6 +120,12 @@ protected boolean isDeviceTokenRequest(final HttpServletRequest request, final H\n      */\n     protected boolean requestRequiresAuthentication(final HttpServletRequest request, final HttpServletResponse response) {\n         val accessTokenRequest = isAccessTokenRequest(request, response);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwMTY3MQ=="}, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDQ5MDI3OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwODoxMDoyOVrOF9eLPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxOTo1ODozOFrOF9589A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwMTg1NA==", "bodyText": "This likely should be a warn.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400001854", "createdAt": "2020-03-30T08:10:29Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.audit.AuditableContext;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.OAuth20Token;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM0Mjg5NA==", "bodyText": "Are you sure?\nAll the other endpoints are raising an error when the request verification failed. For example:\nAuthorize Endpoint:\nif (!verifyAuthorizeRequest(context) || !isRequestAuthenticated(manager)) {\n            LOGGER.error(\"Authorize request verification failed. Authorization request is missing required parameters, \"\n                + \"or the request is not authenticated and contains no authenticated profile/principal.\");\n            return OAuth20Utils.produceUnauthorizedErrorView();\n        }\n\nAccessToken Endpoint:\n            if (!verifyAccessTokenRequest(request, response)) {\n                throw new IllegalArgumentException(\"Access token validation failed\");\n            }", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400342894", "createdAt": "2020-03-30T16:50:50Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.audit.AuditableContext;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.OAuth20Token;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwMTg1NA=="}, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ1Njk0OA==", "bodyText": "Sounds good, let's keep things consistent then. Thanks!", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400456948", "createdAt": "2020-03-30T19:58:38Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.audit.AuditableContext;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.OAuth20Token;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwMTg1NA=="}, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDQ5MjQwOnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwODoxMTowMlrOF9eMeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzoxNzozOFrOF90BxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwMjE3MA==", "bodyText": "This likely should be a warn.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400002170", "createdAt": "2020-03-30T08:11:02Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.audit.AuditableContext;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.OAuth20Token;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (OAuth20Utils.doesServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        } else {\n+            val service = getOAuthConfigurationContext().getWebApplicationServiceServiceFactory().createService(registeredService.getServiceId());\n+\n+            val audit = AuditableContext.builder()\n+                .service(service)\n+                .registeredService(registeredService)\n+                .build();\n+\n+            val accessResult = getOAuthConfigurationContext().getRegisteredServiceAccessStrategyEnforcer().execute(audit);\n+            if (accessResult.isExecutionFailure()) {\n+                return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        return generateRevocationResponse(token, clientId, response);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param clientId the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    protected ModelAndView generateRevocationResponse(final String token,\n+                                                      final String clientId,\n+                                                      final HttpServletResponse response) {\n+\n+        val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20Token.class);\n+\n+        if (registryToken == null) {\n+            LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+        } else if (isRefreshToken(registryToken) || isAccessToken(registryToken)) {\n+            if (!StringUtils.equals(clientId, registryToken.getClientId())) {\n+                LOGGER.error(\"Provided token [{}] has not been issued for the service [{}]\", token, clientId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM1OTg3Nw==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400359877", "createdAt": "2020-03-30T17:17:38Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.audit.AuditableContext;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.OAuth20Token;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (OAuth20Utils.doesServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        } else {\n+            val service = getOAuthConfigurationContext().getWebApplicationServiceServiceFactory().createService(registeredService.getServiceId());\n+\n+            val audit = AuditableContext.builder()\n+                .service(service)\n+                .registeredService(registeredService)\n+                .build();\n+\n+            val accessResult = getOAuthConfigurationContext().getRegisteredServiceAccessStrategyEnforcer().execute(audit);\n+            if (accessResult.isExecutionFailure()) {\n+                return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        return generateRevocationResponse(token, clientId, response);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param clientId the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    protected ModelAndView generateRevocationResponse(final String token,\n+                                                      final String clientId,\n+                                                      final HttpServletResponse response) {\n+\n+        val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20Token.class);\n+\n+        if (registryToken == null) {\n+            LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+        } else if (isRefreshToken(registryToken) || isAccessToken(registryToken)) {\n+            if (!StringUtils.equals(clientId, registryToken.getClientId())) {\n+                LOGGER.error(\"Provided token [{}] has not been issued for the service [{}]\", token, clientId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwMjE3MA=="}, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDQ5OTE2OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwODoxMjo1MFrOF9eQig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxMzoxODoxOVrOF9pPdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwMzIxMA==", "bodyText": "I think doing calls directly specially with the JPA ticket registry fails with a transaction-required error. Do you think you might be able to verify this?", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400003210", "createdAt": "2020-03-30T08:12:50Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.audit.AuditableContext;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.OAuth20Token;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (OAuth20Utils.doesServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        } else {\n+            val service = getOAuthConfigurationContext().getWebApplicationServiceServiceFactory().createService(registeredService.getServiceId());\n+\n+            val audit = AuditableContext.builder()\n+                .service(service)\n+                .registeredService(registeredService)\n+                .build();\n+\n+            val accessResult = getOAuthConfigurationContext().getRegisteredServiceAccessStrategyEnforcer().execute(audit);\n+            if (accessResult.isExecutionFailure()) {\n+                return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        return generateRevocationResponse(token, clientId, response);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param clientId the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    protected ModelAndView generateRevocationResponse(final String token,\n+                                                      final String clientId,\n+                                                      final HttpServletResponse response) {\n+\n+        val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20Token.class);\n+\n+        if (registryToken == null) {\n+            LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+        } else if (isRefreshToken(registryToken) || isAccessToken(registryToken)) {\n+            if (!StringUtils.equals(clientId, registryToken.getClientId())) {\n+                LOGGER.error(\"Provided token [{}] has not been issued for the service [{}]\", token, clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+            }\n+\n+            if (isRefreshToken(registryToken)) {\n+                revokeToken((OAuth20RefreshToken) registryToken);\n+            } else {\n+                revokeToken(registryToken.getId());\n+            }\n+        } else {\n+            LOGGER.error(\"Provided token [{}] is either not a refresh token or not an access token\", token);\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val mv = new ModelAndView(new MappingJackson2JsonView());\n+        mv.setStatus(HttpStatus.OK);\n+        return mv;\n+    }\n+\n+    /**\n+     * Revoke the provided Refresh Token and it's related Access Tokens.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final OAuth20RefreshToken token) {\n+        revokeToken(token.getId());\n+\n+        token.getAccessTokens().forEach(item-> {\n+            revokeToken(item);\n+        });\n+    }\n+\n+    /**\n+     * Revoke the provided OAuth Token.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final String token) {\n+        LOGGER.debug(\"Revoking token [{}]\", token);\n+        getOAuthConfigurationContext().getTicketRegistry().deleteTicket(token);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA2NDE0Nw==", "bodyText": "I didn't tested it with JPA (only with Redis) but it's exactly the same revocation process than the old one.\nWill test it to be sure.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400064147", "createdAt": "2020-03-30T09:51:25Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.audit.AuditableContext;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.OAuth20Token;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (OAuth20Utils.doesServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        } else {\n+            val service = getOAuthConfigurationContext().getWebApplicationServiceServiceFactory().createService(registeredService.getServiceId());\n+\n+            val audit = AuditableContext.builder()\n+                .service(service)\n+                .registeredService(registeredService)\n+                .build();\n+\n+            val accessResult = getOAuthConfigurationContext().getRegisteredServiceAccessStrategyEnforcer().execute(audit);\n+            if (accessResult.isExecutionFailure()) {\n+                return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        return generateRevocationResponse(token, clientId, response);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param clientId the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    protected ModelAndView generateRevocationResponse(final String token,\n+                                                      final String clientId,\n+                                                      final HttpServletResponse response) {\n+\n+        val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20Token.class);\n+\n+        if (registryToken == null) {\n+            LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+        } else if (isRefreshToken(registryToken) || isAccessToken(registryToken)) {\n+            if (!StringUtils.equals(clientId, registryToken.getClientId())) {\n+                LOGGER.error(\"Provided token [{}] has not been issued for the service [{}]\", token, clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+            }\n+\n+            if (isRefreshToken(registryToken)) {\n+                revokeToken((OAuth20RefreshToken) registryToken);\n+            } else {\n+                revokeToken(registryToken.getId());\n+            }\n+        } else {\n+            LOGGER.error(\"Provided token [{}] is either not a refresh token or not an access token\", token);\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val mv = new ModelAndView(new MappingJackson2JsonView());\n+        mv.setStatus(HttpStatus.OK);\n+        return mv;\n+    }\n+\n+    /**\n+     * Revoke the provided Refresh Token and it's related Access Tokens.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final OAuth20RefreshToken token) {\n+        revokeToken(token.getId());\n+\n+        token.getAccessTokens().forEach(item-> {\n+            revokeToken(item);\n+        });\n+    }\n+\n+    /**\n+     * Revoke the provided OAuth Token.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final String token) {\n+        LOGGER.debug(\"Revoking token [{}]\", token);\n+        getOAuthConfigurationContext().getTicketRegistry().deleteTicket(token);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwMzIxMA=="}, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDE4MzE1Ng==", "bodyText": "OK, thanks. Let's leave it aside for now. I can try to help in this area too.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400183156", "createdAt": "2020-03-30T13:18:19Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointController.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.audit.AuditableContext;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.services.OAuthRegisteredService;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+import org.apereo.cas.ticket.OAuth20Token;\n+import org.apereo.cas.ticket.accesstoken.OAuth20AccessToken;\n+import org.apereo.cas.ticket.refreshtoken.OAuth20RefreshToken;\n+\n+import lombok.extern.slf4j.Slf4j;\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+import org.pac4j.core.profile.CommonProfile;\n+import org.pac4j.core.profile.ProfileManager;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.web.bind.annotation.PostMapping;\n+import org.springframework.web.servlet.ModelAndView;\n+import org.springframework.web.servlet.view.json.MappingJackson2JsonView;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * This is {@link OAuth20RevocationEndpointController}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Slf4j\n+public class OAuth20RevocationEndpointController extends BaseOAuth20Controller {\n+    public OAuth20RevocationEndpointController(final OAuth20ConfigurationContext oAuthConfigurationContext) {\n+        super(oAuthConfigurationContext);\n+    }\n+\n+    /**\n+     * Handle request for revocation.\n+     *\n+     * @param request  the request\n+     * @param response the response\n+     * @return the response entity\n+     */\n+    @PostMapping(path = '/' + OAuth20Constants.BASE_OAUTH20_URL + '/' + OAuth20Constants.REVOCATION_URL,\n+        produces = MediaType.APPLICATION_JSON_VALUE)\n+    public ModelAndView handleRequest(final HttpServletRequest request,\n+                                      final HttpServletResponse response) {\n+        val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n+\n+        if (!verifyRevocationRequest(context)) {\n+            LOGGER.error(\"Revocation request verification failed. Request is missing required parameters\");\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n+        val clientId = OAuth20Utils.getClientIdAndClientSecret(context).getLeft();\n+        val registeredService = getRegisteredServiceByClientId(clientId);\n+\n+        if (OAuth20Utils.doesServiceNeedAuthentication(registeredService)) {\n+            if (manager.get(true).isEmpty()) {\n+                LOGGER.error(\"Service [{}] requests authentication\", clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.ACCESS_DENIED);\n+            }\n+        } else {\n+            val service = getOAuthConfigurationContext().getWebApplicationServiceServiceFactory().createService(registeredService.getServiceId());\n+\n+            val audit = AuditableContext.builder()\n+                .service(service)\n+                .registeredService(registeredService)\n+                .build();\n+\n+            val accessResult = getOAuthConfigurationContext().getRegisteredServiceAccessStrategyEnforcer().execute(audit);\n+            if (accessResult.isExecutionFailure()) {\n+                return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+            }\n+        }\n+        val token = context.getRequestParameter(OAuth20Constants.TOKEN)\n+            .map(String::valueOf).orElse(StringUtils.EMPTY);\n+\n+        return generateRevocationResponse(token, clientId, response);\n+    }\n+\n+    /**\n+     * Generate revocation token response.\n+     *\n+     * @param token the token to revoke\n+     * @param clientId the client who requests the revocation\n+     * @param response the response\n+     * @return the model and view\n+     */\n+    protected ModelAndView generateRevocationResponse(final String token,\n+                                                      final String clientId,\n+                                                      final HttpServletResponse response) {\n+\n+        val registryToken = getOAuthConfigurationContext().getTicketRegistry().getTicket(token, OAuth20Token.class);\n+\n+        if (registryToken == null) {\n+            LOGGER.error(\"Provided token [{}] has not been found in the ticket registry\", token);\n+        } else if (isRefreshToken(registryToken) || isAccessToken(registryToken)) {\n+            if (!StringUtils.equals(clientId, registryToken.getClientId())) {\n+                LOGGER.error(\"Provided token [{}] has not been issued for the service [{}]\", token, clientId);\n+                return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+            }\n+\n+            if (isRefreshToken(registryToken)) {\n+                revokeToken((OAuth20RefreshToken) registryToken);\n+            } else {\n+                revokeToken(registryToken.getId());\n+            }\n+        } else {\n+            LOGGER.error(\"Provided token [{}] is either not a refresh token or not an access token\", token);\n+            return OAuth20Utils.writeError(response, OAuth20Constants.INVALID_REQUEST);\n+        }\n+\n+        val mv = new ModelAndView(new MappingJackson2JsonView());\n+        mv.setStatus(HttpStatus.OK);\n+        return mv;\n+    }\n+\n+    /**\n+     * Revoke the provided Refresh Token and it's related Access Tokens.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final OAuth20RefreshToken token) {\n+        revokeToken(token.getId());\n+\n+        token.getAccessTokens().forEach(item-> {\n+            revokeToken(item);\n+        });\n+    }\n+\n+    /**\n+     * Revoke the provided OAuth Token.\n+     *\n+     * @param token the token\n+     * @return the model and view\n+     */\n+    private void revokeToken(final String token) {\n+        LOGGER.debug(\"Revoking token [{}]\", token);\n+        getOAuthConfigurationContext().getTicketRegistry().deleteTicket(token);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwMzIxMA=="}, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDUxMzUyOnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth/src/test/java/org/apereo/cas/support/oauth/web/AbstractOAuth20Tests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwODoxNjoyMlrOF9eY6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzoxODo0NVrOF90EsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwNTM1Mw==", "bodyText": "Clean up protected static OAuthRegisteredService getRegisteredService(final String serviceId,                                                                 final String secret, final Set<OAuth20GrantTypes> grantTypes) {} to avoid duplicate code.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400005353", "createdAt": "2020-03-30T08:16:22Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth/src/test/java/org/apereo/cas/support/oauth/web/AbstractOAuth20Tests.java", "diffHunk": "@@ -321,6 +321,21 @@ protected static OAuthRegisteredService getRegisteredService(final String servic\n         return registeredServiceImpl;\n     }\n \n+    protected static OAuthRegisteredService getRegisteredService(final String serviceId,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2MDYyNQ==", "bodyText": "Right. Hope my future PRs will produce you less work...", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400360625", "createdAt": "2020-03-30T17:18:45Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth/src/test/java/org/apereo/cas/support/oauth/web/AbstractOAuth20Tests.java", "diffHunk": "@@ -321,6 +321,21 @@ protected static OAuthRegisteredService getRegisteredService(final String servic\n         return registeredServiceImpl;\n     }\n \n+    protected static OAuthRegisteredService getRegisteredService(final String serviceId,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwNTM1Mw=="}, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MDUxNjQ3OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth/src/test/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointControllerTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwODoxNzoxN1rOF9ea3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNzoxODo1NVrOF90FIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwNTg1Mw==", "bodyText": "Make private?", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400005853", "createdAt": "2020-03-30T08:17:17Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth/src/test/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointControllerTests.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.web.AbstractOAuth20Tests;\n+\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.mock.web.MockHttpServletRequest;\n+import org.springframework.mock.web.MockHttpServletResponse;\n+\n+import java.util.HashSet;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+/**\n+ * This class tests the {@link OAuth20RevocationEndpointController} class.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Tag(\"OAuth\")\n+public class OAuth20RevocationEndpointControllerTests extends AbstractOAuth20Tests {\n+\n+    public static final String PUBLIC_CLIENT_ID = \"clientWithoutSecret\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM2MDczOQ==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4771#discussion_r400360739", "createdAt": "2020-03-30T17:18:55Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth/src/test/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20RevocationEndpointControllerTests.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package org.apereo.cas.support.oauth.web.endpoints;\n+\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.web.AbstractOAuth20Tests;\n+\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Tag;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Qualifier;\n+import org.springframework.http.HttpMethod;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.mock.web.MockHttpServletRequest;\n+import org.springframework.mock.web.MockHttpServletResponse;\n+\n+import java.util.HashSet;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+/**\n+ * This class tests the {@link OAuth20RevocationEndpointController} class.\n+ *\n+ * @author Julien Huon\n+ * @since 6.2.0\n+ */\n+@Tag(\"OAuth\")\n+public class OAuth20RevocationEndpointControllerTests extends AbstractOAuth20Tests {\n+\n+    public static final String PUBLIC_CLIENT_ID = \"clientWithoutSecret\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDAwNTg1Mw=="}, "originalCommit": {"oid": "dd24ba6f6c313099f34a770aa3416c7e3c951606"}, "originalPosition": 31}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4087, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}