{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0MjY5NTM1", "number": 4984, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMzo1NTozMFrOE8u4tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDoxMzo0NVrOE_Ky1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTE4MTk3OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/validator/authorization/OAuth20AuthorizationCodeResponseTypeAuthorizationRequestValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMzo1NTozMFrOH5B66Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjo0Mjo0MVrOH5Lmnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2MjM0NQ==", "bodyText": "Should this really be a public method?", "url": "https://github.com/apereo/cas/pull/4984#discussion_r529562345", "createdAt": "2020-11-24T13:55:30Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/validator/authorization/OAuth20AuthorizationCodeResponseTypeAuthorizationRequestValidator.java", "diffHunk": "@@ -83,16 +82,85 @@ public boolean validate(final JEEContext context) {\n \n         if (accessResult.isExecutionFailure()) {\n             LOGGER.warn(\"Registered service [{}] is not found or is not authorized for access.\", registeredService);\n+\n+            setErrorDetails(context,\n+                OAuth20Constants.INVALID_REQUEST,\n+                StringUtils.EMPTY,\n+                false);\n+\n             return false;\n         }\n \n-        val redirectUri = request.getParameter(OAuth20Constants.REDIRECT_URI);\n         if (!OAuth20Utils.checkCallbackValid(registeredService, redirectUri)) {\n             LOGGER.warn(\"Callback URL [{}] is not authorized for registered service [{}].\", redirectUri, registeredService);\n+\n+            setErrorDetails(context,\n+                OAuth20Constants.INVALID_REQUEST,\n+                StringUtils.EMPTY,\n+                false);\n+\n+            return false;\n+        }\n+\n+        val authnRequest = request.getParameter(OAuth20Constants.REQUEST);\n+        if (StringUtils.isNotBlank(authnRequest)) {\n+            LOGGER.warn(\"Self-contained authentication requests as JWTs are not accepted\");\n+\n+            setErrorDetails(context,\n+                OAuth20Constants.REQUEST_NOT_SUPPORTED,\n+                StringUtils.EMPTY,\n+                true);\n+\n+            return false;\n+        }\n+\n+        val responseType = request.getParameter(OAuth20Constants.RESPONSE_TYPE);\n+        if (StringUtils.isBlank(responseType)) {\n+            setErrorDetails(context,\n+                OAuth20Constants.UNSUPPORTED_RESPONSE_TYPE,\n+                String.format(\"Missing required parameter: [%s]\", OAuth20Constants.RESPONSE_TYPE),\n+                true);\n+\n+            return false;\n+        }\n+\n+        if (!OAuth20Utils.checkResponseTypes(responseType, OAuth20ResponseTypes.values())) {\n+            LOGGER.warn(\"Response type [{}] is not found in the list of supported values [{}].\",\n+                responseType, OAuth20ResponseTypes.values());\n+\n+            setErrorDetails(context,\n+                OAuth20Constants.UNSUPPORTED_RESPONSE_TYPE,\n+                String.format(\"Unsupported response_type: [%s]\", responseType),\n+                true);\n+\n+            return false;\n+        }\n+\n+        if (!OAuth20Utils.isAuthorizedResponseTypeForService(context, registeredService)) {\n+            setErrorDetails(context,\n+                OAuth20Constants.UNAUTHORIZED_CLIENT,\n+                String.format(\"Client is not allowed to use the [%s] response_type\", responseType),\n+                true);\n+\n             return false;\n         }\n \n-        return OAuth20Utils.isAuthorizedResponseTypeForService(context, registeredService);\n+        return true;\n+    }\n+\n+    /**\n+     * Set the OAuth Error details in the context.\n+     *\n+     * @param context the context\n+     * @param error the OAuth error\n+     * @param errorDescription the OAuth error description\n+     * @param errorWithCallBack does the error will redirect the end-user to the client\n+     */\n+    public void setErrorDetails(final JEEContext context, final String error,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e18c7de3d96d4468293a2b9b773dfdeb5a890cd9"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyMDk5MQ==", "bodyText": "No, you're right.", "url": "https://github.com/apereo/cas/pull/4984#discussion_r529720991", "createdAt": "2020-11-24T16:42:41Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/validator/authorization/OAuth20AuthorizationCodeResponseTypeAuthorizationRequestValidator.java", "diffHunk": "@@ -83,16 +82,85 @@ public boolean validate(final JEEContext context) {\n \n         if (accessResult.isExecutionFailure()) {\n             LOGGER.warn(\"Registered service [{}] is not found or is not authorized for access.\", registeredService);\n+\n+            setErrorDetails(context,\n+                OAuth20Constants.INVALID_REQUEST,\n+                StringUtils.EMPTY,\n+                false);\n+\n             return false;\n         }\n \n-        val redirectUri = request.getParameter(OAuth20Constants.REDIRECT_URI);\n         if (!OAuth20Utils.checkCallbackValid(registeredService, redirectUri)) {\n             LOGGER.warn(\"Callback URL [{}] is not authorized for registered service [{}].\", redirectUri, registeredService);\n+\n+            setErrorDetails(context,\n+                OAuth20Constants.INVALID_REQUEST,\n+                StringUtils.EMPTY,\n+                false);\n+\n+            return false;\n+        }\n+\n+        val authnRequest = request.getParameter(OAuth20Constants.REQUEST);\n+        if (StringUtils.isNotBlank(authnRequest)) {\n+            LOGGER.warn(\"Self-contained authentication requests as JWTs are not accepted\");\n+\n+            setErrorDetails(context,\n+                OAuth20Constants.REQUEST_NOT_SUPPORTED,\n+                StringUtils.EMPTY,\n+                true);\n+\n+            return false;\n+        }\n+\n+        val responseType = request.getParameter(OAuth20Constants.RESPONSE_TYPE);\n+        if (StringUtils.isBlank(responseType)) {\n+            setErrorDetails(context,\n+                OAuth20Constants.UNSUPPORTED_RESPONSE_TYPE,\n+                String.format(\"Missing required parameter: [%s]\", OAuth20Constants.RESPONSE_TYPE),\n+                true);\n+\n+            return false;\n+        }\n+\n+        if (!OAuth20Utils.checkResponseTypes(responseType, OAuth20ResponseTypes.values())) {\n+            LOGGER.warn(\"Response type [{}] is not found in the list of supported values [{}].\",\n+                responseType, OAuth20ResponseTypes.values());\n+\n+            setErrorDetails(context,\n+                OAuth20Constants.UNSUPPORTED_RESPONSE_TYPE,\n+                String.format(\"Unsupported response_type: [%s]\", responseType),\n+                true);\n+\n+            return false;\n+        }\n+\n+        if (!OAuth20Utils.isAuthorizedResponseTypeForService(context, registeredService)) {\n+            setErrorDetails(context,\n+                OAuth20Constants.UNAUTHORIZED_CLIENT,\n+                String.format(\"Client is not allowed to use the [%s] response_type\", responseType),\n+                true);\n+\n             return false;\n         }\n \n-        return OAuth20Utils.isAuthorizedResponseTypeForService(context, registeredService);\n+        return true;\n+    }\n+\n+    /**\n+     * Set the OAuth Error details in the context.\n+     *\n+     * @param context the context\n+     * @param error the OAuth error\n+     * @param errorDescription the OAuth error description\n+     * @param errorWithCallBack does the error will redirect the end-user to the client\n+     */\n+    public void setErrorDetails(final JEEContext context, final String error,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2MjM0NQ=="}, "originalCommit": {"oid": "e18c7de3d96d4468293a2b9b773dfdeb5a890cd9"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMTE4NzIxOnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/validator/authorization/OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator.java", "isResolved": true, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMzo1NjozN1rOH5B-Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QyMjozMTo1NlrOH7Kd-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2MzE1NA==", "bodyText": "The class name seems rather odd to me. How about OAuth20ResponseTypeAuthorizationRequestValidator instead? You're validating the response type, and the validator contains a number of checks. Those checks don't need to be advertised in the class name.", "url": "https://github.com/apereo/cas/pull/4984#discussion_r529563154", "createdAt": "2020-11-24T13:56:37Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/validator/authorization/OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.apereo.cas.support.oauth.validator.authorization;\n+\n+import org.apereo.cas.audit.AuditableExecution;\n+import org.apereo.cas.authentication.principal.ServiceFactory;\n+import org.apereo.cas.authentication.principal.WebApplicationService;\n+import org.apereo.cas.services.ServicesManager;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.OAuth20ResponseTypes;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+\n+/**\n+ * This is {@link OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.3.0\n+ */\n+public class OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator extends OAuth20AuthorizationCodeResponseTypeAuthorizationRequestValidator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e18c7de3d96d4468293a2b9b773dfdeb5a890cd9"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyMjA1Nw==", "bodyText": "I wanted to stay consistent with the other class names but you're proposal is better. Will do it. :)", "url": "https://github.com/apereo/cas/pull/4984#discussion_r529722057", "createdAt": "2020-11-24T16:44:14Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/validator/authorization/OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.apereo.cas.support.oauth.validator.authorization;\n+\n+import org.apereo.cas.audit.AuditableExecution;\n+import org.apereo.cas.authentication.principal.ServiceFactory;\n+import org.apereo.cas.authentication.principal.WebApplicationService;\n+import org.apereo.cas.services.ServicesManager;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.OAuth20ResponseTypes;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+\n+/**\n+ * This is {@link OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.3.0\n+ */\n+public class OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator extends OAuth20AuthorizationCodeResponseTypeAuthorizationRequestValidator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2MzE1NA=="}, "originalCommit": {"oid": "e18c7de3d96d4468293a2b9b773dfdeb5a890cd9"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg5Mjc0Mw==", "bodyText": "Just a question.\nAll the current validators are related to the response_type parameter and if an authorization request is made without any response_type, none of the validators matches and it is rejected.\nWith this PR I want to still refuse them but to have all the error details in the context. That's why I added this one which will allow a request without or with an invalid response_type to be scanned by a validator. Should I just rename the class or try to find another supports logic in the Authorization validators? Or maybe to give to this class the lowest order?", "url": "https://github.com/apereo/cas/pull/4984#discussion_r529892743", "createdAt": "2020-11-24T21:35:30Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/validator/authorization/OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.apereo.cas.support.oauth.validator.authorization;\n+\n+import org.apereo.cas.audit.AuditableExecution;\n+import org.apereo.cas.authentication.principal.ServiceFactory;\n+import org.apereo.cas.authentication.principal.WebApplicationService;\n+import org.apereo.cas.services.ServicesManager;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.OAuth20ResponseTypes;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+\n+/**\n+ * This is {@link OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.3.0\n+ */\n+public class OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator extends OAuth20AuthorizationCodeResponseTypeAuthorizationRequestValidator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2MzE1NA=="}, "originalCommit": {"oid": "e18c7de3d96d4468293a2b9b773dfdeb5a890cd9"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEyMTkzNw==", "bodyText": "I see. In that case, none of the above :)\nWhat you should do is: in the super parent class, implement the response_type checking logic that you have here. When that passes, then you call an abstract protected method (defined by the super parent class) that is implemented by other validators who can do the job. This way, the common logic is contained within the parent class and not duplicated everywhere. It also helps you remove this class.\nSee AbstractPreAndPostProcessingAuthenticationHandler#authenticate for an example of doing pre/execution/post.", "url": "https://github.com/apereo/cas/pull/4984#discussion_r530121937", "createdAt": "2020-11-25T05:48:25Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/validator/authorization/OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.apereo.cas.support.oauth.validator.authorization;\n+\n+import org.apereo.cas.audit.AuditableExecution;\n+import org.apereo.cas.authentication.principal.ServiceFactory;\n+import org.apereo.cas.authentication.principal.WebApplicationService;\n+import org.apereo.cas.services.ServicesManager;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.OAuth20ResponseTypes;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+\n+/**\n+ * This is {@link OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.3.0\n+ */\n+public class OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator extends OAuth20AuthorizationCodeResponseTypeAuthorizationRequestValidator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2MzE1NA=="}, "originalCommit": {"oid": "e18c7de3d96d4468293a2b9b773dfdeb5a890cd9"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY0NjAyMw==", "bodyText": "Still have a question, sorry.\nToday, the right class is selected via a stream which is looking to a class where the supports method will respond true. All theses supports methods are looking for a particular value in the response_type parameter. When the right class is found, the validate method of the class found is called.\n        val validator = oauthAuthorizationRequestValidators\n            .stream()\n            .filter(b -> b.supports(context))\n            .findFirst()\n            .orElse(null);\n\n        if (validator == null) {\n            context.setRequestAttribute(OAuth20Constants.ERROR, OAuth20Constants.INVALID_REQUEST);\n            return false;\n        }\n        return validator.validate(context);\n\nSo, I guess I'll have to pre-validate the request in the supports method if we want to remove this class. Because, even if I do what you want, the validate method will never be called.\nI could add the logic needed and the error details will be in the context but an invalid request gonna be checked multiple times (as much as the number of validate class defined in the oauthAuthorizationRequestValidators class) instead of being rejected instantly.\nBecause a request without or with an invalid request could produce a callback if the client_id & the redirect_uri do exist in the request. I need to check them in pre-validate method which is more expensive than looking to a single parameter.\nIn the code, it's more elegant but I don't known if it's more performant. Unless I missed something? Like, maybe, check if an INVALID_REQUEST attribute already exists in the supports method because of a previous supports call? And I don't known if that is logic to pre-validate in the supports method.", "url": "https://github.com/apereo/cas/pull/4984#discussion_r530646023", "createdAt": "2020-11-25T21:15:06Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/validator/authorization/OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.apereo.cas.support.oauth.validator.authorization;\n+\n+import org.apereo.cas.audit.AuditableExecution;\n+import org.apereo.cas.authentication.principal.ServiceFactory;\n+import org.apereo.cas.authentication.principal.WebApplicationService;\n+import org.apereo.cas.services.ServicesManager;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.OAuth20ResponseTypes;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+\n+/**\n+ * This is {@link OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.3.0\n+ */\n+public class OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator extends OAuth20AuthorizationCodeResponseTypeAuthorizationRequestValidator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2MzE1NA=="}, "originalCommit": {"oid": "e18c7de3d96d4468293a2b9b773dfdeb5a890cd9"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDgyNDYxNA==", "bodyText": "So, I guess I'll have to pre-validate the request in the supports method if we want to remove this class.\n\nThat makes sense. You'd apply the strategy I pointed out earlier to the supports method. pre-validate in a parent class, and if it passes, let each child authorizer class decide if it can support the request. There should be no performance side-effects with multiple checking of the parameter's existence or value. My main concern is maintainability and readability. Let's make it work, and make it look good. Then, we'll make it fast[er] :)\n\nBecause a request without or with an invalid request could produce a callback if the client_id & the redirect_uri do exist in the request. I need to check them in pre-validate method which is more expensive than looking to a single parameter.\n\nCan you elaborate more please? By callback, you mean a redirect back to the application if the client_id & the redirect_uri do exist?", "url": "https://github.com/apereo/cas/pull/4984#discussion_r530824614", "createdAt": "2020-11-26T07:40:57Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/validator/authorization/OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.apereo.cas.support.oauth.validator.authorization;\n+\n+import org.apereo.cas.audit.AuditableExecution;\n+import org.apereo.cas.authentication.principal.ServiceFactory;\n+import org.apereo.cas.authentication.principal.WebApplicationService;\n+import org.apereo.cas.services.ServicesManager;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.OAuth20ResponseTypes;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+\n+/**\n+ * This is {@link OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.3.0\n+ */\n+public class OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator extends OAuth20AuthorizationCodeResponseTypeAuthorizationRequestValidator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2MzE1NA=="}, "originalCommit": {"oid": "e18c7de3d96d4468293a2b9b773dfdeb5a890cd9"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDg0NzQ0MQ==", "bodyText": "Can you elaborate more please? By callback, you mean a redirect back to the application if the client_id & the redirect_uri do exist?\n\nYes. When the client_id & the redirect_uri is valid you have to redirect the user-agent to the redirect_uri with parameters : state if any, error and an error_description if any.\nSo a big part of the actual validate method will be in the pre-validate method : check if a client_id & a redirect_uri do exist. Does the client_id exists in our configuration? Does the redirect_uri is valid for the client_id? And then, is the response_type valid or authorized for this client?", "url": "https://github.com/apereo/cas/pull/4984#discussion_r530847441", "createdAt": "2020-11-26T08:25:20Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/validator/authorization/OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.apereo.cas.support.oauth.validator.authorization;\n+\n+import org.apereo.cas.audit.AuditableExecution;\n+import org.apereo.cas.authentication.principal.ServiceFactory;\n+import org.apereo.cas.authentication.principal.WebApplicationService;\n+import org.apereo.cas.services.ServicesManager;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.OAuth20ResponseTypes;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+\n+/**\n+ * This is {@link OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.3.0\n+ */\n+public class OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator extends OAuth20AuthorizationCodeResponseTypeAuthorizationRequestValidator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2MzE1NA=="}, "originalCommit": {"oid": "e18c7de3d96d4468293a2b9b773dfdeb5a890cd9"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk5OTU5OQ==", "bodyText": "That makes sense to me. If pre-validate passes, you can then invoke validate, or optionally issue a redirect if data is available.", "url": "https://github.com/apereo/cas/pull/4984#discussion_r530999599", "createdAt": "2020-11-26T12:35:38Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/validator/authorization/OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.apereo.cas.support.oauth.validator.authorization;\n+\n+import org.apereo.cas.audit.AuditableExecution;\n+import org.apereo.cas.authentication.principal.ServiceFactory;\n+import org.apereo.cas.authentication.principal.WebApplicationService;\n+import org.apereo.cas.services.ServicesManager;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.OAuth20ResponseTypes;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+\n+/**\n+ * This is {@link OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.3.0\n+ */\n+public class OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator extends OAuth20AuthorizationCodeResponseTypeAuthorizationRequestValidator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2MzE1NA=="}, "originalCommit": {"oid": "e18c7de3d96d4468293a2b9b773dfdeb5a890cd9"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAxNzQ5OQ==", "bodyText": "Ok I'll do it.\nAbout the coverage, the code produced has a slightly better coverage than the existent one. If I can do even more I will. :)", "url": "https://github.com/apereo/cas/pull/4984#discussion_r531017499", "createdAt": "2020-11-26T13:08:17Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/validator/authorization/OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.apereo.cas.support.oauth.validator.authorization;\n+\n+import org.apereo.cas.audit.AuditableExecution;\n+import org.apereo.cas.authentication.principal.ServiceFactory;\n+import org.apereo.cas.authentication.principal.WebApplicationService;\n+import org.apereo.cas.services.ServicesManager;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.OAuth20ResponseTypes;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+\n+/**\n+ * This is {@link OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.3.0\n+ */\n+public class OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator extends OAuth20AuthorizationCodeResponseTypeAuthorizationRequestValidator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2MzE1NA=="}, "originalCommit": {"oid": "e18c7de3d96d4468293a2b9b773dfdeb5a890cd9"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc5OTU0Ng==", "bodyText": "Done.", "url": "https://github.com/apereo/cas/pull/4984#discussion_r531799546", "createdAt": "2020-11-27T22:31:56Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/validator/authorization/OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.apereo.cas.support.oauth.validator.authorization;\n+\n+import org.apereo.cas.audit.AuditableExecution;\n+import org.apereo.cas.authentication.principal.ServiceFactory;\n+import org.apereo.cas.authentication.principal.WebApplicationService;\n+import org.apereo.cas.services.ServicesManager;\n+import org.apereo.cas.support.oauth.OAuth20Constants;\n+import org.apereo.cas.support.oauth.OAuth20ResponseTypes;\n+import org.apereo.cas.support.oauth.util.OAuth20Utils;\n+\n+import lombok.val;\n+import org.apache.commons.lang3.StringUtils;\n+import org.pac4j.core.context.JEEContext;\n+\n+/**\n+ * This is {@link OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator}.\n+ *\n+ * @author Julien Huon\n+ * @since 6.3.0\n+ */\n+public class OAuth20MissingOrInvalidResponseTypeAuthorizationRequestValidator extends OAuth20AuthorizationCodeResponseTypeAuthorizationRequestValidator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU2MzE1NA=="}, "originalCommit": {"oid": "e18c7de3d96d4468293a2b9b773dfdeb5a890cd9"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NjcyNTk5OnYy", "diffSide": "RIGHT", "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20AuthorizeEndpointController.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxNDoxMzo0NVrOH8ubGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQyMDoxOTowN1rOH8-MLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzNzIxMA==", "bodyText": "This is not helpful. You need to, if you really want to, explain exactly what failed and how; the message here is very generic and it confuses more than it helps. If you don't have enough information to explain things, remove the line, specially if the error is tracked in logs via some other component.", "url": "https://github.com/apereo/cas/pull/4984#discussion_r533437210", "createdAt": "2020-12-01T14:13:45Z", "author": {"login": "mmoayyed"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20AuthorizeEndpointController.java", "diffHunk": "@@ -62,9 +63,13 @@ public ModelAndView handleRequest(final HttpServletRequest request,\n         val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n         val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n \n-        if (!verifyAuthorizeRequest(context) || !isRequestAuthenticated(manager)) {\n-            LOGGER.error(\"Authorize request verification failed. Authorization request is missing required parameters, \"\n-                + \"or the request is not authenticated and contains no authenticated profile/principal.\");\n+        if (context.getRequestAttribute(OAuth20Constants.ERROR).isPresent()) {\n+            LOGGER.error(\"Authorize request verification failed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "076c72ee4b2f66612105bcbd6981a3ffeee6fd54"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUxODU3Mg==", "bodyText": "Ok. I'll remove it because the other components are logging all the errors.", "url": "https://github.com/apereo/cas/pull/4984#discussion_r533518572", "createdAt": "2020-12-01T15:49:44Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20AuthorizeEndpointController.java", "diffHunk": "@@ -62,9 +63,13 @@ public ModelAndView handleRequest(final HttpServletRequest request,\n         val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n         val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n \n-        if (!verifyAuthorizeRequest(context) || !isRequestAuthenticated(manager)) {\n-            LOGGER.error(\"Authorize request verification failed. Authorization request is missing required parameters, \"\n-                + \"or the request is not authenticated and contains no authenticated profile/principal.\");\n+        if (context.getRequestAttribute(OAuth20Constants.ERROR).isPresent()) {\n+            LOGGER.error(\"Authorize request verification failed\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzNzIxMA=="}, "originalCommit": {"oid": "076c72ee4b2f66612105bcbd6981a3ffeee6fd54"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY5NTUzNQ==", "bodyText": "Done", "url": "https://github.com/apereo/cas/pull/4984#discussion_r533695535", "createdAt": "2020-12-01T20:19:07Z", "author": {"login": "julienhuon"}, "path": "support/cas-server-support-oauth-core-api/src/main/java/org/apereo/cas/support/oauth/web/endpoints/OAuth20AuthorizeEndpointController.java", "diffHunk": "@@ -62,9 +63,13 @@ public ModelAndView handleRequest(final HttpServletRequest request,\n         val context = new JEEContext(request, response, getOAuthConfigurationContext().getSessionStore());\n         val manager = new ProfileManager<CommonProfile>(context, context.getSessionStore());\n \n-        if (!verifyAuthorizeRequest(context) || !isRequestAuthenticated(manager)) {\n-            LOGGER.error(\"Authorize request verification failed. Authorization request is missing required parameters, \"\n-                + \"or the request is not authenticated and contains no authenticated profile/principal.\");\n+        if (context.getRequestAttribute(OAuth20Constants.ERROR).isPresent()) {\n+            LOGGER.error(\"Authorize request verification failed\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzNzIxMA=="}, "originalCommit": {"oid": "076c72ee4b2f66612105bcbd6981a3ffeee6fd54"}, "originalPosition": 18}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3997, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}