{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0MDgwNzgy", "number": 3696, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxMDoxMlrODYySzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxODoyNlrODYyaUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzE2NDI5OnYy", "diffSide": "RIGHT", "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxMDoxMlrOFe15ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxMDoxMlrOFe15ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NDY1MA==", "bodyText": "Do you think 10 seconds is enough? Maybe we use the stepTimeout from the cfg?", "url": "https://github.com/camunda-cloud/zeebe/pull/3696#discussion_r367884650", "createdAt": "2020-01-17T11:10:12Z", "author": {"login": "Zelldon"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "diffHunk": "@@ -208,16 +207,40 @@ protected void before() throws IOException {\n \n   @Override\n   protected void after() {\n+    final var latch = new CountDownLatch(brokers.size());\n+    brokers\n+        .values()\n+        .parallelStream()\n+        .forEach(\n+            broker -> {\n+              broker.close();\n+              latch.countDown();\n+            });\n \n-    brokers.values().parallelStream().forEach(Broker::close);\n+    // wait until the brokers are shutdown before deleting their data, otherwise exceptions will be\n+    // thrown and cause developers to waste time figuring out that they aren't production bugs\n+    try {\n+      latch.await(10, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "339e308027fe023abe37c5f7f00c66ca328a3f33"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzE2NTI1OnYy", "diffSide": "RIGHT", "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxMDozNlrOFe16EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMjozNjoxOVrOFe3vFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NDgxNw==", "bodyText": "Who did this before?", "url": "https://github.com/camunda-cloud/zeebe/pull/3696#discussion_r367884817", "createdAt": "2020-01-17T11:10:36Z", "author": {"login": "Zelldon"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "diffHunk": "@@ -208,16 +207,40 @@ protected void before() throws IOException {\n \n   @Override\n   protected void after() {\n+    final var latch = new CountDownLatch(brokers.size());\n+    brokers\n+        .values()\n+        .parallelStream()\n+        .forEach(\n+            broker -> {\n+              broker.close();\n+              latch.countDown();\n+            });\n \n-    brokers.values().parallelStream().forEach(Broker::close);\n+    // wait until the brokers are shutdown before deleting their data, otherwise exceptions will be\n+    // thrown and cause developers to waste time figuring out that they aren't production bugs\n+    try {\n+      latch.await(10, TimeUnit.SECONDS);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      LOG.warn(\"Interrupted while waiting for {} brokers to close\", brokers.size());\n+    }\n+\n+    for (final var base : brokerBases.entrySet()) {\n+      try {\n+        FileUtil.deleteFolder(base.getValue().getAbsolutePath());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "339e308027fe023abe37c5f7f00c66ca328a3f33"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NTQ3MQ==", "bodyText": "Ah I see it is done in the closeables. But why not anymore? Brokers should be closed now right?", "url": "https://github.com/camunda-cloud/zeebe/pull/3696#discussion_r367885471", "createdAt": "2020-01-17T11:12:24Z", "author": {"login": "Zelldon"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "diffHunk": "@@ -208,16 +207,40 @@ protected void before() throws IOException {\n \n   @Override\n   protected void after() {\n+    final var latch = new CountDownLatch(brokers.size());\n+    brokers\n+        .values()\n+        .parallelStream()\n+        .forEach(\n+            broker -> {\n+              broker.close();\n+              latch.countDown();\n+            });\n \n-    brokers.values().parallelStream().forEach(Broker::close);\n+    // wait until the brokers are shutdown before deleting their data, otherwise exceptions will be\n+    // thrown and cause developers to waste time figuring out that they aren't production bugs\n+    try {\n+      latch.await(10, TimeUnit.SECONDS);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      LOG.warn(\"Interrupted while waiting for {} brokers to close\", brokers.size());\n+    }\n+\n+    for (final var base : brokerBases.entrySet()) {\n+      try {\n+        FileUtil.deleteFolder(base.getValue().getAbsolutePath());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NDgxNw=="}, "originalCommit": {"oid": "339e308027fe023abe37c5f7f00c66ca328a3f33"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxMTEyNQ==", "bodyText": "I'm actually not sure why we keep track of the folders here and also in the closeables to be honest. My issue with closeables is basically that keeping track of resources differently (i.e. one is the resource itself, another is a closure capturing it) led to out of memory errors for me (since we removed things from brokerBase and brokers but not closeables).\nSo like I said, I'm actually not sure what the gain of closeables is for the brokers if we keep track of those values in another map anyway \ud83d\ude05", "url": "https://github.com/camunda-cloud/zeebe/pull/3696#discussion_r367911125", "createdAt": "2020-01-17T12:25:26Z", "author": {"login": "npepinpe"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "diffHunk": "@@ -208,16 +207,40 @@ protected void before() throws IOException {\n \n   @Override\n   protected void after() {\n+    final var latch = new CountDownLatch(brokers.size());\n+    brokers\n+        .values()\n+        .parallelStream()\n+        .forEach(\n+            broker -> {\n+              broker.close();\n+              latch.countDown();\n+            });\n \n-    brokers.values().parallelStream().forEach(Broker::close);\n+    // wait until the brokers are shutdown before deleting their data, otherwise exceptions will be\n+    // thrown and cause developers to waste time figuring out that they aren't production bugs\n+    try {\n+      latch.await(10, TimeUnit.SECONDS);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      LOG.warn(\"Interrupted while waiting for {} brokers to close\", brokers.size());\n+    }\n+\n+    for (final var base : brokerBases.entrySet()) {\n+      try {\n+        FileUtil.deleteFolder(base.getValue().getAbsolutePath());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NDgxNw=="}, "originalCommit": {"oid": "339e308027fe023abe37c5f7f00c66ca328a3f33"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxNDc3Mw==", "bodyText": "Furthermore if we use a temp folder rule, this should cleanup by himself right?", "url": "https://github.com/camunda-cloud/zeebe/pull/3696#discussion_r367914773", "createdAt": "2020-01-17T12:36:19Z", "author": {"login": "Zelldon"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "diffHunk": "@@ -208,16 +207,40 @@ protected void before() throws IOException {\n \n   @Override\n   protected void after() {\n+    final var latch = new CountDownLatch(brokers.size());\n+    brokers\n+        .values()\n+        .parallelStream()\n+        .forEach(\n+            broker -> {\n+              broker.close();\n+              latch.countDown();\n+            });\n \n-    brokers.values().parallelStream().forEach(Broker::close);\n+    // wait until the brokers are shutdown before deleting their data, otherwise exceptions will be\n+    // thrown and cause developers to waste time figuring out that they aren't production bugs\n+    try {\n+      latch.await(10, TimeUnit.SECONDS);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      LOG.warn(\"Interrupted while waiting for {} brokers to close\", brokers.size());\n+    }\n+\n+    for (final var base : brokerBases.entrySet()) {\n+      try {\n+        FileUtil.deleteFolder(base.getValue().getAbsolutePath());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NDgxNw=="}, "originalCommit": {"oid": "339e308027fe023abe37c5f7f00c66ca328a3f33"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzE3MDc5OnYy", "diffSide": "RIGHT", "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxMzowMlrOFe19dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMjoyNjo0MVrOFe3idg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NTY4NQ==", "bodyText": "nice catch", "url": "https://github.com/camunda-cloud/zeebe/pull/3696#discussion_r367885685", "createdAt": "2020-01-17T11:13:02Z", "author": {"login": "Zelldon"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "diffHunk": "@@ -511,6 +532,7 @@ public void stopBroker(final int nodeId) {\n           broker.getConfig().getNetwork().getCommandApi().getAddress();\n       final List<Integer> brokersLeadingPartitions = getBrokersLeadingPartitions(socketAddress);\n       broker.close();\n+      closeables.remove(broker);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "339e308027fe023abe37c5f7f00c66ca328a3f33"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NjE1Nw==", "bodyText": "So close was also called twice? But this should be cleared after the test class?\nAh ok and if you run a test in a loop this piles up right", "url": "https://github.com/camunda-cloud/zeebe/pull/3696#discussion_r367886157", "createdAt": "2020-01-17T11:14:19Z", "author": {"login": "Zelldon"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "diffHunk": "@@ -511,6 +532,7 @@ public void stopBroker(final int nodeId) {\n           broker.getConfig().getNetwork().getCommandApi().getAddress();\n       final List<Integer> brokersLeadingPartitions = getBrokersLeadingPartitions(socketAddress);\n       broker.close();\n+      closeables.remove(broker);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NTY4NQ=="}, "originalCommit": {"oid": "339e308027fe023abe37c5f7f00c66ca328a3f33"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NzQ1NQ==", "bodyText": "Where do you see that the brokers are added to the closeables? Haven't found this in the code?", "url": "https://github.com/camunda-cloud/zeebe/pull/3696#discussion_r367887455", "createdAt": "2020-01-17T11:17:48Z", "author": {"login": "Zelldon"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "diffHunk": "@@ -511,6 +532,7 @@ public void stopBroker(final int nodeId) {\n           broker.getConfig().getNetwork().getCommandApi().getAddress();\n       final List<Integer> brokersLeadingPartitions = getBrokersLeadingPartitions(socketAddress);\n       broker.close();\n+      closeables.remove(broker);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NTY4NQ=="}, "originalCommit": {"oid": "339e308027fe023abe37c5f7f00c66ca328a3f33"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkxMTU0Mg==", "bodyText": "Uh, you're right, they aren't. I added it because I ran into this issue in the past and had to do that, apparently it was already removed, my bad \ud83d\ude05 Makes more sense to not have the brokers managed by closeables anyway", "url": "https://github.com/camunda-cloud/zeebe/pull/3696#discussion_r367911542", "createdAt": "2020-01-17T12:26:41Z", "author": {"login": "npepinpe"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "diffHunk": "@@ -511,6 +532,7 @@ public void stopBroker(final int nodeId) {\n           broker.getConfig().getNetwork().getCommandApi().getAddress();\n       final List<Integer> brokersLeadingPartitions = getBrokersLeadingPartitions(socketAddress);\n       broker.close();\n+      closeables.remove(broker);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NTY4NQ=="}, "originalCommit": {"oid": "339e308027fe023abe37c5f7f00c66ca328a3f33"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MzE4MzUzOnYy", "diffSide": "LEFT", "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxODoyNlrOFe2FSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxMToxODoyNlrOFe2FSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NzY4OQ==", "bodyText": "Ah the parallel stream directly returns after beeing called?", "url": "https://github.com/camunda-cloud/zeebe/pull/3696#discussion_r367887689", "createdAt": "2020-01-17T11:18:26Z", "author": {"login": "Zelldon"}, "path": "qa/integration-tests/src/test/java/io/zeebe/broker/it/clustering/ClusteringRule.java", "diffHunk": "@@ -208,16 +207,40 @@ protected void before() throws IOException {\n \n   @Override\n   protected void after() {\n+    final var latch = new CountDownLatch(brokers.size());\n+    brokers\n+        .values()\n+        .parallelStream()\n+        .forEach(\n+            broker -> {\n+              broker.close();\n+              latch.countDown();\n+            });\n \n-    brokers.values().parallelStream().forEach(Broker::close);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "339e308027fe023abe37c5f7f00c66ca328a3f33"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 32, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}