{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDczOTgwNDg5", "number": 5244, "title": "Prepare 0.24 for rolling upgrade", "bodyText": "Description\nAllows 0.24 brokers to deserialize messages sent from 0.25 brokers, making it possible for a 0.24 cluster to be rolled to 0.25. I've ran the rolling update test with the 0.25 changes and it works.\nRelated issues\ncloses #5104\nDefinition of Done\nNot all items need to be done depending on the issue and the pull request.\nCode changes:\n\n The changes are backwards compatibility with previous versions\n If it fixes a bug then PRs are created to backport the fix to the last two minor versions\n\nTesting:\n\n There are unit/integration tests that verify all acceptance criterias of the issue\n New tests are written to ensure backwards compatibility with further versions\n The behavior is tested manually\n The impact of the changes is verified by a benchmark\n\nDocumentation:\n\n The documentation is updated (e.g. BPMN reference, configuration, examples, get-started guides, etc.)\n New content is added to the release announcement", "createdAt": "2020-08-26T15:19:48Z", "url": "https://github.com/camunda-cloud/zeebe/pull/5244", "merged": true, "mergeCommit": {"oid": "930a33d899fb911380ca68c3fd656eff6058a218"}, "closed": true, "closedAt": "2020-08-27T13:22:57Z", "author": {"login": "MiguelPires"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdC-t6mgBqjM2OTkxNzY4OTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdC_imrABqjM2OTkzODcwMTM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "050bef31c747421e332788175ade8fa34f60c5a6", "author": {"user": null}, "url": "https://github.com/camunda-cloud/zeebe/commit/050bef31c747421e332788175ade8fa34f60c5a6", "committedDate": "2020-08-26T13:50:43Z", "message": "chore(atomix): disable Kryo logs"}, "afterCommit": {"oid": "159a323f4e24df2a009a9503aba69dafd5ad430b", "author": {"user": null}, "url": "https://github.com/camunda-cloud/zeebe/commit/159a323f4e24df2a009a9503aba69dafd5ad430b", "committedDate": "2020-08-27T11:26:22Z", "message": "chore(atomix): disable Kryo logs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NjI4NjQ2", "url": "https://github.com/camunda-cloud/zeebe/pull/5244#pullrequestreview-476628646", "createdAt": "2020-08-27T11:32:32Z", "commit": {"oid": "159a323f4e24df2a009a9503aba69dafd5ad430b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMTozMjozMlrOHIMDyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxMTo0NDowNlrOHIMbVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0ODIzNQ==", "bodyText": "It would be good not to tie implementation with the interface. So I would move this method out and put it in the NamespaceImpl.", "url": "https://github.com/camunda-cloud/zeebe/pull/5244#discussion_r478348235", "createdAt": "2020-08-27T11:32:32Z", "author": {"login": "deepthidevaki"}, "path": "atomix/utils/src/main/java/io/atomix/utils/serializer/Namespace.java", "diffHunk": "@@ -260,388 +64,16 @@ public void serialize(final Object obj, final OutputStream stream, final int buf\n    * @param <T> deserialized Object type\n    * @return deserialized Object\n    */\n-  public <T> T deserialize(final ByteBuffer buffer) {\n-    final Kryo kryo = borrow();\n-    try (final ByteBufferInput in = new ByteBufferInput(buffer)) {\n-      @SuppressWarnings(\"unchecked\")\n-      final T obj = (T) kryo.readClassAndObject(in);\n-      return obj;\n-    } finally {\n-      release(kryo);\n-    }\n-  }\n-\n-  /**\n-   * Deserializes given InputStream to an Object using Kryo instance in pool.\n-   *\n-   * @param stream input stream\n-   * @param <T> deserialized Object type\n-   * @return deserialized Object\n-   */\n-  public <T> T deserialize(final InputStream stream) {\n-    return deserialize(stream, DEFAULT_BUFFER_SIZE);\n-  }\n+  <T> T deserialize(final ByteBuffer buffer);\n \n-  /**\n-   * Deserializes given InputStream to an Object using Kryo instance in pool.\n-   *\n-   * @param stream input stream\n-   * @param <T> deserialized Object type\n-   * @param bufferSize size of the buffer in front of the stream\n-   * @return deserialized Object\n-   */\n-  public <T> T deserialize(final InputStream stream, final int bufferSize) {\n-    final Kryo kryo = borrow();\n-    try (final ByteBufferInput in = new ByteBufferInput(stream, bufferSize)) {\n-      @SuppressWarnings(\"unchecked\")\n-      final T obj = (T) kryo.readClassAndObject(in);\n-      return obj;\n-    } finally {\n-      release(kryo);\n-    }\n-  }\n-\n-  private String friendlyName() {\n-    return friendlyName;\n-  }\n+  ImmutableList<RegistrationBlock> getRegisteredBlocks();\n \n   /**\n-   * Gets the number of classes registered in this Kryo namespace.\n-   *\n-   * @return size of namespace\n-   */\n-  public int size() {\n-    return (int) registeredBlocks.stream().flatMap(block -> block.types().stream()).count();\n-  }\n-\n-  /**\n-   * Creates a Kryo instance.\n-   *\n-   * @return Kryo instance\n-   */\n-  @Override\n-  public Kryo create() {\n-    LOGGER.trace(\"Creating Kryo instance for {}\", this);\n-    final Kryo kryo = new Kryo();\n-    kryo.setClassLoader(classLoader);\n-    kryo.setRegistrationRequired(registrationRequired);\n-\n-    // If compatible serialization is enabled, override the default serializer.\n-    if (compatible) {\n-      kryo.setDefaultSerializer(CompatibleFieldSerializer::new);\n-    }\n-\n-    // TODO rethink whether we want to use StdInstantiatorStrategy\n-    kryo.setInstantiatorStrategy(\n-        new Kryo.DefaultInstantiatorStrategy(new StdInstantiatorStrategy()));\n-\n-    for (final RegistrationBlock block : registeredBlocks) {\n-      int id = block.begin();\n-      if (id == FLOATING_ID) {\n-        id = kryo.getNextRegistrationId();\n-      }\n-      for (final Pair<Class<?>[], Serializer<?>> entry : block.types()) {\n-        register(kryo, entry.getLeft(), entry.getRight(), id++);\n-      }\n-    }\n-    return kryo;\n-  }\n-\n-  /**\n-   * Register {@code type} and {@code serializer} to {@code kryo} instance.\n+   * Creates a new {@link Namespace} builder.\n    *\n-   * @param kryo Kryo instance\n-   * @param types types to register\n-   * @param serializer Specific serializer to register or null to use default.\n-   * @param id type registration id to use\n+   * @return builder\n    */\n-  private void register(\n-      final Kryo kryo, final Class<?>[] types, final Serializer<?> serializer, final int id) {\n-    final Registration existing = kryo.getRegistration(id);\n-    if (existing != null) {\n-      boolean matches = false;\n-      for (final Class<?> type : types) {\n-        if (existing.getType() == type) {\n-          matches = true;\n-          break;\n-        }\n-      }\n-\n-      if (!matches) {\n-        LOGGER.error(\n-            \"{}: Failed to register {} as {}, {} was already registered.\",\n-            friendlyName(),\n-            types,\n-            id,\n-            existing.getType());\n-\n-        throw new IllegalStateException(\n-            String.format(\n-                \"Failed to register %s as %s, %s was already registered.\",\n-                Arrays.toString(types), id, existing.getType()));\n-      }\n-      // falling through to register call for now.\n-      // Consider skipping, if there's reasonable\n-      // way to compare serializer equivalence.\n-    }\n-\n-    for (final Class<?> type : types) {\n-      Registration r = null;\n-      if (serializer == null) {\n-        r = kryo.register(type, id);\n-      } else if (type.isInterface()) {\n-        kryo.addDefaultSerializer(type, serializer);\n-      } else {\n-        r = kryo.register(type, serializer, id);\n-      }\n-      if (r != null) {\n-        if (r.getId() != id) {\n-          LOGGER.debug(\n-              \"{}: {} already registered as {}. Skipping {}.\",\n-              friendlyName(),\n-              r.getType(),\n-              r.getId(),\n-              id);\n-        }\n-        LOGGER.trace(\"{} registered as {}\", r.getType(), r.getId());\n-      }\n-    }\n-  }\n-\n-  @Override\n-  public Kryo borrow() {\n-    return kryoPool.borrow();\n-  }\n-\n-  @Override\n-  public void release(final Kryo kryo) {\n-    kryoPool.release(kryo);\n-  }\n-\n-  @Override\n-  public <T> T run(final KryoCallback<T> callback) {\n-    return kryoPool.run(callback);\n-  }\n-\n-  @Override\n-  public String toString() {\n-    if (!friendlyName.equals(NO_NAME)) {\n-      return MoreObjects.toStringHelper(getClass())\n-          .omitNullValues()\n-          .add(\"friendlyName\", friendlyName)\n-          // omit lengthy detail, when there's a name\n-          .toString();\n-    }\n-    return MoreObjects.toStringHelper(getClass())\n-        .add(\"registeredBlocks\", registeredBlocks)\n-        .toString();\n-  }\n-\n-  /** KryoNamespace builder. */\n-  // @NotThreadSafe\n-  public static final class Builder {\n-    private int blockHeadId = INITIAL_ID;\n-    private List<Pair<Class<?>[], Serializer<?>>> types = new ArrayList<>();\n-    private final List<RegistrationBlock> blocks = new ArrayList<>();\n-    private ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n-    private boolean registrationRequired = true;\n-    private boolean compatible = false;\n-\n-    /**\n-     * Builds a {@link Namespace} instance.\n-     *\n-     * @return KryoNamespace\n-     */\n-    public Namespace build() {\n-      return build(NO_NAME);\n-    }\n-\n-    /**\n-     * Builds a {@link Namespace} instance.\n-     *\n-     * @param friendlyName friendly name for the namespace\n-     * @return KryoNamespace\n-     */\n-    public Namespace build(final String friendlyName) {\n-      if (!types.isEmpty()) {\n-        blocks.add(new RegistrationBlock(this.blockHeadId, types));\n-      }\n-      return new Namespace(blocks, classLoader, registrationRequired, compatible, friendlyName)\n-          .populate(1);\n-    }\n-\n-    /**\n-     * Sets the next Kryo registration Id for following register entries.\n-     *\n-     * @param id Kryo registration Id\n-     * @return this\n-     * @see Kryo#register(Class, Serializer, int)\n-     */\n-    public Builder nextId(final int id) {\n-      if (!types.isEmpty()) {\n-        if (id != FLOATING_ID && id < blockHeadId + types.size()) {\n-\n-          if (LOGGER.isWarnEnabled()) {\n-            LOGGER.warn(\n-                \"requested nextId {} could potentially overlap \"\n-                    + \"with existing registrations {}+{} \",\n-                id,\n-                blockHeadId,\n-                types.size(),\n-                new RuntimeException());\n-          }\n-        }\n-        blocks.add(new RegistrationBlock(this.blockHeadId, types));\n-        types = new ArrayList<>();\n-      }\n-      this.blockHeadId = id;\n-      return this;\n-    }\n-\n-    /**\n-     * Registers classes to be serialized using Kryo default serializer.\n-     *\n-     * @param expectedTypes list of classes\n-     * @return this\n-     */\n-    public Builder register(final Class<?>... expectedTypes) {\n-      for (final Class<?> clazz : expectedTypes) {\n-        types.add(Pair.of(new Class<?>[] {clazz}, null));\n-      }\n-      return this;\n-    }\n-\n-    /**\n-     * Registers serializer for the given set of classes.\n-     *\n-     * <p>When multiple classes are registered with an explicitly provided serializer, the namespace\n-     * guarantees all instances will be serialized with the same type ID.\n-     *\n-     * @param classes list of classes to register\n-     * @param serializer serializer to use for the class\n-     * @return this\n-     */\n-    public Builder register(final Serializer<?> serializer, final Class<?>... classes) {\n-      types.add(Pair.of(classes, checkNotNull(serializer)));\n-      return this;\n-    }\n-\n-    private Builder register(final RegistrationBlock block) {\n-      if (block.begin() != FLOATING_ID) {\n-        // flush pending types\n-        nextId(block.begin());\n-        blocks.add(block);\n-        nextId(block.begin() + block.types().size());\n-      } else {\n-        // flush pending types\n-        final int addedBlockBegin = blockHeadId + types.size();\n-        nextId(addedBlockBegin);\n-        blocks.add(new RegistrationBlock(addedBlockBegin, block.types()));\n-        nextId(addedBlockBegin + block.types().size());\n-      }\n-      return this;\n-    }\n-\n-    /**\n-     * Registers all the class registered to given KryoNamespace.\n-     *\n-     * @param ns KryoNamespace\n-     * @return this\n-     */\n-    public Builder register(final Namespace ns) {\n-\n-      if (blocks.containsAll(ns.registeredBlocks)) {\n-        // Everything was already registered.\n-        LOGGER.debug(\"Ignoring {}, already registered.\", ns);\n-        return this;\n-      }\n-      for (final RegistrationBlock block : ns.registeredBlocks) {\n-        this.register(block);\n-      }\n-      return this;\n-    }\n-\n-    /**\n-     * Sets the namespace class loader.\n-     *\n-     * @param classLoader the namespace class loader\n-     * @return the namespace builder\n-     */\n-    public Builder setClassLoader(final ClassLoader classLoader) {\n-      this.classLoader = classLoader;\n-      return this;\n-    }\n-\n-    /**\n-     * Sets whether backwards/forwards compatible versioned serialization is enabled.\n-     *\n-     * <p>When compatible serialization is enabled, the {@link CompatibleFieldSerializer} will be\n-     * set as the default serializer for types that do not otherwise explicitly specify a\n-     * serializer.\n-     *\n-     * @param compatible whether versioned serialization is enabled\n-     * @return this\n-     */\n-    public Builder setCompatible(final boolean compatible) {\n-      this.compatible = compatible;\n-      return this;\n-    }\n-\n-    /**\n-     * Sets the registrationRequired flag.\n-     *\n-     * @param registrationRequired Kryo's registrationRequired flag\n-     * @return this\n-     * @see Kryo#setRegistrationRequired(boolean)\n-     */\n-    public Builder setRegistrationRequired(final boolean registrationRequired) {\n-      this.registrationRequired = registrationRequired;\n-      return this;\n-    }\n-  }\n-\n-  static final class RegistrationBlock {\n-    private final int begin;\n-    private final ImmutableList<Pair<Class<?>[], Serializer<?>>> types;\n-\n-    RegistrationBlock(final int begin, final List<Pair<Class<?>[], Serializer<?>>> types) {\n-      this.begin = begin;\n-      this.types = ImmutableList.copyOf(types);\n-    }\n-\n-    public int begin() {\n-      return begin;\n-    }\n-\n-    public ImmutableList<Pair<Class<?>[], Serializer<?>>> types() {\n-      return types;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-      return types.hashCode();\n-    }\n-\n-    // Only the registered types are used for equality.\n-    @Override\n-    public boolean equals(final Object obj) {\n-      if (this == obj) {\n-        return true;\n-      }\n-\n-      if (obj instanceof RegistrationBlock) {\n-        final RegistrationBlock that = (RegistrationBlock) obj;\n-        return Objects.equals(this.types, that.types);\n-      }\n-      return false;\n-    }\n-\n-    @Override\n-    public String toString() {\n-      return MoreObjects.toStringHelper(getClass())\n-          .add(\"begin\", begin)\n-          .add(\"types\", types)\n-          .toString();\n-    }\n+  static NamespaceImpl.Builder builder() {\n+    return new NamespaceImpl.Builder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159a323f4e24df2a009a9503aba69dafd5ad430b"}, "originalPosition": 651}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0OTY0Ng==", "bodyText": "A broker running this version always serialize with fallback, but deserialize with the new one. Is that ideal? A cluster running with all 0.24.x broker then always have to fallback when deserializing. Not sure how much performance impact it will have.", "url": "https://github.com/camunda-cloud/zeebe/pull/5244#discussion_r478349646", "createdAt": "2020-08-27T11:35:32Z", "author": {"login": "deepthidevaki"}, "path": "atomix/utils/src/main/java/io/atomix/utils/serializer/FallbackNamespace.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.utils.serializer;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.atomix.utils.serializer.NamespaceImpl.Builder;\n+import io.atomix.utils.serializer.NamespaceImpl.RegistrationBlock;\n+import java.nio.ByteBuffer;\n+import org.slf4j.Logger;\n+\n+public class FallbackNamespace implements Namespace {\n+\n+  private static final Logger LOG = getLogger(FallbackNamespace.class);\n+  private static final String DESERIALIZE_ERROR =\n+      \"Deserialization failed with both the versioned and fallback serializers. The fallback serializer failed with:\\n %s\";\n+  private final Namespace fallback;\n+  private final Namespace namespace;\n+\n+  FallbackNamespace(final Namespace fallback, final Namespace namespace) {\n+    this.fallback = fallback;\n+    this.namespace = namespace;\n+  }\n+\n+  public FallbackNamespace(final NamespaceImpl.Builder builder) {\n+    final Builder copy = builder.copy();\n+    this.fallback = builder.build();\n+    this.namespace = copy.name(copy.getName() + \"-compatible\").setCompatible(true).build();\n+  }\n+\n+  /**\n+   * Serializes given object to byte array using Kryo instance in pool.\n+   *\n+   * <p>Note: Serialized bytes must be smaller than {@link NamespaceImpl#MAX_BUFFER_SIZE}.\n+   *\n+   * @param obj Object to serialize\n+   * @return serialized bytes\n+   */\n+  public byte[] serialize(final Object obj) {\n+    return fallback.serialize(obj);\n+  }\n+\n+  /**\n+   * Serializes given object to byte array using Kryo instance in pool.\n+   *\n+   * @param obj Object to serialize\n+   * @param bufferSize maximum size of serialized bytes\n+   * @return serialized bytes\n+   */\n+  public byte[] serialize(final Object obj, final int bufferSize) {\n+    return fallback.serialize(obj, bufferSize);\n+  }\n+\n+  /**\n+   * Serializes given object to byte buffer using Kryo instance in pool.\n+   *\n+   * @param obj Object to serialize\n+   * @param buffer to write to\n+   */\n+  public void serialize(final Object obj, final ByteBuffer buffer) {\n+    fallback.serialize(obj, buffer);\n+  }\n+\n+  /**\n+   * Deserializes given byte array to Object using Kryo instance in pool.\n+   *\n+   * @param bytes serialized bytes\n+   * @param <T> deserialized Object type\n+   * @return deserialized Object\n+   */\n+  public <T> T deserialize(final byte[] bytes) {\n+    try {\n+      return namespace.deserialize(bytes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159a323f4e24df2a009a9503aba69dafd5ad430b"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1MDY1MQ==", "bodyText": "I think that namespace should be the current one and fallback should be the new one because we have to use fallback only during rolling upgrade to 0.25.x.", "url": "https://github.com/camunda-cloud/zeebe/pull/5244#discussion_r478350651", "createdAt": "2020-08-27T11:37:27Z", "author": {"login": "deepthidevaki"}, "path": "atomix/utils/src/main/java/io/atomix/utils/serializer/FallbackNamespace.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.utils.serializer;\n+\n+import static org.slf4j.LoggerFactory.getLogger;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.atomix.utils.serializer.NamespaceImpl.Builder;\n+import io.atomix.utils.serializer.NamespaceImpl.RegistrationBlock;\n+import java.nio.ByteBuffer;\n+import org.slf4j.Logger;\n+\n+public class FallbackNamespace implements Namespace {\n+\n+  private static final Logger LOG = getLogger(FallbackNamespace.class);\n+  private static final String DESERIALIZE_ERROR =\n+      \"Deserialization failed with both the versioned and fallback serializers. The fallback serializer failed with:\\n %s\";\n+  private final Namespace fallback;\n+  private final Namespace namespace;\n+\n+  FallbackNamespace(final Namespace fallback, final Namespace namespace) {\n+    this.fallback = fallback;\n+    this.namespace = namespace;\n+  }\n+\n+  public FallbackNamespace(final NamespaceImpl.Builder builder) {\n+    final Builder copy = builder.copy();\n+    this.fallback = builder.build();\n+    this.namespace = copy.name(copy.getName() + \"-compatible\").setCompatible(true).build();\n+  }\n+\n+  /**\n+   * Serializes given object to byte array using Kryo instance in pool.\n+   *\n+   * <p>Note: Serialized bytes must be smaller than {@link NamespaceImpl#MAX_BUFFER_SIZE}.\n+   *\n+   * @param obj Object to serialize\n+   * @return serialized bytes\n+   */\n+  public byte[] serialize(final Object obj) {\n+    return fallback.serialize(obj);\n+  }\n+\n+  /**\n+   * Serializes given object to byte array using Kryo instance in pool.\n+   *\n+   * @param obj Object to serialize\n+   * @param bufferSize maximum size of serialized bytes\n+   * @return serialized bytes\n+   */\n+  public byte[] serialize(final Object obj, final int bufferSize) {\n+    return fallback.serialize(obj, bufferSize);\n+  }\n+\n+  /**\n+   * Serializes given object to byte buffer using Kryo instance in pool.\n+   *\n+   * @param obj Object to serialize\n+   * @param buffer to write to\n+   */\n+  public void serialize(final Object obj, final ByteBuffer buffer) {\n+    fallback.serialize(obj, buffer);\n+  }\n+\n+  /**\n+   * Deserializes given byte array to Object using Kryo instance in pool.\n+   *\n+   * @param bytes serialized bytes\n+   * @param <T> deserialized Object type\n+   * @return deserialized Object\n+   */\n+  public <T> T deserialize(final byte[] bytes) {\n+    try {\n+      return namespace.deserialize(bytes);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0OTY0Ng=="}, "originalCommit": {"oid": "159a323f4e24df2a009a9503aba69dafd5ad430b"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NDI2MQ==", "bodyText": "Why is this required?", "url": "https://github.com/camunda-cloud/zeebe/pull/5244#discussion_r478354261", "createdAt": "2020-08-27T11:44:06Z", "author": {"login": "deepthidevaki"}, "path": "broker/src/test/java/io/zeebe/broker/logstreams/AtomixLogDeletionServiceTest.java", "diffHunk": "@@ -147,7 +147,7 @@ private void createSnapshot(final long index) {\n     try {\n       return builder\n           // hardcode max segment size to allow a single entry only\n-          .withMaxSegmentSize(JournalSegmentDescriptor.BYTES + 8 * Integer.BYTES)\n+          .withMaxSegmentSize(JournalSegmentDescriptor.BYTES + 9 * Integer.BYTES)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "159a323f4e24df2a009a9503aba69dafd5ad430b"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NjYxMjg1", "url": "https://github.com/camunda-cloud/zeebe/pull/5244#pullrequestreview-476661285", "createdAt": "2020-08-27T12:17:26Z", "commit": {"oid": "7dc95fb05b9ab7fb2e8e8b35d55f46bceca67bd8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3f1b79f5e7277e791c7a8ed553245340560dded", "author": {"user": null}, "url": "https://github.com/camunda-cloud/zeebe/commit/b3f1b79f5e7277e791c7a8ed553245340560dded", "committedDate": "2020-08-27T12:26:40Z", "message": "chore(atomix): prepare 0.24 for rolling upgrade"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e546940a59eaa7eb43f42e148d1240fba259f28", "author": {"user": null}, "url": "https://github.com/camunda-cloud/zeebe/commit/1e546940a59eaa7eb43f42e148d1240fba259f28", "committedDate": "2020-08-27T12:26:42Z", "message": "chore(atomix): disable Kryo logs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7dc95fb05b9ab7fb2e8e8b35d55f46bceca67bd8", "author": {"user": null}, "url": "https://github.com/camunda-cloud/zeebe/commit/7dc95fb05b9ab7fb2e8e8b35d55f46bceca67bd8", "committedDate": "2020-08-27T12:02:51Z", "message": "chore(atomix): review feedback"}, "afterCommit": {"oid": "1e546940a59eaa7eb43f42e148d1240fba259f28", "author": {"user": null}, "url": "https://github.com/camunda-cloud/zeebe/commit/1e546940a59eaa7eb43f42e148d1240fba259f28", "committedDate": "2020-08-27T12:26:42Z", "message": "chore(atomix): disable Kryo logs"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2568, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}