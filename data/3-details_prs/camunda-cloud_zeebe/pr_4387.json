{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5NDcxNzky", "number": 4387, "title": "Refactor cluster event service", "bodyText": "Description\n\nUse member properties to propagate subscription info instead of custom gossip\nEventService can now only  broadcast. Methods for unicast and send are removed from the interface.\n\nRelated issues\n\ncloses #4154\ncloses #4307\nPull Request Checklist\n\n All commit messages match our commit message guidelines\n The submitting code follows our code style\n If submitting code, please run mvn clean install -DskipTests locally before committing", "createdAt": "2020-04-27T12:34:03Z", "url": "https://github.com/camunda-cloud/zeebe/pull/4387", "merged": true, "mergeCommit": {"oid": "86d86d15d562593bbf3cc8edf9a59413a9877860"}, "closed": true, "closedAt": "2020-04-29T12:22:04Z", "author": {"login": "deepthidevaki"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcb8aQMgFqTQwMTQ4NzM0NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABccWgxSABqjMyODQxMDEyOTg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxNDg3MzQ1", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#pullrequestreview-401487345", "createdAt": "2020-04-28T04:22:55Z", "commit": {"oid": "ee87cca00b00b957df4e9a0d08f087727ec47925"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwNDoyMjo1NlrOGNB6DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwNDo0MToxOVrOGNCP4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNTkxNw==", "bodyText": "These properties are always send via gossip? Can it happen that we have an different update like our broker address or something similar, which doesn't contain the subscription name and then we remove all subscriptions here?", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416315917", "createdAt": "2020-04-28T04:22:56Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/main/java/io/atomix/cluster/messaging/impl/DefaultClusterEventService.java", "diffHunk": "@@ -354,77 +202,64 @@ public boolean isRunning() {\n   @Override\n   public CompletableFuture<Void> stop() {\n     if (started.compareAndSet(true, false)) {\n-      if (gossipExecutor != null) {\n-        gossipExecutor.shutdown();\n+      if (eventServiceExecutor != null) {\n+        eventServiceExecutor.shutdown();\n       }\n       LOGGER.info(\"Stopped\");\n     }\n     return CompletableFuture.completedFuture(null);\n   }\n \n-  /** Internal message. */\n-  private static class InternalMessage {\n-    private final Type type;\n-    private final byte[] payload;\n-\n-    InternalMessage(final Type type, final byte[] payload) {\n-      this.type = type;\n-      this.payload = payload;\n-    }\n-\n-    /**\n-     * Returns the message type.\n-     *\n-     * @return the message type\n-     */\n-    public Type type() {\n-      return type;\n-    }\n-\n-    /**\n-     * Returns the payload.\n-     *\n-     * @return the payload\n-     */\n-    public byte[] payload() {\n-      return payload;\n-    }\n-\n-    private enum Type {\n-      DIRECT,\n-      ALL,\n-    }\n+  @Override\n+  public void event(final ClusterMembershipEvent event) {\n+    eventServiceExecutor.execute(\n+        () -> {\n+          switch (event.type()) {\n+            case MEMBER_ADDED:\n+              updateRemoteSubscription(event);\n+              break;\n+            case METADATA_CHANGED:\n+              updateRemoteSubscription(event);\n+              break;\n+            case REACHABILITY_CHANGED:\n+              break;\n+            case MEMBER_REMOVED:\n+              removeAllSubscription(event.subject().id());\n+              break;\n+            default:\n+              LOGGER.warn(\n+                  \"Unexpected membership event type {} from {}\", event.type(), event.subject());\n+          }\n+        });\n   }\n \n-  /** Subscriber iterator that iterates subscribers in a loop. */\n-  private static class TopicIterator implements Iterator<InternalSubscriptionInfo> {\n-    private final AtomicInteger counter = new AtomicInteger();\n-    private final InternalSubscriptionInfo[] subscribers;\n-\n-    TopicIterator(final List<InternalSubscriptionInfo> subscribers) {\n-      final List<InternalSubscriptionInfo> filteredSubscribers =\n-          subscribers.stream().filter(s -> !s.isTombstone()).collect(Collectors.toList());\n-      Collections.reverse(filteredSubscribers);\n-      this.subscribers =\n-          filteredSubscribers.toArray(new InternalSubscriptionInfo[filteredSubscribers.size()]);\n-    }\n-\n-    @Override\n-    public boolean hasNext() {\n-      return subscribers.length > 0;\n+  private void removeAllSubscription(final MemberId id) {\n+    final Set<String> prevSubscriptions = remoteMemberSubscriptions.remove(id);\n+    if (prevSubscriptions != null) {\n+      prevSubscriptions.forEach(s -> topics.get(s).removeRemoteSubscription(id));\n     }\n+  }\n \n-    @Override\n-    public InternalSubscriptionInfo next() {\n-      return subscribers[Math.abs(counter.incrementAndGet() % subscribers.length)];\n+  private void updateRemoteSubscription(final ClusterMembershipEvent event) {\n+    final String topicSubscribedAsString =\n+        event.subject().properties().getProperty(SUBSCRIPTION_PROPERTY_NAME);\n+    if (topicSubscribedAsString != null) {\n+      final Set<String> topicsSubscribed = topicsFromString(topicSubscribedAsString);\n+      topicsSubscribed.forEach(\n+          topic ->\n+              topics\n+                  .computeIfAbsent(topic, t -> new InternalTopic(topic))\n+                  .addRemoteSubscription(event.subject().id()));\n+      remoteMemberSubscriptions.put(event.subject().id(), topicsSubscribed);\n+    } else {\n+      removeAllSubscription(event.subject().id());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee87cca00b00b957df4e9a0d08f087727ec47925"}, "originalPosition": 428}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNjM2MA==", "bodyText": "Do we really need here a concurrent data structure?", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416316360", "createdAt": "2020-04-28T04:24:26Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/main/java/io/atomix/cluster/messaging/impl/DefaultClusterEventService.java", "diffHunk": "@@ -354,77 +202,64 @@ public boolean isRunning() {\n   @Override\n   public CompletableFuture<Void> stop() {\n     if (started.compareAndSet(true, false)) {\n-      if (gossipExecutor != null) {\n-        gossipExecutor.shutdown();\n+      if (eventServiceExecutor != null) {\n+        eventServiceExecutor.shutdown();\n       }\n       LOGGER.info(\"Stopped\");\n     }\n     return CompletableFuture.completedFuture(null);\n   }\n \n-  /** Internal message. */\n-  private static class InternalMessage {\n-    private final Type type;\n-    private final byte[] payload;\n-\n-    InternalMessage(final Type type, final byte[] payload) {\n-      this.type = type;\n-      this.payload = payload;\n-    }\n-\n-    /**\n-     * Returns the message type.\n-     *\n-     * @return the message type\n-     */\n-    public Type type() {\n-      return type;\n-    }\n-\n-    /**\n-     * Returns the payload.\n-     *\n-     * @return the payload\n-     */\n-    public byte[] payload() {\n-      return payload;\n-    }\n-\n-    private enum Type {\n-      DIRECT,\n-      ALL,\n-    }\n+  @Override\n+  public void event(final ClusterMembershipEvent event) {\n+    eventServiceExecutor.execute(\n+        () -> {\n+          switch (event.type()) {\n+            case MEMBER_ADDED:\n+              updateRemoteSubscription(event);\n+              break;\n+            case METADATA_CHANGED:\n+              updateRemoteSubscription(event);\n+              break;\n+            case REACHABILITY_CHANGED:\n+              break;\n+            case MEMBER_REMOVED:\n+              removeAllSubscription(event.subject().id());\n+              break;\n+            default:\n+              LOGGER.warn(\n+                  \"Unexpected membership event type {} from {}\", event.type(), event.subject());\n+          }\n+        });\n   }\n \n-  /** Subscriber iterator that iterates subscribers in a loop. */\n-  private static class TopicIterator implements Iterator<InternalSubscriptionInfo> {\n-    private final AtomicInteger counter = new AtomicInteger();\n-    private final InternalSubscriptionInfo[] subscribers;\n-\n-    TopicIterator(final List<InternalSubscriptionInfo> subscribers) {\n-      final List<InternalSubscriptionInfo> filteredSubscribers =\n-          subscribers.stream().filter(s -> !s.isTombstone()).collect(Collectors.toList());\n-      Collections.reverse(filteredSubscribers);\n-      this.subscribers =\n-          filteredSubscribers.toArray(new InternalSubscriptionInfo[filteredSubscribers.size()]);\n-    }\n-\n-    @Override\n-    public boolean hasNext() {\n-      return subscribers.length > 0;\n+  private void removeAllSubscription(final MemberId id) {\n+    final Set<String> prevSubscriptions = remoteMemberSubscriptions.remove(id);\n+    if (prevSubscriptions != null) {\n+      prevSubscriptions.forEach(s -> topics.get(s).removeRemoteSubscription(id));\n     }\n+  }\n \n-    @Override\n-    public InternalSubscriptionInfo next() {\n-      return subscribers[Math.abs(counter.incrementAndGet() % subscribers.length)];\n+  private void updateRemoteSubscription(final ClusterMembershipEvent event) {\n+    final String topicSubscribedAsString =\n+        event.subject().properties().getProperty(SUBSCRIPTION_PROPERTY_NAME);\n+    if (topicSubscribedAsString != null) {\n+      final Set<String> topicsSubscribed = topicsFromString(topicSubscribedAsString);\n+      topicsSubscribed.forEach(\n+          topic ->\n+              topics\n+                  .computeIfAbsent(topic, t -> new InternalTopic(topic))\n+                  .addRemoteSubscription(event.subject().id()));\n+      remoteMemberSubscriptions.put(event.subject().id(), topicsSubscribed);\n+    } else {\n+      removeAllSubscription(event.subject().id());\n     }\n   }\n \n   /** Internal subscriber. */\n   private static class InternalSubscriber\n       implements BiFunction<Address, byte[], CompletableFuture<byte[]>> {\n-    private final AtomicInteger counter = new AtomicInteger();\n-    private InternalSubscription[] subscriptions = new InternalSubscription[0];\n+    private final List<InternalSubscription> subscriptions = new CopyOnWriteArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee87cca00b00b957df4e9a0d08f087727ec47925"}, "originalPosition": 437}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNzEzNg==", "bodyText": "Do you know why this is synchronized? Is this really necessary?", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416317136", "createdAt": "2020-04-28T04:27:00Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/main/java/io/atomix/cluster/messaging/impl/DefaultClusterEventService.java", "diffHunk": "@@ -702,58 +418,34 @@ TopicIterator iterator() {\n      *\n      * @param subscription the subscription to add\n      */\n-    synchronized void addRemoteSubscription(final InternalSubscriptionInfo subscription) {\n+    synchronized void addRemoteSubscription(final MemberId subscription) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee87cca00b00b957df4e9a0d08f087727ec47925"}, "originalPosition": 647}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNzM2OA==", "bodyText": "I would assume not, since we are using here a concurrent hash set.", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416317368", "createdAt": "2020-04-28T04:27:54Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/main/java/io/atomix/cluster/messaging/impl/DefaultClusterEventService.java", "diffHunk": "@@ -702,58 +418,34 @@ TopicIterator iterator() {\n      *\n      * @param subscription the subscription to add\n      */\n-    synchronized void addRemoteSubscription(final InternalSubscriptionInfo subscription) {\n+    synchronized void addRemoteSubscription(final MemberId subscription) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNzEzNg=="}, "originalCommit": {"oid": "ee87cca00b00b957df4e9a0d08f087727ec47925"}, "originalPosition": 647}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxODMyNg==", "bodyText": "I think distinct is not necessary here, since you're using a set.", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416318326", "createdAt": "2020-04-28T04:30:56Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/main/java/io/atomix/cluster/messaging/impl/DefaultClusterEventService.java", "diffHunk": "@@ -193,154 +142,53 @@ public DefaultClusterEventService(\n     return ImmutableList.copyOf(topic.localSubscriber().subscriptions());\n   }\n \n-  /**\n-   * Returns a collection of nodes that subscribe to the given topic.\n-   *\n-   * @param topicName the topic for which to return the collection of subscriber nodes\n-   * @return the collection of subscribers for the given topic\n-   */\n-  private Stream<MemberId> getSubscriberNodes(final String topicName) {\n-    final InternalTopic topic = topics.get(topicName);\n-    if (topic == null) {\n-      return Stream.empty();\n-    }\n-    return topic.remoteSubscriptions().stream()\n-        .filter(s -> !s.isTombstone())\n-        .map(s -> s.memberId())\n-        .distinct();\n-  }\n-\n-  /**\n-   * Returns the next node ID for the given message topic.\n-   *\n-   * @param topicName the topic for which to return the next node ID\n-   * @return the next node ID for the given message topic\n-   */\n-  private MemberId getNextMemberId(final String topicName) {\n+  @Override\n+  public Set<MemberId> getSubscribers(final String topicName) {\n     final InternalTopic topic = topics.get(topicName);\n     if (topic == null) {\n-      return null;\n-    }\n-\n-    final TopicIterator iterator = topic.iterator();\n-    if (iterator.hasNext()) {\n-      return iterator.next().memberId();\n+      return Set.of();\n     }\n-    return null;\n+    return topic.remoteSubscriptions();\n   }\n \n   /**\n-   * Handles a collection of subscription updates received via the gossip protocol.\n+   * Returns a collection of nodes that subscribe to the given topic.\n    *\n-   * @param subscriptions a collection of subscriptions provided by the sender\n+   * @param topicName the topic for which to return the collection of subscriber nodes\n+   * @return the collection of subscribers for the given topic\n    */\n-  private void update(final Collection<InternalSubscriptionInfo> subscriptions) {\n-    for (final InternalSubscriptionInfo subscription : subscriptions) {\n-      final InternalTopic topic = topics.computeIfAbsent(subscription.topic, InternalTopic::new);\n-      final InternalSubscriptionInfo matchingSubscription =\n-          topic.remoteSubscriptions().stream()\n-              .filter(\n-                  s ->\n-                      s.memberId().equals(subscription.memberId())\n-                          && s.logicalTimestamp().equals(subscription.logicalTimestamp()))\n-              .findFirst()\n-              .orElse(null);\n-      if (matchingSubscription == null) {\n-        topic.addRemoteSubscription(subscription);\n-      } else if (subscription.isTombstone()) {\n-        topic.removeRemoteSubscription(subscription);\n-      }\n-    }\n-  }\n-\n-  /** Sends a gossip message to an active peer. */\n-  private void gossip() {\n-    final List<Member> members =\n-        membershipService.getMembers().stream()\n-            .filter(node -> !localMemberId.equals(node.id()))\n-            .filter(node -> node.isReachable())\n-            .collect(Collectors.toList());\n-\n-    if (!members.isEmpty()) {\n-      Collections.shuffle(members);\n-      final Member member = members.get(0);\n-      updateNode(member);\n-    }\n+  private Stream<MemberId> getSubscriberNodes(final String topicName) {\n+    return getSubscribers(topicName).stream().distinct();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee87cca00b00b957df4e9a0d08f087727ec47925"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMyMTUwNw==", "bodyText": "This is not used anymore or?", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416321507", "createdAt": "2020-04-28T04:41:19Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/cluster/messaging/impl/DefaultClusterEventServiceTest.java", "diffHunk": "@@ -54,6 +59,16 @@\n public class DefaultClusterEventServiceTest {\n   private static final Serializer SERIALIZER = Serializer.using(Namespaces.BASIC);\n \n+  private final TestMessagingServiceFactory messagingServiceFactory =\n+      new TestMessagingServiceFactory();\n+  private final TestUnicastServiceFactory unicastServiceFactory = new TestUnicastServiceFactory();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee87cca00b00b957df4e9a0d08f087727ec47925"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxNjQ1NTY1", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#pullrequestreview-401645565", "createdAt": "2020-04-28T09:12:00Z", "commit": {"oid": "68df3812c9a636ef82355f86ae6dca528ec62c88"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwOToxMjowMFrOGNKg1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwOToxMjowMFrOGNKg1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ1NjkxOQ==", "bodyText": "On the local things I'm a bit unsure to remove that. This means it can happen that we remove one and concurrently add one; could this be a problem? That I end in a state where I actually subscribed but I'm not registered correctly?\nBut actually adding only happens on starting and removing on closing phase right? So probably this will never happen concurrently? \ud83e\udd37", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#discussion_r416456919", "createdAt": "2020-04-28T09:12:00Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/main/java/io/atomix/cluster/messaging/impl/DefaultClusterEventService.java", "diffHunk": "@@ -403,7 +403,7 @@ InternalSubscriber localSubscriber() {\n      *\n      * @param subscription the subscription to unregister\n      */\n-    private synchronized CompletableFuture<Void> removeLocalSubscription(\n+    private CompletableFuture<Void> removeLocalSubscription(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68df3812c9a636ef82355f86ae6dca528ec62c88"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyNTIyNzgw", "url": "https://github.com/camunda-cloud/zeebe/pull/4387#pullrequestreview-402522780", "createdAt": "2020-04-29T09:58:41Z", "commit": {"oid": "931101f9161800e3db4bf87593cc1665104acf90"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81636dfa97a93178c3c611d9d0e205d19c9e2941", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/81636dfa97a93178c3c611d9d0e205d19c9e2941", "committedDate": "2020-04-29T11:09:16Z", "message": "chore(atomix): refactor DefaultClusterEventService\n\n * use member properties to propogate event subscription info instead of custom gossip"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "931101f9161800e3db4bf87593cc1665104acf90", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/931101f9161800e3db4bf87593cc1665104acf90", "committedDate": "2020-04-29T06:07:09Z", "message": "chore(atomix): fix multiple local subscriptions on same topic"}, "afterCommit": {"oid": "81636dfa97a93178c3c611d9d0e205d19c9e2941", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/81636dfa97a93178c3c611d9d0e205d19c9e2941", "committedDate": "2020-04-29T11:09:16Z", "message": "chore(atomix): refactor DefaultClusterEventService\n\n * use member properties to propogate event subscription info instead of custom gossip"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2863, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}