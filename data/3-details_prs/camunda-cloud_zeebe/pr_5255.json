{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1Mjg4Nzcx", "number": 5255, "title": "Take snapshots at same index if either exporter or processor position changed", "bodyText": "Description\n\nMove snapshot related interfaces and classes to new module zeebe-snapshots\nUse mock implementation of snapshot stores in raft tests\nSplit PersistedSnapshotStore interface\nAdd exported position and processor position to snapshot id\nTake snapshot if either exporter or processor position has changed\n\nRelated issues\n\ncloses #4922\nDefinition of Done\nNot all items need to be done depending on the issue and the pull request.\nCode changes:\n\n The changes are backwards compatibility with previous versions\n If it fixes a bug then PRs are created to backport the fix to the last two minor versions\n\nTesting:\n\n There are unit/integration tests that verify all acceptance criterias of the issue\n New tests are written to ensure backwards compatibility with further versions\n The behavior is tested manually\n The impact of the changes is verified by a benchmark\n\nDocumentation:\n\n The documentation is updated (e.g. BPMN reference, configuration, examples, get-started guides, etc.)\n New content is added to the release announcement", "createdAt": "2020-08-28T09:17:18Z", "url": "https://github.com/camunda-cloud/zeebe/pull/5255", "merged": true, "mergeCommit": {"oid": "5ead32107ff74122309d7b9651b760cc3c6bff69"}, "closed": true, "closedAt": "2020-09-01T08:59:14Z", "author": {"login": "deepthidevaki"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdDTydPgBqjM3MDM2MjI4NTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdEjBuxABqjM3MTM1MzAyNzI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9f7ec170282b71f2528e586a6e32c49476500bb8", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/9f7ec170282b71f2528e586a6e32c49476500bb8", "committedDate": "2020-08-28T09:49:50Z", "message": "chore(snapshots): improve documentation"}, "afterCommit": {"oid": "5e18ceedb01ec29e99d2ca819e1e17565a891c59", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/5e18ceedb01ec29e99d2ca819e1e17565a891c59", "committedDate": "2020-08-28T12:01:50Z", "message": "chore(snapshots): fix for backward compatibility"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3NjQ4NjQx", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#pullrequestreview-477648641", "createdAt": "2020-08-28T11:22:47Z", "commit": {"oid": "9f7ec170282b71f2528e586a6e32c49476500bb8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMToyMjo0N1rOHI9RYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMjo0OTowMFrOHJDWMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTE1NDUzMQ==", "bodyText": "Should be assertAllNodesHaveSnapshotWithIndex", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479154531", "createdAt": "2020-08-28T11:22:47Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -347,7 +343,7 @@ public void shouldReplicateSnapshotToOldLeaderAfterRestart() throws Exception {\n     raftRule.joinCluster(leader);\n \n     // then\n-    assertThat(raftRule.allNodesHaveSnapshotWithIndex(200)).isTrue();\n+    raftRule.assertallNodesHaveSnapshotWithIndex(200);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f7ec170282b71f2528e586a6e32c49476500bb8"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTE1Nzk0Nw==", "bodyText": "I assume this can be removed ? :D", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479157947", "createdAt": "2020-08-28T11:25:53Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/snapshot/InMemorySnapshot.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.snapshots.raft.PersistedSnapshot;\n+import io.zeebe.snapshots.raft.ReceivedSnapshot;\n+import io.zeebe.snapshots.raft.SnapshotChunk;\n+import io.zeebe.snapshots.raft.SnapshotChunkReader;\n+import io.zeebe.util.StringUtil;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.NavigableMap;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import org.agrona.concurrent.UnsafeBuffer;\n+import org.slf4j.LoggerFactory;\n+\n+public class InMemorySnapshot implements PersistedSnapshot, ReceivedSnapshot {\n+\n+  private final TestSnapshotStore testSnapshotStore;\n+  private final long index;\n+  private final long term;\n+  private final WallClockTimestamp timestamp;\n+  private final String id;\n+  private final NavigableMap<String, String> chunks = new TreeMap<>();\n+  private ByteBuffer nextExpected;\n+\n+  InMemorySnapshot(final TestSnapshotStore testSnapshotStore, final String snapshotId) {\n+    this.testSnapshotStore = testSnapshotStore;\n+    id = snapshotId;\n+    final var parts = snapshotId.split(\"-\");\n+    index = Long.parseLong(parts[0]);\n+    term = Long.parseLong(parts[1]);\n+    timestamp = WallClockTimestamp.from(Long.parseLong(parts[2]));\n+  }\n+\n+  InMemorySnapshot(\n+      final TestSnapshotStore testSnapshotStore,\n+      final long index,\n+      final long term,\n+      final WallClockTimestamp timestamp) {\n+    this.testSnapshotStore = testSnapshotStore;\n+    this.index = index;\n+    this.term = term;\n+    this.timestamp = timestamp;\n+    this.id = String.format(\"%d-%d-%d\", index, term, timestamp.unixTimestamp());\n+  }\n+\n+  public static InMemorySnapshot newPersistedSnapshot(\n+      final long index, final long term, final int size, final TestSnapshotStore snapshotStore) {\n+    final var snapshot = new InMemorySnapshot(snapshotStore, index, term, new WallClockTimestamp());\n+    for (int i = 0; i < size; i++) {\n+      snapshot.writeChunks(\"chunk-\" + i, \"test\".getBytes());\n+    }\n+    snapshot.persist();\n+    return snapshot;\n+  }\n+\n+  void writeChunks(final String id, final byte[] chunk) {\n+    chunks.put(id, StringUtil.fromBytes(chunk));\n+  }\n+\n+  @Override\n+  public WallClockTimestamp getTimestamp() {\n+    return timestamp;\n+  }\n+\n+  @Override\n+  public int version() {\n+    return 1;\n+  }\n+\n+  @Override\n+  public long getIndex() {\n+    return index;\n+  }\n+\n+  @Override\n+  public long getTerm() {\n+    return term;\n+  }\n+\n+  @Override\n+  public SnapshotChunkReader newChunkReader() {\n+    return new SnapshotChunkReader() {\n+      private NavigableMap<String, String> iterator = chunks;\n+\n+      @Override\n+      public void seek(final ByteBuffer id) {\n+        final var chunkId = byteBufferToString(id);\n+        iterator = chunks.tailMap(chunkId, true);\n+      }\n+\n+      @Override\n+      public ByteBuffer nextId() {\n+        if (!hasNext()) {\n+          return null;\n+        }\n+        return ByteBuffer.wrap(iterator.firstEntry().getKey().getBytes());\n+      }\n+\n+      @Override\n+      public void close() {\n+        iterator = null;\n+      }\n+\n+      @Override\n+      public boolean hasNext() {\n+        return !iterator.isEmpty();\n+      }\n+\n+      @Override\n+      public SnapshotChunk next() {\n+        final var nextEntry = iterator.firstEntry();\n+        LoggerFactory.getLogger(\"FINDME\").info(\"Returning next chunk Id = {}\", nextEntry.getKey());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f7ec170282b71f2528e586a6e32c49476500bb8"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTE1ODY1NA==", "bodyText": "Maybe we have something like that already in io.zeebe.util.BufferUtil", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479158654", "createdAt": "2020-08-28T11:26:32Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/snapshot/InMemorySnapshot.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Copyright \u00a9 2020 camunda services GmbH (info@camunda.com)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.atomix.raft.snapshot;\n+\n+import io.atomix.utils.time.WallClockTimestamp;\n+import io.zeebe.snapshots.raft.PersistedSnapshot;\n+import io.zeebe.snapshots.raft.ReceivedSnapshot;\n+import io.zeebe.snapshots.raft.SnapshotChunk;\n+import io.zeebe.snapshots.raft.SnapshotChunkReader;\n+import io.zeebe.util.StringUtil;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Path;\n+import java.util.NavigableMap;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import org.agrona.concurrent.UnsafeBuffer;\n+import org.slf4j.LoggerFactory;\n+\n+public class InMemorySnapshot implements PersistedSnapshot, ReceivedSnapshot {\n+\n+  private final TestSnapshotStore testSnapshotStore;\n+  private final long index;\n+  private final long term;\n+  private final WallClockTimestamp timestamp;\n+  private final String id;\n+  private final NavigableMap<String, String> chunks = new TreeMap<>();\n+  private ByteBuffer nextExpected;\n+\n+  InMemorySnapshot(final TestSnapshotStore testSnapshotStore, final String snapshotId) {\n+    this.testSnapshotStore = testSnapshotStore;\n+    id = snapshotId;\n+    final var parts = snapshotId.split(\"-\");\n+    index = Long.parseLong(parts[0]);\n+    term = Long.parseLong(parts[1]);\n+    timestamp = WallClockTimestamp.from(Long.parseLong(parts[2]));\n+  }\n+\n+  InMemorySnapshot(\n+      final TestSnapshotStore testSnapshotStore,\n+      final long index,\n+      final long term,\n+      final WallClockTimestamp timestamp) {\n+    this.testSnapshotStore = testSnapshotStore;\n+    this.index = index;\n+    this.term = term;\n+    this.timestamp = timestamp;\n+    this.id = String.format(\"%d-%d-%d\", index, term, timestamp.unixTimestamp());\n+  }\n+\n+  public static InMemorySnapshot newPersistedSnapshot(\n+      final long index, final long term, final int size, final TestSnapshotStore snapshotStore) {\n+    final var snapshot = new InMemorySnapshot(snapshotStore, index, term, new WallClockTimestamp());\n+    for (int i = 0; i < size; i++) {\n+      snapshot.writeChunks(\"chunk-\" + i, \"test\".getBytes());\n+    }\n+    snapshot.persist();\n+    return snapshot;\n+  }\n+\n+  void writeChunks(final String id, final byte[] chunk) {\n+    chunks.put(id, StringUtil.fromBytes(chunk));\n+  }\n+\n+  @Override\n+  public WallClockTimestamp getTimestamp() {\n+    return timestamp;\n+  }\n+\n+  @Override\n+  public int version() {\n+    return 1;\n+  }\n+\n+  @Override\n+  public long getIndex() {\n+    return index;\n+  }\n+\n+  @Override\n+  public long getTerm() {\n+    return term;\n+  }\n+\n+  @Override\n+  public SnapshotChunkReader newChunkReader() {\n+    return new SnapshotChunkReader() {\n+      private NavigableMap<String, String> iterator = chunks;\n+\n+      @Override\n+      public void seek(final ByteBuffer id) {\n+        final var chunkId = byteBufferToString(id);\n+        iterator = chunks.tailMap(chunkId, true);\n+      }\n+\n+      @Override\n+      public ByteBuffer nextId() {\n+        if (!hasNext()) {\n+          return null;\n+        }\n+        return ByteBuffer.wrap(iterator.firstEntry().getKey().getBytes());\n+      }\n+\n+      @Override\n+      public void close() {\n+        iterator = null;\n+      }\n+\n+      @Override\n+      public boolean hasNext() {\n+        return !iterator.isEmpty();\n+      }\n+\n+      @Override\n+      public SnapshotChunk next() {\n+        final var nextEntry = iterator.firstEntry();\n+        LoggerFactory.getLogger(\"FINDME\").info(\"Returning next chunk Id = {}\", nextEntry.getKey());\n+        iterator = chunks.tailMap(nextEntry.getKey(), false);\n+        return new TestSnapshotChunkImpl(\n+            id, nextEntry.getKey(), StringUtil.getBytes(nextEntry.getValue()), chunks.size());\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public void delete() {}\n+\n+  @Override\n+  public Path getPath() {\n+    return null;\n+  }\n+\n+  @Override\n+  public long getCompactionBound() {\n+    return index;\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return id;\n+  }\n+\n+  private String byteBufferToString(final ByteBuffer buf) {\n+    final var view = new UnsafeBuffer(buf);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f7ec170282b71f2528e586a6e32c49476500bb8"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIyNzkwMA==", "bodyText": "Why is this called active? I assume because you can actively create a snapshot ? :D", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479227900", "createdAt": "2020-08-28T12:25:11Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -89,7 +89,7 @@\n   private LogStream logStream;\n   private Role raftRole;\n   private SnapshotReplication stateReplication;\n-  private PersistedSnapshotStore persistedSnapshotStore;\n+  private final ActivePersistedSnapshotStore persistedSnapshotStore;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e18ceedb01ec29e99d2ca819e1e17565a891c59"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzMTA1Ng==", "bodyText": "Why we not using the interface?", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479231056", "createdAt": "2020-08-28T12:27:48Z", "author": {"login": "Zelldon"}, "path": "broker/src/test/java/io/zeebe/broker/system/partitions/AsyncSnapshotingTest.java", "diffHunk": "@@ -63,13 +63,14 @@\n   private AsyncSnapshotDirector asyncSnapshotDirector;\n   private StreamProcessor mockStreamProcessor;\n   private List<ActorCondition> conditionList;\n-  private PersistedSnapshotStore persistedSnapshotStore;\n+  private FileBasedSnapshotStore persistedSnapshotStore;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e18ceedb01ec29e99d2ca819e1e17565a891c59"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzMjM5OQ==", "bodyText": "I assume this is not intended", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479232399", "createdAt": "2020-08-28T12:28:57Z", "author": {"login": "Zelldon"}, "path": "logstreams/pom.xml", "diffHunk": "@@ -86,6 +91,11 @@\n       <groupId>io.zeebe</groupId>\n       <artifactId>atomix-cluster</artifactId>\n     </dependency>\n+    <dependency>\n+      <groupId>io.zeebe</groupId>\n+      <artifactId>atomix-utils</artifactId>\n+      <version>0.25.0-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e18ceedb01ec29e99d2ca819e1e17565a891c59"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzMjcwNQ==", "bodyText": "Do we still need to snapshot classes here?", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479232705", "createdAt": "2020-08-28T12:29:12Z", "author": {"login": "Zelldon"}, "path": "logstreams/pom.xml", "diffHunk": "@@ -73,6 +73,11 @@\n       <artifactId>atomix-storage</artifactId>\n     </dependency>\n \n+    <dependency>\n+      <groupId>io.zeebe</groupId>\n+      <artifactId>zeebe-snapshots</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e18ceedb01ec29e99d2ca819e1e17565a891c59"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzMzUyOQ==", "bodyText": "Why we are not using the interface?", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479233529", "createdAt": "2020-08-28T12:29:54Z", "author": {"login": "Zelldon"}, "path": "logstreams/src/test/java/io/zeebe/logstreams/util/AtomixLogStorageRule.java", "diffHunk": "@@ -51,13 +51,13 @@\n   private ZeebeIndexAdapter indexMapping;\n   private RaftStorage raftStorage;\n   private RaftLog raftLog;\n-  private PersistedSnapshotStore persistedSnapshotStore;\n+  private NoopSnapshotStore persistedSnapshotStore;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e18ceedb01ec29e99d2ca819e1e17565a891c59"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzODY3NQ==", "bodyText": "Active sounds a bit odd to me. Maybe WritableSnapshotStore or PersistableSnapshotStore", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479238675", "createdAt": "2020-08-28T12:34:10Z", "author": {"login": "Zelldon"}, "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/ActivePersistedSnapshotStore.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.snapshots.broker;\n+\n+import io.zeebe.snapshots.raft.PersistedSnapshotStore;\n+import io.zeebe.snapshots.raft.TransientSnapshot;\n+import java.util.Optional;\n+\n+/** A persisted snapshot store than can create a new snapshot and persists it. */\n+public interface ActivePersistedSnapshotStore extends PersistedSnapshotStore {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e18ceedb01ec29e99d2ca819e1e17565a891c59"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIzOTgyMA==", "bodyText": "Maybe we implemented here a fallback to accept also old snapshot id's?", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479239820", "createdAt": "2020-08-28T12:35:06Z", "author": {"login": "Zelldon"}, "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedReceivedSnapshot.java", "diffHunk": "@@ -171,8 +163,11 @@ private boolean isTotalCountInvalid(final int currentTotalCount) {\n   }\n \n   private boolean isSnapshotIdInvalid(final String snapshotId) {\n-    final var expectedSnapshotId = metadata.getSnapshotIdAsString();\n-    return !expectedSnapshotId.equals(snapshotId);\n+    final var receivedSnapshotId = FileBasedSnapshotMetadata.ofFileName(snapshotId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e18ceedb01ec29e99d2ca819e1e17565a891c59"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0MTQ1Mg==", "bodyText": "Ah cool so we can already receive old snapshots.", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479241452", "createdAt": "2020-08-28T12:36:30Z", "author": {"login": "Zelldon"}, "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotMetadata.java", "diffHunk": "@@ -42,15 +53,34 @@\n         final var index = Long.parseLong(parts[0]);\n         final var term = Long.parseLong(parts[1]);\n         final var timestamp = Long.parseLong(parts[2]);\n+        final var processedPosition = Long.parseLong(parts[3]);\n+        final var exporterPosition = Long.parseLong(parts[4]);\n \n         metadata =\n             Optional.of(\n-                new FileBasedSnapshotMetadata(index, term, WallClockTimestamp.from(timestamp)));\n+                new FileBasedSnapshotMetadata(\n+                    index,\n+                    term,\n+                    WallClockTimestamp.from(timestamp),\n+                    processedPosition,\n+                    exporterPosition));\n       } catch (final NumberFormatException e) {\n         LOGGER.warn(\"Failed to parse part of snapshot metadata\", e);\n       }\n-    }\n+    } else if (parts.length >= METADATA_PARTS_OLD_VERSION) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e18ceedb01ec29e99d2ca819e1e17565a891c59"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0Mzg4Nw==", "bodyText": "Is the timestamp also used? Can this ever happen then ? \ud83d\ude05", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479243887", "createdAt": "2020-08-28T12:38:30Z", "author": {"login": "Zelldon"}, "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStore.java", "diffHunk": "@@ -180,6 +164,28 @@ public void delete() {\n     }\n   }\n \n+  @Override\n+  public Optional<TransientSnapshot> newTransientSnapshot(\n+      final long index,\n+      final long term,\n+      final long processedPosition,\n+      final long exportedPosition) {\n+\n+    final WallClockTimestamp timestamp = WallClockTimestamp.from(System.currentTimeMillis());\n+    final var newSnapshotId =\n+        new FileBasedSnapshotMetadata(index, term, timestamp, processedPosition, exportedPosition);\n+    final FileBasedSnapshot currentSnapshot = currentPersistedSnapshotRef.get();\n+    if (currentSnapshot != null && currentSnapshot.getMetadata().compareTo(newSnapshotId) == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e18ceedb01ec29e99d2ca819e1e17565a891c59"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0NzQyMg==", "bodyText": "Please always try to return the interfaces", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479247422", "createdAt": "2020-08-28T12:41:27Z", "author": {"login": "Zelldon"}, "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStoreFactory.java", "diffHunk": "@@ -43,7 +38,14 @@ public PersistedSnapshotStore createSnapshotStore(final Path root, final String\n     IoUtil.ensureDirectoryExists(snapshotDirectory.toFile(), \"Snapshot directory\");\n     IoUtil.ensureDirectoryExists(pendingDirectory.toFile(), \"Pending snapshot directory\");\n \n-    return new FileBasedSnapshotStore(\n-        new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory);\n+    return partitionSnapshotStores.computeIfAbsent(\n+        partitionName,\n+        p ->\n+            new FileBasedSnapshotStore(\n+                new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory));\n+  }\n+\n+  public FileBasedSnapshotStore getSnapshotStore(final String partitionName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e18ceedb01ec29e99d2ca819e1e17565a891c59"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0ODY5NQ==", "bodyText": "Why was this necessary? To get the same store in the ZeebePartition as in the journal?", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479248695", "createdAt": "2020-08-28T12:42:39Z", "author": {"login": "Zelldon"}, "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStoreFactory.java", "diffHunk": "@@ -43,7 +38,14 @@ public PersistedSnapshotStore createSnapshotStore(final Path root, final String\n     IoUtil.ensureDirectoryExists(snapshotDirectory.toFile(), \"Snapshot directory\");\n     IoUtil.ensureDirectoryExists(pendingDirectory.toFile(), \"Pending snapshot directory\");\n \n-    return new FileBasedSnapshotStore(\n-        new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory);\n+    return partitionSnapshotStores.computeIfAbsent(\n+        partitionName,\n+        p ->\n+            new FileBasedSnapshotStore(\n+                new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory));\n+  }\n+\n+  public FileBasedSnapshotStore getSnapshotStore(final String partitionName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0NzQyMg=="}, "originalCommit": {"oid": "5e18ceedb01ec29e99d2ca819e1e17565a891c59"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0OTUwMg==", "bodyText": "Is is problematic if we never really recreate the store when we had a leader change?", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479249502", "createdAt": "2020-08-28T12:43:37Z", "author": {"login": "Zelldon"}, "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStoreFactory.java", "diffHunk": "@@ -43,7 +38,14 @@ public PersistedSnapshotStore createSnapshotStore(final Path root, final String\n     IoUtil.ensureDirectoryExists(snapshotDirectory.toFile(), \"Snapshot directory\");\n     IoUtil.ensureDirectoryExists(pendingDirectory.toFile(), \"Pending snapshot directory\");\n \n-    return new FileBasedSnapshotStore(\n-        new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory);\n+    return partitionSnapshotStores.computeIfAbsent(\n+        partitionName,\n+        p ->\n+            new FileBasedSnapshotStore(\n+                new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory));\n+  }\n+\n+  public FileBasedSnapshotStore getSnapshotStore(final String partitionName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI0NzQyMg=="}, "originalCommit": {"oid": "5e18ceedb01ec29e99d2ca819e1e17565a891c59"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI1MjQ5OA==", "bodyText": "I thought we want to have two factory methods in this factory one to create a store which can receive chunks and one which can be used to take snapshots?", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479252498", "createdAt": "2020-08-28T12:47:07Z", "author": {"login": "Zelldon"}, "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/impl/FileBasedSnapshotStoreFactory.java", "diffHunk": "@@ -43,7 +38,14 @@ public PersistedSnapshotStore createSnapshotStore(final Path root, final String\n     IoUtil.ensureDirectoryExists(snapshotDirectory.toFile(), \"Snapshot directory\");\n     IoUtil.ensureDirectoryExists(pendingDirectory.toFile(), \"Pending snapshot directory\");\n \n-    return new FileBasedSnapshotStore(\n-        new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory);\n+    return partitionSnapshotStores.computeIfAbsent(\n+        partitionName,\n+        p ->\n+            new FileBasedSnapshotStore(\n+                new SnapshotMetrics(partitionName), snapshotDirectory, pendingDirectory));\n+  }\n+\n+  public FileBasedSnapshotStore getSnapshotStore(final String partitionName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e18ceedb01ec29e99d2ca819e1e17565a891c59"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI1MzI0NQ==", "bodyText": "We we need to cast this everywhere ?", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479253245", "createdAt": "2020-08-28T12:48:00Z", "author": {"login": "Zelldon"}, "path": "snapshot/src/test/java/io/zeebe/snapshots/broker/impl/FileBasedReceivedSnapshotTest.java", "diffHunk": "@@ -50,22 +37,26 @@\n public class FileBasedReceivedSnapshotTest {\n \n   @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-  private PersistedSnapshotStore senderSnapshotStore;\n-  private PersistedSnapshotStore receiverSnapshotStore;\n+  private FileBasedSnapshotStore senderSnapshotStore;\n+  private FileBasedSnapshotStore receiverSnapshotStore;\n   private Path receiverSnapshotsDir;\n   private Path receiverPendingSnapshotsDir;\n-  private FileBasedSnapshotStoreFactory factory;\n \n   @Before\n   public void before() throws Exception {\n-    factory = new FileBasedSnapshotStoreFactory();\n     final String partitionName = \"1\";\n     final File senderRoot = temporaryFolder.newFolder(\"sender\");\n \n-    senderSnapshotStore = factory.createSnapshotStore(senderRoot.toPath(), partitionName);\n+    senderSnapshotStore =\n+        (FileBasedSnapshotStore)\n+            new FileBasedSnapshotStoreFactory()\n+                .createSnapshotStore(senderRoot.toPath(), partitionName);\n \n     final var receiverRoot = temporaryFolder.newFolder(\"received\");\n-    receiverSnapshotStore = factory.createSnapshotStore(receiverRoot.toPath(), partitionName);\n+    receiverSnapshotStore =\n+        (FileBasedSnapshotStore)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e18ceedb01ec29e99d2ca819e1e17565a891c59"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI1NDA2NA==", "bodyText": "i would expect that we still can use the interfaces otherwise we did something wrong in our api", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r479254064", "createdAt": "2020-08-28T12:49:00Z", "author": {"login": "Zelldon"}, "path": "snapshot/src/test/java/io/zeebe/snapshots/broker/impl/FileBasedTransientSnapshotTest.java", "diffHunk": "@@ -40,7 +30,7 @@\n public class FileBasedTransientSnapshotTest {\n \n   @Rule public TemporaryFolder temporaryFolder = new TemporaryFolder();\n-  private PersistedSnapshotStore persistedSnapshotStore;\n+  private FileBasedSnapshotStore persistedSnapshotStore;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e18ceedb01ec29e99d2ca819e1e17565a891c59"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4NTY5ODUx", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#pullrequestreview-478569851", "createdAt": "2020-08-31T12:27:36Z", "commit": {"oid": "cfad20ed0e36d403c5771f3209f1b52ef5e06713"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMjoyNzozNlrOHJ2u4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxMjozMjoxM1rOHJ24Uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5NTk3MA==", "bodyText": "could we rename it to supplier? Or just use the supplier once to get the store?", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480095970", "createdAt": "2020-08-31T12:27:36Z", "author": {"login": "Zelldon"}, "path": "broker/src/main/java/io/zeebe/broker/system/partitions/ZeebePartition.java", "diffHunk": "@@ -113,13 +113,13 @@ public ZeebePartition(\n       final BrokerCfg brokerCfg,\n       final CommandApiService commandApiService,\n       final ZeebeIndexMapping zeebeIndexMapping,\n-      final ActivePersistedSnapshotStore persistedSnapshotStore,\n+      final SnapshotStoreSupplier snapshotStoreFactory,\n       final TypedRecordProcessorsFactory typedRecordProcessorsFactory) {\n     this.localBroker = localBroker;\n     this.atomixRaftPartition = atomixRaftPartition;\n     this.messagingService = messagingService;\n     this.brokerCfg = brokerCfg;\n-    this.persistedSnapshotStore = persistedSnapshotStore;\n+    this.snapshotStoreFactory = snapshotStoreFactory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfad20ed0e36d403c5771f3209f1b52ef5e06713"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODE0Mg==", "bodyText": "Would be cool if we can adjust the docs then", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480098142", "createdAt": "2020-08-31T12:31:45Z", "author": {"login": "Zelldon"}, "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/ConstructableSnapshotStore.java", "diffHunk": "@@ -12,7 +12,7 @@\n import java.util.Optional;\n \n /** A persisted snapshot store than can create a new snapshot and persists it. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfad20ed0e36d403c5771f3209f1b52ef5e06713"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA5ODM4Nw==", "bodyText": "Do we need that?", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#discussion_r480098387", "createdAt": "2020-08-31T12:32:13Z", "author": {"login": "Zelldon"}, "path": "snapshot/src/main/java/io/zeebe/snapshots/broker/SnapshotStoreSupplier.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright Camunda Services GmbH and/or licensed to Camunda Services GmbH under\n+ * one or more contributor license agreements. See the NOTICE file distributed\n+ * with this work for additional information regarding copyright ownership.\n+ * Licensed under the Zeebe Community License 1.0. You may not use this file\n+ * except in compliance with the Zeebe Community License 1.0.\n+ */\n+package io.zeebe.snapshots.broker;\n+\n+import io.zeebe.snapshots.raft.PersistedSnapshotStore;\n+import io.zeebe.snapshots.raft.ReceivableSnapshotStore;\n+\n+public interface SnapshotStoreSupplier {\n+\n+  /**\n+   * Returns a partition's {@link ConstructableSnapshotStore}\n+   *\n+   * @param partitionName\n+   * @return a ConstructableSnapshotStore\n+   */\n+  ConstructableSnapshotStore getConstructableSnapshotStore(String partitionName);\n+\n+  /**\n+   * Returns a partition's {@link ReceivableSnapshotStore}\n+   *\n+   * @param partitionName\n+   * @return a ReceivableSnapshotStore\n+   */\n+  ReceivableSnapshotStore getReceivableSnapshotStore(final String partitionName);\n+\n+  /**\n+   * Returns a partition's {@link PersistedSnapshotStore}\n+   *\n+   * @param partitionName\n+   * @return a ConstructableSnapshotStore\n+   */\n+  PersistedSnapshotStore getPersistedSnapshotStore(String partitionName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cfad20ed0e36d403c5771f3209f1b52ef5e06713"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4NzYzODIz", "url": "https://github.com/camunda-cloud/zeebe/pull/5255#pullrequestreview-478763823", "createdAt": "2020-08-31T16:30:31Z", "commit": {"oid": "9de34fcce6c90ac8d7e063c74c5a7d1a440d3ea7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "218e93b1d671776c2143a8fc2a37b499017e2b12", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/218e93b1d671776c2143a8fc2a37b499017e2b12", "committedDate": "2020-09-01T08:20:51Z", "message": "chore(atomix): use mock implementation of snapshot store in tests\nThis is in preparation for refactoring snapshot implementations and moving the concrete implementation out of atomix."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8609cfca1a9e15d87704684f5f7444f41497a84f", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/8609cfca1a9e15d87704684f5f7444f41497a84f", "committedDate": "2020-09-01T08:20:52Z", "message": "chore(atomix): remove snapshot listener when closing a role"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a6bf99473aad6c331bc94a0735c843b6a711885", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/1a6bf99473aad6c331bc94a0735c843b6a711885", "committedDate": "2020-09-01T08:20:52Z", "message": "chore(broker): use exporter and processor positions in snapshot id\n* move snapshot interfaces and clases to new module\n* take snapshot at same index if either exporter or processor position is changed\n* snapshot is uniquely identified by index,term,processedposition,exporterposition"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9de34fcce6c90ac8d7e063c74c5a7d1a440d3ea7", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/9de34fcce6c90ac8d7e063c74c5a7d1a440d3ea7", "committedDate": "2020-08-31T14:22:44Z", "message": "chore(snapshots): fix doc"}, "afterCommit": {"oid": "1a6bf99473aad6c331bc94a0735c843b6a711885", "author": {"user": {"login": "deepthidevaki", "name": "Deepthi Devaki Akkoorath"}}, "url": "https://github.com/camunda-cloud/zeebe/commit/1a6bf99473aad6c331bc94a0735c843b6a711885", "committedDate": "2020-09-01T08:20:52Z", "message": "chore(broker): use exporter and processor positions in snapshot id\n* move snapshot interfaces and clases to new module\n* take snapshot at same index if either exporter or processor position is changed\n* snapshot is uniquely identified by index,term,processedposition,exporterposition"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2574, "cost": 1, "resetAt": "2021-11-01T13:07:16Z"}}}