{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4NTQ2MTM3", "number": 4531, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNToyOTo0N1rOD9ceyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjozMDoxNFrOD9p3oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzU2MzYxOnYy", "diffSide": "RIGHT", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNToyOTo0N1rOGW8aTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNTo1Mjo0MFrOGXQyYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxMTYzMA==", "bodyText": "Nit: snapshot is a verb, so just say shouldSnapshot ;)", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#discussion_r426711630", "createdAt": "2020-05-18T15:29:47Z", "author": {"login": "npepinpe"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -118,19 +117,97 @@ public void shouldRecoverLeaderRestart() throws Throwable {\n   }\n \n   @Test\n-  @Ignore(\"https://github.com/zeebe-io/zeebe/issues/4467\")\n-  public void testNodeCatchUpAfterCompaction() throws Exception {\n+  public void shouldDoSnapshot() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NTQ3Mw==", "bodyText": "hm, but normally we say 'take a snapshot' right?", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#discussion_r427045473", "createdAt": "2020-05-19T05:52:40Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -118,19 +117,97 @@ public void shouldRecoverLeaderRestart() throws Throwable {\n   }\n \n   @Test\n-  @Ignore(\"https://github.com/zeebe-io/zeebe/issues/4467\")\n-  public void testNodeCatchUpAfterCompaction() throws Exception {\n+  public void shouldDoSnapshot() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcxMTYzMA=="}, "originalCommit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTcyMTg2OnYy", "diffSide": "RIGHT", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjoxNjoxMlrOGXRSJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwNzozMjoyNFrOGX-wsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MzYwNA==", "bodyText": "Isn't this testing the test setup rather than real implementation. Compaction is triggered by RaftRule.RaftSnapshotListener.", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#discussion_r427053604", "createdAt": "2020-05-19T06:16:12Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -118,19 +117,97 @@ public void shouldRecoverLeaderRestart() throws Throwable {\n   }\n \n   @Test\n-  @Ignore(\"https://github.com/zeebe-io/zeebe/issues/4467\")\n-  public void testNodeCatchUpAfterCompaction() throws Exception {\n+  public void shouldDoSnapshot() throws Exception {\n     // given\n-    raftRule.shutdownServer(\"1\");\n+    raftRule.appendEntries(128);\n+\n+    // when\n+    raftRule.doSnapshot(100);\n+\n+    // then\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(100)).isTrue();\n+  }\n+\n+  @Test\n+  public void shouldCompactLogOnSnapshot() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3OTU0OQ==", "bodyText": "I think you're totally right. But actually I would like to keep it, to make sure our test suite works also as expected. I could move it in a separate class called something like RaftRuleTest ? What do you think @deepthidevaki ?", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#discussion_r427179549", "createdAt": "2020-05-19T09:58:35Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -118,19 +117,97 @@ public void shouldRecoverLeaderRestart() throws Throwable {\n   }\n \n   @Test\n-  @Ignore(\"https://github.com/zeebe-io/zeebe/issues/4467\")\n-  public void testNodeCatchUpAfterCompaction() throws Exception {\n+  public void shouldDoSnapshot() throws Exception {\n     // given\n-    raftRule.shutdownServer(\"1\");\n+    raftRule.appendEntries(128);\n+\n+    // when\n+    raftRule.doSnapshot(100);\n+\n+    // then\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(100)).isTrue();\n+  }\n+\n+  @Test\n+  public void shouldCompactLogOnSnapshot() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MzYwNA=="}, "originalCommit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI4OTQxMw==", "bodyText": "Do you really have to have the compaction logic in RaftRule? Isn't it used only in this test?", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#discussion_r427289413", "createdAt": "2020-05-19T13:11:07Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -118,19 +117,97 @@ public void shouldRecoverLeaderRestart() throws Throwable {\n   }\n \n   @Test\n-  @Ignore(\"https://github.com/zeebe-io/zeebe/issues/4467\")\n-  public void testNodeCatchUpAfterCompaction() throws Exception {\n+  public void shouldDoSnapshot() throws Exception {\n     // given\n-    raftRule.shutdownServer(\"1\");\n+    raftRule.appendEntries(128);\n+\n+    // when\n+    raftRule.doSnapshot(100);\n+\n+    // then\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(100)).isTrue();\n+  }\n+\n+  @Test\n+  public void shouldCompactLogOnSnapshot() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MzYwNA=="}, "originalCommit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMzMTc3MQ==", "bodyText": "Yes because with that I can test our bug we had, easily. Also other more complex scenarios", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#discussion_r427331771", "createdAt": "2020-05-19T14:10:19Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -118,19 +117,97 @@ public void shouldRecoverLeaderRestart() throws Throwable {\n   }\n \n   @Test\n-  @Ignore(\"https://github.com/zeebe-io/zeebe/issues/4467\")\n-  public void testNodeCatchUpAfterCompaction() throws Exception {\n+  public void shouldDoSnapshot() throws Exception {\n     // given\n-    raftRule.shutdownServer(\"1\");\n+    raftRule.appendEntries(128);\n+\n+    // when\n+    raftRule.doSnapshot(100);\n+\n+    // then\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(100)).isTrue();\n+  }\n+\n+  @Test\n+  public void shouldCompactLogOnSnapshot() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MzYwNA=="}, "originalCommit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc5NDA0Mw==", "bodyText": "Without this logic I wouldn't be able to test like shouldReplicateSnapshotOnJoin or shouldTakeMultipleSnapshotsAndReplicateSnapshotAfterRestart and also not what you mentioned below.", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#discussion_r427794043", "createdAt": "2020-05-20T07:23:27Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -118,19 +117,97 @@ public void shouldRecoverLeaderRestart() throws Throwable {\n   }\n \n   @Test\n-  @Ignore(\"https://github.com/zeebe-io/zeebe/issues/4467\")\n-  public void testNodeCatchUpAfterCompaction() throws Exception {\n+  public void shouldDoSnapshot() throws Exception {\n     // given\n-    raftRule.shutdownServer(\"1\");\n+    raftRule.appendEntries(128);\n+\n+    // when\n+    raftRule.doSnapshot(100);\n+\n+    // then\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(100)).isTrue();\n+  }\n+\n+  @Test\n+  public void shouldCompactLogOnSnapshot() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MzYwNA=="}, "originalCommit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc5ODcwNQ==", "bodyText": "Ok", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#discussion_r427798705", "createdAt": "2020-05-20T07:32:24Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -118,19 +117,97 @@ public void shouldRecoverLeaderRestart() throws Throwable {\n   }\n \n   @Test\n-  @Ignore(\"https://github.com/zeebe-io/zeebe/issues/4467\")\n-  public void testNodeCatchUpAfterCompaction() throws Exception {\n+  public void shouldDoSnapshot() throws Exception {\n     // given\n-    raftRule.shutdownServer(\"1\");\n+    raftRule.appendEntries(128);\n+\n+    // when\n+    raftRule.doSnapshot(100);\n+\n+    // then\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(100)).isTrue();\n+  }\n+\n+  @Test\n+  public void shouldCompactLogOnSnapshot() throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MzYwNA=="}, "originalCommit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTc0MDQ1OnYy", "diffSide": "RIGHT", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjoyMzozOVrOGXRdHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwNzozNToxOVrOGX-2hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1NjQxNQ==", "bodyText": "In addition to this, another test that would be interesting is to restart follower with data loss. Can you add it?", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#discussion_r427056415", "createdAt": "2020-05-19T06:23:39Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -118,19 +117,97 @@ public void shouldRecoverLeaderRestart() throws Throwable {\n   }\n \n   @Test\n-  @Ignore(\"https://github.com/zeebe-io/zeebe/issues/4467\")\n-  public void testNodeCatchUpAfterCompaction() throws Exception {\n+  public void shouldDoSnapshot() throws Exception {\n     // given\n-    raftRule.shutdownServer(\"1\");\n+    raftRule.appendEntries(128);\n+\n+    // when\n+    raftRule.doSnapshot(100);\n+\n+    // then\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(100)).isTrue();\n+  }\n+\n+  @Test\n+  public void shouldCompactLogOnSnapshot() throws Exception {\n+    // given\n+    raftRule.appendEntries(128);\n+    final var memberLogs = raftRule.getMemberLogs();\n+\n+    // when\n+    raftRule.doSnapshot(100);\n+\n+    // then\n+    final var compactedLogs = raftRule.getMemberLogs();\n+\n+    assertThat(compactedLogs.isEmpty()).isFalse();\n+    for (final String raftMember : compactedLogs.keySet()) {\n+      final var compactedLog = compactedLogs.get(raftMember);\n+      final var previousLog = memberLogs.get(raftMember);\n+      assertThat(compactedLog.size()).isLessThan(previousLog.size());\n+      assertThat(compactedLog).isSubsetOf(previousLog);\n+    }\n+  }\n+\n+  @Test\n+  public void shouldReplicateSnapshotOnJoin() throws Exception {\n+    // given\n+    final var follower = raftRule.shutdownFollower();\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(100);\n+\n+    // when\n+    raftRule.startNode(follower);\n+\n+    // then\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(100)).isTrue();\n+    final var snapshot = raftRule.snapshotOnNode(follower);\n+\n+    assertThat(snapshot.index()).isEqualTo(100);\n+    assertThat(snapshot.term()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void shouldTakeMultipleSnapshotAndReplicateSnapshotAfterRestart() throws Exception {\n+    // given\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(100);\n+    final var follower = raftRule.shutdownFollower();\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(200);\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(300);\n+\n+    // when\n+    raftRule.startNode(follower);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3OTY3OA==", "bodyText": "Of course!", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#discussion_r427179678", "createdAt": "2020-05-19T09:58:47Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -118,19 +117,97 @@ public void shouldRecoverLeaderRestart() throws Throwable {\n   }\n \n   @Test\n-  @Ignore(\"https://github.com/zeebe-io/zeebe/issues/4467\")\n-  public void testNodeCatchUpAfterCompaction() throws Exception {\n+  public void shouldDoSnapshot() throws Exception {\n     // given\n-    raftRule.shutdownServer(\"1\");\n+    raftRule.appendEntries(128);\n+\n+    // when\n+    raftRule.doSnapshot(100);\n+\n+    // then\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(100)).isTrue();\n+  }\n+\n+  @Test\n+  public void shouldCompactLogOnSnapshot() throws Exception {\n+    // given\n+    raftRule.appendEntries(128);\n+    final var memberLogs = raftRule.getMemberLogs();\n+\n+    // when\n+    raftRule.doSnapshot(100);\n+\n+    // then\n+    final var compactedLogs = raftRule.getMemberLogs();\n+\n+    assertThat(compactedLogs.isEmpty()).isFalse();\n+    for (final String raftMember : compactedLogs.keySet()) {\n+      final var compactedLog = compactedLogs.get(raftMember);\n+      final var previousLog = memberLogs.get(raftMember);\n+      assertThat(compactedLog.size()).isLessThan(previousLog.size());\n+      assertThat(compactedLog).isSubsetOf(previousLog);\n+    }\n+  }\n+\n+  @Test\n+  public void shouldReplicateSnapshotOnJoin() throws Exception {\n+    // given\n+    final var follower = raftRule.shutdownFollower();\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(100);\n+\n+    // when\n+    raftRule.startNode(follower);\n+\n+    // then\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(100)).isTrue();\n+    final var snapshot = raftRule.snapshotOnNode(follower);\n+\n+    assertThat(snapshot.index()).isEqualTo(100);\n+    assertThat(snapshot.term()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void shouldTakeMultipleSnapshotAndReplicateSnapshotAfterRestart() throws Exception {\n+    // given\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(100);\n+    final var follower = raftRule.shutdownFollower();\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(200);\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(300);\n+\n+    // when\n+    raftRule.startNode(follower);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1NjQxNQ=="}, "originalCommit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc5NDg1NA==", "bodyText": "btw this should be similar to shouldReplicateSnapshotOnJoin", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#discussion_r427794854", "createdAt": "2020-05-20T07:25:02Z", "author": {"login": "Zelldon"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -118,19 +117,97 @@ public void shouldRecoverLeaderRestart() throws Throwable {\n   }\n \n   @Test\n-  @Ignore(\"https://github.com/zeebe-io/zeebe/issues/4467\")\n-  public void testNodeCatchUpAfterCompaction() throws Exception {\n+  public void shouldDoSnapshot() throws Exception {\n     // given\n-    raftRule.shutdownServer(\"1\");\n+    raftRule.appendEntries(128);\n+\n+    // when\n+    raftRule.doSnapshot(100);\n+\n+    // then\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(100)).isTrue();\n+  }\n+\n+  @Test\n+  public void shouldCompactLogOnSnapshot() throws Exception {\n+    // given\n+    raftRule.appendEntries(128);\n+    final var memberLogs = raftRule.getMemberLogs();\n+\n+    // when\n+    raftRule.doSnapshot(100);\n+\n+    // then\n+    final var compactedLogs = raftRule.getMemberLogs();\n+\n+    assertThat(compactedLogs.isEmpty()).isFalse();\n+    for (final String raftMember : compactedLogs.keySet()) {\n+      final var compactedLog = compactedLogs.get(raftMember);\n+      final var previousLog = memberLogs.get(raftMember);\n+      assertThat(compactedLog.size()).isLessThan(previousLog.size());\n+      assertThat(compactedLog).isSubsetOf(previousLog);\n+    }\n+  }\n+\n+  @Test\n+  public void shouldReplicateSnapshotOnJoin() throws Exception {\n+    // given\n+    final var follower = raftRule.shutdownFollower();\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(100);\n+\n+    // when\n+    raftRule.startNode(follower);\n+\n+    // then\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(100)).isTrue();\n+    final var snapshot = raftRule.snapshotOnNode(follower);\n+\n+    assertThat(snapshot.index()).isEqualTo(100);\n+    assertThat(snapshot.term()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void shouldTakeMultipleSnapshotAndReplicateSnapshotAfterRestart() throws Exception {\n+    // given\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(100);\n+    final var follower = raftRule.shutdownFollower();\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(200);\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(300);\n+\n+    // when\n+    raftRule.startNode(follower);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1NjQxNQ=="}, "originalCommit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgwMDE5Nw==", "bodyText": "It is different. When follower restarts with data loss, leader thinks that it has already send those events to the follower. There was a bug before - something like leader doesn't send the snapshot again if the follower restarts with data loss.", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#discussion_r427800197", "createdAt": "2020-05-20T07:35:19Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftFailOverTest.java", "diffHunk": "@@ -118,19 +117,97 @@ public void shouldRecoverLeaderRestart() throws Throwable {\n   }\n \n   @Test\n-  @Ignore(\"https://github.com/zeebe-io/zeebe/issues/4467\")\n-  public void testNodeCatchUpAfterCompaction() throws Exception {\n+  public void shouldDoSnapshot() throws Exception {\n     // given\n-    raftRule.shutdownServer(\"1\");\n+    raftRule.appendEntries(128);\n+\n+    // when\n+    raftRule.doSnapshot(100);\n+\n+    // then\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(100)).isTrue();\n+  }\n+\n+  @Test\n+  public void shouldCompactLogOnSnapshot() throws Exception {\n+    // given\n+    raftRule.appendEntries(128);\n+    final var memberLogs = raftRule.getMemberLogs();\n+\n+    // when\n+    raftRule.doSnapshot(100);\n+\n+    // then\n+    final var compactedLogs = raftRule.getMemberLogs();\n+\n+    assertThat(compactedLogs.isEmpty()).isFalse();\n+    for (final String raftMember : compactedLogs.keySet()) {\n+      final var compactedLog = compactedLogs.get(raftMember);\n+      final var previousLog = memberLogs.get(raftMember);\n+      assertThat(compactedLog.size()).isLessThan(previousLog.size());\n+      assertThat(compactedLog).isSubsetOf(previousLog);\n+    }\n+  }\n+\n+  @Test\n+  public void shouldReplicateSnapshotOnJoin() throws Exception {\n+    // given\n+    final var follower = raftRule.shutdownFollower();\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(100);\n+\n+    // when\n+    raftRule.startNode(follower);\n+\n+    // then\n+    assertThat(raftRule.allNodesHaveSnapshotWithIndex(100)).isTrue();\n+    final var snapshot = raftRule.snapshotOnNode(follower);\n+\n+    assertThat(snapshot.index()).isEqualTo(100);\n+    assertThat(snapshot.term()).isEqualTo(1);\n+  }\n+\n+  @Test\n+  public void shouldTakeMultipleSnapshotAndReplicateSnapshotAfterRestart() throws Exception {\n+    // given\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(100);\n+    final var follower = raftRule.shutdownFollower();\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(200);\n+    raftRule.appendEntries(128);\n+    raftRule.doSnapshot(300);\n+\n+    // when\n+    raftRule.startNode(follower);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1NjQxNQ=="}, "originalCommit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1OTc1NzEzOnYy", "diffSide": "RIGHT", "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjozMDoxNFrOGXRnaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQwNjozMDoxNFrOGXRnaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1OTA1MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public Snapshot snapshotOnNode(final String nodeId) {\n          \n          \n            \n              public Snapshot getSnapshotOnNode(final String nodeId) {", "url": "https://github.com/camunda-cloud/zeebe/pull/4531#discussion_r427059051", "createdAt": "2020-05-19T06:30:14Z", "author": {"login": "deepthidevaki"}, "path": "atomix/cluster/src/test/java/io/atomix/raft/RaftRule.java", "diffHunk": "@@ -179,90 +187,119 @@ private MemberId nextNodeId() {\n           .thenAccept(this::addCommitListener)\n           .thenRun(latch::countDown);\n       servers.add(server);\n+      compactAwaiters.put(server.name(), new AtomicReference<>());\n     }\n \n     latch.await(30, TimeUnit.SECONDS);\n \n     return servers;\n   }\n \n-  public void shutdownFollower() throws Exception {\n+  public String shutdownFollower() throws Exception {\n     final var follower = getFollower().orElseThrow();\n     shutdownServer(follower);\n+    return follower.name();\n   }\n \n-  public RaftServer shutdownLeader() throws Exception {\n+  public void startNode(final String nodeId) throws Exception {\n+    final RaftMember member = getRaftMember(nodeId);\n+    createServer(member.memberId())\n+        .join(getMemberIds())\n+        .thenAccept(this::addCommitListener)\n+        .get(30, TimeUnit.SECONDS);\n+  }\n+\n+  public String shutdownLeader() throws Exception {\n     final var leader = getLeader().orElseThrow();\n     shutdownServer(leader);\n-    return leader;\n+    return leader.name();\n   }\n \n   public void restartLeader() throws Exception {\n     awaitNewLeader();\n     final var leader = shutdownLeader();\n-\n-    final RaftMember leaderMember = getRaftMember(leader.name());\n-    createServer(leaderMember.memberId())\n-        .join(getMemberIds())\n-        .thenAccept(this::addCommitListener)\n-        .get(30, TimeUnit.SECONDS);\n+    startNode(leader);\n   }\n \n   private List<MemberId> getMemberIds() {\n     return members.stream().map(RaftMember::memberId).collect(Collectors.toList());\n   }\n \n-  public void shutdownServer(final String memberId) throws Exception {\n-    final var raftServer = getRaftServer(memberId);\n-    shutdownServer(raftServer);\n-  }\n-\n-  private RaftServer getRaftServer(final String memberId) {\n-    return servers.stream()\n-        .filter(server -> server.name().equals(memberId))\n-        .findFirst()\n-        .orElseThrow();\n-  }\n-\n   public void shutdownServer(final RaftServer raftServer) throws Exception {\n     raftServer.shutdown().get(30, TimeUnit.SECONDS);\n-    servers.remove(raftServer);\n+    servers.remove(raftServer.name());\n+    compactAwaiters.remove(raftServer.name());\n     memberLog.remove(raftServer.name());\n   }\n \n-  public CompletableFuture<RaftServer> startServer(final String memberId) {\n-    final RaftMember raftMember = getRaftMember(memberId);\n-    final var server = createServer(raftMember.memberId());\n-    return server.join(getMemberIds());\n-  }\n-\n   private RaftMember getRaftMember(final String memberId) {\n     return members.stream()\n         .filter(member -> member.memberId().id().equals(memberId))\n         .findFirst()\n         .orElseThrow();\n   }\n \n-  public CompletableFuture<Void> tryToCompactLogsOnServersExcept(\n-      final String memberId, final long index) {\n+  public void doSnapshot(final long index) throws Exception {\n+    awaitNewLeader();\n+\n+    // we write on all nodes the same snapshot\n+    // this is similar to our current logic where leader takes a snapshot and replicates it\n+    // in the end all call the method #newSnapshot and the snapshot listener is triggered to compact\n \n-    final var servers =\n-        this.servers.stream()\n-            .filter(server -> !server.name().equals(memberId))\n-            .collect(Collectors.toList());\n+    for (final RaftServer raftServer : servers.values()) {\n+      if (raftServer.isRunning()) {\n+        final var raftContext = raftServer.getContext();\n+        final var snapshotStore = raftContext.getSnapshotStore();\n+\n+        compactAwaiters.get(raftServer.name()).set(new CountDownLatch(1));\n+        writeSnapshot(index, raftContext.getTerm(), snapshotStore);\n+      }\n+    }\n \n-    final List<CompletableFuture<Void>> futures = new ArrayList<>();\n-    for (final RaftServer server : servers) {\n-      futures.add(tryToCompactLogOnServer(server, index));\n+    // await the compaction to avoid race condition with reading the logs\n+    for (final RaftServer server : servers.values()) {\n+      final var latchAtomicReference = compactAwaiters.get(server.name());\n+      final var latch = latchAtomicReference.get();\n+      if (!latch.await(30, TimeUnit.SECONDS)) {\n+        throw new TimeoutException(\"Expected to compact the log after 30 seconds!\");\n+      }\n+      latchAtomicReference.set(null);\n     }\n+  }\n \n-    return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));\n+  public boolean allNodesHaveSnapshotWithIndex(final long index) {\n+    return servers.values().stream()\n+            .map(RaftServer::getContext)\n+            .map(RaftContext::getSnapshotStore)\n+            .map(SnapshotStore::getCurrentSnapshotIndex)\n+            .filter(idx -> idx == index)\n+            .count()\n+        == servers.values().size();\n   }\n \n-  private CompletableFuture<Void> tryToCompactLogOnServer(\n-      final RaftServer raftServer, final long index) {\n-    raftServer.getContext().getServiceManager().setCompactableIndex(index);\n-    return raftServer.compact();\n+  public Snapshot snapshotOnNode(final String nodeId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f13895fed1fae7e46d5b1a055cf8e7c01cf56a66"}, "originalPosition": 212}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 561, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}